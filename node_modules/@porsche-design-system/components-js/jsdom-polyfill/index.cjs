'use strict';

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var src = {};

var adoptedStyleSheets = {};

var hasRequiredAdoptedStyleSheets;

function requireAdoptedStyleSheets () {
	if (hasRequiredAdoptedStyleSheets) return adoptedStyleSheets;
	hasRequiredAdoptedStyleSheets = 1;
	(function () {

	    if (typeof document === 'undefined' || 'adoptedStyleSheets' in document) { return; }

	    var hasShadyCss = 'ShadyCSS' in window && !ShadyCSS.nativeShadow;
	    var bootstrapper = document.implementation.createHTMLDocument('');
	    var closedShadowRootRegistry = new WeakMap();
	    var _DOMException = typeof DOMException === 'object' ? Error : DOMException;
	    var defineProperty = Object.defineProperty;
	    var forEach = Array.prototype.forEach;

	    var importPattern = /@import.+?;?$/gm;
	    function rejectImports(contents) {
	        var _contents = contents.replace(importPattern, '');
	        if (_contents !== contents) {
	            console.warn('@import rules are not allowed here. See https://github.com/WICG/construct-stylesheets/issues/119#issuecomment-588352418');
	        }
	        return _contents.trim();
	    }
	    function isElementConnected(element) {
	        return 'isConnected' in element
	            ? element.isConnected
	            : document.contains(element);
	    }
	    function unique(arr) {
	        return arr.filter(function (value, index) { return arr.indexOf(value) === index; });
	    }
	    function diff(arr1, arr2) {
	        return arr1.filter(function (value) { return arr2.indexOf(value) === -1; });
	    }
	    function removeNode(node) {
	        node.parentNode.removeChild(node);
	    }
	    function getShadowRoot(element) {
	        return element.shadowRoot || closedShadowRootRegistry.get(element);
	    }

	    var cssStyleSheetMethods = [
	        'addRule',
	        'deleteRule',
	        'insertRule',
	        'removeRule',
	    ];
	    var NonConstructedStyleSheet = CSSStyleSheet;
	    var nonConstructedProto = NonConstructedStyleSheet.prototype;
	    nonConstructedProto.replace = function () {
	        return Promise.reject(new _DOMException("Can't call replace on non-constructed CSSStyleSheets."));
	    };
	    nonConstructedProto.replaceSync = function () {
	        throw new _DOMException("Failed to execute 'replaceSync' on 'CSSStyleSheet': Can't call replaceSync on non-constructed CSSStyleSheets.");
	    };
	    function isCSSStyleSheetInstance(instance) {
	        return typeof instance === 'object'
	            ? proto$1.isPrototypeOf(instance) ||
	                nonConstructedProto.isPrototypeOf(instance)
	            : false;
	    }
	    function isNonConstructedStyleSheetInstance(instance) {
	        return typeof instance === 'object'
	            ? nonConstructedProto.isPrototypeOf(instance)
	            : false;
	    }
	    var $basicStyleElement = new WeakMap();
	    var $locations = new WeakMap();
	    var $adoptersByLocation = new WeakMap();
	    var $appliedMethods = new WeakMap();
	    function addAdopterLocation(sheet, location) {
	        var adopter = document.createElement('style');
	        $adoptersByLocation.get(sheet).set(location, adopter);
	        $locations.get(sheet).push(location);
	        return adopter;
	    }
	    function getAdopterByLocation(sheet, location) {
	        return $adoptersByLocation.get(sheet).get(location);
	    }
	    function removeAdopterLocation(sheet, location) {
	        $adoptersByLocation.get(sheet).delete(location);
	        $locations.set(sheet, $locations.get(sheet).filter(function (_location) { return _location !== location; }));
	    }
	    function restyleAdopter(sheet, adopter) {
	        requestAnimationFrame(function () {
	            adopter.textContent = $basicStyleElement.get(sheet).textContent;
	            $appliedMethods
	                .get(sheet)
	                .forEach(function (command) {
	                return adopter.sheet[command.method].apply(adopter.sheet, command.args);
	            });
	        });
	    }
	    function checkInvocationCorrectness(self) {
	        if (!$basicStyleElement.has(self)) {
	            throw new TypeError('Illegal invocation');
	        }
	    }
	    function ConstructedStyleSheet() {
	        var self = this;
	        var style = document.createElement('style');
	        bootstrapper.body.appendChild(style);
	        $basicStyleElement.set(self, style);
	        $locations.set(self, []);
	        $adoptersByLocation.set(self, new WeakMap());
	        $appliedMethods.set(self, []);
	    }
	    var proto$1 = ConstructedStyleSheet.prototype;
	    proto$1.replace = function replace(contents) {
	        try {
	            this.replaceSync(contents);
	            return Promise.resolve(this);
	        }
	        catch (e) {
	            return Promise.reject(e);
	        }
	    };
	    proto$1.replaceSync = function replaceSync(contents) {
	        checkInvocationCorrectness(this);
	        if (typeof contents === 'string') {
	            var self_1 = this;
	            $basicStyleElement.get(self_1).textContent = rejectImports(contents);
	            $appliedMethods.set(self_1, []);
	            $locations.get(self_1).forEach(function (location) {
	                if (location.isConnected()) {
	                    restyleAdopter(self_1, getAdopterByLocation(self_1, location));
	                }
	            });
	        }
	    };
	    defineProperty(proto$1, 'cssRules', {
	        configurable: true,
	        enumerable: true,
	        get: function cssRules() {
	            checkInvocationCorrectness(this);
	            return $basicStyleElement.get(this).sheet.cssRules;
	        },
	    });
	    defineProperty(proto$1, 'media', {
	        configurable: true,
	        enumerable: true,
	        get: function media() {
	            checkInvocationCorrectness(this);
	            return $basicStyleElement.get(this).sheet.media;
	        },
	    });
	    cssStyleSheetMethods.forEach(function (method) {
	        proto$1[method] = function () {
	            var self = this;
	            checkInvocationCorrectness(self);
	            var args = arguments;
	            $appliedMethods.get(self).push({ method: method, args: args });
	            $locations.get(self).forEach(function (location) {
	                if (location.isConnected()) {
	                    var sheet = getAdopterByLocation(self, location).sheet;
	                    sheet[method].apply(sheet, args);
	                }
	            });
	            var basicSheet = $basicStyleElement.get(self).sheet;
	            return basicSheet[method].apply(basicSheet, args);
	        };
	    });
	    defineProperty(ConstructedStyleSheet, Symbol.hasInstance, {
	        configurable: true,
	        value: isCSSStyleSheetInstance,
	    });

	    var defaultObserverOptions = {
	        childList: true,
	        subtree: true,
	    };
	    var locations = new WeakMap();
	    function getAssociatedLocation(element) {
	        var location = locations.get(element);
	        if (!location) {
	            location = new Location(element);
	            locations.set(element, location);
	        }
	        return location;
	    }
	    function attachAdoptedStyleSheetProperty(constructor) {
	        defineProperty(constructor.prototype, 'adoptedStyleSheets', {
	            configurable: true,
	            enumerable: true,
	            get: function () {
	                return getAssociatedLocation(this).sheets;
	            },
	            set: function (sheets) {
	                getAssociatedLocation(this).update(sheets);
	            },
	        });
	    }
	    function traverseWebComponents(node, callback) {
	        var iter = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT, function (foundNode) {
	            return getShadowRoot(foundNode)
	                ? NodeFilter.FILTER_ACCEPT
	                : NodeFilter.FILTER_REJECT;
	        },
	        null, false);
	        for (var next = void 0; (next = iter.nextNode());) {
	            callback(getShadowRoot(next));
	        }
	    }
	    var $element = new WeakMap();
	    var $uniqueSheets = new WeakMap();
	    var $observer = new WeakMap();
	    function isExistingAdopter(self, element) {
	        return (element instanceof HTMLStyleElement &&
	            $uniqueSheets.get(self).some(function (sheet) { return getAdopterByLocation(sheet, self); }));
	    }
	    function getAdopterContainer(self) {
	        var element = $element.get(self);
	        return element instanceof Document ? element.body : element;
	    }
	    function adopt(self) {
	        var styleList = document.createDocumentFragment();
	        var sheets = $uniqueSheets.get(self);
	        var observer = $observer.get(self);
	        var container = getAdopterContainer(self);
	        observer.disconnect();
	        sheets.forEach(function (sheet) {
	            styleList.appendChild(getAdopterByLocation(sheet, self) || addAdopterLocation(sheet, self));
	        });
	        container.insertBefore(styleList, null);
	        observer.observe(container, defaultObserverOptions);
	        sheets.forEach(function (sheet) {
	            restyleAdopter(sheet, getAdopterByLocation(sheet, self));
	        });
	    }
	    function Location(element) {
	        var self = this;
	        self.sheets = [];
	        $element.set(self, element);
	        $uniqueSheets.set(self, []);
	        $observer.set(self, new MutationObserver(function (mutations, observer) {
	            if (!document) {
	                observer.disconnect();
	                return;
	            }
	            mutations.forEach(function (mutation) {
	                if (!hasShadyCss) {
	                    forEach.call(mutation.addedNodes, function (node) {
	                        if (!(node instanceof Element)) {
	                            return;
	                        }
	                        traverseWebComponents(node, function (root) {
	                            getAssociatedLocation(root).connect();
	                        });
	                    });
	                }
	                forEach.call(mutation.removedNodes, function (node) {
	                    if (!(node instanceof Element)) {
	                        return;
	                    }
	                    if (isExistingAdopter(self, node)) {
	                        adopt(self);
	                    }
	                    if (!hasShadyCss) {
	                        traverseWebComponents(node, function (root) {
	                            getAssociatedLocation(root).disconnect();
	                        });
	                    }
	                });
	            });
	        }));
	    }
	    Location.prototype = {
	        isConnected: function () {
	            var element = $element.get(this);
	            return element instanceof Document
	                ? element.readyState !== 'loading'
	                : isElementConnected(element.host);
	        },
	        connect: function () {
	            var container = getAdopterContainer(this);
	            $observer.get(this).observe(container, defaultObserverOptions);
	            if ($uniqueSheets.get(this).length > 0) {
	                adopt(this);
	            }
	            traverseWebComponents(container, function (root) {
	                getAssociatedLocation(root).connect();
	            });
	        },
	        disconnect: function () {
	            $observer.get(this).disconnect();
	        },
	        update: function (sheets) {
	            var self = this;
	            var locationType = $element.get(self) === document ? 'Document' : 'ShadowRoot';
	            if (!Array.isArray(sheets)) {
	                throw new TypeError("Failed to set the 'adoptedStyleSheets' property on " + locationType + ": Iterator getter is not callable.");
	            }
	            if (!sheets.every(isCSSStyleSheetInstance)) {
	                throw new TypeError("Failed to set the 'adoptedStyleSheets' property on " + locationType + ": Failed to convert value to 'CSSStyleSheet'");
	            }
	            if (sheets.some(isNonConstructedStyleSheetInstance)) {
	                throw new TypeError("Failed to set the 'adoptedStyleSheets' property on " + locationType + ": Can't adopt non-constructed stylesheets");
	            }
	            self.sheets = sheets;
	            var oldUniqueSheets = $uniqueSheets.get(self);
	            var uniqueSheets = unique(sheets);
	            var removedSheets = diff(oldUniqueSheets, uniqueSheets);
	            removedSheets.forEach(function (sheet) {
	                removeNode(getAdopterByLocation(sheet, self));
	                removeAdopterLocation(sheet, self);
	            });
	            $uniqueSheets.set(self, uniqueSheets);
	            if (self.isConnected() && uniqueSheets.length > 0) {
	                adopt(self);
	            }
	        },
	    };

	    window.CSSStyleSheet = ConstructedStyleSheet;
	    attachAdoptedStyleSheetProperty(Document);
	    if ('ShadowRoot' in window) {
	        attachAdoptedStyleSheetProperty(ShadowRoot);
	        var proto = Element.prototype;
	        var attach_1 = proto.attachShadow;
	        proto.attachShadow = function attachShadow(init) {
	            var root = attach_1.call(this, init);
	            if (init.mode === 'closed') {
	                closedShadowRootRegistry.set(this, root);
	            }
	            return root;
	        };
	    }
	    var documentLocation = getAssociatedLocation(document);
	    if (documentLocation.isConnected()) {
	        documentLocation.connect();
	    }
	    else {
	        document.addEventListener('DOMContentLoaded', documentLocation.connect.bind(documentLocation));
	    }

	}());
	return adoptedStyleSheets;
}

var intersectionObserver = {};

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.
 *
 *  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 *
 */

var hasRequiredIntersectionObserver;

function requireIntersectionObserver () {
	if (hasRequiredIntersectionObserver) return intersectionObserver;
	hasRequiredIntersectionObserver = 1;
	(function() {

	// Exit early if we're not running in a browser.
	if (typeof window !== 'object') {
	  return;
	}

	// Exit early if all IntersectionObserver and IntersectionObserverEntry
	// features are natively supported.
	if ('IntersectionObserver' in window &&
	    'IntersectionObserverEntry' in window &&
	    'intersectionRatio' in window.IntersectionObserverEntry.prototype) {

	  // Minimal polyfill for Edge 15's lack of `isIntersecting`
	  // See: https://github.com/w3c/IntersectionObserver/issues/211
	  if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {
	    Object.defineProperty(window.IntersectionObserverEntry.prototype,
	      'isIntersecting', {
	      get: function () {
	        return this.intersectionRatio > 0;
	      }
	    });
	  }
	  return;
	}

	/**
	 * Returns the embedding frame element, if any.
	 * @param {!Document} doc
	 * @return {!Element}
	 */
	function getFrameElement(doc) {
	  try {
	    return doc.defaultView && doc.defaultView.frameElement || null;
	  } catch (e) {
	    // Ignore the error.
	    return null;
	  }
	}

	/**
	 * A local reference to the root document.
	 */
	var document = (function(startDoc) {
	  var doc = startDoc;
	  var frame = getFrameElement(doc);
	  while (frame) {
	    doc = frame.ownerDocument;
	    frame = getFrameElement(doc);
	  }
	  return doc;
	})(window.document);

	/**
	 * An IntersectionObserver registry. This registry exists to hold a strong
	 * reference to IntersectionObserver instances currently observing a target
	 * element. Without this registry, instances without another reference may be
	 * garbage collected.
	 */
	var registry = [];

	/**
	 * The signal updater for cross-origin intersection. When not null, it means
	 * that the polyfill is configured to work in a cross-origin mode.
	 * @type {function(DOMRect|ClientRect, DOMRect|ClientRect)}
	 */
	var crossOriginUpdater = null;

	/**
	 * The current cross-origin intersection. Only used in the cross-origin mode.
	 * @type {DOMRect|ClientRect}
	 */
	var crossOriginRect = null;


	/**
	 * Creates the global IntersectionObserverEntry constructor.
	 * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry
	 * @param {Object} entry A dictionary of instance properties.
	 * @constructor
	 */
	function IntersectionObserverEntry(entry) {
	  this.time = entry.time;
	  this.target = entry.target;
	  this.rootBounds = ensureDOMRect(entry.rootBounds);
	  this.boundingClientRect = ensureDOMRect(entry.boundingClientRect);
	  this.intersectionRect = ensureDOMRect(entry.intersectionRect || getEmptyRect());
	  this.isIntersecting = !!entry.intersectionRect;

	  // Calculates the intersection ratio.
	  var targetRect = this.boundingClientRect;
	  var targetArea = targetRect.width * targetRect.height;
	  var intersectionRect = this.intersectionRect;
	  var intersectionArea = intersectionRect.width * intersectionRect.height;

	  // Sets intersection ratio.
	  if (targetArea) {
	    // Round the intersection ratio to avoid floating point math issues:
	    // https://github.com/w3c/IntersectionObserver/issues/324
	    this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4));
	  } else {
	    // If area is zero and is intersecting, sets to 1, otherwise to 0
	    this.intersectionRatio = this.isIntersecting ? 1 : 0;
	  }
	}


	/**
	 * Creates the global IntersectionObserver constructor.
	 * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface
	 * @param {Function} callback The function to be invoked after intersection
	 *     changes have queued. The function is not invoked if the queue has
	 *     been emptied by calling the `takeRecords` method.
	 * @param {Object=} opt_options Optional configuration options.
	 * @constructor
	 */
	function IntersectionObserver(callback, opt_options) {

	  var options = opt_options || {};

	  if (typeof callback != 'function') {
	    throw new Error('callback must be a function');
	  }

	  if (
	    options.root &&
	    options.root.nodeType != 1 &&
	    options.root.nodeType != 9
	  ) {
	    throw new Error('root must be a Document or Element');
	  }

	  // Binds and throttles `this._checkForIntersections`.
	  this._checkForIntersections = throttle(
	      this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);

	  // Private properties.
	  this._callback = callback;
	  this._observationTargets = [];
	  this._queuedEntries = [];
	  this._rootMarginValues = this._parseRootMargin(options.rootMargin);

	  // Public properties.
	  this.thresholds = this._initThresholds(options.threshold);
	  this.root = options.root || null;
	  this.rootMargin = this._rootMarginValues.map(function(margin) {
	    return margin.value + margin.unit;
	  }).join(' ');

	  /** @private @const {!Array<!Document>} */
	  this._monitoringDocuments = [];
	  /** @private @const {!Array<function()>} */
	  this._monitoringUnsubscribes = [];
	}


	/**
	 * The minimum interval within which the document will be checked for
	 * intersection changes.
	 */
	IntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;


	/**
	 * The frequency in which the polyfill polls for intersection changes.
	 * this can be updated on a per instance basis and must be set prior to
	 * calling `observe` on the first target.
	 */
	IntersectionObserver.prototype.POLL_INTERVAL = null;

	/**
	 * Use a mutation observer on the root element
	 * to detect intersection changes.
	 */
	IntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;


	/**
	 * Sets up the polyfill in the cross-origin mode. The result is the
	 * updater function that accepts two arguments: `boundingClientRect` and
	 * `intersectionRect` - just as these fields would be available to the
	 * parent via `IntersectionObserverEntry`. This function should be called
	 * each time the iframe receives intersection information from the parent
	 * window, e.g. via messaging.
	 * @return {function(DOMRect|ClientRect, DOMRect|ClientRect)}
	 */
	IntersectionObserver._setupCrossOriginUpdater = function() {
	  if (!crossOriginUpdater) {
	    /**
	     * @param {DOMRect|ClientRect} boundingClientRect
	     * @param {DOMRect|ClientRect} intersectionRect
	     */
	    crossOriginUpdater = function(boundingClientRect, intersectionRect) {
	      if (!boundingClientRect || !intersectionRect) {
	        crossOriginRect = getEmptyRect();
	      } else {
	        crossOriginRect = convertFromParentRect(boundingClientRect, intersectionRect);
	      }
	      registry.forEach(function(observer) {
	        observer._checkForIntersections();
	      });
	    };
	  }
	  return crossOriginUpdater;
	};


	/**
	 * Resets the cross-origin mode.
	 */
	IntersectionObserver._resetCrossOriginUpdater = function() {
	  crossOriginUpdater = null;
	  crossOriginRect = null;
	};


	/**
	 * Starts observing a target element for intersection changes based on
	 * the thresholds values.
	 * @param {Element} target The DOM element to observe.
	 */
	IntersectionObserver.prototype.observe = function(target) {
	  var isTargetAlreadyObserved = this._observationTargets.some(function(item) {
	    return item.element == target;
	  });

	  if (isTargetAlreadyObserved) {
	    return;
	  }

	  if (!(target && target.nodeType == 1)) {
	    throw new Error('target must be an Element');
	  }

	  this._registerInstance();
	  this._observationTargets.push({element: target, entry: null});
	  this._monitorIntersections(target.ownerDocument);
	  this._checkForIntersections();
	};


	/**
	 * Stops observing a target element for intersection changes.
	 * @param {Element} target The DOM element to observe.
	 */
	IntersectionObserver.prototype.unobserve = function(target) {
	  this._observationTargets =
	      this._observationTargets.filter(function(item) {
	        return item.element != target;
	      });
	  this._unmonitorIntersections(target.ownerDocument);
	  if (this._observationTargets.length == 0) {
	    this._unregisterInstance();
	  }
	};


	/**
	 * Stops observing all target elements for intersection changes.
	 */
	IntersectionObserver.prototype.disconnect = function() {
	  this._observationTargets = [];
	  this._unmonitorAllIntersections();
	  this._unregisterInstance();
	};


	/**
	 * Returns any queue entries that have not yet been reported to the
	 * callback and clears the queue. This can be used in conjunction with the
	 * callback to obtain the absolute most up-to-date intersection information.
	 * @return {Array} The currently queued entries.
	 */
	IntersectionObserver.prototype.takeRecords = function() {
	  var records = this._queuedEntries.slice();
	  this._queuedEntries = [];
	  return records;
	};


	/**
	 * Accepts the threshold value from the user configuration object and
	 * returns a sorted array of unique threshold values. If a value is not
	 * between 0 and 1 and error is thrown.
	 * @private
	 * @param {Array|number=} opt_threshold An optional threshold value or
	 *     a list of threshold values, defaulting to [0].
	 * @return {Array} A sorted list of unique and valid threshold values.
	 */
	IntersectionObserver.prototype._initThresholds = function(opt_threshold) {
	  var threshold = opt_threshold || [0];
	  if (!Array.isArray(threshold)) threshold = [threshold];

	  return threshold.sort().filter(function(t, i, a) {
	    if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {
	      throw new Error('threshold must be a number between 0 and 1 inclusively');
	    }
	    return t !== a[i - 1];
	  });
	};


	/**
	 * Accepts the rootMargin value from the user configuration object
	 * and returns an array of the four margin values as an object containing
	 * the value and unit properties. If any of the values are not properly
	 * formatted or use a unit other than px or %, and error is thrown.
	 * @private
	 * @param {string=} opt_rootMargin An optional rootMargin value,
	 *     defaulting to '0px'.
	 * @return {Array<Object>} An array of margin objects with the keys
	 *     value and unit.
	 */
	IntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {
	  var marginString = opt_rootMargin || '0px';
	  var margins = marginString.split(/\s+/).map(function(margin) {
	    var parts = /^(-?\d*\.?\d+)(px|%)$/.exec(margin);
	    if (!parts) {
	      throw new Error('rootMargin must be specified in pixels or percent');
	    }
	    return {value: parseFloat(parts[1]), unit: parts[2]};
	  });

	  // Handles shorthand.
	  margins[1] = margins[1] || margins[0];
	  margins[2] = margins[2] || margins[0];
	  margins[3] = margins[3] || margins[1];

	  return margins;
	};


	/**
	 * Starts polling for intersection changes if the polling is not already
	 * happening, and if the page's visibility state is visible.
	 * @param {!Document} doc
	 * @private
	 */
	IntersectionObserver.prototype._monitorIntersections = function(doc) {
	  var win = doc.defaultView;
	  if (!win) {
	    // Already destroyed.
	    return;
	  }
	  if (this._monitoringDocuments.indexOf(doc) != -1) {
	    // Already monitoring.
	    return;
	  }

	  // Private state for monitoring.
	  var callback = this._checkForIntersections;
	  var monitoringInterval = null;
	  var domObserver = null;

	  // If a poll interval is set, use polling instead of listening to
	  // resize and scroll events or DOM mutations.
	  if (this.POLL_INTERVAL) {
	    monitoringInterval = win.setInterval(callback, this.POLL_INTERVAL);
	  } else {
	    addEvent(win, 'resize', callback, true);
	    addEvent(doc, 'scroll', callback, true);
	    if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in win) {
	      domObserver = new win.MutationObserver(callback);
	      domObserver.observe(doc, {
	        attributes: true,
	        childList: true,
	        characterData: true,
	        subtree: true
	      });
	    }
	  }

	  this._monitoringDocuments.push(doc);
	  this._monitoringUnsubscribes.push(function() {
	    // Get the window object again. When a friendly iframe is destroyed, it
	    // will be null.
	    var win = doc.defaultView;

	    if (win) {
	      if (monitoringInterval) {
	        win.clearInterval(monitoringInterval);
	      }
	      removeEvent(win, 'resize', callback, true);
	    }

	    removeEvent(doc, 'scroll', callback, true);
	    if (domObserver) {
	      domObserver.disconnect();
	    }
	  });

	  // Also monitor the parent.
	  var rootDoc =
	    (this.root && (this.root.ownerDocument || this.root)) || document;
	  if (doc != rootDoc) {
	    var frame = getFrameElement(doc);
	    if (frame) {
	      this._monitorIntersections(frame.ownerDocument);
	    }
	  }
	};


	/**
	 * Stops polling for intersection changes.
	 * @param {!Document} doc
	 * @private
	 */
	IntersectionObserver.prototype._unmonitorIntersections = function(doc) {
	  var index = this._monitoringDocuments.indexOf(doc);
	  if (index == -1) {
	    return;
	  }

	  var rootDoc =
	    (this.root && (this.root.ownerDocument || this.root)) || document;

	  // Check if any dependent targets are still remaining.
	  var hasDependentTargets =
	      this._observationTargets.some(function(item) {
	        var itemDoc = item.element.ownerDocument;
	        // Target is in this context.
	        if (itemDoc == doc) {
	          return true;
	        }
	        // Target is nested in this context.
	        while (itemDoc && itemDoc != rootDoc) {
	          var frame = getFrameElement(itemDoc);
	          itemDoc = frame && frame.ownerDocument;
	          if (itemDoc == doc) {
	            return true;
	          }
	        }
	        return false;
	      });
	  if (hasDependentTargets) {
	    return;
	  }

	  // Unsubscribe.
	  var unsubscribe = this._monitoringUnsubscribes[index];
	  this._monitoringDocuments.splice(index, 1);
	  this._monitoringUnsubscribes.splice(index, 1);
	  unsubscribe();

	  // Also unmonitor the parent.
	  if (doc != rootDoc) {
	    var frame = getFrameElement(doc);
	    if (frame) {
	      this._unmonitorIntersections(frame.ownerDocument);
	    }
	  }
	};


	/**
	 * Stops polling for intersection changes.
	 * @param {!Document} doc
	 * @private
	 */
	IntersectionObserver.prototype._unmonitorAllIntersections = function() {
	  var unsubscribes = this._monitoringUnsubscribes.slice(0);
	  this._monitoringDocuments.length = 0;
	  this._monitoringUnsubscribes.length = 0;
	  for (var i = 0; i < unsubscribes.length; i++) {
	    unsubscribes[i]();
	  }
	};


	/**
	 * Scans each observation target for intersection changes and adds them
	 * to the internal entries queue. If new entries are found, it
	 * schedules the callback to be invoked.
	 * @private
	 */
	IntersectionObserver.prototype._checkForIntersections = function() {
	  if (!this.root && crossOriginUpdater && !crossOriginRect) {
	    // Cross origin monitoring, but no initial data available yet.
	    return;
	  }

	  var rootIsInDom = this._rootIsInDom();
	  var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();

	  this._observationTargets.forEach(function(item) {
	    var target = item.element;
	    var targetRect = getBoundingClientRect(target);
	    var rootContainsTarget = this._rootContainsTarget(target);
	    var oldEntry = item.entry;
	    var intersectionRect = rootIsInDom && rootContainsTarget &&
	        this._computeTargetAndRootIntersection(target, targetRect, rootRect);

	    var rootBounds = null;
	    if (!this._rootContainsTarget(target)) {
	      rootBounds = getEmptyRect();
	    } else if (!crossOriginUpdater || this.root) {
	      rootBounds = rootRect;
	    }

	    var newEntry = item.entry = new IntersectionObserverEntry({
	      time: now(),
	      target: target,
	      boundingClientRect: targetRect,
	      rootBounds: rootBounds,
	      intersectionRect: intersectionRect
	    });

	    if (!oldEntry) {
	      this._queuedEntries.push(newEntry);
	    } else if (rootIsInDom && rootContainsTarget) {
	      // If the new entry intersection ratio has crossed any of the
	      // thresholds, add a new entry.
	      if (this._hasCrossedThreshold(oldEntry, newEntry)) {
	        this._queuedEntries.push(newEntry);
	      }
	    } else {
	      // If the root is not in the DOM or target is not contained within
	      // root but the previous entry for this target had an intersection,
	      // add a new record indicating removal.
	      if (oldEntry && oldEntry.isIntersecting) {
	        this._queuedEntries.push(newEntry);
	      }
	    }
	  }, this);

	  if (this._queuedEntries.length) {
	    this._callback(this.takeRecords(), this);
	  }
	};


	/**
	 * Accepts a target and root rect computes the intersection between then
	 * following the algorithm in the spec.
	 * TODO(philipwalton): at this time clip-path is not considered.
	 * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo
	 * @param {Element} target The target DOM element
	 * @param {Object} targetRect The bounding rect of the target.
	 * @param {Object} rootRect The bounding rect of the root after being
	 *     expanded by the rootMargin value.
	 * @return {?Object} The final intersection rect object or undefined if no
	 *     intersection is found.
	 * @private
	 */
	IntersectionObserver.prototype._computeTargetAndRootIntersection =
	    function(target, targetRect, rootRect) {
	  // If the element isn't displayed, an intersection can't happen.
	  if (window.getComputedStyle(target).display == 'none') return;

	  var intersectionRect = targetRect;
	  var parent = getParentNode(target);
	  var atRoot = false;

	  while (!atRoot && parent) {
	    var parentRect = null;
	    var parentComputedStyle = parent.nodeType == 1 ?
	        window.getComputedStyle(parent) : {};

	    // If the parent isn't displayed, an intersection can't happen.
	    if (parentComputedStyle.display == 'none') return null;

	    if (parent == this.root || parent.nodeType == /* DOCUMENT */ 9) {
	      atRoot = true;
	      if (parent == this.root || parent == document) {
	        if (crossOriginUpdater && !this.root) {
	          if (!crossOriginRect ||
	              crossOriginRect.width == 0 && crossOriginRect.height == 0) {
	            // A 0-size cross-origin intersection means no-intersection.
	            parent = null;
	            parentRect = null;
	            intersectionRect = null;
	          } else {
	            parentRect = crossOriginRect;
	          }
	        } else {
	          parentRect = rootRect;
	        }
	      } else {
	        // Check if there's a frame that can be navigated to.
	        var frame = getParentNode(parent);
	        var frameRect = frame && getBoundingClientRect(frame);
	        var frameIntersect =
	            frame &&
	            this._computeTargetAndRootIntersection(frame, frameRect, rootRect);
	        if (frameRect && frameIntersect) {
	          parent = frame;
	          parentRect = convertFromParentRect(frameRect, frameIntersect);
	        } else {
	          parent = null;
	          intersectionRect = null;
	        }
	      }
	    } else {
	      // If the element has a non-visible overflow, and it's not the <body>
	      // or <html> element, update the intersection rect.
	      // Note: <body> and <html> cannot be clipped to a rect that's not also
	      // the document rect, so no need to compute a new intersection.
	      var doc = parent.ownerDocument;
	      if (parent != doc.body &&
	          parent != doc.documentElement &&
	          parentComputedStyle.overflow != 'visible') {
	        parentRect = getBoundingClientRect(parent);
	      }
	    }

	    // If either of the above conditionals set a new parentRect,
	    // calculate new intersection data.
	    if (parentRect) {
	      intersectionRect = computeRectIntersection(parentRect, intersectionRect);
	    }
	    if (!intersectionRect) break;
	    parent = parent && getParentNode(parent);
	  }
	  return intersectionRect;
	};


	/**
	 * Returns the root rect after being expanded by the rootMargin value.
	 * @return {ClientRect} The expanded root rect.
	 * @private
	 */
	IntersectionObserver.prototype._getRootRect = function() {
	  var rootRect;
	  if (this.root && !isDoc(this.root)) {
	    rootRect = getBoundingClientRect(this.root);
	  } else {
	    // Use <html>/<body> instead of window since scroll bars affect size.
	    var doc = isDoc(this.root) ? this.root : document;
	    var html = doc.documentElement;
	    var body = doc.body;
	    rootRect = {
	      top: 0,
	      left: 0,
	      right: html.clientWidth || body.clientWidth,
	      width: html.clientWidth || body.clientWidth,
	      bottom: html.clientHeight || body.clientHeight,
	      height: html.clientHeight || body.clientHeight
	    };
	  }
	  return this._expandRectByRootMargin(rootRect);
	};


	/**
	 * Accepts a rect and expands it by the rootMargin value.
	 * @param {DOMRect|ClientRect} rect The rect object to expand.
	 * @return {ClientRect} The expanded rect.
	 * @private
	 */
	IntersectionObserver.prototype._expandRectByRootMargin = function(rect) {
	  var margins = this._rootMarginValues.map(function(margin, i) {
	    return margin.unit == 'px' ? margin.value :
	        margin.value * (i % 2 ? rect.width : rect.height) / 100;
	  });
	  var newRect = {
	    top: rect.top - margins[0],
	    right: rect.right + margins[1],
	    bottom: rect.bottom + margins[2],
	    left: rect.left - margins[3]
	  };
	  newRect.width = newRect.right - newRect.left;
	  newRect.height = newRect.bottom - newRect.top;

	  return newRect;
	};


	/**
	 * Accepts an old and new entry and returns true if at least one of the
	 * threshold values has been crossed.
	 * @param {?IntersectionObserverEntry} oldEntry The previous entry for a
	 *    particular target element or null if no previous entry exists.
	 * @param {IntersectionObserverEntry} newEntry The current entry for a
	 *    particular target element.
	 * @return {boolean} Returns true if a any threshold has been crossed.
	 * @private
	 */
	IntersectionObserver.prototype._hasCrossedThreshold =
	    function(oldEntry, newEntry) {

	  // To make comparing easier, an entry that has a ratio of 0
	  // but does not actually intersect is given a value of -1
	  var oldRatio = oldEntry && oldEntry.isIntersecting ?
	      oldEntry.intersectionRatio || 0 : -1;
	  var newRatio = newEntry.isIntersecting ?
	      newEntry.intersectionRatio || 0 : -1;

	  // Ignore unchanged ratios
	  if (oldRatio === newRatio) return;

	  for (var i = 0; i < this.thresholds.length; i++) {
	    var threshold = this.thresholds[i];

	    // Return true if an entry matches a threshold or if the new ratio
	    // and the old ratio are on the opposite sides of a threshold.
	    if (threshold == oldRatio || threshold == newRatio ||
	        threshold < oldRatio !== threshold < newRatio) {
	      return true;
	    }
	  }
	};


	/**
	 * Returns whether or not the root element is an element and is in the DOM.
	 * @return {boolean} True if the root element is an element and is in the DOM.
	 * @private
	 */
	IntersectionObserver.prototype._rootIsInDom = function() {
	  return !this.root || containsDeep(document, this.root);
	};


	/**
	 * Returns whether or not the target element is a child of root.
	 * @param {Element} target The target element to check.
	 * @return {boolean} True if the target element is a child of root.
	 * @private
	 */
	IntersectionObserver.prototype._rootContainsTarget = function(target) {
	  var rootDoc =
	    (this.root && (this.root.ownerDocument || this.root)) || document;
	  return (
	    containsDeep(rootDoc, target) &&
	    (!this.root || rootDoc == target.ownerDocument)
	  );
	};


	/**
	 * Adds the instance to the global IntersectionObserver registry if it isn't
	 * already present.
	 * @private
	 */
	IntersectionObserver.prototype._registerInstance = function() {
	  if (registry.indexOf(this) < 0) {
	    registry.push(this);
	  }
	};


	/**
	 * Removes the instance from the global IntersectionObserver registry.
	 * @private
	 */
	IntersectionObserver.prototype._unregisterInstance = function() {
	  var index = registry.indexOf(this);
	  if (index != -1) registry.splice(index, 1);
	};


	/**
	 * Returns the result of the performance.now() method or null in browsers
	 * that don't support the API.
	 * @return {number} The elapsed time since the page was requested.
	 */
	function now() {
	  return window.performance && performance.now && performance.now();
	}


	/**
	 * Throttles a function and delays its execution, so it's only called at most
	 * once within a given time period.
	 * @param {Function} fn The function to throttle.
	 * @param {number} timeout The amount of time that must pass before the
	 *     function can be called again.
	 * @return {Function} The throttled function.
	 */
	function throttle(fn, timeout) {
	  var timer = null;
	  return function () {
	    if (!timer) {
	      timer = setTimeout(function() {
	        fn();
	        timer = null;
	      }, timeout);
	    }
	  };
	}


	/**
	 * Adds an event handler to a DOM node ensuring cross-browser compatibility.
	 * @param {Node} node The DOM node to add the event handler to.
	 * @param {string} event The event name.
	 * @param {Function} fn The event handler to add.
	 * @param {boolean} opt_useCapture Optionally adds the even to the capture
	 *     phase. Note: this only works in modern browsers.
	 */
	function addEvent(node, event, fn, opt_useCapture) {
	  if (typeof node.addEventListener == 'function') {
	    node.addEventListener(event, fn, opt_useCapture || false);
	  }
	  else if (typeof node.attachEvent == 'function') {
	    node.attachEvent('on' + event, fn);
	  }
	}


	/**
	 * Removes a previously added event handler from a DOM node.
	 * @param {Node} node The DOM node to remove the event handler from.
	 * @param {string} event The event name.
	 * @param {Function} fn The event handler to remove.
	 * @param {boolean} opt_useCapture If the event handler was added with this
	 *     flag set to true, it should be set to true here in order to remove it.
	 */
	function removeEvent(node, event, fn, opt_useCapture) {
	  if (typeof node.removeEventListener == 'function') {
	    node.removeEventListener(event, fn, opt_useCapture || false);
	  }
	  else if (typeof node.detachEvent == 'function') {
	    node.detachEvent('on' + event, fn);
	  }
	}


	/**
	 * Returns the intersection between two rect objects.
	 * @param {Object} rect1 The first rect.
	 * @param {Object} rect2 The second rect.
	 * @return {?Object|?ClientRect} The intersection rect or undefined if no
	 *     intersection is found.
	 */
	function computeRectIntersection(rect1, rect2) {
	  var top = Math.max(rect1.top, rect2.top);
	  var bottom = Math.min(rect1.bottom, rect2.bottom);
	  var left = Math.max(rect1.left, rect2.left);
	  var right = Math.min(rect1.right, rect2.right);
	  var width = right - left;
	  var height = bottom - top;

	  return (width >= 0 && height >= 0) && {
	    top: top,
	    bottom: bottom,
	    left: left,
	    right: right,
	    width: width,
	    height: height
	  } || null;
	}


	/**
	 * Shims the native getBoundingClientRect for compatibility with older IE.
	 * @param {Element} el The element whose bounding rect to get.
	 * @return {DOMRect|ClientRect} The (possibly shimmed) rect of the element.
	 */
	function getBoundingClientRect(el) {
	  var rect;

	  try {
	    rect = el.getBoundingClientRect();
	  } catch (err) {
	    // Ignore Windows 7 IE11 "Unspecified error"
	    // https://github.com/w3c/IntersectionObserver/pull/205
	  }

	  if (!rect) return getEmptyRect();

	  // Older IE
	  if (!(rect.width && rect.height)) {
	    rect = {
	      top: rect.top,
	      right: rect.right,
	      bottom: rect.bottom,
	      left: rect.left,
	      width: rect.right - rect.left,
	      height: rect.bottom - rect.top
	    };
	  }
	  return rect;
	}


	/**
	 * Returns an empty rect object. An empty rect is returned when an element
	 * is not in the DOM.
	 * @return {ClientRect} The empty rect.
	 */
	function getEmptyRect() {
	  return {
	    top: 0,
	    bottom: 0,
	    left: 0,
	    right: 0,
	    width: 0,
	    height: 0
	  };
	}


	/**
	 * Ensure that the result has all of the necessary fields of the DOMRect.
	 * Specifically this ensures that `x` and `y` fields are set.
	 *
	 * @param {?DOMRect|?ClientRect} rect
	 * @return {?DOMRect}
	 */
	function ensureDOMRect(rect) {
	  // A `DOMRect` object has `x` and `y` fields.
	  if (!rect || 'x' in rect) {
	    return rect;
	  }
	  // A IE's `ClientRect` type does not have `x` and `y`. The same is the case
	  // for internally calculated Rect objects. For the purposes of
	  // `IntersectionObserver`, it's sufficient to simply mirror `left` and `top`
	  // for these fields.
	  return {
	    top: rect.top,
	    y: rect.top,
	    bottom: rect.bottom,
	    left: rect.left,
	    x: rect.left,
	    right: rect.right,
	    width: rect.width,
	    height: rect.height
	  };
	}


	/**
	 * Inverts the intersection and bounding rect from the parent (frame) BCR to
	 * the local BCR space.
	 * @param {DOMRect|ClientRect} parentBoundingRect The parent's bound client rect.
	 * @param {DOMRect|ClientRect} parentIntersectionRect The parent's own intersection rect.
	 * @return {ClientRect} The local root bounding rect for the parent's children.
	 */
	function convertFromParentRect(parentBoundingRect, parentIntersectionRect) {
	  var top = parentIntersectionRect.top - parentBoundingRect.top;
	  var left = parentIntersectionRect.left - parentBoundingRect.left;
	  return {
	    top: top,
	    left: left,
	    height: parentIntersectionRect.height,
	    width: parentIntersectionRect.width,
	    bottom: top + parentIntersectionRect.height,
	    right: left + parentIntersectionRect.width
	  };
	}


	/**
	 * Checks to see if a parent element contains a child element (including inside
	 * shadow DOM).
	 * @param {Node} parent The parent element.
	 * @param {Node} child The child element.
	 * @return {boolean} True if the parent node contains the child node.
	 */
	function containsDeep(parent, child) {
	  var node = child;
	  while (node) {
	    if (node == parent) return true;

	    node = getParentNode(node);
	  }
	  return false;
	}


	/**
	 * Gets the parent node of an element or its host element if the parent node
	 * is a shadow root.
	 * @param {Node} node The node whose parent to get.
	 * @return {Node|null} The parent node or null if no parent exists.
	 */
	function getParentNode(node) {
	  var parent = node.parentNode;

	  if (node.nodeType == /* DOCUMENT */ 9 && node != document) {
	    // If this node is a document node, look for the embedding frame.
	    return getFrameElement(node);
	  }

	  // If the parent has element that is assigned through shadow root slot
	  if (parent && parent.assignedSlot) {
	    parent = parent.assignedSlot.parentNode;
	  }

	  if (parent && parent.nodeType == 11 && parent.host) {
	    // If the parent is a shadow root, return the host element.
	    return parent.host;
	  }

	  return parent;
	}

	/**
	 * Returns true if `node` is a Document.
	 * @param {!Node} node
	 * @returns {boolean}
	 */
	function isDoc(node) {
	  return node && node.nodeType === 9;
	}


	// Exposes the constructors globally.
	window.IntersectionObserver = IntersectionObserver;
	window.IntersectionObserverEntry = IntersectionObserverEntry;

	}());
	return intersectionObserver;
}

var matchMedia$1 = {};

/*! matchMedia() polyfill - Test a CSS media type/query in JS. Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. MIT license */

var hasRequiredMatchMedia;

function requireMatchMedia () {
	if (hasRequiredMatchMedia) return matchMedia$1;
	hasRequiredMatchMedia = 1;
	window.matchMedia || (window.matchMedia = function() {

	    // For browsers that support matchMedium api such as IE 9 and webkit
	    var styleMedia = (window.styleMedia || window.media);

	    // For those that don't support matchMedium
	    if (!styleMedia) {
	        var style       = document.createElement('style'),
	            script      = document.getElementsByTagName('script')[0],
	            info        = null;

	        style.type  = 'text/css';
	        style.id    = 'matchmediajs-test';

	        if (!script) {
	          document.head.appendChild(style);
	        } else {
	          script.parentNode.insertBefore(style, script);
	        }

	        // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers
	        info = ('getComputedStyle' in window) && window.getComputedStyle(style, null) || style.currentStyle;

	        styleMedia = {
	            matchMedium: function(media) {
	                var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';

	                // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers
	                if (style.styleSheet) {
	                    style.styleSheet.cssText = text;
	                } else {
	                    style.textContent = text;
	                }

	                // Test if media query is true or false
	                return info.width === '1px';
	            }
	        };
	    }

	    return function(media) {
	        return {
	            matches: styleMedia.matchMedium(media || 'all'),
	            media: media || 'all'
	        };
	    };
	}());
	return matchMedia$1;
}

var matchMedia_addListener = {};

/*! matchMedia() polyfill addListener/removeListener extension. Author & copyright (c) 2012: Scott Jehl. MIT license */

var hasRequiredMatchMedia_addListener;

function requireMatchMedia_addListener () {
	if (hasRequiredMatchMedia_addListener) return matchMedia_addListener;
	hasRequiredMatchMedia_addListener = 1;
	(function(){
	    // Bail out for browsers that have addListener support
	    if (window.matchMedia && window.matchMedia('all').addListener) {
	        return false;
	    }

	    var localMatchMedia = window.matchMedia,
	        hasMediaQueries = localMatchMedia('only all').matches,
	        isListening     = false,
	        timeoutID       = 0,    // setTimeout for debouncing 'handleChange'
	        queries         = [],   // Contains each 'mql' and associated 'listeners' if 'addListener' is used
	        handleChange    = function(evt) {
	            // Debounce
	            clearTimeout(timeoutID);

	            timeoutID = setTimeout(function() {
	                for (var i = 0, il = queries.length; i < il; i++) {
	                    var mql         = queries[i].mql,
	                        listeners   = queries[i].listeners || [],
	                        matches     = localMatchMedia(mql.media).matches;

	                    // Update mql.matches value and call listeners
	                    // Fire listeners only if transitioning to or from matched state
	                    if (matches !== mql.matches) {
	                        mql.matches = matches;

	                        for (var j = 0, jl = listeners.length; j < jl; j++) {
	                            listeners[j].call(window, mql);
	                        }
	                    }
	                }
	            }, 30);
	        };

	    window.matchMedia = function(media) {
	        var mql         = localMatchMedia(media),
	            listeners   = [],
	            index       = 0;

	        mql.addListener = function(listener) {
	            // Changes would not occur to css media type so return now (Affects IE <= 8)
	            if (!hasMediaQueries) {
	                return;
	            }

	            // Set up 'resize' listener for browsers that support CSS3 media queries (Not for IE <= 8)
	            // There should only ever be 1 resize listener running for performance
	            if (!isListening) {
	                isListening = true;
	                window.addEventListener('resize', handleChange, true);
	            }

	            // Push object only if it has not been pushed already
	            if (index === 0) {
	                index = queries.push({
	                    mql         : mql,
	                    listeners   : listeners
	                });
	            }

	            listeners.push(listener);
	        };

	        mql.removeListener = function(listener) {
	            for (var i = 0, il = listeners.length; i < il; i++){
	                if (listeners[i] === listener){
	                    listeners.splice(i, 1);
	                }
	            }
	        };

	        return mql;
	    };
	}());
	return matchMedia_addListener;
}

var dist = {};

var hasRequiredDist;

function requireDist () {
	if (hasRequiredDist) return dist;
	hasRequiredDist = 1;
	(function () {

	    var UNSUPPORTED_ENVIRONMENT = typeof window === "undefined";

	    /**
	     * Is true if the browser natively supports the 'scroll-behavior' CSS-property.
	     * @type {boolean}
	     */
	    var SUPPORTS_SCROLL_BEHAVIOR = UNSUPPORTED_ENVIRONMENT ? false : "scrollBehavior" in document.documentElement.style;

	    

	    /*! *****************************************************************************
	    Copyright (c) Microsoft Corporation. All rights reserved.
	    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	    this file except in compliance with the License. You may obtain a copy of the
	    License at http://www.apache.org/licenses/LICENSE-2.0

	    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	    MERCHANTABLITY OR NON-INFRINGEMENT.

	    See the Apache Version 2.0 License for specific language governing permissions
	    and limitations under the License.
	    ***************************************************************************** */

	    var __assign = function() {
	        __assign = Object.assign || function __assign(t) {
	            for (var s, i = 1, n = arguments.length; i < n; i++) {
	                s = arguments[i];
	                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	            }
	            return t;
	        };
	        return __assign.apply(this, arguments);
	    };

	    function __read(o, n) {
	        var m = typeof Symbol === "function" && o[Symbol.iterator];
	        if (!m) return o;
	        var i = m.call(o), r, ar = [], e;
	        try {
	            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	        }
	        catch (error) { e = { error: error }; }
	        finally {
	            try {
	                if (r && !r.done && (m = i["return"])) m.call(i);
	            }
	            finally { if (e) throw e.error; }
	        }
	        return ar;
	    }

	    function getScrollingElement() {
	        if (document.scrollingElement != null) {
	            return document.scrollingElement;
	        }
	        else {
	            return document.documentElement;
	        }
	    }

	    var STYLE_ATTRIBUTE_PROPERTY_NAME = "scroll-behavior";
	    var STYLE_ATTRIBUTE_PROPERTY_REGEXP = new RegExp(STYLE_ATTRIBUTE_PROPERTY_NAME + ":\\s*([^;]*)");
	    /**
	     * Given an Element, this function appends the given ScrollBehavior CSS property value to the elements' 'style' attribute.
	     * If it doesnt already have one, it will add it.
	     * @param {Element} element
	     * @param {ScrollBehavior} behavior
	     */
	    function appendScrollBehaviorToStyleAttribute(element, behavior) {
	        var addition = STYLE_ATTRIBUTE_PROPERTY_NAME + ":" + behavior;
	        var attributeValue = element.getAttribute("style");
	        if (attributeValue == null || attributeValue === "") {
	            element.setAttribute("style", addition);
	            return;
	        }
	        // The style attribute may already include a 'scroll-behavior:<something>' in which case that should be replaced
	        var existingValueForProperty = parseScrollBehaviorFromStyleAttribute(element);
	        if (existingValueForProperty != null) {
	            var replacementProperty = STYLE_ATTRIBUTE_PROPERTY_NAME + ":" + existingValueForProperty;
	            // Replace the variant that ends with a semi-colon which it may
	            attributeValue = attributeValue.replace(replacementProperty + ";", "");
	            // Replace the variant that *doesn't* end with a semi-colon
	            attributeValue = attributeValue.replace(replacementProperty, "");
	        }
	        // Now, append the behavior to the string.
	        element.setAttribute("style", attributeValue.endsWith(";") ? "" + attributeValue + addition : ";" + attributeValue + addition);
	    }
	    /**
	     * Given an Element, this function attempts to parse its 'style' attribute (if it has one)' to extract
	     * a value for the 'scroll-behavior' CSS property (if it is given within that style attribute)
	     * @param {Element} element
	     * @returns {ScrollBehavior?}
	     */
	    function parseScrollBehaviorFromStyleAttribute(element) {
	        var styleAttributeValue = element.getAttribute("style");
	        if (styleAttributeValue != null && styleAttributeValue.includes(STYLE_ATTRIBUTE_PROPERTY_NAME)) {
	            var match = styleAttributeValue.match(STYLE_ATTRIBUTE_PROPERTY_REGEXP);
	            if (match != null) {
	                var _a = __read(match, 2), behavior = _a[1];
	                if (behavior != null && behavior !== "") {
	                    return behavior;
	                }
	            }
	        }
	        return undefined;
	    }

	    var styleDeclarationPropertyName = "scrollBehavior";
	    /**
	     * Determines the scroll behavior to use, depending on the given ScrollOptions and the position of the Element
	     * within the DOM
	     * @param {Element|HTMLElement|Window} inputTarget
	     * @param {ScrollOptions} [options]
	     * @returns {ScrollBehavior}
	     */
	    function getScrollBehavior(inputTarget, options) {
	        // If the given 'behavior' is 'smooth', apply smooth scrolling no matter what
	        if (options != null && options.behavior === "smooth")
	            return "smooth";
	        var target = "style" in inputTarget ? inputTarget : getScrollingElement();
	        var value;
	        if ("style" in target) {
	            // Check if scroll-behavior is set as a property on the CSSStyleDeclaration
	            var scrollBehaviorPropertyValue = target.style[styleDeclarationPropertyName];
	            // Return it if it is given and has a proper value
	            if (scrollBehaviorPropertyValue != null && scrollBehaviorPropertyValue !== "") {
	                value = scrollBehaviorPropertyValue;
	            }
	        }
	        if (value == null) {
	            var attributeValue = target.getAttribute("scroll-behavior");
	            if (attributeValue != null && attributeValue !== "") {
	                value = attributeValue;
	            }
	        }
	        if (value == null) {
	            // Otherwise, check if it is set as an inline style
	            value = parseScrollBehaviorFromStyleAttribute(target);
	        }
	        if (value == null) {
	            // Take the computed style for the element and see if it contains a specific 'scroll-behavior' value
	            var computedStyle = getComputedStyle(target);
	            var computedStyleValue = computedStyle.getPropertyValue("scrollBehavior");
	            if (computedStyleValue != null && computedStyleValue !== "") {
	                value = computedStyleValue;
	            }
	        }
	        // In all other cases, use the value from the CSSOM
	        return value;
	    }

	    

	    

	    var HALF = 0.5;
	    /**
	     * The easing function to use when applying the smooth scrolling
	     * @param {number} k
	     * @returns {number}
	     */
	    function ease(k) {
	        return HALF * (1 - Math.cos(Math.PI * k));
	    }

	    var NOOP = {
	        reset: function () { }
	    };
	    var map = typeof WeakMap === "undefined" ? undefined : new WeakMap();
	    function disableScrollSnap(scroller) {
	        // If scroll-behavior is natively supported, or if there is no native WeakMap support, there's no need for this fix
	        if (SUPPORTS_SCROLL_BEHAVIOR || map == null) {
	            return NOOP;
	        }
	        var scrollingElement = getScrollingElement();
	        var cachedScrollSnapValue;
	        var cachedScrollBehaviorStyleAttributeValue;
	        var secondaryScroller;
	        var secondaryScrollerCachedScrollSnapValue;
	        var secondaryScrollerCachedScrollBehaviorStyleAttributeValue;
	        var existingResult = map.get(scroller);
	        if (existingResult != null) {
	            cachedScrollSnapValue = existingResult.cachedScrollSnapValue;
	            cachedScrollBehaviorStyleAttributeValue = existingResult.cachedScrollBehaviorStyleAttributeValue;
	            secondaryScroller = existingResult.secondaryScroller;
	            secondaryScrollerCachedScrollSnapValue = existingResult.secondaryScrollerCachedScrollSnapValue;
	            secondaryScrollerCachedScrollBehaviorStyleAttributeValue = existingResult.secondaryScrollerCachedScrollBehaviorStyleAttributeValue;
	            existingResult.release();
	        }
	        else {
	            cachedScrollSnapValue = scroller.style.scrollSnapType === "" ? null : scroller.style.scrollSnapType;
	            cachedScrollBehaviorStyleAttributeValue = parseScrollBehaviorFromStyleAttribute(scroller);
	            secondaryScroller = scroller === scrollingElement && scrollingElement !== document.body ? document.body : undefined;
	            secondaryScrollerCachedScrollSnapValue =
	                secondaryScroller == null ? undefined : secondaryScroller.style.scrollSnapType === "" ? null : secondaryScroller.style.scrollSnapType;
	            secondaryScrollerCachedScrollBehaviorStyleAttributeValue =
	                secondaryScroller == null ? undefined : parseScrollBehaviorFromStyleAttribute(secondaryScroller);
	            var cachedComputedScrollSnapValue = getComputedStyle(scroller).getPropertyValue("scroll-snap-type");
	            var secondaryScrollerCachedComputedScrollSnapValue = secondaryScroller == null ? undefined : getComputedStyle(secondaryScroller).getPropertyValue("scroll-snap-type");
	            // If it just so happens that there actually isn't any scroll snapping going on, there's no point in performing any additional work here.
	            if (cachedComputedScrollSnapValue === "none" && secondaryScrollerCachedComputedScrollSnapValue === "none") {
	                return NOOP;
	            }
	        }
	        scroller.style.scrollSnapType = "none";
	        if (secondaryScroller !== undefined) {
	            secondaryScroller.style.scrollSnapType = "none";
	        }
	        if (cachedScrollBehaviorStyleAttributeValue !== undefined) {
	            appendScrollBehaviorToStyleAttribute(scroller, cachedScrollBehaviorStyleAttributeValue);
	        }
	        if (secondaryScroller !== undefined && secondaryScrollerCachedScrollBehaviorStyleAttributeValue !== undefined) {
	            appendScrollBehaviorToStyleAttribute(secondaryScroller, secondaryScrollerCachedScrollBehaviorStyleAttributeValue);
	        }
	        var hasReleased = false;
	        var eventTarget = scroller === scrollingElement ? window : scroller;
	        function release() {
	            eventTarget.removeEventListener("scroll", resetHandler);
	            if (map != null) {
	                map["delete"](scroller);
	            }
	            hasReleased = true;
	        }
	        function resetHandler() {
	            scroller.style.scrollSnapType = cachedScrollSnapValue;
	            if (secondaryScroller != null && secondaryScrollerCachedScrollSnapValue !== undefined) {
	                secondaryScroller.style.scrollSnapType = secondaryScrollerCachedScrollSnapValue;
	            }
	            if (cachedScrollBehaviorStyleAttributeValue !== undefined) {
	                appendScrollBehaviorToStyleAttribute(scroller, cachedScrollBehaviorStyleAttributeValue);
	            }
	            if (secondaryScroller !== undefined && secondaryScrollerCachedScrollBehaviorStyleAttributeValue !== undefined) {
	                appendScrollBehaviorToStyleAttribute(secondaryScroller, secondaryScrollerCachedScrollBehaviorStyleAttributeValue);
	            }
	            release();
	        }
	        function reset() {
	            setTimeout(function () {
	                if (hasReleased)
	                    return;
	                eventTarget.addEventListener("scroll", resetHandler);
	            });
	        }
	        map.set(scroller, {
	            release: release,
	            cachedScrollSnapValue: cachedScrollSnapValue,
	            cachedScrollBehaviorStyleAttributeValue: cachedScrollBehaviorStyleAttributeValue,
	            secondaryScroller: secondaryScroller,
	            secondaryScrollerCachedScrollSnapValue: secondaryScrollerCachedScrollSnapValue,
	            secondaryScrollerCachedScrollBehaviorStyleAttributeValue: secondaryScrollerCachedScrollBehaviorStyleAttributeValue
	        });
	        return {
	            reset: reset
	        };
	    }

	    /**
	     * The duration of a smooth scroll
	     * @type {number}
	     */
	    var SCROLL_TIME = 15000;
	    /**
	     * Performs a smooth repositioning of the scroll
	     * @param {ISmoothScrollOptions} options
	     */
	    function smoothScroll(options) {
	        var startTime = options.startTime, startX = options.startX, startY = options.startY, endX = options.endX, endY = options.endY, method = options.method, scroller = options.scroller;
	        var timeLapsed = 0;
	        var distanceX = endX - startX;
	        var distanceY = endY - startY;
	        var speed = Math.max(Math.abs((distanceX / 1000) * SCROLL_TIME), Math.abs((distanceY / 1000) * SCROLL_TIME));
	        // Temporarily disables any scroll snapping that may be active since it fights for control over the scroller with this polyfill
	        var scrollSnapFix = disableScrollSnap(scroller);
	        requestAnimationFrame(function animate(timestamp) {
	            timeLapsed += timestamp - startTime;
	            var percentage = Math.max(0, Math.min(1, speed === 0 ? 0 : timeLapsed / speed));
	            var positionX = Math.floor(startX + distanceX * ease(percentage));
	            var positionY = Math.floor(startY + distanceY * ease(percentage));
	            method(positionX, positionY);
	            if (positionX !== endX || positionY !== endY) {
	                requestAnimationFrame(animate);
	            }
	            else {
	                if (scrollSnapFix != null) {
	                    scrollSnapFix.reset();
	                    scrollSnapFix = undefined;
	                }
	            }
	        });
	    }

	    /**
	     * Returns a High Resolution timestamp if possible, otherwise fallbacks to Date.now()
	     * @returns {number}
	     */
	    function now() {
	        if ("performance" in window)
	            return performance.now();
	        return Date.now();
	    }

	    

	    var ELEMENT_ORIGINAL_SCROLL = UNSUPPORTED_ENVIRONMENT ? undefined : Element.prototype.scroll;

	    var WINDOW_ORIGINAL_SCROLL = UNSUPPORTED_ENVIRONMENT ? undefined : window.scroll;

	    var ELEMENT_ORIGINAL_SCROLL_BY = UNSUPPORTED_ENVIRONMENT ? undefined : Element.prototype.scrollBy;

	    var WINDOW_ORIGINAL_SCROLL_BY = UNSUPPORTED_ENVIRONMENT ? undefined : window.scrollBy;

	    var ELEMENT_ORIGINAL_SCROLL_TO = UNSUPPORTED_ENVIRONMENT ? undefined : Element.prototype.scrollTo;

	    var WINDOW_ORIGINAL_SCROLL_TO = UNSUPPORTED_ENVIRONMENT ? undefined : window.scrollTo;

	    /**
	     * A fallback if Element.prototype.scroll is not defined
	     * @param {number} x
	     * @param {number} y
	     */
	    function elementPrototypeScrollFallback(x, y) {
	        this.__adjustingScrollPosition = true;
	        this.scrollLeft = x;
	        this.scrollTop = y;
	        delete this.__adjustingScrollPosition;
	    }
	    /**
	     * A fallback if Element.prototype.scrollTo is not defined
	     * @param {number} x
	     * @param {number} y
	     */
	    function elementPrototypeScrollToFallback(x, y) {
	        return elementPrototypeScrollFallback.call(this, x, y);
	    }
	    /**
	     * A fallback if Element.prototype.scrollBy is not defined
	     * @param {number} x
	     * @param {number} y
	     */
	    function elementPrototypeScrollByFallback(x, y) {
	        this.__adjustingScrollPosition = true;
	        this.scrollLeft += x;
	        this.scrollTop += y;
	        delete this.__adjustingScrollPosition;
	    }
	    /**
	     * Gets the original non-patched prototype method for the given kind
	     * @param {ScrollMethodName} kind
	     * @param {Element|Window} element
	     * @return {Function}
	     */
	    function getOriginalScrollMethodForKind(kind, element) {
	        switch (kind) {
	            case "scroll":
	                if (element instanceof Element) {
	                    if (ELEMENT_ORIGINAL_SCROLL != null) {
	                        return ELEMENT_ORIGINAL_SCROLL;
	                    }
	                    else {
	                        return elementPrototypeScrollFallback;
	                    }
	                }
	                else {
	                    return WINDOW_ORIGINAL_SCROLL;
	                }
	            case "scrollBy":
	                if (element instanceof Element) {
	                    if (ELEMENT_ORIGINAL_SCROLL_BY != null) {
	                        return ELEMENT_ORIGINAL_SCROLL_BY;
	                    }
	                    else {
	                        return elementPrototypeScrollByFallback;
	                    }
	                }
	                else {
	                    return WINDOW_ORIGINAL_SCROLL_BY;
	                }
	            case "scrollTo":
	                if (element instanceof Element) {
	                    if (ELEMENT_ORIGINAL_SCROLL_TO != null) {
	                        return ELEMENT_ORIGINAL_SCROLL_TO;
	                    }
	                    else {
	                        return elementPrototypeScrollToFallback;
	                    }
	                }
	                else {
	                    return WINDOW_ORIGINAL_SCROLL_TO;
	                }
	        }
	    }

	    /**
	     * Gets the Smooth Scroll Options to use for the step function
	     * @param {Element|Window} element
	     * @param {number} x
	     * @param {number} y
	     * @param {ScrollMethodName} kind
	     * @returns {ISmoothScrollOptions}
	     */
	    function getSmoothScrollOptions(element, x, y, kind) {
	        var startTime = now();
	        if (!(element instanceof Element)) {
	            // Use window as the scroll container
	            var scrollX_1 = window.scrollX, pageXOffset_1 = window.pageXOffset, scrollY_1 = window.scrollY, pageYOffset_1 = window.pageYOffset;
	            var startX = scrollX_1 == null || scrollX_1 === 0 ? pageXOffset_1 : scrollX_1;
	            var startY = scrollY_1 == null || scrollY_1 === 0 ? pageYOffset_1 : scrollY_1;
	            return {
	                startTime: startTime,
	                startX: startX,
	                startY: startY,
	                endX: Math.floor(kind === "scrollBy" ? startX + x : x),
	                endY: Math.floor(kind === "scrollBy" ? startY + y : y),
	                method: getOriginalScrollMethodForKind("scrollTo", window).bind(window),
	                scroller: getScrollingElement()
	            };
	        }
	        else {
	            var scrollLeft = element.scrollLeft, scrollTop = element.scrollTop;
	            var startX = scrollLeft;
	            var startY = scrollTop;
	            return {
	                startTime: startTime,
	                startX: startX,
	                startY: startY,
	                endX: Math.floor(kind === "scrollBy" ? startX + x : x),
	                endY: Math.floor(kind === "scrollBy" ? startY + y : y),
	                method: getOriginalScrollMethodForKind("scrollTo", element).bind(element),
	                scroller: element
	            };
	        }
	    }

	    /**
	     * Ensures that the given value is numeric
	     * @param {number} value
	     * @return {number}
	     */
	    function ensureNumeric(value) {
	        if (value == null)
	            return 0;
	        else if (typeof value === "number") {
	            return value;
	        }
	        else if (typeof value === "string") {
	            return parseFloat(value);
	        }
	        else {
	            return 0;
	        }
	    }

	    /**
	     * Returns true if the given value is some ScrollToOptions
	     * @param {number | ScrollToOptions} value
	     * @return {value is ScrollToOptions}
	     */
	    function isScrollToOptions(value) {
	        return value != null && typeof value === "object";
	    }

	    /**
	     * Handles a scroll method
	     * @param {Element|Window} element
	     * @param {ScrollMethodName} kind
	     * @param {number | ScrollToOptions} optionsOrX
	     * @param {number} y
	     */
	    function handleScrollMethod(element, kind, optionsOrX, y) {
	        onScrollWithOptions(getScrollToOptionsWithValidation(optionsOrX, y), element, kind);
	    }
	    /**
	     * Invoked when a 'ScrollToOptions' dict is provided to 'scroll()' as the first argument
	     * @param {ScrollToOptions} options
	     * @param {Element|Window} element
	     * @param {ScrollMethodName} kind
	     */
	    function onScrollWithOptions(options, element, kind) {
	        var behavior = getScrollBehavior(element, options);
	        // If the behavior is 'auto' apply instantaneous scrolling
	        if (behavior == null || behavior === "auto") {
	            getOriginalScrollMethodForKind(kind, element).call(element, options.left, options.top);
	        }
	        else {
	            smoothScroll(getSmoothScrollOptions(element, options.left, options.top, kind));
	        }
	    }
	    /**
	     * Normalizes the given scroll coordinates
	     * @param {number?} x
	     * @param {number?} y
	     * @return {Required<Pick<ScrollToOptions, "top" | "left">>}
	     */
	    function normalizeScrollCoordinates(x, y) {
	        return {
	            left: ensureNumeric(x),
	            top: ensureNumeric(y)
	        };
	    }
	    /**
	     * Gets ScrollToOptions based on the given arguments. Will throw if validation fails
	     * @param {number | ScrollToOptions} optionsOrX
	     * @param {number} y
	     * @return {Required<ScrollToOptions>}
	     */
	    function getScrollToOptionsWithValidation(optionsOrX, y) {
	        // If only one argument is given, and it isn't an options object, throw a TypeError
	        if (y === undefined && !isScrollToOptions(optionsOrX)) {
	            throw new TypeError("Failed to execute 'scroll' on 'Element': parameter 1 ('options') is not an object.");
	        }
	        // Scroll based on the primitive values given as arguments
	        if (!isScrollToOptions(optionsOrX)) {
	            return __assign(__assign({}, normalizeScrollCoordinates(optionsOrX, y)), { behavior: "auto" });
	        }
	        // Scroll based on the received options object
	        else {
	            return __assign(__assign({}, normalizeScrollCoordinates(optionsOrX.left, optionsOrX.top)), { behavior: optionsOrX.behavior == null ? "auto" : optionsOrX.behavior });
	        }
	    }

	    /**
	     * Patches the 'scroll' method on the Element prototype
	     */
	    function patchElementScroll() {
	        Element.prototype.scroll = function (optionsOrX, y) {
	            handleScrollMethod(this, "scroll", optionsOrX, y);
	        };
	    }

	    /**
	     * Patches the 'scrollBy' method on the Element prototype
	     */
	    function patchElementScrollBy() {
	        Element.prototype.scrollBy = function (optionsOrX, y) {
	            handleScrollMethod(this, "scrollBy", optionsOrX, y);
	        };
	    }

	    /**
	     * Patches the 'scrollTo' method on the Element prototype
	     */
	    function patchElementScrollTo() {
	        Element.prototype.scrollTo = function (optionsOrX, y) {
	            handleScrollMethod(this, "scrollTo", optionsOrX, y);
	        };
	    }

	    /**
	     * Patches the 'scroll' method on the Window prototype
	     */
	    function patchWindowScroll() {
	        window.scroll = function (optionsOrX, y) {
	            handleScrollMethod(this, "scroll", optionsOrX, y);
	        };
	    }

	    /**
	     * Patches the 'scrollBy' method on the Window prototype
	     */
	    function patchWindowScrollBy() {
	        window.scrollBy = function (optionsOrX, y) {
	            handleScrollMethod(this, "scrollBy", optionsOrX, y);
	        };
	    }

	    /**
	     * Patches the 'scrollTo' method on the Window prototype
	     */
	    function patchWindowScrollTo() {
	        window.scrollTo = function (optionsOrX, y) {
	            handleScrollMethod(this, "scrollTo", optionsOrX, y);
	        };
	    }

	    // tslint:disable:no-any
	    /**
	     * Gets the parent of an element, taking into account DocumentFragments, ShadowRoots, as well as the root context (window)
	     * @param {EventTarget} currentElement
	     * @returns {EventTarget | null}
	     */
	    function getParent(currentElement) {
	        if ("nodeType" in currentElement && currentElement.nodeType === 1) {
	            return currentElement.parentNode;
	        }
	        if ("ShadowRoot" in window && currentElement instanceof window.ShadowRoot) {
	            return currentElement.host;
	        }
	        else if (currentElement === document) {
	            return window;
	        }
	        else if (currentElement instanceof Node)
	            return currentElement.parentNode;
	        return null;
	    }

	    /**
	     * Returns true if the given overflow property represents a scrollable overflow value
	     * @param {string | null} overflow
	     * @return {boolean}
	     */
	    function canOverflow(overflow) {
	        return overflow !== "visible" && overflow !== "clip";
	    }
	    /**
	     * Returns true if the given element is scrollable
	     * @param {Element} element
	     * @return {boolean}
	     */
	    function isScrollable(element) {
	        if (element.clientHeight < element.scrollHeight || element.clientWidth < element.scrollWidth) {
	            var style = getComputedStyle(element, null);
	            return canOverflow(style.overflowY) || canOverflow(style.overflowX);
	        }
	        return false;
	    }
	    /**
	     * Finds the nearest ancestor of an element that can scroll
	     * @param {Element} target
	     * @returns {Element|Window?}
	     */
	    function findNearestAncestorsWithScrollBehavior(target) {
	        var currentElement = target;
	        var scrollingElement = getScrollingElement();
	        while (currentElement != null) {
	            var behavior = getScrollBehavior(currentElement);
	            if (behavior != null && (currentElement === scrollingElement || isScrollable(currentElement))) {
	                return [currentElement, behavior];
	            }
	            var parent_1 = getParent(currentElement);
	            currentElement = parent_1;
	        }
	        // No such element could be found. Start over, but this time find the nearest ancestor that can simply scroll
	        currentElement = target;
	        while (currentElement != null) {
	            if (currentElement === scrollingElement || isScrollable(currentElement)) {
	                return [currentElement, "auto"];
	            }
	            var parent_2 = getParent(currentElement);
	            currentElement = parent_2;
	        }
	        // Default to the scrolling element
	        return [scrollingElement, "auto"];
	    }

	    // tslint:disable:no-any
	    /**
	     * Finds the nearest root from an element
	     * @param {Element} target
	     * @returns {Document|ShadowRoot}
	     */
	    function findNearestRoot(target) {
	        var currentElement = target;
	        while (currentElement != null) {
	            if ("ShadowRoot" in window && currentElement instanceof window.ShadowRoot) {
	                // Assume this is a ShadowRoot
	                return currentElement;
	            }
	            var parent_1 = getParent(currentElement);
	            if (parent_1 === currentElement) {
	                return document;
	            }
	            currentElement = parent_1;
	        }
	        return document;
	    }

	    /**
	     * Gets the origin of the given Location or HTMLAnchorElement if available in the runtime, and otherwise shims it. (it's a one-liner)
	     * @returns {string}
	     */
	    function getLocationOrigin(locationLike) {
	        if (locationLike === void 0) { locationLike = location; }
	        if ("origin" in locationLike && locationLike.origin != null) {
	            return locationLike.origin;
	        }
	        var port = locationLike.port != null && locationLike.port.length > 0 ? ":" + locationLike.port : "";
	        if (locationLike.protocol === "http:" && port === ":80") {
	            port = "";
	        }
	        else if (locationLike.protocol === "https:" && port === ":443") {
	            port = "";
	        }
	        return locationLike.protocol + "//" + locationLike.hostname + port;
	    }

	    /**
	     * A Regular expression that matches id's of the form "#[digit]"
	     * @type {RegExp}
	     */
	    var ID_WITH_LEADING_DIGIT_REGEXP = /^#\d/;
	    /**
	     * Catches anchor navigation to IDs within the same root and ensures that they can be smooth-scrolled
	     * if the scroll behavior is smooth in the first rooter within that context
	     */
	    function catchNavigation() {
	        // Listen for 'click' events globally
	        window.addEventListener("click", function (e) {
	            // Only work with trusted events on HTMLAnchorElements
	            if (!e.isTrusted || !(e.target instanceof HTMLAnchorElement))
	                return;
	            var _a = e.target, pathname = _a.pathname, search = _a.search, hash = _a.hash;
	            var pointsToCurrentPage = getLocationOrigin(e.target) === getLocationOrigin(location) && pathname === location.pathname && search === location.search;
	            // Only work with HTMLAnchorElements that navigates to a specific ID on the current page
	            if (!pointsToCurrentPage || hash == null || hash.length < 1) {
	                return;
	            }
	            // Find the nearest root, whether it be a ShadowRoot or the document itself
	            var root = findNearestRoot(e.target);
	            // Attempt to match the selector from that root. querySelector' doesn't support IDs that start with a digit, so work around that limitation
	            var elementMatch = hash.match(ID_WITH_LEADING_DIGIT_REGEXP) != null ? root.getElementById(hash.slice(1)) : root.querySelector(hash);
	            // If no selector could be found, don't proceed
	            if (elementMatch == null)
	                return;
	            // Find the nearest ancestor that can be scrolled
	            var _b = __read(findNearestAncestorsWithScrollBehavior(elementMatch), 2), behavior = _b[1];
	            // If the behavior isn't smooth, don't proceed
	            if (behavior !== "smooth")
	                return;
	            // Otherwise, first prevent the default action.
	            e.preventDefault();
	            // Now, scroll to the element with that ID
	            elementMatch.scrollIntoView({
	                behavior: behavior
	            });
	        });
	    }

	    var ELEMENT_ORIGINAL_SCROLL_INTO_VIEW = UNSUPPORTED_ENVIRONMENT ? undefined : Element.prototype.scrollIntoView;

	    /**
	     * The majority of this file is based on https://github.com/stipsan/compute-scroll-into-view (MIT license),
	     * but has been rewritten to accept a scroller as an argument.
	     */
	    /**
	     * Find out which edge to align against when logical scroll position is "nearest"
	     * Interesting fact: "nearest" works similarly to "if-needed", if the element is fully visible it will not scroll it
	     *
	     * Legends:
	     * ┌────────┐ ┏ ━ ━ ━ ┓
	     * │ target │   frame
	     * └────────┘ ┗ ━ ━ ━ ┛
	     */
	    function alignNearest(scrollingEdgeStart, scrollingEdgeEnd, scrollingSize, scrollingBorderStart, scrollingBorderEnd, elementEdgeStart, elementEdgeEnd, elementSize) {
	        /**
	         * If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B
	         *
	         *          ┌──┐
	         *        ┏━│━━│━┓
	         *          │  │
	         *        ┃ │  │ ┃        do nothing
	         *          │  │
	         *        ┗━│━━│━┛
	         *          └──┘
	         *
	         *  If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D
	         *
	         *    ┏ ━ ━ ━ ━ ┓
	         *   ┌───────────┐
	         *   │┃         ┃│        do nothing
	         *   └───────────┘
	         *    ┗ ━ ━ ━ ━ ┛
	         */
	        if ((elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd) ||
	            (elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd)) {
	            return 0;
	        }
	        /**
	         * If element edge A is outside scrolling box edge A and element height is less than scrolling box height
	         *
	         *          ┌──┐
	         *        ┏━│━━│━┓         ┏━┌━━┐━┓
	         *          └──┘             │  │
	         *  from  ┃      ┃     to  ┃ └──┘ ┃
	         *
	         *        ┗━ ━━ ━┛         ┗━ ━━ ━┛
	         *
	         * If element edge B is outside scrolling box edge B and element height is greater than scrolling box height
	         *
	         *        ┏━ ━━ ━┓         ┏━┌━━┐━┓
	         *                           │  │
	         *  from  ┃ ┌──┐ ┃     to  ┃ │  │ ┃
	         *          │  │             │  │
	         *        ┗━│━━│━┛         ┗━│━━│━┛
	         *          │  │             └──┘
	         *          │  │
	         *          └──┘
	         *
	         * If element edge C is outside scrolling box edge C and element width is less than scrolling box width
	         *
	         *       from                 to
	         *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓
	         *  ┌───┐                 ┌───┐
	         *  │ ┃ │       ┃         ┃   │     ┃
	         *  └───┘                 └───┘
	         *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛
	         *
	         * If element edge D is outside scrolling box edge D and element width is greater than scrolling box width
	         *
	         *       from                 to
	         *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓
	         *        ┌───────────┐   ┌───────────┐
	         *    ┃   │     ┃     │   ┃         ┃ │
	         *        └───────────┘   └───────────┘
	         *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛
	         */
	        if ((elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize) ||
	            (elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize)) {
	            return elementEdgeStart - scrollingEdgeStart - scrollingBorderStart;
	        }
	        /**
	         * If element edge B is outside scrolling box edge B and element height is less than scrolling box height
	         *
	         *        ┏━ ━━ ━┓         ┏━ ━━ ━┓
	         *
	         *  from  ┃      ┃     to  ┃ ┌──┐ ┃
	         *          ┌──┐             │  │
	         *        ┗━│━━│━┛         ┗━└━━┘━┛
	         *          └──┘
	         *
	         * If element edge A is outside scrolling box edge A and element height is greater than scrolling box height
	         *
	         *          ┌──┐
	         *          │  │
	         *          │  │             ┌──┐
	         *        ┏━│━━│━┓         ┏━│━━│━┓
	         *          │  │             │  │
	         *  from  ┃ └──┘ ┃     to  ┃ │  │ ┃
	         *                           │  │
	         *        ┗━ ━━ ━┛         ┗━└━━┘━┛
	         *
	         * If element edge C is outside scrolling box edge C and element width is greater than scrolling box width
	         *
	         *           from                 to
	         *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓
	         *  ┌───────────┐           ┌───────────┐
	         *  │     ┃     │   ┃       │ ┃         ┃
	         *  └───────────┘           └───────────┘
	         *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛
	         *
	         * If element edge D is outside scrolling box edge D and element width is less than scrolling box width
	         *
	         *           from                 to
	         *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓
	         *                ┌───┐             ┌───┐
	         *        ┃       │ ┃ │       ┃     │   ┃
	         *                └───┘             └───┘
	         *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛
	         *
	         */
	        if ((elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize) || (elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize)) {
	            return elementEdgeEnd - scrollingEdgeEnd + scrollingBorderEnd;
	        }
	        return 0;
	    }
	    function computeScrollIntoView(target, scroller, options) {
	        var block = options.block, inline = options.inline;
	        // Used to handle the top most element that can be scrolled
	        var scrollingElement = getScrollingElement();
	        // Support pinch-zooming properly, making sure elements scroll into the visual viewport
	        // Browsers that don't support visualViewport will report the layout viewport dimensions on document.documentElement.clientWidth/Height
	        // and viewport dimensions on window.innerWidth/Height
	        // https://www.quirksmode.org/mobile/viewports2.html
	        // https://bokand.github.io/viewport/index.html
	        var viewportWidth = window.visualViewport != null ? visualViewport.width : innerWidth;
	        var viewportHeight = window.visualViewport != null ? visualViewport.height : innerHeight;
	        var viewportX = window.scrollX != null ? window.scrollX : window.pageXOffset;
	        var viewportY = window.scrollY != null ? window.scrollY : window.pageYOffset;
	        var _a = target.getBoundingClientRect(), targetHeight = _a.height, targetWidth = _a.width, targetTop = _a.top, targetRight = _a.right, targetBottom = _a.bottom, targetLeft = _a.left;
	        // These values mutate as we loop through and generate scroll coordinates
	        var targetBlock = block === "start" || block === "nearest" ? targetTop : block === "end" ? targetBottom : targetTop + targetHeight / 2; // block === 'center
	        var targetInline = inline === "center" ? targetLeft + targetWidth / 2 : inline === "end" ? targetRight : targetLeft; // inline === 'start || inline === 'nearest
	        var _b = scroller.getBoundingClientRect(), height = _b.height, width = _b.width, top = _b.top, right = _b.right, bottom = _b.bottom, left = _b.left;
	        var frameStyle = getComputedStyle(scroller);
	        var borderLeft = parseInt(frameStyle.borderLeftWidth, 10);
	        var borderTop = parseInt(frameStyle.borderTopWidth, 10);
	        var borderRight = parseInt(frameStyle.borderRightWidth, 10);
	        var borderBottom = parseInt(frameStyle.borderBottomWidth, 10);
	        var blockScroll = 0;
	        var inlineScroll = 0;
	        // The property existance checks for offset[Width|Height] is because only HTMLElement objects have them, but any Element might pass by here
	        // @TODO find out if the "as HTMLElement" overrides can be dropped
	        var scrollbarWidth = "offsetWidth" in scroller ? scroller.offsetWidth - scroller.clientWidth - borderLeft - borderRight : 0;
	        var scrollbarHeight = "offsetHeight" in scroller ? scroller.offsetHeight - scroller.clientHeight - borderTop - borderBottom : 0;
	        if (scrollingElement === scroller) {
	            // Handle viewport logic (document.documentElement or document.body)
	            if (block === "start") {
	                blockScroll = targetBlock;
	            }
	            else if (block === "end") {
	                blockScroll = targetBlock - viewportHeight;
	            }
	            else if (block === "nearest") {
	                blockScroll = alignNearest(viewportY, viewportY + viewportHeight, viewportHeight, borderTop, borderBottom, viewportY + targetBlock, viewportY + targetBlock + targetHeight, targetHeight);
	            }
	            else {
	                // block === 'center' is the default
	                blockScroll = targetBlock - viewportHeight / 2;
	            }
	            if (inline === "start") {
	                inlineScroll = targetInline;
	            }
	            else if (inline === "center") {
	                inlineScroll = targetInline - viewportWidth / 2;
	            }
	            else if (inline === "end") {
	                inlineScroll = targetInline - viewportWidth;
	            }
	            else {
	                // inline === 'nearest' is the default
	                inlineScroll = alignNearest(viewportX, viewportX + viewportWidth, viewportWidth, borderLeft, borderRight, viewportX + targetInline, viewportX + targetInline + targetWidth, targetWidth);
	            }
	            // Apply scroll position offsets and ensure they are within bounds
	            // @TODO add more test cases to cover this 100%
	            blockScroll = Math.max(0, blockScroll + viewportY);
	            inlineScroll = Math.max(0, inlineScroll + viewportX);
	        }
	        else {
	            // Handle each scrolling frame that might exist between the target and the viewport
	            if (block === "start") {
	                blockScroll = targetBlock - top - borderTop;
	            }
	            else if (block === "end") {
	                blockScroll = targetBlock - bottom + borderBottom + scrollbarHeight;
	            }
	            else if (block === "nearest") {
	                blockScroll = alignNearest(top, bottom, height, borderTop, borderBottom + scrollbarHeight, targetBlock, targetBlock + targetHeight, targetHeight);
	            }
	            else {
	                // block === 'center' is the default
	                blockScroll = targetBlock - (top + height / 2) + scrollbarHeight / 2;
	            }
	            if (inline === "start") {
	                inlineScroll = targetInline - left - borderLeft;
	            }
	            else if (inline === "center") {
	                inlineScroll = targetInline - (left + width / 2) + scrollbarWidth / 2;
	            }
	            else if (inline === "end") {
	                inlineScroll = targetInline - right + borderRight + scrollbarWidth;
	            }
	            else {
	                // inline === 'nearest' is the default
	                inlineScroll = alignNearest(left, right, width, borderLeft, borderRight + scrollbarWidth, targetInline, targetInline + targetWidth, targetWidth);
	            }
	            var scrollLeft = scroller.scrollLeft, scrollTop = scroller.scrollTop;
	            // Ensure scroll coordinates are not out of bounds while applying scroll offsets
	            blockScroll = Math.max(0, Math.min(scrollTop + blockScroll, scroller.scrollHeight - height + scrollbarHeight));
	            inlineScroll = Math.max(0, Math.min(scrollLeft + inlineScroll, scroller.scrollWidth - width + scrollbarWidth));
	        }
	        return {
	            top: blockScroll,
	            left: inlineScroll
	        };
	    }

	    /**
	     * Patches the 'scrollIntoView' method on the Element prototype
	     */
	    function patchElementScrollIntoView() {
	        Element.prototype.scrollIntoView = function (arg) {
	            var normalizedOptions = arg == null || arg === true
	                ? {
	                    block: "start",
	                    inline: "nearest"
	                }
	                : arg === false
	                    ? {
	                        block: "end",
	                        inline: "nearest"
	                    }
	                    : arg;
	            // Find the nearest ancestor that can be scrolled
	            var _a = __read(findNearestAncestorsWithScrollBehavior(this), 2), ancestorWithScroll = _a[0], ancestorWithScrollBehavior = _a[1];
	            var behavior = normalizedOptions.behavior != null ? normalizedOptions.behavior : ancestorWithScrollBehavior;
	            // If the behavior isn't smooth, simply invoke the original implementation and do no more
	            if (behavior !== "smooth") {
	                // Assert that 'scrollIntoView' is actually defined
	                if (ELEMENT_ORIGINAL_SCROLL_INTO_VIEW != null) {
	                    ELEMENT_ORIGINAL_SCROLL_INTO_VIEW.call(this, normalizedOptions);
	                }
	                // Otherwise, invoke 'scrollTo' instead and provide the scroll coordinates
	                else {
	                    var _b = computeScrollIntoView(this, ancestorWithScroll, normalizedOptions), top_1 = _b.top, left = _b.left;
	                    getOriginalScrollMethodForKind("scrollTo", this).call(this, left, top_1);
	                }
	                return;
	            }
	            ancestorWithScroll.scrollTo(__assign({ behavior: behavior }, computeScrollIntoView(this, ancestorWithScroll, normalizedOptions)));
	        };
	        // On IE11, HTMLElement has its own declaration of scrollIntoView and does not inherit this from the prototype chain, so we'll need to patch that one too.
	        if (HTMLElement.prototype.scrollIntoView != null && HTMLElement.prototype.scrollIntoView !== Element.prototype.scrollIntoView) {
	            HTMLElement.prototype.scrollIntoView = Element.prototype.scrollIntoView;
	        }
	    }

	    var ELEMENT_ORIGINAL_SCROLL_TOP_SET_DESCRIPTOR = UNSUPPORTED_ENVIRONMENT
	        ? undefined
	        : Object.getOwnPropertyDescriptor(Element.prototype, "scrollTop").set;

	    /**
	     * Patches the 'scrollTop' property descriptor on the Element prototype
	     */
	    function patchElementScrollTop() {
	        Object.defineProperty(Element.prototype, "scrollTop", {
	            set: function (scrollTop) {
	                if (this.__adjustingScrollPosition) {
	                    return ELEMENT_ORIGINAL_SCROLL_TOP_SET_DESCRIPTOR.call(this, scrollTop);
	                }
	                handleScrollMethod(this, "scrollTo", this.scrollLeft, scrollTop);
	                return scrollTop;
	            }
	        });
	    }

	    var ELEMENT_ORIGINAL_SCROLL_LEFT_SET_DESCRIPTOR = UNSUPPORTED_ENVIRONMENT
	        ? undefined
	        : Object.getOwnPropertyDescriptor(Element.prototype, "scrollLeft").set;

	    /**
	     * Patches the 'scrollLeft' property descriptor on the Element prototype
	     */
	    function patchElementScrollLeft() {
	        Object.defineProperty(Element.prototype, "scrollLeft", {
	            set: function (scrollLeft) {
	                if (this.__adjustingScrollPosition) {
	                    return ELEMENT_ORIGINAL_SCROLL_LEFT_SET_DESCRIPTOR.call(this, scrollLeft);
	                }
	                handleScrollMethod(this, "scrollTo", scrollLeft, this.scrollTop);
	                return scrollLeft;
	            }
	        });
	    }

	    /**
	     * Applies the polyfill
	     */
	    function patch() {
	        // Element.prototype methods
	        patchElementScroll();
	        patchElementScrollBy();
	        patchElementScrollTo();
	        patchElementScrollIntoView();
	        // Element.prototype descriptors
	        patchElementScrollLeft();
	        patchElementScrollTop();
	        // window methods
	        patchWindowScroll();
	        patchWindowScrollBy();
	        patchWindowScrollTo();
	        // Navigation
	        catchNavigation();
	    }

	    /**
	     * Is true if the browser natively supports the Element.prototype.[scroll|scrollTo|scrollBy|scrollIntoView] methods
	     * @type {boolean}
	     */
	    var SUPPORTS_ELEMENT_PROTOTYPE_SCROLL_METHODS = UNSUPPORTED_ENVIRONMENT
	        ? false
	        : "scroll" in Element.prototype && "scrollTo" in Element.prototype && "scrollBy" in Element.prototype && "scrollIntoView" in Element.prototype;

	    if (!UNSUPPORTED_ENVIRONMENT && (!SUPPORTS_SCROLL_BEHAVIOR || !SUPPORTS_ELEMENT_PROTOTYPE_SCROLL_METHODS)) {
	        patch();
	    }

	}());
	
	return dist;
}

var loader_cjs = {};

var alignLabel7a9d9074 = {};

var hasRequiredAlignLabel7a9d9074;

function requireAlignLabel7a9d9074 () {
	if (hasRequiredAlignLabel7a9d9074) return alignLabel7a9d9074;
	hasRequiredAlignLabel7a9d9074 = 1;

	// 'left' is deprecated and will be mapped to 'start'
	// 'right' is deprecated and will be mapped to 'end'
	/** @deprecated */
	const ALIGN_LABELS_DEPRECATED = ['left', 'right'];
	const ALIGN_LABELS = ['start', 'end', ...ALIGN_LABELS_DEPRECATED];

	alignLabel7a9d9074.ALIGN_LABELS = ALIGN_LABELS;

	
	return alignLabel7a9d9074;
}

var appGlobals999bcb42 = {};

var getCDNBaseURLE7722df3 = {};

var hasRequiredGetCDNBaseURLE7722df3;

function requireGetCDNBaseURLE7722df3 () {
	if (hasRequiredGetCDNBaseURLE7722df3) return getCDNBaseURLE7722df3;
	hasRequiredGetCDNBaseURLE7722df3 = 1;

	const getCDNBaseURL = () => document.porscheDesignSystem.cdn.url + "/porsche-design-system";

	getCDNBaseURLE7722df3.getCDNBaseURL = getCDNBaseURL;

	
	return getCDNBaseURLE7722df3;
}

var hasRequiredAppGlobals999bcb42;

function requireAppGlobals999bcb42 () {
	if (hasRequiredAppGlobals999bcb42) return appGlobals999bcb42;
	hasRequiredAppGlobals999bcb42 = 1;

	const validateProps = requireValidatePropsF6586828();
	const getCDNBaseURL = requireGetCDNBaseURLE7722df3();

	const FONT_FACE_CDN_FILE_COM = 'font-face.min.411a644e410cecb29d61874e179032f8.css';
	const FONT_FACE_CDN_FILE_CN = 'font-face.min.cn.640bec695bc74bd0b73d489f3cb2670f.css';

	const validatePartialUsage = () => {
	    // TODO: before reactivating we need to be able to distinguish between Light DOM and/or Shadow DOM usage.
	    // validateGetInitialStylesUsage();
	    validateGetFontFaceStylesUsage();
	    validateGetFontLinksUsage();
	    // TODO: integration test (real world test) first, before rollout
	    // validateGetLoaderScriptUsage();
	    // validateGetComponentChunkLinksUsage();
	};
	const validateGetFontFaceStylesUsage = () => {
	    const baseUrl = getCDNBaseURL.getCDNBaseURL();
	    const styleUrl = `${baseUrl}/styles/${baseUrl.match(/\.cn\//) ? FONT_FACE_CDN_FILE_CN : FONT_FACE_CDN_FILE_COM}`
	        ;
	    if (!document.head.querySelector(`link[href="${styleUrl}"],style[data-pds-font-face-styles=""]`)) {
	        logPartialValidationWarning('getFontFaceStyles');
	    }
	};
	const validateGetFontLinksUsage = () => {
	    if (!document.head.querySelector('link[rel=preload][as=font][href*=porsche-next-w-la-regular]')) {
	        logPartialValidationWarning('getFontLinks');
	    }
	};
	const logPartialValidationWarning = (partialName, prefix) => {
	    validateProps.consoleWarn(getValidatePartialErrorPrimaryText(partialName, prefix), getValidatePartialErrorSecondaryText(partialName));
	};
	const getValidatePartialErrorPrimaryText = (partialName, prefix) => {
	    return `The Porsche Design System ${prefix ? `with prefix: '${prefix}' ` : ''}is used without using the ${partialName}() partial.`;
	};
	const getValidatePartialErrorSecondaryText = (partialName, required) => {
	    const partialUrl = partialName
	        .replace('get', '')
	        .replace(/([a-z])([A-Z])/g, '$1-$2') // camelCase to param-case
	        .toLowerCase();
	    return `The usage of the ${partialName}() partial is ${required ? 'required' : 'recommended'} as described at https://designsystem.porsche.com/v3/partials/${partialUrl} to enhance loading behavior.`;
	};

	// TODO: should be removed, instead consumers should be forced via validation to use the partial for preloading
	const injectGlobalStyle = () => {
	    if (typeof document !== 'undefined' && "production" === 'production') {
	        const baseUrl = getCDNBaseURL.getCDNBaseURL();
	        const styleUrl = `${baseUrl}/styles/${baseUrl.match(/\.cn\//) ? FONT_FACE_CDN_FILE_CN : FONT_FACE_CDN_FILE_COM}`;
	        const { head } = document;
	        if (!head.querySelector(`link[href='${styleUrl}'],style[data-pds-font-face-styles=""]`)) {
	            const link = document.createElement('link');
	            link.href = styleUrl;
	            link.type = 'text/css';
	            link.rel = 'stylesheet';
	            head.appendChild(link);
	        }
	    }
	};

	// Timout after which the version validation will happen to increase changes of different versions being loaded and initialized
	const VERSION_VALIDATION_TIMEOUT = 3000;
	/**
	 * Validates the versions of the Porsche Design System and logs a warning if multiple different versions are detected.
	 *
	 * This is in particular problematic since multiple versions can initialize at different times.
	 * You cannot know when all versions are initialized and versions can be loaded only on particular pages. You have to consider having a mix of versions with the validation logic and without.
	 * You would need to detect changes to the document.porscheDesignSystem object and fire a validation on every change.
	 * This would be possible with a proxy which is only created once, but it would still only warn about the versions initialized at the time.
	 * Also, it makes it difficult to change the implementation in the future since it cannot be overwritten by another proxy.
	 * Another approach could be using the stencil 'appload' event (https://stenciljs.com/docs/api), which is already included in older versions of the design system.
	 * More information about other implementations can be found in the PR: https://github.com/porsche-design-system/porsche-design-system/pull/2867
	 */
	const validateVersions = () => {
	    // skip for yarn start
	    {
	        // Uses a timeout to increase the chances that all used versions are loaded and initialized
	        setTimeout(() => {
	            // eslint-disable-next-line @typescript-eslint/no-unused-vars
	            const { cdn, ...versions } = document.porscheDesignSystem;
	            if (Object.keys(versions).length > 1) {
	                validateProps.consoleWarn(
	                // eslint-disable-next-line @typescript-eslint/quotes
	                "Multiple different versions detected!\nWhile bootstrapping multiple versions is valid, it's highly recommended to upgrade all instances to the latest version in use for the best performance.\nRefer to the document.porscheDesignSystem object for detailed information on the current versions in use.\n", document.porscheDesignSystem);
	            }
	        }, VERSION_VALIDATION_TIMEOUT);
	    }
	};

	const appGlobalScript = () => {
	    {
	        // not available during `yarn start` of components package
	        document.porscheDesignSystem["3.15.0-rc.5"].readyResolve(); // provided via load() of components-js package
	    }
	    injectGlobalStyle();
	    validatePartialUsage();
	    validateVersions();
	};

	const globalScripts = appGlobalScript;

	appGlobals999bcb42.globalScripts = globalScripts;

	
	return appGlobals999bcb42;
}

var bannerUtils2cc83734 = {};

var hasRequiredBannerUtils2cc83734;

function requireBannerUtils2cc83734 () {
	if (hasRequiredBannerUtils2cc83734) return bannerUtils2cc83734;
	hasRequiredBannerUtils2cc83734 = 1;

	/** @deprecated */
	const BANNER_STATES_DEPRECATED = ['neutral'];
	const BANNER_STATES = ['info', 'warning', 'error', ...BANNER_STATES_DEPRECATED];

	bannerUtils2cc83734.BANNER_STATES = BANNER_STATES;

	
	return bannerUtils2cc83734;
}

var borderRadiusLargeA0aa3a01 = {};

var hasRequiredBorderRadiusLargeA0aa3a01;

function requireBorderRadiusLargeA0aa3a01 () {
	if (hasRequiredBorderRadiusLargeA0aa3a01) return borderRadiusLargeA0aa3a01;
	hasRequiredBorderRadiusLargeA0aa3a01 = 1;

	const borderRadiusLarge = '12px';

	borderRadiusLargeA0aa3a01.borderRadiusLarge = borderRadiusLarge;

	
	return borderRadiusLargeA0aa3a01;
}

var borderRadiusMedium758b9411 = {};

var hasRequiredBorderRadiusMedium758b9411;

function requireBorderRadiusMedium758b9411 () {
	if (hasRequiredBorderRadiusMedium758b9411) return borderRadiusMedium758b9411;
	hasRequiredBorderRadiusMedium758b9411 = 1;

	const borderRadiusMedium = '8px';

	borderRadiusMedium758b9411.borderRadiusMedium = borderRadiusMedium;

	
	return borderRadiusMedium758b9411;
}

var borderRadiusSmall5f37fc45 = {};

var hasRequiredBorderRadiusSmall5f37fc45;

function requireBorderRadiusSmall5f37fc45 () {
	if (hasRequiredBorderRadiusSmall5f37fc45) return borderRadiusSmall5f37fc45;
	hasRequiredBorderRadiusSmall5f37fc45 = 1;

	const borderRadiusSmall = '4px';

	borderRadiusSmall5f37fc45.borderRadiusSmall = borderRadiusSmall;

	
	return borderRadiusSmall5f37fc45;
}

var buttonHandlingB33ae166 = {};

var getClosestHTMLElement83d01a84 = {};

var hasRequiredGetClosestHTMLElement83d01a84;

function requireGetClosestHTMLElement83d01a84 () {
	if (hasRequiredGetClosestHTMLElement83d01a84) return getClosestHTMLElement83d01a84;
	hasRequiredGetClosestHTMLElement83d01a84 = 1;

	/* eslint-disable prefer-arrow/prefer-arrow-functions */
	function getClosestHTMLElement(element, selector) {
	    return element?.closest(selector);
	}

	getClosestHTMLElement83d01a84.getClosestHTMLElement = getClosestHTMLElement;

	
	return getClosestHTMLElement83d01a84;
}

var setAttributes642a7e67 = {};

var hasRequiredSetAttributes642a7e67;

function requireSetAttributes642a7e67 () {
	if (hasRequiredSetAttributes642a7e67) return setAttributes642a7e67;
	hasRequiredSetAttributes642a7e67 = 1;

	/**
	 * Sets attributes on an HTMLElement.
	 *
	 * @param {HTMLElement} host - The target HTMLElement to set attributes on.
	 * @param {{ [x: string]: string }} attributes - An object of attribute names and their corresponding values.
	 * @returns {void}
	 */
	const setAttributes = (host, attributes) => Object.entries(attributes).forEach((args) => host.setAttribute(...args));

	setAttributes642a7e67.setAttributes = setAttributes;

	
	return setAttributes642a7e67;
}

var hasRequiredButtonHandlingB33ae166;

function requireButtonHandlingB33ae166 () {
	if (hasRequiredButtonHandlingB33ae166) return buttonHandlingB33ae166;
	hasRequiredButtonHandlingB33ae166 = 1;

	requireValidatePropsF6586828();
	const getClosestHTMLElement = requireGetClosestHTMLElement83d01a84();
	const setAttributes = requireSetAttributes642a7e67();

	const improveButtonHandlingForCustomElement = (element, getType, getDisabled, getName, getValue) => {
	    element.addEventListener('click', (event) => handleButtonEvent(event, element, getType, getDisabled, getName, getValue));
	};
	const handleButtonEvent = (event, element, getType, getDisabled, getName, getValue) => {
	    // Why? That's why: https://hjorthhansen.dev/shadow-dom-and-forms/
	    const form = getClosestHTMLElement.getClosestHTMLElement(element, 'form');
	    if (form && !getDisabled()) {
	        /**
	         * we've to wait if someone calls preventDefault on the event
	         * then we shouldn't submit the form
	         */
	        window.setTimeout(() => {
	            if (!event.defaultPrevented) {
	                const name = getName?.();
	                const value = getValue?.();
	                const fakeButton = document.createElement('button');
	                setAttributes.setAttributes(fakeButton, {
	                    ...(name && { name }),
	                    ...(value && { value }),
	                    type: getType(),
	                });
	                fakeButton.style.display = 'none';
	                form.appendChild(fakeButton);
	                fakeButton.addEventListener('click', (fakeButtonEvent) => {
	                    fakeButtonEvent.stopPropagation();
	                });
	                fakeButton.click();
	                fakeButton.remove();
	            }
	        }, 1);
	    }
	};

	buttonHandlingB33ae166.handleButtonEvent = handleButtonEvent;
	buttonHandlingB33ae166.improveButtonHandlingForCustomElement = improveButtonHandlingForCustomElement;

	
	return buttonHandlingB33ae166;
}

var buttonLinkPureUtils1db4d1d1 = {};

var isParentOfKindB7d9f81c = {};

var hasRequiredIsParentOfKindB7d9f81c;

function requireIsParentOfKindB7d9f81c () {
	if (hasRequiredIsParentOfKindB7d9f81c) return isParentOfKindB7d9f81c;
	hasRequiredIsParentOfKindB7d9f81c = 1;

	const validateProps = requireValidatePropsF6586828();

	const isParentOfKind = (element, tagName) => {
	    const { parentElement } = element;
	    return parentElement && validateProps.getTagNameWithoutPrefix(parentElement) === tagName;
	};

	isParentOfKindB7d9f81c.isParentOfKind = isParentOfKind;

	
	return isParentOfKindB7d9f81c;
}

var hasRequiredButtonLinkPureUtils1db4d1d1;

function requireButtonLinkPureUtils1db4d1d1 () {
	if (hasRequiredButtonLinkPureUtils1db4d1d1) return buttonLinkPureUtils1db4d1d1;
	hasRequiredButtonLinkPureUtils1db4d1d1 = 1;

	const validateProps = requireValidatePropsF6586828();
	const isParentOfKind = requireIsParentOfKindB7d9f81c();

	const hasVisibleIcon = (iconName, iconSource) => {
	    return iconName !== 'none' || !!iconSource;
	};
	const warnIfParentIsPTextAndIconIsNone = (host, iconName, iconSource) => {
	    if (!hasVisibleIcon(iconName, iconSource) && isParentOfKind.isParentOfKind(host, 'p-text')) {
	        validateProps.consoleWarn(`${validateProps.getTagNameWithoutPrefix(host)} should not be used inside p-text. Please use a <button> or <a> tag.`);
	    }
	};

	buttonLinkPureUtils1db4d1d1.hasVisibleIcon = hasVisibleIcon;
	buttonLinkPureUtils1db4d1d1.warnIfParentIsPTextAndIconIsNone = warnIfParentIsPTextAndIconIsNone;

	
	return buttonLinkPureUtils1db4d1d1;
}

var buttonTypeAe0c09db = {};

var hasRequiredButtonTypeAe0c09db;

function requireButtonTypeAe0c09db () {
	if (hasRequiredButtonTypeAe0c09db) return buttonTypeAe0c09db;
	hasRequiredButtonTypeAe0c09db = 1;

	const BUTTON_ARIA_ATTRIBUTES = ['aria-label', 'aria-expanded', 'aria-pressed', 'aria-haspopup'];

	const BUTTON_TYPES = ['button', 'submit', 'reset'];

	buttonTypeAe0c09db.BUTTON_ARIA_ATTRIBUTES = BUTTON_ARIA_ATTRIBUTES;
	buttonTypeAe0c09db.BUTTON_TYPES = BUTTON_TYPES;

	
	return buttonTypeAe0c09db;
}

var checkboxRadioStylesE83cbdf9 = {};

var isDisabledOrLoadingB1f56d7f = {};

var hasRequiredIsDisabledOrLoadingB1f56d7f;

function requireIsDisabledOrLoadingB1f56d7f () {
	if (hasRequiredIsDisabledOrLoadingB1f56d7f) return isDisabledOrLoadingB1f56d7f;
	hasRequiredIsDisabledOrLoadingB1f56d7f = 1;

	const isDisabledOrLoading = (disabled, loading) => {
	    return disabled || loading;
	};

	isDisabledOrLoadingB1f56d7f.isDisabledOrLoading = isDisabledOrLoading;

	
	return isDisabledOrLoadingB1f56d7f;
}

var hoverMediaQuery5e6deda8 = {};

var hasRequiredHoverMediaQuery5e6deda8;

function requireHoverMediaQuery5e6deda8 () {
	if (hasRequiredHoverMediaQuery5e6deda8) return hoverMediaQuery5e6deda8;
	hasRequiredHoverMediaQuery5e6deda8 = 1;

	/**
	 * utility to wrap jss styles parameter in `@media (hover: hover)`
	 * which is used to not have hover styles on touch devices
	 */
	const hoverMediaQuery = (style) => ({ '@media(hover:hover)': style });

	hoverMediaQuery5e6deda8.hoverMediaQuery = hoverMediaQuery;

	
	return hoverMediaQuery5e6deda8;
}

var requiredF3c463a3 = {};

var hasNamedSlotA96fd22a = {};

var getNamedSlotA0cdbdbc = {};

var hasRequiredGetNamedSlotA0cdbdbc;

function requireGetNamedSlotA0cdbdbc () {
	if (hasRequiredGetNamedSlotA0cdbdbc) return getNamedSlotA0cdbdbc;
	hasRequiredGetNamedSlotA0cdbdbc = 1;

	const validateProps = requireValidatePropsF6586828();

	const getNamedSlot = (el, slotName) => validateProps.getHTMLElement(el, `[slot="${slotName}"]`);

	getNamedSlotA0cdbdbc.getNamedSlot = getNamedSlot;

	
	return getNamedSlotA0cdbdbc;
}

var hasRequiredHasNamedSlotA96fd22a;

function requireHasNamedSlotA96fd22a () {
	if (hasRequiredHasNamedSlotA96fd22a) return hasNamedSlotA96fd22a;
	hasRequiredHasNamedSlotA96fd22a = 1;

	const getNamedSlot = requireGetNamedSlotA0cdbdbc();

	const hasNamedSlot = (el, slotName) => !!getNamedSlot.getNamedSlot(el, slotName);

	hasNamedSlotA96fd22a.hasNamedSlot = hasNamedSlot;

	
	return hasNamedSlotA96fd22a;
}

var spacingStaticXSmallB7d708b8 = {};

var hasRequiredSpacingStaticXSmallB7d708b8;

function requireSpacingStaticXSmallB7d708b8 () {
	if (hasRequiredSpacingStaticXSmallB7d708b8) return spacingStaticXSmallB7d708b8;
	hasRequiredSpacingStaticXSmallB7d708b8 = 1;

	const spacingStaticXSmall = '4px';

	spacingStaticXSmallB7d708b8.spacingStaticXSmall = spacingStaticXSmall;

	
	return spacingStaticXSmallB7d708b8;
}

var textSmallStyle7246779a = {};

var textShared9135e2ef = {};

var fontLineHeight78b03658 = {};

var hasRequiredFontLineHeight78b03658;

function requireFontLineHeight78b03658 () {
	if (hasRequiredFontLineHeight78b03658) return fontLineHeight78b03658;
	hasRequiredFontLineHeight78b03658 = 1;

	const fontFamily = "'Porsche Next','Arial Narrow',Arial,'Heiti SC',SimHei,sans-serif";

	const fontLineHeight = 'calc(6px + 2.125ex)';

	fontLineHeight78b03658.fontFamily = fontFamily;
	fontLineHeight78b03658.fontLineHeight = fontLineHeight;

	
	return fontLineHeight78b03658;
}

var fontWeightRegularD0c768ac = {};

var hasRequiredFontWeightRegularD0c768ac;

function requireFontWeightRegularD0c768ac () {
	if (hasRequiredFontWeightRegularD0c768ac) return fontWeightRegularD0c768ac;
	hasRequiredFontWeightRegularD0c768ac = 1;

	const fontWeightRegular = 400;

	fontWeightRegularD0c768ac.fontWeightRegular = fontWeightRegular;

	
	return fontWeightRegularD0c768ac;
}

var fontVariant6ba3b7cb = {};

var hasRequiredFontVariant6ba3b7cb;

function requireFontVariant6ba3b7cb () {
	if (hasRequiredFontVariant6ba3b7cb) return fontVariant6ba3b7cb;
	hasRequiredFontVariant6ba3b7cb = 1;

	const fontStyleNormal = 'normal';

	const fontVariant = 'normal';

	fontVariant6ba3b7cb.fontStyleNormal = fontStyleNormal;
	fontVariant6ba3b7cb.fontVariant = fontVariant;

	
	return fontVariant6ba3b7cb;
}

var hasRequiredTextShared9135e2ef;

function requireTextShared9135e2ef () {
	if (hasRequiredTextShared9135e2ef) return textShared9135e2ef;
	hasRequiredTextShared9135e2ef = 1;

	const fontLineHeight = requireFontLineHeight78b03658();
	const fontWeightRegular = requireFontWeightRegularD0c768ac();
	const fontVariant = requireFontVariant6ba3b7cb();

	const fontHyphenationStyle = {
	    overflowWrap: 'break-word',
	    hyphens: 'auto',
	};

	const _textFontPartA = `${fontVariant.fontStyleNormal} ${fontVariant.fontVariant} ${fontWeightRegular.fontWeightRegular} `;
	const _textFontPartB = `/${fontLineHeight.fontLineHeight} ${fontLineHeight.fontFamily}`;

	textShared9135e2ef._textFontPartA = _textFontPartA;
	textShared9135e2ef._textFontPartB = _textFontPartB;
	textShared9135e2ef.fontHyphenationStyle = fontHyphenationStyle;

	
	return textShared9135e2ef;
}

var fontSizeTextSmall508930e5 = {};

var hasRequiredFontSizeTextSmall508930e5;

function requireFontSizeTextSmall508930e5 () {
	if (hasRequiredFontSizeTextSmall508930e5) return fontSizeTextSmall508930e5;
	hasRequiredFontSizeTextSmall508930e5 = 1;

	const fontSizeTextSmall = '1rem';

	fontSizeTextSmall508930e5.fontSizeTextSmall = fontSizeTextSmall;

	
	return fontSizeTextSmall508930e5;
}

var hasRequiredTextSmallStyle7246779a;

function requireTextSmallStyle7246779a () {
	if (hasRequiredTextSmallStyle7246779a) return textSmallStyle7246779a;
	hasRequiredTextSmallStyle7246779a = 1;

	const textShared = requireTextShared9135e2ef();
	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();

	const textSmallStyle = {
	    font: `${textShared._textFontPartA}${fontSizeTextSmall.fontSizeTextSmall}${textShared._textFontPartB}`,
	    ...textShared.fontHyphenationStyle,
	};

	textSmallStyle7246779a.textSmallStyle = textSmallStyle;

	
	return textSmallStyle7246779a;
}

var hasRequiredRequiredF3c463a3;

function requireRequiredF3c463a3 () {
	if (hasRequiredRequiredF3c463a3) return requiredF3c463a3;
	hasRequiredRequiredF3c463a3 = 1;

	const validateProps = requireValidatePropsF6586828();
	const hasNamedSlot = requireHasNamedSlotA96fd22a();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const textSmallStyle = requireTextSmallStyle7246779a();

	const FORM_STATES = ['none', 'error', 'success'];

	const getRole = (state) => {
	    return state === 'error' ? 'alert' : state === 'success' ? 'status' : null;
	};

	const hasLabel = (element, label) => {
	    return !!label || hasNamedSlot.hasNamedSlot(element, 'label');
	};

	const hasMessage = (element, message, state) => {
	    return (message || hasNamedSlot.hasNamedSlot(element, 'message')) && ['success', 'error'].includes(state);
	};

	const getThemedFormStateColors = (theme, state) => {
	    const themedColors = validateProps.getThemedColors(theme);
	    return {
	        formStateColor: themedColors[`${state}Color`],
	        formStateHoverColor: themedColors[`${state}ColorDarken`],
	    };
	};

	const getFunctionalComponentStateMessageStyles = (theme, state, additionalDefaultJssStyle) => {
	    return {
	        message: {
	            display: 'flex',
	            gap: spacingStaticXSmall.spacingStaticXSmall,
	            ...textSmallStyle.textSmallStyle,
	            color: getThemedFormStateColors(theme, state).formStateColor,
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                color: getThemedFormStateColors('dark', state).formStateColor,
	            }),
	            transition: validateProps.getTransition('color'),
	            ...additionalDefaultJssStyle,
	        },
	    };
	};

	const getFunctionalComponentRequiredStyles = () => {
	    return {
	        required: {
	            userSelect: 'none',
	        },
	    };
	};

	const messageId = 'message';
	const StateMessage = ({ state, message, theme, host }) => {
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(host);
	    const isErrorState = state === 'error';
	    return (hasMessage(host, message, state) && (validateProps.h("span", { id: messageId, class: "message", role: getRole(state) },
	        validateProps.h(PrefixedTagNames.pIcon, { name: isErrorState ? 'exclamation' : 'check', color: isErrorState ? 'notification-error' : 'notification-success', theme: theme, "aria-hidden": "true" }),
	        message || validateProps.h("slot", { name: "message" }))));
	};

	const Required = () => {
	    return validateProps.h("span", { class: "required" }, " *");
	};

	requiredF3c463a3.FORM_STATES = FORM_STATES;
	requiredF3c463a3.Required = Required;
	requiredF3c463a3.StateMessage = StateMessage;
	requiredF3c463a3.getFunctionalComponentRequiredStyles = getFunctionalComponentRequiredStyles;
	requiredF3c463a3.getFunctionalComponentStateMessageStyles = getFunctionalComponentStateMessageStyles;
	requiredF3c463a3.getThemedFormStateColors = getThemedFormStateColors;
	requiredF3c463a3.hasLabel = hasLabel;
	requiredF3c463a3.hasMessage = hasMessage;
	requiredF3c463a3.messageId = messageId;

	
	return requiredF3c463a3;
}

var hasRequiredCheckboxRadioStylesE83cbdf9;

function requireCheckboxRadioStylesE83cbdf9 () {
	if (hasRequiredCheckboxRadioStylesE83cbdf9) return checkboxRadioStylesE83cbdf9;
	hasRequiredCheckboxRadioStylesE83cbdf9 = 1;

	const validateProps = requireValidatePropsF6586828();
	const isDisabledOrLoading = requireIsDisabledOrLoadingB1f56d7f();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const required = requireRequiredF3c463a3();
	const fontLineHeight = requireFontLineHeight78b03658();
	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();

	/**
	 * Applies a style only on Chromium based browsers by using a media query which is only supported there.
	 * https://browserstack.com/guide/create-browser-specific-css
	 *
	 * @param {JssStyle} style - The style to be applied when the Chromium media query is supported.
	 * @returns {JssStyle} - The Chromium media query containing the style.
	 */
	const supportsChromiumMediaQuery = (style) => ({
	    '@media screen and (-webkit-min-device-pixel-ratio: 0) and (min-resolution: 0.001dpcm)': style,
	});

	const elementsMap = new Map();
	const getElementMap = (element) => {
	    const tagName = element.tagName;
	    if (!elementsMap.has(tagName)) {
	        elementsMap.set(tagName, new Map());
	    }
	    return elementsMap.get(tagName);
	};
	const hasConstructableStylesheetSupport = (() => {
	    try {
	        return typeof new CSSStyleSheet().replaceSync === 'function';
	    }
	    catch {
	        return false;
	    }
	})(); // determine it once
	// TODO: we can get rid of this fix, as soon as p-checkbox-wrapper and p-radio-button-wrapper have been deprecated and
	//  replaced by encapsulated p-checkbox and p-radio-button component
	const applyCheckboxRadioButtonSafariRenderingFix = (element) => {
	    if (hasConstructableStylesheetSupport) {
	        const documentOrShadowRoot = element.getRootNode();
	        const elementMap = getElementMap(element);
	        if (!elementMap.has(documentOrShadowRoot)) {
	            elementMap.set(documentOrShadowRoot, true);
	            // Workaround for Safari >= 16.4 rendering issues (see #3012 for reference).
	            // Checkbox/Radio-Button change is not rendered immediately if input or its label is still hovered.
	            // The same bug appears on keyboard navigation.
	            const sheet = new CSSStyleSheet();
	            sheet.replaceSync(`${element.tagName.toLowerCase()}>input:checked{transform:rotateZ(0)}`);
	            // TODO: for some reason unit test in Docker environment throws TS2339: Property 'push' does not exist on type 'readonly CSSStyleSheet[]'
	            /* eslint-disable @typescript-eslint/prefer-ts-expect-error, @typescript-eslint/ban-ts-comment */
	            // @ts-ignore
	            documentOrShadowRoot.adoptedStyleSheets?.push(sheet);
	        }
	    }
	};

	// TODO: move to form-styles.ts
	const getSlottedCheckboxRadioButtonStyles = (state, isDisabled, isLoading, theme) => {
	    const { primaryColor, contrastMediumColor, contrastHighColor, disabledColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, contrastMediumColor: contrastMediumColorDark, contrastHighColor: contrastHighColorDark, disabledColor: disabledColorDark, } = validateProps.getThemedColors('dark');
	    const { formStateColor, formStateHoverColor } = required.getThemedFormStateColors(theme, state);
	    const { formStateColor: formStateColorDark, formStateHoverColor: formStateHoverColorDark } = required.getThemedFormStateColors('dark', state);
	    const { canvasTextColor } = validateProps.getHighContrastColors();
	    const disabledOrLoading = isDisabledOrLoading.isDisabledOrLoading(isDisabled, isLoading);
	    // TODO: needs to be extracted into a color function
	    const uncheckedColor = disabledOrLoading ? disabledColor : formStateColor || contrastMediumColor;
	    const uncheckedColorDark = disabledOrLoading ? disabledColorDark : formStateColorDark || contrastMediumColorDark;
	    const uncheckedHoverColor = formStateHoverColor || primaryColor;
	    const uncheckedHoverColorDark = formStateHoverColorDark || primaryColorDark;
	    const checkedColor = validateProps.isHighContrastMode
	        ? canvasTextColor
	        : disabledOrLoading
	            ? disabledColor
	            : formStateColor || primaryColor;
	    const checkedColorDark = validateProps.isHighContrastMode
	        ? canvasTextColor
	        : disabledOrLoading
	            ? disabledColorDark
	            : formStateColorDark || primaryColorDark;
	    const checkedHoverColor = formStateHoverColor || contrastHighColor;
	    const checkedHoverColorDark = formStateHoverColorDark || contrastHighColorDark;
	    return {
	        '::slotted': {
	            '&(input)': {
	                width: fontLineHeight.fontLineHeight,
	                height: fontLineHeight.fontLineHeight,
	                font: `${fontSizeTextSmall.fontSizeTextSmall} ${fontLineHeight.fontFamily}`, // needed for correct width and height definition based on ex-unit
	                display: 'block',
	                margin: 0,
	                padding: 0,
	                WebkitAppearance: 'none', // iOS safari
	                appearance: 'none',
	                boxSizing: 'content-box',
	                background: `transparent 0% 0% / ${fontLineHeight.fontLineHeight}`,
	                transition: `${validateProps.getTransition('background-color')}, ${validateProps.getTransition('border-color')}`,
	                border: `${validateProps.borderWidthBase} solid ${uncheckedColor}`,
	                outline: 0, // TODO: only relevant for VRT testing with forced states - prevents :focus style (in case getFocusJssStyle() condition is not matching)
	                ...(disabledOrLoading
	                    ? {
	                        pointerEvents: 'none', // to prevent form element becomes clickable/toggleable
	                    }
	                    : {
	                        cursor: 'pointer',
	                    }),
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    borderColor: uncheckedColorDark,
	                }),
	            },
	            '&(input:checked)': {
	                // background-image is merged in later
	                borderColor: checkedColor,
	                backgroundColor: checkedColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    borderColor: checkedColorDark,
	                    backgroundColor: checkedColorDark,
	                }),
	            },
	            ...(!disabledOrLoading &&
	                !validateProps.isHighContrastMode &&
	                hoverMediaQuery.hoverMediaQuery({
	                    '&(input:hover),label:hover~.wrapper &(input)': {
	                        borderColor: uncheckedHoverColor,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            borderColor: uncheckedHoverColorDark,
	                        }),
	                    },
	                    '&(input:checked:hover),label:hover~.wrapper &(input:checked)': {
	                        borderColor: checkedHoverColor,
	                        backgroundColor: checkedHoverColor,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            borderColor: checkedHoverColorDark,
	                            backgroundColor: checkedHoverColorDark,
	                        }),
	                    },
	                    'label:hover~.wrapper &(input)': supportsChromiumMediaQuery({
	                        transition: 'unset', // Fixes chrome bug where transition properties are stuck on hover
	                    }),
	                })),
	            ...(!isDisabled && validateProps.getFocusJssStyle(theme, { slotted: 'input' })),
	        },
	    };
	};

	checkboxRadioStylesE83cbdf9.applyCheckboxRadioButtonSafariRenderingFix = applyCheckboxRadioButtonSafariRenderingFix;
	checkboxRadioStylesE83cbdf9.getSlottedCheckboxRadioButtonStyles = getSlottedCheckboxRadioButtonStyles;

	
	return checkboxRadioStylesE83cbdf9;
}

var colorSchemeStyles4bc3d59c = {};

var hasRequiredColorSchemeStyles4bc3d59c;

function requireColorSchemeStyles4bc3d59c () {
	if (hasRequiredColorSchemeStyles4bc3d59c) return colorSchemeStyles4bc3d59c;
	hasRequiredColorSchemeStyles4bc3d59c = 1;

	const hostHiddenStyles = {
	    '&([hidden])': {
	        display: 'none',
	    },
	};

	const colorSchemeStyles = {
	    colorScheme: 'light dark',
	};

	colorSchemeStyles4bc3d59c.colorSchemeStyles = colorSchemeStyles;
	colorSchemeStyles4bc3d59c.hostHiddenStyles = hostHiddenStyles;

	
	return colorSchemeStyles4bc3d59c;
}

var constantsCa271244 = {};

var hasRequiredConstantsCa271244;

function requireConstantsCa271244 () {
	if (hasRequiredConstantsCa271244) return constantsCa271244;
	hasRequiredConstantsCa271244 = 1;

	const TOAST_Z_INDEX = 999999;
	const MODAL_Z_INDEX = 99999;
	const FLYOUT_Z_INDEX = 99998;
	const POPOVER_Z_INDEX = 9999;
	const BANNER_Z_INDEX = 99;

	constantsCa271244.BANNER_Z_INDEX = BANNER_Z_INDEX;
	constantsCa271244.FLYOUT_Z_INDEX = FLYOUT_Z_INDEX;
	constantsCa271244.MODAL_Z_INDEX = MODAL_Z_INDEX;
	constantsCa271244.POPOVER_Z_INDEX = POPOVER_Z_INDEX;
	constantsCa271244.TOAST_Z_INDEX = TOAST_Z_INDEX;

	
	return constantsCa271244;
}

var displayShared43dd15a5 = {};

var hasRequiredDisplayShared43dd15a5;

function requireDisplayShared43dd15a5 () {
	if (hasRequiredDisplayShared43dd15a5) return displayShared43dd15a5;
	hasRequiredDisplayShared43dd15a5 = 1;

	const fontLineHeight = requireFontLineHeight78b03658();
	const fontWeightRegular = requireFontWeightRegularD0c768ac();
	const fontVariant = requireFontVariant6ba3b7cb();

	const fontSizeDisplayMedium = 'clamp(2.03rem, 3.58vw + 1.31rem, 5.61rem)';

	const _displayFontPartA = `${fontVariant.fontStyleNormal} ${fontVariant.fontVariant} ${fontWeightRegular.fontWeightRegular} `;
	const _displayFontPartB = `/${fontLineHeight.fontLineHeight} ${fontLineHeight.fontFamily}`;

	displayShared43dd15a5._displayFontPartA = _displayFontPartA;
	displayShared43dd15a5._displayFontPartB = _displayFontPartB;
	displayShared43dd15a5.fontSizeDisplayMedium = fontSizeDisplayMedium;

	
	return displayShared43dd15a5;
}

var dropShadowHighStyle7edcadc6 = {};

var dropShadowShared6e50faf3 = {};

var hasRequiredDropShadowShared6e50faf3;

function requireDropShadowShared6e50faf3 () {
	if (hasRequiredDropShadowShared6e50faf3) return dropShadowShared6e50faf3;
	hasRequiredDropShadowShared6e50faf3 = 1;

	const _dropShadowBackgroundColor = 'rgba(0, 0, 0, 0.16)';

	dropShadowShared6e50faf3._dropShadowBackgroundColor = _dropShadowBackgroundColor;

	
	return dropShadowShared6e50faf3;
}

var hasRequiredDropShadowHighStyle7edcadc6;

function requireDropShadowHighStyle7edcadc6 () {
	if (hasRequiredDropShadowHighStyle7edcadc6) return dropShadowHighStyle7edcadc6;
	hasRequiredDropShadowHighStyle7edcadc6 = 1;

	const dropShadowShared = requireDropShadowShared6e50faf3();

	const dropShadowHighStyle = {
	    boxShadow: `0px 8px 40px ${dropShadowShared._dropShadowBackgroundColor}`, // filter: drop-shadow() causes visual glitches in Firefox in combination with frostedGlassStyle
	};

	dropShadowHighStyle7edcadc6.dropShadowHighStyle = dropShadowHighStyle;

	
	return dropShadowHighStyle7edcadc6;
}

var escapeHashCharacterB9f68bcf = {};

var hasRequiredEscapeHashCharacterB9f68bcf;

function requireEscapeHashCharacterB9f68bcf () {
	if (hasRequiredEscapeHashCharacterB9f68bcf) return escapeHashCharacterB9f68bcf;
	hasRequiredEscapeHashCharacterB9f68bcf = 1;

	const getInlineSVGBackgroundImage = (path) => {
	    return `url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">${path}</svg>')`;
	};

	const escapeHashCharacter = (colorString) => {
	    return colorString.replace('#', '%23');
	};

	escapeHashCharacterB9f68bcf.escapeHashCharacter = escapeHashCharacter;
	escapeHashCharacterB9f68bcf.getInlineSVGBackgroundImage = getInlineSVGBackgroundImage;

	
	return escapeHashCharacterB9f68bcf;
}

var fieldsetUtilsA0590284 = {};

var hasRequiredFieldsetUtilsA0590284;

function requireFieldsetUtilsA0590284 () {
	if (hasRequiredFieldsetUtilsA0590284) return fieldsetUtilsA0590284;
	hasRequiredFieldsetUtilsA0590284 = 1;

	const FIELDSET_LABEL_SIZES = ['small', 'medium'];

	fieldsetUtilsA0590284.FIELDSET_LABEL_SIZES = FIELDSET_LABEL_SIZES;

	
	return fieldsetUtilsA0590284;
}

var flyoutDialogResetStylesA29edb86 = {};

var hasRequiredFlyoutDialogResetStylesA29edb86;

function requireFlyoutDialogResetStylesA29edb86 () {
	if (hasRequiredFlyoutDialogResetStylesA29edb86) return flyoutDialogResetStylesA29edb86;
	hasRequiredFlyoutDialogResetStylesA29edb86 = 1;

	const getFlyoutDialogResetJssStyle = () => {
	    return {
	        position: 'fixed',
	        height: '100dvh',
	        maxHeight: '100dvh',
	        margin: '0',
	        padding: '0',
	        border: '0',
	        visibility: 'inherit',
	        outline: '0',
	    };
	};

	flyoutDialogResetStylesA29edb86.getFlyoutDialogResetJssStyle = getFlyoutDialogResetJssStyle;

	
	return flyoutDialogResetStylesA29edb86;
}

var fontWeightStylesB74e8683 = {};

var fontWeightSemiBold4482c830 = {};

var hasRequiredFontWeightSemiBold4482c830;

function requireFontWeightSemiBold4482c830 () {
	if (hasRequiredFontWeightSemiBold4482c830) return fontWeightSemiBold4482c830;
	hasRequiredFontWeightSemiBold4482c830 = 1;

	const fontWeightSemiBold = 600;

	fontWeightSemiBold4482c830.fontWeightSemiBold = fontWeightSemiBold;

	
	return fontWeightSemiBold4482c830;
}

var hasRequiredFontWeightStylesB74e8683;

function requireFontWeightStylesB74e8683 () {
	if (hasRequiredFontWeightStylesB74e8683) return fontWeightStylesB74e8683;
	hasRequiredFontWeightStylesB74e8683 = 1;

	const fontWeightRegular = requireFontWeightRegularD0c768ac();
	const fontWeightSemiBold = requireFontWeightSemiBold4482c830();

	const fontWeightBold = 700;

	const fontWeightMap = {
	    regular: fontWeightRegular.fontWeightRegular,
	    'semi-bold': fontWeightSemiBold.fontWeightSemiBold,
	    bold: fontWeightBold,
	};
	const getFontWeight = (weight) => {
	    return fontWeightMap[weight];
	};

	fontWeightStylesB74e8683.getFontWeight = getFontWeight;

	
	return fontWeightStylesB74e8683;
}

var fontSizeHeadingLargeC355151d = {};

var fontSizeTextLarge05a4bc90 = {};

var hasRequiredFontSizeTextLarge05a4bc90;

function requireFontSizeTextLarge05a4bc90 () {
	if (hasRequiredFontSizeTextLarge05a4bc90) return fontSizeTextLarge05a4bc90;
	hasRequiredFontSizeTextLarge05a4bc90 = 1;

	const fontSizeTextLarge = 'clamp(1.27rem, 0.51vw + 1.16rem, 1.78rem)';

	fontSizeTextLarge05a4bc90.fontSizeTextLarge = fontSizeTextLarge;

	
	return fontSizeTextLarge05a4bc90;
}

var hasRequiredFontSizeHeadingLargeC355151d;

function requireFontSizeHeadingLargeC355151d () {
	if (hasRequiredFontSizeHeadingLargeC355151d) return fontSizeHeadingLargeC355151d;
	hasRequiredFontSizeHeadingLargeC355151d = 1;

	const fontSizeTextLarge = requireFontSizeTextLarge05a4bc90();

	const fontSizeHeadingLarge = fontSizeTextLarge.fontSizeTextLarge;

	fontSizeHeadingLargeC355151d.fontSizeHeadingLarge = fontSizeHeadingLarge;

	
	return fontSizeHeadingLargeC355151d;
}

var fontSizeHeadingMediumC49ab5a2 = {};

var fontSizeTextMedium88887ad8 = {};

var hasRequiredFontSizeTextMedium88887ad8;

function requireFontSizeTextMedium88887ad8 () {
	if (hasRequiredFontSizeTextMedium88887ad8) return fontSizeTextMedium88887ad8;
	hasRequiredFontSizeTextMedium88887ad8 = 1;

	const fontSizeTextMedium = 'clamp(1.13rem, 0.21vw + 1.08rem, 1.33rem)';

	fontSizeTextMedium88887ad8.fontSizeTextMedium = fontSizeTextMedium;

	
	return fontSizeTextMedium88887ad8;
}

var hasRequiredFontSizeHeadingMediumC49ab5a2;

function requireFontSizeHeadingMediumC49ab5a2 () {
	if (hasRequiredFontSizeHeadingMediumC49ab5a2) return fontSizeHeadingMediumC49ab5a2;
	hasRequiredFontSizeHeadingMediumC49ab5a2 = 1;

	const fontSizeTextMedium = requireFontSizeTextMedium88887ad8();

	const fontSizeHeadingMedium = fontSizeTextMedium.fontSizeTextMedium;

	fontSizeHeadingMediumC49ab5a2.fontSizeHeadingMedium = fontSizeHeadingMedium;

	
	return fontSizeHeadingMediumC49ab5a2;
}

var fontSizeHeadingSmallA15141a5 = {};

var hasRequiredFontSizeHeadingSmallA15141a5;

function requireFontSizeHeadingSmallA15141a5 () {
	if (hasRequiredFontSizeHeadingSmallA15141a5) return fontSizeHeadingSmallA15141a5;
	hasRequiredFontSizeHeadingSmallA15141a5 = 1;

	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();

	const fontSizeHeadingSmall = fontSizeTextSmall.fontSizeTextSmall;

	fontSizeHeadingSmallA15141a5.fontSizeHeadingSmall = fontSizeHeadingSmall;

	
	return fontSizeHeadingSmallA15141a5;
}

var fontSizeText728b6387 = {};

var fontSizeTextXXSmallA02f9c40 = {};

var hasRequiredFontSizeTextXXSmallA02f9c40;

function requireFontSizeTextXXSmallA02f9c40 () {
	if (hasRequiredFontSizeTextXXSmallA02f9c40) return fontSizeTextXXSmallA02f9c40;
	hasRequiredFontSizeTextXXSmallA02f9c40 = 1;

	const fontSizeTextXXSmall = '.75rem';

	fontSizeTextXXSmallA02f9c40.fontSizeTextXXSmall = fontSizeTextXXSmall;

	
	return fontSizeTextXXSmallA02f9c40;
}

var fontSizeTextXSmallE59d35d7 = {};

var hasRequiredFontSizeTextXSmallE59d35d7;

function requireFontSizeTextXSmallE59d35d7 () {
	if (hasRequiredFontSizeTextXSmallE59d35d7) return fontSizeTextXSmallE59d35d7;
	hasRequiredFontSizeTextXSmallE59d35d7 = 1;

	const fontSizeTextXSmall = 'clamp(0.81rem, 0.23vw + 0.77rem, 0.88rem)';

	fontSizeTextXSmallE59d35d7.fontSizeTextXSmall = fontSizeTextXSmall;

	
	return fontSizeTextXSmallE59d35d7;
}

var fontSizeTextXLarge0ecf9ef3 = {};

var hasRequiredFontSizeTextXLarge0ecf9ef3;

function requireFontSizeTextXLarge0ecf9ef3 () {
	if (hasRequiredFontSizeTextXLarge0ecf9ef3) return fontSizeTextXLarge0ecf9ef3;
	hasRequiredFontSizeTextXLarge0ecf9ef3 = 1;

	const fontSizeTextXLarge = 'clamp(1.42rem, 0.94vw + 1.23rem, 2.37rem)';

	fontSizeTextXLarge0ecf9ef3.fontSizeTextXLarge = fontSizeTextXLarge;

	
	return fontSizeTextXLarge0ecf9ef3;
}

var hasRequiredFontSizeText728b6387;

function requireFontSizeText728b6387 () {
	if (hasRequiredFontSizeText728b6387) return fontSizeText728b6387;
	hasRequiredFontSizeText728b6387 = 1;

	const fontSizeTextXXSmall = requireFontSizeTextXXSmallA02f9c40();
	const fontSizeTextXSmall = requireFontSizeTextXSmallE59d35d7();
	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();
	const fontSizeTextMedium = requireFontSizeTextMedium88887ad8();
	const fontSizeTextLarge = requireFontSizeTextLarge05a4bc90();
	const fontSizeTextXLarge = requireFontSizeTextXLarge0ecf9ef3();

	const fontSizeText = {
	    xxSmall: fontSizeTextXXSmall.fontSizeTextXXSmall,
	    xSmall: fontSizeTextXSmall.fontSizeTextXSmall,
	    small: fontSizeTextSmall.fontSizeTextSmall,
	    medium: fontSizeTextMedium.fontSizeTextMedium,
	    large: fontSizeTextLarge.fontSizeTextLarge,
	    xLarge: fontSizeTextXLarge.fontSizeTextXLarge,
	};

	fontSizeText728b6387.fontSizeText = fontSizeText;

	
	return fontSizeText728b6387;
}

var formStyles7e9d1c43 = {};

var spacingStaticSmall2130ed04 = {};

var hasRequiredSpacingStaticSmall2130ed04;

function requireSpacingStaticSmall2130ed04 () {
	if (hasRequiredSpacingStaticSmall2130ed04) return spacingStaticSmall2130ed04;
	hasRequiredSpacingStaticSmall2130ed04 = 1;

	const spacingStaticSmall = '8px';

	spacingStaticSmall2130ed04.spacingStaticSmall = spacingStaticSmall;

	
	return spacingStaticSmall2130ed04;
}

var spacingStaticMedium94812711 = {};

var hasRequiredSpacingStaticMedium94812711;

function requireSpacingStaticMedium94812711 () {
	if (hasRequiredSpacingStaticMedium94812711) return spacingStaticMedium94812711;
	hasRequiredSpacingStaticMedium94812711 = 1;

	const spacingStaticMedium = '16px';

	spacingStaticMedium94812711.spacingStaticMedium = spacingStaticMedium;

	
	return spacingStaticMedium94812711;
}

var hasRequiredFormStyles7e9d1c43;

function requireFormStyles7e9d1c43 () {
	if (hasRequiredFormStyles7e9d1c43) return formStyles7e9d1c43;
	hasRequiredFormStyles7e9d1c43 = 1;

	const validateProps = requireValidatePropsF6586828();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const required = requireRequiredF3c463a3();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();
	const fontLineHeight = requireFontLineHeight78b03658();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const textSmallStyle = requireTextSmallStyle7246779a();

	const getSlottedTextFieldTextareaSelectStyles = (child, state, isLoading, theme, additionalDefaultJssStyle) => {
	    const { primaryColor, contrastLowColor, contrastMediumColor, disabledColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, contrastLowColor: contrastLowColorDark, contrastMediumColor: contrastMediumColorDark, disabledColor: disabledColorDark, } = validateProps.getThemedColors('dark');
	    const { formStateColor, formStateHoverColor } = required.getThemedFormStateColors(theme, state);
	    const { formStateColor: formStateColorDark, formStateHoverColor: formStateHoverColorDark } = required.getThemedFormStateColors('dark', state);
	    return {
	        [`::slotted(${child})`]: {
	            display: 'block',
	            width: '100%',
	            height: child !== 'textarea'
	                ? `calc(${fontLineHeight.fontLineHeight} + 10px + ${validateProps.borderWidthBase} * 2 + ${spacingStaticSmall.spacingStaticSmall} * 2)` // we need 10px additionally so input height becomes 54px
	                : 'auto',
	            margin: 0,
	            outline: 0,
	            WebkitAppearance: 'none', // iOS safari
	            appearance: 'none',
	            boxSizing: 'border-box',
	            border: `${validateProps.borderWidthBase} solid ${formStateColor || contrastMediumColor}`,
	            borderRadius: borderRadiusSmall.borderRadiusSmall,
	            background: 'transparent',
	            font: textSmallStyle.textSmallStyle.font.replace('ex', 'ex + 6px'), // a minimum line-height is needed for input, otherwise value is scrollable in Chrome, +6px is aligned with how Safari visualize date/time input highlighting
	            textIndent: 0,
	            color: primaryColor,
	            transition: `${validateProps.getTransition('background-color')}, ${validateProps.getTransition('border-color')}, ${validateProps.getTransition('color')}`, // for smooth transitions between e.g. disabled states
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                borderColor: formStateColorDark || contrastMediumColorDark,
	                color: primaryColorDark,
	            }),
	            ...additionalDefaultJssStyle,
	        },
	        ...(!isLoading &&
	            hoverMediaQuery.hoverMediaQuery({
	                // with the media query the selector has higher priority and overrides disabled styles
	                [`::slotted(${child}:not(:disabled):not(:focus):not([readonly]):hover),label:hover~.wrapper ::slotted(${child}:not(:disabled):not(:focus):not([readonly]))${child === 'select' ? ',label:hover~.wrapper ::part(select-wrapper-dropdown)' : ''}`]: {
	                    borderColor: formStateHoverColor || primaryColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        borderColor: formStateHoverColorDark || primaryColorDark,
	                    }),
	                },
	            })),
	        // TODO: getFocusJssStyle() can't be re-used because focus style differs for form elements
	        [`::slotted(${child}:focus)`]: {
	            borderColor: primaryColor,
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                borderColor: primaryColorDark,
	            }),
	        },
	        [`::slotted(${child}:disabled)`]: {
	            cursor: 'not-allowed',
	            color: disabledColor,
	            borderColor: disabledColor,
	            WebkitTextFillColor: disabledColor,
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                color: disabledColorDark,
	                borderColor: disabledColorDark,
	                WebkitTextFillColor: disabledColorDark,
	            }),
	        },
	        ...(child !== 'select' && {
	            [`::slotted(${child}[readonly])`]: {
	                borderColor: contrastLowColor,
	                background: contrastLowColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    borderColor: contrastLowColorDark,
	                    background: contrastLowColorDark,
	                }),
	            },
	        }),
	    };
	};
	const formElementLayeredGap = '9px'; // to have same distance vertically and horizontally for e.g. button/icon within form element
	const formElementLayeredSafeZone = `calc(${formElementLayeredGap} + ${validateProps.borderWidthBase})`;
	// TODO: basic button/icon padding can already be set within style function instead of on component style level
	const formButtonOrIconPadding = spacingStaticXSmall.spacingStaticXSmall;
	// TODO: if we'd use 12px instead, it wouldn't be necessary for textarea to have a custom vertical padding,
	//  unfortunately line-height alignment breaks for a select element for some reasons then
	// TODO: basic form element padding can already be set within style function instead of on component style level
	const formElementPaddingVertical = spacingStaticSmall.spacingStaticSmall;
	// TODO: basic form element padding can already be set within style function instead of on component style level
	const formElementPaddingHorizontal = spacingStaticMedium.spacingStaticMedium;
	const getCalculatedFormElementPaddingHorizontal = (buttonOrIconAmount) => {
	    // when applied, font-family and font-size needs to be set too for correct calculation of ex-unit ($fontLineHeight)
	    return `calc(${formElementLayeredGap} + ${formElementPaddingHorizontal} / 2 + (${fontLineHeight.fontLineHeight} + ${formButtonOrIconPadding} * 2) * ${buttonOrIconAmount})`;
	};
	// TODO: re-use in textarea-wrapper not only in text-field-wrapper
	const getUnitCounterJssStyle = (isDisabled, theme) => {
	    const { disabledColor, contrastMediumColor } = validateProps.getThemedColors(theme);
	    const { disabledColor: disabledColorDark, contrastMediumColor: contrastMediumColorDark } = validateProps.getThemedColors('dark');
	    return {
	        pointerEvents: 'none',
	        maxWidth: '100%',
	        boxSizing: 'border-box',
	        whiteSpace: 'nowrap',
	        overflow: 'hidden',
	        textOverflow: 'ellipsis',
	        font: textSmallStyle.textSmallStyle.font,
	        color: contrastMediumColor,
	        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	            color: contrastMediumColorDark,
	        }),
	        ...(isDisabled && {
	            color: disabledColor,
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                color: disabledColorDark,
	            }),
	        }),
	    };
	};

	formStyles7e9d1c43.formButtonOrIconPadding = formButtonOrIconPadding;
	formStyles7e9d1c43.formElementLayeredGap = formElementLayeredGap;
	formStyles7e9d1c43.formElementLayeredSafeZone = formElementLayeredSafeZone;
	formStyles7e9d1c43.formElementPaddingHorizontal = formElementPaddingHorizontal;
	formStyles7e9d1c43.formElementPaddingVertical = formElementPaddingVertical;
	formStyles7e9d1c43.getCalculatedFormElementPaddingHorizontal = getCalculatedFormElementPaddingHorizontal;
	formStyles7e9d1c43.getSlottedTextFieldTextareaSelectStyles = getSlottedTextFieldTextareaSelectStyles;
	formStyles7e9d1c43.getUnitCounterJssStyle = getUnitCounterJssStyle;

	
	return formStyles7e9d1c43;
}

var getButtonBaseAriaAttributes2b382c95 = {};

var hasRequiredGetButtonBaseAriaAttributes2b382c95;

function requireGetButtonBaseAriaAttributes2b382c95 () {
	if (hasRequiredGetButtonBaseAriaAttributes2b382c95) return getButtonBaseAriaAttributes2b382c95;
	hasRequiredGetButtonBaseAriaAttributes2b382c95 = 1;

	requireValidatePropsF6586828();
	const isDisabledOrLoading = requireIsDisabledOrLoadingB1f56d7f();

	const getButtonBaseAriaAttributes = (isDisabled, isLoading) => {
	    return {
	        'aria-disabled': isDisabledOrLoading.isDisabledOrLoading(isDisabled, isLoading) ? 'true' : null,
	    };
	};

	getButtonBaseAriaAttributes2b382c95.getButtonBaseAriaAttributes = getButtonBaseAriaAttributes;

	
	return getButtonBaseAriaAttributes2b382c95;
}

var getNativePopoverDropdownPosition06475061 = {};

var hasRequiredGetNativePopoverDropdownPosition06475061;

function requireGetNativePopoverDropdownPosition06475061 () {
	if (hasRequiredGetNativePopoverDropdownPosition06475061) return getNativePopoverDropdownPosition06475061;
	hasRequiredGetNativePopoverDropdownPosition06475061 = 1;

	const validateProps = requireValidatePropsF6586828();

	const getFilterInputAriaAttributes = (isOpen, isRequired, labelId, descriptionId, dropdownId, activeDescendantId) => {
	    return {
	        ...getSelectDropdownButtonAriaAttributes(isOpen, labelId, descriptionId, dropdownId, activeDescendantId),
	        'aria-autocomplete': 'list',
	        ...(isRequired && {
	            'aria-required': 'true',
	        }),
	    };
	};
	const getSelectDropdownButtonAriaAttributes = (isOpen, labelId, descriptionId, dropdownId, activeDescendantId) => {
	    return {
	        'aria-labelledby': labelId || null,
	        'aria-describedby': descriptionId || null,
	        'aria-haspopup': 'listbox',
	        'aria-expanded': isOpen ? 'true' : 'false',
	        'aria-controls': dropdownId,
	        ...(isOpen &&
	            activeDescendantId !== undefined && {
	            'aria-activedescendant': `option-${activeDescendantId}`,
	        }),
	    };
	};
	// TODO: Can this be shared with select-wrapper dropdown?
	const getComboboxAriaAttributes = (isOpen, isRequired, labelId, descriptionId, dropdownId) => {
	    return {
	        'aria-labelledby': labelId || null,
	        'aria-describedby': descriptionId || null,
	        'aria-haspopup': 'listbox',
	        'aria-expanded': isOpen ? 'true' : 'false',
	        'aria-required': isRequired ? 'true' : 'false',
	        'aria-controls': dropdownId,
	    };
	};
	// TODO: Change to aria-labelledby
	const getListAriaAttributes = (label, isRequired, hasFilter, isOpen, multiple = false) => {
	    return {
	        role: 'listbox',
	        'aria-label': label,
	        ...(isRequired &&
	            !hasFilter && {
	            'aria-required': 'true',
	        }),
	        ...(!isOpen && {
	            'aria-hidden': 'true',
	        }),
	        ...(multiple && {
	            'aria-multiselectable': 'true',
	        }),
	    };
	};
	const getOptionAriaAttributes = (isSelected, isDisabled, isHidden, hasValue) => ({
	    ...(!isHidden && { 'aria-selected': isSelected ? 'true' : 'false' }),
	    'aria-disabled': isDisabled ? 'true' : null,
	    'aria-hidden': isHidden ? 'true' : null,
	    'aria-label': hasValue ? null : 'Empty value',
	});

	const OPTION_HEIGHT = 40; // optgroups are higher and ignored
	const MULTI_SELECT_OPTION_HEIGHT = 44;
	const getNoResultsOptionJssStyle = () => ({
	    '&[role=status]': {
	        cursor: 'not-allowed',
	    },
	    // TODO: shouldn't be used here, instead use sr-only functional component and style
	    '&__sr': validateProps.getHiddenTextJssStyle(),
	});

	const SELECT_DROPDOWN_DIRECTIONS_INTERNAL = ['down', 'up'];
	const SELECT_DROPDOWN_DIRECTIONS = [...SELECT_DROPDOWN_DIRECTIONS_INTERNAL, 'auto'];
	const MAX_CHILDREN = 9;
	const INPUT_HEIGHT = 54;
	const determineDropdownDirection = (host, visibleOptionLength) => {
	    const { top } = host.getBoundingClientRect();
	    const listHeight = OPTION_HEIGHT * (visibleOptionLength > MAX_CHILDREN ? MAX_CHILDREN : visibleOptionLength) + 64; // 64 = 2 x 6px padding + 2px border + 50px combobox height
	    const spaceBottom = window.innerHeight - top - INPUT_HEIGHT;
	    return spaceBottom <= listHeight && top >= listHeight ? 'up' : 'down';
	};

	const getNativePopoverDropdownPosition = (positionReference, visibleOptionsLength, nativePopover, direction) => {
	    const { left, top, width, height } = positionReference.getBoundingClientRect();
	    const isDirectionDown = direction === 'down' ||
	        (direction === 'auto' && determineDropdownDirection(positionReference, visibleOptionsLength) === 'down');
	    nativePopover.style.left = `${left + window.scrollX}px`;
	    nativePopover.style.top = `${top + window.scrollY + (isDirectionDown ? height : 0)}px`;
	    nativePopover.style.width = `${width}px`;
	};

	getNativePopoverDropdownPosition06475061.MULTI_SELECT_OPTION_HEIGHT = MULTI_SELECT_OPTION_HEIGHT;
	getNativePopoverDropdownPosition06475061.OPTION_HEIGHT = OPTION_HEIGHT;
	getNativePopoverDropdownPosition06475061.SELECT_DROPDOWN_DIRECTIONS = SELECT_DROPDOWN_DIRECTIONS;
	getNativePopoverDropdownPosition06475061.determineDropdownDirection = determineDropdownDirection;
	getNativePopoverDropdownPosition06475061.getComboboxAriaAttributes = getComboboxAriaAttributes;
	getNativePopoverDropdownPosition06475061.getFilterInputAriaAttributes = getFilterInputAriaAttributes;
	getNativePopoverDropdownPosition06475061.getListAriaAttributes = getListAriaAttributes;
	getNativePopoverDropdownPosition06475061.getNativePopoverDropdownPosition = getNativePopoverDropdownPosition;
	getNativePopoverDropdownPosition06475061.getNoResultsOptionJssStyle = getNoResultsOptionJssStyle;
	getNativePopoverDropdownPosition06475061.getOptionAriaAttributes = getOptionAriaAttributes;
	getNativePopoverDropdownPosition06475061.getSelectDropdownButtonAriaAttributes = getSelectDropdownButtonAriaAttributes;

	
	return getNativePopoverDropdownPosition06475061;
}

var getAttribute9c66ed26 = {};

var hasRequiredGetAttribute9c66ed26;

function requireGetAttribute9c66ed26 () {
	if (hasRequiredGetAttribute9c66ed26) return getAttribute9c66ed26;
	hasRequiredGetAttribute9c66ed26 = 1;

	const getAttribute = (el, attributeName) => {
	    return el.getAttribute(attributeName);
	};

	getAttribute9c66ed26.getAttribute = getAttribute;

	
	return getAttribute9c66ed26;
}

var getClickedItemDb2d9f29 = {};

var hasRequiredGetClickedItemDb2d9f29;

function requireGetClickedItemDb2d9f29 () {
	if (hasRequiredGetClickedItemDb2d9f29) return getClickedItemDb2d9f29;
	hasRequiredGetClickedItemDb2d9f29 = 1;

	const validateProps = requireValidatePropsF6586828();

	const getClickedItem = (host, tagName, targets) => {
	    const item = validateProps.getPrefixedTagNames(host)[validateProps.paramCaseToCamelCase(tagName)];
	    return targets.find((x) => x.tagName?.toLowerCase() === item);
	};

	getClickedItemDb2d9f29.getClickedItem = getClickedItem;

	
	return getClickedItemDb2d9f29;
}

var getDirectChildHTMLElementC5dd1dc2 = {};

var transformSelectorToDirectChildSelectorC1b1f9b0 = {};

var hasRequiredTransformSelectorToDirectChildSelectorC1b1f9b0;

function requireTransformSelectorToDirectChildSelectorC1b1f9b0 () {
	if (hasRequiredTransformSelectorToDirectChildSelectorC1b1f9b0) return transformSelectorToDirectChildSelectorC1b1f9b0;
	hasRequiredTransformSelectorToDirectChildSelectorC1b1f9b0 = 1;

	const transformSelectorToDirectChildSelector = (selector) => selector
	    .split(',')
	    .map((part) => ':scope>' + part)
	    .join();

	transformSelectorToDirectChildSelectorC1b1f9b0.transformSelectorToDirectChildSelector = transformSelectorToDirectChildSelector;

	
	return transformSelectorToDirectChildSelectorC1b1f9b0;
}

var hasRequiredGetDirectChildHTMLElementC5dd1dc2;

function requireGetDirectChildHTMLElementC5dd1dc2 () {
	if (hasRequiredGetDirectChildHTMLElementC5dd1dc2) return getDirectChildHTMLElementC5dd1dc2;
	hasRequiredGetDirectChildHTMLElementC5dd1dc2 = 1;

	const validateProps = requireValidatePropsF6586828();
	const transformSelectorToDirectChildSelector = requireTransformSelectorToDirectChildSelectorC1b1f9b0();

	/* eslint-disable prefer-arrow/prefer-arrow-functions */
	function getDirectChildHTMLElement(element, selector) {
	    // querySelector(All) doesn't work with :scope pseudo class and comma separator in jsdom, yet
	    // https://github.com/jsdom/jsdom/issues/3141
	    // therefore we got a workaround so it works nicely when consumed from jsdom-polyfill package
	    return (transformSelectorToDirectChildSelector.transformSelectorToDirectChildSelector(selector)
	        .split(',')
	        .map((sel) => validateProps.getHTMLElement(element, sel))
	        .filter((x) => x)[0] || null // comma separated selector might return null, so we have to filter
	    );
	}

	getDirectChildHTMLElementC5dd1dc2.getDirectChildHTMLElement = getDirectChildHTMLElement;

	
	return getDirectChildHTMLElementC5dd1dc2;
}

var getDirectChildHTMLElements31d23fa9 = {};

var getHTMLElements3f1c700f = {};

var hasRequiredGetHTMLElements3f1c700f;

function requireGetHTMLElements3f1c700f () {
	if (hasRequiredGetHTMLElements3f1c700f) return getHTMLElements3f1c700f;
	hasRequiredGetHTMLElements3f1c700f = 1;

	function getHTMLElements(element, selector) {
	    return element ? Array.from(element.querySelectorAll(selector)) : [];
	}

	getHTMLElements3f1c700f.getHTMLElements = getHTMLElements;

	
	return getHTMLElements3f1c700f;
}

var hasRequiredGetDirectChildHTMLElements31d23fa9;

function requireGetDirectChildHTMLElements31d23fa9 () {
	if (hasRequiredGetDirectChildHTMLElements31d23fa9) return getDirectChildHTMLElements31d23fa9;
	hasRequiredGetDirectChildHTMLElements31d23fa9 = 1;

	const getHTMLElements = requireGetHTMLElements3f1c700f();
	const transformSelectorToDirectChildSelector = requireTransformSelectorToDirectChildSelectorC1b1f9b0();

	/* eslint-disable prefer-arrow/prefer-arrow-functions */
	function getDirectChildHTMLElements(element, selector) {
	    // querySelector(All) doesn't work with :scope pseudo class and comma separator in jsdom, yet
	    // https://github.com/jsdom/jsdom/issues/3141
	    // therefore we got a workaround so it works nicely when consumed from jsdom-polyfill package
	    return transformSelectorToDirectChildSelector.transformSelectorToDirectChildSelector(selector)
	        .split(',')
	        .map((sel) => getHTMLElements.getHTMLElements(element, sel))
	        .flat(); // might contain duplicates
	}

	getDirectChildHTMLElements31d23fa9.getDirectChildHTMLElements = getDirectChildHTMLElements;

	
	return getDirectChildHTMLElements31d23fa9;
}

var getMediaQueryMaxBbf4c490 = {};

var hasRequiredGetMediaQueryMaxBbf4c490;

function requireGetMediaQueryMaxBbf4c490 () {
	if (hasRequiredGetMediaQueryMaxBbf4c490) return getMediaQueryMaxBbf4c490;
	hasRequiredGetMediaQueryMaxBbf4c490 = 1;

	const validateProps = requireValidatePropsF6586828();

	function getMediaQueryMax(max) {
	    return `@media(max-width:${validateProps.breakpoint[max] - 1}px)`;
	}

	getMediaQueryMaxBbf4c490.getMediaQueryMax = getMediaQueryMax;

	
	return getMediaQueryMaxBbf4c490;
}

var getOnlyChildOfKindHTMLElementOrThrowF7285231 = {};

var hasRequiredGetOnlyChildOfKindHTMLElementOrThrowF7285231;

function requireGetOnlyChildOfKindHTMLElementOrThrowF7285231 () {
	if (hasRequiredGetOnlyChildOfKindHTMLElementOrThrowF7285231) return getOnlyChildOfKindHTMLElementOrThrowF7285231;
	hasRequiredGetOnlyChildOfKindHTMLElementOrThrowF7285231 = 1;

	const validateProps = requireValidatePropsF6586828();
	const getDirectChildHTMLElements = requireGetDirectChildHTMLElements31d23fa9();

	/* eslint-disable prefer-arrow/prefer-arrow-functions */
	function getOnlyChildOfKindHTMLElementOrThrow(element, selector) {
	    // we need to support named slots for label/description or message, hence we can't verify element.children.length
	    const directChildren = getDirectChildHTMLElements.getDirectChildHTMLElements(element, selector);
	    if (directChildren.length !== 1) {
	        validateProps.throwException(`${validateProps.getTagNameWithoutPrefix(element)} has to contain a single direct child of: ${selector}`);
	    }
	    return directChildren[0];
	}

	getOnlyChildOfKindHTMLElementOrThrowF7285231.getOnlyChildOfKindHTMLElementOrThrow = getOnlyChildOfKindHTMLElementOrThrow;

	
	return getOnlyChildOfKindHTMLElementOrThrowF7285231;
}

var gridBasicOffsetEafb13d6 = {};

var gridExtendedOffsetBaseFb9830f6 = {};

var hasRequiredGridExtendedOffsetBaseFb9830f6;

function requireGridExtendedOffsetBaseFb9830f6 () {
	if (hasRequiredGridExtendedOffsetBaseFb9830f6) return gridExtendedOffsetBaseFb9830f6;
	hasRequiredGridExtendedOffsetBaseFb9830f6 = 1;

	const _gridWidthMax = '2560px';
	// fluid sizing calculated by https://fluidtypography.com/#app-get-started
	const _gridSafeZoneBase = 'max(22px, 10.625vw - 12px)'; // viewport-width range = 320 - 760px / size range = 22 - 68.75px
	const _gridSafeZoneS = 'calc(5vw - 16px)'; // viewport-width range = 760 - 1920px / size range = 22(22.75) - 80(79.71)px
	const _gridSafeZoneXXL = 'min(50vw - 880px, 400px)'; // viewport-width range = 1920 - 2560px / size range = 80(79.71)px - 400(399.71)px

	const gridExtendedOffsetBase = _gridSafeZoneBase;

	gridExtendedOffsetBaseFb9830f6._gridSafeZoneBase = _gridSafeZoneBase;
	gridExtendedOffsetBaseFb9830f6._gridSafeZoneS = _gridSafeZoneS;
	gridExtendedOffsetBaseFb9830f6._gridSafeZoneXXL = _gridSafeZoneXXL;
	gridExtendedOffsetBaseFb9830f6._gridWidthMax = _gridWidthMax;
	gridExtendedOffsetBaseFb9830f6.gridExtendedOffsetBase = gridExtendedOffsetBase;

	
	return gridExtendedOffsetBaseFb9830f6;
}

var gridExtendedOffsetXXLC7a41e50 = {};

var gridGapB5b73e4a = {};

var spacingFluidMedium88ab712b = {};

var hasRequiredSpacingFluidMedium88ab712b;

function requireSpacingFluidMedium88ab712b () {
	if (hasRequiredSpacingFluidMedium88ab712b) return spacingFluidMedium88ab712b;
	hasRequiredSpacingFluidMedium88ab712b = 1;

	const spacingFluidMedium = 'clamp(16px, 1.25vw + 12px, 36px)';

	spacingFluidMedium88ab712b.spacingFluidMedium = spacingFluidMedium;

	
	return spacingFluidMedium88ab712b;
}

var hasRequiredGridGapB5b73e4a;

function requireGridGapB5b73e4a () {
	if (hasRequiredGridGapB5b73e4a) return gridGapB5b73e4a;
	hasRequiredGridGapB5b73e4a = 1;

	const spacingFluidMedium = requireSpacingFluidMedium88ab712b();

	const gridGap = spacingFluidMedium.spacingFluidMedium;

	gridGapB5b73e4a.gridGap = gridGap;

	
	return gridGapB5b73e4a;
}

var hasRequiredGridExtendedOffsetXXLC7a41e50;

function requireGridExtendedOffsetXXLC7a41e50 () {
	if (hasRequiredGridExtendedOffsetXXLC7a41e50) return gridExtendedOffsetXXLC7a41e50;
	hasRequiredGridExtendedOffsetXXLC7a41e50 = 1;

	const gridExtendedOffsetBase = requireGridExtendedOffsetBaseFb9830f6();
	const gridGap = requireGridGapB5b73e4a();

	const columnMap = {
	    narrow: 4,
	    basic: 2,
	    extended: 1,
	};
	const gridColumnWidthS = `calc((100vw - ${gridExtendedOffsetBase._gridSafeZoneS} * 2 - ${gridGap.gridGap} * 15) / 16)`;
	const gridColumnWidthXXL = `calc((min(100vw, ${gridExtendedOffsetBase._gridWidthMax}) - ${gridExtendedOffsetBase._gridSafeZoneXXL} * 2 - ${gridGap.gridGap} * 15) / 16)`;
	const _gridPadding = `max(0px, 50vw - ${gridExtendedOffsetBase._gridWidthMax} / 2)`;
	const _getGridOffsetS = (width) => `calc(${gridExtendedOffsetBase._gridSafeZoneS} + (${gridGap.gridGap} + ${gridColumnWidthS}) * ${columnMap[width]})`;
	const _getGridOffsetXXL = (width) => `calc(${_gridPadding} + ${gridExtendedOffsetBase._gridSafeZoneXXL} + (${gridGap.gridGap} + ${gridColumnWidthXXL}) * ${columnMap[width]})`;

	const gridExtendedOffsetS = _getGridOffsetS('extended');

	const gridExtendedOffsetXXL = _getGridOffsetXXL('extended');

	gridExtendedOffsetXXLC7a41e50._getGridOffsetS = _getGridOffsetS;
	gridExtendedOffsetXXLC7a41e50._getGridOffsetXXL = _getGridOffsetXXL;
	gridExtendedOffsetXXLC7a41e50._gridPadding = _gridPadding;
	gridExtendedOffsetXXLC7a41e50.gridExtendedOffsetS = gridExtendedOffsetS;
	gridExtendedOffsetXXLC7a41e50.gridExtendedOffsetXXL = gridExtendedOffsetXXL;

	
	return gridExtendedOffsetXXLC7a41e50;
}

var hasRequiredGridBasicOffsetEafb13d6;

function requireGridBasicOffsetEafb13d6 () {
	if (hasRequiredGridBasicOffsetEafb13d6) return gridBasicOffsetEafb13d6;
	hasRequiredGridBasicOffsetEafb13d6 = 1;

	const gridExtendedOffsetBase = requireGridExtendedOffsetBaseFb9830f6();
	const gridExtendedOffsetXXL = requireGridExtendedOffsetXXLC7a41e50();

	const gridExtendedOffset = {
	    base: gridExtendedOffsetBase.gridExtendedOffsetBase,
	    s: gridExtendedOffsetXXL.gridExtendedOffsetS,
	    xxl: gridExtendedOffsetXXL.gridExtendedOffsetXXL,
	};

	const gridBasicOffsetBase = gridExtendedOffsetBase._gridSafeZoneBase;

	const gridBasicOffsetS = gridExtendedOffsetXXL._getGridOffsetS('basic');

	const gridBasicOffsetXXL = gridExtendedOffsetXXL._getGridOffsetXXL('basic');

	const gridBasicOffset = {
	    base: gridBasicOffsetBase,
	    s: gridBasicOffsetS,
	    xxl: gridBasicOffsetXXL,
	};

	gridBasicOffsetEafb13d6.gridBasicOffset = gridBasicOffset;
	gridBasicOffsetEafb13d6.gridBasicOffsetBase = gridBasicOffsetBase;
	gridBasicOffsetEafb13d6.gridExtendedOffset = gridExtendedOffset;

	
	return gridBasicOffsetEafb13d6;
}

var groupDirectionStylesC4bd8b11 = {};

var hasRequiredGroupDirectionStylesC4bd8b11;

function requireGroupDirectionStylesC4bd8b11 () {
	if (hasRequiredGroupDirectionStylesC4bd8b11) return groupDirectionStylesC4bd8b11;
	hasRequiredGroupDirectionStylesC4bd8b11 = 1;

	const GROUP_DIRECTIONS = ['row', 'column'];
	const groupDirectionJssStyles = {
	    column: {
	        flexFlow: 'column nowrap',
	        alignItems: 'stretch',
	    },
	    row: {
	        flexFlow: 'row wrap',
	        alignItems: 'center',
	    },
	};
	const getGroupDirectionJssStyles = (direction) => {
	    return groupDirectionJssStyles[direction];
	};

	groupDirectionStylesC4bd8b11.GROUP_DIRECTIONS = GROUP_DIRECTIONS;
	groupDirectionStylesC4bd8b11.getGroupDirectionJssStyles = getGroupDirectionJssStyles;

	
	return groupDirectionStylesC4bd8b11;
}

var hasDocument079654e6 = {};

var hasRequiredHasDocument079654e6;

function requireHasDocument079654e6 () {
	if (hasRequiredHasDocument079654e6) return hasDocument079654e6;
	hasRequiredHasDocument079654e6 = 1;

	const hasDocument = typeof document !== 'undefined';

	hasDocument079654e6.hasDocument = hasDocument;

	
	return hasDocument079654e6;
}

var hasAttributeBf22c03a = {};

var hasRequiredHasAttributeBf22c03a;

function requireHasAttributeBf22c03a () {
	if (hasRequiredHasAttributeBf22c03a) return hasAttributeBf22c03a;
	hasRequiredHasAttributeBf22c03a = 1;

	const hasAttribute = (el, attributeName) => {
	    return el.hasAttribute(attributeName);
	};

	hasAttributeBf22c03a.hasAttribute = hasAttribute;

	
	return hasAttributeBf22c03a;
}

var hasDescriptionBbe55afe = {};

var hasRequiredHasDescriptionBbe55afe;

function requireHasDescriptionBbe55afe () {
	if (hasRequiredHasDescriptionBbe55afe) return hasDescriptionBbe55afe;
	hasRequiredHasDescriptionBbe55afe = 1;

	requireValidatePropsF6586828();
	const hasNamedSlot = requireHasNamedSlotA96fd22a();

	const hasDescription = (element, description) => {
	    return !!description || hasNamedSlot.hasNamedSlot(element, 'description');
	};

	hasDescriptionBbe55afe.hasDescription = hasDescription;

	
	return hasDescriptionBbe55afe;
}

var hasHeading6f9fd2ca = {};

var hasRequiredHasHeading6f9fd2ca;

function requireHasHeading6f9fd2ca () {
	if (hasRequiredHasHeading6f9fd2ca) return hasHeading6f9fd2ca;
	hasRequiredHasHeading6f9fd2ca = 1;

	requireValidatePropsF6586828();
	const hasNamedSlot = requireHasNamedSlotA96fd22a();

	const hasHeading = (element, heading) => {
	    return !!heading || hasNamedSlot.hasNamedSlot(element, 'heading');
	};

	hasHeading6f9fd2ca.hasHeading = hasHeading;

	
	return hasHeading6f9fd2ca;
}

var headingTag6cfe20fe = {};

var hasRequiredHeadingTag6cfe20fe;

function requireHeadingTag6cfe20fe () {
	if (hasRequiredHeadingTag6cfe20fe) return headingTag6cfe20fe;
	hasRequiredHeadingTag6cfe20fe = 1;

	const HEADING_TAGS = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];

	headingTag6cfe20fe.HEADING_TAGS = HEADING_TAGS;

	
	return headingTag6cfe20fe;
}

var headingMediumStyle1c9f0c45 = {};

var headingSharedAa59e66d = {};

var hasRequiredHeadingSharedAa59e66d;

function requireHeadingSharedAa59e66d () {
	if (hasRequiredHeadingSharedAa59e66d) return headingSharedAa59e66d;
	hasRequiredHeadingSharedAa59e66d = 1;

	const fontLineHeight = requireFontLineHeight78b03658();
	const fontWeightSemiBold = requireFontWeightSemiBold4482c830();
	const fontVariant = requireFontVariant6ba3b7cb();

	const _headingFontPartA = `${fontVariant.fontStyleNormal} ${fontVariant.fontVariant} ${fontWeightSemiBold.fontWeightSemiBold} `;
	const _headingFontPartB = `/${fontLineHeight.fontLineHeight} ${fontLineHeight.fontFamily}`;

	headingSharedAa59e66d._headingFontPartA = _headingFontPartA;
	headingSharedAa59e66d._headingFontPartB = _headingFontPartB;

	
	return headingSharedAa59e66d;
}

var hasRequiredHeadingMediumStyle1c9f0c45;

function requireHeadingMediumStyle1c9f0c45 () {
	if (hasRequiredHeadingMediumStyle1c9f0c45) return headingMediumStyle1c9f0c45;
	hasRequiredHeadingMediumStyle1c9f0c45 = 1;

	const headingShared = requireHeadingSharedAa59e66d();
	const fontSizeHeadingMedium = requireFontSizeHeadingMediumC49ab5a2();

	const headingMediumStyle = {
	    font: `${headingShared._headingFontPartA}${fontSizeHeadingMedium.fontSizeHeadingMedium}${headingShared._headingFontPartB}`,
	};

	headingMediumStyle1c9f0c45.headingMediumStyle = headingMediumStyle;

	
	return headingMediumStyle1c9f0c45;
}

var headingSmallStyle0707b97f = {};

var hasRequiredHeadingSmallStyle0707b97f;

function requireHeadingSmallStyle0707b97f () {
	if (hasRequiredHeadingSmallStyle0707b97f) return headingSmallStyle0707b97f;
	hasRequiredHeadingSmallStyle0707b97f = 1;

	const headingShared = requireHeadingSharedAa59e66d();
	const fontSizeHeadingSmall = requireFontSizeHeadingSmallA15141a5();

	const headingSmallStyle = {
	    font: `${headingShared._headingFontPartA}${fontSizeHeadingSmall.fontSizeHeadingSmall}${headingShared._headingFontPartB}`,
	};

	headingSmallStyle0707b97f.headingSmallStyle = headingSmallStyle;

	
	return headingSmallStyle0707b97f;
}

var headingXXLargeStyle139a1eb3 = {};

var hasRequiredHeadingXXLargeStyle139a1eb3;

function requireHeadingXXLargeStyle139a1eb3 () {
	if (hasRequiredHeadingXXLargeStyle139a1eb3) return headingXXLargeStyle139a1eb3;
	hasRequiredHeadingXXLargeStyle139a1eb3 = 1;

	const fontSizeTextXLarge = requireFontSizeTextXLarge0ecf9ef3();
	const headingShared = requireHeadingSharedAa59e66d();

	const fontSizeHeadingXLarge = fontSizeTextXLarge.fontSizeTextXLarge;

	const fontSizeHeadingXXLarge = 'clamp(1.6rem, 1.56vw + 1.29rem, 3.16rem)';

	const headingXXLargeStyle = {
	    font: `${headingShared._headingFontPartA}${fontSizeHeadingXXLarge}${headingShared._headingFontPartB}`,
	};

	headingXXLargeStyle139a1eb3.fontSizeHeadingXLarge = fontSizeHeadingXLarge;
	headingXXLargeStyle139a1eb3.fontSizeHeadingXXLarge = fontSizeHeadingXXLarge;
	headingXXLargeStyle139a1eb3.headingXXLargeStyle = headingXXLargeStyle;

	
	return headingXXLargeStyle139a1eb3;
}

var helperA66adcf2 = {};

var hasRequiredHelperA66adcf2;

function requireHelperA66adcf2 () {
	if (hasRequiredHelperA66adcf2) return helperA66adcf2;
	hasRequiredHelperA66adcf2 = 1;

	const validateProps = requireValidatePropsF6586828();

	const getDeprecatedPropOrSlotWarningMessage = (host, propOrSlot) => `${propOrSlot} is deprecated for component ${validateProps.getTagNameWithoutPrefix(host)} and will be removed with next major release.`;

	helperA66adcf2.getDeprecatedPropOrSlotWarningMessage = getDeprecatedPropOrSlotWarningMessage;

	
	return helperA66adcf2;
}

var index_cjs = {};

var hasRequiredIndex_cjs;

function requireIndex_cjs () {
	if (hasRequiredIndex_cjs) return index_cjs;
	hasRequiredIndex_cjs = 1;


	
	return index_cjs;
}

var initialLoadingController44585a09 = {};

var hasRequiredInitialLoadingController44585a09;

function requireInitialLoadingController44585a09 () {
	if (hasRequiredInitialLoadingController44585a09) return initialLoadingController44585a09;
	hasRequiredInitialLoadingController44585a09 = 1;

	const validateProps = requireValidatePropsF6586828();

	const getFunctionalComponentLoadingMessageStyles = () => {
	    return {
	        loading: validateProps.getHiddenTextJssStyle(),
	    };
	};

	const loadingId = 'loading';
	const LoadingMessage = ({ loading, initialLoading }) => {
	    return (validateProps.h("span", { id: loadingId, class: "loading", role: "status" }, loading ? 'Loading' : !initialLoading ? '' : 'Loading finished'));
	};

	class ControllerHost {
	    constructor(host) {
	        this.host = host;
	        this.controllers = new Set();
	        const { connectedCallback, // eslint-disable-line @typescript-eslint/unbound-method
	        disconnectedCallback, // eslint-disable-line @typescript-eslint/unbound-method
	        componentWillLoad, // eslint-disable-line @typescript-eslint/unbound-method
	        componentDidLoad, // eslint-disable-line @typescript-eslint/unbound-method
	        componentWillUpdate, // eslint-disable-line @typescript-eslint/unbound-method
	        componentDidUpdate, // eslint-disable-line @typescript-eslint/unbound-method
	         } = host;
	        host.connectedCallback = () => {
	            this.controllers.forEach((ctrl) => ctrl.hostConnected?.());
	            connectedCallback?.apply(host);
	        };
	        host.disconnectedCallback = () => {
	            this.controllers.forEach((ctrl) => ctrl.hostDisconnected?.());
	            disconnectedCallback?.apply(host);
	        };
	        host.componentWillLoad = () => {
	            this.controllers.forEach((ctrl) => ctrl.hostWillLoad?.());
	            componentWillLoad?.apply(host);
	        };
	        host.componentDidLoad = () => {
	            this.controllers.forEach((ctrl) => ctrl.hostDidLoad?.());
	            componentDidLoad?.apply(host);
	        };
	        host.componentWillUpdate = () => {
	            this.controllers.forEach((ctrl) => ctrl.hostWillUpdate?.());
	            componentWillUpdate?.apply(host);
	        };
	        host.componentDidUpdate = () => {
	            this.controllers.forEach((ctrl) => ctrl.hostDidUpdate?.());
	            componentDidUpdate?.apply(host);
	        };
	    }
	    addController(ctrl) {
	        this.controllers.add(ctrl);
	    }
	    removeController(ctrl) {
	        this.controllers.delete(ctrl);
	    }
	    requestUpdate() {
	        validateProps.forceUpdate(this.host);
	    }
	}

	class InitialLoadingController {
	    constructor(controllerHost) {
	        this.controllerHost = controllerHost;
	        this.initialLoading = false;
	        this.controllerHost.addController(this);
	    }
	    hostConnected() {
	        this.initialLoading = this.controllerHost.host.loading;
	    }
	    hostWillLoad() {
	        this.initialLoading = this.controllerHost.host.loading;
	    }
	    hostWillUpdate() {
	        if (this.controllerHost.host.loading) {
	            this.initialLoading = true;
	        }
	    }
	}

	initialLoadingController44585a09.ControllerHost = ControllerHost;
	initialLoadingController44585a09.InitialLoadingController = InitialLoadingController;
	initialLoadingController44585a09.LoadingMessage = LoadingMessage;
	initialLoadingController44585a09.getFunctionalComponentLoadingMessageStyles = getFunctionalComponentLoadingMessageStyles;
	initialLoadingController44585a09.loadingId = loadingId;

	
	return initialLoadingController44585a09;
}

var inlineNotificationUtils60940706 = {};

var hasRequiredInlineNotificationUtils60940706;

function requireInlineNotificationUtils60940706 () {
	if (hasRequiredInlineNotificationUtils60940706) return inlineNotificationUtils60940706;
	hasRequiredInlineNotificationUtils60940706 = 1;

	const validateProps = requireValidatePropsF6586828();
	const getMediaQueryMax = requireGetMediaQueryMaxBbf4c490();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const bannerUtils = requireBannerUtils2cc83734();

	const mediaQueryMinS = validateProps.getMediaQueryMin('s');
	const mediaQueryMaxS = getMediaQueryMax.getMediaQueryMax('s');
	const getBackgroundColor = (state, theme) => {
	    const { infoSoftColor, successSoftColor, errorSoftColor, warningSoftColor } = validateProps.getThemedColors(theme);
	    const colorMap = {
	        neutral: infoSoftColor, // deprecated
	        info: infoSoftColor,
	        warning: warningSoftColor,
	        success: successSoftColor,
	        error: errorSoftColor,
	    };
	    return colorMap[state];
	};
	const getNotificationRootJssStyle = (state, hasAction, hasClose, theme) => {
	    return {
	        // display: 'grid', // NOTE: display property is moved into component styled to not apply !important keyword
	        // 2 columns for content and optional close button
	        gridTemplateColumns: `minmax(auto, 1fr)${hasClose ? ' auto' : ''}`,
	        gap: spacingStaticMedium.spacingStaticMedium,
	        placeItems: 'start',
	        padding: spacingStaticMedium.spacingStaticMedium,
	        background: getBackgroundColor(state, theme),
	        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	            background: getBackgroundColor(state, 'dark'),
	        }),
	        borderRadius: borderRadiusSmall.borderRadiusSmall,
	        ...(validateProps.isHighContrastMode && {
	            outline: '1px solid transparent',
	        }),
	        [mediaQueryMinS]: {
	            // 4 columns are for icon, content, optional action button and optional close button
	            gridTemplateColumns: `auto minmax(auto, 1fr)${hasAction ? ' auto' : ''}${hasClose ? ' auto' : ''}`,
	        },
	    };
	};
	const getNotificationIconJssStyle = () => ({
	    [mediaQueryMaxS]: {
	        display: 'none',
	    },
	});
	const getNotificationContentJssStyle = () => ({
	    display: 'grid',
	    gap: spacingStaticXSmall.spacingStaticXSmall,
	    maxWidth: '50rem',
	    [mediaQueryMinS]: {
	        marginLeft: `-${spacingStaticSmall.spacingStaticSmall}`,
	    },
	});

	const INLINE_NOTIFICATION_STATES = ['success', ...bannerUtils.BANNER_STATES];
	const getInlineNotificationIconName = (state) => {
	    const stateToIconMap = {
	        neutral: 'information-filled', // deprecated
	        info: 'information-filled',
	        warning: 'warning-filled',
	        success: 'success-filled',
	        error: 'error-filled',
	    };
	    return stateToIconMap[state];
	};
	const getContentAriaAttributes = (state, labelId, descriptionId) => {
	    const isAlert = state === 'warning' || state === 'error';
	    return {
	        role: isAlert ? 'alert' : 'status',
	        'aria-live': isAlert ? 'assertive' : 'polite',
	        'aria-labelledby': labelId,
	        'aria-describedby': descriptionId,
	    };
	};

	inlineNotificationUtils60940706.INLINE_NOTIFICATION_STATES = INLINE_NOTIFICATION_STATES;
	inlineNotificationUtils60940706.getContentAriaAttributes = getContentAriaAttributes;
	inlineNotificationUtils60940706.getInlineNotificationIconName = getInlineNotificationIconName;
	inlineNotificationUtils60940706.getNotificationContentJssStyle = getNotificationContentJssStyle;
	inlineNotificationUtils60940706.getNotificationIconJssStyle = getNotificationIconJssStyle;
	inlineNotificationUtils60940706.getNotificationRootJssStyle = getNotificationRootJssStyle;

	
	return inlineNotificationUtils60940706;
}

var isSsrHydration9278b79b = {};

var hasRequiredIsSsrHydration9278b79b;

function requireIsSsrHydration9278b79b () {
	if (hasRequiredIsSsrHydration9278b79b) return isSsrHydration9278b79b;
	hasRequiredIsSsrHydration9278b79b = 1;

	const isSsrHydration = (host) => host.classList.contains('ssr');

	isSsrHydration9278b79b.isSsrHydration = isSsrHydration;

	
	return isSsrHydration9278b79b;
}

var isWithinForm3637a500 = {};

var hasRequiredIsWithinForm3637a500;

function requireIsWithinForm3637a500 () {
	if (hasRequiredIsWithinForm3637a500) return isWithinForm3637a500;
	hasRequiredIsWithinForm3637a500 = 1;

	requireValidatePropsF6586828();
	const getClosestHTMLElement = requireGetClosestHTMLElement83d01a84();

	const isWithinForm = (host) => !!getClosestHTMLElement.getClosestHTMLElement(host, 'form');

	isWithinForm3637a500.isWithinForm = isWithinForm;

	
	return isWithinForm3637a500;
}

var label5379ea8c = {};

var hasRequiredLabel5379ea8c;

function requireLabel5379ea8c () {
	if (hasRequiredLabel5379ea8c) return label5379ea8c;
	hasRequiredLabel5379ea8c = 1;

	const validateProps = requireValidatePropsF6586828();
	const required = requireRequiredF3c463a3();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const fontSizeTextXSmall = requireFontSizeTextXSmallE59d35d7();
	const getClosestHTMLElement = requireGetClosestHTMLElement83d01a84();
	const hasDescription = requireHasDescriptionBbe55afe();
	const isParentOfKind = requireIsParentOfKindB7d9f81c();

	const isRequired = (el) => !!el?.required;

	const isParentFieldsetRequired = (element) => {
	    return ((isParentOfKind.isParentOfKind(element, 'p-fieldset') || isParentOfKind.isParentOfKind(element, 'p-fieldset-wrapper')) &&
	        isRequired(element.parentElement));
	};

	const isRequiredAndParentNotRequired = (element, child) => {
	    return isRequired(child) && !isParentFieldsetRequired(element);
	};

	const getFunctionalComponentLabelStyles = (isDisabledOrLoading, hideLabel, theme, additionalDefaultJssStyle, additionalIsShownJssStyle) => {
	    const { primaryColor, disabledColor, contrastHighColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, disabledColor: disabledColorDark, contrastHighColor: contrastHighColorDark, } = validateProps.getThemedColors('dark');
	    return {
	        label: {
	            ...textSmallStyle.textSmallStyle,
	            cursor: isDisabledOrLoading ? 'not-allowed' : 'pointer',
	            justifySelf: 'flex-start', // ensures label is not getting stretched by flex or grid context of its parent
	            color: isDisabledOrLoading ? disabledColor : primaryColor,
	            transition: validateProps.getTransition('color'), // for smooth transitions between e.g. disabled state
	            ...validateProps.buildResponsiveStyles(hideLabel, (isHidden) => validateProps.getHiddenTextJssStyle(isHidden, additionalIsShownJssStyle)),
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                color: isDisabledOrLoading ? disabledColorDark : primaryColorDark,
	            }),
	            '&:empty': {
	                display: 'none', // prevents outer spacing caused by parents grid gap, in case no label value is defined (although it has to be set to be a11y compliant)
	            },
	            '&+&': {
	                cursor: 'unset',
	                marginTop: `-${spacingStaticXSmall.spacingStaticXSmall}`,
	                fontSize: fontSizeTextXSmall.fontSizeTextXSmall,
	                ...(!isDisabledOrLoading && {
	                    color: contrastHighColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        color: contrastHighColorDark,
	                    }),
	                }),
	            },
	            ...additionalDefaultJssStyle,
	        },
	        // .required
	        ...required.getFunctionalComponentRequiredStyles(),
	    };
	};

	const labelId = 'label';
	const descriptionId = 'description';
	const Label = ({ host, label, description, htmlFor, isRequired, isLoading, isDisabled, formElement, }) => {
	    return (validateProps.h(validateProps.Fragment, null,
	        validateProps.h("label", { class: "label", id: labelId, "aria-disabled": isLoading || isDisabled ? 'true' : null, ...(htmlFor
	                ? { htmlFor }
	                : {
	                    onClick: (event) => onLabelClick(event, formElement, isLoading, isDisabled, host),
	                }) }, required.hasLabel(host, label) && (validateProps.h(validateProps.Fragment, null,
	            label || validateProps.h("slot", { name: "label" }),
	            ((isRequired && !isParentFieldsetRequired(host)) ||
	                (formElement && isRequiredAndParentNotRequired(host, formElement))) && validateProps.h(required.Required, null)))),
	        hasDescription.hasDescription(host, description) && (validateProps.h("span", { class: "label", id: descriptionId, "aria-disabled": isLoading || isDisabled ? 'true' : null }, description || validateProps.h("slot", { name: "description" })))));
	};
	const onLabelClick = (event, formElement, isLoading, isDisabled, host) => {
	    // we don't want to click/focus the form element, if a link is clicked or when host/form-field is in loading or disabled state
	    if (isLoading || isDisabled || getClosestHTMLElement.getClosestHTMLElement(event.target, 'a') !== null) {
	        return;
	    }
	    if (formElement.tagName === 'INPUT' && (formElement.type === 'checkbox' || formElement.type === 'radio')) {
	        // checkbox-wrapper, radio-button-wrapper
	        formElement.click();
	        // TODO: maybe we should call `formElement.focus();` too, to be in sync with the behaviour of other form fields.
	        //  On the other hand, it would show a focus outline, maybe this then needs to be handled with :focus-visible and :focus fallback instead.
	    }
	    else if (formElement.tagName === 'SELECT') {
	        // select-wrapper
	        // TODO: should be refactored in select-wrapper, so that "for" attribute becomes possible to use
	        const el = host.shadowRoot.children[0].querySelector('.dropdown')?.shadowRoot.children[0]; // input or button of p-select-wrapper-dropdown
	        if (el) {
	            el.click();
	            el.focus();
	        }
	        else {
	            formElement.focus(); // it's not possible to open the native option list of a select by JS
	        }
	    }
	    else if (formElement.tagName === 'INPUT' || formElement.tagName === 'TEXTAREA') {
	        // text-field-wrapper, textarea-wrapper
	        formElement.focus();
	    }
	};

	label5379ea8c.Label = Label;
	label5379ea8c.descriptionId = descriptionId;
	label5379ea8c.getFunctionalComponentLabelStyles = getFunctionalComponentLabelStyles;
	label5379ea8c.isRequiredAndParentNotRequired = isRequiredAndParentNotRequired;
	label5379ea8c.labelId = labelId;

	
	return label5379ea8c;
}

var linkAriaAttribute5de11e89 = {};

var hasRequiredLinkAriaAttribute5de11e89;

function requireLinkAriaAttribute5de11e89 () {
	if (hasRequiredLinkAriaAttribute5de11e89) return linkAriaAttribute5de11e89;
	hasRequiredLinkAriaAttribute5de11e89 = 1;

	const LINK_ARIA_ATTRIBUTES = ['aria-label', 'aria-current'];

	linkAriaAttribute5de11e89.LINK_ARIA_ATTRIBUTES = LINK_ARIA_ATTRIBUTES;

	
	return linkAriaAttribute5de11e89;
}

var linkButtonPureStyles67cba12c = {};

var hasRequiredLinkButtonPureStyles67cba12c;

function requireLinkButtonPureStyles67cba12c () {
	if (hasRequiredLinkButtonPureStyles67cba12c) return linkButtonPureStyles67cba12c;
	hasRequiredLinkButtonPureStyles67cba12c = 1;

	const validateProps = requireValidatePropsF6586828();
	const buttonLinkPureUtils = requireButtonLinkPureUtils1db4d1d1();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const fontSizeTextXXSmall = requireFontSizeTextXXSmallA02f9c40();
	const fontSizeTextXSmall = requireFontSizeTextXSmallE59d35d7();
	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();
	const fontSizeTextMedium = requireFontSizeTextMedium88887ad8();
	const fontSizeTextLarge = requireFontSizeTextLarge05a4bc90();
	const fontSizeTextXLarge = requireFontSizeTextXLarge0ecf9ef3();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const fontLineHeight = requireFontLineHeight78b03658();

	const fontSizeTextMap = {
	    'xx-small': fontSizeTextXXSmall.fontSizeTextXXSmall,
	    'x-small': fontSizeTextXSmall.fontSizeTextXSmall,
	    small: fontSizeTextSmall.fontSizeTextSmall,
	    medium: fontSizeTextMedium.fontSizeTextMedium,
	    large: fontSizeTextLarge.fontSizeTextLarge,
	    'x-large': fontSizeTextXLarge.fontSizeTextXLarge,
	    inherit: 'inherit',
	};
	const getFontSizeText = (size) => {
	    return fontSizeTextMap[size];
	};

	// Needed for slotted anchor and hidden label, which then enlarges the hidden label to equal host size and indents the text to be visually hidden.
	const getVisibilityJssStyle = (hideLabel) => {
	    return hideLabel
	        ? {
	            whiteSpace: 'nowrap',
	            textIndent: '-999999px', // Needed because standard sr-only classes don't work here due that we need a bounding box for the focus style
	            overflow: 'hidden',
	        }
	        : {
	            whiteSpace: 'inherit',
	            textIndent: 0,
	            zIndex: 1, // fix Firefox bug on :hover (#2583)
	            overflow: 'visible',
	        };
	};
	const offsetVertical = '-2px';
	const offsetHorizontal = '-4px';
	const getLinkButtonPureStyles = (icon, iconSource, active, isDisabledOrLoading, stretch, size, hideLabel, alignLabel, underline, hasSlottedAnchor, theme) => {
	    const { primaryColor, disabledColor, hoverColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, disabledColor: disabledColorDark, hoverColor: hoverColorDark, } = validateProps.getThemedColors('dark');
	    const hasIcon = buttonLinkPureUtils.hasVisibleIcon(icon, iconSource);
	    return {
	        '@global': {
	            ':host': {
	                ...validateProps.addImportantToEachRule({
	                    transform: 'translate3d(0,0,0)', // creates new stacking context
	                    outline: 0, // custom element is able to delegate the focus
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	                ...validateProps.buildResponsiveStyles(stretch, (responsiveStretch) => ({
	                    display: responsiveStretch ? 'block' : 'inline-block',
	                    width: responsiveStretch ? '100%' : 'auto', // prevents adjusting its size when used as flex or grid child
	                    ...(!responsiveStretch && { verticalAlign: 'top' }),
	                })),
	            },
	        },
	        root: {
	            display: 'flex',
	            width: '100%',
	            padding: 0,
	            margin: 0, // Removes default button margin on safari 15
	            color: isDisabledOrLoading ? disabledColor : primaryColor,
	            textDecoration: underline ? 'underline' : 'none',
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                color: isDisabledOrLoading ? disabledColorDark : primaryColorDark,
	            }),
	            ...textSmallStyle.textSmallStyle,
	            ...validateProps.mergeDeep(validateProps.buildResponsiveStyles(hideLabel, (hidelabelValue) => ({
	                gap: hidelabelValue ? 0 : spacingStaticXSmall.spacingStaticXSmall,
	            })), validateProps.buildResponsiveStyles(stretch, (stretchValue) => ({
	                justifyContent: stretchValue ? 'space-between' : 'flex-start',
	                alignItems: stretchValue ? 'center' : 'flex-start',
	            })), validateProps.buildResponsiveStyles(size, (sizeValue) => ({
	                fontSize: getFontSizeText(sizeValue),
	            }))),
	            '&::before': {
	                content: '""',
	                position: 'absolute', // mobile Safari -> prevent lagging active state
	                top: offsetVertical,
	                bottom: offsetVertical,
	                ...validateProps.buildResponsiveStyles(hideLabel, (hideLabelValue) => ({
	                    right: hideLabelValue ? offsetVertical : offsetHorizontal,
	                    left: hideLabelValue ? offsetVertical : offsetHorizontal,
	                })),
	                borderRadius: borderRadiusSmall.borderRadiusSmall,
	                transition: validateProps.getTransition('background-color'),
	                ...(active && {
	                    ...validateProps.frostedGlassStyle,
	                    backgroundColor: hoverColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        backgroundColor: hoverColorDark,
	                    }),
	                }),
	            },
	            ...(!isDisabledOrLoading &&
	                hoverMediaQuery.hoverMediaQuery({
	                    '&:hover::before': {
	                        ...validateProps.frostedGlassStyle,
	                        backgroundColor: hoverColor,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            backgroundColor: hoverColorDark,
	                        }),
	                    },
	                })),
	            ...(!hasSlottedAnchor && validateProps.getFocusJssStyle(theme, { pseudo: true, offset: '-2px' })),
	        },
	        ...(hasIcon
	            ? {
	                icon: {
	                    position: 'relative',
	                    flexShrink: '0',
	                    width: fontLineHeight.fontLineHeight,
	                    height: fontLineHeight.fontLineHeight,
	                    // workaround for Safari to optimize vertical alignment of icons
	                    // TODO: check if this is still needed after optimized icons are included
	                    '@supports (width: round(down, 1px, 1px))': {
	                        width: `round(down, ${fontLineHeight.fontLineHeight}, 1px)`,
	                        height: `round(down, ${fontLineHeight.fontLineHeight}, 1px)`,
	                    },
	                },
	                label: validateProps.mergeDeep(validateProps.buildResponsiveStyles(hideLabel, getVisibilityJssStyle), validateProps.buildResponsiveStyles(alignLabel, (alignLabelValue) => ({
	                    // TODO: we should remove 'left' here and map the value in the component class already to 'start' but might be difficult due to breakpoint customizable prop value
	                    order: alignLabelValue === 'left' || alignLabelValue === 'start' ? -1 : 0,
	                }))),
	            }
	            : {
	                label: {
	                    position: 'relative', // needed for hover state when icon="none" is set
	                },
	            }),
	    };
	};

	linkButtonPureStyles67cba12c.getLinkButtonPureStyles = getLinkButtonPureStyles;
	linkButtonPureStyles67cba12c.offsetHorizontal = offsetHorizontal;
	linkButtonPureStyles67cba12c.offsetVertical = offsetVertical;

	
	return linkButtonPureStyles67cba12c;
}

var linkButtonStylesAafed6b0 = {};

var hasRequiredLinkButtonStylesAafed6b0;

function requireLinkButtonStylesAafed6b0 () {
	if (hasRequiredLinkButtonStylesAafed6b0) return linkButtonStylesAafed6b0;
	hasRequiredLinkButtonStylesAafed6b0 = 1;

	const validateProps = requireValidatePropsF6586828();
	const buttonLinkPureUtils = requireButtonLinkPureUtils1db4d1d1();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const fontLineHeight = requireFontLineHeight78b03658();

	const { primaryColor: darkThemePrimaryColor } = validateProps.getThemedColors('dark');
	const { primaryColor: lightThemePrimaryColor } = validateProps.getThemedColors('light');
	const getVariantColors = (variant, theme) => {
	    const { primaryColor, contrastHighColor, contrastMediumColor, hoverColor } = validateProps.getThemedColors(theme);
	    const { canvasColor } = validateProps.getHighContrastColors();
	    const colors = {
	        primary: {
	            textColor: theme === 'dark' ? lightThemePrimaryColor : darkThemePrimaryColor,
	            borderColor: primaryColor,
	            borderColorHover: contrastHighColor,
	            backgroundColor: primaryColor,
	            backgroundColorHover: contrastHighColor,
	        },
	        secondary: {
	            textColor: primaryColor,
	            borderColor: primaryColor,
	            borderColorHover: contrastMediumColor,
	            backgroundColor: validateProps.isHighContrastMode ? canvasColor : 'transparent',
	            backgroundColorHover: hoverColor,
	        },
	    };
	    return colors[variant === 'tertiary' ? 'secondary' : variant];
	};
	const getLinkButtonStyles = (icon, iconSource, variant, hideLabel, isDisabledOrLoading, hasSlottedAnchor, theme) => {
	    const isPrimary = variant === 'primary';
	    const { textColor, borderColor, borderColorHover, backgroundColor, backgroundColorHover } = getVariantColors(variant, theme);
	    const { textColor: textColorDark, borderColor: borderColorDark, borderColorHover: borderColorHoverDark, backgroundColor: backgroundColorDark, backgroundColorHover: backgroundColorHoverDark, } = getVariantColors(variant, 'dark');
	    const { focusColor } = validateProps.getThemedColors(theme);
	    const hasIcon = buttonLinkPureUtils.hasVisibleIcon(icon, iconSource) || hideLabel;
	    return {
	        '@global': {
	            ':host': {
	                display: 'inline-block',
	                ...validateProps.addImportantToEachRule({
	                    verticalAlign: 'top',
	                    outline: 0, // custom element is able to delegate the focus
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	        },
	        root: {
	            display: 'flex',
	            alignItems: 'flex-start',
	            justifyContent: 'center',
	            width: '100%',
	            minWidth: '54px', // ensure space is already reserved until icon component is loaded (ssr)
	            minHeight: '54px', // ensure space is already reserved until icon component is loaded (ssr)
	            boxSizing: 'border-box',
	            textAlign: 'start',
	            WebkitAppearance: 'none', // iOS safari
	            appearance: 'none',
	            textDecoration: 'none',
	            border: `2px solid ${borderColor}`,
	            borderRadius: borderRadiusSmall.borderRadiusSmall,
	            transform: 'translate3d(0,0,0)', // creates new stacking context (for slotted anchor + focus)
	            backgroundColor,
	            color: textColor,
	            ...textSmallStyle.textSmallStyle,
	            transition: `${validateProps.getTransition('background-color')}, ${validateProps.getTransition('border-color')}, ${validateProps.getTransition('color')}`,
	            ...validateProps.buildResponsiveStyles(hideLabel, (hideLabelValue) => ({
	                padding: hideLabelValue ? '13px' : '13px 26px',
	                gap: hideLabelValue ? 0 : spacingStaticSmall.spacingStaticSmall,
	            })),
	            ...(!hasSlottedAnchor && validateProps.getFocusJssStyle(theme)),
	            ...(!isDisabledOrLoading &&
	                hoverMediaQuery.hoverMediaQuery({
	                    '&:hover': {
	                        backgroundColor: backgroundColorHover,
	                        borderColor: validateProps.isHighContrastMode ? focusColor : borderColorHover,
	                        ...(!isPrimary && validateProps.frostedGlassStyle),
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            backgroundColor: backgroundColorHoverDark,
	                            borderColor: borderColorHoverDark,
	                        }),
	                    },
	                })),
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                borderColor: borderColorDark,
	                backgroundColor: backgroundColorDark,
	                color: textColorDark,
	            }),
	        },
	        label: validateProps.buildResponsiveStyles(hideLabel, validateProps.getHiddenTextJssStyle),
	        ...(hasIcon && {
	            icon: {
	                width: fontLineHeight.fontLineHeight,
	                height: fontLineHeight.fontLineHeight,
	                ...validateProps.buildResponsiveStyles(hideLabel, (hideLabelValue) => ({
	                    marginInlineStart: hideLabelValue ? 0 : '-8px', // compensate white space of svg icon and optimize visual alignment
	                })),
	            },
	        }),
	    };
	};

	linkButtonStylesAafed6b0.getLinkButtonStyles = getLinkButtonStyles;

	
	return linkButtonStylesAafed6b0;
}

var linkButtonVariant3104b925 = {};

var hasRequiredLinkButtonVariant3104b925;

function requireLinkButtonVariant3104b925 () {
	if (hasRequiredLinkButtonVariant3104b925) return linkButtonVariant3104b925;
	hasRequiredLinkButtonVariant3104b925 = 1;

	const LINK_BUTTON_VARIANTS = ['primary', 'secondary', 'tertiary'];

	linkButtonVariant3104b925.LINK_BUTTON_VARIANTS = LINK_BUTTON_VARIANTS;

	
	return linkButtonVariant3104b925;
}

var linkStylesA7b4953d = {};

var hasRequiredLinkStylesA7b4953d;

function requireLinkStylesA7b4953d () {
	if (hasRequiredLinkStylesA7b4953d) return linkStylesA7b4953d;
	hasRequiredLinkStylesA7b4953d = 1;

	const validateProps = requireValidatePropsF6586828();
	const linkButtonStyles = requireLinkButtonStylesAafed6b0();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();

	const getComponentCss = (icon, iconSource, variant, hideLabel, hasSlottedAnchor, theme) => {
	    const { linkColor } = validateProps.getHighContrastColors();
	    const isPrimary = variant === 'primary';
	    return validateProps.getCss(validateProps.mergeDeep(linkButtonStyles.getLinkButtonStyles(icon, iconSource, variant, hideLabel, false, hasSlottedAnchor, theme), {
	        label: {
	            clip: validateProps.addImportantToRule('unset'), // to overrule breakpoint customizable hide-label style
	        },
	        icon: {
	            ...(isPrimary &&
	                !validateProps.isHighContrastMode && {
	                filter: 'invert(1)',
	            }),
	        },
	    }, hasSlottedAnchor && {
	        ...(validateProps.isHighContrastMode && {
	            root: {
	                borderColor: linkColor,
	            },
	        }),
	        '@global': validateProps.addImportantToEachRule({
	            '::slotted': {
	                '&(a)': {
	                    ...validateProps.getResetInitialStylesForSlottedAnchor,
	                    textDecoration: 'none',
	                    font: 'inherit',
	                    color: 'inherit',
	                },
	                // The clickable area for Safari < ~15 (<= release date: 2021-10-28) is reduced to the slotted anchor itself,
	                // since Safari prior to this major release does not support pseudo-elements in the slotted context
	                // (https://bugs.webkit.org/show_bug.cgi?id=178237)
	                '&(a)::before': {
	                    content: '""',
	                    position: 'fixed',
	                    inset: '-2px',
	                    borderRadius: borderRadiusSmall.borderRadiusSmall,
	                },
	                ...validateProps.getFocusJssStyle(theme, { slotted: 'a', pseudo: true }),
	            },
	        }),
	    }));
	};

	linkStylesA7b4953d.getComponentCss = getComponentCss;

	
	return linkStylesA7b4953d;
}

var linkTileUtilsF366cfed = {};

var tileBaseStyles0dff2b0f = {};

var textIconStyles990609fb = {};

var hasRequiredTextIconStyles990609fb;

function requireTextIconStyles990609fb () {
	if (hasRequiredTextIconStyles990609fb) return textIconStyles990609fb;
	hasRequiredTextIconStyles990609fb = 1;

	const validateProps = requireValidatePropsF6586828();

	const getThemedTypographyColor = (theme, textColor // eslint-disable-line @typescript-eslint/no-duplicate-type-constituents
	) => {
	    const themedColors = validateProps.getThemedColors(theme);
	    const colorMap = {
	        primary: themedColors.primaryColor,
	        default: themedColors.primaryColor, // deprecated but part of HeadlineColor
	        'contrast-low': themedColors.contrastLowColor,
	        'contrast-medium': themedColors.contrastMediumColor,
	        'contrast-high': themedColors.contrastHighColor,
	        'notification-success': themedColors.successColor,
	        'notification-warning': themedColors.warningColor,
	        'notification-error': themedColors.errorColor,
	        'notification-info': themedColors.infoColor,
	        inherit: 'currentColor',
	    };
	    return colorMap[textColor];
	};

	textIconStyles990609fb.getThemedTypographyColor = getThemedTypographyColor;

	
	return textIconStyles990609fb;
}

var hasRequiredTileBaseStyles0dff2b0f;

function requireTileBaseStyles0dff2b0f () {
	if (hasRequiredTileBaseStyles0dff2b0f) return tileBaseStyles0dff2b0f;
	hasRequiredTileBaseStyles0dff2b0f = 1;

	const textShared = requireTextShared9135e2ef();
	const fontSizeTextLarge = requireFontSizeTextLarge05a4bc90();
	const validateProps = requireValidatePropsF6586828();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const textIconStyles = requireTextIconStyles990609fb();
	const borderRadiusLarge = requireBorderRadiusLargeA0aa3a01();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();

	const _gradient = 'rgba(31,31,31,0.9) 0%,' +
	    'rgba(31,31,31,0.9) 20%,' +
	    'rgba(31,31,31,0.852589) 26.67%,' +
	    'rgba(32,32,32,0.768225) 33.33%,' +
	    'rgba(33,33,33,0.668116) 40%,' +
	    'rgba(34,34,34,0.557309) 46.67%,' +
	    'rgba(35,35,35,0.442691) 53.33%,' +
	    'rgba(36,36,36,0.331884) 60%,' +
	    'rgba(37,37,37,0.231775) 66.67%,' +
	    'rgba(38,38,38,0.147411) 73.33%,' +
	    'rgba(39,39,39,0.0816599) 80%,' +
	    'rgba(39,39,39,0.03551) 86.67%,' +
	    'rgba(39,39,39,0.0086472) 93.33%,' +
	    'rgba(39,39,39,0)';

	const gradientToTopStyle = {
	    background: `linear-gradient(to top, ${_gradient} 100%);`,
	};

	const textLargeStyle = {
	    font: `${textShared._textFontPartA}${fontSizeTextLarge.fontSizeTextLarge}${textShared._textFontPartB}`,
	    ...textShared.fontHyphenationStyle,
	};

	const TILE_ASPECT_RATIOS = ['1:1', '4:3', '3:4', '16:9', '9:16'];
	const TILE_SIZES = ['default', 'inherit'];
	const TILE_WEIGHTS = ['regular', 'semi-bold'];
	const TILE_ALIGNS = ['top', 'bottom'];

	const aspectRatioPaddingMap = {
	    '1:1': '100%',
	    '4:3': '75%',
	    '3:4': '133.33%',
	    '16:9': '56.25%',
	    '9:16': '177.75%',
	};
	const getTileBaseStyles = (aspectRatio, isDisabled) => {
	    return {
	        '@global': {
	            ':host': {
	                display: 'block',
	                hyphens: 'auto',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...validateProps.addImportantToEachRule({
	                '::slotted': {
	                    '&(picture)': {
	                        position: 'absolute',
	                        inset: 0,
	                    },
	                    '&(img)': {
	                        height: '100%',
	                        width: '100%',
	                        objectFit: 'cover',
	                    },
	                },
	            }),
	        },
	        root: {
	            position: 'relative',
	            overflow: 'hidden',
	            transform: 'translate3d(0,0,0)', // change stacking context for position fixed
	            borderRadius: borderRadiusLarge.borderRadiusLarge,
	            color: textIconStyles.getThemedTypographyColor('dark', 'primary'),
	            ...validateProps.buildResponsiveStyles(aspectRatio, (ratio) => ({
	                paddingTop: aspectRatioPaddingMap[ratio],
	            })),
	            ...(!isDisabled &&
	                hoverMediaQuery.hoverMediaQuery({
	                    '&:hover .image-container': {
	                        transform: 'scale3d(1.05,1.05,1.05)',
	                    },
	                })),
	        },
	        'image-container': {
	            position: 'absolute',
	            inset: 0,
	            transition: validateProps.getTransition('transform', 'moderate'),
	        },
	        content: {
	            position: 'absolute',
	            left: 0,
	            right: 0,
	            display: 'flex',
	            justifyItems: 'start',
	            gap: spacingStaticMedium.spacingStaticMedium,
	            borderRadius: borderRadiusLarge.borderRadiusLarge, // for gradient
	            '@media (forced-colors: active)': {
	                background: 'rgba(0,0,0,0.7)',
	            },
	        },
	    };
	};

	tileBaseStyles0dff2b0f.TILE_ALIGNS = TILE_ALIGNS;
	tileBaseStyles0dff2b0f.TILE_ASPECT_RATIOS = TILE_ASPECT_RATIOS;
	tileBaseStyles0dff2b0f.TILE_SIZES = TILE_SIZES;
	tileBaseStyles0dff2b0f.TILE_WEIGHTS = TILE_WEIGHTS;
	tileBaseStyles0dff2b0f._gradient = _gradient;
	tileBaseStyles0dff2b0f.getTileBaseStyles = getTileBaseStyles;
	tileBaseStyles0dff2b0f.gradientToTopStyle = gradientToTopStyle;
	tileBaseStyles0dff2b0f.textLargeStyle = textLargeStyle;

	
	return tileBaseStyles0dff2b0f;
}

var spacingFluidLarge6087a0f7 = {};

var hasRequiredSpacingFluidLarge6087a0f7;

function requireSpacingFluidLarge6087a0f7 () {
	if (hasRequiredSpacingFluidLarge6087a0f7) return spacingFluidLarge6087a0f7;
	hasRequiredSpacingFluidLarge6087a0f7 = 1;

	const spacingFluidLarge = 'clamp(32px, 2.75vw + 23px, 76px)';

	spacingFluidLarge6087a0f7.spacingFluidLarge = spacingFluidLarge;

	
	return spacingFluidLarge6087a0f7;
}

var themeBfc10573 = {};

var hasRequiredThemeBfc10573;

function requireThemeBfc10573 () {
	if (hasRequiredThemeBfc10573) return themeBfc10573;
	hasRequiredThemeBfc10573 = 1;

	const THEMES = ['light', 'dark', 'auto'];

	themeBfc10573.THEMES = THEMES;

	
	return themeBfc10573;
}

var hasRequiredLinkTileUtilsF366cfed;

function requireLinkTileUtilsF366cfed () {
	if (hasRequiredLinkTileUtilsF366cfed) return linkTileUtilsF366cfed;
	hasRequiredLinkTileUtilsF366cfed = 1;

	const validateProps = requireValidatePropsF6586828();
	const fontWeightStyles = requireFontWeightStylesB74e8683();
	const tileBaseStyles = requireTileBaseStyles0dff2b0f();
	const fontSizeTextMedium = requireFontSizeTextMedium88887ad8();
	const spacingFluidMedium = requireSpacingFluidMedium88ab712b();
	const spacingFluidLarge = requireSpacingFluidLarge6087a0f7();
	const theme = requireThemeBfc10573();

	const gradientToBottomStyle = {
	    background: `linear-gradient(to bottom, ${tileBaseStyles._gradient} 100%);`,
	};

	// does not take care of breakpoint customizable
	const throwIfAlignTopAndNotCompact = (host, align, compact) => {
	    if (align === 'top' && (!compact || (typeof compact === 'string' && compact === 'false'))) {
	        validateProps.throwException(`usage of ${validateProps.getTagNameWithoutPrefix(host)} is not valid. align='top' is only possible with compact='true'.`);
	    }
	};

	const sizeMap = {
	    inherit: { fontSize: 'inherit' },
	    default: { fontSize: fontSizeTextMedium.fontSizeTextMedium },
	};
	const getButtonLinkTileStyles = (aspectRatio, size, weight, // to get deprecated semibold typed
	background, align, compact, hasGradient, isDisabled) => {
	    const isTopAligned = align === 'top';
	    return validateProps.mergeDeep(tileBaseStyles.getTileBaseStyles(aspectRatio, isDisabled), {
	        '@global': {
	            p: {
	                maxWidth: '34.375rem', // in this case rem unit makes sense to scale up available space
	                margin: 0,
	                ...tileBaseStyles.textLargeStyle,
	                hyphens: 'inherit',
	                ...validateProps.mergeDeep(validateProps.buildResponsiveStyles(size, (s) => sizeMap[s]), validateProps.buildResponsiveStyles(weight, (w) => ({
	                    fontWeight: fontWeightStyles.getFontWeight(w === 'semibold' ? 'semi-bold' : w), // mapping of the deprecated weight semibold
	                }))),
	                ...validateProps.buildResponsiveStyles(background, (b) => ({
	                    color: validateProps.getThemedColors(b).primaryColor,
	                })),
	            },
	        },
	        content: {
	            display: 'grid', // TODO: flex via getTileBaseStyles
	            ...(isTopAligned ? { top: 0 } : { bottom: 0 }),
	            padding: isTopAligned
	                ? `${spacingFluidMedium.spacingFluidMedium} ${spacingFluidMedium.spacingFluidMedium} ${spacingFluidLarge.spacingFluidLarge}`
	                : `${spacingFluidLarge.spacingFluidLarge} ${spacingFluidMedium.spacingFluidMedium} ${spacingFluidMedium.spacingFluidMedium}`,
	            ...validateProps.mergeDeep(hasGradient &&
	                validateProps.isThemeDark(background) &&
	                validateProps.buildResponsiveStyles(compact, (isCompact) => isCompact && isTopAligned ? gradientToBottomStyle : tileBaseStyles.gradientToTopStyle), validateProps.buildResponsiveStyles(compact, (isCompact) => isCompact // TODO: use flex
	                ? {
	                    alignItems: 'center',
	                    gridTemplateColumns: 'auto 24px',
	                    gridTemplateRows: 'auto',
	                    ...(isTopAligned ? { top: 0 } : { bottom: 0 }),
	                }
	                : {
	                    gridTemplateRows: 'auto auto',
	                    gridTemplateColumns: 'auto',
	                })),
	        },
	        'link-or-button-pure': validateProps.buildResponsiveStyles(compact, (isCompact) => ({
	            display: isCompact ? 'inline-block' : 'none',
	        })),
	        'link-or-button': {
	            minHeight: '54px', // prevent content shift
	            ...validateProps.buildResponsiveStyles(compact, (isCompact) => ({
	                display: isCompact ? 'none' : 'inline-block',
	            })),
	        },
	    });
	};

	const LINK_TILE_WEIGHTS = [...tileBaseStyles.TILE_WEIGHTS, 'semibold'];
	const sharedTilePropTypes = {
	    size: validateProps.AllowedTypes.breakpoint(tileBaseStyles.TILE_SIZES),
	    background: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    aspectRatio: validateProps.AllowedTypes.breakpoint(tileBaseStyles.TILE_ASPECT_RATIOS),
	    label: validateProps.AllowedTypes.string,
	    description: validateProps.AllowedTypes.string,
	    align: validateProps.AllowedTypes.oneOf(tileBaseStyles.TILE_ALIGNS),
	    gradient: validateProps.AllowedTypes.boolean,
	    compact: validateProps.AllowedTypes.breakpoint('boolean'),
	};

	linkTileUtilsF366cfed.LINK_TILE_WEIGHTS = LINK_TILE_WEIGHTS;
	linkTileUtilsF366cfed.getButtonLinkTileStyles = getButtonLinkTileStyles;
	linkTileUtilsF366cfed.sharedTilePropTypes = sharedTilePropTypes;
	linkTileUtilsF366cfed.throwIfAlignTopAndNotCompact = throwIfAlignTopAndNotCompact;

	
	return linkTileUtilsF366cfed;
}

var modalFlyoutUtils950041a2 = {};

var hasRequiredModalFlyoutUtils950041a2;

function requireModalFlyoutUtils950041a2 () {
	if (hasRequiredModalFlyoutUtils950041a2) return modalFlyoutUtils950041a2;
	hasRequiredModalFlyoutUtils950041a2 = 1;

	const getHTMLElements = requireGetHTMLElements3f1c700f();

	/* eslint-disable prefer-arrow/prefer-arrow-functions */
	function getShadowRootHTMLElements(element, selector) {
	    return getHTMLElements.getHTMLElements(element.shadowRoot, selector);
	}

	const scrollShadowColor = 'rgba(204, 204, 204, 0.35)';
	const scrollShadowColorDark = 'rgba(0, 0, 0, 0.6)';

	modalFlyoutUtils950041a2.getShadowRootHTMLElements = getShadowRootHTMLElements;
	modalFlyoutUtils950041a2.scrollShadowColor = scrollShadowColor;
	modalFlyoutUtils950041a2.scrollShadowColorDark = scrollShadowColorDark;

	
	return modalFlyoutUtils950041a2;
}

var pAccordion_cjs_entry = {};

var warnIfDeprecatedPropIsUsed0dc3288b = {};

var hasRequiredWarnIfDeprecatedPropIsUsed0dc3288b;

function requireWarnIfDeprecatedPropIsUsed0dc3288b () {
	if (hasRequiredWarnIfDeprecatedPropIsUsed0dc3288b) return warnIfDeprecatedPropIsUsed0dc3288b;
	hasRequiredWarnIfDeprecatedPropIsUsed0dc3288b = 1;

	const helper = requireHelperA66adcf2();
	const validateProps = requireValidatePropsF6586828();

	const warnIfDeprecatedPropIsUsed = (instance, prop, additionalText) => {
	    const propValue = instance[prop];
	    if (propValue !== undefined && propValue !== null) {
	        validateProps.consoleWarn(helper.getDeprecatedPropOrSlotWarningMessage(instance.host, prop), additionalText || '');
	    }
	};

	warnIfDeprecatedPropIsUsed0dc3288b.warnIfDeprecatedPropIsUsed = warnIfDeprecatedPropIsUsed;

	
	return warnIfDeprecatedPropIsUsed0dc3288b;
}

var hasRequiredPAccordion_cjs_entry;

function requirePAccordion_cjs_entry () {
	if (hasRequiredPAccordion_cjs_entry) return pAccordion_cjs_entry;
	hasRequiredPAccordion_cjs_entry = 1;

	Object.defineProperty(pAccordion_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed0dc3288b();
	const theme = requireThemeBfc10573();
	const headingTag = requireHeadingTag6cfe20fe();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const fontWeightSemiBold = requireFontWeightSemiBold4482c830();
	const fontSizeTextMedium = requireFontSizeTextMedium88887ad8();
	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const fontLineHeight = requireFontLineHeight78b03658();
	const fontSizeTextXXSmall = requireFontSizeTextXXSmallA02f9c40();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	requireHelperA66adcf2();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();

	const ACCORDION_SIZES = ['small', 'medium'];

	const getComponentCss = (size, compact, open, theme, sticky) => {
	    const { primaryColor, hoverColor, contrastLowColor, backgroundColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, hoverColor: hoverColorDark, contrastLowColor: contrastLowColorDark, backgroundColor: backgroundColorDark, } = validateProps.getThemedColors('dark');
	    const cssVariablePositionStickyTop = '--p-accordion-position-sticky-top';
	    const positionStickyTopFallback = '0';
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...(compact
	                        ? { transform: 'translate3d(0,0,0)' } // relevant for custom click-area in compact variant
	                        : {
	                            borderBottom: `1px solid ${contrastLowColor}`,
	                            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                                borderColor: contrastLowColorDark,
	                            }),
	                        }),
	                    '&(:only-of-type)': { borderBottom: 0 },
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            button: {
	                display: 'flex',
	                position: 'relative',
	                justifyContent: 'space-between',
	                alignItems: 'center',
	                width: '100%',
	                textDecoration: 'none',
	                border: 0,
	                margin: 0, // Removes default button margin on safari 15
	                gap: '24px',
	                background: 'transparent',
	                cursor: 'pointer',
	                textAlign: 'start',
	                color: primaryColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: primaryColorDark,
	                }),
	                ...textSmallStyle.textSmallStyle,
	                fontWeight: fontWeightSemiBold.fontWeightSemiBold,
	                ...validateProps.buildResponsiveStyles(size, (s) => ({
	                    fontSize: s === 'medium' ? fontSizeTextMedium.fontSizeTextMedium : fontSizeTextSmall.fontSizeTextSmall,
	                    padding: `${compact ? '4px' : s === 'medium' ? '20px' : '15px'} 0`,
	                })),
	                // mergeDeep needed because of hoverMediaQuery in certain modes not wrapping keys and therefore overriding "&::before" key
	                ...validateProps.mergeDeep({
	                    '&::before': {
	                        content: '""',
	                        position: 'absolute',
	                        borderRadius: borderRadiusSmall.borderRadiusSmall,
	                        left: '-4px',
	                        right: '-4px',
	                        ...(compact
	                            ? {
	                                top: '2px',
	                                bottom: '2px',
	                            }
	                            : {
	                                top: '6px',
	                                bottom: '6px',
	                            }),
	                    },
	                }, hoverMediaQuery.hoverMediaQuery({
	                    '&::before': {
	                        transition: validateProps.getTransition('background-color'),
	                    },
	                    '&:hover::before': {
	                        background: hoverColor,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            background: hoverColorDark,
	                        }),
	                    },
	                })),
	                ...validateProps.getFocusJssStyle(theme, { pseudo: true, offset: '-2px' }),
	            },
	        },
	        heading: {
	            margin: 0,
	            ...(sticky && {
	                position: 'sticky',
	                top: `var(${cssVariablePositionStickyTop}, ${positionStickyTopFallback})`,
	                zIndex: 1, // to be on top of the collapsible
	                backgroundColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    backgroundColor: backgroundColorDark,
	                }),
	            }),
	        },
	        'icon-container': {
	            height: fontLineHeight.fontLineHeight,
	            width: fontLineHeight.fontLineHeight,
	            display: 'flex',
	            alignItems: 'center',
	            justifyContent: 'center',
	        },
	        icon: {
	            width: fontLineHeight.fontLineHeight,
	            height: fontLineHeight.fontLineHeight,
	            fontSize: fontSizeTextXXSmall.fontSizeTextXXSmall,
	            transform: open ? 'rotate3d(0)' : 'rotate3d(0,0,1,90deg)',
	            transition: validateProps.getTransition('transform'),
	        },
	        collapsible: {
	            color: primaryColor, // enables color inheritance for slotted content
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                color: primaryColorDark,
	            }),
	            display: 'grid',
	            ...(sticky && {
	                position: 'relative',
	                zIndex: 0, // to be below the heading
	            }),
	            ...(open
	                ? {
	                    gridTemplateRows: '1fr',
	                    visibility: 'inherit',
	                    transition: validateProps.getTransition('grid-template-rows'),
	                    paddingBottom: compact ? spacingStaticSmall.spacingStaticSmall : '24px',
	                }
	                : {
	                    gridTemplateRows: '0fr',
	                    visibility: 'hidden',
	                    transition: `${validateProps.getTransition('grid-template-rows')}, visibility 0s linear var(${validateProps.cssVariableTransitionDuration}, ${validateProps.motionDurationShort})`,
	                }),
	            '& div': {
	                overflow: open ? 'visible' : 'hidden',
	                // Fix overflow issues for overlapping content (e.g. select dropdown)
	                animation: open ? `$overflow var(${validateProps.cssVariableTransitionDuration},${validateProps.motionDurationShort})` : 'none',
	                // Necessary to make focus outlines fully visible
	                padding: '4px',
	                margin: '-4px',
	                // Fix scrollbar issues when slotted content includes .sr-only styles (see issue #3042)
	                transform: 'translate3d(0,0,0)',
	                zIndex: 1,
	            },
	        },
	        '@keyframes overflow': {
	            from: { overflow: 'hidden' },
	            to: { overflow: 'hidden' },
	        },
	    });
	};

	const propTypes = {
	    size: validateProps.AllowedTypes.breakpoint(ACCORDION_SIZES),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    heading: validateProps.AllowedTypes.string,
	    headingTag: validateProps.AllowedTypes.oneOf(headingTag.HEADING_TAGS),
	    tag: validateProps.AllowedTypes.oneOf([undefined, ...headingTag.HEADING_TAGS]),
	    open: validateProps.AllowedTypes.boolean,
	    compact: validateProps.AllowedTypes.boolean,
	    sticky: validateProps.AllowedTypes.boolean,
	};
	const Accordion = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.accordionChange = validateProps.createEvent(this, "accordionChange", 3);
	        this.update = validateProps.createEvent(this, "update", 3);
	        this.onButtonClick = () => {
	            this.update.emit({ open: !this.open });
	            this.accordionChange.emit({ open: !this.open });
	        };
	        this.size = 'small';
	        this.theme = 'light';
	        this.heading = undefined;
	        this.headingTag = 'h2';
	        this.tag = undefined;
	        this.open = undefined;
	        this.compact = undefined;
	        this.sticky = undefined;
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'tag', 'Please use heading-tag prop instead.');
	        validateProps.attachComponentCss(this.host, getComponentCss, this.size, this.compact, this.open, this.theme, this.sticky);
	        const buttonId = 'accordion-control';
	        const contentId = 'accordion-panel';
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        const Heading = this.tag || this.headingTag;
	        return (validateProps.h(validateProps.Host, { key: 'dd7f6f320b82d948f68945a6b546947656a38042' }, validateProps.h(Heading, { key: '54c29a7f85e6d06e902a6e803a734cbda00b765b', class: "heading" }, validateProps.h("button", { key: 'd006b4b0cb6293c939a3a12f787cbcaace5bfe19', id: buttonId, type: "button", "aria-expanded": this.open ? 'true' : 'false', "aria-controls": contentId, onClick: this.onButtonClick }, this.heading || validateProps.h("slot", { name: "heading" }), validateProps.h("span", { key: '8473ef626d232e1a2c091e060842f530b94bd6a9', class: "icon-container" }, validateProps.h(PrefixedTagNames.pIcon, { key: '057307c864a6c3667e5652bde7d0cb6b2f380777', class: "icon", name: this.open ? 'minus' : 'plus', theme: this.theme, size: "xx-small", "aria-hidden": "true" })))), validateProps.h("div", { key: '42ed77ad0a01d5c2a45533848cd302ea143c76b9', id: contentId, class: "collapsible", role: "region", "aria-labelledby": buttonId }, validateProps.h("div", { key: '7180016c5ece176fc239cc17430165f8c6b17da2' }, validateProps.h("slot", { key: '21b76e1a033578f327955d534df2cccdb4b662f6' })))));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pAccordion_cjs_entry.p_accordion = Accordion;

	
	return pAccordion_cjs_entry;
}

var pBanner_cjs_entry = {};

var warnIfDeprecatedPropValueIsUsed2d6d1d94 = {};

var hasRequiredWarnIfDeprecatedPropValueIsUsed2d6d1d94;

function requireWarnIfDeprecatedPropValueIsUsed2d6d1d94 () {
	if (hasRequiredWarnIfDeprecatedPropValueIsUsed2d6d1d94) return warnIfDeprecatedPropValueIsUsed2d6d1d94;
	hasRequiredWarnIfDeprecatedPropValueIsUsed2d6d1d94 = 1;

	const helper = requireHelperA66adcf2();
	const validateProps = requireValidatePropsF6586828();

	const warnIfDeprecatedPropValueIsUsed = (instance, prop, deprecationMap) => {
	    const value = instance[prop];
	    if (deprecationMap[value]) {
	        const deprecatedPropWarningMessage = helper.getDeprecatedPropOrSlotWarningMessage(instance.host, `${prop}='${value}'`);
	        validateProps.consoleWarn(deprecatedPropWarningMessage, `Please use ${prop}='${deprecationMap[value]}' instead.`);
	    }
	};

	warnIfDeprecatedPropValueIsUsed2d6d1d94.warnIfDeprecatedPropValueIsUsed = warnIfDeprecatedPropValueIsUsed;

	
	return warnIfDeprecatedPropValueIsUsed2d6d1d94;
}

var hasRequiredPBanner_cjs_entry;

function requirePBanner_cjs_entry () {
	if (hasRequiredPBanner_cjs_entry) return pBanner_cjs_entry;
	hasRequiredPBanner_cjs_entry = 1;

	Object.defineProperty(pBanner_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const bannerUtils = requireBannerUtils2cc83734();
	const hasNamedSlot = requireHasNamedSlotA96fd22a();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed2d6d1d94();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed0dc3288b();
	const theme = requireThemeBfc10573();
	const headingTag = requireHeadingTag6cfe20fe();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const constants = requireConstantsCa271244();
	const gridExtendedOffsetBase = requireGridExtendedOffsetBaseFb9830f6();
	const dropShadowHighStyle = requireDropShadowHighStyle7edcadc6();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const gridExtendedOffsetXXL = requireGridExtendedOffsetXXLC7a41e50();
	const helper = requireHelperA66adcf2();
	requireGetNamedSlotA0cdbdbc();
	requireDropShadowShared6e50faf3();
	requireGridGapB5b73e4a();
	requireSpacingFluidMedium88ab712b();

	const getBannerPopoverResetStyles = () => {
	    return {
	        position: 'fixed',
	        margin: 0,
	        padding: 0,
	        width: 'auto', // ua popover reset
	        height: 'auto', // ua popover reset
	        maxWidth: '100%', // If component is wrapped in container with maxWidth
	        border: '0', // ua popover reset
	        outline: '0', // ua popover reset
	        overflow: 'visible', // ua popover reset
	    };
	};

	const cssVariableTop = '--p-banner-position-top';
	const cssVariableBottom = '--p-banner-position-bottom';
	const cssVariableZIndex = '--p-internal-banner-z-index';
	const topBottomFallback = '56px';
	const getComponentCss = (isOpen) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...getBannerPopoverResetStyles(),
	                    bottom: `var(${cssVariableBottom},${topBottomFallback})`,
	                    left: gridExtendedOffsetBase.gridExtendedOffsetBase,
	                    right: gridExtendedOffsetBase.gridExtendedOffsetBase,
	                    zIndex: `var(${cssVariableZIndex},${constants.BANNER_Z_INDEX})`,
	                    ...dropShadowHighStyle.dropShadowHighStyle,
	                    borderRadius: borderRadiusSmall.borderRadiusSmall, // needed for rounded box-shadow
	                    ...(isOpen
	                        ? {
	                            opacity: 1,
	                            visibility: 'inherit',
	                            pointerEvents: 'inherit',
	                            transform: 'translate3d(0,0,0)',
	                            transition: `${validateProps.getTransition('transform', 'moderate', 'in')}, ${validateProps.getTransition('opacity', 'moderate', 'in')}`,
	                        }
	                        : {
	                            opacity: 0,
	                            visibility: 'hidden',
	                            pointerEvents: 'none',
	                            transform: `translate3d(0,calc(var(${cssVariableBottom},${topBottomFallback}) + 100%),0)`,
	                            '&(.hydrated),&(.ssr)': {
	                                transition: `visibility 0s linear var(${validateProps.cssVariableTransitionDuration}, ${validateProps.motionDurationLong}), ${validateProps.getTransition('transform', 'moderate', 'out')}, ${validateProps.getTransition('opacity', 'moderate', 'out')}`,
	                                // during transition the element will be removed from top-layer immediately, resulting in other elements laying over (as of Mai 2024 only Chrome is fixed by this)
	                                '@supports (transition-behavior: allow-discrete)': {
	                                    transition: `visibility 0s linear var(${validateProps.cssVariableTransitionDuration}, ${validateProps.motionDurationLong}), ${validateProps.getTransition('transform', 'moderate', 'out')}, ${validateProps.getTransition('opacity', 'moderate', 'out')}, overlay var(${validateProps.cssVariableTransitionDuration}, ${validateProps.motionDurationModerate}) ${validateProps.motionEasingOut} allow-discrete`,
	                                },
	                            },
	                        }),
	                    [validateProps.getMediaQueryMin('s')]: {
	                        top: `var(${cssVariableTop},${topBottomFallback})`,
	                        bottom: 'auto',
	                        left: gridExtendedOffsetXXL.gridExtendedOffsetS,
	                        right: gridExtendedOffsetXXL.gridExtendedOffsetS,
	                        // space before and after "-" is crucial)
	                        ...(!isOpen && { transform: `translate3d(0,calc(-100% - var(${cssVariableTop},${topBottomFallback})),0)` }),
	                    },
	                    [validateProps.getMediaQueryMin('xxl')]: {
	                        left: gridExtendedOffsetXXL.gridExtendedOffsetXXL,
	                        right: gridExtendedOffsetXXL.gridExtendedOffsetXXL,
	                    },
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	        },
	    });
	};

	const propTypes = {
	    open: validateProps.AllowedTypes.boolean,
	    heading: validateProps.AllowedTypes.string,
	    headingTag: validateProps.AllowedTypes.oneOf(headingTag.HEADING_TAGS),
	    description: validateProps.AllowedTypes.string,
	    state: validateProps.AllowedTypes.oneOf(bannerUtils.BANNER_STATES),
	    dismissButton: validateProps.AllowedTypes.boolean,
	    persistent: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Banner = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.dismiss = validateProps.createEvent(this, "dismiss", 3);
	        this.onKeyboardEvent = (event) => {
	            if (event.key === 'Escape') {
	                this.dismissBanner();
	            }
	        };
	        this.onDismiss = (event) => {
	            if (this.hasDismissButton) {
	                event?.stopPropagation(); // prevent double event emission because of identical name
	                this.dismiss.emit();
	            }
	        };
	        this.dismissBanner = () => {
	            this.dismiss.emit();
	        };
	        this.open = false;
	        this.heading = '';
	        this.headingTag = 'h5';
	        this.description = '';
	        this.state = 'info';
	        this.dismissButton = true;
	        this.persistent = undefined;
	        this.width = undefined;
	        this.theme = 'light';
	    }
	    get hasDismissButton() {
	        return this.persistent ? false : this.dismissButton;
	    }
	    openChangeHandler(isOpen) {
	        if (this.hasDismissButton) {
	            if (isOpen) {
	                document.addEventListener('keydown', this.onKeyboardEvent);
	            }
	            else {
	                document.removeEventListener('keydown', this.onKeyboardEvent);
	            }
	        }
	    }
	    connectedCallback() {
	        if (this.open && this.hasDismissButton) {
	            document.addEventListener('keydown', this.onKeyboardEvent);
	        }
	    }
	    componentDidRender() {
	        // showPopover needs to be called after render cycle to prepare visibility states of popover in order to focus the dismiss button correctly
	        this.setBannerVisibility(this.open);
	        if (this.hasDismissButton) {
	            this.closeBtn = validateProps.getShadowRootHTMLElement(this.inlineNotificationElement, '.close');
	            this.closeBtn?.focus();
	        }
	    }
	    disconnectedCallback() {
	        if (this.open && this.hasDismissButton) {
	            document.removeEventListener('keydown', this.onKeyboardEvent);
	        }
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'state', {
	            neutral: 'info',
	        });
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'persistent', 'Please use dismissButton prop instead.');
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'width', 'The component is aligned with Porsche Grid "extended" by default.');
	        const hasTitleSlot = hasNamedSlot.hasNamedSlot(this.host, 'title');
	        if (hasTitleSlot) {
	            validateProps.consoleWarn(helper.getDeprecatedPropOrSlotWarningMessage(this.host, 'slot="title"'), 'Please use the heading prop or slot="heading" instead.');
	        }
	        validateProps.attachComponentCss(this.host, getComponentCss, this.open);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(validateProps.Host, { key: '67b6287f6d89d04dac1293be11b2f94d4aad5f13', popover: "manual" }, validateProps.h(PrefixedTagNames.pInlineNotification, { key: '23d04b33162d5c1ef6aae7f7a4e71dd534e68bd8', ref: (el) => (this.inlineNotificationElement = el), heading: this.heading, headingTag: this.headingTag, description: this.description, state: this.state, dismissButton: this.hasDismissButton, theme: this.theme, onDismiss: this.onDismiss, "aria-hidden": !this.open ? 'true' : 'false' }, hasNamedSlot.hasNamedSlot(this.host, 'heading') ? (validateProps.h("slot", { name: "heading", slot: "heading" })) : (hasTitleSlot && validateProps.h("slot", { name: "title", slot: "heading" })), hasNamedSlot.hasNamedSlot(this.host, 'description') && validateProps.h("slot", { name: "description" }))));
	    }
	    setBannerVisibility(isOpen) {
	        if (isOpen) {
	            this.host.showPopover();
	        }
	        else {
	            this.host.hidePopover();
	        }
	    }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "open": ["openChangeHandler"]
	    }; }
	};

	pBanner_cjs_entry.p_banner = Banner;

	
	return pBanner_cjs_entry;
}

var pButtonGroup_cjs_entry = {};

var spacingFluidSmall2c6caae7 = {};

var hasRequiredSpacingFluidSmall2c6caae7;

function requireSpacingFluidSmall2c6caae7 () {
	if (hasRequiredSpacingFluidSmall2c6caae7) return spacingFluidSmall2c6caae7;
	hasRequiredSpacingFluidSmall2c6caae7 = 1;

	const spacingFluidSmall = 'clamp(8px, 0.5vw + 6px, 16px)';

	spacingFluidSmall2c6caae7.spacingFluidSmall = spacingFluidSmall;

	
	return spacingFluidSmall2c6caae7;
}

var hasRequiredPButtonGroup_cjs_entry;

function requirePButtonGroup_cjs_entry () {
	if (hasRequiredPButtonGroup_cjs_entry) return pButtonGroup_cjs_entry;
	hasRequiredPButtonGroup_cjs_entry = 1;

	Object.defineProperty(pButtonGroup_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const groupDirectionStyles = requireGroupDirectionStylesC4bd8b11();
	const spacingFluidSmall = requireSpacingFluidSmall2c6caae7();

	const getComponentCss = (direction) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            div: {
	                display: 'flex',
	                gap: spacingFluidSmall.spacingFluidSmall,
	                ...validateProps.buildResponsiveStyles(direction, groupDirectionStyles.getGroupDirectionJssStyles),
	            },
	        },
	    });
	};

	const propTypes = {
	    direction: validateProps.AllowedTypes.breakpoint(groupDirectionStyles.GROUP_DIRECTIONS),
	};
	const ButtonGroup = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.direction = { base: 'column', xs: 'row' };
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.direction);
	        return (validateProps.h("div", { key: '57dd9fde2385b5e6152a67c208b1f5a0781fbd84', role: "group" }, validateProps.h("slot", { key: 'c90b4ad6be795d881403a178c31a531309b724fb' })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pButtonGroup_cjs_entry.p_button_group = ButtonGroup;

	
	return pButtonGroup_cjs_entry;
}

var pButtonPure_cjs_entry = {};

var textSizeBe3fca13 = {};

var hasRequiredTextSizeBe3fca13;

function requireTextSizeBe3fca13 () {
	if (hasRequiredTextSizeBe3fca13) return textSizeBe3fca13;
	hasRequiredTextSizeBe3fca13 = 1;

	const TEXT_SIZES = ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'inherit'];

	textSizeBe3fca13.TEXT_SIZES = TEXT_SIZES;

	
	return textSizeBe3fca13;
}

var typographyTextWeight02ea3596 = {};

var hasRequiredTypographyTextWeight02ea3596;

function requireTypographyTextWeight02ea3596 () {
	if (hasRequiredTypographyTextWeight02ea3596) return typographyTextWeight02ea3596;
	hasRequiredTypographyTextWeight02ea3596 = 1;

	// 'thin' is deprecated and will be mapped to 'regular'
	// 'semibold' is deprecated and will be mapped to 'semi-bold'
	/** @deprecated */
	const TYPOGRAPHY_TEXT_WEIGHTS_DEPRECATED = ['thin', 'semibold'];
	const TYPOGRAPHY_TEXT_WEIGHTS = ['regular', 'semi-bold', 'bold', ...TYPOGRAPHY_TEXT_WEIGHTS_DEPRECATED];

	typographyTextWeight02ea3596.TYPOGRAPHY_TEXT_WEIGHTS = TYPOGRAPHY_TEXT_WEIGHTS;

	
	return typographyTextWeight02ea3596;
}

var hasRequiredPButtonPure_cjs_entry;

function requirePButtonPure_cjs_entry () {
	if (hasRequiredPButtonPure_cjs_entry) return pButtonPure_cjs_entry;
	hasRequiredPButtonPure_cjs_entry = 1;

	Object.defineProperty(pButtonPure_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const buttonType = requireButtonTypeAe0c09db();
	const isDisabledOrLoading = requireIsDisabledOrLoadingB1f56d7f();
	const buttonHandling = requireButtonHandlingB33ae166();
	const buttonLinkPureUtils = requireButtonLinkPureUtils1db4d1d1();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed2d6d1d94();
	const theme = requireThemeBfc10573();
	const textSize = requireTextSizeBe3fca13();
	const typographyTextWeight = requireTypographyTextWeight02ea3596();
	const alignLabel = requireAlignLabel7a9d9074();
	const getButtonBaseAriaAttributes = requireGetButtonBaseAriaAttributes2b382c95();
	const linkButtonPureStyles = requireLinkButtonPureStyles67cba12c();
	const initialLoadingController = requireInitialLoadingController44585a09();
	const fontLineHeight = requireFontLineHeight78b03658();
	requireGetClosestHTMLElement83d01a84();
	requireSetAttributes642a7e67();
	requireIsParentOfKindB7d9f81c();
	requireHelperA66adcf2();
	requireColorSchemeStyles4bc3d59c();
	requireHoverMediaQuery5e6deda8();
	requireFontSizeTextXXSmallA02f9c40();
	requireFontSizeTextXSmallE59d35d7();
	requireFontSizeTextSmall508930e5();
	requireFontSizeTextMedium88887ad8();
	requireFontSizeTextLarge05a4bc90();
	requireFontSizeTextXLarge0ecf9ef3();
	requireTextSmallStyle7246779a();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireSpacingStaticXSmallB7d708b8();
	requireBorderRadiusSmall5f37fc45();

	const warnIfIsLoadingAndIconIsNone = (host, loading, iconName, iconSource) => {
	    if (loading && !buttonLinkPureUtils.hasVisibleIcon(iconName, iconSource)) {
	        validateProps.consoleWarn(`combination of properties icon='${iconName}' and loading='${loading}' for component ${validateProps.getTagNameWithoutPrefix(host)} is not supported.`);
	    }
	};
	const getButtonPureAriaAttributes = (isDisabled, isLoading, aria) => {
	    return {
	        ...validateProps.parseAndGetAriaAttributes(aria),
	        ...getButtonBaseAriaAttributes.getButtonBaseAriaAttributes(isDisabled, isLoading),
	    };
	};

	const getComponentCss = (icon, iconSource, active, isLoading, isDisabledOrLoading, stretch, size, hideLabel, alignLabel, underline, theme) => {
	    const hasIcon = buttonLinkPureUtils.hasVisibleIcon(icon, iconSource);
	    return validateProps.getCss(validateProps.mergeDeep(linkButtonPureStyles.getLinkButtonPureStyles(icon, iconSource, active, isDisabledOrLoading, stretch, size, hideLabel, alignLabel, underline, false, theme), {
	        root: {
	            WebkitAppearance: 'none', // iOS safari
	            appearance: 'none',
	            background: 'transparent',
	            textAlign: 'start',
	            border: 0,
	            cursor: isDisabledOrLoading ? 'not-allowed' : 'pointer',
	        },
	        ...(!hasIcon &&
	            isLoading && {
	            label: {
	                opacity: 0, // use opacity for smooth transition between states and to keep accessible name available
	            },
	            icon: {
	                position: 'absolute',
	                top: 0,
	                left: `calc(50% - ${fontLineHeight.fontLineHeight} / 2)`,
	                width: fontLineHeight.fontLineHeight,
	                height: fontLineHeight.fontLineHeight,
	            },
	        }),
	        // .loading
	        ...initialLoadingController.getFunctionalComponentLoadingMessageStyles(),
	    }));
	};

	const propTypes = {
	    type: validateProps.AllowedTypes.oneOf(buttonType.BUTTON_TYPES),
	    name: validateProps.AllowedTypes.string,
	    value: validateProps.AllowedTypes.string,
	    disabled: validateProps.AllowedTypes.boolean,
	    loading: validateProps.AllowedTypes.boolean,
	    size: validateProps.AllowedTypes.breakpoint(textSize.TEXT_SIZES),
	    weight: validateProps.AllowedTypes.oneOf(typographyTextWeight.TYPOGRAPHY_TEXT_WEIGHTS),
	    icon: validateProps.AllowedTypes.string,
	    iconSource: validateProps.AllowedTypes.string,
	    underline: validateProps.AllowedTypes.boolean,
	    active: validateProps.AllowedTypes.boolean,
	    hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	    alignLabel: validateProps.AllowedTypes.breakpoint(alignLabel.ALIGN_LABELS),
	    stretch: validateProps.AllowedTypes.breakpoint('boolean'),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    aria: validateProps.AllowedTypes.aria(buttonType.BUTTON_ARIA_ATTRIBUTES),
	};
	const ButtonPure = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.controllerHost = new initialLoadingController.ControllerHost(this);
	        this.loadingCtrl = new initialLoadingController.InitialLoadingController(this.controllerHost);
	        this.type = 'submit';
	        this.name = undefined;
	        this.value = undefined;
	        this.disabled = false;
	        this.loading = false;
	        this.size = 'small';
	        this.weight = 'regular';
	        this.icon = 'arrow-right';
	        this.iconSource = undefined;
	        this.underline = false;
	        this.active = false;
	        this.hideLabel = false;
	        this.alignLabel = 'end';
	        this.stretch = false;
	        this.theme = 'light';
	        this.aria = undefined;
	    }
	    get isDisabledOrLoading() {
	        return isDisabledOrLoading.isDisabledOrLoading(this.disabled, this.loading);
	    }
	    // this stops click events when button is disabled
	    onClick(e) {
	        if (this.isDisabledOrLoading) {
	            e.stopPropagation();
	        }
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    componentDidLoad() {
	        buttonHandling.improveButtonHandlingForCustomElement(this.host, () => this.type, () => this.isDisabledOrLoading, () => this.name, () => this.value);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfIsLoadingAndIconIsNone(this.host, this.loading, this.icon, this.iconSource);
	        buttonLinkPureUtils.warnIfParentIsPTextAndIconIsNone(this.host, this.icon, this.iconSource);
	        const alignLabelDeprecationMap = {
	            left: 'start',
	            right: 'end',
	        };
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'alignLabel', alignLabelDeprecationMap);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.icon, this.iconSource, this.active, this.loading, this.isDisabledOrLoading, this.stretch, this.size, this.hideLabel, this.alignLabel, this.underline, this.theme);
	        const hasIcon = buttonLinkPureUtils.hasVisibleIcon(this.icon, this.iconSource);
	        const iconProps = {
	            class: 'icon',
	            size: 'inherit',
	            theme: this.theme,
	        };
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(validateProps.Host, { key: 'f7d5949a40f34b49e934e9bead428ee05237b313' }, validateProps.h("button", { key: '72c2fa19b147af4d147fa811be5825a4d27eacc9', ...getButtonPureAriaAttributes(this.disabled, this.loading, this.aria), class: "root", type: this.type, name: this.name, value: this.value, "aria-describedby": this.loading ? initialLoadingController.loadingId : undefined }, this.loading ? (validateProps.h(PrefixedTagNames.pSpinner, { ...iconProps, "aria-hidden": "true" })) : (hasIcon && (validateProps.h(PrefixedTagNames.pIcon, { ...iconProps, name: this.icon, source: this.iconSource, color: this.isDisabledOrLoading ? 'state-disabled' : 'primary', theme: this.theme, "aria-hidden": "true" }))), validateProps.h("span", { key: '144f47b16b30426a0ee8f632a86f15aef43bd084', class: "label" }, validateProps.h("slot", { key: '328e93e89400acaa612e32c80cd50ba5e7dbaae6' }))), validateProps.h(initialLoadingController.LoadingMessage, { key: 'e94a4071bdeeb84842f370aa4b055ef5cf73cccd', loading: this.loading, initialLoading: this.loadingCtrl.initialLoading })));
	    }
	    static get delegatesFocus() { return true; }
	    get host() { return validateProps.getElement(this); }
	};

	pButtonPure_cjs_entry.p_button_pure = ButtonPure;

	
	return pButtonPure_cjs_entry;
}

var pButtonTile_cjs_entry = {};

var hasRequiredPButtonTile_cjs_entry;

function requirePButtonTile_cjs_entry () {
	if (hasRequiredPButtonTile_cjs_entry) return pButtonTile_cjs_entry;
	hasRequiredPButtonTile_cjs_entry = 1;

	Object.defineProperty(pButtonTile_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const buttonType = requireButtonTypeAe0c09db();
	const isDisabledOrLoading = requireIsDisabledOrLoadingB1f56d7f();
	const linkTileUtils = requireLinkTileUtilsF366cfed();
	const tileBaseStyles = requireTileBaseStyles0dff2b0f();
	requireFontWeightStylesB74e8683();
	requireFontWeightRegularD0c768ac();
	requireFontWeightSemiBold4482c830();
	requireFontSizeTextMedium88887ad8();
	requireSpacingFluidMedium88ab712b();
	requireSpacingFluidLarge6087a0f7();
	requireThemeBfc10573();
	requireTextShared9135e2ef();
	requireFontLineHeight78b03658();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextLarge05a4bc90();
	requireColorSchemeStyles4bc3d59c();
	requireHoverMediaQuery5e6deda8();
	requireTextIconStyles990609fb();
	requireBorderRadiusLargeA0aa3a01();
	requireSpacingStaticMedium94812711();

	const getComponentCss = (isDisabledOrLoading, ...args) => {
	    const buttonLinkTileStyles = linkTileUtils.getButtonLinkTileStyles(...args);
	    return validateProps.getCss({
	        ...buttonLinkTileStyles,
	        root: {
	            ...buttonLinkTileStyles.root,
	            cursor: isDisabledOrLoading ? 'not-allowed' : 'pointer',
	        },
	    });
	};

	const propTypes = {
	    ...linkTileUtils.sharedTilePropTypes,
	    weight: validateProps.AllowedTypes.breakpoint(tileBaseStyles.TILE_WEIGHTS),
	    type: validateProps.AllowedTypes.oneOf(buttonType.BUTTON_TYPES),
	    disabled: validateProps.AllowedTypes.boolean,
	    loading: validateProps.AllowedTypes.boolean,
	    icon: validateProps.AllowedTypes.string,
	    iconSource: validateProps.AllowedTypes.string,
	    aria: validateProps.AllowedTypes.aria(buttonType.BUTTON_ARIA_ATTRIBUTES),
	};
	const ButtonTile = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.size = 'default';
	        this.weight = 'semi-bold';
	        this.background = 'dark';
	        this.aspectRatio = '4:3';
	        this.label = undefined;
	        this.description = undefined;
	        this.align = 'bottom';
	        this.gradient = true;
	        this.compact = false;
	        this.type = 'submit';
	        this.disabled = false;
	        this.loading = false;
	        this.icon = 'none';
	        this.iconSource = undefined;
	        this.aria = undefined;
	    }
	    onClick(e) {
	        if (isDisabledOrLoading.isDisabledOrLoading(this.disabled, this.loading)) {
	            e.stopPropagation();
	        }
	    }
	    componentWillLoad() {
	        linkTileUtils.throwIfAlignTopAndNotCompact(this.host, this.align, this.compact);
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        this.compact = validateProps.parseJSON(this.compact); // parsing the value just once per lifecycle
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, getComponentCss, isDisabledOrLoading.isDisabledOrLoading(this.disabled, this.loading), this.aspectRatio, this.size, this.weight, this.background, this.align, this.compact, this.gradient, this.disabled);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        const buttonProps = {
	            theme: this.background,
	            variant: 'secondary',
	            iconSource: this.iconSource,
	            type: this.type,
	            disabled: this.disabled,
	            loading: this.loading,
	            aria: this.aria,
	        };
	        const button = (validateProps.h(PrefixedTagNames.pButton, { ...buttonProps, icon: this.icon, key: "link-or-button", class: "link-or-button" }, this.label));
	        const buttonPure = (validateProps.h(PrefixedTagNames.pButtonPure, { ...buttonProps, key: "link-or-button-pure", class: "link-or-button-pure", hideLabel: true, icon: this.icon === 'none' ? 'arrow-right' : this.icon }, this.label));
	        return (validateProps.h("div", { key: 'ec78ae921034ab9815ec678a1fb534e5ad77d15c', class: "root" }, validateProps.h("div", { key: '4ebd6b63eeadefce03180d8815002e41c5f6ffcc', class: "image-container" }, validateProps.h("slot", { key: '77d42e0e778b98d882f9692b44e4784c59605628' })), validateProps.h("div", { key: '00d0306d50cad48edb83b20f1be4b55a8e46004f', class: "content" }, validateProps.h("p", { key: '7799b026bc39d930e37fc544c3ea5f3819d749d5' }, this.description), typeof this.compact === 'boolean' ? (this.compact ? buttonPure : button) : [buttonPure, button])));
	    }
	    static get delegatesFocus() { return true; }
	    get host() { return validateProps.getElement(this); }
	};

	pButtonTile_cjs_entry.p_button_tile = ButtonTile;

	
	return pButtonTile_cjs_entry;
}

var pButton_cjs_entry = {};

var hasRequiredPButton_cjs_entry;

function requirePButton_cjs_entry () {
	if (hasRequiredPButton_cjs_entry) return pButton_cjs_entry;
	hasRequiredPButton_cjs_entry = 1;

	Object.defineProperty(pButton_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const buttonType = requireButtonTypeAe0c09db();
	const isDisabledOrLoading = requireIsDisabledOrLoadingB1f56d7f();
	const buttonHandling = requireButtonHandlingB33ae166();
	const buttonLinkPureUtils = requireButtonLinkPureUtils1db4d1d1();
	const theme = requireThemeBfc10573();
	const linkButtonVariant = requireLinkButtonVariant3104b925();
	const getButtonBaseAriaAttributes = requireGetButtonBaseAriaAttributes2b382c95();
	const linkButtonStyles = requireLinkButtonStylesAafed6b0();
	const initialLoadingController = requireInitialLoadingController44585a09();
	const fontLineHeight = requireFontLineHeight78b03658();
	requireGetClosestHTMLElement83d01a84();
	requireSetAttributes642a7e67();
	requireIsParentOfKindB7d9f81c();
	requireColorSchemeStyles4bc3d59c();
	requireHoverMediaQuery5e6deda8();
	requireBorderRadiusSmall5f37fc45();
	requireTextSmallStyle7246779a();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireSpacingStaticSmall2130ed04();

	const getButtonAriaAttributes = (isDisabled, isLoading, aria) => {
	    return {
	        ...validateProps.parseAndGetAriaAttributes(aria),
	        ...getButtonBaseAriaAttributes.getButtonBaseAriaAttributes(isDisabled, isLoading),
	    };
	};

	const getDisabledColors = (variant, loading, theme) => {
	    const { contrastMediumColor, contrastHighColor, disabledColor, hoverColor } = validateProps.getThemedColors(theme);
	    const { canvasColor } = validateProps.getHighContrastColors();
	    const colors = {
	        primary: {
	            textColor: validateProps.isHighContrastMode ? disabledColor : contrastHighColor,
	            borderColor: validateProps.isHighContrastMode ? disabledColor : loading ? contrastHighColor : disabledColor,
	            backgroundColor: validateProps.isHighContrastMode ? canvasColor : loading ? contrastHighColor : disabledColor,
	        },
	        secondary: {
	            textColor: disabledColor,
	            borderColor: validateProps.isHighContrastMode ? disabledColor : loading ? contrastMediumColor : disabledColor,
	            backgroundColor: validateProps.isHighContrastMode ? canvasColor : loading ? hoverColor : 'transparent',
	        },
	    };
	    return colors[variant === 'tertiary' ? 'secondary' : variant];
	};
	const getComponentCss = (icon, iconSource, variant, hideLabel, disabled, loading, theme) => {
	    const disabledOrLoading = isDisabledOrLoading.isDisabledOrLoading(disabled, loading);
	    const { textColor, borderColor, backgroundColor } = getDisabledColors(variant, loading, theme);
	    const { textColor: textColorDark, borderColor: borderColorDark, backgroundColor: backgroundColorDark, } = getDisabledColors(variant, loading, 'dark');
	    const isPrimary = variant === 'primary';
	    return validateProps.getCss(validateProps.mergeDeep(linkButtonStyles.getLinkButtonStyles(icon, iconSource, variant, hideLabel, disabledOrLoading, false, theme), {
	        root: {
	            cursor: disabledOrLoading ? 'not-allowed' : 'pointer',
	            ...(disabledOrLoading && {
	                backgroundColor,
	                borderColor,
	                color: textColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    backgroundColor: backgroundColorDark,
	                    borderColor: borderColorDark,
	                    color: textColorDark,
	                }),
	            }),
	            ...(loading && !isPrimary && validateProps.frostedGlassStyle),
	            margin: 0, // Removes default button margin on safari 15
	        },
	        ...(loading && {
	            spinner: {
	                width: fontLineHeight.fontLineHeight,
	                height: fontLineHeight.fontLineHeight,
	                pointerEvents: 'none',
	                position: 'absolute',
	                top: '50%',
	                left: '50%',
	                transform: 'translate(-50%, -50%)',
	                ...(isPrimary && !validateProps.isHighContrastMode && { filter: 'invert(1)' }),
	            },
	        }),
	        label: {
	            transition: validateProps.getTransition('opacity'),
	            ...(loading && {
	                opacity: 0, // use opacity for smooth transition between states
	            }),
	        },
	        icon: {
	            transition: validateProps.getTransition('opacity'),
	            ...(!disabled &&
	                isPrimary &&
	                !validateProps.isHighContrastMode && {
	                filter: 'invert(1)',
	            }),
	            ...(loading && {
	                opacity: 0, // use opacity for smooth transition between states
	            }),
	        },
	        // .loading
	        ...initialLoadingController.getFunctionalComponentLoadingMessageStyles(),
	    }));
	};

	const propTypes = {
	    type: validateProps.AllowedTypes.oneOf(buttonType.BUTTON_TYPES),
	    name: validateProps.AllowedTypes.string,
	    value: validateProps.AllowedTypes.string,
	    variant: validateProps.AllowedTypes.oneOf(linkButtonVariant.LINK_BUTTON_VARIANTS),
	    disabled: validateProps.AllowedTypes.boolean,
	    loading: validateProps.AllowedTypes.boolean,
	    icon: validateProps.AllowedTypes.string,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    iconSource: validateProps.AllowedTypes.string,
	    hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	    aria: validateProps.AllowedTypes.aria(buttonType.BUTTON_ARIA_ATTRIBUTES),
	};
	const Button = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.controllerHost = new initialLoadingController.ControllerHost(this);
	        this.loadingCtrl = new initialLoadingController.InitialLoadingController(this.controllerHost);
	        this.type = 'submit';
	        this.name = undefined;
	        this.value = undefined;
	        this.disabled = false;
	        this.loading = false;
	        this.variant = 'primary';
	        this.icon = 'none';
	        this.iconSource = undefined;
	        this.hideLabel = false;
	        this.theme = 'light';
	        this.aria = undefined;
	    }
	    onClick(e) {
	        if (isDisabledOrLoading.isDisabledOrLoading(this.disabled, this.loading)) {
	            e.stopPropagation();
	        }
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    componentDidLoad() {
	        buttonHandling.improveButtonHandlingForCustomElement(this.host, () => this.type, () => isDisabledOrLoading.isDisabledOrLoading(this.disabled, this.loading), () => this.name, () => this.value);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.icon, this.iconSource, this.variant, this.hideLabel, this.disabled, this.loading, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(validateProps.Host, { key: '0eb5a0cffd0fdc775a7665e0614d3c2804a8306a' }, validateProps.h("button", { key: 'dda090bf43476830e35a8c62307528f8c34acf84', ...getButtonAriaAttributes(this.disabled, this.loading, this.aria), class: "root", type: this.type, name: this.name, value: this.value, "aria-describedby": this.loading ? initialLoadingController.loadingId : undefined }, this.loading && (validateProps.h(PrefixedTagNames.pSpinner, { class: "spinner", size: "inherit", theme: this.theme, "aria-hidden": "true" })), buttonLinkPureUtils.hasVisibleIcon(this.icon, this.iconSource) && (validateProps.h(PrefixedTagNames.pIcon, { class: "icon", size: "inherit", name: this.iconSource ? undefined : this.icon, source: this.iconSource, color: this.disabled ? (this.variant === 'primary' ? 'contrast-high' : 'state-disabled') : 'primary', theme: this.theme, "aria-hidden": "true" })), validateProps.h("span", { key: '7aadc8edb249e7acf9296779e1193dfd18adb426', class: "label" }, validateProps.h("slot", { key: 'dbe07f8bd6191ee05eb41b21996a32ad8ccf6ae2' }))), validateProps.h(initialLoadingController.LoadingMessage, { key: 'b237ac0b44b3bb0186d3358337a263871b418616', loading: this.loading, initialLoading: this.loadingCtrl.initialLoading })));
	    }
	    static get delegatesFocus() { return true; }
	    get host() { return validateProps.getElement(this); }
	};

	pButton_cjs_entry.p_button = Button;

	
	return pButton_cjs_entry;
}

var pCarousel_cjs_entry = {};

var hasRequiredPCarousel_cjs_entry;

function requirePCarousel_cjs_entry () {
	if (hasRequiredPCarousel_cjs_entry) return pCarousel_cjs_entry;
	hasRequiredPCarousel_cjs_entry = 1;

	Object.defineProperty(pCarousel_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const gridBasicOffset = requireGridBasicOffsetEafb13d6();
	const spacingFluidMedium = requireSpacingFluidMedium88ab712b();
	const borderRadiusLarge = requireBorderRadiusLargeA0aa3a01();
	const headingXXLargeStyle = requireHeadingXXLargeStyle139a1eb3();
	const headingShared = requireHeadingSharedAa59e66d();
	const spacingFluidSmall = requireSpacingFluidSmall2c6caae7();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const getMediaQueryMax = requireGetMediaQueryMaxBbf4c490();
	const gridGap = requireGridGapB5b73e4a();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const hasNamedSlot = requireHasNamedSlotA96fd22a();
	const hasDescription = requireHasDescriptionBbe55afe();
	const hasHeading = requireHasHeading6f9fd2ca();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed2d6d1d94();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed0dc3288b();
	const theme = requireThemeBfc10573();
	requireGridExtendedOffsetBaseFb9830f6();
	requireGridExtendedOffsetXXLC7a41e50();
	requireFontSizeTextXLarge0ecf9ef3();
	requireFontLineHeight78b03658();
	requireFontWeightSemiBold4482c830();
	requireFontVariant6ba3b7cb();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontSizeTextSmall508930e5();
	requireGetNamedSlotA0cdbdbc();
	requireHelperA66adcf2();

	const headingXLargeStyle = {
	    font: `${headingShared._headingFontPartA}${headingXXLargeStyle.fontSizeHeadingXLarge}${headingShared._headingFontPartB}`,
	};

	const cssVariablePrevNextFilter = '--p-carousel-prev-next-filter';
	const carouselTransitionDuration = validateProps.motionDurationModerate;
	const paginationInfiniteStartCaseClass = 'pagination--infinite';
	const bulletClass = 'bullet';
	const bulletActiveClass = 'bullet--active';
	const bulletInfiniteClass = 'bullet--infinite';
	const paginationVisibleBulletCount = 5;
	const paginationBulletSize = '8px';
	const paginationInfiniteBulletSize = '4px';
	const paginationActiveBulletSize = '20px';
	const paginationGap = '8px';
	const paginationWidth = `calc(${paginationActiveBulletSize} + ${paginationBulletSize} * ${paginationVisibleBulletCount - 1} + ${paginationGap} * ${paginationVisibleBulletCount - 1})`; // Width for one active bullet + width of inactive bullets + spacing
	const paginationInset = '8px'; // Used to increase clickable area on touch devices
	const paginationGapLarge = '16px';
	const paginationWidthLarge = `calc(${paginationActiveBulletSize} + ${paginationBulletSize} * ${paginationVisibleBulletCount - 1} + ${paginationGapLarge} * ${paginationVisibleBulletCount - 1} + 2 * ${paginationInset})`; // Width for one active bullet + width of inactive bullets + spacing
	const selectorHeading = 'h2,::slotted([slot="heading"])';
	const selectorDescription = 'p,::slotted([slot="description"])';
	const mediaQueryS = validateProps.getMediaQueryMin('s');
	const mediaQueryXXL = validateProps.getMediaQueryMin('xxl');
	const mediaQueryPointerCoarse = '@media (pointer: coarse)';
	const spacingMap = {
	    basic: gridBasicOffset.gridBasicOffset,
	    extended: gridBasicOffset.gridExtendedOffset,
	};
	const backfaceVisibilityJssStyle = {
	    backfaceVisibility: 'hidden',
	    WebkitBackfaceVisibility: 'hidden',
	};
	const getComponentCss = (hasHeading, hasDescription, hasControlsSlot, headingSize, width, hasPagination, isInfinitePagination, alignHeader, theme) => {
	    const { primaryColor, contrastMediumColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, contrastMediumColor: contrastMediumColorDark } = validateProps.getThemedColors('dark');
	    const { canvasTextColor } = validateProps.getHighContrastColors();
	    const isHeaderAlignCenter = alignHeader === 'center';
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'flex',
	                ...validateProps.addImportantToEachRule({
	                    gap: spacingFluidMedium.spacingFluidMedium, // TODO: maybe it's better to style by margin on .splide, then styles would be part of shadow dom
	                    flexDirection: 'column',
	                    boxSizing: 'content-box', // ensures padding is added to host instead of subtracted
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...(hasControlsSlot && {
	                ['slot[name="controls"]']: {
	                    display: 'block',
	                    gridColumnStart: 1,
	                    gridRowStart: 3,
	                    alignSelf: 'center', // ensures vertical alignment to prev/next buttons
	                },
	            }),
	            ...validateProps.addImportantToEachRule({
	                '::slotted': {
	                    '&(*)': {
	                        borderRadius: `var(--p-carousel-border-radius, ${borderRadiusLarge.borderRadiusLarge})`,
	                    },
	                    ...validateProps.getFocusJssStyle(theme, { slotted: true }),
	                },
	                // TODO: maybe it's better to style with slot[name="heading"] and slot[name="description"] instead, then styles would be part of shadow dom
	                // h2,::slotted([slot=heading]),p,::slotted([slot=description])
	                ...((hasHeading || hasDescription) && {
	                    [`${selectorHeading},${selectorDescription}`]: {
	                        gridColumn: '1/-1',
	                        color: primaryColor,
	                        ...(isHeaderAlignCenter && {
	                            textAlign: 'center', // relevant in case heading or description becomes multiline
	                            justifySelf: 'center', // relevant for horizontal alignment of heading and description in case max-width applies
	                        }),
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            color: primaryColorDark,
	                        }),
	                    },
	                }),
	                // h2,::slotted([slot=heading])
	                ...(hasHeading && {
	                    [selectorHeading]: {
	                        maxWidth: '56.25rem',
	                        margin: `0 0 ${!hasDescription ? spacingFluidMedium.spacingFluidMedium : 0}`,
	                        ...(headingSize === 'xx-large' ? headingXXLargeStyle.headingXXLargeStyle : headingXLargeStyle),
	                    },
	                }),
	                // p,::slotted([slot=description])
	                ...(hasDescription && {
	                    [selectorDescription]: {
	                        maxWidth: '34.375rem',
	                        margin: `${spacingFluidSmall.spacingFluidSmall} 0 ${spacingFluidMedium.spacingFluidMedium}`,
	                        ...textSmallStyle.textSmallStyle,
	                    },
	                }),
	            }),
	        },
	        header: {
	            display: 'grid',
	            padding: `0 ${spacingMap[width].base}`,
	            [mediaQueryS]: {
	                gridTemplateColumns: 'minmax(0px, 1fr) auto',
	                columnGap: spacingStaticMedium.spacingStaticMedium,
	                padding: `0 ${spacingMap[width].s}`,
	            },
	            [mediaQueryXXL]: {
	                padding: `0 ${spacingMap[width].xxl}`,
	            },
	        },
	        nav: {
	            display: 'none',
	            [mediaQueryS]: {
	                gridRowStart: '3',
	                gridColumnEnd: '-1',
	                display: 'flex',
	                gap: spacingStaticXSmall.spacingStaticXSmall,
	                alignSelf: 'flex-start', // relevant in case slot="header" becomes higher than nav group
	            },
	            filter: `var(${cssVariablePrevNextFilter}, none)`,
	        },
	        btn: {
	            padding: spacingStaticSmall.spacingStaticSmall,
	        },
	        'skip-link': {
	            // :focus must be used in this case, because :focus-visible is just matched on the focusable element itself, not on the host element.
	            '&:not(:focus)': {
	                opacity: 0,
	                pointerEvents: 'none',
	            },
	        },
	        splide: {
	            overflow: 'hidden',
	            padding: '4px 0', // for slide focus outline
	            margin: '-4px 0', // for slide focus outline
	            '&__track': {
	                // !important is necessary to override inline styles set by splide library
	                ...validateProps.addImportantToEachRule({
	                    padding: `0 ${spacingMap[width].base}`,
	                    [getMediaQueryMax.getMediaQueryMax('xs')]: {
	                        paddingRight: `calc(${gridBasicOffset.gridBasicOffsetBase} + ${gridGap.gridGap})`, // we need to give cut off slides a bit more space on mobile views
	                    },
	                    [mediaQueryS]: {
	                        padding: `0 ${spacingMap[width].s}`,
	                    },
	                    [mediaQueryXXL]: {
	                        padding: `0 ${spacingMap[width].xxl}`,
	                    },
	                }),
	                '&--draggable': {
	                    cursor: 'grab',
	                    userSelect: 'none',
	                    WebkitUserSelect: 'none',
	                    WebkitTouchCallout: 'none',
	                },
	            },
	            '&__list': {
	                ...backfaceVisibilityJssStyle,
	                display: 'flex',
	            },
	            '&__slide': {
	                ...backfaceVisibilityJssStyle,
	                flexShrink: 0,
	                transform: 'translateZ(0)', // fixes mobile safari flickering, https://github.com/nolimits4web/swiper/issues/3527#issuecomment-609088939
	            },
	            '&__sr': validateProps.getHiddenTextJssStyle(), // appears in the DOM when sliding
	        },
	        ...(hasPagination && {
	            'pagination-container': {
	                ...validateProps.buildResponsiveStyles(hasPagination, (hasPaginationValue) => ({
	                    display: hasPaginationValue ? 'flex' : 'none',
	                })),
	                position: 'relative',
	                justifyContent: isInfinitePagination ? 'flex-start' : 'center',
	                width: paginationWidth,
	                left: `calc(50% - (${paginationWidth}) / 2)`,
	                [mediaQueryPointerCoarse]: {
	                    width: paginationWidthLarge,
	                    left: `calc(50% - ${paginationWidthLarge} / 2)`,
	                },
	                overflowX: 'hidden',
	            },
	            pagination: {
	                display: 'flex',
	                alignItems: 'center',
	                width: 'fit-content',
	                height: paginationBulletSize, // Needed to avoid jumping when rewinding dynamically added slides
	                gap: paginationGap,
	                [mediaQueryPointerCoarse]: {
	                    height: `calc(${paginationBulletSize} + 2 * ${paginationInset})`,
	                    gap: paginationGapLarge,
	                },
	                transition: `transform ${carouselTransitionDuration}`,
	            },
	            [bulletClass]: {
	                // Increase clickable area on touch devices
	                [mediaQueryPointerCoarse]: {
	                    '&::before': {
	                        content: '""',
	                        position: 'absolute',
	                        inset: `-${paginationInset}`,
	                    },
	                    position: 'relative',
	                },
	                borderRadius: borderRadiusSmall.borderRadiusSmall,
	                ...(validateProps.isHighContrastMode
	                    ? {
	                        background: canvasTextColor,
	                    }
	                    : {
	                        background: contrastMediumColor,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            background: contrastMediumColorDark,
	                        }),
	                    }),
	                ...(isInfinitePagination
	                    ? {
	                        width: '0px',
	                        height: '0px',
	                        transition: `background-color ${carouselTransitionDuration}, width ${carouselTransitionDuration}, height ${carouselTransitionDuration}`,
	                    }
	                    : {
	                        width: paginationBulletSize,
	                        height: paginationBulletSize,
	                        transition: `background-color ${carouselTransitionDuration}, width ${carouselTransitionDuration}`,
	                    }),
	                ...hoverMediaQuery.hoverMediaQuery({
	                    cursor: 'pointer',
	                }),
	            },
	            ...(isInfinitePagination && {
	                [paginationInfiniteStartCaseClass]: {
	                    [`& > .${bulletClass}:nth-child(-n+4)`]: {
	                        width: paginationBulletSize,
	                        height: paginationBulletSize,
	                    },
	                },
	                [bulletInfiniteClass]: {
	                    // Necessary to override the bulletActiveClass sibling selector
	                    ...validateProps.addImportantToEachRule({
	                        width: paginationInfiniteBulletSize,
	                        height: paginationInfiniteBulletSize,
	                    }),
	                    [`& ~ .${bulletClass}`]: {
	                        width: paginationBulletSize,
	                        height: paginationBulletSize,
	                    },
	                    [`& ~ .${bulletInfiniteClass} ~ .${bulletClass}`]: {
	                        width: '0px',
	                        height: '0px',
	                    },
	                },
	            }),
	            [bulletActiveClass]: {
	                ...(validateProps.isHighContrastMode
	                    ? {
	                        background: canvasTextColor,
	                    }
	                    : {
	                        background: primaryColor,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            background: primaryColorDark,
	                        }),
	                    }),
	                height: paginationBulletSize,
	                width: validateProps.addImportantToRule(paginationActiveBulletSize),
	                ...(isInfinitePagination && {
	                    [`& ~ .${bulletClass}`]: {
	                        width: paginationBulletSize,
	                        height: paginationBulletSize,
	                    },
	                    [`& ~ .${bulletInfiniteClass} ~ .${bulletClass}`]: {
	                        width: '0px',
	                        height: '0px',
	                    },
	                }),
	            },
	        }),
	    });
	};

	const CAROUSEL_WIDTHS = ['basic', 'extended'];
	// 'left' is deprecated and will be mapped to 'start'
	/** @deprecated */
	const CAROUSEL_ALIGN_HEADERS_DEPRECATED = ['left'];
	const CAROUSEL_ALIGN_HEADERS = ['start', 'center', ...CAROUSEL_ALIGN_HEADERS_DEPRECATED];
	const CAROUSEL_ARIA_ATTRIBUTES = ['aria-label'];
	// The offset value used for calculating the number of infinite bullets
	const INFINITE_BULLET_OFFSET = 2;
	// The total number of infinite bullets including the center bullet
	const INFINITE_BULLET_AMOUNT = INFINITE_BULLET_OFFSET * 2 + 1;
	// Infinite bullets will be shown if the total number of bullets is greater than this value
	const INFINITE_BULLET_THRESHOLD = 5;
	const getSplideBreakpoints = (perPage) => {
	    return typeof perPage === 'object'
	        ? Object.entries(perPage).reduce((result, [key, val]) => ({
	            ...result,
	            [validateProps.breakpoint[key]]: {
	                // round to sanitize floating numbers
	                perPage: Math.round(val),
	            },
	        }), {})
	        : {
	            0: {
	                // round to sanitize floating numbers
	                perPage: perPage === 'auto' ? 1 : Math.round(perPage),
	            },
	        };
	};
	const getSlidesAndAddAttributes = (host) => {
	    const slides = Array.from(host.children).filter(({ slot }) => slot !== 'heading' && slot !== 'description' && slot !== 'controls');
	    slides.forEach((el, i) => {
	        el.setAttribute('slot', `slide-${i}`);
	        el.setAttribute('tabindex', '0');
	    });
	    return slides;
	};
	const getAmountOfPages = (amountOfSlides, slidesPerPage) => {
	    return amountOfSlides === 0 ? 0 : amountOfSlides < slidesPerPage ? 1 : amountOfSlides - slidesPerPage + 1;
	};
	const isFirstPage = (splide) => splide.index === 0;
	const isLastPage = (splide, amountOfPages) => splide.index >= amountOfPages - 1; // catch removal of slide
	const slidePrev = (splide, amountOfPages) => {
	    // sanitize in case of removal of slide since splide.index seems to be from before splide.refresh()
	    const prevSlide = splide.index === amountOfPages ? splide.index - 2 : '<';
	    splide.go(isFirstPage(splide) ? amountOfPages - 1 : prevSlide);
	};
	const slideNext = (splide, amountOfPages) => {
	    splide.go(isLastPage(splide, amountOfPages) ? 0 : '>');
	};
	const updatePrevNextButtons = (btnPrev, btnNext, splide) => {
	    const { i18n, rewind } = splide.options;
	    const isFirst = isFirstPage(splide);
	    btnPrev.disabled = isFirst && !rewind;
	    btnPrev.aria = { 'aria-label': i18n[isFirst ? 'last' : 'prev'] };
	    const isLast = isLastPage(splide, getAmountOfPages(splide.length, splide.options.perPage));
	    btnNext.disabled = isLast && !rewind;
	    btnNext.aria = {
	        'aria-label': i18n[isLast ? 'first' : 'next'],
	    };
	};
	const isInfinitePagination = (amountOfPages) => {
	    return amountOfPages > INFINITE_BULLET_THRESHOLD;
	};
	const renderPagination = (paginationEl, amountOfPages, activeIndex, splide) => {
	    if (paginationEl) {
	        // sanitize in case of removal of slide since activeIndex is from before splide.refresh()
	        activeIndex = activeIndex > amountOfPages - 1 ? amountOfPages - 1 : activeIndex;
	        paginationEl.innerHTML = Array.from(Array(amountOfPages), (_, i) => `<span class="bullet${i === activeIndex ? ' ' + bulletActiveClass : ''}"></span>`).join('');
	        paginationEl.addEventListener('click', (e) => {
	            const target = e.composedPath()[0];
	            if (target.classList.contains(bulletClass)) {
	                splide.go(Array.from(paginationEl.children).indexOf(target));
	            }
	        });
	        if (isInfinitePagination(amountOfPages)) {
	            updateBulletState(paginationEl, amountOfPages, activeIndex);
	        }
	    }
	};
	const updateBulletState = (paginationEl, amountOfPages, newIndex) => {
	    const isStartCase = newIndex < INFINITE_BULLET_OFFSET;
	    const isEndCase = newIndex > amountOfPages - 1 - INFINITE_BULLET_OFFSET;
	    const infiniteBulletRightIndex = newIndex + INFINITE_BULLET_OFFSET;
	    const infiniteBulletLeftIndex = newIndex - INFINITE_BULLET_OFFSET;
	    const endCaseInfiniteBulletIndex = amountOfPages - INFINITE_BULLET_AMOUNT;
	    const startCaseInfiniteBulletIndex = INFINITE_BULLET_AMOUNT - 1;
	    const isInfiniteBulletLeft = (bulletIndex) => isEndCase ? bulletIndex === endCaseInfiniteBulletIndex : bulletIndex === infiniteBulletLeftIndex;
	    const isInfiniteBulletRight = (bulletIndex) => isStartCase ? bulletIndex === startCaseInfiniteBulletIndex : bulletIndex === infiniteBulletRightIndex;
	    const paginationGap = getComputedStyle(paginationEl).columnGap; // Touch devices use a larger gap
	    const getTranslateX = () => {
	        if (isStartCase) {
	            return '0';
	        }
	        else if (isEndCase) {
	            return `calc(-${amountOfPages - INFINITE_BULLET_AMOUNT} * ${paginationGap})`;
	        }
	        else {
	            return `calc(-${newIndex - INFINITE_BULLET_OFFSET} * ${paginationGap})`;
	        }
	    };
	    paginationEl.style.transform = `translateX(${getTranslateX()})`;
	    // Only update bullets around newIndex
	    for (let i = newIndex - INFINITE_BULLET_AMOUNT - 1; i < newIndex + INFINITE_BULLET_AMOUNT + 1; i++) {
	        const index = (i + amountOfPages) % amountOfPages;
	        paginationEl.children[index].classList.toggle(bulletInfiniteClass, isInfiniteBulletLeft(index) || isInfiniteBulletRight(index));
	    }
	    // Add/Remove class to pagination in order to style the first bullets when the index is in isStartCase
	    paginationEl.classList.toggle(paginationInfiniteStartCaseClass, isStartCase);
	};
	const updatePagination = (paginationEl, amountOfPages, newIndex) => {
	    if (paginationEl) {
	        paginationEl.querySelector('.' + bulletActiveClass).classList.remove(bulletActiveClass);
	        paginationEl.children[newIndex].classList.add(bulletActiveClass);
	        if (isInfinitePagination(amountOfPages)) {
	            updateBulletState(paginationEl, amountOfPages, newIndex);
	        }
	    }
	};

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

	/*!
	 * Splide.js
	 * Version  : 4.1.4
	 * License  : MIT
	 * Copyright: 2022 Naotoshi Fujita
	 */
	var MEDIA_PREFERS_REDUCED_MOTION = "(prefers-reduced-motion: reduce)";
	var CREATED = 1;
	var MOUNTED = 2;
	var IDLE = 3;
	var MOVING = 4;
	var SCROLLING = 5;
	var DRAGGING = 6;
	var DESTROYED = 7;
	var STATES = {
	  CREATED: CREATED,
	  MOUNTED: MOUNTED,
	  IDLE: IDLE,
	  MOVING: MOVING,
	  SCROLLING: SCROLLING,
	  DRAGGING: DRAGGING,
	  DESTROYED: DESTROYED
	};

	function empty(array) {
	  array.length = 0;
	}

	function slice(arrayLike, start, end) {
	  return Array.prototype.slice.call(arrayLike, start, end);
	}

	function apply(func) {
	  return func.bind.apply(func, [null].concat(slice(arguments, 1)));
	}

	var nextTick = setTimeout;

	var noop = function noop() {};

	function raf(func) {
	  return requestAnimationFrame(func);
	}

	function typeOf(type, subject) {
	  return typeof subject === type;
	}

	function isObject(subject) {
	  return !isNull(subject) && typeOf("object", subject);
	}

	var isArray = Array.isArray;
	var isFunction = apply(typeOf, "function");
	var isString = apply(typeOf, "string");
	var isUndefined = apply(typeOf, "undefined");

	function isNull(subject) {
	  return subject === null;
	}

	function isHTMLElement(subject) {
	  try {
	    return subject instanceof (subject.ownerDocument.defaultView || window).HTMLElement;
	  } catch (e) {
	    return false;
	  }
	}

	function toArray(value) {
	  return isArray(value) ? value : [value];
	}

	function forEach(values, iteratee) {
	  toArray(values).forEach(iteratee);
	}

	function includes(array, value) {
	  return array.indexOf(value) > -1;
	}

	function push(array, items) {
	  array.push.apply(array, toArray(items));
	  return array;
	}

	function toggleClass(elm, classes, add) {
	  if (elm) {
	    forEach(classes, function (name) {
	      if (name) {
	        elm.classList[add ? "add" : "remove"](name);
	      }
	    });
	  }
	}

	function addClass(elm, classes) {
	  toggleClass(elm, isString(classes) ? classes.split(" ") : classes, true);
	}

	function append(parent, children) {
	  forEach(children, parent.appendChild.bind(parent));
	}

	function before(nodes, ref) {
	  forEach(nodes, function (node) {
	    var parent = (ref || node).parentNode;

	    if (parent) {
	      parent.insertBefore(node, ref);
	    }
	  });
	}

	function matches(elm, selector) {
	  return isHTMLElement(elm) && (elm["msMatchesSelector"] || elm.matches).call(elm, selector);
	}

	function children(parent, selector) {
	  var children2 = parent ? slice(parent.children) : [];
	  return selector ? children2.filter(function (child) {
	    return matches(child, selector);
	  }) : children2;
	}

	function child(parent, selector) {
	  return selector ? children(parent, selector)[0] : parent.firstElementChild;
	}

	var ownKeys = Object.keys;

	function forOwn(object, iteratee, right) {
	  if (object) {
	    (right ? ownKeys(object).reverse() : ownKeys(object)).forEach(function (key) {
	      key !== "__proto__" && iteratee(object[key], key);
	    });
	  }

	  return object;
	}

	function assign(object) {
	  slice(arguments, 1).forEach(function (source) {
	    forOwn(source, function (value, key) {
	      object[key] = source[key];
	    });
	  });
	  return object;
	}

	function merge(object) {
	  slice(arguments, 1).forEach(function (source) {
	    forOwn(source, function (value, key) {
	      if (isArray(value)) {
	        object[key] = value.slice();
	      } else if (isObject(value)) {
	        object[key] = merge({}, isObject(object[key]) ? object[key] : {}, value);
	      } else {
	        object[key] = value;
	      }
	    });
	  });
	  return object;
	}

	function omit(object, keys) {
	  forEach(keys || ownKeys(object), function (key) {
	    delete object[key];
	  });
	}

	function removeAttribute(elms, attrs) {
	  forEach(elms, function (elm) {
	    forEach(attrs, function (attr) {
	      elm && elm.removeAttribute(attr);
	    });
	  });
	}

	function setAttribute(elms, attrs, value) {
	  if (isObject(attrs)) {
	    forOwn(attrs, function (value2, name) {
	      setAttribute(elms, name, value2);
	    });
	  } else {
	    forEach(elms, function (elm) {
	      isNull(value) || value === "" ? removeAttribute(elm, attrs) : elm.setAttribute(attrs, String(value));
	    });
	  }
	}

	function create(tag, attrs, parent) {
	  var elm = document.createElement(tag);

	  if (attrs) {
	    isString(attrs) ? addClass(elm, attrs) : setAttribute(elm, attrs);
	  }

	  parent && append(parent, elm);
	  return elm;
	}

	function style(elm, prop, value) {
	  if (isUndefined(value)) {
	    return getComputedStyle(elm)[prop];
	  }

	  if (!isNull(value)) {
	    elm.style[prop] = "" + value;
	  }
	}

	function display(elm, display2) {
	  style(elm, "display", display2);
	}

	function focus(elm) {
	  elm["setActive"] && elm["setActive"]() || elm.focus({
	    preventScroll: true
	  });
	}

	function getAttribute(elm, attr) {
	  return elm.getAttribute(attr);
	}

	function hasClass(elm, className) {
	  return elm && elm.classList.contains(className);
	}

	function rect(target) {
	  return target.getBoundingClientRect();
	}

	function remove(nodes) {
	  forEach(nodes, function (node) {
	    if (node && node.parentNode) {
	      node.parentNode.removeChild(node);
	    }
	  });
	}

	function parseHtml(html) {
	  return child(new DOMParser().parseFromString(html, "text/html").body);
	}

	function prevent(e, stopPropagation) {
	  e.preventDefault();

	  if (stopPropagation) {
	    e.stopPropagation();
	    e.stopImmediatePropagation();
	  }
	}

	function query(parent, selector) {
	  return parent && parent.querySelector(selector);
	}

	function queryAll(parent, selector) {
	  return selector ? slice(parent.querySelectorAll(selector)) : [];
	}

	function removeClass(elm, classes) {
	  toggleClass(elm, classes, false);
	}

	function timeOf(e) {
	  return e.timeStamp;
	}

	function unit(value) {
	  return isString(value) ? value : value ? value + "px" : "";
	}

	var PROJECT_CODE = "splide";
	var DATA_ATTRIBUTE = "data-" + PROJECT_CODE;

	function assert(condition, message) {
	  if (!condition) {
	    throw new Error("[" + PROJECT_CODE + "] " + (message || ""));
	  }
	}

	var min = Math.min,
	    max = Math.max,
	    floor = Math.floor,
	    ceil = Math.ceil,
	    abs = Math.abs;

	function approximatelyEqual(x, y, epsilon) {
	  return abs(x - y) < epsilon;
	}

	function between(number, x, y, exclusive) {
	  var minimum = min(x, y);
	  var maximum = max(x, y);
	  return exclusive ? minimum < number && number < maximum : minimum <= number && number <= maximum;
	}

	function clamp(number, x, y) {
	  var minimum = min(x, y);
	  var maximum = max(x, y);
	  return min(max(minimum, number), maximum);
	}

	function sign(x) {
	  return +(x > 0) - +(x < 0);
	}

	function format(string, replacements) {
	  forEach(replacements, function (replacement) {
	    string = string.replace("%s", "" + replacement);
	  });
	  return string;
	}

	function pad(number) {
	  return number < 10 ? "0" + number : "" + number;
	}

	var ids = {};

	function uniqueId(prefix) {
	  return "" + prefix + pad(ids[prefix] = (ids[prefix] || 0) + 1);
	}

	function EventBinder() {
	  var listeners = [];

	  function bind(targets, events, callback, options) {
	    forEachEvent(targets, events, function (target, event, namespace) {
	      var isEventTarget = ("addEventListener" in target);
	      var remover = isEventTarget ? target.removeEventListener.bind(target, event, callback, options) : target["removeListener"].bind(target, callback);
	      isEventTarget ? target.addEventListener(event, callback, options) : target["addListener"](callback);
	      listeners.push([target, event, namespace, callback, remover]);
	    });
	  }

	  function unbind(targets, events, callback) {
	    forEachEvent(targets, events, function (target, event, namespace) {
	      listeners = listeners.filter(function (listener) {
	        if (listener[0] === target && listener[1] === event && listener[2] === namespace && (!callback || listener[3] === callback)) {
	          listener[4]();
	          return false;
	        }

	        return true;
	      });
	    });
	  }

	  function dispatch(target, type, detail) {
	    var e;
	    var bubbles = true;

	    if (typeof CustomEvent === "function") {
	      e = new CustomEvent(type, {
	        bubbles: bubbles,
	        detail: detail
	      });
	    } else {
	      e = document.createEvent("CustomEvent");
	      e.initCustomEvent(type, bubbles, false, detail);
	    }

	    target.dispatchEvent(e);
	    return e;
	  }

	  function forEachEvent(targets, events, iteratee) {
	    forEach(targets, function (target) {
	      target && forEach(events, function (events2) {
	        events2.split(" ").forEach(function (eventNS) {
	          var fragment = eventNS.split(".");
	          iteratee(target, fragment[0], fragment[1]);
	        });
	      });
	    });
	  }

	  function destroy() {
	    listeners.forEach(function (data) {
	      data[4]();
	    });
	    empty(listeners);
	  }

	  return {
	    bind: bind,
	    unbind: unbind,
	    dispatch: dispatch,
	    destroy: destroy
	  };
	}

	var EVENT_MOUNTED = "mounted";
	var EVENT_READY = "ready";
	var EVENT_MOVE = "move";
	var EVENT_MOVED = "moved";
	var EVENT_CLICK = "click";
	var EVENT_ACTIVE = "active";
	var EVENT_INACTIVE = "inactive";
	var EVENT_VISIBLE = "visible";
	var EVENT_HIDDEN = "hidden";
	var EVENT_REFRESH = "refresh";
	var EVENT_UPDATED = "updated";
	var EVENT_RESIZE = "resize";
	var EVENT_RESIZED = "resized";
	var EVENT_DRAG = "drag";
	var EVENT_DRAGGING = "dragging";
	var EVENT_DRAGGED = "dragged";
	var EVENT_SCROLL = "scroll";
	var EVENT_SCROLLED = "scrolled";
	var EVENT_OVERFLOW = "overflow";
	var EVENT_DESTROY = "destroy";
	var EVENT_ARROWS_MOUNTED = "arrows:mounted";
	var EVENT_ARROWS_UPDATED = "arrows:updated";
	var EVENT_PAGINATION_MOUNTED = "pagination:mounted";
	var EVENT_PAGINATION_UPDATED = "pagination:updated";
	var EVENT_NAVIGATION_MOUNTED = "navigation:mounted";
	var EVENT_AUTOPLAY_PLAY = "autoplay:play";
	var EVENT_AUTOPLAY_PLAYING = "autoplay:playing";
	var EVENT_AUTOPLAY_PAUSE = "autoplay:pause";
	var EVENT_LAZYLOAD_LOADED = "lazyload:loaded";
	var EVENT_SLIDE_KEYDOWN = "sk";
	var EVENT_SHIFTED = "sh";
	var EVENT_END_INDEX_CHANGED = "ei";

	function EventInterface(Splide2) {
	  var bus = Splide2 ? Splide2.event.bus : document.createDocumentFragment();
	  var binder = EventBinder();

	  function on(events, callback) {
	    binder.bind(bus, toArray(events).join(" "), function (e) {
	      callback.apply(callback, isArray(e.detail) ? e.detail : []);
	    });
	  }

	  function emit(event) {
	    binder.dispatch(bus, event, slice(arguments, 1));
	  }

	  if (Splide2) {
	    Splide2.event.on(EVENT_DESTROY, binder.destroy);
	  }

	  return assign(binder, {
	    bus: bus,
	    on: on,
	    off: apply(binder.unbind, bus),
	    emit: emit
	  });
	}

	function RequestInterval(interval, onInterval, onUpdate, limit) {
	  var now = Date.now;
	  var startTime;
	  var rate = 0;
	  var id;
	  var paused = true;
	  var count = 0;

	  function update() {
	    if (!paused) {
	      rate = interval ? min((now() - startTime) / interval, 1) : 1;
	      onUpdate && onUpdate(rate);

	      if (rate >= 1) {
	        onInterval();
	        startTime = now();

	        if (limit && ++count >= limit) {
	          return pause();
	        }
	      }

	      id = raf(update);
	    }
	  }

	  function start(resume) {
	    resume || cancel();
	    startTime = now() - (resume ? rate * interval : 0);
	    paused = false;
	    id = raf(update);
	  }

	  function pause() {
	    paused = true;
	  }

	  function rewind() {
	    startTime = now();
	    rate = 0;

	    if (onUpdate) {
	      onUpdate(rate);
	    }
	  }

	  function cancel() {
	    id && cancelAnimationFrame(id);
	    rate = 0;
	    id = 0;
	    paused = true;
	  }

	  function set(time) {
	    interval = time;
	  }

	  function isPaused() {
	    return paused;
	  }

	  return {
	    start: start,
	    rewind: rewind,
	    pause: pause,
	    cancel: cancel,
	    set: set,
	    isPaused: isPaused
	  };
	}

	function State(initialState) {
	  var state = initialState;

	  function set(value) {
	    state = value;
	  }

	  function is(states) {
	    return includes(toArray(states), state);
	  }

	  return {
	    set: set,
	    is: is
	  };
	}

	function Throttle(func, duration) {
	  var interval = RequestInterval(duration || 0, func, null, 1);
	  return function () {
	    interval.isPaused() && interval.start();
	  };
	}

	function Media(Splide2, Components2, options) {
	  var state = Splide2.state;
	  var breakpoints = options.breakpoints || {};
	  var reducedMotion = options.reducedMotion || {};
	  var binder = EventBinder();
	  var queries = [];

	  function setup() {
	    var isMin = options.mediaQuery === "min";
	    ownKeys(breakpoints).sort(function (n, m) {
	      return isMin ? +n - +m : +m - +n;
	    }).forEach(function (key) {
	      register(breakpoints[key], "(" + (isMin ? "min" : "max") + "-width:" + key + "px)");
	    });
	    register(reducedMotion, MEDIA_PREFERS_REDUCED_MOTION);
	    update();
	  }

	  function destroy(completely) {
	    if (completely) {
	      binder.destroy();
	    }
	  }

	  function register(options2, query) {
	    var queryList = matchMedia(query);
	    binder.bind(queryList, "change", update);
	    queries.push([options2, queryList]);
	  }

	  function update() {
	    var destroyed = state.is(DESTROYED);
	    var direction = options.direction;
	    var merged = queries.reduce(function (merged2, entry) {
	      return merge(merged2, entry[1].matches ? entry[0] : {});
	    }, {});
	    omit(options);
	    set(merged);

	    if (options.destroy) {
	      Splide2.destroy(options.destroy === "completely");
	    } else if (destroyed) {
	      destroy(true);
	      Splide2.mount();
	    } else {
	      direction !== options.direction && Splide2.refresh();
	    }
	  }

	  function reduce(enable) {
	    if (matchMedia(MEDIA_PREFERS_REDUCED_MOTION).matches) {
	      enable ? merge(options, reducedMotion) : omit(options, ownKeys(reducedMotion));
	    }
	  }

	  function set(opts, base, notify) {
	    merge(options, opts);
	    base && merge(Object.getPrototypeOf(options), opts);

	    if (notify || !state.is(CREATED)) {
	      Splide2.emit(EVENT_UPDATED, options);
	    }
	  }

	  return {
	    setup: setup,
	    destroy: destroy,
	    reduce: reduce,
	    set: set
	  };
	}

	var ARROW = "Arrow";
	var ARROW_LEFT = ARROW + "Left";
	var ARROW_RIGHT = ARROW + "Right";
	var ARROW_UP = ARROW + "Up";
	var ARROW_DOWN = ARROW + "Down";
	var RTL = "rtl";
	var TTB = "ttb";
	var ORIENTATION_MAP = {
	  width: ["height"],
	  left: ["top", "right"],
	  right: ["bottom", "left"],
	  x: ["y"],
	  X: ["Y"],
	  Y: ["X"],
	  ArrowLeft: [ARROW_UP, ARROW_RIGHT],
	  ArrowRight: [ARROW_DOWN, ARROW_LEFT]
	};

	function Direction(Splide2, Components2, options) {
	  function resolve(prop, axisOnly, direction) {
	    direction = direction || options.direction;
	    var index = direction === RTL && !axisOnly ? 1 : direction === TTB ? 0 : -1;
	    return ORIENTATION_MAP[prop] && ORIENTATION_MAP[prop][index] || prop.replace(/width|left|right/i, function (match, offset) {
	      var replacement = ORIENTATION_MAP[match.toLowerCase()][index] || match;
	      return offset > 0 ? replacement.charAt(0).toUpperCase() + replacement.slice(1) : replacement;
	    });
	  }

	  function orient(value) {
	    return value * (options.direction === RTL ? 1 : -1);
	  }

	  return {
	    resolve: resolve,
	    orient: orient
	  };
	}

	var ROLE = "role";
	var TAB_INDEX = "tabindex";
	var DISABLED = "disabled";
	var ARIA_PREFIX = "aria-";
	var ARIA_CONTROLS = ARIA_PREFIX + "controls";
	var ARIA_CURRENT = ARIA_PREFIX + "current";
	var ARIA_SELECTED = ARIA_PREFIX + "selected";
	var ARIA_LABEL = ARIA_PREFIX + "label";
	var ARIA_LABELLEDBY = ARIA_PREFIX + "labelledby";
	var ARIA_HIDDEN = ARIA_PREFIX + "hidden";
	var ARIA_ORIENTATION = ARIA_PREFIX + "orientation";
	var ARIA_ROLEDESCRIPTION = ARIA_PREFIX + "roledescription";
	var ARIA_LIVE = ARIA_PREFIX + "live";
	var ARIA_BUSY = ARIA_PREFIX + "busy";
	var ARIA_ATOMIC = ARIA_PREFIX + "atomic";
	var ALL_ATTRIBUTES = [ROLE, TAB_INDEX, DISABLED, ARIA_CONTROLS, ARIA_CURRENT, ARIA_LABEL, ARIA_LABELLEDBY, ARIA_HIDDEN, ARIA_ORIENTATION, ARIA_ROLEDESCRIPTION];
	var CLASS_PREFIX = PROJECT_CODE + "__";
	var STATUS_CLASS_PREFIX = "is-";
	var CLASS_ROOT = PROJECT_CODE;
	var CLASS_TRACK = CLASS_PREFIX + "track";
	var CLASS_LIST = CLASS_PREFIX + "list";
	var CLASS_SLIDE = CLASS_PREFIX + "slide";
	var CLASS_CLONE = CLASS_SLIDE + "--clone";
	var CLASS_CONTAINER = CLASS_SLIDE + "__container";
	var CLASS_ARROWS = CLASS_PREFIX + "arrows";
	var CLASS_ARROW = CLASS_PREFIX + "arrow";
	var CLASS_ARROW_PREV = CLASS_ARROW + "--prev";
	var CLASS_ARROW_NEXT = CLASS_ARROW + "--next";
	var CLASS_PAGINATION = CLASS_PREFIX + "pagination";
	var CLASS_PAGINATION_PAGE = CLASS_PAGINATION + "__page";
	var CLASS_PROGRESS = CLASS_PREFIX + "progress";
	var CLASS_PROGRESS_BAR = CLASS_PROGRESS + "__bar";
	var CLASS_TOGGLE = CLASS_PREFIX + "toggle";
	var CLASS_SPINNER = CLASS_PREFIX + "spinner";
	var CLASS_SR = CLASS_PREFIX + "sr";
	var CLASS_INITIALIZED = STATUS_CLASS_PREFIX + "initialized";
	var CLASS_ACTIVE = STATUS_CLASS_PREFIX + "active";
	var CLASS_PREV = STATUS_CLASS_PREFIX + "prev";
	var CLASS_NEXT = STATUS_CLASS_PREFIX + "next";
	var CLASS_VISIBLE = STATUS_CLASS_PREFIX + "visible";
	var CLASS_LOADING = STATUS_CLASS_PREFIX + "loading";
	var CLASS_FOCUS_IN = STATUS_CLASS_PREFIX + "focus-in";
	var CLASS_OVERFLOW = STATUS_CLASS_PREFIX + "overflow";
	var STATUS_CLASSES = [CLASS_ACTIVE, CLASS_VISIBLE, CLASS_PREV, CLASS_NEXT, CLASS_LOADING, CLASS_FOCUS_IN, CLASS_OVERFLOW];
	var CLASSES = {
	  slide: CLASS_SLIDE,
	  clone: CLASS_CLONE,
	  arrows: CLASS_ARROWS,
	  arrow: CLASS_ARROW,
	  prev: CLASS_ARROW_PREV,
	  next: CLASS_ARROW_NEXT,
	  pagination: CLASS_PAGINATION,
	  page: CLASS_PAGINATION_PAGE,
	  spinner: CLASS_SPINNER
	};

	function closest(from, selector) {
	  if (isFunction(from.closest)) {
	    return from.closest(selector);
	  }

	  var elm = from;

	  while (elm && elm.nodeType === 1) {
	    if (matches(elm, selector)) {
	      break;
	    }

	    elm = elm.parentElement;
	  }

	  return elm;
	}

	var FRICTION = 5;
	var LOG_INTERVAL = 200;
	var POINTER_DOWN_EVENTS = "touchstart mousedown";
	var POINTER_MOVE_EVENTS = "touchmove mousemove";
	var POINTER_UP_EVENTS = "touchend touchcancel mouseup click";

	function Elements(Splide2, Components2, options) {
	  var _EventInterface = EventInterface(Splide2),
	      on = _EventInterface.on,
	      bind = _EventInterface.bind;

	  var root = Splide2.root;
	  var i18n = options.i18n;
	  var elements = {};
	  var slides = [];
	  var rootClasses = [];
	  var trackClasses = [];
	  var track;
	  var list;
	  var isUsingKey;

	  function setup() {
	    collect();
	    init();
	    update();
	  }

	  function mount() {
	    on(EVENT_REFRESH, destroy);
	    on(EVENT_REFRESH, setup);
	    on(EVENT_UPDATED, update);
	    bind(document, POINTER_DOWN_EVENTS + " keydown", function (e) {
	      isUsingKey = e.type === "keydown";
	    }, {
	      capture: true
	    });
	    bind(root, "focusin", function () {
	      toggleClass(root, CLASS_FOCUS_IN, !!isUsingKey);
	    });
	  }

	  function destroy(completely) {
	    var attrs = ALL_ATTRIBUTES.concat("style");
	    empty(slides);
	    removeClass(root, rootClasses);
	    removeClass(track, trackClasses);
	    removeAttribute([track, list], attrs);
	    removeAttribute(root, completely ? attrs : ["style", ARIA_ROLEDESCRIPTION]);
	  }

	  function update() {
	    removeClass(root, rootClasses);
	    removeClass(track, trackClasses);
	    rootClasses = getClasses(CLASS_ROOT);
	    trackClasses = getClasses(CLASS_TRACK);
	    addClass(root, rootClasses);
	    addClass(track, trackClasses);
	    setAttribute(root, ARIA_LABEL, options.label);
	    setAttribute(root, ARIA_LABELLEDBY, options.labelledby);
	  }

	  function collect() {
	    track = find("." + CLASS_TRACK);
	    list = child(track, "." + CLASS_LIST);
	    assert(track && list, "A track/list element is missing.");
	    push(slides, children(list, "." + CLASS_SLIDE + ":not(." + CLASS_CLONE + ")"));
	    forOwn({
	      arrows: CLASS_ARROWS,
	      pagination: CLASS_PAGINATION,
	      prev: CLASS_ARROW_PREV,
	      next: CLASS_ARROW_NEXT,
	      bar: CLASS_PROGRESS_BAR,
	      toggle: CLASS_TOGGLE
	    }, function (className, key) {
	      elements[key] = find("." + className);
	    });
	    assign(elements, {
	      root: root,
	      track: track,
	      list: list,
	      slides: slides
	    });
	  }

	  function init() {
	    var id = root.id || uniqueId(PROJECT_CODE);
	    var role = options.role;
	    root.id = id;
	    track.id = track.id || id + "-track";
	    list.id = list.id || id + "-list";

	    if (!getAttribute(root, ROLE) && root.tagName !== "SECTION" && role) {
	      setAttribute(root, ROLE, role);
	    }

	    setAttribute(root, ARIA_ROLEDESCRIPTION, i18n.carousel);
	    setAttribute(list, ROLE, "presentation");
	  }

	  function find(selector) {
	    var elm = query(root, selector);
	    return elm && closest(elm, "." + CLASS_ROOT) === root ? elm : void 0;
	  }

	  function getClasses(base) {
	    return [base + "--" + options.type, base + "--" + options.direction, options.drag && base + "--draggable", options.isNavigation && base + "--nav", base === CLASS_ROOT && CLASS_ACTIVE];
	  }

	  return assign(elements, {
	    setup: setup,
	    mount: mount,
	    destroy: destroy
	  });
	}

	var SLIDE = "slide";
	var LOOP = "loop";
	var FADE = "fade";

	function Slide$1(Splide2, index, slideIndex, slide) {
	  var event = EventInterface(Splide2);
	  var on = event.on,
	      emit = event.emit,
	      bind = event.bind;
	  var Components = Splide2.Components,
	      root = Splide2.root,
	      options = Splide2.options;
	  var isNavigation = options.isNavigation,
	      updateOnMove = options.updateOnMove,
	      i18n = options.i18n,
	      pagination = options.pagination,
	      slideFocus = options.slideFocus;
	  var resolve = Components.Direction.resolve;
	  var styles = getAttribute(slide, "style");
	  var label = getAttribute(slide, ARIA_LABEL);
	  var isClone = slideIndex > -1;
	  var container = child(slide, "." + CLASS_CONTAINER);
	  var destroyed;

	  function mount() {
	    if (!isClone) {
	      slide.id = root.id + "-slide" + pad(index + 1);
	      setAttribute(slide, ROLE, pagination ? "tabpanel" : "group");
	      setAttribute(slide, ARIA_ROLEDESCRIPTION, i18n.slide);
	      setAttribute(slide, ARIA_LABEL, label || format(i18n.slideLabel, [index + 1, Splide2.length]));
	    }

	    listen();
	  }

	  function listen() {
	    bind(slide, "click", apply(emit, EVENT_CLICK, self));
	    bind(slide, "keydown", apply(emit, EVENT_SLIDE_KEYDOWN, self));
	    on([EVENT_MOVED, EVENT_SHIFTED, EVENT_SCROLLED], update);
	    on(EVENT_NAVIGATION_MOUNTED, initNavigation);

	    if (updateOnMove) {
	      on(EVENT_MOVE, onMove);
	    }
	  }

	  function destroy() {
	    destroyed = true;
	    event.destroy();
	    removeClass(slide, STATUS_CLASSES);
	    removeAttribute(slide, ALL_ATTRIBUTES);
	    setAttribute(slide, "style", styles);
	    setAttribute(slide, ARIA_LABEL, label || "");
	  }

	  function initNavigation() {
	    var controls = Splide2.splides.map(function (target) {
	      var Slide2 = target.splide.Components.Slides.getAt(index);
	      return Slide2 ? Slide2.slide.id : "";
	    }).join(" ");
	    setAttribute(slide, ARIA_LABEL, format(i18n.slideX, (isClone ? slideIndex : index) + 1));
	    setAttribute(slide, ARIA_CONTROLS, controls);
	    setAttribute(slide, ROLE, slideFocus ? "button" : "");
	    slideFocus && removeAttribute(slide, ARIA_ROLEDESCRIPTION);
	  }

	  function onMove() {
	    if (!destroyed) {
	      update();
	    }
	  }

	  function update() {
	    if (!destroyed) {
	      var curr = Splide2.index;
	      updateActivity();
	      updateVisibility();
	      toggleClass(slide, CLASS_PREV, index === curr - 1);
	      toggleClass(slide, CLASS_NEXT, index === curr + 1);
	    }
	  }

	  function updateActivity() {
	    var active = isActive();

	    if (active !== hasClass(slide, CLASS_ACTIVE)) {
	      toggleClass(slide, CLASS_ACTIVE, active);
	      setAttribute(slide, ARIA_CURRENT, isNavigation && active || "");
	      emit(active ? EVENT_ACTIVE : EVENT_INACTIVE, self);
	    }
	  }

	  function updateVisibility() {
	    var visible = isVisible();
	    var hidden = !visible && (!isActive() || isClone);

	    if (!Splide2.state.is([MOVING, SCROLLING])) {
	      setAttribute(slide, ARIA_HIDDEN, hidden || "");
	    }

	    setAttribute(queryAll(slide, options.focusableNodes || ""), TAB_INDEX, hidden ? -1 : "");

	    if (slideFocus) {
	      setAttribute(slide, TAB_INDEX, hidden ? -1 : 0);
	    }

	    if (visible !== hasClass(slide, CLASS_VISIBLE)) {
	      toggleClass(slide, CLASS_VISIBLE, visible);
	      emit(visible ? EVENT_VISIBLE : EVENT_HIDDEN, self);
	    }

	    if (!visible && document.activeElement === slide) {
	      var Slide2 = Components.Slides.getAt(Splide2.index);
	      Slide2 && focus(Slide2.slide);
	    }
	  }

	  function style$1(prop, value, useContainer) {
	    style(useContainer && container || slide, prop, value);
	  }

	  function isActive() {
	    var curr = Splide2.index;
	    return curr === index || options.cloneStatus && curr === slideIndex;
	  }

	  function isVisible() {
	    if (Splide2.is(FADE)) {
	      return isActive();
	    }

	    var trackRect = rect(Components.Elements.track);
	    var slideRect = rect(slide);
	    var left = resolve("left", true);
	    var right = resolve("right", true);
	    return floor(trackRect[left]) <= ceil(slideRect[left]) && floor(slideRect[right]) <= ceil(trackRect[right]);
	  }

	  function isWithin(from, distance) {
	    var diff = abs(from - index);

	    if (!isClone && (options.rewind || Splide2.is(LOOP))) {
	      diff = min(diff, Splide2.length - diff);
	    }

	    return diff <= distance;
	  }

	  var self = {
	    index: index,
	    slideIndex: slideIndex,
	    slide: slide,
	    container: container,
	    isClone: isClone,
	    mount: mount,
	    destroy: destroy,
	    update: update,
	    style: style$1,
	    isWithin: isWithin
	  };
	  return self;
	}

	function Slides(Splide2, Components2, options) {
	  var _EventInterface2 = EventInterface(Splide2),
	      on = _EventInterface2.on,
	      emit = _EventInterface2.emit,
	      bind = _EventInterface2.bind;

	  var _Components2$Elements = Components2.Elements,
	      slides = _Components2$Elements.slides,
	      list = _Components2$Elements.list;
	  var Slides2 = [];

	  function mount() {
	    init();
	    on(EVENT_REFRESH, destroy);
	    on(EVENT_REFRESH, init);
	  }

	  function init() {
	    slides.forEach(function (slide, index) {
	      register(slide, index, -1);
	    });
	  }

	  function destroy() {
	    forEach$1(function (Slide2) {
	      Slide2.destroy();
	    });
	    empty(Slides2);
	  }

	  function update() {
	    forEach$1(function (Slide2) {
	      Slide2.update();
	    });
	  }

	  function register(slide, index, slideIndex) {
	    var object = Slide$1(Splide2, index, slideIndex, slide);
	    object.mount();
	    Slides2.push(object);
	    Slides2.sort(function (Slide1, Slide2) {
	      return Slide1.index - Slide2.index;
	    });
	  }

	  function get(excludeClones) {
	    return excludeClones ? filter(function (Slide2) {
	      return !Slide2.isClone;
	    }) : Slides2;
	  }

	  function getIn(page) {
	    var Controller = Components2.Controller;
	    var index = Controller.toIndex(page);
	    var max = Controller.hasFocus() ? 1 : options.perPage;
	    return filter(function (Slide2) {
	      return between(Slide2.index, index, index + max - 1);
	    });
	  }

	  function getAt(index) {
	    return filter(index)[0];
	  }

	  function add(items, index) {
	    forEach(items, function (slide) {
	      if (isString(slide)) {
	        slide = parseHtml(slide);
	      }

	      if (isHTMLElement(slide)) {
	        var ref = slides[index];
	        ref ? before(slide, ref) : append(list, slide);
	        addClass(slide, options.classes.slide);
	        observeImages(slide, apply(emit, EVENT_RESIZE));
	      }
	    });
	    emit(EVENT_REFRESH);
	  }

	  function remove$1(matcher) {
	    remove(filter(matcher).map(function (Slide2) {
	      return Slide2.slide;
	    }));
	    emit(EVENT_REFRESH);
	  }

	  function forEach$1(iteratee, excludeClones) {
	    get(excludeClones).forEach(iteratee);
	  }

	  function filter(matcher) {
	    return Slides2.filter(isFunction(matcher) ? matcher : function (Slide2) {
	      return isString(matcher) ? matches(Slide2.slide, matcher) : includes(toArray(matcher), Slide2.index);
	    });
	  }

	  function style(prop, value, useContainer) {
	    forEach$1(function (Slide2) {
	      Slide2.style(prop, value, useContainer);
	    });
	  }

	  function observeImages(elm, callback) {
	    var images = queryAll(elm, "img");
	    var length = images.length;

	    if (length) {
	      images.forEach(function (img) {
	        bind(img, "load error", function () {
	          if (! --length) {
	            callback();
	          }
	        });
	      });
	    } else {
	      callback();
	    }
	  }

	  function getLength(excludeClones) {
	    return excludeClones ? slides.length : Slides2.length;
	  }

	  function isEnough() {
	    return Slides2.length > options.perPage;
	  }

	  return {
	    mount: mount,
	    destroy: destroy,
	    update: update,
	    register: register,
	    get: get,
	    getIn: getIn,
	    getAt: getAt,
	    add: add,
	    remove: remove$1,
	    forEach: forEach$1,
	    filter: filter,
	    style: style,
	    getLength: getLength,
	    isEnough: isEnough
	  };
	}

	function Layout(Splide2, Components2, options) {
	  var _EventInterface3 = EventInterface(Splide2),
	      on = _EventInterface3.on,
	      bind = _EventInterface3.bind,
	      emit = _EventInterface3.emit;

	  var Slides = Components2.Slides;
	  var resolve = Components2.Direction.resolve;
	  var _Components2$Elements2 = Components2.Elements,
	      root = _Components2$Elements2.root,
	      track = _Components2$Elements2.track,
	      list = _Components2$Elements2.list;
	  var getAt = Slides.getAt,
	      styleSlides = Slides.style;
	  var vertical;
	  var rootRect;
	  var overflow;

	  function mount() {
	    init();
	    bind(window, "resize load", Throttle(apply(emit, EVENT_RESIZE)));
	    on([EVENT_UPDATED, EVENT_REFRESH], init);
	    on(EVENT_RESIZE, resize);
	  }

	  function init() {
	    vertical = options.direction === TTB;
	    style(root, "maxWidth", unit(options.width));
	    style(track, resolve("paddingLeft"), cssPadding(false));
	    style(track, resolve("paddingRight"), cssPadding(true));
	    resize(true);
	  }

	  function resize(force) {
	    var newRect = rect(root);

	    if (force || rootRect.width !== newRect.width || rootRect.height !== newRect.height) {
	      style(track, "height", cssTrackHeight());
	      styleSlides(resolve("marginRight"), unit(options.gap));
	      styleSlides("width", cssSlideWidth());
	      styleSlides("height", cssSlideHeight(), true);
	      rootRect = newRect;
	      emit(EVENT_RESIZED);

	      if (overflow !== (overflow = isOverflow())) {
	        toggleClass(root, CLASS_OVERFLOW, overflow);
	        emit(EVENT_OVERFLOW, overflow);
	      }
	    }
	  }

	  function cssPadding(right) {
	    var padding = options.padding;
	    var prop = resolve(right ? "right" : "left");
	    return padding && unit(padding[prop] || (isObject(padding) ? 0 : padding)) || "0px";
	  }

	  function cssTrackHeight() {
	    var height = "";

	    if (vertical) {
	      height = cssHeight();
	      assert(height, "height or heightRatio is missing.");
	      height = "calc(" + height + " - " + cssPadding(false) + " - " + cssPadding(true) + ")";
	    }

	    return height;
	  }

	  function cssHeight() {
	    return unit(options.height || rect(list).width * options.heightRatio);
	  }

	  function cssSlideWidth() {
	    return options.autoWidth ? null : unit(options.fixedWidth) || (vertical ? "" : cssSlideSize());
	  }

	  function cssSlideHeight() {
	    return unit(options.fixedHeight) || (vertical ? options.autoHeight ? null : cssSlideSize() : cssHeight());
	  }

	  function cssSlideSize() {
	    var gap = unit(options.gap);
	    return "calc((100%" + (gap && " + " + gap) + ")/" + (options.perPage || 1) + (gap && " - " + gap) + ")";
	  }

	  function listSize() {
	    return rect(list)[resolve("width")];
	  }

	  function slideSize(index, withoutGap) {
	    var Slide = getAt(index || 0);
	    return Slide ? rect(Slide.slide)[resolve("width")] + (withoutGap ? 0 : getGap()) : 0;
	  }

	  function totalSize(index, withoutGap) {
	    var Slide = getAt(index);

	    if (Slide) {
	      var right = rect(Slide.slide)[resolve("right")];
	      var left = rect(list)[resolve("left")];
	      return abs(right - left) + (withoutGap ? 0 : getGap());
	    }

	    return 0;
	  }

	  function sliderSize(withoutGap) {
	    return totalSize(Splide2.length - 1) - totalSize(0) + slideSize(0, withoutGap);
	  }

	  function getGap() {
	    var Slide = getAt(0);
	    return Slide && parseFloat(style(Slide.slide, resolve("marginRight"))) || 0;
	  }

	  function getPadding(right) {
	    return parseFloat(style(track, resolve("padding" + (right ? "Right" : "Left")))) || 0;
	  }

	  function isOverflow() {
	    return Splide2.is(FADE) || sliderSize(true) > listSize();
	  }

	  return {
	    mount: mount,
	    resize: resize,
	    listSize: listSize,
	    slideSize: slideSize,
	    sliderSize: sliderSize,
	    totalSize: totalSize,
	    getPadding: getPadding,
	    isOverflow: isOverflow
	  };
	}

	var MULTIPLIER = 2;

	function Clones(Splide2, Components2, options) {
	  var event = EventInterface(Splide2);
	  var on = event.on;
	  var Elements = Components2.Elements,
	      Slides = Components2.Slides;
	  var resolve = Components2.Direction.resolve;
	  var clones = [];
	  var cloneCount;

	  function mount() {
	    on(EVENT_REFRESH, remount);
	    on([EVENT_UPDATED, EVENT_RESIZE], observe);

	    if (cloneCount = computeCloneCount()) {
	      generate(cloneCount);
	      Components2.Layout.resize(true);
	    }
	  }

	  function remount() {
	    destroy();
	    mount();
	  }

	  function destroy() {
	    remove(clones);
	    empty(clones);
	    event.destroy();
	  }

	  function observe() {
	    var count = computeCloneCount();

	    if (cloneCount !== count) {
	      if (cloneCount < count || !count) {
	        event.emit(EVENT_REFRESH);
	      }
	    }
	  }

	  function generate(count) {
	    var slides = Slides.get().slice();
	    var length = slides.length;

	    if (length) {
	      while (slides.length < count) {
	        push(slides, slides);
	      }

	      push(slides.slice(-count), slides.slice(0, count)).forEach(function (Slide, index) {
	        var isHead = index < count;
	        var clone = cloneDeep(Slide.slide, index);
	        isHead ? before(clone, slides[0].slide) : append(Elements.list, clone);
	        push(clones, clone);
	        Slides.register(clone, index - count + (isHead ? 0 : length), Slide.index);
	      });
	    }
	  }

	  function cloneDeep(elm, index) {
	    var clone = elm.cloneNode(true);
	    addClass(clone, options.classes.clone);
	    clone.id = Splide2.root.id + "-clone" + pad(index + 1);
	    return clone;
	  }

	  function computeCloneCount() {
	    var clones2 = options.clones;

	    if (!Splide2.is(LOOP)) {
	      clones2 = 0;
	    } else if (isUndefined(clones2)) {
	      var fixedSize = options[resolve("fixedWidth")] && Components2.Layout.slideSize(0);
	      var fixedCount = fixedSize && ceil(rect(Elements.track)[resolve("width")] / fixedSize);
	      clones2 = fixedCount || options[resolve("autoWidth")] && Splide2.length || options.perPage * MULTIPLIER;
	    }

	    return clones2;
	  }

	  return {
	    mount: mount,
	    destroy: destroy
	  };
	}

	function Move(Splide2, Components2, options) {
	  var _EventInterface4 = EventInterface(Splide2),
	      on = _EventInterface4.on,
	      emit = _EventInterface4.emit;

	  var set = Splide2.state.set;
	  var _Components2$Layout = Components2.Layout,
	      slideSize = _Components2$Layout.slideSize,
	      getPadding = _Components2$Layout.getPadding,
	      totalSize = _Components2$Layout.totalSize,
	      listSize = _Components2$Layout.listSize,
	      sliderSize = _Components2$Layout.sliderSize;
	  var _Components2$Directio = Components2.Direction,
	      resolve = _Components2$Directio.resolve,
	      orient = _Components2$Directio.orient;
	  var _Components2$Elements3 = Components2.Elements,
	      list = _Components2$Elements3.list,
	      track = _Components2$Elements3.track;
	  var Transition;

	  function mount() {
	    Transition = Components2.Transition;
	    on([EVENT_MOUNTED, EVENT_RESIZED, EVENT_UPDATED, EVENT_REFRESH], reposition);
	  }

	  function reposition() {
	    if (!Components2.Controller.isBusy()) {
	      Components2.Scroll.cancel();
	      jump(Splide2.index);
	      Components2.Slides.update();
	    }
	  }

	  function move(dest, index, prev, callback) {
	    if (dest !== index && canShift(dest > prev)) {
	      cancel();
	      translate(shift(getPosition(), dest > prev), true);
	    }

	    set(MOVING);
	    emit(EVENT_MOVE, index, prev, dest);
	    Transition.start(index, function () {
	      set(IDLE);
	      emit(EVENT_MOVED, index, prev, dest);
	      callback && callback();
	    });
	  }

	  function jump(index) {
	    translate(toPosition(index, true));
	  }

	  function translate(position, preventLoop) {
	    if (!Splide2.is(FADE)) {
	      var destination = preventLoop ? position : loop(position);
	      style(list, "transform", "translate" + resolve("X") + "(" + destination + "px)");
	      position !== destination && emit(EVENT_SHIFTED);
	    }
	  }

	  function loop(position) {
	    if (Splide2.is(LOOP)) {
	      var index = toIndex(position);
	      var exceededMax = index > Components2.Controller.getEnd();
	      var exceededMin = index < 0;

	      if (exceededMin || exceededMax) {
	        position = shift(position, exceededMax);
	      }
	    }

	    return position;
	  }

	  function shift(position, backwards) {
	    var excess = position - getLimit(backwards);
	    var size = sliderSize();
	    position -= orient(size * (ceil(abs(excess) / size) || 1)) * (backwards ? 1 : -1);
	    return position;
	  }

	  function cancel() {
	    translate(getPosition(), true);
	    Transition.cancel();
	  }

	  function toIndex(position) {
	    var Slides = Components2.Slides.get();
	    var index = 0;
	    var minDistance = Infinity;

	    for (var i = 0; i < Slides.length; i++) {
	      var slideIndex = Slides[i].index;
	      var distance = abs(toPosition(slideIndex, true) - position);

	      if (distance <= minDistance) {
	        minDistance = distance;
	        index = slideIndex;
	      } else {
	        break;
	      }
	    }

	    return index;
	  }

	  function toPosition(index, trimming) {
	    var position = orient(totalSize(index - 1) - offset(index));
	    return trimming ? trim(position) : position;
	  }

	  function getPosition() {
	    var left = resolve("left");
	    return rect(list)[left] - rect(track)[left] + orient(getPadding(false));
	  }

	  function trim(position) {
	    if (options.trimSpace && Splide2.is(SLIDE)) {
	      position = clamp(position, 0, orient(sliderSize(true) - listSize()));
	    }

	    return position;
	  }

	  function offset(index) {
	    var focus = options.focus;
	    return focus === "center" ? (listSize() - slideSize(index, true)) / 2 : +focus * slideSize(index) || 0;
	  }

	  function getLimit(max) {
	    return toPosition(max ? Components2.Controller.getEnd() : 0, !!options.trimSpace);
	  }

	  function canShift(backwards) {
	    var shifted = orient(shift(getPosition(), backwards));
	    return backwards ? shifted >= 0 : shifted <= list[resolve("scrollWidth")] - rect(track)[resolve("width")];
	  }

	  function exceededLimit(max, position) {
	    position = isUndefined(position) ? getPosition() : position;
	    var exceededMin = max !== true && orient(position) < orient(getLimit(false));
	    var exceededMax = max !== false && orient(position) > orient(getLimit(true));
	    return exceededMin || exceededMax;
	  }

	  return {
	    mount: mount,
	    move: move,
	    jump: jump,
	    translate: translate,
	    shift: shift,
	    cancel: cancel,
	    toIndex: toIndex,
	    toPosition: toPosition,
	    getPosition: getPosition,
	    getLimit: getLimit,
	    exceededLimit: exceededLimit,
	    reposition: reposition
	  };
	}

	function Controller(Splide2, Components2, options) {
	  var _EventInterface5 = EventInterface(Splide2),
	      on = _EventInterface5.on,
	      emit = _EventInterface5.emit;

	  var Move = Components2.Move;
	  var getPosition = Move.getPosition,
	      getLimit = Move.getLimit,
	      toPosition = Move.toPosition;
	  var _Components2$Slides = Components2.Slides,
	      isEnough = _Components2$Slides.isEnough,
	      getLength = _Components2$Slides.getLength;
	  var omitEnd = options.omitEnd;
	  var isLoop = Splide2.is(LOOP);
	  var isSlide = Splide2.is(SLIDE);
	  var getNext = apply(getAdjacent, false);
	  var getPrev = apply(getAdjacent, true);
	  var currIndex = options.start || 0;
	  var endIndex;
	  var prevIndex = currIndex;
	  var slideCount;
	  var perMove;
	  var perPage;

	  function mount() {
	    init();
	    on([EVENT_UPDATED, EVENT_REFRESH, EVENT_END_INDEX_CHANGED], init);
	    on(EVENT_RESIZED, onResized);
	  }

	  function init() {
	    slideCount = getLength(true);
	    perMove = options.perMove;
	    perPage = options.perPage;
	    endIndex = getEnd();
	    var index = clamp(currIndex, 0, omitEnd ? endIndex : slideCount - 1);

	    if (index !== currIndex) {
	      currIndex = index;
	      Move.reposition();
	    }
	  }

	  function onResized() {
	    if (endIndex !== getEnd()) {
	      emit(EVENT_END_INDEX_CHANGED);
	    }
	  }

	  function go(control, allowSameIndex, callback) {
	    if (!isBusy()) {
	      var dest = parse(control);
	      var index = loop(dest);

	      if (index > -1 && (allowSameIndex || index !== currIndex)) {
	        setIndex(index);
	        Move.move(dest, index, prevIndex, callback);
	      }
	    }
	  }

	  function scroll(destination, duration, snap, callback) {
	    Components2.Scroll.scroll(destination, duration, snap, function () {
	      var index = loop(Move.toIndex(getPosition()));
	      setIndex(omitEnd ? min(index, endIndex) : index);
	      callback && callback();
	    });
	  }

	  function parse(control) {
	    var index = currIndex;

	    if (isString(control)) {
	      var _ref = control.match(/([+\-<>])(\d+)?/) || [],
	          indicator = _ref[1],
	          number = _ref[2];

	      if (indicator === "+" || indicator === "-") {
	        index = computeDestIndex(currIndex + +("" + indicator + (+number || 1)), currIndex);
	      } else if (indicator === ">") {
	        index = number ? toIndex(+number) : getNext(true);
	      } else if (indicator === "<") {
	        index = getPrev(true);
	      }
	    } else {
	      index = isLoop ? control : clamp(control, 0, endIndex);
	    }

	    return index;
	  }

	  function getAdjacent(prev, destination) {
	    var number = perMove || (hasFocus() ? 1 : perPage);
	    var dest = computeDestIndex(currIndex + number * (prev ? -1 : 1), currIndex, !(perMove || hasFocus()));

	    if (dest === -1 && isSlide) {
	      if (!approximatelyEqual(getPosition(), getLimit(!prev), 1)) {
	        return prev ? 0 : endIndex;
	      }
	    }

	    return destination ? dest : loop(dest);
	  }

	  function computeDestIndex(dest, from, snapPage) {
	    if (isEnough() || hasFocus()) {
	      var index = computeMovableDestIndex(dest);

	      if (index !== dest) {
	        from = dest;
	        dest = index;
	        snapPage = false;
	      }

	      if (dest < 0 || dest > endIndex) {
	        if (!perMove && (between(0, dest, from, true) || between(endIndex, from, dest, true))) {
	          dest = toIndex(toPage(dest));
	        } else {
	          if (isLoop) {
	            dest = snapPage ? dest < 0 ? -(slideCount % perPage || perPage) : slideCount : dest;
	          } else if (options.rewind) {
	            dest = dest < 0 ? endIndex : 0;
	          } else {
	            dest = -1;
	          }
	        }
	      } else {
	        if (snapPage && dest !== from) {
	          dest = toIndex(toPage(from) + (dest < from ? -1 : 1));
	        }
	      }
	    } else {
	      dest = -1;
	    }

	    return dest;
	  }

	  function computeMovableDestIndex(dest) {
	    if (isSlide && options.trimSpace === "move" && dest !== currIndex) {
	      var position = getPosition();

	      while (position === toPosition(dest, true) && between(dest, 0, Splide2.length - 1, !options.rewind)) {
	        dest < currIndex ? --dest : ++dest;
	      }
	    }

	    return dest;
	  }

	  function loop(index) {
	    return isLoop ? (index + slideCount) % slideCount || 0 : index;
	  }

	  function getEnd() {
	    var end = slideCount - (hasFocus() || isLoop && perMove ? 1 : perPage);

	    while (omitEnd && end-- > 0) {
	      if (toPosition(slideCount - 1, true) !== toPosition(end, true)) {
	        end++;
	        break;
	      }
	    }

	    return clamp(end, 0, slideCount - 1);
	  }

	  function toIndex(page) {
	    return clamp(hasFocus() ? page : perPage * page, 0, endIndex);
	  }

	  function toPage(index) {
	    return hasFocus() ? min(index, endIndex) : floor((index >= endIndex ? slideCount - 1 : index) / perPage);
	  }

	  function toDest(destination) {
	    var closest = Move.toIndex(destination);
	    return isSlide ? clamp(closest, 0, endIndex) : closest;
	  }

	  function setIndex(index) {
	    if (index !== currIndex) {
	      prevIndex = currIndex;
	      currIndex = index;
	    }
	  }

	  function getIndex(prev) {
	    return prev ? prevIndex : currIndex;
	  }

	  function hasFocus() {
	    return !isUndefined(options.focus) || options.isNavigation;
	  }

	  function isBusy() {
	    return Splide2.state.is([MOVING, SCROLLING]) && !!options.waitForTransition;
	  }

	  return {
	    mount: mount,
	    go: go,
	    scroll: scroll,
	    getNext: getNext,
	    getPrev: getPrev,
	    getAdjacent: getAdjacent,
	    getEnd: getEnd,
	    setIndex: setIndex,
	    getIndex: getIndex,
	    toIndex: toIndex,
	    toPage: toPage,
	    toDest: toDest,
	    hasFocus: hasFocus,
	    isBusy: isBusy
	  };
	}

	var XML_NAME_SPACE = "http://www.w3.org/2000/svg";
	var PATH = "m15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z";
	var SIZE = 40;

	function Arrows(Splide2, Components2, options) {
	  var event = EventInterface(Splide2);
	  var on = event.on,
	      bind = event.bind,
	      emit = event.emit;
	  var classes = options.classes,
	      i18n = options.i18n;
	  var Elements = Components2.Elements,
	      Controller = Components2.Controller;
	  var placeholder = Elements.arrows,
	      track = Elements.track;
	  var wrapper = placeholder;
	  var prev = Elements.prev;
	  var next = Elements.next;
	  var created;
	  var wrapperClasses;
	  var arrows = {};

	  function mount() {
	    init();
	    on(EVENT_UPDATED, remount);
	  }

	  function remount() {
	    destroy();
	    mount();
	  }

	  function init() {
	    var enabled = options.arrows;

	    if (enabled && !(prev && next)) {
	      createArrows();
	    }

	    if (prev && next) {
	      assign(arrows, {
	        prev: prev,
	        next: next
	      });
	      display(wrapper, enabled ? "" : "none");
	      addClass(wrapper, wrapperClasses = CLASS_ARROWS + "--" + options.direction);

	      if (enabled) {
	        listen();
	        update();
	        setAttribute([prev, next], ARIA_CONTROLS, track.id);
	        emit(EVENT_ARROWS_MOUNTED, prev, next);
	      }
	    }
	  }

	  function destroy() {
	    event.destroy();
	    removeClass(wrapper, wrapperClasses);

	    if (created) {
	      remove(placeholder ? [prev, next] : wrapper);
	      prev = next = null;
	    } else {
	      removeAttribute([prev, next], ALL_ATTRIBUTES);
	    }
	  }

	  function listen() {
	    on([EVENT_MOUNTED, EVENT_MOVED, EVENT_REFRESH, EVENT_SCROLLED, EVENT_END_INDEX_CHANGED], update);
	    bind(next, "click", apply(go, ">"));
	    bind(prev, "click", apply(go, "<"));
	  }

	  function go(control) {
	    Controller.go(control, true);
	  }

	  function createArrows() {
	    wrapper = placeholder || create("div", classes.arrows);
	    prev = createArrow(true);
	    next = createArrow(false);
	    created = true;
	    append(wrapper, [prev, next]);
	    !placeholder && before(wrapper, track);
	  }

	  function createArrow(prev2) {
	    var arrow = "<button class=\"" + classes.arrow + " " + (prev2 ? classes.prev : classes.next) + "\" type=\"button\"><svg xmlns=\"" + XML_NAME_SPACE + "\" viewBox=\"0 0 " + SIZE + " " + SIZE + "\" width=\"" + SIZE + "\" height=\"" + SIZE + "\" focusable=\"false\"><path d=\"" + (options.arrowPath || PATH) + "\" />";
	    return parseHtml(arrow);
	  }

	  function update() {
	    if (prev && next) {
	      var index = Splide2.index;
	      var prevIndex = Controller.getPrev();
	      var nextIndex = Controller.getNext();
	      var prevLabel = prevIndex > -1 && index < prevIndex ? i18n.last : i18n.prev;
	      var nextLabel = nextIndex > -1 && index > nextIndex ? i18n.first : i18n.next;
	      prev.disabled = prevIndex < 0;
	      next.disabled = nextIndex < 0;
	      setAttribute(prev, ARIA_LABEL, prevLabel);
	      setAttribute(next, ARIA_LABEL, nextLabel);
	      emit(EVENT_ARROWS_UPDATED, prev, next, prevIndex, nextIndex);
	    }
	  }

	  return {
	    arrows: arrows,
	    mount: mount,
	    destroy: destroy,
	    update: update
	  };
	}

	var INTERVAL_DATA_ATTRIBUTE = DATA_ATTRIBUTE + "-interval";

	function Autoplay(Splide2, Components2, options) {
	  var _EventInterface6 = EventInterface(Splide2),
	      on = _EventInterface6.on,
	      bind = _EventInterface6.bind,
	      emit = _EventInterface6.emit;

	  var interval = RequestInterval(options.interval, Splide2.go.bind(Splide2, ">"), onAnimationFrame);
	  var isPaused = interval.isPaused;
	  var Elements = Components2.Elements,
	      _Components2$Elements4 = Components2.Elements,
	      root = _Components2$Elements4.root,
	      toggle = _Components2$Elements4.toggle;
	  var autoplay = options.autoplay;
	  var hovered;
	  var focused;
	  var stopped = autoplay === "pause";

	  function mount() {
	    if (autoplay) {
	      listen();
	      toggle && setAttribute(toggle, ARIA_CONTROLS, Elements.track.id);
	      stopped || play();
	      update();
	    }
	  }

	  function listen() {
	    if (options.pauseOnHover) {
	      bind(root, "mouseenter mouseleave", function (e) {
	        hovered = e.type === "mouseenter";
	        autoToggle();
	      });
	    }

	    if (options.pauseOnFocus) {
	      bind(root, "focusin focusout", function (e) {
	        focused = e.type === "focusin";
	        autoToggle();
	      });
	    }

	    if (toggle) {
	      bind(toggle, "click", function () {
	        stopped ? play() : pause(true);
	      });
	    }

	    on([EVENT_MOVE, EVENT_SCROLL, EVENT_REFRESH], interval.rewind);
	    on(EVENT_MOVE, onMove);
	  }

	  function play() {
	    if (isPaused() && Components2.Slides.isEnough()) {
	      interval.start(!options.resetProgress);
	      focused = hovered = stopped = false;
	      update();
	      emit(EVENT_AUTOPLAY_PLAY);
	    }
	  }

	  function pause(stop) {
	    if (stop === void 0) {
	      stop = true;
	    }

	    stopped = !!stop;
	    update();

	    if (!isPaused()) {
	      interval.pause();
	      emit(EVENT_AUTOPLAY_PAUSE);
	    }
	  }

	  function autoToggle() {
	    if (!stopped) {
	      hovered || focused ? pause(false) : play();
	    }
	  }

	  function update() {
	    if (toggle) {
	      toggleClass(toggle, CLASS_ACTIVE, !stopped);
	      setAttribute(toggle, ARIA_LABEL, options.i18n[stopped ? "play" : "pause"]);
	    }
	  }

	  function onAnimationFrame(rate) {
	    var bar = Elements.bar;
	    bar && style(bar, "width", rate * 100 + "%");
	    emit(EVENT_AUTOPLAY_PLAYING, rate);
	  }

	  function onMove(index) {
	    var Slide = Components2.Slides.getAt(index);
	    interval.set(Slide && +getAttribute(Slide.slide, INTERVAL_DATA_ATTRIBUTE) || options.interval);
	  }

	  return {
	    mount: mount,
	    destroy: interval.cancel,
	    play: play,
	    pause: pause,
	    isPaused: isPaused
	  };
	}

	function Cover(Splide2, Components2, options) {
	  var _EventInterface7 = EventInterface(Splide2),
	      on = _EventInterface7.on;

	  function mount() {
	    if (options.cover) {
	      on(EVENT_LAZYLOAD_LOADED, apply(toggle, true));
	      on([EVENT_MOUNTED, EVENT_UPDATED, EVENT_REFRESH], apply(cover, true));
	    }
	  }

	  function cover(cover2) {
	    Components2.Slides.forEach(function (Slide) {
	      var img = child(Slide.container || Slide.slide, "img");

	      if (img && img.src) {
	        toggle(cover2, img, Slide);
	      }
	    });
	  }

	  function toggle(cover2, img, Slide) {
	    Slide.style("background", cover2 ? "center/cover no-repeat url(\"" + img.src + "\")" : "", true);
	    display(img, cover2 ? "none" : "");
	  }

	  return {
	    mount: mount,
	    destroy: apply(cover, false)
	  };
	}

	var BOUNCE_DIFF_THRESHOLD = 10;
	var BOUNCE_DURATION = 600;
	var FRICTION_FACTOR = 0.6;
	var BASE_VELOCITY = 1.5;
	var MIN_DURATION = 800;

	function Scroll(Splide2, Components2, options) {
	  var _EventInterface8 = EventInterface(Splide2),
	      on = _EventInterface8.on,
	      emit = _EventInterface8.emit;

	  var set = Splide2.state.set;
	  var Move = Components2.Move;
	  var getPosition = Move.getPosition,
	      getLimit = Move.getLimit,
	      exceededLimit = Move.exceededLimit,
	      translate = Move.translate;
	  var isSlide = Splide2.is(SLIDE);
	  var interval;
	  var callback;
	  var friction = 1;

	  function mount() {
	    on(EVENT_MOVE, clear);
	    on([EVENT_UPDATED, EVENT_REFRESH], cancel);
	  }

	  function scroll(destination, duration, snap, onScrolled, noConstrain) {
	    var from = getPosition();
	    clear();

	    if (snap && (!isSlide || !exceededLimit())) {
	      var size = Components2.Layout.sliderSize();
	      var offset = sign(destination) * size * floor(abs(destination) / size) || 0;
	      destination = Move.toPosition(Components2.Controller.toDest(destination % size)) + offset;
	    }

	    var noDistance = approximatelyEqual(from, destination, 1);
	    friction = 1;
	    duration = noDistance ? 0 : duration || max(abs(destination - from) / BASE_VELOCITY, MIN_DURATION);
	    callback = onScrolled;
	    interval = RequestInterval(duration, onEnd, apply(update, from, destination, noConstrain), 1);
	    set(SCROLLING);
	    emit(EVENT_SCROLL);
	    interval.start();
	  }

	  function onEnd() {
	    set(IDLE);
	    callback && callback();
	    emit(EVENT_SCROLLED);
	  }

	  function update(from, to, noConstrain, rate) {
	    var position = getPosition();
	    var target = from + (to - from) * easing(rate);
	    var diff = (target - position) * friction;
	    translate(position + diff);

	    if (isSlide && !noConstrain && exceededLimit()) {
	      friction *= FRICTION_FACTOR;

	      if (abs(diff) < BOUNCE_DIFF_THRESHOLD) {
	        scroll(getLimit(exceededLimit(true)), BOUNCE_DURATION, false, callback, true);
	      }
	    }
	  }

	  function clear() {
	    if (interval) {
	      interval.cancel();
	    }
	  }

	  function cancel() {
	    if (interval && !interval.isPaused()) {
	      clear();
	      onEnd();
	    }
	  }

	  function easing(t) {
	    var easingFunc = options.easingFunc;
	    return easingFunc ? easingFunc(t) : 1 - Math.pow(1 - t, 4);
	  }

	  return {
	    mount: mount,
	    destroy: clear,
	    scroll: scroll,
	    cancel: cancel
	  };
	}

	var SCROLL_LISTENER_OPTIONS = {
	  passive: false,
	  capture: true
	};

	function Drag(Splide2, Components2, options) {
	  var _EventInterface9 = EventInterface(Splide2),
	      on = _EventInterface9.on,
	      emit = _EventInterface9.emit,
	      bind = _EventInterface9.bind,
	      unbind = _EventInterface9.unbind;

	  var state = Splide2.state;
	  var Move = Components2.Move,
	      Scroll = Components2.Scroll,
	      Controller = Components2.Controller,
	      track = Components2.Elements.track,
	      reduce = Components2.Media.reduce;
	  var _Components2$Directio2 = Components2.Direction,
	      resolve = _Components2$Directio2.resolve,
	      orient = _Components2$Directio2.orient;
	  var getPosition = Move.getPosition,
	      exceededLimit = Move.exceededLimit;
	  var basePosition;
	  var baseEvent;
	  var prevBaseEvent;
	  var isFree;
	  var dragging;
	  var exceeded = false;
	  var clickPrevented;
	  var disabled;
	  var target;

	  function mount() {
	    bind(track, POINTER_MOVE_EVENTS, noop, SCROLL_LISTENER_OPTIONS);
	    bind(track, POINTER_UP_EVENTS, noop, SCROLL_LISTENER_OPTIONS);
	    bind(track, POINTER_DOWN_EVENTS, onPointerDown, SCROLL_LISTENER_OPTIONS);
	    bind(track, "click", onClick, {
	      capture: true
	    });
	    bind(track, "dragstart", prevent);
	    on([EVENT_MOUNTED, EVENT_UPDATED], init);
	  }

	  function init() {
	    var drag = options.drag;
	    disable(!drag);
	    isFree = drag === "free";
	  }

	  function onPointerDown(e) {
	    clickPrevented = false;

	    if (!disabled) {
	      var isTouch = isTouchEvent(e);

	      if (isDraggable(e.target) && (isTouch || !e.button)) {
	        if (!Controller.isBusy()) {
	          target = isTouch ? track : window;
	          dragging = state.is([MOVING, SCROLLING]);
	          prevBaseEvent = null;
	          bind(target, POINTER_MOVE_EVENTS, onPointerMove, SCROLL_LISTENER_OPTIONS);
	          bind(target, POINTER_UP_EVENTS, onPointerUp, SCROLL_LISTENER_OPTIONS);
	          Move.cancel();
	          Scroll.cancel();
	          save(e);
	        } else {
	          prevent(e, true);
	        }
	      }
	    }
	  }

	  function onPointerMove(e) {
	    if (!state.is(DRAGGING)) {
	      state.set(DRAGGING);
	      emit(EVENT_DRAG);
	    }

	    if (e.cancelable) {
	      if (dragging) {
	        Move.translate(basePosition + constrain(diffCoord(e)));
	        var expired = diffTime(e) > LOG_INTERVAL;
	        var hasExceeded = exceeded !== (exceeded = exceededLimit());

	        if (expired || hasExceeded) {
	          save(e);
	        }

	        clickPrevented = true;
	        emit(EVENT_DRAGGING);
	        prevent(e);
	      } else if (isSliderDirection(e)) {
	        dragging = shouldStart(e);
	        prevent(e);
	      }
	    }
	  }

	  function onPointerUp(e) {
	    if (state.is(DRAGGING)) {
	      state.set(IDLE);
	      emit(EVENT_DRAGGED);
	    }

	    if (dragging) {
	      move(e);
	      prevent(e);
	    }

	    unbind(target, POINTER_MOVE_EVENTS, onPointerMove);
	    unbind(target, POINTER_UP_EVENTS, onPointerUp);
	    dragging = false;
	  }

	  function onClick(e) {
	    if (!disabled && clickPrevented) {
	      prevent(e, true);
	    }
	  }

	  function save(e) {
	    prevBaseEvent = baseEvent;
	    baseEvent = e;
	    basePosition = getPosition();
	  }

	  function move(e) {
	    var velocity = computeVelocity(e);
	    var destination = computeDestination(velocity);
	    var rewind = options.rewind && options.rewindByDrag;
	    reduce(false);

	    if (isFree) {
	      Controller.scroll(destination, 0, options.snap);
	    } else if (Splide2.is(FADE)) {
	      Controller.go(orient(sign(velocity)) < 0 ? rewind ? "<" : "-" : rewind ? ">" : "+");
	    } else if (Splide2.is(SLIDE) && exceeded && rewind) {
	      Controller.go(exceededLimit(true) ? ">" : "<");
	    } else {
	      Controller.go(Controller.toDest(destination), true);
	    }

	    reduce(true);
	  }

	  function shouldStart(e) {
	    var thresholds = options.dragMinThreshold;
	    var isObj = isObject(thresholds);
	    var mouse = isObj && thresholds.mouse || 0;
	    var touch = (isObj ? thresholds.touch : +thresholds) || 10;
	    return abs(diffCoord(e)) > (isTouchEvent(e) ? touch : mouse);
	  }

	  function isSliderDirection(e) {
	    return abs(diffCoord(e)) > abs(diffCoord(e, true));
	  }

	  function computeVelocity(e) {
	    if (Splide2.is(LOOP) || !exceeded) {
	      var time = diffTime(e);

	      if (time && time < LOG_INTERVAL) {
	        return diffCoord(e) / time;
	      }
	    }

	    return 0;
	  }

	  function computeDestination(velocity) {
	    return getPosition() + sign(velocity) * min(abs(velocity) * (options.flickPower || 600), isFree ? Infinity : Components2.Layout.listSize() * (options.flickMaxPages || 1));
	  }

	  function diffCoord(e, orthogonal) {
	    return coordOf(e, orthogonal) - coordOf(getBaseEvent(e), orthogonal);
	  }

	  function diffTime(e) {
	    return timeOf(e) - timeOf(getBaseEvent(e));
	  }

	  function getBaseEvent(e) {
	    return baseEvent === e && prevBaseEvent || baseEvent;
	  }

	  function coordOf(e, orthogonal) {
	    return (isTouchEvent(e) ? e.changedTouches[0] : e)["page" + resolve(orthogonal ? "Y" : "X")];
	  }

	  function constrain(diff) {
	    return diff / (exceeded && Splide2.is(SLIDE) ? FRICTION : 1);
	  }

	  function isDraggable(target2) {
	    var noDrag = options.noDrag;
	    return !matches(target2, "." + CLASS_PAGINATION_PAGE + ", ." + CLASS_ARROW) && (!noDrag || !matches(target2, noDrag));
	  }

	  function isTouchEvent(e) {
	    return typeof TouchEvent !== "undefined" && e instanceof TouchEvent;
	  }

	  function isDragging() {
	    return dragging;
	  }

	  function disable(value) {
	    disabled = value;
	  }

	  return {
	    mount: mount,
	    disable: disable,
	    isDragging: isDragging
	  };
	}

	var NORMALIZATION_MAP = {
	  Spacebar: " ",
	  Right: ARROW_RIGHT,
	  Left: ARROW_LEFT,
	  Up: ARROW_UP,
	  Down: ARROW_DOWN
	};

	function normalizeKey(key) {
	  key = isString(key) ? key : key.key;
	  return NORMALIZATION_MAP[key] || key;
	}

	var KEYBOARD_EVENT = "keydown";

	function Keyboard(Splide2, Components2, options) {
	  var _EventInterface10 = EventInterface(Splide2),
	      on = _EventInterface10.on,
	      bind = _EventInterface10.bind,
	      unbind = _EventInterface10.unbind;

	  var root = Splide2.root;
	  var resolve = Components2.Direction.resolve;
	  var target;
	  var disabled;

	  function mount() {
	    init();
	    on(EVENT_UPDATED, destroy);
	    on(EVENT_UPDATED, init);
	    on(EVENT_MOVE, onMove);
	  }

	  function init() {
	    var keyboard = options.keyboard;

	    if (keyboard) {
	      target = keyboard === "global" ? window : root;
	      bind(target, KEYBOARD_EVENT, onKeydown);
	    }
	  }

	  function destroy() {
	    unbind(target, KEYBOARD_EVENT);
	  }

	  function disable(value) {
	    disabled = value;
	  }

	  function onMove() {
	    var _disabled = disabled;
	    disabled = true;
	    nextTick(function () {
	      disabled = _disabled;
	    });
	  }

	  function onKeydown(e) {
	    if (!disabled) {
	      var key = normalizeKey(e);

	      if (key === resolve(ARROW_LEFT)) {
	        Splide2.go("<");
	      } else if (key === resolve(ARROW_RIGHT)) {
	        Splide2.go(">");
	      }
	    }
	  }

	  return {
	    mount: mount,
	    destroy: destroy,
	    disable: disable
	  };
	}

	var SRC_DATA_ATTRIBUTE = DATA_ATTRIBUTE + "-lazy";
	var SRCSET_DATA_ATTRIBUTE = SRC_DATA_ATTRIBUTE + "-srcset";
	var IMAGE_SELECTOR = "[" + SRC_DATA_ATTRIBUTE + "], [" + SRCSET_DATA_ATTRIBUTE + "]";

	function LazyLoad(Splide2, Components2, options) {
	  var _EventInterface11 = EventInterface(Splide2),
	      on = _EventInterface11.on,
	      off = _EventInterface11.off,
	      bind = _EventInterface11.bind,
	      emit = _EventInterface11.emit;

	  var isSequential = options.lazyLoad === "sequential";
	  var events = [EVENT_MOVED, EVENT_SCROLLED];
	  var entries = [];

	  function mount() {
	    if (options.lazyLoad) {
	      init();
	      on(EVENT_REFRESH, init);
	    }
	  }

	  function init() {
	    empty(entries);
	    register();

	    if (isSequential) {
	      loadNext();
	    } else {
	      off(events);
	      on(events, check);
	      check();
	    }
	  }

	  function register() {
	    Components2.Slides.forEach(function (Slide) {
	      queryAll(Slide.slide, IMAGE_SELECTOR).forEach(function (img) {
	        var src = getAttribute(img, SRC_DATA_ATTRIBUTE);
	        var srcset = getAttribute(img, SRCSET_DATA_ATTRIBUTE);

	        if (src !== img.src || srcset !== img.srcset) {
	          var className = options.classes.spinner;
	          var parent = img.parentElement;
	          var spinner = child(parent, "." + className) || create("span", className, parent);
	          entries.push([img, Slide, spinner]);
	          img.src || display(img, "none");
	        }
	      });
	    });
	  }

	  function check() {
	    entries = entries.filter(function (data) {
	      var distance = options.perPage * ((options.preloadPages || 1) + 1) - 1;
	      return data[1].isWithin(Splide2.index, distance) ? load(data) : true;
	    });
	    entries.length || off(events);
	  }

	  function load(data) {
	    var img = data[0];
	    addClass(data[1].slide, CLASS_LOADING);
	    bind(img, "load error", apply(onLoad, data));
	    setAttribute(img, "src", getAttribute(img, SRC_DATA_ATTRIBUTE));
	    setAttribute(img, "srcset", getAttribute(img, SRCSET_DATA_ATTRIBUTE));
	    removeAttribute(img, SRC_DATA_ATTRIBUTE);
	    removeAttribute(img, SRCSET_DATA_ATTRIBUTE);
	  }

	  function onLoad(data, e) {
	    var img = data[0],
	        Slide = data[1];
	    removeClass(Slide.slide, CLASS_LOADING);

	    if (e.type !== "error") {
	      remove(data[2]);
	      display(img, "");
	      emit(EVENT_LAZYLOAD_LOADED, img, Slide);
	      emit(EVENT_RESIZE);
	    }

	    isSequential && loadNext();
	  }

	  function loadNext() {
	    entries.length && load(entries.shift());
	  }

	  return {
	    mount: mount,
	    destroy: apply(empty, entries),
	    check: check
	  };
	}

	function Pagination(Splide2, Components2, options) {
	  var event = EventInterface(Splide2);
	  var on = event.on,
	      emit = event.emit,
	      bind = event.bind;
	  var Slides = Components2.Slides,
	      Elements = Components2.Elements,
	      Controller = Components2.Controller;
	  var hasFocus = Controller.hasFocus,
	      getIndex = Controller.getIndex,
	      go = Controller.go;
	  var resolve = Components2.Direction.resolve;
	  var placeholder = Elements.pagination;
	  var items = [];
	  var list;
	  var paginationClasses;

	  function mount() {
	    destroy();
	    on([EVENT_UPDATED, EVENT_REFRESH, EVENT_END_INDEX_CHANGED], mount);
	    var enabled = options.pagination;
	    placeholder && display(placeholder, enabled ? "" : "none");

	    if (enabled) {
	      on([EVENT_MOVE, EVENT_SCROLL, EVENT_SCROLLED], update);
	      createPagination();
	      update();
	      emit(EVENT_PAGINATION_MOUNTED, {
	        list: list,
	        items: items
	      }, getAt(Splide2.index));
	    }
	  }

	  function destroy() {
	    if (list) {
	      remove(placeholder ? slice(list.children) : list);
	      removeClass(list, paginationClasses);
	      empty(items);
	      list = null;
	    }

	    event.destroy();
	  }

	  function createPagination() {
	    var length = Splide2.length;
	    var classes = options.classes,
	        i18n = options.i18n,
	        perPage = options.perPage;
	    var max = hasFocus() ? Controller.getEnd() + 1 : ceil(length / perPage);
	    list = placeholder || create("ul", classes.pagination, Elements.track.parentElement);
	    addClass(list, paginationClasses = CLASS_PAGINATION + "--" + getDirection());
	    setAttribute(list, ROLE, "tablist");
	    setAttribute(list, ARIA_LABEL, i18n.select);
	    setAttribute(list, ARIA_ORIENTATION, getDirection() === TTB ? "vertical" : "");

	    for (var i = 0; i < max; i++) {
	      var li = create("li", null, list);
	      var button = create("button", {
	        class: classes.page,
	        type: "button"
	      }, li);
	      var controls = Slides.getIn(i).map(function (Slide) {
	        return Slide.slide.id;
	      });
	      var text = !hasFocus() && perPage > 1 ? i18n.pageX : i18n.slideX;
	      bind(button, "click", apply(onClick, i));

	      if (options.paginationKeyboard) {
	        bind(button, "keydown", apply(onKeydown, i));
	      }

	      setAttribute(li, ROLE, "presentation");
	      setAttribute(button, ROLE, "tab");
	      setAttribute(button, ARIA_CONTROLS, controls.join(" "));
	      setAttribute(button, ARIA_LABEL, format(text, i + 1));
	      setAttribute(button, TAB_INDEX, -1);
	      items.push({
	        li: li,
	        button: button,
	        page: i
	      });
	    }
	  }

	  function onClick(page) {
	    go(">" + page, true);
	  }

	  function onKeydown(page, e) {
	    var length = items.length;
	    var key = normalizeKey(e);
	    var dir = getDirection();
	    var nextPage = -1;

	    if (key === resolve(ARROW_RIGHT, false, dir)) {
	      nextPage = ++page % length;
	    } else if (key === resolve(ARROW_LEFT, false, dir)) {
	      nextPage = (--page + length) % length;
	    } else if (key === "Home") {
	      nextPage = 0;
	    } else if (key === "End") {
	      nextPage = length - 1;
	    }

	    var item = items[nextPage];

	    if (item) {
	      focus(item.button);
	      go(">" + nextPage);
	      prevent(e, true);
	    }
	  }

	  function getDirection() {
	    return options.paginationDirection || options.direction;
	  }

	  function getAt(index) {
	    return items[Controller.toPage(index)];
	  }

	  function update() {
	    var prev = getAt(getIndex(true));
	    var curr = getAt(getIndex());

	    if (prev) {
	      var button = prev.button;
	      removeClass(button, CLASS_ACTIVE);
	      removeAttribute(button, ARIA_SELECTED);
	      setAttribute(button, TAB_INDEX, -1);
	    }

	    if (curr) {
	      var _button = curr.button;
	      addClass(_button, CLASS_ACTIVE);
	      setAttribute(_button, ARIA_SELECTED, true);
	      setAttribute(_button, TAB_INDEX, "");
	    }

	    emit(EVENT_PAGINATION_UPDATED, {
	      list: list,
	      items: items
	    }, prev, curr);
	  }

	  return {
	    items: items,
	    mount: mount,
	    destroy: destroy,
	    getAt: getAt,
	    update: update
	  };
	}

	var TRIGGER_KEYS = [" ", "Enter"];

	function Sync(Splide2, Components2, options) {
	  var isNavigation = options.isNavigation,
	      slideFocus = options.slideFocus;
	  var events = [];

	  function mount() {
	    Splide2.splides.forEach(function (target) {
	      if (!target.isParent) {
	        sync(Splide2, target.splide);
	        sync(target.splide, Splide2);
	      }
	    });

	    if (isNavigation) {
	      navigate();
	    }
	  }

	  function destroy() {
	    events.forEach(function (event) {
	      event.destroy();
	    });
	    empty(events);
	  }

	  function remount() {
	    destroy();
	    mount();
	  }

	  function sync(splide, target) {
	    var event = EventInterface(splide);
	    event.on(EVENT_MOVE, function (index, prev, dest) {
	      target.go(target.is(LOOP) ? dest : index);
	    });
	    events.push(event);
	  }

	  function navigate() {
	    var event = EventInterface(Splide2);
	    var on = event.on;
	    on(EVENT_CLICK, onClick);
	    on(EVENT_SLIDE_KEYDOWN, onKeydown);
	    on([EVENT_MOUNTED, EVENT_UPDATED], update);
	    events.push(event);
	    event.emit(EVENT_NAVIGATION_MOUNTED, Splide2.splides);
	  }

	  function update() {
	    setAttribute(Components2.Elements.list, ARIA_ORIENTATION, options.direction === TTB ? "vertical" : "");
	  }

	  function onClick(Slide) {
	    Splide2.go(Slide.index);
	  }

	  function onKeydown(Slide, e) {
	    if (includes(TRIGGER_KEYS, normalizeKey(e))) {
	      onClick(Slide);
	      prevent(e);
	    }
	  }

	  return {
	    setup: apply(Components2.Media.set, {
	      slideFocus: isUndefined(slideFocus) ? isNavigation : slideFocus
	    }, true),
	    mount: mount,
	    destroy: destroy,
	    remount: remount
	  };
	}

	function Wheel(Splide2, Components2, options) {
	  var _EventInterface12 = EventInterface(Splide2),
	      bind = _EventInterface12.bind;

	  var lastTime = 0;

	  function mount() {
	    if (options.wheel) {
	      bind(Components2.Elements.track, "wheel", onWheel, SCROLL_LISTENER_OPTIONS);
	    }
	  }

	  function onWheel(e) {
	    if (e.cancelable) {
	      var deltaY = e.deltaY;
	      var backwards = deltaY < 0;
	      var timeStamp = timeOf(e);

	      var _min = options.wheelMinThreshold || 0;

	      var sleep = options.wheelSleep || 0;

	      if (abs(deltaY) > _min && timeStamp - lastTime > sleep) {
	        Splide2.go(backwards ? "<" : ">");
	        lastTime = timeStamp;
	      }

	      shouldPrevent(backwards) && prevent(e);
	    }
	  }

	  function shouldPrevent(backwards) {
	    return !options.releaseWheel || Splide2.state.is(MOVING) || Components2.Controller.getAdjacent(backwards) !== -1;
	  }

	  return {
	    mount: mount
	  };
	}

	var SR_REMOVAL_DELAY = 90;

	function Live(Splide2, Components2, options) {
	  var _EventInterface13 = EventInterface(Splide2),
	      on = _EventInterface13.on;

	  var track = Components2.Elements.track;
	  var enabled = options.live && !options.isNavigation;
	  var sr = create("span", CLASS_SR);
	  var interval = RequestInterval(SR_REMOVAL_DELAY, apply(toggle, false));

	  function mount() {
	    if (enabled) {
	      disable(!Components2.Autoplay.isPaused());
	      setAttribute(track, ARIA_ATOMIC, true);
	      sr.textContent = "\u2026";
	      on(EVENT_AUTOPLAY_PLAY, apply(disable, true));
	      on(EVENT_AUTOPLAY_PAUSE, apply(disable, false));
	      on([EVENT_MOVED, EVENT_SCROLLED], apply(toggle, true));
	    }
	  }

	  function toggle(active) {
	    setAttribute(track, ARIA_BUSY, active);

	    if (active) {
	      append(track, sr);
	      interval.start();
	    } else {
	      remove(sr);
	      interval.cancel();
	    }
	  }

	  function destroy() {
	    removeAttribute(track, [ARIA_LIVE, ARIA_ATOMIC, ARIA_BUSY]);
	    remove(sr);
	  }

	  function disable(disabled) {
	    if (enabled) {
	      setAttribute(track, ARIA_LIVE, disabled ? "off" : "polite");
	    }
	  }

	  return {
	    mount: mount,
	    disable: disable,
	    destroy: destroy
	  };
	}

	var ComponentConstructors = /*#__PURE__*/Object.freeze({
	  __proto__: null,
	  Media: Media,
	  Direction: Direction,
	  Elements: Elements,
	  Slides: Slides,
	  Layout: Layout,
	  Clones: Clones,
	  Move: Move,
	  Controller: Controller,
	  Arrows: Arrows,
	  Autoplay: Autoplay,
	  Cover: Cover,
	  Scroll: Scroll,
	  Drag: Drag,
	  Keyboard: Keyboard,
	  LazyLoad: LazyLoad,
	  Pagination: Pagination,
	  Sync: Sync,
	  Wheel: Wheel,
	  Live: Live
	});
	var I18N = {
	  prev: "Previous slide",
	  next: "Next slide",
	  first: "Go to first slide",
	  last: "Go to last slide",
	  slideX: "Go to slide %s",
	  pageX: "Go to page %s",
	  play: "Start autoplay",
	  pause: "Pause autoplay",
	  carousel: "carousel",
	  slide: "slide",
	  select: "Select a slide to show",
	  slideLabel: "%s of %s"
	};
	var DEFAULTS = {
	  type: "slide",
	  role: "region",
	  speed: 400,
	  perPage: 1,
	  cloneStatus: true,
	  arrows: true,
	  pagination: true,
	  paginationKeyboard: true,
	  interval: 5e3,
	  pauseOnHover: true,
	  pauseOnFocus: true,
	  resetProgress: true,
	  easing: "cubic-bezier(0.25, 1, 0.5, 1)",
	  drag: true,
	  direction: "ltr",
	  trimSpace: true,
	  focusableNodes: "a, button, textarea, input, select, iframe",
	  live: true,
	  classes: CLASSES,
	  i18n: I18N,
	  reducedMotion: {
	    speed: 0,
	    rewindSpeed: 0,
	    autoplay: "pause"
	  }
	};

	function Fade(Splide2, Components2, options) {
	  var Slides = Components2.Slides;

	  function mount() {
	    EventInterface(Splide2).on([EVENT_MOUNTED, EVENT_REFRESH], init);
	  }

	  function init() {
	    Slides.forEach(function (Slide) {
	      Slide.style("transform", "translateX(-" + 100 * Slide.index + "%)");
	    });
	  }

	  function start(index, done) {
	    Slides.style("transition", "opacity " + options.speed + "ms " + options.easing);
	    nextTick(done);
	  }

	  return {
	    mount: mount,
	    start: start,
	    cancel: noop
	  };
	}

	function Slide(Splide2, Components2, options) {
	  var Move = Components2.Move,
	      Controller = Components2.Controller,
	      Scroll = Components2.Scroll;
	  var list = Components2.Elements.list;
	  var transition = apply(style, list, "transition");
	  var endCallback;

	  function mount() {
	    EventInterface(Splide2).bind(list, "transitionend", function (e) {
	      if (e.target === list && endCallback) {
	        cancel();
	        endCallback();
	      }
	    });
	  }

	  function start(index, done) {
	    var destination = Move.toPosition(index, true);
	    var position = Move.getPosition();
	    var speed = getSpeed(index);

	    if (abs(destination - position) >= 1 && speed >= 1) {
	      if (options.useScroll) {
	        Scroll.scroll(destination, speed, false, done);
	      } else {
	        transition("transform " + speed + "ms " + options.easing);
	        Move.translate(destination, true);
	        endCallback = done;
	      }
	    } else {
	      Move.jump(index);
	      done();
	    }
	  }

	  function cancel() {
	    transition("");
	    Scroll.cancel();
	  }

	  function getSpeed(index) {
	    var rewindSpeed = options.rewindSpeed;

	    if (Splide2.is(SLIDE) && rewindSpeed) {
	      var prev = Controller.getIndex(true);
	      var end = Controller.getEnd();

	      if (prev === 0 && index >= end || prev >= end && index === 0) {
	        return rewindSpeed;
	      }
	    }

	    return options.speed;
	  }

	  return {
	    mount: mount,
	    start: start,
	    cancel: cancel
	  };
	}

	var _Splide = /*#__PURE__*/function () {
	  function _Splide(target, options) {
	    this.event = EventInterface();
	    this.Components = {};
	    this.state = State(CREATED);
	    this.splides = [];
	    this._o = {};
	    this._E = {};
	    var root = isString(target) ? query(document, target) : target;
	    assert(root, root + " is invalid.");
	    this.root = root;
	    options = merge({
	      label: getAttribute(root, ARIA_LABEL) || "",
	      labelledby: getAttribute(root, ARIA_LABELLEDBY) || ""
	    }, DEFAULTS, _Splide.defaults, options || {});

	    try {
	      merge(options, JSON.parse(getAttribute(root, DATA_ATTRIBUTE)));
	    } catch (e) {
	      assert(false, "Invalid JSON");
	    }

	    this._o = Object.create(merge({}, options));
	  }

	  var _proto = _Splide.prototype;

	  _proto.mount = function mount(Extensions, Transition) {
	    var _this = this;

	    var state = this.state,
	        Components2 = this.Components;
	    assert(state.is([CREATED, DESTROYED]), "Already mounted!");
	    state.set(CREATED);
	    this._C = Components2;
	    this._T = Transition || this._T || (this.is(FADE) ? Fade : Slide);
	    this._E = Extensions || this._E;
	    var Constructors = assign({}, ComponentConstructors, this._E, {
	      Transition: this._T
	    });
	    forOwn(Constructors, function (Component, key) {
	      var component = Component(_this, Components2, _this._o);
	      Components2[key] = component;
	      component.setup && component.setup();
	    });
	    forOwn(Components2, function (component) {
	      component.mount && component.mount();
	    });
	    this.emit(EVENT_MOUNTED);
	    addClass(this.root, CLASS_INITIALIZED);
	    state.set(IDLE);
	    this.emit(EVENT_READY);
	    return this;
	  };

	  _proto.sync = function sync(splide) {
	    this.splides.push({
	      splide: splide
	    });
	    splide.splides.push({
	      splide: this,
	      isParent: true
	    });

	    if (this.state.is(IDLE)) {
	      this._C.Sync.remount();

	      splide.Components.Sync.remount();
	    }

	    return this;
	  };

	  _proto.go = function go(control) {
	    this._C.Controller.go(control);

	    return this;
	  };

	  _proto.on = function on(events, callback) {
	    this.event.on(events, callback);
	    return this;
	  };

	  _proto.off = function off(events) {
	    this.event.off(events);
	    return this;
	  };

	  _proto.emit = function emit(event) {
	    var _this$event;

	    (_this$event = this.event).emit.apply(_this$event, [event].concat(slice(arguments, 1)));

	    return this;
	  };

	  _proto.add = function add(slides, index) {
	    this._C.Slides.add(slides, index);

	    return this;
	  };

	  _proto.remove = function remove(matcher) {
	    this._C.Slides.remove(matcher);

	    return this;
	  };

	  _proto.is = function is(type) {
	    return this._o.type === type;
	  };

	  _proto.refresh = function refresh() {
	    this.emit(EVENT_REFRESH);
	    return this;
	  };

	  _proto.destroy = function destroy(completely) {
	    if (completely === void 0) {
	      completely = true;
	    }

	    var event = this.event,
	        state = this.state;

	    if (state.is(CREATED)) {
	      EventInterface(this).on(EVENT_READY, this.destroy.bind(this, completely));
	    } else {
	      forOwn(this._C, function (component) {
	        component.destroy && component.destroy(completely);
	      }, true);
	      event.emit(EVENT_DESTROY);
	      event.destroy();
	      completely && empty(this.splides);
	      state.set(DESTROYED);
	    }

	    return this;
	  };

	  _createClass(_Splide, [{
	    key: "options",
	    get: function get() {
	      return this._o;
	    },
	    set: function set(options) {
	      this._C.Media.set(options, true, true);
	    }
	  }, {
	    key: "length",
	    get: function get() {
	      return this._C.Slides.getLength(true);
	    }
	  }, {
	    key: "index",
	    get: function get() {
	      return this._C.Controller.getIndex();
	    }
	  }]);

	  return _Splide;
	}();

	var Splide = _Splide;
	Splide.defaults = {};
	Splide.STATES = STATES;

	const propTypes = {
	    heading: validateProps.AllowedTypes.string,
	    headingSize: validateProps.AllowedTypes.oneOf(['x-large', 'xx-large']),
	    description: validateProps.AllowedTypes.string,
	    alignHeader: validateProps.AllowedTypes.oneOf(CAROUSEL_ALIGN_HEADERS),
	    rewind: validateProps.AllowedTypes.boolean,
	    wrapContent: validateProps.AllowedTypes.boolean,
	    width: validateProps.AllowedTypes.oneOf(CAROUSEL_WIDTHS),
	    slidesPerPage: validateProps.AllowedTypes.oneOf([
	        validateProps.AllowedTypes.breakpoint('number'),
	        validateProps.AllowedTypes.oneOf(['auto']),
	    ]),
	    disablePagination: validateProps.AllowedTypes.breakpoint('boolean'),
	    pagination: validateProps.AllowedTypes.breakpoint('boolean'),
	    aria: validateProps.AllowedTypes.aria(CAROUSEL_ARIA_ATTRIBUTES),
	    intl: validateProps.AllowedTypes.shape({
	        prev: validateProps.AllowedTypes.string,
	        next: validateProps.AllowedTypes.string,
	        first: validateProps.AllowedTypes.string,
	        last: validateProps.AllowedTypes.string,
	        slideLabel: validateProps.AllowedTypes.string,
	        slide: validateProps.AllowedTypes.string,
	    }),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    activeSlideIndex: validateProps.AllowedTypes.number,
	    skipLinkTarget: validateProps.AllowedTypes.string,
	};
	const Carousel = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.carouselChange = validateProps.createEvent(this, "carouselChange", 3);
	        this.update = validateProps.createEvent(this, "update", 3);
	        this.slides = [];
	        this.updateSlidesAndPagination = () => {
	            this.slides = getSlidesAndAddAttributes(this.host);
	            this.updateAmountOfPages();
	        };
	        this.updateAmountOfPages = () => {
	            this.amountOfPages = getAmountOfPages(this.slides.length, 
	            // round to sanitize floating numbers
	            this.slidesPerPage === 'auto' ? 1 : Math.round(validateProps.getCurrentMatchingBreakpointValue(this.slidesPerPage)));
	            renderPagination(this.paginationEl, this.amountOfPages, this.splide?.index || 0, this.splide);
	        };
	        this.onNextKeyDown = (e) => {
	            if (e.key === 'Tab' && !e.shiftKey) {
	                const activeSlide = this.slides.at(this.splide.index);
	                activeSlide.focus();
	                e.preventDefault();
	            }
	        };
	        this.onSplideFocusIn = (e) => {
	            const { target } = e;
	            const { index: splideIndex } = this.splide;
	            const slideIndexOfFocusedElement = this.slides.findIndex((slide) => slide.contains(target)); // focussed element is slot or within slide, e.g. link or button
	            const slideIsVisible = this.splide.Components.Elements.slides[slideIndexOfFocusedElement].classList.contains('is-visible');
	            if (splideIndex !== slideIndexOfFocusedElement) {
	                if (slideIndexOfFocusedElement > splideIndex && !slideIsVisible) {
	                    slideNext(this.splide, this.amountOfPages);
	                }
	                else if (slideIndexOfFocusedElement < splideIndex) {
	                    slidePrev(this.splide, this.amountOfPages);
	                }
	            }
	        };
	        this.heading = undefined;
	        this.headingSize = 'x-large';
	        this.description = undefined;
	        this.alignHeader = 'start';
	        this.rewind = true;
	        this.wrapContent = undefined;
	        this.width = 'basic';
	        this.slidesPerPage = 1;
	        this.disablePagination = undefined;
	        this.pagination = true;
	        this.aria = undefined;
	        this.intl = undefined;
	        this.theme = 'light';
	        this.activeSlideIndex = 0;
	        this.skipLinkTarget = undefined;
	        this.amountOfPages = undefined;
	    }
	    get hasNavigation() {
	        return this.slidesPerPage === 'auto' || this.amountOfPages > 1;
	    }
	    activeSlideHandler(newValue) {
	        this.splide.go(newValue); // change event is emitted via splide.on('move')
	    }
	    connectedCallback() {
	        validateProps.observeChildren(this.host, this.updateSlidesAndPagination);
	        this.observeBreakpointChange();
	        if (this.splide) {
	            this.observeSlides(); // on reconnect, adjust aria attributes on slides
	            // on reconnect we can reuse the splide instance
	            this.updateSlidesAndPagination();
	            this.registerSplideHandlers(this.splide);
	        }
	    }
	    componentWillLoad() {
	        this.slidesPerPage = validateProps.parseJSON(this.slidesPerPage); // dynamic change is not supported right now
	        this.updateSlidesAndPagination();
	        this.observeBreakpointChange();
	    }
	    componentShouldUpdate(newVal, oldVal, propName) {
	        return propName !== 'activeSlideIndex' && validateProps.hasPropValueChanged(newVal, oldVal); // we need to prevent splide reinitialization via splide.refresh() when activeSlideIndex is changed from outside
	    }
	    componentDidLoad() {
	        this.observeSlides(); // initial, adjust tabindex and aria attributes on slides
	        this.splide = new Splide(this.container, {
	            start: this.activeSlideIndex,
	            autoWidth: this.slidesPerPage === 'auto', // https://splidejs.com/guides/auto-width/#auto-width
	            arrows: false,
	            easing: validateProps.motionEasingBase,
	            pagination: false,
	            rewind: this.rewind,
	            rewindByDrag: true, // only works when rewind: true
	            drag: this.hasNavigation,
	            perMove: 1,
	            mediaQuery: 'min',
	            speed: parseFloat(carouselTransitionDuration) * 1000,
	            gap: gridGap.gridGap,
	            // TODO: this uses matchMedia internally, since we also use it, there is some redundancy
	            breakpoints: getSplideBreakpoints(this.slidesPerPage), // eslint-disable-line @typescript-eslint/no-redundant-type-constituents
	            // https://splidejs.com/guides/i18n/#default-texts
	            i18n: validateProps.parseJSONAttribute(this.intl || {}), // can only be applied initially atm
	        });
	        this.registerSplideHandlers(this.splide);
	    }
	    componentDidUpdate() {
	        this.splide.options = { drag: this.hasNavigation };
	        this.splide.refresh(); // needs to happen after render to detect new and removed slides
	        if (this.hasNavigation) {
	            renderPagination(this.paginationEl, this.amountOfPages, this.splide?.index || 0, this.splide); // update pagination in case the carousel was not draggable before
	            updatePrevNextButtons(this.btnPrev, this.btnNext, this.splide); // go to last/first slide aria might be wrong
	        }
	    }
	    disconnectedCallback() {
	        validateProps.unobserveChildren(this.host);
	        validateProps.unobserveChildren(this.container); // adjust tabindex and aria attributes on slides
	        validateProps.unobserveBreakpointChange(this.host);
	        this.splide.destroy();
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        const alignHeaderDeprecationMap = {
	            left: 'start',
	        };
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'alignHeader', alignHeaderDeprecationMap);
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'wrapContent');
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'disablePagination', 'Please use pagination prop instead.');
	        const hasHeadingPropOrSlot = hasHeading.hasHeading(this.host, this.heading);
	        const hasDescriptionPropOrSlot = hasDescription.hasDescription(this.host, this.description);
	        const hasControlsSlot = hasNamedSlot.hasNamedSlot(this.host, 'controls');
	        this.disablePagination = validateProps.parseJSON(this.disablePagination); // parsing the value just once per lifecycle
	        this.pagination = validateProps.parseJSON(this.pagination); // parsing the value just once per lifecycle
	        validateProps.attachComponentCss(this.host, getComponentCss, hasHeadingPropOrSlot, hasDescriptionPropOrSlot, hasControlsSlot, this.headingSize, this.width, 
	        // flip boolean values of disablePagination since it is the inverse of pagination
	        this.disablePagination
	            ? typeof this.disablePagination === 'object'
	                ? Object.fromEntries(Object.entries(this.disablePagination).map(([key, value]) => [key, !value]))
	                : !this.disablePagination
	            : this.pagination, isInfinitePagination(this.amountOfPages), (alignHeaderDeprecationMap[this.alignHeader] || this.alignHeader), this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        const btnProps = {
	            class: 'btn',
	            type: 'button',
	            hideLabel: true,
	            theme: this.theme,
	            // 'aria-controls': 'splide-track', // TODO: cross shadow dom? use native button tag instead of p-button-pure?
	        };
	        const headingId = 'heading';
	        return (validateProps.h(validateProps.Host, { key: '385078d73e8cb0842f74d9048800578e6bca60bb' }, validateProps.h("div", { key: 'e59eeeb6899e43d533af7621342c17028569f467', class: "header" }, hasHeadingPropOrSlot && (this.heading ? validateProps.h("h2", { id: headingId }, this.heading) : validateProps.h("slot", { name: "heading" })), hasDescriptionPropOrSlot && (this.description ? validateProps.h("p", null, this.description) : validateProps.h("slot", { name: "description" })), hasControlsSlot && validateProps.h("slot", { name: "controls" }), validateProps.h("div", { key: 'd118aa51a5737b3ac1f61cf106960aabf4ad28a7', class: "nav" }, this.skipLinkTarget && (validateProps.h(PrefixedTagNames.pLinkPure, { href: this.skipLinkTarget, theme: this.theme, icon: "arrow-last", class: "btn skip-link", alignLabel: "start", hideLabel: true }, "Skip carousel entries")), this.hasNavigation && (validateProps.h(PrefixedTagNames.pButtonPure, { ...btnProps, icon: "arrow-left", ref: (ref) => (this.btnPrev = ref), onClick: () => slidePrev(this.splide, this.amountOfPages) })), this.hasNavigation && (validateProps.h(PrefixedTagNames.pButtonPure, { ...btnProps, icon: "arrow-right", ref: (ref) => (this.btnNext = ref), onClick: () => slideNext(this.splide, this.amountOfPages), onKeyDown: this.onNextKeyDown })))), validateProps.h("div", { key: 'c727825419290b7afbc0d9242e9070725306286e', id: "splide", class: "splide", ...validateProps.parseAndGetAriaAttributes({
	                'aria-label': this.heading,
	                ...validateProps.parseAndGetAriaAttributes(this.aria),
	            }), ref: (ref) => (this.container = ref), onMouseDown: (e) => e.preventDefault(), onFocusin: this.onSplideFocusIn }, validateProps.h("div", { key: '2e05be9037877424f8ad417d3bbc454eba630b76', class: "splide__track" }, validateProps.h("div", { key: '0b315f064bd835eab0a9c7e2155fd712d2a97b80', class: "splide__list" }, this.slides.map((_, i) => (validateProps.h("div", { key: i, class: "splide__slide" }, validateProps.h("slot", { name: `slide-${i}` }))))))), (this.disablePagination ? this.disablePagination !== true : this.pagination) && this.hasNavigation && (validateProps.h("div", { class: "pagination-container", "aria-hidden": "true" }, validateProps.h("div", { class: "pagination", ref: (ref) => (this.paginationEl = ref) })))));
	    }
	    registerSplideHandlers(splide) {
	        splide.on('mounted', () => {
	            if (this.splide.options.drag) {
	                updatePrevNextButtons(this.btnPrev, this.btnNext, splide);
	                renderPagination(this.paginationEl, this.amountOfPages, this.activeSlideIndex, this.splide); // initial pagination
	            }
	        });
	        splide.on('move', (activeIndex, previousIndex) => {
	            updatePrevNextButtons(this.btnPrev, this.btnNext, splide);
	            updatePagination(this.paginationEl, this.amountOfPages, activeIndex);
	            this.update.emit({ activeIndex, previousIndex });
	            this.carouselChange.emit({ activeIndex, previousIndex });
	        });
	        splide.mount();
	    }
	    observeBreakpointChange() {
	        if (typeof this.slidesPerPage === 'object') {
	            validateProps.observeBreakpointChange(this.host, this.updateAmountOfPages);
	        }
	    }
	    observeSlides() {
	        // splide sets attributes everytime it slides or slides are added, which we need to adjust after wards
	        validateProps.observeChildren(this.container, () => this.splide.Components.Elements.slides.forEach((el) => {
	            el.removeAttribute('aria-hidden');
	        }), ['aria-hidden']);
	    }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "activeSlideIndex": ["activeSlideHandler"]
	    }; }
	};

	pCarousel_cjs_entry.p_carousel = Carousel;

	
	return pCarousel_cjs_entry;
}

var pCheckboxWrapper_cjs_entry = {};

var hasRequiredPCheckboxWrapper_cjs_entry;

function requirePCheckboxWrapper_cjs_entry () {
	if (hasRequiredPCheckboxWrapper_cjs_entry) return pCheckboxWrapper_cjs_entry;
	hasRequiredPCheckboxWrapper_cjs_entry = 1;

	Object.defineProperty(pCheckboxWrapper_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const isDisabledOrLoading = requireIsDisabledOrLoadingB1f56d7f();
	const required = requireRequiredF3c463a3();
	const theme = requireThemeBfc10573();
	const getOnlyChildOfKindHTMLElementOrThrow = requireGetOnlyChildOfKindHTMLElementOrThrowF7285231();
	const checkboxRadioStyles = requireCheckboxRadioStylesE83cbdf9();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const escapeHashCharacter = requireEscapeHashCharacterB9f68bcf();
	const label = requireLabel5379ea8c();
	const initialLoadingController = requireInitialLoadingController44585a09();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const fontLineHeight = requireFontLineHeight78b03658();
	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	requireHasNamedSlotA96fd22a();
	requireGetNamedSlotA0cdbdbc();
	requireTextSmallStyle7246779a();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireGetDirectChildHTMLElements31d23fa9();
	requireGetHTMLElements3f1c700f();
	requireTransformSelectorToDirectChildSelectorC1b1f9b0();
	requireHoverMediaQuery5e6deda8();
	requireFontSizeTextXSmallE59d35d7();
	requireGetClosestHTMLElement83d01a84();
	requireHasDescriptionBbe55afe();
	requireIsParentOfKindB7d9f81c();

	const getCheckedSVGBackgroundImage = (fill) => {
	    return escapeHashCharacter.getInlineSVGBackgroundImage(`<path fill="${fill}" d="m20.22,7.47l-1.47-1.42-9.26,9.02-4.24-4.15-1.47,1.42,5.71,5.6,10.73-10.47Z"/>`);
	};
	const getIndeterminateSVGBackgroundImage = (fill) => {
	    return escapeHashCharacter.getInlineSVGBackgroundImage(`<path fill="${fill}" d="m20,11v2H4v-2h16Z"/>`);
	};
	const getComponentCss = (hideLabel, state, isDisabled, isLoading, theme) => {
	    const { canvasColor } = validateProps.getHighContrastColors();
	    const checkedIconColor = validateProps.isHighContrastMode
	        ? canvasColor
	        : escapeHashCharacter.escapeHashCharacter(validateProps.getInvertedThemedColors(theme).primaryColor);
	    const checkedIconColorDark = validateProps.isHighContrastMode
	        ? canvasColor
	        : escapeHashCharacter.escapeHashCharacter(validateProps.getInvertedThemedColors('dark').primaryColor);
	    const indeterminateIconColor = validateProps.isHighContrastMode
	        ? canvasColor
	        : escapeHashCharacter.escapeHashCharacter(validateProps.getThemedColors(theme).primaryColor);
	    const indeterminateIconColorDark = validateProps.isHighContrastMode
	        ? canvasColor
	        : escapeHashCharacter.escapeHashCharacter(validateProps.getThemedColors('dark').primaryColor);
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            // ::slotted(input)
	            ...validateProps.addImportantToEachRule(validateProps.mergeDeep(checkboxRadioStyles.getSlottedCheckboxRadioButtonStyles(state, isDisabled, isLoading, theme), {
	                '::slotted': {
	                    '&(input)': {
	                        gridArea: '1/1',
	                        borderRadius: borderRadiusSmall.borderRadiusSmall,
	                    },
	                    // TODO: is it somehow useful possible to make following styles configurable by parameter?
	                    ...(!isLoading && {
	                        '&(input:checked)': {
	                            backgroundImage: getCheckedSVGBackgroundImage(checkedIconColor),
	                            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                                backgroundImage: getCheckedSVGBackgroundImage(checkedIconColorDark),
	                            }),
	                        },
	                        '&(input:indeterminate)': {
	                            backgroundImage: getIndeterminateSVGBackgroundImage(indeterminateIconColor),
	                            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                                backgroundImage: getIndeterminateSVGBackgroundImage(indeterminateIconColorDark),
	                            }),
	                        },
	                    }),
	                },
	            })),
	        },
	        root: {
	            display: 'grid',
	            gridTemplateColumns: 'auto minmax(0, 1fr)',
	            rowGap: spacingStaticXSmall.spacingStaticXSmall,
	        },
	        wrapper: {
	            display: 'grid',
	            gridArea: '1/1',
	            alignSelf: 'flex-start', // in case label becomes multiline
	            ...(isDisabledOrLoading.isDisabledOrLoading(isDisabled, isLoading) && {
	                // TODO: maybe .wrapper should handle it for all form components while pointer-events: none is set to input
	                cursor: 'not-allowed',
	            }),
	        },
	        ...(isLoading && {
	            // TODO: extract for checkbox-wrapper and radio-button-wrapper (not gridArea and placeSelf)
	            spinner: {
	                position: 'relative', // ensure correct stacking, can be removed as soon as focus for input is handled with outline
	                gridArea: '1/1',
	                placeSelf: 'center',
	                width: fontLineHeight.fontLineHeight,
	                height: fontLineHeight.fontLineHeight,
	                font: `${fontSizeTextSmall.fontSizeTextSmall} ${fontLineHeight.fontFamily}`, // needed for correct width and height definition based on ex-unit
	                pointerEvents: 'none',
	            },
	        }),
	        // .label / .required
	        ...label.getFunctionalComponentLabelStyles(isDisabled || isLoading, hideLabel, theme, {
	            gridArea: '1/2',
	        }, {
	            paddingTop: '2px', // compensate vertical alignment
	            paddingInlineStart: spacingStaticSmall.spacingStaticSmall, // asymmetric padding used instead of gap to prevent not clickable area between label and input
	        }),
	        // .message
	        ...required.getFunctionalComponentStateMessageStyles(theme, state, {
	            gridColumn: '1/3',
	        }),
	        // .loading
	        ...initialLoadingController.getFunctionalComponentLoadingMessageStyles(),
	    });
	};

	const propTypes = {
	    label: validateProps.AllowedTypes.string,
	    state: validateProps.AllowedTypes.oneOf(required.FORM_STATES),
	    message: validateProps.AllowedTypes.string,
	    hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	    loading: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const CheckboxWrapper = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.controllerHost = new initialLoadingController.ControllerHost(this);
	        this.loadingCtrl = new initialLoadingController.InitialLoadingController(this.controllerHost);
	        this.observeAttributes = () => {
	            validateProps.observeAttributes(this.input, ['disabled', 'required'], () => validateProps.forceUpdate(this.host));
	        };
	        this.label = '';
	        this.state = 'none';
	        this.message = '';
	        this.hideLabel = false;
	        this.loading = false;
	        this.theme = 'light';
	    }
	    onKeydown(e) {
	        const { key } = e;
	        if ((key === ' ' || key === 'Spacebar') && isDisabledOrLoading.isDisabledOrLoading(this.input.disabled, this.loading)) {
	            e.preventDefault();
	        }
	    }
	    connectedCallback() {
	        checkboxRadioStyles.applyCheckboxRadioButtonSafariRenderingFix(this.host);
	        this.observeAttributes(); // on every reconnect
	    }
	    componentWillLoad() {
	        this.input = getOnlyChildOfKindHTMLElementOrThrow.getOnlyChildOfKindHTMLElementOrThrow(this.host, 'input[type=checkbox]');
	        this.observeAttributes(); // once initially
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    componentDidRender() {
	        /*
	         * This is a workaround to improve accessibility because the input and the label/description/message text are placed in different DOM.
	         * Referencing ID's from outside the component is impossible because the web component’s DOM is separate.
	         * We have to wait for full support of the Accessibility Object Model (AOM) to provide the relationship between shadow DOM and slots
	         */
	        validateProps.setAriaAttributes(this.input, {
	            label: this.label,
	            message: this.message,
	            state: this.state,
	        });
	    }
	    disconnectedCallback() {
	        validateProps.unobserveAttributes(this.input);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        const { disabled } = this.input;
	        validateProps.attachComponentCss(this.host, getComponentCss, this.hideLabel, this.state, disabled, this.loading, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h("div", { key: '6456ad08689f85927a05da0781d55b2c9736c2a6', class: "root" }, validateProps.h(label.Label, { key: 'dc6c1efee1a855ef4a16563c9a7af92010421b30', host: this.host, label: this.label, isLoading: this.loading, isDisabled: disabled, formElement: this.input }), validateProps.h("div", { key: '41f7b7bf6aeeda2f21c880d75dcd34d5752492ac', class: "wrapper" }, validateProps.h("slot", { key: '9c7295d18974ef95fe2bc1db89fc5e04fc704ddb' }), this.loading && (validateProps.h(PrefixedTagNames.pSpinner, { class: "spinner", size: "inherit", theme: this.theme, "aria-hidden": "true" }))), validateProps.h(required.StateMessage, { key: '6324d285849f676cb6508a1519016804a1e3bcd2', state: this.state, message: this.message, theme: this.theme, host: this.host }), validateProps.h(initialLoadingController.LoadingMessage, { key: 'a3819094e87afc6f8e8d9db96bd56404df03d699', loading: this.loading, initialLoading: this.loadingCtrl.initialLoading })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pCheckboxWrapper_cjs_entry.p_checkbox_wrapper = CheckboxWrapper;

	
	return pCheckboxWrapper_cjs_entry;
}

var pContentWrapper_cjs_entry = {};

var warnIfDeprecatedComponentIsUsed6c2a81ac = {};

var hasRequiredWarnIfDeprecatedComponentIsUsed6c2a81ac;

function requireWarnIfDeprecatedComponentIsUsed6c2a81ac () {
	if (hasRequiredWarnIfDeprecatedComponentIsUsed6c2a81ac) return warnIfDeprecatedComponentIsUsed6c2a81ac;
	hasRequiredWarnIfDeprecatedComponentIsUsed6c2a81ac = 1;

	const validateProps = requireValidatePropsF6586828();

	const warnIfDeprecatedComponentIsUsed = (host, message) => {
	    validateProps.consoleWarn(`component ${validateProps.getTagNameWithoutPrefix(host)} is deprecated and will be removed with next major release.`, message);
	};

	warnIfDeprecatedComponentIsUsed6c2a81ac.warnIfDeprecatedComponentIsUsed = warnIfDeprecatedComponentIsUsed;

	
	return warnIfDeprecatedComponentIsUsed6c2a81ac;
}

var hasRequiredPContentWrapper_cjs_entry;

function requirePContentWrapper_cjs_entry () {
	if (hasRequiredPContentWrapper_cjs_entry) return pContentWrapper_cjs_entry;
	hasRequiredPContentWrapper_cjs_entry = 1;

	Object.defineProperty(pContentWrapper_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const warnIfDeprecatedComponentIsUsed = requireWarnIfDeprecatedComponentIsUsed6c2a81ac();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const gridExtendedOffsetBase = requireGridExtendedOffsetBaseFb9830f6();
	const gridExtendedOffsetXXL = requireGridExtendedOffsetXXLC7a41e50();
	const gridBasicOffset = requireGridBasicOffsetEafb13d6();
	requireGridGapB5b73e4a();
	requireSpacingFluidMedium88ab712b();

	const gridFullOffset = gridExtendedOffsetXXL._gridPadding;

	const gridNarrowOffsetBase = gridExtendedOffsetBase._gridSafeZoneBase;

	const gridNarrowOffsetS = gridExtendedOffsetXXL._getGridOffsetS('narrow');

	const gridNarrowOffsetXXL = gridExtendedOffsetXXL._getGridOffsetXXL('narrow');

	const gridNarrowOffset = {
	    base: gridNarrowOffsetBase,
	    s: gridNarrowOffsetS,
	    xxl: gridNarrowOffsetXXL,
	};

	const CONTENT_WRAPPER_BACKGROUND_COLORS = ['transparent', 'default'];
	// fluid is deprecated and will be mapped to full
	const CONTENT_WRAPPER_WIDTHS = ['narrow', 'basic', 'extended', 'fluid', 'full'];
	const deprecatedContentWrapperComponentMessage = 'Please use native CSS Grid (https://css-tricks.com/snippets/css/complete-guide-grid) instead in combination with the Porsche Grid utility based on CSS Grid.';

	const widthMap = {
	    narrow: gridNarrowOffset,
	    basic: gridBasicOffset.gridBasicOffset,
	    extended: gridBasicOffset.gridExtendedOffset,
	};
	const getComponentCss = (width) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	        },
	        root: {
	            minWidth: 0, // needed for some flex context
	            ...(['full', 'fluid'].includes(width)
	                ? {
	                    padding: `0 ${gridFullOffset}`,
	                }
	                : {
	                    padding: `0 ${widthMap[width].base}`,
	                    [validateProps.getMediaQueryMin('s')]: {
	                        padding: `0 ${widthMap[width].s}`,
	                    },
	                    [validateProps.getMediaQueryMin('xxl')]: {
	                        padding: `0 ${widthMap[width].xxl}`,
	                    },
	                }),
	        },
	    });
	};

	const propTypes = {
	    width: validateProps.AllowedTypes.oneOf(CONTENT_WRAPPER_WIDTHS),
	    backgroundColor: validateProps.AllowedTypes.oneOf(CONTENT_WRAPPER_BACKGROUND_COLORS),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const ContentWrapper = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.width = 'extended';
	        this.backgroundColor = 'transparent';
	        this.theme = 'light';
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedComponentIsUsed.warnIfDeprecatedComponentIsUsed(this.host, deprecatedContentWrapperComponentMessage);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.width);
	        return (validateProps.h("div", { key: 'c41ef65fdc48cdef955ca9789fa2bc7963894d57', class: "root" }, validateProps.h("slot", { key: '66d827db4be8931176a1b740f523c2ec2976a1ec' })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pContentWrapper_cjs_entry.p_content_wrapper = ContentWrapper;

	
	return pContentWrapper_cjs_entry;
}

var pCrest_cjs_entry = {};

var hasRequiredPCrest_cjs_entry;

function requirePCrest_cjs_entry () {
	if (hasRequiredPCrest_cjs_entry) return pCrest_cjs_entry;
	hasRequiredPCrest_cjs_entry = 1;

	Object.defineProperty(pCrest_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const getCDNBaseURL = requireGetCDNBaseURLE7722df3();
	const linkAriaAttribute = requireLinkAriaAttribute5de11e89();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();

	const CRESTS_MANIFEST = { "porscheCrest": { "1x": { "png": "porsche-crest.min.d76137cf8cf94822b7aedb534ba88418@1x.png", "webp": "porsche-crest.min.0d0cc89ae5ee57c4c15bd0dbbcbfe5d0@1x.webp" }, "2x": { "png": "porsche-crest.min.8a292fbd35a5155789ddd011585e05c4@2x.png", "webp": "porsche-crest.min.2245c45e99be5a46b4b56e73c43d5c63@2x.webp" }, "3x": { "png": "porsche-crest.min.18d6f02003b0829bac939fade88fd4e6@3x.png", "webp": "porsche-crest.min.19b429278b158b5cb5aa6ce80751e3fe@3x.webp" } } };

	const buildCrestSrcSet = (format) => {
	    return Object.entries(CRESTS_MANIFEST.porscheCrest)
	        .map(([resolution, fileName]) => `${getCDNBaseURL.getCDNBaseURL()}/crest/${fileName[format]} ${resolution}`)
	        .join();
	};
	const buildCrestImgSrc = () => {
	    return `${getCDNBaseURL.getCDNBaseURL()}/crest/${CRESTS_MANIFEST.porscheCrest['2x'].png}`;
	};
	const crestSize = {
	    width: 30,
	    height: 40,
	};

	const { width: width$1, height: height$1 } = crestSize;
	const getDimensionStyle = {
	    maxWidth: `${width$1}px`,
	    maxHeight: `${height$1}px`,
	    width: 'inherit',
	    height: 'inherit',
	};
	const getComponentCss = () => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                position: 'relative',
	                display: 'inline-block',
	                verticalAlign: 'top',
	                ...validateProps.addImportantToEachRule({
	                    outline: 0, // TODO: is it still necessary?
	                    boxSizing: 'content-box', // needed for correct height calculation when padding is set on host (e.g. custom click area)
	                    ...getDimensionStyle,
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            a: {
	                display: 'block',
	                textDecoration: 'none',
	                ...getDimensionStyle,
	                '&::before': {
	                    // needs to be defined always to have correct custom click area
	                    content: '""',
	                    position: 'absolute',
	                    inset: 0,
	                    borderRadius: '1px',
	                },
	                ...validateProps.getFocusJssStyle('light', { pseudo: true }), // TODO: we need to support theme
	            },
	            picture: {
	                display: 'block',
	                width: `min(${width$1}px, 100%)`,
	                height: `min(${height$1}px, 100%)`,
	            },
	            img: {
	                display: 'block',
	                maxWidth: '100%',
	                maxHeight: '100%',
	                width: 'auto',
	                height: 'auto',
	            },
	        },
	    });
	};

	const propTypes = {
	    href: validateProps.AllowedTypes.string,
	    target: validateProps.AllowedTypes.string,
	    aria: validateProps.AllowedTypes.aria(linkAriaAttribute.LINK_ARIA_ATTRIBUTES),
	};
	const { width, height } = crestSize;
	const Crest = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.href = undefined;
	        this.target = '_self';
	        this.aria = undefined;
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, getComponentCss);
	        const picture = window.PDS_SKIP_FETCH ? undefined :  (validateProps.h("picture", { key: '4e909578a0170d474b9d246af10f88f6da4e85f1' }, validateProps.h("source", { key: "webp", srcSet: buildCrestSrcSet('webp'), type: "image/webp" }), validateProps.h("source", { key: "png", srcSet: buildCrestSrcSet('png'), type: "image/png" }), validateProps.h("img", { key: '7c5254d7071814d193c48deee48a7438beaec77c', src: buildCrestImgSrc(), width: width, height: height, alt: "Porsche" })));
	        return (validateProps.h(validateProps.Host, { key: 'a5d535938a98ce5ec004e818344422951aa1137f' }, this.href === undefined ? (picture) : (validateProps.h("a", { href: this.href, target: this.target, ...validateProps.parseAndGetAriaAttributes(this.aria) }, picture))));
	    }
	    static get delegatesFocus() { return true; }
	    get host() { return validateProps.getElement(this); }
	};

	pCrest_cjs_entry.p_crest = Crest;

	
	return pCrest_cjs_entry;
}

var pDisplay_cjs_entry = {};

var typographyAlign25ce02f4 = {};

var hasRequiredTypographyAlign25ce02f4;

function requireTypographyAlign25ce02f4 () {
	if (hasRequiredTypographyAlign25ce02f4) return typographyAlign25ce02f4;
	hasRequiredTypographyAlign25ce02f4 = 1;

	const getDirectChildHTMLElement = requireGetDirectChildHTMLElementC5dd1dc2();

	const hasSpecificDirectChildTag = (host, tag) => {
	    const el = getDirectChildHTMLElement.getDirectChildHTMLElement(host, ':only-child');
	    return !!(el?.matches(tag));
	};

	// 'left' is deprecated and will be mapped to 'start'
	// 'right' is deprecated and will be mapped to 'end'
	/** @deprecated */
	const TYPOGRAPHY_ALIGNS_DEPRECATED = ['left', 'right'];
	const TYPOGRAPHY_ALIGNS = ['start', 'center', 'end', ...TYPOGRAPHY_ALIGNS_DEPRECATED];

	typographyAlign25ce02f4.TYPOGRAPHY_ALIGNS = TYPOGRAPHY_ALIGNS;
	typographyAlign25ce02f4.hasSpecificDirectChildTag = hasSpecificDirectChildTag;

	
	return typographyAlign25ce02f4;
}

var typographyStyles1a447490 = {};

var hasRequiredTypographyStyles1a447490;

function requireTypographyStyles1a447490 () {
	if (hasRequiredTypographyStyles1a447490) return typographyStyles1a447490;
	hasRequiredTypographyStyles1a447490 = 1;

	const textIconStyles = requireTextIconStyles990609fb();
	const validateProps = requireValidatePropsF6586828();

	const getTypographyRootJssStyle = (baseTextStyle, responsiveStyle, align, // eslint-disable-line @typescript-eslint/no-duplicate-type-constituents
	color, // eslint-disable-line @typescript-eslint/no-duplicate-type-constituents
	ellipsis, theme) => {
	    return {
	        margin: 0,
	        padding: 0,
	        ...baseTextStyle,
	        color: textIconStyles.getThemedTypographyColor(theme, color),
	        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	            color: textIconStyles.getThemedTypographyColor('dark', color),
	        }),
	        textAlign: align,
	        letterSpacing: 'normal',
	        listStyleType: 'none',
	        whiteSpace: 'inherit',
	        ...(ellipsis && {
	            maxWidth: '100%',
	            overflow: 'hidden',
	            textOverflow: 'ellipsis',
	            whiteSpace: 'nowrap',
	        }),
	        ...responsiveStyle,
	    };
	};
	const getTypographySlottedJssStyle = () => {
	    return {
	        all: 'unset',
	    };
	};

	typographyStyles1a447490.getTypographyRootJssStyle = getTypographyRootJssStyle;
	typographyStyles1a447490.getTypographySlottedJssStyle = getTypographySlottedJssStyle;

	
	return typographyStyles1a447490;
}

var hasRequiredPDisplay_cjs_entry;

function requirePDisplay_cjs_entry () {
	if (hasRequiredPDisplay_cjs_entry) return pDisplay_cjs_entry;
	hasRequiredPDisplay_cjs_entry = 1;

	Object.defineProperty(pDisplay_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const typographyAlign = requireTypographyAlign25ce02f4();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed2d6d1d94();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const typographyStyles = requireTypographyStyles1a447490();
	const displayShared = requireDisplayShared43dd15a5();
	requireGetDirectChildHTMLElementC5dd1dc2();
	requireTransformSelectorToDirectChildSelectorC1b1f9b0();
	requireHelperA66adcf2();
	requireTextIconStyles990609fb();
	requireFontLineHeight78b03658();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();

	const fontSizeDisplaySmall = 'clamp(1.8rem, 2.41vw + 1.32rem, 4.21rem)';

	const fontSizeDisplayLarge = 'clamp(2.28rem, 5.2vw + 1.24rem, 7.48rem)';

	const displayLargeStyle = {
	    font: `${displayShared._displayFontPartA}${fontSizeDisplayLarge}${displayShared._displayFontPartB}`,
	};

	const DISPLAY_TAGS = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
	const DISPLAY_SIZES = ['small', 'medium', 'large', 'inherit'];
	const DISPLAY_COLORS = ['primary', 'inherit'];
	const displaySizeToTagMap = {
	    small: 'h3',
	    medium: 'h2',
	    large: 'h1',
	    inherit: 'h1',
	};
	const getDisplayTagType = (host, size, tag) => {
	    if (typographyAlign.hasSpecificDirectChildTag(host, DISPLAY_TAGS.join())) {
	        return 'div';
	    }
	    else if (tag) {
	        return tag;
	    }
	    else {
	        return displaySizeToTagMap[size] || 'h1';
	    }
	};

	const sizeMap = {
	    small: fontSizeDisplaySmall,
	    medium: displayShared.fontSizeDisplayMedium,
	    large: fontSizeDisplayLarge,
	};
	const getComponentCss = (size, align, color, ellipsis, theme) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            [`::slotted(:is(${DISPLAY_TAGS.join()}))`]: validateProps.addImportantToEachRule(typographyStyles.getTypographySlottedJssStyle()),
	        },
	        root: typographyStyles.getTypographyRootJssStyle(displayLargeStyle, validateProps.buildResponsiveStyles(size, (sizeValue) => ({
	            fontSize: sizeValue === 'inherit' ? sizeValue : sizeMap[sizeValue],
	        })), align, color, ellipsis, theme),
	    });
	};

	const propTypes = {
	    tag: validateProps.AllowedTypes.oneOf([undefined, ...DISPLAY_TAGS]),
	    size: validateProps.AllowedTypes.breakpoint(DISPLAY_SIZES),
	    align: validateProps.AllowedTypes.oneOf(typographyAlign.TYPOGRAPHY_ALIGNS),
	    color: validateProps.AllowedTypes.oneOf(DISPLAY_COLORS),
	    ellipsis: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Display = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.tag = undefined;
	        this.size = 'large';
	        this.align = 'start';
	        this.color = 'primary';
	        this.ellipsis = false;
	        this.theme = 'light';
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        const alignDeprecationMap = {
	            left: 'start',
	            right: 'end',
	        };
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'align', alignDeprecationMap);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.size, (alignDeprecationMap[this.align] || this.align), this.color, this.ellipsis, this.theme);
	        const TagType = getDisplayTagType(this.host, this.size, this.tag);
	        return (validateProps.h(TagType, { key: '2905939684707e92cd0010741dcebe6356c0b8dc', class: "root" }, validateProps.h("slot", { key: '0a7c399b3f3bf9bc4cd8737e9ff094d656176b85' })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pDisplay_cjs_entry.p_display = Display;

	
	return pDisplay_cjs_entry;
}

var pDivider_cjs_entry = {};

var hasRequiredPDivider_cjs_entry;

function requirePDivider_cjs_entry () {
	if (hasRequiredPDivider_cjs_entry) return pDivider_cjs_entry;
	hasRequiredPDivider_cjs_entry = 1;

	Object.defineProperty(pDivider_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed2d6d1d94();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed0dc3288b();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	requireHelperA66adcf2();

	/** @deprecated */
	const DIVIDER_COLORS_DEPRECATED = [
	    'neutral-contrast-high',
	    'neutral-contrast-medium',
	    'neutral-contrast-low',
	];
	const DIVIDER_COLORS = [
	    'contrast-low',
	    'contrast-medium',
	    'contrast-high',
	    ...DIVIDER_COLORS_DEPRECATED,
	];
	const DIVIDER_DIRECTIONS = ['vertical', 'horizontal'];

	const getComponentCss = (color, orientation, theme) => {
	    const { contrastLowColor, contrastMediumColor, contrastHighColor } = validateProps.getThemedColors(theme);
	    const { contrastLowColor: contrastLowColorDark, contrastMediumColor: contrastMediumColorDark, contrastHighColor: contrastHighColorDark, } = validateProps.getThemedColors('dark');
	    const colorMap = {
	        'contrast-low': contrastLowColor,
	        'contrast-medium': contrastMediumColor,
	        'contrast-high': contrastHighColor,
	    };
	    const colorMapDark = {
	        'contrast-low': contrastLowColorDark,
	        'contrast-medium': contrastMediumColorDark,
	        'contrast-high': contrastHighColorDark,
	    };
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            hr: {
	                margin: 0,
	                padding: 0,
	                border: 'none',
	                textAlign: 'start',
	                ...(validateProps.isHighContrastMode
	                    ? {
	                        background: validateProps.getHighContrastColors().canvasTextColor,
	                    }
	                    : {
	                        background: colorMap[color],
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            background: colorMapDark[color],
	                        }),
	                    }),
	                ...validateProps.buildResponsiveStyles(orientation, (o) => o === 'horizontal' ? { height: '1px', width: '100%' } : { height: '100%', width: '1px' }),
	            },
	        },
	    });
	};

	const propTypes = {
	    color: validateProps.AllowedTypes.oneOf(DIVIDER_COLORS),
	    orientation: validateProps.AllowedTypes.breakpoint([undefined, ...DIVIDER_DIRECTIONS]),
	    direction: validateProps.AllowedTypes.breakpoint(DIVIDER_DIRECTIONS),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Divider = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.color = 'contrast-low';
	        this.orientation = undefined;
	        this.direction = 'horizontal';
	        this.theme = 'light';
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        const deprecationMap = {
	            'neutral-contrast-low': 'contrast-low',
	            'neutral-contrast-medium': 'contrast-medium',
	            'neutral-contrast-high': 'contrast-high',
	        };
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'color', deprecationMap);
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'orientation', 'Please use direction prop instead.');
	        validateProps.attachComponentCss(this.host, getComponentCss, (deprecationMap[this.color] || this.color), this.orientation || this.direction, this.theme);
	        return validateProps.h("hr", { key: '2ce3b422e21a68b98513796145a017dab424e203' });
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pDivider_cjs_entry.p_divider = Divider;

	
	return pDivider_cjs_entry;
}

var pFieldsetWrapper_cjs_entry = {};

var hasRequiredPFieldsetWrapper_cjs_entry;

function requirePFieldsetWrapper_cjs_entry () {
	if (hasRequiredPFieldsetWrapper_cjs_entry) return pFieldsetWrapper_cjs_entry;
	hasRequiredPFieldsetWrapper_cjs_entry = 1;

	Object.defineProperty(pFieldsetWrapper_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const required = requireRequiredF3c463a3();
	const warnIfDeprecatedComponentIsUsed = requireWarnIfDeprecatedComponentIsUsed6c2a81ac();
	const theme = requireThemeBfc10573();
	const fieldsetUtils = requireFieldsetUtilsA0590284();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();
	const headingSmallStyle = requireHeadingSmallStyle0707b97f();
	const headingMediumStyle = requireHeadingMediumStyle1c9f0c45();
	requireHasNamedSlotA96fd22a();
	requireGetNamedSlotA0cdbdbc();
	requireSpacingStaticXSmallB7d708b8();
	requireTextSmallStyle7246779a();
	requireTextShared9135e2ef();
	requireFontLineHeight78b03658();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireHeadingSharedAa59e66d();
	requireFontWeightSemiBold4482c830();
	requireFontSizeHeadingSmallA15141a5();
	requireFontSizeHeadingMediumC49ab5a2();
	requireFontSizeTextMedium88887ad8();

	const getComponentCss = (state, labelSize, hasLabel, theme) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            fieldset: {
	                margin: 0,
	                padding: 0,
	                border: 'none',
	            },
	            ...(hasLabel && {
	                legend: {
	                    margin: `0 0 ${spacingStaticMedium.spacingStaticMedium}`,
	                    padding: 0,
	                    color: validateProps.getThemedColors(theme).primaryColor,
	                    ...(labelSize === 'small' ? headingSmallStyle.headingSmallStyle : headingMediumStyle.headingMediumStyle),
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        color: validateProps.getThemedColors('dark').primaryColor,
	                    }),
	                },
	            }),
	        },
	        ...required.getFunctionalComponentRequiredStyles(),
	        ...validateProps.mergeDeep(required.getFunctionalComponentStateMessageStyles(theme, state), {
	            message: {
	                marginTop: spacingStaticMedium.spacingStaticMedium,
	            },
	        }),
	    });
	};

	const propTypes = {
	    label: validateProps.AllowedTypes.string,
	    labelSize: validateProps.AllowedTypes.oneOf(fieldsetUtils.FIELDSET_LABEL_SIZES),
	    required: validateProps.AllowedTypes.boolean,
	    state: validateProps.AllowedTypes.oneOf(required.FORM_STATES),
	    message: validateProps.AllowedTypes.string,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const FieldsetWrapper = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.label = '';
	        this.labelSize = 'medium';
	        this.required = false;
	        this.state = 'none';
	        this.message = '';
	        this.theme = 'light';
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedComponentIsUsed.warnIfDeprecatedComponentIsUsed(this.host, 'Please use new p-fieldset component instead.');
	        validateProps.attachComponentCss(this.host, getComponentCss, this.state, this.labelSize, required.hasLabel(this.host, this.label), this.theme);
	        const hasMessageValue = required.hasMessage(this.host, this.message, this.state);
	        return (validateProps.h("fieldset", { key: '4027e637aece95b7d29a2405fdf585c326e91f86', "aria-describedby": hasMessageValue ? required.messageId : null }, required.hasLabel(this.host, this.label) && (validateProps.h("legend", null, this.label || validateProps.h("slot", { name: "label" }), this.required && validateProps.h(required.Required, null))), validateProps.h("slot", { key: '551450bf1ddc33a34df128ecda69792a1e4f209b' }), validateProps.h(required.StateMessage, { key: '5e60a70b05c5c5dc3f69f28b567f56f85fb18645', state: this.state, message: this.message, theme: this.theme, host: this.host })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pFieldsetWrapper_cjs_entry.p_fieldset_wrapper = FieldsetWrapper;

	
	return pFieldsetWrapper_cjs_entry;
}

var pFieldset_cjs_entry = {};

var hasRequiredPFieldset_cjs_entry;

function requirePFieldset_cjs_entry () {
	if (hasRequiredPFieldset_cjs_entry) return pFieldset_cjs_entry;
	hasRequiredPFieldset_cjs_entry = 1;

	Object.defineProperty(pFieldset_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const required = requireRequiredF3c463a3();
	const theme = requireThemeBfc10573();
	const fieldsetUtils = requireFieldsetUtilsA0590284();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();
	const headingSmallStyle = requireHeadingSmallStyle0707b97f();
	const headingMediumStyle = requireHeadingMediumStyle1c9f0c45();
	requireHasNamedSlotA96fd22a();
	requireGetNamedSlotA0cdbdbc();
	requireSpacingStaticXSmallB7d708b8();
	requireTextSmallStyle7246779a();
	requireTextShared9135e2ef();
	requireFontLineHeight78b03658();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireHeadingSharedAa59e66d();
	requireFontWeightSemiBold4482c830();
	requireFontSizeHeadingSmallA15141a5();
	requireFontSizeHeadingMediumC49ab5a2();
	requireFontSizeTextMedium88887ad8();

	const getComponentCss = (state, labelSize, hasLabel, theme) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            fieldset: {
	                margin: 0,
	                padding: 0,
	                border: 'none',
	            },
	            ...(hasLabel && {
	                legend: {
	                    margin: `0 0 ${spacingStaticMedium.spacingStaticMedium}`,
	                    padding: 0,
	                    color: validateProps.getThemedColors(theme).primaryColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        color: validateProps.getThemedColors('dark').primaryColor,
	                    }),
	                    ...(labelSize === 'small' ? headingSmallStyle.headingSmallStyle : headingMediumStyle.headingMediumStyle),
	                },
	            }),
	        },
	        ...required.getFunctionalComponentRequiredStyles(),
	        ...validateProps.mergeDeep(required.getFunctionalComponentStateMessageStyles(theme, state), {
	            message: {
	                marginTop: spacingStaticMedium.spacingStaticMedium,
	            },
	        }),
	    });
	};

	const propTypes = {
	    label: validateProps.AllowedTypes.string,
	    labelSize: validateProps.AllowedTypes.oneOf(fieldsetUtils.FIELDSET_LABEL_SIZES),
	    required: validateProps.AllowedTypes.boolean,
	    state: validateProps.AllowedTypes.oneOf(required.FORM_STATES),
	    message: validateProps.AllowedTypes.string,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Fieldset = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.label = '';
	        this.labelSize = 'medium';
	        this.required = false;
	        this.state = 'none';
	        this.message = '';
	        this.theme = 'light';
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.state, this.labelSize, required.hasLabel(this.host, this.label), this.theme);
	        const hasMessageValue = required.hasMessage(this.host, this.message, this.state);
	        return (validateProps.h("fieldset", { key: '477ebc85b6136faf6c45323157e8d16a1c939e58', "aria-describedby": hasMessageValue ? required.messageId : null }, required.hasLabel(this.host, this.label) && (validateProps.h("legend", null, this.label || validateProps.h("slot", { name: "label" }), this.required && validateProps.h(required.Required, null))), validateProps.h("slot", { key: 'e8f150fbf230d273e05cb139f878883c9dd9503e' }), validateProps.h(required.StateMessage, { key: '836819ef00de7e042d04d1146f591ae0e13ceafa', state: this.state, message: this.message, theme: this.theme, host: this.host })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pFieldset_cjs_entry.p_fieldset = Fieldset;

	
	return pFieldset_cjs_entry;
}

var pFlex_2_cjs_entry = {};

var throwIfParentIsNotOfKindEb817ad3 = {};

var hasRequiredThrowIfParentIsNotOfKindEb817ad3;

function requireThrowIfParentIsNotOfKindEb817ad3 () {
	if (hasRequiredThrowIfParentIsNotOfKindEb817ad3) return throwIfParentIsNotOfKindEb817ad3;
	hasRequiredThrowIfParentIsNotOfKindEb817ad3 = 1;

	const validateProps = requireValidatePropsF6586828();
	const isParentOfKind = requireIsParentOfKindB7d9f81c();

	const throwIfParentIsNotOfKind = (element, tagName) => {
	    if (element.parentElement && !isParentOfKind.isParentOfKind(element, tagName)) {
	        const allowedTagName = validateProps.getPrefixedTagNames(element)[tagName];
	        const actualTagName = validateProps.getTagName(element.parentElement);
	        validateProps.throwException(`parent HTMLElement of ${validateProps.getTagName(element)} should be of kind ${allowedTagName} but got ${actualTagName}.`);
	    }
	};

	throwIfParentIsNotOfKindEb817ad3.throwIfParentIsNotOfKind = throwIfParentIsNotOfKind;

	
	return throwIfParentIsNotOfKindEb817ad3;
}

var hasRequiredPFlex_2_cjs_entry;

function requirePFlex_2_cjs_entry () {
	if (hasRequiredPFlex_2_cjs_entry) return pFlex_2_cjs_entry;
	hasRequiredPFlex_2_cjs_entry = 1;

	Object.defineProperty(pFlex_2_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const warnIfDeprecatedComponentIsUsed = requireWarnIfDeprecatedComponentIsUsed6c2a81ac();
	const throwIfParentIsNotOfKind = requireThrowIfParentIsNotOfKindEb817ad3();
	requireIsParentOfKindB7d9f81c();

	const FLEX_WRAPS = ['nowrap', 'wrap', 'wrap-reverse'];
	const FLEX_DIRECTIONS = ['row', 'row-reverse', 'column', 'column-reverse'];
	const FLEX_JUSTIFY_CONTENTS = [
	    'flex-start',
	    'flex-end',
	    'center',
	    'space-between',
	    'space-around',
	    'space-evenly',
	];
	const FLEX_ALIGN_ITEMS = ['stretch', 'flex-start', 'flex-end', 'center', 'baseline'];
	const FLEX_ALIGN_CONTENTS = [
	    'stretch',
	    'flex-start',
	    'flex-end',
	    'center',
	    'space-between',
	    'space-around',
	    'space-evenly',
	];
	const deprecatedFlexComponentMessage = 'Please use native CSS Flex (https://css-tricks.com/snippets/css/a-guide-to-flexbox) instead for better performance and more standardized layout technique.';

	const getComponentCss$1 = (inline, wrap, direction, justifyContent, alignItems, alignContent) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                ...validateProps.buildResponsiveStyles(inline, (inlineResponsive) => ({
	                    display: inlineResponsive ? 'inline-flex' : 'flex',
	                })),
	                ...validateProps.addImportantToEachRule(validateProps.mergeDeep(colorSchemeStyles.colorSchemeStyles, colorSchemeStyles.hostHiddenStyles, validateProps.buildResponsiveStyles(wrap, (flexWrapResponsive) => ({ flexWrap: flexWrapResponsive })), validateProps.buildResponsiveStyles(direction, (flexDirectionResponsive) => ({
	                    flexDirection: flexDirectionResponsive,
	                })), validateProps.buildResponsiveStyles(justifyContent, (justifyContentResponsive) => ({
	                    justifyContent: justifyContentResponsive,
	                })), validateProps.buildResponsiveStyles(alignItems, (alignItemsResponsive) => ({
	                    alignItems: alignItemsResponsive,
	                })), validateProps.buildResponsiveStyles(alignContent, (alignContentResponsive) => ({
	                    alignContent: alignContentResponsive,
	                })))),
	            },
	        },
	    });
	};

	const propTypes$1 = {
	    inline: validateProps.AllowedTypes.breakpoint('boolean'),
	    wrap: validateProps.AllowedTypes.breakpoint(FLEX_WRAPS),
	    direction: validateProps.AllowedTypes.breakpoint(FLEX_DIRECTIONS),
	    justifyContent: validateProps.AllowedTypes.breakpoint(FLEX_JUSTIFY_CONTENTS),
	    alignItems: validateProps.AllowedTypes.breakpoint(FLEX_ALIGN_ITEMS),
	    alignContent: validateProps.AllowedTypes.breakpoint(FLEX_ALIGN_CONTENTS),
	};
	const Flex = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.inline = false;
	        this.wrap = 'nowrap';
	        this.direction = 'row';
	        this.justifyContent = 'flex-start';
	        this.alignItems = 'stretch';
	        this.alignContent = 'stretch';
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes$1);
	        warnIfDeprecatedComponentIsUsed.warnIfDeprecatedComponentIsUsed(this.host, deprecatedFlexComponentMessage);
	        validateProps.attachComponentCss(this.host, getComponentCss$1, this.inline, this.wrap, this.direction, this.justifyContent, this.alignItems, this.alignContent);
	        return validateProps.h("slot", { key: '74716e80c83327e6fda6b0b9d00b76dd14c590ce' });
	    }
	    get host() { return validateProps.getElement(this); }
	};

	const flexItemWidths = {
	    none: 0,
	    'one-quarter': 25,
	    'one-third': 33.333333,
	    half: 50,
	    'two-thirds': 66.666667,
	    'three-quarters': 75,
	    full: 100,
	    auto: 'auto',
	};
	const getComponentCss = (width, offset, alignSelf, grow, shrink, flex) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': validateProps.addImportantToEachRule({
	                boxSizing: 'border-box',
	                ...colorSchemeStyles.hostHiddenStyles,
	                ...validateProps.mergeDeep(validateProps.buildResponsiveStyles(width, (widthResponsive) => ({
	                    width: `${flexItemWidths[widthResponsive]}%`,
	                })), validateProps.buildResponsiveStyles(offset, (offsetResponsive) => ({
	                    marginLeft: `${flexItemWidths[offsetResponsive]}%`,
	                })), validateProps.buildResponsiveStyles(alignSelf, (alignSelfResponsive) => ({
	                    alignSelf: alignSelfResponsive,
	                })), flex !== 'initial' // flex shorthand conflicts with grow and shrink, which means even default grow or shrink props would override flex
	                    ? validateProps.buildResponsiveStyles(flex, (flexResponsive) => ({
	                        flex: flexResponsive === 'equal' ? '1 1 0' : flexResponsive,
	                    }))
	                    : validateProps.mergeDeep(validateProps.buildResponsiveStyles(grow, (flexGrow) => ({ flexGrow })), validateProps.buildResponsiveStyles(shrink, (flexShrink) => ({ flexShrink })))),
	            }),
	        },
	    });
	};

	const FLEX_ITEM_WIDTHS = [
	    'auto',
	    'one-quarter',
	    'one-third',
	    'half',
	    'two-thirds',
	    'three-quarters',
	    'full',
	];
	const FLEX_ITEM_OFFSETS = ['none', 'one-quarter', 'one-third', 'half', 'two-thirds', 'three-quarters'];
	const FLEX_ITEM_ALIGN_SELFS = ['auto', 'flex-start', 'flex-end', 'center', 'baseline', 'stretch'];
	const FLEX_ITEM_GROWS = [0, 1];
	const FLEX_ITEM_SHRINKS = [0, 1];
	const FLEX_ITEM_FLEXS = ['initial', 'auto', 'none', 'equal'];

	const propTypes = {
	    width: validateProps.AllowedTypes.breakpoint(FLEX_ITEM_WIDTHS),
	    offset: validateProps.AllowedTypes.breakpoint(FLEX_ITEM_OFFSETS),
	    alignSelf: validateProps.AllowedTypes.breakpoint(FLEX_ITEM_ALIGN_SELFS),
	    grow: validateProps.AllowedTypes.breakpoint(FLEX_ITEM_GROWS),
	    shrink: validateProps.AllowedTypes.breakpoint(FLEX_ITEM_SHRINKS),
	    flex: validateProps.AllowedTypes.breakpoint(FLEX_ITEM_FLEXS),
	};
	const FlexItem = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.width = 'auto';
	        this.offset = 'none';
	        this.alignSelf = 'auto';
	        this.grow = 0;
	        this.shrink = 1;
	        this.flex = 'initial';
	    }
	    connectedCallback() {
	        throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-flex');
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedComponentIsUsed.warnIfDeprecatedComponentIsUsed(this.host, deprecatedFlexComponentMessage);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.width, this.offset, this.alignSelf, this.grow, this.shrink, this.flex);
	        return validateProps.h("slot", { key: '2d535f4eb8863f2ff43e3207dce2aa72cb55d1ef' });
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pFlex_2_cjs_entry.p_flex = Flex;
	pFlex_2_cjs_entry.p_flex_item = FlexItem;

	
	return pFlex_2_cjs_entry;
}

var pFlyoutNavigation_2_cjs_entry = {};

var spacingFluidXSmall0dd753ae = {};

var hasRequiredSpacingFluidXSmall0dd753ae;

function requireSpacingFluidXSmall0dd753ae () {
	if (hasRequiredSpacingFluidXSmall0dd753ae) return spacingFluidXSmall0dd753ae;
	hasRequiredSpacingFluidXSmall0dd753ae = 1;

	const spacingFluidXSmall = 'clamp(4px, 0.25vw + 3px, 8px)';

	spacingFluidXSmall0dd753ae.spacingFluidXSmall = spacingFluidXSmall;

	
	return spacingFluidXSmall0dd753ae;
}

var setScrollLock68edfbd1 = {};

var hasRequiredSetScrollLock68edfbd1;

function requireSetScrollLock68edfbd1 () {
	if (hasRequiredSetScrollLock68edfbd1) return setScrollLock68edfbd1;
	hasRequiredSetScrollLock68edfbd1 = 1;

	const setScrollLock = (isOpen) => {
	    // This doesn't work reliably in iOS Safari with collapsed address bar where body is still scrollable
	    // there are libraries like `body-scroll-lock` and `body-scroll-lock-upgrade` which advertise to handle it, but they
	    // rely on event manipulation and also don't work reliable
	    // https://github.com/willmcpo/body-scroll-lock/blob/master/src/bodyScrollLock.js
	    // https://github.com/rick-liruixin/body-scroll-lock-upgrade/blob/develop/src/body-scroll-lock.ts
	    // Since solutions where the html and body nodes are manipulated can cause all kinds of other problems, we keep this simple solution for now
	    document.body.style.overflow = isOpen ? 'hidden' : '';
	};

	setScrollLock68edfbd1.setScrollLock = setScrollLock;

	
	return setScrollLock68edfbd1;
}

var hasRequiredPFlyoutNavigation_2_cjs_entry;

function requirePFlyoutNavigation_2_cjs_entry () {
	if (hasRequiredPFlyoutNavigation_2_cjs_entry) return pFlyoutNavigation_2_cjs_entry;
	hasRequiredPFlyoutNavigation_2_cjs_entry = 1;

	Object.defineProperty(pFlyoutNavigation_2_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const constants = requireConstantsCa271244();
	const flyoutDialogResetStyles = requireFlyoutDialogResetStylesA29edb86();
	const spacingFluidXSmall = requireSpacingFluidXSmall0dd753ae();
	const spacingFluidSmall = requireSpacingFluidSmall2c6caae7();
	const spacingFluidLarge = requireSpacingFluidLarge6087a0f7();
	const spacingFluidMedium = requireSpacingFluidMedium88ab712b();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const setScrollLock = requireSetScrollLock68edfbd1();
	const theme = requireThemeBfc10573();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const headingSmallStyle = requireHeadingSmallStyle0707b97f();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const dropShadowHighStyle = requireDropShadowHighStyle7edcadc6();
	const headingMediumStyle = requireHeadingMediumStyle1c9f0c45();
	const throwIfParentIsNotOfKind = requireThrowIfParentIsNotOfKindEb817ad3();
	requireHeadingSharedAa59e66d();
	requireFontLineHeight78b03658();
	requireFontWeightSemiBold4482c830();
	requireFontVariant6ba3b7cb();
	requireFontSizeHeadingSmallA15141a5();
	requireFontSizeTextSmall508930e5();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireDropShadowShared6e50faf3();
	requireFontSizeHeadingMediumC49ab5a2();
	requireFontSizeTextMedium88887ad8();
	requireIsParentOfKindB7d9f81c();

	const getDirectChildHTMLElementOfKind = (element, tagName) => {
	    const children = Array.from(element.children);
	    const prefixedElementTagName = validateProps.getPrefixedTagNames(element)[validateProps.paramCaseToCamelCase(tagName)];
	    return Array.from(children).filter((el) => validateProps.getTagName(el) === prefixedElementTagName);
	};

	const FLYOUT_NAVIGATION_ARIA_ATTRIBUTES = ['aria-label'];
	const INTERNAL_UPDATE_EVENT_NAME = 'internalUpdate';
	const syncFlyoutNavigationItemsProps = (items, activeIdentifier, theme) => {
	    items.forEach((item) => {
	        item.theme = theme;
	        item.open = item.identifier === activeIdentifier;
	        validateProps.forceUpdate(item);
	    });
	};
	const validateActiveIdentifier = (instance, items, activeIdentifier) => {
	    if (activeIdentifier !== undefined) {
	        const matchingItems = items.filter((item) => item.identifier === activeIdentifier);
	        if (matchingItems.length === 0) {
	            logInvalidIdentifierError(instance, activeIdentifier);
	        }
	        else if (matchingItems.length > 1) {
	            logMultipleIdentifierError(instance, activeIdentifier, matchingItems);
	        }
	    }
	};
	const logInvalidIdentifierError = (instance, activeIdentifier) => validateProps.consoleError(`Invalid value '${activeIdentifier}' supplied to ${validateProps.getTagNameWithoutPrefix(instance.host)} for property 'activeIdentifier' because reference is not present.`);
	const logMultipleIdentifierError = (instance, activeIdentifier, matchingItems) => validateProps.consoleError(`Found multiple matching items for value '${activeIdentifier}' supplied to ${validateProps.getTagNameWithoutPrefix(instance.host)}:`, ...matchingItems);

	const cssVariableVisibility = '--p-internal-flyout-navigation-visibility';
	const cssVariableVisibilityTransitionDuration = '--p-internal-flyout-navigation-visibility-transition-duration';
	const frostedGlassHeaderHeight = '4rem';
	const frostedGlassBackgroundColorLight$1 = 'rgba(255, 255, 255, 0.79)';
	const frostedGlassBackgroundColorDark$1 = 'rgba(14, 14, 18, 0.79)';
	const scrollerWidthEnhancedView = 'clamp(338px, 10.52vw + 258px, 460px)';
	const mediaQueryEnhancedView = validateProps.getMediaQueryMin('s');
	const getComponentCss$1 = (isPrimaryScrollerVisible, isSecondaryScrollerVisible, theme) => {
	    const { backgroundColor } = validateProps.getThemedColors(theme);
	    const { backgroundColor: backgroundColorDark } = validateProps.getThemedColors('dark');
	    const frostedGlassBackgroundColor = validateProps.isThemeDark(theme)
	        ? frostedGlassBackgroundColorDark$1
	        : frostedGlassBackgroundColorLight$1;
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...(!isPrimaryScrollerVisible && {
	                        [cssVariableVisibility]: 'hidden',
	                        [cssVariableVisibilityTransitionDuration]: validateProps.motionDurationLong,
	                    }),
	                    ...validateProps.getBackdropJssStyle(isPrimaryScrollerVisible, constants.FLYOUT_Z_INDEX, theme),
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            dialog: {
	                ...flyoutDialogResetStyles.getFlyoutDialogResetJssStyle(),
	                inset: '0',
	                display: 'grid',
	                overflow: 'hidden',
	                width: 'auto',
	                maxWidth: '100vw',
	                background: 'none',
	                ...(isPrimaryScrollerVisible
	                    ? {
	                        transform: 'translate3d(0, 0, 0)',
	                        transition: `${validateProps.getTransition('transform', 'long', 'in')}`,
	                    }
	                    : {
	                        transform: 'translate3d(-100%, 0, 0)',
	                        transition: `${validateProps.getTransition('transform', 'long', 'out')}`,
	                    }),
	                [mediaQueryEnhancedView]: {
	                    gridTemplateColumns: `repeat(${isSecondaryScrollerVisible ? 2 : 1}, ${scrollerWidthEnhancedView}) auto`,
	                    gridTemplateRows: '100vh',
	                    insetInlineEnd: 'auto', // to have correct dialog dimensions for ideal transitions
	                },
	                '&:dir(rtl)': {
	                    ...(!isPrimaryScrollerVisible && {
	                        transform: 'translate3d(100%, 0, 0)', // use correct transitions in rtl mode
	                    }),
	                },
	                '&::backdrop': {
	                    // to improve browser backwards compatibility we visually style the backdrop on the :host,
	                    // although it's not on the #top-layer like it would be for modern browsers supporting ::backdrop
	                    opacity: 0, // to support backdrop click for modern browsers supporting ::backdrop
	                },
	            },
	        },
	        scroller: {
	            gridArea: '1/1',
	            overflow: 'auto',
	            // cssVariableVisibility ensures secondary scroller is not tabbable when whole flyout-navigation is closed
	            // on mobile we need to decide if secondary scroller needs to be visible or not, on desktop it's not necessary but also doesn't harm
	            visibility: `var(${cssVariableVisibility},${isSecondaryScrollerVisible ? 'hidden' : 'inherit'})`,
	            transition: `${validateProps.getTransition('left', 'long', isSecondaryScrollerVisible ? 'in' : 'out')}, visibility 0s linear var(${validateProps.cssVariableTransitionDuration}, ${!isPrimaryScrollerVisible || isSecondaryScrollerVisible ? validateProps.motionDurationLong : '0s'})`,
	            // it's important to define background-color for each scroller to have correct scrollbar coloring
	            backgroundColor,
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                backgroundColor: backgroundColorDark,
	            }),
	            [mediaQueryEnhancedView]: {
	                visibility: 'inherit',
	                transition: 'initial',
	            },
	            // simulates frosted glass header, to be visually in sync with header of secondary scroller
	            '&::before': {
	                content: '""',
	                display: 'block',
	                position: 'sticky',
	                top: 0,
	                zIndex: 1,
	                height: frostedGlassHeaderHeight,
	                backgroundColor: frostedGlassBackgroundColor,
	                WebkitBackdropFilter: 'blur(8px)',
	                backdropFilter: 'blur(8px)', // with current frostedGlassStyle of blur(32px) scrolling becomes visually distracting
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    backgroundColor: frostedGlassBackgroundColorDark$1,
	                }),
	                [mediaQueryEnhancedView]: {
	                    display: 'none',
	                },
	            },
	        },
	        content: {
	            display: 'flex',
	            flexDirection: 'column',
	            gap: spacingFluidXSmall.spacingFluidXSmall,
	            padding: `${spacingFluidSmall.spacingFluidSmall} ${spacingFluidLarge.spacingFluidLarge} ${spacingFluidLarge.spacingFluidLarge}`,
	            [mediaQueryEnhancedView]: {
	                padding: `${spacingFluidMedium.spacingFluidMedium} ${spacingFluidLarge.spacingFluidLarge} ${spacingFluidLarge.spacingFluidLarge}`,
	            },
	        },
	        // header is needed to keep position of dismiss button in sync with header of secondary scroller
	        header: {
	            position: 'relative',
	            zIndex: 3, // ensures dismiss button is visible on secondary drawer in mobile view
	            gridArea: '1/1',
	            alignSelf: 'flex-start',
	            justifySelf: 'flex-end',
	            marginInlineEnd: `calc(${spacingFluidLarge.spacingFluidLarge} - ${spacingFluidSmall.spacingFluidSmall})`,
	            height: frostedGlassHeaderHeight,
	            display: 'flex',
	            alignItems: 'center',
	            [mediaQueryEnhancedView]: {
	                marginInlineEnd: 0,
	                gridArea: '1/-1',
	                placeSelf: 'flex-start',
	            },
	        },
	        dismiss: {
	            padding: spacingFluidSmall.spacingFluidSmall,
	            [mediaQueryEnhancedView]: {
	                '--p-internal-icon-filter': 'invert(1)',
	                margin: spacingFluidSmall.spacingFluidSmall,
	                padding: spacingStaticSmall.spacingStaticSmall,
	            },
	        },
	    });
	};
	const getContentJssStyle = () => {
	    return {
	        display: 'flex',
	        flexDirection: 'column',
	        gap: spacingFluidXSmall.spacingFluidXSmall,
	        padding: `${spacingFluidSmall.spacingFluidSmall} ${spacingFluidLarge.spacingFluidLarge} ${spacingFluidLarge.spacingFluidLarge}`,
	        [mediaQueryEnhancedView]: {
	            padding: `${spacingFluidMedium.spacingFluidMedium} ${spacingFluidLarge.spacingFluidLarge} ${spacingFluidLarge.spacingFluidLarge}`,
	        },
	    };
	};

	const propTypes$1 = {
	    activeIdentifier: validateProps.AllowedTypes.string,
	    open: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    aria: validateProps.AllowedTypes.aria(FLYOUT_NAVIGATION_ARIA_ATTRIBUTES),
	};
	const FlyoutNavigation = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.dismiss = validateProps.createEvent(this, "dismiss", 3);
	        this.update = validateProps.createEvent(this, "update", 3);
	        this.defineFlyoutNavigationItemElements = () => {
	            this.flyoutNavigationItemElements = getDirectChildHTMLElementOfKind(this.host, 'p-flyout-navigation-item');
	        };
	        this.onClickDialog = (e) => {
	            if (e.target.tagName === 'DIALOG') {
	                // dismiss dialog when clicked on backdrop
	                this.dismissDialog();
	            }
	        };
	        this.onCancelDialog = (e) => {
	            // prevent closing the dialog uncontrolled by ESC (only relevant for browsers supporting <dialog/>)
	            e.preventDefault();
	            this.dismissDialog();
	        };
	        this.dismissDialog = () => {
	            this.dismiss.emit();
	        };
	        this.open = false;
	        this.activeIdentifier = undefined;
	        this.theme = 'light';
	        this.aria = undefined;
	        this.flyoutNavigationItemElements = [];
	    }
	    openChangeHandler(isOpen) {
	        setScrollLock.setScrollLock(isOpen);
	    }
	    componentWillLoad() {
	        this.defineFlyoutNavigationItemElements();
	        this.host.shadowRoot.addEventListener(INTERNAL_UPDATE_EVENT_NAME, (e) => {
	            e.stopPropagation(); // prevents internal event from bubbling further
	            const activeIdentifier = e.detail.activeIdentifier;
	            this.update.emit({ activeIdentifier });
	        });
	    }
	    componentDidLoad() {
	        if (this.open) {
	            setScrollLock.setScrollLock(true);
	            this.setDialogVisibility(true);
	        }
	        validateProps.getShadowRootHTMLElement(this.host, 'slot').addEventListener('slotchange', this.defineFlyoutNavigationItemElements);
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    disconnectedCallback() {
	        setScrollLock.setScrollLock(false);
	    }
	    componentDidRender() {
	        // showModal needs to be called after render cycle to prepare visibility states of dialog in order to focus the dismiss button correctly
	        this.setDialogVisibility(this.open);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes$1);
	        validateActiveIdentifier(this, this.flyoutNavigationItemElements, this.activeIdentifier);
	        validateProps.attachComponentCss(this.host, getComponentCss$1, this.open, !!this.activeIdentifier, this.theme);
	        syncFlyoutNavigationItemsProps(this.flyoutNavigationItemElements, this.activeIdentifier, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h("dialog", { key: 'c29f18b90e7478bb177b3b98f5a1e090cbb4ae25', inert: this.open ? null : true, tabIndex: -1, ref: (ref) => (this.dialog = ref), onCancel: this.onCancelDialog, onClick: this.onClickDialog }, validateProps.h("div", { key: '7c377859b2946e1cf5930d7afd510c7bbae13625', class: "header" }, validateProps.h(PrefixedTagNames.pButtonPure, { key: 'a5504a37ad6b767d0e7c652f6ccb03e5689d836e', class: "dismiss", type: "button", size: "medium", icon: "close", hideLabel: true, theme: this.theme, onClick: this.dismissDialog }, "Dismiss flyout")), validateProps.h("div", { key: '14680eb6da8b1099c2ab124707849149ae237b72', class: "scroller" }, validateProps.h("nav", { key: 'c38712120b20886492d98c674c146e656645b645', class: "content", ...validateProps.parseAndGetAriaAttributes(this.aria) }, validateProps.h("slot", { key: '511ea9273f030de9719ad63659a78312d63d3e12' })))));
	    }
	    setDialogVisibility(isOpen) {
	        // TODO: SupportsNativeDialog check
	        // Only call showModal/close on dialog when state changes
	        if (isOpen === true && !this.dialog.open) {
	            this.dialog.showModal();
	        }
	        else if (isOpen === false && this.dialog.open) {
	            this.dialog.close();
	        }
	    }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "open": ["openChangeHandler"]
	    }; }
	};

	const frostedGlassBackgroundColorLight = 'rgba(238, 239, 242, 0.79)';
	const frostedGlassBackgroundColorDark = 'rgba(33, 34, 37, 0.79)';
	const getComponentCss = (isSecondaryScrollerVisible, theme) => {
	    const { primaryColor, backgroundSurfaceColor, hoverColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, backgroundSurfaceColor: backgroundSurfaceColorDark, hoverColor: hoverColorDark, } = validateProps.getThemedColors('dark');
	    const frostedGlassBackgroundColor = validateProps.isThemeDark(theme)
	        ? frostedGlassBackgroundColorDark
	        : frostedGlassBackgroundColorLight;
	    const fadeInOutTransition = isSecondaryScrollerVisible
	        ? {
	            opacity: 1,
	            transition: `${validateProps.getTransition('opacity', 'veryLong', 'in', 'short')}`,
	            [mediaQueryEnhancedView]: {
	                transition: `${validateProps.getTransition('opacity', 'veryLong', 'in')}`,
	            },
	        }
	        : {
	            opacity: 0,
	            transition: `${validateProps.getTransition('opacity', 'short', 'out')}`,
	        };
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            '::slotted(:is(h1, h2, h3, h4, h5, h6))': validateProps.addImportantToEachRule({
	                ...headingSmallStyle.headingSmallStyle,
	                margin: 0,
	                color: primaryColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: primaryColorDark,
	                }),
	            }),
	            '::slotted(:is(h1, h2, h3, h4, h5, h6):not(:first-child))': validateProps.addImportantToEachRule({
	                margin: `calc(${spacingFluidMedium.spacingFluidMedium} - ${spacingFluidXSmall.spacingFluidXSmall}) 0 0`, // spacingFluidXSmall to compensate default gap
	            }),
	            '::slotted': validateProps.addImportantToEachRule({
	                '&(p)': {
	                    ...textSmallStyle.textSmallStyle,
	                    margin: 0,
	                    color: primaryColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        color: primaryColorDark,
	                    }),
	                },
	                '&(a)': {
	                    ...{
	                        ...textSmallStyle.textSmallStyle,
	                        alignSelf: 'flex-start',
	                        display: 'block',
	                        textDecoration: 'none',
	                        cursor: 'pointer',
	                        color: primaryColor,
	                        borderRadius: borderRadiusSmall.borderRadiusSmall,
	                        marginLeft: `-${spacingStaticXSmall.spacingStaticXSmall}`,
	                        marginRight: `-${spacingStaticXSmall.spacingStaticXSmall}`,
	                        padding: `2px ${spacingStaticXSmall.spacingStaticXSmall}`,
	                        transition: `background var(${validateProps.cssVariableTransitionDuration}, ${validateProps.motionDurationShort}) ${validateProps.motionEasingBase}`,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            color: primaryColorDark,
	                        }),
	                    },
	                },
	                '&(a[aria-current])': {
	                    background: hoverColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        background: hoverColorDark,
	                    }),
	                },
	                ...hoverMediaQuery.hoverMediaQuery({
	                    // TODO: how can we easily re-use getHoverStyle() with ::slotted(a) selector?
	                    '&(a:hover)': {
	                        background: hoverColor,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            background: hoverColorDark,
	                        }),
	                    },
	                }),
	                ...validateProps.getFocusJssStyle(theme, { slotted: 'a', offset: '-2px' }),
	            }),
	        },
	        button: {
	            width: 'auto',
	            padding: spacingFluidSmall.spacingFluidSmall,
	            margin: `0 calc(${spacingFluidSmall.spacingFluidSmall} * -1)`,
	        },
	        scroller: {
	            position: 'fixed',
	            inset: 0,
	            // "cssVariableTransitionDuration" ensures closing animation of secondary scroller is given when whole flyout-navigation gets closed
	            // "cssVariableVisibility" ensures secondary scroller is not tabbable when whole flyout-navigation is closed
	            ...(isSecondaryScrollerVisible
	                ? {
	                    zIndex: 2,
	                    transform: 'translate3d(0, 0, 0)',
	                    // TODO: Should be visibility: inherit to allow overwriting but currently not possible since it would inherit from the scroller of the p-flyout-navigation itself, which is hidden on mobile
	                    visibility: `var(${cssVariableVisibility},visible)`,
	                    transition: `${validateProps.getTransition('transform', 'long', 'in')}, visibility 0s linear var(${validateProps.cssVariableTransitionDuration},var(${cssVariableVisibilityTransitionDuration},0s))`,
	                }
	                : {
	                    zIndex: 1,
	                    transform: 'translate3d(100%, 0, 0)',
	                    visibility: `var(${cssVariableVisibility},hidden)`,
	                    transition: `${validateProps.getTransition('transform', 'long', 'out')}, visibility 0s linear var(${validateProps.cssVariableTransitionDuration},var(${cssVariableVisibilityTransitionDuration},${validateProps.motionDurationLong}))`,
	                }),
	            width: '100vw',
	            boxSizing: 'border-box',
	            overflow: 'auto',
	            ...dropShadowHighStyle.dropShadowHighStyle,
	            // it's important to define background-color for each scroller to have correct scrollbar coloring
	            backgroundColor: backgroundSurfaceColor,
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                backgroundColor: backgroundSurfaceColorDark,
	            }),
	            [mediaQueryEnhancedView]: {
	                boxShadow: 'none',
	                insetInlineStart: `calc(${scrollerWidthEnhancedView} - 1px)`, // -1px prevents possible visible background under certain circumstances between primary and secondary scroller
	                width: scrollerWidthEnhancedView,
	                transform: validateProps.addImportantToRule('initial'), // to overrule :dir(rtl) selector
	                transition: `visibility 0s linear var(${validateProps.cssVariableTransitionDuration},var(${cssVariableVisibilityTransitionDuration},0s))`,
	            },
	            '&:dir(rtl)': {
	                ...(!isSecondaryScrollerVisible && {
	                    transform: 'translate3d(-100%, 0, 0)', // use correct transitions in rtl mode for mobile view
	                }),
	            },
	        },
	        // header needs to be placed within scroller to ensure scrollbars are fully visible
	        header: {
	            position: 'sticky',
	            top: 0,
	            zIndex: 1,
	            height: frostedGlassHeaderHeight,
	            padding: `0 ${spacingFluidLarge.spacingFluidLarge}`,
	            display: 'grid',
	            gridTemplateColumns: '4rem minmax(0, 1fr) 4rem',
	            alignItems: 'center',
	            gap: spacingFluidSmall.spacingFluidSmall,
	            WebkitBackdropFilter: 'blur(8px)',
	            backdropFilter: 'blur(8px)', // with current frostedGlassStyle of blur(32px) scrolling becomes visually distracting
	            backgroundColor: frostedGlassBackgroundColor,
	            ...fadeInOutTransition,
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                backgroundColor: frostedGlassBackgroundColorDark,
	            }),
	            [mediaQueryEnhancedView]: {
	                display: 'none',
	            },
	        },
	        back: {
	            justifySelf: 'flex-start',
	            padding: spacingFluidSmall.spacingFluidSmall,
	            marginInlineStart: `calc(${spacingFluidSmall.spacingFluidSmall} * -1)`,
	        },
	        heading: {
	            ...headingMediumStyle.headingMediumStyle,
	            margin: 0,
	            padding: 0,
	            overflow: 'hidden',
	            textAlign: 'center',
	            whiteSpace: 'nowrap',
	            textOverflow: 'ellipsis',
	            color: primaryColor,
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                color: primaryColorDark,
	            }),
	        },
	        content: validateProps.mergeDeep(getContentJssStyle(), fadeInOutTransition),
	    });
	};

	const propTypes = {
	    identifier: validateProps.AllowedTypes.string,
	    label: validateProps.AllowedTypes.string,
	};
	const FlyoutNavigationItem = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.onClickButton = (activeIdentifier) => {
	            this.host.dispatchEvent(new CustomEvent(INTERNAL_UPDATE_EVENT_NAME, {
	                bubbles: true,
	                detail: { activeIdentifier },
	            }));
	        };
	        this.label = undefined;
	        this.identifier = undefined;
	    }
	    get theme() {
	        return this.host.theme || 'light'; // default as fallback (internal private prop is controlled by flyout-navigation)
	    }
	    get open() {
	        return this.host.open || false; // default as fallback (internal private prop is controlled by flyout-navigation)
	    }
	    connectedCallback() {
	        throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-flyout-navigation');
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.open, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(validateProps.Host, { key: '3ab0c13961898186db0dec1ebc23cde2d79c9fc0' }, validateProps.h(PrefixedTagNames.pButtonPure, { key: '7c444a38f82b72f5288d62438ff7c8509b874aa4', class: "button", type: "button", size: "medium", alignLabel: "start", stretch: true, icon: "arrow-head-right", active: this.open, aria: { 'aria-expanded': this.open }, theme: this.theme, onClick: () => this.onClickButton(this.open ? undefined : this.identifier) }, this.label), validateProps.h("div", { key: '0da5400e264227c6679331b7faa7c533b8c568de', class: "scroller", inert: this.open ? null : true }, validateProps.h("div", { key: '26d9d44d2f954502041744e77cfe31b0727e2423', class: "header" }, validateProps.h(PrefixedTagNames.pButtonPure, { key: '236d4b34661fef08f3a233d2d9546cac1780843f', class: "back", type: "button", size: "medium", icon: "arrow-head-left", hideLabel: true, theme: this.theme, onClick: () => this.onClickButton(undefined) }, "Back"), validateProps.h("h2", { key: '84906319d86c9471d2e3f5a0de5d1642a13b9728', class: "heading" }, this.label)), validateProps.h("div", { key: '9a5570972aaea21edf3c56bbe9645c3473bc2ee2', class: "content" }, validateProps.h("slot", { key: 'b0b29bb908a08bdff3e24d98cf245355571a5c1c' })))));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pFlyoutNavigation_2_cjs_entry.p_flyout_navigation = FlyoutNavigation;
	pFlyoutNavigation_2_cjs_entry.p_flyout_navigation_item = FlyoutNavigationItem;

	
	return pFlyoutNavigation_2_cjs_entry;
}

var pFlyout_cjs_entry = {};

var hasRequiredPFlyout_cjs_entry;

function requirePFlyout_cjs_entry () {
	if (hasRequiredPFlyout_cjs_entry) return pFlyout_cjs_entry;
	hasRequiredPFlyout_cjs_entry = 1;

	Object.defineProperty(pFlyout_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const modalFlyoutUtils = requireModalFlyoutUtils950041a2();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const constants = requireConstantsCa271244();
	const flyoutDialogResetStyles = requireFlyoutDialogResetStylesA29edb86();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();
	const spacingFluidLarge = requireSpacingFluidLarge6087a0f7();
	const gridGap = requireGridGapB5b73e4a();
	const hasNamedSlot = requireHasNamedSlotA96fd22a();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed2d6d1d94();
	const setScrollLock = requireSetScrollLock68edfbd1();
	const theme = requireThemeBfc10573();
	requireGetHTMLElements3f1c700f();
	requireSpacingFluidMedium88ab712b();
	requireGetNamedSlotA0cdbdbc();
	requireHelperA66adcf2();

	// 'left' is deprecated and will be mapped to 'start'
	// 'right' is deprecated and will be mapped to 'end'
	/** @deprecated */
	const FLYOUT_POSITIONS_DEPRECATED = ['left', 'right'];
	const FLYOUT_POSITIONS = ['start', 'end', ...FLYOUT_POSITIONS_DEPRECATED];
	const FLYOUT_ARIA_ATTRIBUTES = ['aria-label'];
	// Threshold value to determine the scroll offset at which the shadow should be visible in the flyout
	const FLYOUT_SCROLL_SHADOW_THRESHOLD = 10;

	const headerShadowClass = 'header--shadow';
	const footerShadowClass = 'footer--shadow';
	const getComponentCss = (isOpen, position, hasFooter, hasSubFooter, theme) => {
	    const { primaryColor, backgroundColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, backgroundColor: backgroundColorDark } = validateProps.getThemedColors('dark');
	    const isPositionStart = position === 'start';
	    const contentPadding = `${spacingStaticMedium.spacingStaticMedium} ${spacingFluidLarge.spacingFluidLarge}`;
	    const isDark = validateProps.isThemeDark(theme);
	    const shadowColor = isDark ? modalFlyoutUtils.scrollShadowColorDark : modalFlyoutUtils.scrollShadowColor;
	    const transparentColorDark = 'rgba(14, 14, 18, 0)';
	    const transparentColor = isDark ? transparentColorDark : 'rgba(255, 255, 255, 0)';
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    // needed for correct alignment of the Porsche Grid within the Flyout
	                    '--pds-internal-grid-outer-column': `calc(${spacingFluidLarge.spacingFluidLarge} - ${gridGap.gridGap})`,
	                    '--pds-internal-grid-margin': `calc(${spacingFluidLarge.spacingFluidLarge} * -1)`,
	                    ...validateProps.getBackdropJssStyle(isOpen, constants.FLYOUT_Z_INDEX, theme),
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            dialog: {
	                ...flyoutDialogResetStyles.getFlyoutDialogResetJssStyle(),
	                insetInline: isPositionStart ? '0 0' : 'auto 0',
	                insetBlock: '0 0',
	                display: 'flex',
	                flexDirection: 'column',
	                boxSizing: 'border-box',
	                width: 'var(--p-flyout-width, fit-content)',
	                minWidth: '320px',
	                maxWidth: 'var(--p-flyout-max-width, 1180px)',
	                color: primaryColor, // enables color inheritance for slotted content
	                background: backgroundColor,
	                ...(isOpen
	                    ? {
	                        opacity: 1,
	                        transform: 'initial',
	                        transition: `${validateProps.getTransition('opacity', 'long', 'in')}, ${validateProps.getTransition('transform', 'long', 'in')}`,
	                    }
	                    : {
	                        opacity: 0,
	                        transform: `translate3d(${isPositionStart ? '-100%' : '100%'}, 0, 0)`,
	                        transition: `${validateProps.getTransition('opacity', 'short', 'out', 'long')}, ${validateProps.getTransition('transform', 'long', 'out')}`,
	                    }),
	                boxShadow: `${isPositionStart ? '3px' : '-3px'} 0px 30px rgba(0, 0, 0, 0.25)`,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: primaryColorDark,
	                    background: backgroundColorDark,
	                }),
	                '&:focus-visible': {
	                    outline: 'none', // ua-style reset
	                },
	                '&::backdrop': {
	                    // to improve browser backwards compatibility we visually style the backdrop on the :host,
	                    // although it's not on the #top-layer like it would be for modern browsers supporting ::backdrop
	                    opacity: 0, // to support backdrop click for modern browsers supporting ::backdrop
	                },
	            },
	        },
	        wrapper: {
	            display: 'flex', // ua-style reset
	            flexGrow: 1,
	            height: 0,
	            flexDirection: 'column',
	            ...(hasSubFooter && {
	                overflowY: 'auto',
	                overscrollBehaviorY: 'none',
	            }),
	        },
	        header: {
	            position: 'sticky',
	            top: 0,
	            zIndex: 2,
	            display: 'grid',
	            gridTemplateColumns: `minmax(0, 1fr) ${spacingFluidLarge.spacingFluidLarge}`,
	            alignItems: 'flex-start',
	            padding: `${spacingStaticMedium.spacingStaticMedium} 0`,
	            paddingInlineStart: spacingFluidLarge.spacingFluidLarge,
	            background: backgroundColor,
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                background: backgroundColorDark,
	            }),
	        },
	        [headerShadowClass]: {
	            boxShadow: `${isDark ? modalFlyoutUtils.scrollShadowColorDark : modalFlyoutUtils.scrollShadowColor} 0px 5px 10px`,
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                boxShadow: `${modalFlyoutUtils.scrollShadowColorDark} 0px 5px 10px`,
	            }),
	        },
	        dismiss: {
	            gridArea: '1 / 2',
	            justifySelf: 'center',
	        },
	        content: {
	            padding: contentPadding,
	            maxWidth: `calc(100vw - calc(${spacingFluidLarge.spacingFluidLarge} * 2))`,
	            position: 'relative',
	            zIndex: 0,
	            backgroundColor, // to ensure scrollbar coloring is optimal for light theme
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                backgroundColor: backgroundColorDark, // to ensure scrollbar coloring is optimal for dark theme
	            }),
	            // If sub-footer is used scroll shadows have to be done via JS
	            ...(!hasSubFooter && {
	                overflowY: 'auto',
	                WebkitOverflowScrolling: 'touch',
	                backgroundImage: `linear-gradient(to top, ${backgroundColor}, ${backgroundColor}), linear-gradient(to top, ${backgroundColor}, ${backgroundColor}), linear-gradient(to top, ${shadowColor}, ${transparentColor}), linear-gradient(to bottom, ${shadowColor}, ${transparentColor})`,
	                backgroundPosition: 'bottom center, top center, bottom center, top center',
	                backgroundRepeat: 'no-repeat',
	                backgroundSize: '100% 20px, 100% 20px, 100% 10px, 100% 10px',
	                backgroundAttachment: 'local, local, scroll, scroll',
	                overscrollBehaviorY: 'none',
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    backgroundImage: `linear-gradient(to top, ${backgroundColorDark}, ${backgroundColorDark}), linear-gradient(to top, ${backgroundColorDark}, ${backgroundColorDark}), linear-gradient(to top, ${modalFlyoutUtils.scrollShadowColorDark}, ${transparentColorDark}), linear-gradient(to bottom, ${modalFlyoutUtils.scrollShadowColorDark}, ${transparentColorDark})`,
	                    backgroundColor: backgroundColorDark, // to ensure scrollbar coloring is optimal for dark theme
	                }),
	            }),
	        },
	        ...(hasFooter && {
	            footer: {
	                position: 'sticky',
	                bottom: 0,
	                zIndex: 1,
	                padding: contentPadding,
	                background: backgroundColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    background: backgroundColorDark,
	                }),
	            },
	            [footerShadowClass]: {
	                boxShadow: `${isDark ? modalFlyoutUtils.scrollShadowColorDark : modalFlyoutUtils.scrollShadowColor} 0px -5px 10px`,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    boxShadow: `${modalFlyoutUtils.scrollShadowColorDark} 0px -5px 10px`,
	                }),
	            },
	        }),
	        ...(hasSubFooter && {
	            'sub-footer': {
	                padding: contentPadding,
	            },
	        }),
	    });
	};

	const propTypes = {
	    open: validateProps.AllowedTypes.boolean,
	    position: validateProps.AllowedTypes.oneOf(FLYOUT_POSITIONS),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    aria: validateProps.AllowedTypes.aria(FLYOUT_ARIA_ATTRIBUTES),
	};
	const Flyout = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.dismiss = validateProps.createEvent(this, "dismiss", 3);
	        this.updateHeaderShadow = () => {
	            const shouldApplyShadow = this.wrapper.scrollTop > FLYOUT_SCROLL_SHADOW_THRESHOLD;
	            this.header.classList.toggle(headerShadowClass, shouldApplyShadow);
	        };
	        this.updateFooterShadow = () => {
	            const shouldApplyShadow = this.subFooter.offsetTop > this.wrapper.clientHeight + this.wrapper.scrollTop;
	            this.footer.classList.toggle(footerShadowClass, shouldApplyShadow);
	        };
	        // eslint-disable-next-line @typescript-eslint/member-ordering
	        this.updateShadow = validateProps.throttle(100, () => {
	            if (this.wrapper.scrollHeight > this.wrapper.clientHeight) {
	                this.updateHeaderShadow();
	                if (this.hasFooter) {
	                    this.updateFooterShadow();
	                }
	            }
	        });
	        this.onClickDialog = (e) => {
	            if (e.target.tagName === 'DIALOG') {
	                // dismiss dialog when clicked on backdrop
	                this.dismissDialog();
	            }
	        };
	        this.onSlotChange = () => {
	            validateProps.forceUpdate(this.host);
	            this.dismissBtn.focus();
	        };
	        this.onCancelDialog = (e) => {
	            // prevent closing the dialog uncontrolled by ESC (only relevant for browsers supporting <dialog/>)
	            e.preventDefault();
	            this.dismissDialog();
	        };
	        this.dismissDialog = () => {
	            this.dismiss.emit();
	        };
	        this.open = false;
	        this.position = 'end';
	        this.theme = 'light';
	        this.aria = undefined;
	    }
	    openChangeHandler(isOpen) {
	        setScrollLock.setScrollLock(isOpen);
	        if (isOpen && this.hasSubFooter) {
	            this.updateShadow();
	        }
	    }
	    componentDidLoad() {
	        // in case flyout is rendered with open prop
	        if (this.open) {
	            setScrollLock.setScrollLock(true);
	        }
	        // TODO: would be great to use this in jsx but that doesn't work reliable and causes focus e2e test to fail
	        modalFlyoutUtils.getShadowRootHTMLElements(this.host, 'slot').forEach((element) => element.addEventListener('slotchange', this.onSlotChange));
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    componentDidRender() {
	        // showModal needs to be called after render cycle to prepare visibility states of dialog in order to focus the dismiss button correctly
	        this.setDialogVisibility(this.open);
	        // TODO: should this really be executed on every rerender, e.g. prop change?
	        if (this.open && this.hasSubFooter) {
	            // TODO: why not scroll to top when opened just like modal does?
	            this.updateShadow();
	        }
	    }
	    disconnectedCallback() {
	        setScrollLock.setScrollLock(false);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        const positionDeprecationMap = {
	            left: 'start',
	            right: 'end',
	        };
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'position', positionDeprecationMap);
	        this.hasHeader = hasNamedSlot.hasNamedSlot(this.host, 'header');
	        this.hasFooter = hasNamedSlot.hasNamedSlot(this.host, 'footer');
	        this.hasSubFooter = hasNamedSlot.hasNamedSlot(this.host, 'sub-footer');
	        validateProps.attachComponentCss(this.host, getComponentCss, this.open, (positionDeprecationMap[this.position] || this.position), this.hasFooter, this.hasSubFooter, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h("dialog", { key: 'ddbbb8ba5caef1533e673e5586e05398f9b4273f', inert: this.open ? null : true, tabIndex: -1, ref: (ref) => (this.dialog = ref), onCancel: this.onCancelDialog, onClick: this.onClickDialog, ...validateProps.parseAndGetAriaAttributes(this.aria) }, validateProps.h("div", { key: '2605b34c016afb3868fc6e984f422dd86fee968a', class: "wrapper", ref: (ref) => (this.wrapper = ref), ...(this.hasSubFooter && { onScroll: this.updateShadow }) }, validateProps.h("div", { key: "header", class: "header", ref: (el) => (this.header = el) }, validateProps.h(PrefixedTagNames.pButtonPure, { key: '4fea50309541d074d21fc8d39eeb576318363337', class: "dismiss", type: "button", hideLabel: true, icon: "close", theme: this.theme, onClick: this.dismissDialog, ref: (el) => (this.dismissBtn = el) }, "Dismiss flyout"), this.hasHeader && validateProps.h("slot", { name: "header" })), validateProps.h("div", { key: '28cc48d4b4ffd4ec8ee3550df1e943a95cfadeb8', class: "content" }, validateProps.h("slot", { key: 'a8894e22fab5b66139226d741e9d48d323659766' })), this.hasFooter && (validateProps.h("div", { key: "footer", class: "footer", ref: (el) => (this.footer = el) }, validateProps.h("slot", { name: "footer" }))), this.hasSubFooter && (validateProps.h("div", { key: "sub-footer", class: "sub-footer", ref: (el) => (this.subFooter = el) }, validateProps.h("slot", { name: "sub-footer" }))))));
	    }
	    setDialogVisibility(isOpen) {
	        // TODO: SupportsNativeDialog check
	        // Only call showModal/close on dialog when state changes
	        if (isOpen === true && !this.dialog.open) {
	            this.dialog.showModal();
	        }
	        else if (isOpen === false && this.dialog.open) {
	            this.dialog.close();
	        }
	    }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "open": ["openChangeHandler"]
	    }; }
	};

	pFlyout_cjs_entry.p_flyout = Flyout;

	
	return pFlyout_cjs_entry;
}

var pGrid_2_cjs_entry = {};

var hasRequiredPGrid_2_cjs_entry;

function requirePGrid_2_cjs_entry () {
	if (hasRequiredPGrid_2_cjs_entry) return pGrid_2_cjs_entry;
	hasRequiredPGrid_2_cjs_entry = 1;

	Object.defineProperty(pGrid_2_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const gridGap = requireGridGapB5b73e4a();
	const warnIfDeprecatedComponentIsUsed = requireWarnIfDeprecatedComponentIsUsed6c2a81ac();
	const throwIfParentIsNotOfKind = requireThrowIfParentIsNotOfKindEb817ad3();
	requireSpacingFluidMedium88ab712b();
	requireIsParentOfKindB7d9f81c();

	const GRID_DIRECTIONS = ['row', 'row-reverse', 'column', 'column-reverse'];
	const GRID_WRAPS = ['nowrap', 'wrap'];
	const GRID_GUTTERS = [16, 24, 36];
	const deprecatedGridComponentMessage = 'Please use native CSS Grid (https://css-tricks.com/snippets/css/complete-guide-grid) instead in combination with the Porsche Grid utility based on CSS Grid.';

	const gutter$1 = `calc(${gridGap.gridGap} / -2)`;
	const getComponentCss$1 = (direction, wrap) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'flex',
	                ...validateProps.addImportantToEachRule({
	                    flex: 'auto',
	                    width: 'auto',
	                    marginLeft: gutter$1,
	                    marginRight: gutter$1,
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                    ...validateProps.mergeDeep(validateProps.buildResponsiveStyles(direction, (flexDirection) => ({ flexDirection })), validateProps.buildResponsiveStyles(wrap, (flexWrap) => ({ flexWrap }))),
	                }),
	            },
	        },
	    });
	};

	const propTypes$1 = {
	    direction: validateProps.AllowedTypes.breakpoint(GRID_DIRECTIONS),
	    wrap: validateProps.AllowedTypes.breakpoint(GRID_WRAPS),
	    gutter: validateProps.AllowedTypes.breakpoint(GRID_GUTTERS),
	};
	const Grid = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.direction = 'row';
	        this.wrap = 'wrap';
	        this.gutter = { base: 16, s: 24, m: 36 };
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes$1);
	        warnIfDeprecatedComponentIsUsed.warnIfDeprecatedComponentIsUsed(this.host, deprecatedGridComponentMessage);
	        validateProps.attachComponentCss(this.host, getComponentCss$1, this.direction, this.wrap);
	        return validateProps.h("slot", { key: '7fd8480607bfbd2a1fe3357693bc2e2cce4d8ece' });
	    }
	    get host() { return validateProps.getElement(this); }
	};

	const GRID_ITEM_SIZES = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
	const GRID_ITEM_OFFSETS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];

	const gutter = `calc(${gridGap.gridGap} / 2)`;
	const gridItemWidths = [
	    0, 8.333333, 16.666667, 25, 33.333333, 41.666667, 50, 58.333333, 66.666667, 75, 83.333333, 91.666667, 100,
	];
	const getComponentCss = (size, offset) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': validateProps.addImportantToEachRule({
	                paddingLeft: gutter,
	                paddingRight: gutter,
	                boxSizing: 'border-box',
	                ...colorSchemeStyles.hostHiddenStyles,
	                ...validateProps.mergeDeep(validateProps.buildResponsiveStyles(size, (sizeResponsive) => ({
	                    width: `${gridItemWidths[sizeResponsive]}%`,
	                    minWidth: `${gridItemWidths[sizeResponsive]}%`,
	                })), validateProps.buildResponsiveStyles(offset, (offsetResponsive) => ({
	                    marginLeft: `${gridItemWidths[offsetResponsive]}%`,
	                }))),
	            }),
	        },
	    });
	};

	const propTypes = {
	    size: validateProps.AllowedTypes.breakpoint(GRID_ITEM_SIZES),
	    offset: validateProps.AllowedTypes.breakpoint(GRID_ITEM_OFFSETS),
	};
	const GridItem = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.size = 1;
	        this.offset = 0;
	    }
	    connectedCallback() {
	        throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-grid');
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedComponentIsUsed.warnIfDeprecatedComponentIsUsed(this.host, deprecatedGridComponentMessage);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.size, this.offset);
	        return validateProps.h("slot", { key: 'c5f6750c671903b5b4dfbadcd66d20ee0a01d02d' });
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pGrid_2_cjs_entry.p_grid = Grid;
	pGrid_2_cjs_entry.p_grid_item = GridItem;

	
	return pGrid_2_cjs_entry;
}

var pHeading_cjs_entry = {};

var hasRequiredPHeading_cjs_entry;

function requirePHeading_cjs_entry () {
	if (hasRequiredPHeading_cjs_entry) return pHeading_cjs_entry;
	hasRequiredPHeading_cjs_entry = 1;

	Object.defineProperty(pHeading_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const typographyAlign = requireTypographyAlign25ce02f4();
	const headingTag = requireHeadingTag6cfe20fe();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed2d6d1d94();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const typographyStyles = requireTypographyStyles1a447490();
	const fontSizeHeadingSmall = requireFontSizeHeadingSmallA15141a5();
	const fontSizeHeadingMedium = requireFontSizeHeadingMediumC49ab5a2();
	const fontSizeHeadingLarge = requireFontSizeHeadingLargeC355151d();
	const headingXXLargeStyle = requireHeadingXXLargeStyle139a1eb3();
	requireGetDirectChildHTMLElementC5dd1dc2();
	requireTransformSelectorToDirectChildSelectorC1b1f9b0();
	requireHelperA66adcf2();
	requireTextIconStyles990609fb();
	requireFontSizeTextSmall508930e5();
	requireFontSizeTextMedium88887ad8();
	requireFontSizeTextLarge05a4bc90();
	requireFontSizeTextXLarge0ecf9ef3();
	requireHeadingSharedAa59e66d();
	requireFontLineHeight78b03658();
	requireFontWeightSemiBold4482c830();
	requireFontVariant6ba3b7cb();

	const HEADING_SIZES = ['small', 'medium', 'large', 'x-large', 'xx-large', 'inherit'];

	const HEADING_COLORS = ['primary', 'inherit'];
	const headingSizeToTagMap = {
	    small: 'h6',
	    medium: 'h5',
	    large: 'h4',
	    'x-large': 'h3',
	    'xx-large': 'h2',
	    inherit: 'h2',
	};
	const getHeadingTagType = (host, size, tag) => {
	    if (typographyAlign.hasSpecificDirectChildTag(host, headingTag.HEADING_TAGS.join())) {
	        return 'div';
	    }
	    else if (tag) {
	        return tag;
	    }
	    else {
	        return headingSizeToTagMap[size] || 'h2';
	    }
	};

	const sizeMap = {
	    small: fontSizeHeadingSmall.fontSizeHeadingSmall,
	    medium: fontSizeHeadingMedium.fontSizeHeadingMedium,
	    large: fontSizeHeadingLarge.fontSizeHeadingLarge,
	    'x-large': headingXXLargeStyle.fontSizeHeadingXLarge,
	    'xx-large': headingXXLargeStyle.fontSizeHeadingXXLarge,
	};
	const getComponentCss = (size, align, color, ellipsis, theme) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            [`::slotted(:is(${headingTag.HEADING_TAGS.join()}))`]: validateProps.addImportantToEachRule(typographyStyles.getTypographySlottedJssStyle()),
	        },
	        root: typographyStyles.getTypographyRootJssStyle(headingXXLargeStyle.headingXXLargeStyle, validateProps.buildResponsiveStyles(size, (sizeValue) => ({
	            fontSize: sizeValue === 'inherit' ? sizeValue : sizeMap[sizeValue],
	        })), align, color, ellipsis, theme),
	    });
	};

	const propTypes = {
	    tag: validateProps.AllowedTypes.oneOf([undefined, ...headingTag.HEADING_TAGS]),
	    size: validateProps.AllowedTypes.breakpoint(HEADING_SIZES),
	    align: validateProps.AllowedTypes.oneOf(typographyAlign.TYPOGRAPHY_ALIGNS),
	    color: validateProps.AllowedTypes.oneOf(HEADING_COLORS),
	    ellipsis: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Heading = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.tag = undefined;
	        this.size = 'xx-large';
	        this.align = 'start';
	        this.color = 'primary';
	        this.ellipsis = false;
	        this.theme = 'light';
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        const alignDeprecationMap = {
	            left: 'start',
	            right: 'end',
	        };
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'align', alignDeprecationMap);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.size, (alignDeprecationMap[this.align] || this.align), this.color, this.ellipsis, this.theme);
	        const TagType = getHeadingTagType(this.host, this.size, this.tag);
	        return (validateProps.h(TagType, { key: 'd08c6efd058c462eb103bf4e70af37bcf9f2b033', class: "root" }, validateProps.h("slot", { key: 'ac15c043755daf71645f12ffde4bf9c5e0f09907' })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pHeading_cjs_entry.p_heading = Heading;

	
	return pHeading_cjs_entry;
}

var pHeadline_cjs_entry = {};

var hasRequiredPHeadline_cjs_entry;

function requirePHeadline_cjs_entry () {
	if (hasRequiredPHeadline_cjs_entry) return pHeadline_cjs_entry;
	hasRequiredPHeadline_cjs_entry = 1;

	Object.defineProperty(pHeadline_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const typographyAlign = requireTypographyAlign25ce02f4();
	const warnIfDeprecatedComponentIsUsed = requireWarnIfDeprecatedComponentIsUsed6c2a81ac();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const typographyStyles = requireTypographyStyles1a447490();
	const headingXXLargeStyle = requireHeadingXXLargeStyle139a1eb3();
	const fontSizeHeadingLarge = requireFontSizeHeadingLargeC355151d();
	const fontSizeHeadingMedium = requireFontSizeHeadingMediumC49ab5a2();
	const fontSizeHeadingSmall = requireFontSizeHeadingSmallA15141a5();
	const fontSizeTextXXSmall = requireFontSizeTextXXSmallA02f9c40();
	const fontSizeTextXSmall = requireFontSizeTextXSmallE59d35d7();
	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();
	const fontSizeTextMedium = requireFontSizeTextMedium88887ad8();
	const fontSizeTextLarge = requireFontSizeTextLarge05a4bc90();
	const fontSizeTextXLarge = requireFontSizeTextXLarge0ecf9ef3();
	const displayShared = requireDisplayShared43dd15a5();
	requireGetDirectChildHTMLElementC5dd1dc2();
	requireTransformSelectorToDirectChildSelectorC1b1f9b0();
	requireTextIconStyles990609fb();
	requireHeadingSharedAa59e66d();
	requireFontLineHeight78b03658();
	requireFontWeightSemiBold4482c830();
	requireFontVariant6ba3b7cb();
	requireFontWeightRegularD0c768ac();

	const displayMediumStyle = {
	    font: `${displayShared._displayFontPartA}${displayShared.fontSizeDisplayMedium}${displayShared._displayFontPartB}`,
	};

	const HEADLINE_VARIANTS = [
	    'large-title',
	    'headline-1',
	    'headline-2',
	    'headline-3',
	    'headline-4',
	    'headline-5',
	];
	const HEADLINE_TAGS = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
	const HEADLINE_COLORS = ['primary', 'default', 'inherit'];
	const isValidVariantType = (variant) => {
	    return HEADLINE_VARIANTS.includes(variant);
	};
	const variantToTagMap = {
	    'large-title': 'h1',
	    'headline-1': 'h1',
	    'headline-2': 'h2',
	    'headline-3': 'h3',
	    'headline-4': 'h4',
	    'headline-5': 'h5',
	};
	const getHeadlineTagType = (host, variant, tag) => {
	    if (typographyAlign.hasSpecificDirectChildTag(host, HEADLINE_TAGS.join())) {
	        return 'div';
	    }
	    else if (tag) {
	        return tag;
	    }
	    else {
	        return variantToTagMap[variant] || 'h1';
	    }
	};

	const headlineSizeMap = {
	    'headline-1': headingXXLargeStyle.fontSizeHeadingXXLarge,
	    'headline-2': headingXXLargeStyle.fontSizeHeadingXLarge,
	    'headline-3': fontSizeHeadingLarge.fontSizeHeadingLarge,
	    'headline-4': fontSizeHeadingMedium.fontSizeHeadingMedium,
	    'headline-5': fontSizeHeadingSmall.fontSizeHeadingSmall,
	};
	const getHeadlineVariantJssStyle = (variant) => {
	    return {
	        ...(variant === 'large-title'
	            ? displayMediumStyle
	            : {
	                fontSize: headlineSizeMap[variant],
	            }),
	    };
	};
	const textSizeMap = {
	    'xx-small': fontSizeTextXXSmall.fontSizeTextXXSmall,
	    'x-small': fontSizeTextXSmall.fontSizeTextXSmall,
	    small: fontSizeTextSmall.fontSizeTextSmall,
	    medium: fontSizeTextMedium.fontSizeTextMedium,
	    large: fontSizeTextLarge.fontSizeTextLarge,
	    'x-large': fontSizeTextXLarge.fontSizeTextXLarge,
	};
	const getTextSizeJssStyle = (textSize) => {
	    return {
	        fontSize: textSize === 'inherit' ? textSize : textSizeMap[textSize],
	    };
	};
	const getComponentCss = (variant, align, color, ellipsis, theme) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            '::slotted': {
	                [HEADLINE_TAGS.map((i) => `&(${i})`).join()]: validateProps.addImportantToEachRule(typographyStyles.getTypographySlottedJssStyle()),
	            },
	        },
	        root: typographyStyles.getTypographyRootJssStyle(headingXXLargeStyle.headingXXLargeStyle, isValidVariantType(variant)
	            ? getHeadlineVariantJssStyle(variant)
	            : validateProps.buildResponsiveStyles(variant, getTextSizeJssStyle), align, color, ellipsis, theme),
	    });
	};

	const propTypes = {
	    // variant: AllowedTypes.string, // TODO: with all the different values this can't easily be validated
	    tag: validateProps.AllowedTypes.oneOf([undefined, ...HEADLINE_TAGS]),
	    align: validateProps.AllowedTypes.oneOf(typographyAlign.TYPOGRAPHY_ALIGNS),
	    color: validateProps.AllowedTypes.oneOf(HEADLINE_COLORS),
	    ellipsis: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Headline = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.variant = 'headline-1';
	        this.tag = undefined;
	        this.align = 'start';
	        this.color = 'primary';
	        this.ellipsis = false;
	        this.theme = 'light';
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedComponentIsUsed.warnIfDeprecatedComponentIsUsed(this.host, 'Please use new p-heading component instead.');
	        const alignDeprecationMap = {
	            left: 'start',
	            right: 'end',
	        };
	        validateProps.attachComponentCss(this.host, getComponentCss, this.variant, (alignDeprecationMap[this.align] || this.align), this.color, this.ellipsis, this.theme);
	        const TagType = getHeadlineTagType(this.host, this.variant, this.tag);
	        return (validateProps.h(TagType, { key: '5e3b85f56426ecebddb359b87be1836dc3449105', class: "root" }, validateProps.h("slot", { key: '200bc1116ef924fb1d46e7137576f986a841343e' })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pHeadline_cjs_entry.p_headline = Headline;

	
	return pHeadline_cjs_entry;
}

var pIcon_cjs_entry = {};

var typographyTextColor524bae09 = {};

var hasRequiredTypographyTextColor524bae09;

function requireTypographyTextColor524bae09 () {
	if (hasRequiredTypographyTextColor524bae09) return typographyTextColor524bae09;
	hasRequiredTypographyTextColor524bae09 = 1;

	/** @deprecated */
	const TYPOGRAPHY_TEXT_COLORS_DEPRECATED = [
	    'brand', // deprecated
	    'default', // deprecated
	    'neutral-contrast-low', // deprecated
	    'neutral-contrast-medium', // deprecated
	    'neutral-contrast-high', // deprecated
	    'notification-neutral', // deprecated
	];
	const TYPOGRAPHY_TEXT_COLORS = [
	    'primary',
	    'contrast-low',
	    'contrast-medium',
	    'contrast-high',
	    'notification-success',
	    'notification-warning',
	    'notification-error',
	    'notification-info',
	    'inherit',
	    ...TYPOGRAPHY_TEXT_COLORS_DEPRECATED,
	];

	typographyTextColor524bae09.TYPOGRAPHY_TEXT_COLORS = TYPOGRAPHY_TEXT_COLORS;

	
	return typographyTextColor524bae09;
}

var schemedHighContrastMediaQuery462417a0 = {};

var hasRequiredSchemedHighContrastMediaQuery462417a0;

function requireSchemedHighContrastMediaQuery462417a0 () {
	if (hasRequiredSchemedHighContrastMediaQuery462417a0) return schemedHighContrastMediaQuery462417a0;
	hasRequiredSchemedHighContrastMediaQuery462417a0 = 1;

	const getSchemedHighContrastMediaQuery = (light, dark) => {
	    return {
	        '@media (forced-colors: active) and (prefers-color-scheme: light)': light,
	        '@media (forced-colors: active) and (prefers-color-scheme: dark)': dark,
	    };
	};

	schemedHighContrastMediaQuery462417a0.getSchemedHighContrastMediaQuery = getSchemedHighContrastMediaQuery;

	
	return schemedHighContrastMediaQuery462417a0;
}

var hasRequiredPIcon_cjs_entry;

function requirePIcon_cjs_entry () {
	if (hasRequiredPIcon_cjs_entry) return pIcon_cjs_entry;
	hasRequiredPIcon_cjs_entry = 1;

	Object.defineProperty(pIcon_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const typographyTextColor = requireTypographyTextColor524bae09();
	const getCDNBaseURL = requireGetCDNBaseURLE7722df3();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed2d6d1d94();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed0dc3288b();
	const theme = requireThemeBfc10573();
	const textSize = requireTextSizeBe3fca13();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const schemedHighContrastMediaQuery = requireSchemedHighContrastMediaQuery462417a0();
	const fontSizeTextXXSmall = requireFontSizeTextXXSmallA02f9c40();
	const fontSizeTextXSmall = requireFontSizeTextXSmallE59d35d7();
	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();
	const fontSizeTextMedium = requireFontSizeTextMedium88887ad8();
	const fontSizeTextLarge = requireFontSizeTextLarge05a4bc90();
	const fontSizeTextXLarge = requireFontSizeTextXLarge0ecf9ef3();
	const fontLineHeight = requireFontLineHeight78b03658();
	requireHelperA66adcf2();

	const ICONS_MANIFEST = { "360": "360.min.d3b2874981886b5ebece31655f92a3ad.svg", "accessibility": "accessibility.min.39472992434d3aae116c950714e80d26.svg", "active-cabin-ventilation": "active-cabin-ventilation.min.60422415604862b604bab5d59a4cf9ca.svg", "add": "add.min.8a2cc9683690995a35bbe3b21c444afb.svg", "adjust": "adjust.min.faf70ff09f41b20ca5c914871f92ee9b.svg", "arrow-double-down": "arrow-double-down.min.3a5683124626fe51505380524ffbddd5.svg", "arrow-double-left": "arrow-double-left.min.cf7261542e67b89fe8b146ee4c3748ed.svg", "arrow-double-right": "arrow-double-right.min.4291829dcf9bfb5fc9156199a51c61eb.svg", "arrow-double-up": "arrow-double-up.min.e67ff8a2cfe8807f663346cca9b403a0.svg", "arrow-down": "arrow-down.min.86fc100227a564b214f4fe07e8401728.svg", "arrow-first": "arrow-first.min.bc51317ecf4953a664870ebab5059775.svg", "arrow-head-down": "arrow-head-down.min.31c010019ab8911fed67bef461ce8b40.svg", "arrow-head-left": "arrow-head-left.min.4723607b9add50ee55a343bdf26ff315.svg", "arrow-head-right": "arrow-head-right.min.c2b5cd82e92920af36c9be86dc321999.svg", "arrow-head-up": "arrow-head-up.min.e8f62967ee5ecb865e1399ffa3235ac0.svg", "arrow-last": "arrow-last.min.72553c4284717d4961f8bcf8d51e0303.svg", "arrow-left": "arrow-left.min.06c8246bf60d457bc3f2ff8866053de2.svg", "arrow-right": "arrow-right.min.c5cbce45d98d6d1178cc72ea8bfbfa10.svg", "arrow-up": "arrow-up.min.deb76e3aacfb1059ef9f5130adb143b4.svg", "augmented-reality": "augmented-reality.min.f776f8a44e469a2a7f54f3f59e15fa3d.svg", "battery-empty": "battery-empty.min.8594e37d3e67a95b85eb9935f02e69cf.svg", "battery-empty-co2": "battery-empty-co2.min.58e20e83589753260859a9b6afddb2e9.svg", "battery-empty-fuel": "battery-empty-fuel.min.ef5c8b3fa6e0d7b6b365355f75b107c5.svg", "battery-full": "battery-full.min.4c75acb5a64a6dd3116ede7b1859a6d6.svg", "bell": "bell.min.22f7cdeffa6e2a1524c7358b3c045380.svg", "bookmark": "bookmark.min.9d6982fc89822602454c2b1e21aeb1b9.svg", "bookmark-filled": "bookmark-filled.min.9f96a8e4d19a90f288cab4298075fbfe.svg", "broadcast": "broadcast.min.694edb52b13117621b406ca1d1e8a50d.svg", "calculator": "calculator.min.2518729352d3709e488e71dcbf449247.svg", "calendar": "calendar.min.bc89af56fd76ad2e64d30dfc6f385cf4.svg", "camera": "camera.min.c54204c4294683703245cd4ffff8aac4.svg", "car": "car.min.458d137c81fd14019ca67b225ce85b53.svg", "car-battery": "car-battery.min.651ee52abbb40a656842df198a1de7ec.svg", "card": "card.min.572e3adcb01df8f9feb499fac6611b52.svg", "charging-active": "charging-active.min.421bdd011bfc2e8ff4cc2b5adad2a36a.svg", "charging-state": "charging-state.min.26a4894b3de9b3b8676b803dea2f388a.svg", "charging-station": "charging-station.min.bcbf9bed92bce0100d5322bdec4b9887.svg", "chart": "chart.min.fef87221f35a78ff17bbc3d96b773e33.svg", "chat": "chat.min.733ae126444c50779d6d22e9f51dd739.svg", "check": "check.min.e1930a3d5427c6e8e41af7bf8edec8bb.svg", "city": "city.min.a99b88b51adda8244a2c72953a2f4ab4.svg", "climate": "climate.min.5d52b2880552275d9032afc0fa2b7296.svg", "climate-control": "climate-control.min.1d895777024f7feac7efc8a21fae2434.svg", "clock": "clock.min.04a827c1f9bb35bedaacc7eeb82d03fc.svg", "close": "close.min.565f6a718b632a173b7a74eb9cb84378.svg", "closed-caption": "closed-caption.min.e7b74862b113c39c5d5f8457a22f4540.svg", "co2-class": "co2-class.min.f7b24da1aa9e34199ab2e8de7cffd08f.svg", "co2-emission": "co2-emission.min.1a0e315ed17c2bd3a0356bfc12fc440b.svg", "compare": "compare.min.9c23d6a10728833095ea6e49e93d9169.svg", "configurate": "configurate.min.224bd9e2517456659ff569d85cd7f3f8.svg", "copy": "copy.min.b0a10014b18914ec494e8b3e192476ec.svg", "country-road": "country-road.min.d96dabea56a3d002575d59798c12402c.svg", "cubic-capacity": "cubic-capacity.min.cbda5779c4ff38cf4cd96ca39d148282.svg", "delete": "delete.min.65becfbcc48b9492a58f4d3897dec899.svg", "disable": "disable.min.c0ebae661732da2c4b6bdafdc3efb312.svg", "document": "document.min.d2db26d7049ab2180361c7ce40f52d57.svg", "download": "download.min.052783a619244de5e2f34e6300182f54.svg", "duration": "duration.min.4dcbb8fe5db34911a2d0301e2399def8.svg", "edit": "edit.min.8236867e0975bbf4127fbf8047e3ba38.svg", "email": "email.min.eb8ff02812a48c5098d3c40614e8d9d7.svg", "error-filled": "error-filled.min.e9745fe44ade7ee515da8ea964ec4c66.svg", "exclamation": "exclamation.min.69832f14c6f80b43de1628f87efb4933.svg", "external": "external.min.1d85320339ea25db0324e74be0f632e2.svg", "filter": "filter.min.60f168332c7550dfdf714ed0507877b0.svg", "fingerprint": "fingerprint.min.698297df3e9555c61463be51340356ac.svg", "flash": "flash.min.e1ed63ec33d28aaa9cdf78d45df1eb8e.svg", "fuel-station": "fuel-station.min.7149b2be5528908900cbc4c9a2654150.svg", "garage": "garage.min.05bd3f8eae4ba0bb1a758ba272789ad4.svg", "gift": "gift.min.091131a27cb0703b194952a6a6208548.svg", "globe": "globe.min.9e186f3da4fa55382f84c7b66235f47a.svg", "grid": "grid.min.eb7c2ddc778827955200c41e53abdcec.svg", "heart": "heart.min.9bf1c860a0e4c38cf85d1e82b19ba483.svg", "heart-filled": "heart-filled.min.581fbbce1e8955092aa194dcf8fdfb6e.svg", "highway": "highway.min.938feb5bf2ec2a7ce6f43aadc498aa32.svg", "home": "home.min.2bdc01bb7c9b39fa5ef5a81c8c3f9f49.svg", "horn": "horn.min.77105eb430a033a3ffdf21f9fecd32de.svg", "image": "image.min.851c64681e1950312a934a723ca04a85.svg", "increase": "increase.min.45bfe421e86192da37c8cca4917c10c2.svg", "information": "information.min.da41162c49566b753b7162fc6b88adb9.svg", "information-filled": "information-filled.min.d9ff41c99234ae53e794900a355268de.svg", "key": "key.min.4f55b5ba22e76cf8426ad6dbe40d0bbc.svg", "leaf": "leaf.min.9fb555963ab3e04de2b2fc3356fb8d54.svg", "leather": "leather.min.e1869beedb7d489f9c88873db7e86878.svg", "light": "light.min.b3df892b730921aa9f34e72d1dc6707f.svg", "list": "list.min.ecaeee96ec6cf2f8c9028ea404113a9e.svg", "locate": "locate.min.61ea8fda8a7f6a61e90382d371882875.svg", "lock": "lock.min.c9bd1029c6fc9bfa37dbcaa1de314151.svg", "lock-open": "lock-open.min.ebce0c0023d1761620e5a9ec86d5f19c.svg", "logo-apple-podcast": "logo-apple-podcast.min.59a2ee9e209fa59584c5e7d1ab15751b.svg", "logo-baidu": "logo-baidu.min.fef8bfc1e79a0ae2a045b85cb6914500.svg", "logo-delicious": "logo-delicious.min.fc2927d4979ffaed1f23160091e0975e.svg", "logo-digg": "logo-digg.min.d7340b3f22cf4a22a8ac3b472c16e0e2.svg", "logo-facebook": "logo-facebook.min.1f2fd90a9f18dd66befe59beb96ecca8.svg", "logo-foursquare": "logo-foursquare.min.3540cfa24d2148b73109be719fda9dc9.svg", "logo-gmail": "logo-gmail.min.adfa4976a690779760813b2d6233044c.svg", "logo-google": "logo-google.min.94c456d4bbaff4762bc237e955208d43.svg", "logo-hatena": "logo-hatena.min.fa24251ddecb3bb3dc88eb272ceb7207.svg", "logo-instagram": "logo-instagram.min.3598c948318e3ca1d3ceb05b2d92ed82.svg", "logo-kaixin": "logo-kaixin.min.589d54db102fd3601a2f6272e95a97ae.svg", "logo-kakaotalk": "logo-kakaotalk.min.a12bd354de347ae378c814bab03019c9.svg", "logo-linkedin": "logo-linkedin.min.037f80d4dcaed74a8ec477c8b41efda4.svg", "logo-naver": "logo-naver.min.3fb9362b5d870bfa2b4828d3ed8f0908.svg", "logo-pinterest": "logo-pinterest.min.bc85460c3acaf569a2dac52c65e0cbb1.svg", "logo-qq": "logo-qq.min.f4964e246a81d4c53e6cd73b27bec6f7.svg", "logo-qq-share": "logo-qq-share.min.206a8aa10c361b42e0ce21187a026b20.svg", "logo-reddit": "logo-reddit.min.d17ea0df5f3ef78dfd4c589ee05f614c.svg", "logo-skyrock": "logo-skyrock.min.c8abe04e7b2108e0043bfbf767502e28.svg", "logo-sohu": "logo-sohu.min.b08a939d35b55af30a260e7cd4a0ec86.svg", "logo-spotify": "logo-spotify.min.45a99bb091d15e4ee8972c924a0bccd7.svg", "logo-tecent": "logo-tecent.min.46a3a54e2eefb01152fc5bbcf669bb50.svg", "logo-telegram": "logo-telegram.min.624fca36dd6f6c5b64bce6e617372d77.svg", "logo-tiktok": "logo-tiktok.min.7829ba5442928dac099150730224cb05.svg", "logo-tumblr": "logo-tumblr.min.01b11e20074f291f48ad3b8b8b6c3614.svg", "logo-twitter": "logo-twitter.min.5f2490acc4b03eea7f270a750595de71.svg", "logo-viber": "logo-viber.min.646a1bd7d9ddfa36e88ac8167ceb3a62.svg", "logo-vk": "logo-vk.min.3efece5db847af4330a6e8443f63ee69.svg", "logo-wechat": "logo-wechat.min.cd991e932478b2c59f2ec06087e7c24d.svg", "logo-weibo": "logo-weibo.min.7cb2bb1ff4fbb20d389b51acaf36dc3b.svg", "logo-whatsapp": "logo-whatsapp.min.c2c7058b2c0a5b258ac1490e6cd0788a.svg", "logo-x": "logo-x.min.5f2490acc4b03eea7f270a750595de71.svg", "logo-xing": "logo-xing.min.29d25a181d0bd4b4c8f19df1543b92d9.svg", "logo-yahoo": "logo-yahoo.min.e7af46e796bdbfc6420ce2be575e728a.svg", "logo-youku": "logo-youku.min.aae99a44e06894fd39e2e727062ac922.svg", "logo-youtube": "logo-youtube.min.ff07c3f9edd380237a3696ad52922c78.svg", "logout": "logout.min.6fee5a3178d5dc1822872ce7a5498bc2.svg", "map": "map.min.e56d3b260f79967149f12759c2bff74b.svg", "menu-dots-horizontal": "menu-dots-horizontal.min.94e0804e3a5a30a577cab6296ad8d15d.svg", "menu-dots-vertical": "menu-dots-vertical.min.7ec3f5be33dd3459d7a9bed9fdbe22d3.svg", "menu-lines": "menu-lines.min.e3322162121fb57b7109e6c245865e77.svg", "minus": "minus.min.00cca11ec9ce4bd913abba2059c3f10b.svg", "mobile": "mobile.min.00021b016be7e9f085c9a674b00228af.svg", "moon": "moon.min.1bb08960549b5862c853d13a259e51b3.svg", "oil-can": "oil-can.min.4cc2d96f9754e9f708a07836eba07d03.svg", "parking-brake": "parking-brake.min.285b4ba85166dd00b8a6c2e6833e5c88.svg", "parking-light": "parking-light.min.3f11c8f7dbbba49b0c68eea92e97bd5e.svg", "pause": "pause.min.dd29b256b73311abf1549ed16fe7a47b.svg", "phone": "phone.min.cd54f3670e32d37ea41484f6fd45ddaa.svg", "pin": "pin.min.6cf04e89e5946856f6ae8f526425ef8f.svg", "pin-filled": "pin-filled.min.e3a46a4efb0d4041ebafff08ecbdca59.svg", "play": "play.min.65ffffba05432a3f804eb6c537fb71ef.svg", "plug": "plug.min.289db9e36a8ba1dbf5a8e8d387ed8871.svg", "plus": "plus.min.3fbdce4b03fe2c2d1ae489f0dd916f7b.svg", "preheating": "preheating.min.7e8b645163d47293eb7d79f5d6870911.svg", "printer": "printer.min.1df1993070df56c82cdfcc01e9c6f23e.svg", "purchase": "purchase.min.693f7b82c23721fe4bf15a6f8f50b80e.svg", "push-pin": "push-pin.min.a5a47f392030bb24a5b4b985061a5181.svg", "push-pin-off": "push-pin-off.min.2f4b9c8bfb787e48d75a3dd95e38da19.svg", "qr": "qr.min.1facfc2c9b70057552904fe123674746.svg", "question": "question.min.5868a129a8aa88e5504ef2351bfd234f.svg", "racing-flag": "racing-flag.min.c5993e8842a9d4155cc1272358efde84.svg", "refresh": "refresh.min.b4853591c524d0dc7924e60314494ccf.svg", "replay": "replay.min.a3e6361394e1c9432bfb5f9a4b5833ca.svg", "reset": "reset.min.e1ce71f684b6e83b9ed8182389bd407f.svg", "roof-closed": "roof-closed.min.faf6177214e68591bb9911050870103c.svg", "roof-open": "roof-open.min.4314d86b9159ead78bc46622c1c4d3ac.svg", "route": "route.min.784e30085f543fdeb9158cb27c7cb38e.svg", "rss": "rss.min.32a204b2df59ef3fc3bd13effa76b4d2.svg", "save": "save.min.2481cb4d8d04b3ee6b26547a4b8b57ac.svg", "screen": "screen.min.c17978f44a7bf9f7d80f178fd2b7d116.svg", "search": "search.min.1a2481bb5b7acefdb7f69d34d5b2887a.svg", "send": "send.min.544f2b90e562b8582808f735846b1351.svg", "share": "share.min.f92604f534cee4ed9753d1976855908a.svg", "shopping-bag": "shopping-bag.min.3f91a9bcd921ce9d850499c3c5af34fc.svg", "shopping-bag-filled": "shopping-bag-filled.min.abf6c983207c87279f5f6bc26c3ef7d4.svg", "shopping-cart": "shopping-cart.min.05a6c651afb21246daba2e941e8366cc.svg", "shopping-cart-filled": "shopping-cart-filled.min.0e5a79dd87cc0ea1f4c72d5b04aa505e.svg", "sidelights": "sidelights.min.44ca975194d22ac2dc893395256b1678.svg", "snowflake": "snowflake.min.889d8b279ac98abfd0c74cf90b9e3c68.svg", "sort": "sort.min.1629148e7e80ced04d9615b51664e07b.svg", "stack": "stack.min.e71da4fb0445267fa13bff9cfa1fbd16.svg", "star": "star.min.4c5bb15a9c3d7136351e3953805df3c8.svg", "star-filled": "star-filled.min.942167258f7a37f163c03313c5c85eaa.svg", "steering-wheel": "steering-wheel.min.1738194edd71e78e6f8937142bf5d1ef.svg", "stopwatch": "stopwatch.min.932f9fa49916e38a99d2b23511d7f114.svg", "subtract": "subtract.min.43807211256225261ea0cecebc3197fc.svg", "success": "success.min.441faa611fe5d97d758f557ab5438826.svg", "success-filled": "success-filled.min.629e31bb0384825a875c627f5d9f8a37.svg", "sun": "sun.min.7bd259f3f639ac8476a348e2a79ffce3.svg", "switch": "switch.min.bbaf816c7c6982a3714f6e121266dd44.svg", "tablet": "tablet.min.a5e47c3362c7d22fcb44d8cd99f89793.svg", "tachometer": "tachometer.min.4f2563b806263118f75d365f38d26d79.svg", "tire": "tire.min.6ebb3d5a396401e734ae63c06aaaf198.svg", "truck": "truck.min.17f20699b0ebf6f63b418e863410553a.svg", "upload": "upload.min.7b886aa894be24d3549089563361a008.svg", "user": "user.min.255f5ec972caaecfb41b024847a9bbef.svg", "user-filled": "user-filled.min.f35ca1e5ba7d3984ea638b8d92fd3663.svg", "user-group": "user-group.min.27dd137a75974dabf3f60c90591b54c7.svg", "user-manual": "user-manual.min.0b87e500e3d747e67be964c47a3ae312.svg", "video": "video.min.3725461133a7f2a081a5aa4d27b96921.svg", "view": "view.min.78e4839028a721c3efcd47dfdbc8e4bf.svg", "view-off": "view-off.min.041d6453bd984055a91fd70ae251a2c8.svg", "volume-off": "volume-off.min.1bedd2b4a901feda38454b1d495f84e7.svg", "volume-up": "volume-up.min.c6b1b9ca042830cdf31e9b7ca0351bd1.svg", "warning": "warning.min.471ca57c6eef0711bfaa40a6791297ee.svg", "warning-filled": "warning-filled.min.df35246b8e94f696eefc1b2122a77a50.svg", "weight": "weight.min.4f0f06e26c83b4fa29e82e0de9153775.svg", "wifi": "wifi.min.3b4e78e9f4375afd8ada69a3a418a6c4.svg", "work": "work.min.302501dba39782f9a59d3766f57762b2.svg", "wrench": "wrench.min.91a2a4a766ea46cc53898fa4680099b5.svg", "wrenches": "wrenches.min.e06308f102cb227a9fcba2553151bae5.svg", "zoom-in": "zoom-in.min.38a97db3e6a00ce671ee7643679793be.svg", "zoom-out": "zoom-out.min.8dd4c51836b1262285122df30abd8f37.svg" };

	const ICON_ARIA_ATTRIBUTES = ['aria-label'];
	const ICON_COLORS = [...typographyTextColor.TYPOGRAPHY_TEXT_COLORS, 'state-disabled'];
	const isUrl = (str) => str?.length > 0 && /(\/)/.test(str);
	const DEFAULT_ICON_NAME = 'arrow-right';
	// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
	const buildIconUrl = (iconNameOrSource = DEFAULT_ICON_NAME) => {
	    if (iconNameOrSource === null) {
	        return buildIconUrl(DEFAULT_ICON_NAME);
	    }
	    else if (isUrl(iconNameOrSource)) {
	        return iconNameOrSource;
	    }
	    else if (ICONS_MANIFEST[iconNameOrSource]) {
	        return `${getCDNBaseURL.getCDNBaseURL()}/icons/${ICONS_MANIFEST[iconNameOrSource]}`;
	    }
	    return buildIconUrl(DEFAULT_ICON_NAME);
	};

	const toFilter = (values) => `invert(${values[0]}%) sepia(${values[1]}%) saturate(${values[2]}%) hue-rotate(${values[3]}deg) brightness(${values[4]}%) contrast(${values[5]}%)`;

	const filterLightContrastLow = toFilter([93, 11, 36, 201, 89, 102]);
	const filterLightContrastMedium = toFilter([45, 6, 235, 177, 91, 85]);
	const filterLightContrastHigh = toFilter([40, 2, 686, 187, 80, 94]);
	const filterDarkContrastLow = toFilter([20, 7, 421, 202, 97, 82]);
	const filterDarkContrastMedium = toFilter([66, 3, 333, 187, 82, 86]);
	const filterDarkContrastHigh = toFilter([68, 6, 108, 187, 104, 88]);

	const filterLightDisabled = toFilter([63, 8, 108, 188, 94, 86]);
	const filterDarkDisabled = toFilter([52, 6, 135, 187, 94, 89]);

	const filterLightNotificationSuccess = toFilter([28, 89, 572, 71, 111, 98]);
	const filterLightNotificationWarning = toFilter([58, 53, 820, 12, 112, 103]);
	const filterLightNotificationError = toFilter([14, 75, 4140, 347, 100, 97]);
	const filterLightNotificationInfo = toFilter([44, 100, 492, 195, 86, 221]);
	const filterDarkNotificationSuccess = toFilter([60, 71, 512, 106, 91, 97]);
	const filterDarkNotificationWarning = toFilter([75, 39, 759, 350, 109, 94]);
	const filterDarkNotificationError = toFilter([64, 91, 5857, 336, 98, 102]);
	const filterDarkNotificationInfo = toFilter([56, 77, 4175, 198, 104, 98]);

	const filterLightPrimary = toFilter([3, 7, 2930, 188, 91, 103]);
	const filterDarkPrimary = toFilter([100, 91, 38, 254, 110, 110]);

	const sizeMap = {
	    'xx-small': fontSizeTextXXSmall.fontSizeTextXXSmall,
	    'x-small': fontSizeTextXSmall.fontSizeTextXSmall,
	    small: fontSizeTextSmall.fontSizeTextSmall,
	    medium: fontSizeTextMedium.fontSizeTextMedium,
	    large: fontSizeTextLarge.fontSizeTextLarge,
	    'x-large': fontSizeTextXLarge.fontSizeTextXLarge,
	};
	const filterLight = {
	    primary: filterLightPrimary,
	    'state-disabled': filterLightDisabled,
	    'contrast-low': filterLightContrastLow,
	    'contrast-medium': filterLightContrastMedium,
	    'contrast-high': filterLightContrastHigh,
	    'notification-success': filterLightNotificationSuccess,
	    'notification-warning': filterLightNotificationWarning,
	    'notification-error': filterLightNotificationError,
	    'notification-info': filterLightNotificationInfo,
	};
	const filterDark = {
	    primary: filterDarkPrimary,
	    'state-disabled': filterDarkDisabled,
	    'contrast-low': filterDarkContrastLow,
	    'contrast-medium': filterDarkContrastMedium,
	    'contrast-high': filterDarkContrastHigh,
	    'notification-success': filterDarkNotificationSuccess,
	    'notification-warning': filterDarkNotificationWarning,
	    'notification-error': filterDarkNotificationError,
	    'notification-info': filterDarkNotificationInfo,
	};
	const filterMap = {
	    auto: filterLight,
	    light: filterLight,
	    dark: filterDark,
	};
	const forceRerenderAnimationStyle = {
	    '0%': {
	        transform: 'rotateZ(0)',
	    },
	    '100%': {
	        transform: 'rotateZ(0)',
	    },
	};
	const keyFramesLight = 'rerender-light';
	const keyFramesDark = 'rerender-dark';
	const cssVariableFilter = '--p-internal-icon-filter';
	const isFlippableIcon = (name, source) => {
	    return (!source &&
	        (name === 'arrow-double-left' ||
	            name === 'arrow-double-right' ||
	            name === 'arrow-first' ||
	            name === 'arrow-head-left' ||
	            name === 'arrow-head-right' ||
	            name === 'arrow-last' ||
	            name === 'arrow-left' ||
	            name === 'arrow-right' ||
	            name === 'chart' ||
	            name === 'chat' ||
	            name === 'external' ||
	            name === 'increase' ||
	            name === 'list' ||
	            name === 'logout' ||
	            name === 'send'));
	};
	const getComponentCss = (name, source, color, size, theme) => {
	    const isColorInherit = color === 'inherit';
	    const isSizeInherit = size === 'inherit';
	    const isDark = validateProps.isThemeDark(theme);
	    const animationName = `${isDark ? keyFramesDark : keyFramesLight}-${color}`;
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'inline-block',
	                verticalAlign: 'top',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            img: {
	                display: 'block', // without display, img tag gets some extra spacing
	                margin: 0,
	                padding: 0,
	                pointerEvents: 'none', // disable dragging/ghosting of images
	                ...(!isColorInherit && {
	                    filter: `var(${cssVariableFilter},${filterMap[theme][color]})`,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        filter: `var(${cssVariableFilter},${filterMap.dark[color]})`,
	                    }),
	                    ...(validateProps.isHighContrastMode &&
	                        schemedHighContrastMediaQuery.getSchemedHighContrastMediaQuery({
	                            filter: filterMap.light[color],
	                        }, {
	                            filter: filterMap.dark[color],
	                        })),
	                    WebkitAnimation: `${animationName} 1ms`, // needed to enforce repaint in Safari if theme is switched programmatically
	                }),
	                ...(isSizeInherit
	                    ? {
	                        width: size,
	                        height: size,
	                    }
	                    : {
	                        width: fontLineHeight.fontLineHeight,
	                        height: fontLineHeight.fontLineHeight,
	                        font: `${sizeMap[size]} ${fontLineHeight.fontFamily}`,
	                    }),
	                ...(isFlippableIcon(name, source) && {
	                    '&:dir(rtl)': {
	                        transform: 'scaleX(-1)',
	                    },
	                }),
	            },
	            ...(!isColorInherit && {
	                [`@keyframes ${animationName}`]: forceRerenderAnimationStyle,
	            }),
	        },
	    });
	};

	const propTypes = {
	    name: validateProps.AllowedTypes.oneOf(Object.keys(ICONS_MANIFEST)),
	    source: validateProps.AllowedTypes.string,
	    color: validateProps.AllowedTypes.oneOf(ICON_COLORS),
	    size: validateProps.AllowedTypes.oneOf(textSize.TEXT_SIZES),
	    lazy: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    aria: validateProps.AllowedTypes.aria(ICON_ARIA_ATTRIBUTES),
	};
	const Icon = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.name = 'arrow-right';
	        this.source = undefined;
	        this.color = 'primary';
	        this.size = 'small';
	        this.lazy = undefined;
	        this.theme = 'light';
	        this.aria = undefined;
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'lazy');
	        const deprecationMap = {
	            brand: 'primary',
	            default: 'primary',
	            'neutral-contrast-low': 'contrast-low',
	            'neutral-contrast-medium': 'contrast-medium',
	            'neutral-contrast-high': 'contrast-high',
	            'notification-neutral': 'notification-info',
	        };
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'color', deprecationMap);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.name, this.source, (deprecationMap[this.color] || this.color), this.size, this.theme);
	        return (validateProps.h("img", { key: 'c9498478993a008a99de1e3b92e5d8b6d21ba6a5', src: window.PDS_SKIP_FETCH ? undefined : buildIconUrl(this.source || this.name), width: 24, height: 24, loading: "lazy", alt: validateProps.parseAndGetAriaAttributes(this.aria)?.['aria-label'] ?? '' }));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pIcon_cjs_entry.p_icon = Icon;

	
	return pIcon_cjs_entry;
}

var pInlineNotification_cjs_entry = {};

var hasRequiredPInlineNotification_cjs_entry;

function requirePInlineNotification_cjs_entry () {
	if (hasRequiredPInlineNotification_cjs_entry) return pInlineNotification_cjs_entry;
	hasRequiredPInlineNotification_cjs_entry = 1;

	Object.defineProperty(pInlineNotification_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const hasHeading = requireHasHeading6f9fd2ca();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed2d6d1d94();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed0dc3288b();
	const theme = requireThemeBfc10573();
	const headingTag = requireHeadingTag6cfe20fe();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const inlineNotificationUtils = requireInlineNotificationUtils60940706();
	const typographyStyles = requireTypographyStyles1a447490();
	const getMediaQueryMax = requireGetMediaQueryMaxBbf4c490();
	const headingSmallStyle = requireHeadingSmallStyle0707b97f();
	const textSmallStyle = requireTextSmallStyle7246779a();
	requireHasNamedSlotA96fd22a();
	requireGetNamedSlotA0cdbdbc();
	requireHelperA66adcf2();
	requireSpacingStaticMedium94812711();
	requireBorderRadiusSmall5f37fc45();
	requireSpacingStaticXSmallB7d708b8();
	requireSpacingStaticSmall2130ed04();
	requireBannerUtils2cc83734();
	requireTextIconStyles990609fb();
	requireHeadingSharedAa59e66d();
	requireFontLineHeight78b03658();
	requireFontWeightSemiBold4482c830();
	requireFontVariant6ba3b7cb();
	requireFontSizeHeadingSmallA15141a5();
	requireFontSizeTextSmall508930e5();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();

	const mediaQueryMaxS = getMediaQueryMax.getMediaQueryMax('s');
	const getTextJssStyle = (theme) => ({
	    margin: 0,
	    color: validateProps.getThemedColors(theme).primaryColor,
	    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	        color: validateProps.getThemedColors('dark').primaryColor,
	    }),
	});
	const getHeadingJssStyle = (theme) => ({
	    ...headingSmallStyle.headingSmallStyle,
	    ...getTextJssStyle(theme),
	});
	const getComponentCss = (state, hasAction, hasClose, theme) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'grid',
	                ...validateProps.addImportantToEachRule({
	                    ...inlineNotificationUtils.getNotificationRootJssStyle(state, hasAction, hasClose, theme),
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            [`::slotted(:is(${headingTag.HEADING_TAGS.join()}))`]: validateProps.addImportantToEachRule(typographyStyles.getTypographySlottedJssStyle()),
	            'slot[name="heading"]': getHeadingJssStyle(theme),
	        },
	        heading: getHeadingJssStyle(theme),
	        description: {
	            ...textSmallStyle.textSmallStyle,
	            ...getTextJssStyle(theme),
	        },
	        icon: inlineNotificationUtils.getNotificationIconJssStyle(),
	        content: inlineNotificationUtils.getNotificationContentJssStyle(),
	        ...(hasAction && {
	            action: {
	                [mediaQueryMaxS]: {
	                    gridRowStart: 2,
	                },
	            },
	        }),
	    });
	};

	const propTypes = {
	    heading: validateProps.AllowedTypes.string,
	    headingTag: validateProps.AllowedTypes.oneOf(headingTag.HEADING_TAGS),
	    description: validateProps.AllowedTypes.string,
	    state: validateProps.AllowedTypes.oneOf(inlineNotificationUtils.INLINE_NOTIFICATION_STATES),
	    dismissButton: validateProps.AllowedTypes.boolean,
	    persistent: validateProps.AllowedTypes.boolean,
	    actionLabel: validateProps.AllowedTypes.string,
	    actionLoading: validateProps.AllowedTypes.boolean,
	    actionIcon: validateProps.AllowedTypes.string, // TODO: we could use AllowedTypes.oneOf<IconName>(Object.keys(ICONS_MANIFEST) as IconName[]) but then main chunk will increase
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const InlineNotification = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.dismiss = validateProps.createEvent(this, "dismiss", 3);
	        this.action = validateProps.createEvent(this, "action", 3);
	        this.heading = '';
	        this.headingTag = 'h5';
	        this.description = '';
	        this.state = 'info';
	        this.dismissButton = true;
	        this.persistent = undefined;
	        this.actionLabel = undefined;
	        this.actionLoading = false;
	        this.actionIcon = 'arrow-right';
	        this.theme = 'light';
	    }
	    get hasDismissButton() {
	        return this.persistent ? false : this.dismissButton;
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'state', {
	            neutral: 'info',
	        });
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'persistent', 'Please use dismissButton prop instead.');
	        validateProps.attachComponentCss(this.host, getComponentCss, this.state, !!this.actionLabel, this.hasDismissButton, this.theme);
	        const bannerId = 'banner';
	        const labelId = 'label';
	        const descriptionId = 'description';
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        const Heading = this.headingTag;
	        return (validateProps.h(validateProps.Host, { key: '2fb96479b8419c98efb1071d6152fc867fbe5014' }, validateProps.h(PrefixedTagNames.pIcon, { key: '0dfd238093c59e3a322fd41a68ef1d3dd8023430', class: "icon", name: inlineNotificationUtils.getInlineNotificationIconName(this.state), color: `notification-${this.state}`, theme: this.theme, "aria-hidden": "true" }), validateProps.h("div", { key: '200d032c58fb90406d0a3c55349288d9ff34abb3', id: bannerId, class: "content", ...inlineNotificationUtils.getContentAriaAttributes(this.state, labelId, descriptionId) }, hasHeading.hasHeading(this.host, this.heading) &&
	            (this.heading ? (validateProps.h(Heading, { id: labelId, class: "heading" }, this.heading)) : (validateProps.h("slot", { name: "heading" }))), validateProps.h("p", { key: '55c0fbd2c24f4a6f197cd483b815baf6bd48a3f9', id: descriptionId, class: "description" }, this.description || validateProps.h("slot", null))), this.actionLabel && (validateProps.h(PrefixedTagNames.pButtonPure, { class: "action", theme: this.theme, icon: this.actionIcon, loading: this.actionLoading, onClick: this.action.emit }, this.actionLabel)), this.hasDismissButton && (validateProps.h(PrefixedTagNames.pButtonPure, { class: "close", type: "button", icon: "close", theme: this.theme, hideLabel: true, "aria-controls": bannerId, onClick: this.dismiss.emit }, "Close notification"))));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pInlineNotification_cjs_entry.p_inline_notification = InlineNotification;

	
	return pInlineNotification_cjs_entry;
}

var pLinkPure_cjs_entry = {};

var throwIfInvalidLinkUsageCf66fcfc = {};

var hasRequiredThrowIfInvalidLinkUsageCf66fcfc;

function requireThrowIfInvalidLinkUsageCf66fcfc () {
	if (hasRequiredThrowIfInvalidLinkUsageCf66fcfc) return throwIfInvalidLinkUsageCf66fcfc;
	hasRequiredThrowIfInvalidLinkUsageCf66fcfc = 1;

	const validateProps = requireValidatePropsF6586828();
	const getOnlyChildOfKindHTMLElementOrThrow = requireGetOnlyChildOfKindHTMLElementOrThrowF7285231();

	const throwIfInvalidLinkUsage = (host, hrefValue) => {
	    let isInvalid = hrefValue && host.children.length > 0;
	    if (!isInvalid || !hrefValue) {
	        try {
	            if (!hrefValue) {
	                getOnlyChildOfKindHTMLElementOrThrow.getOnlyChildOfKindHTMLElementOrThrow(host, 'a');
	            }
	        }
	        catch {
	            isInvalid = true;
	        }
	    }
	    if (isInvalid) {
	        validateProps.throwException(`usage of ${validateProps.getTagNameWithoutPrefix(host)} is not valid. Please provide a href property or a single and direct <a> child element.`);
	    }
	};

	throwIfInvalidLinkUsageCf66fcfc.throwIfInvalidLinkUsage = throwIfInvalidLinkUsage;

	
	return throwIfInvalidLinkUsageCf66fcfc;
}

var hasRequiredPLinkPure_cjs_entry;

function requirePLinkPure_cjs_entry () {
	if (hasRequiredPLinkPure_cjs_entry) return pLinkPure_cjs_entry;
	hasRequiredPLinkPure_cjs_entry = 1;

	Object.defineProperty(pLinkPure_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const linkAriaAttribute = requireLinkAriaAttribute5de11e89();
	const buttonLinkPureUtils = requireButtonLinkPureUtils1db4d1d1();
	const isSsrHydration = requireIsSsrHydration9278b79b();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed2d6d1d94();
	const theme = requireThemeBfc10573();
	const textSize = requireTextSizeBe3fca13();
	const typographyTextWeight = requireTypographyTextWeight02ea3596();
	const throwIfInvalidLinkUsage = requireThrowIfInvalidLinkUsageCf66fcfc();
	const alignLabel = requireAlignLabel7a9d9074();
	const linkButtonPureStyles = requireLinkButtonPureStyles67cba12c();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	requireIsParentOfKindB7d9f81c();
	requireHelperA66adcf2();
	requireGetOnlyChildOfKindHTMLElementOrThrowF7285231();
	requireGetDirectChildHTMLElements31d23fa9();
	requireGetHTMLElements3f1c700f();
	requireTransformSelectorToDirectChildSelectorC1b1f9b0();
	requireColorSchemeStyles4bc3d59c();
	requireHoverMediaQuery5e6deda8();
	requireFontSizeTextXXSmallA02f9c40();
	requireFontSizeTextXSmallE59d35d7();
	requireFontSizeTextSmall508930e5();
	requireFontSizeTextMedium88887ad8();
	requireFontSizeTextLarge05a4bc90();
	requireFontSizeTextXLarge0ecf9ef3();
	requireTextSmallStyle7246779a();
	requireTextShared9135e2ef();
	requireFontLineHeight78b03658();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireSpacingStaticXSmallB7d708b8();

	const getComponentCss = (icon, iconSource, active, stretch, size, hideLabel, alignLabel, underline, hasSlottedAnchor, theme) => {
	    return validateProps.getCss(validateProps.mergeDeep(linkButtonPureStyles.getLinkButtonPureStyles(icon, iconSource, active, false, stretch, size, hideLabel, alignLabel, underline, hasSlottedAnchor, theme), hasSlottedAnchor && {
	        '@global': validateProps.addImportantToEachRule({
	            '::slotted': {
	                '&(a)': {
	                    ...validateProps.getResetInitialStylesForSlottedAnchor,
	                    textDecoration: underline ? 'underline' : 'none',
	                    font: 'inherit',
	                    color: 'inherit',
	                },
	                // The clickable area for Safari < ~15 (<= release date: 2021-10-28) is reduced to the slotted anchor itself,
	                // since Safari prior to this major release does not support pseudo-elements in the slotted context
	                // (https://bugs.webkit.org/show_bug.cgi?id=178237)
	                '&(a)::before': {
	                    content: '""',
	                    position: 'fixed',
	                    insetBlock: linkButtonPureStyles.offsetVertical,
	                    borderRadius: borderRadiusSmall.borderRadiusSmall,
	                    ...validateProps.buildResponsiveStyles(hideLabel, (hideLabelValue) => ({
	                        insetInline: hideLabelValue ? linkButtonPureStyles.offsetVertical : linkButtonPureStyles.offsetHorizontal,
	                    })),
	                },
	                ...validateProps.getFocusJssStyle(theme, { slotted: 'a', pseudo: true, offset: '-2px' }),
	            },
	        }),
	    }));
	};

	const propTypes = {
	    alignLabel: validateProps.AllowedTypes.breakpoint(alignLabel.ALIGN_LABELS),
	    stretch: validateProps.AllowedTypes.breakpoint('boolean'),
	    size: validateProps.AllowedTypes.breakpoint(textSize.TEXT_SIZES),
	    weight: validateProps.AllowedTypes.oneOf(typographyTextWeight.TYPOGRAPHY_TEXT_WEIGHTS),
	    icon: validateProps.AllowedTypes.string,
	    iconSource: validateProps.AllowedTypes.string,
	    underline: validateProps.AllowedTypes.boolean,
	    href: validateProps.AllowedTypes.string,
	    active: validateProps.AllowedTypes.boolean,
	    hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    target: validateProps.AllowedTypes.string,
	    download: validateProps.AllowedTypes.string,
	    rel: validateProps.AllowedTypes.string,
	    aria: validateProps.AllowedTypes.aria(linkAriaAttribute.LINK_ARIA_ATTRIBUTES),
	};
	const LinkPure = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.alignLabel = 'end';
	        this.stretch = false;
	        this.size = 'small';
	        this.weight = 'regular';
	        this.icon = 'arrow-right';
	        this.iconSource = undefined;
	        this.underline = false;
	        this.href = undefined;
	        this.active = false;
	        this.hideLabel = false;
	        this.theme = 'light';
	        this.target = '_self';
	        this.download = undefined;
	        this.rel = undefined;
	        this.aria = undefined;
	    }
	    componentWillLoad() {
	        if (!isSsrHydration.isSsrHydration(this.host)) {
	            // when ssr rendered component is partially hydrated before being rerendered by its parent (e.g. link-tile)
	            // it has no href prop and no slotted anchor, so validation fails
	            throwIfInvalidLinkUsage.throwIfInvalidLinkUsage(this.host, this.href);
	        }
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        buttonLinkPureUtils.warnIfParentIsPTextAndIconIsNone(this.host, this.icon, this.iconSource);
	        const alignLabelDeprecationMap = {
	            left: 'start',
	            right: 'end',
	        };
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'alignLabel', alignLabelDeprecationMap);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.icon, this.iconSource, this.active, this.stretch, this.size, this.hideLabel, this.alignLabel, this.underline, !this.href, this.theme);
	        const TagType = this.href === undefined ? 'span' : 'a';
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        const hasIcon = buttonLinkPureUtils.hasVisibleIcon(this.icon, this.iconSource);
	        return (validateProps.h(TagType, { key: '387972f682083292b8a6e758c52bcbb950848a5a', class: "root", ...(TagType === 'a' && {
	                href: this.href,
	                target: this.target,
	                download: this.download,
	                rel: this.rel,
	                ...validateProps.parseAndGetAriaAttributes(this.aria),
	            }) }, hasIcon && (validateProps.h(PrefixedTagNames.pIcon, { class: "icon", size: "inherit", name: this.icon, source: this.iconSource, theme: this.theme, "aria-hidden": "true" })), validateProps.h("span", { key: '9cbbcb6c6550aff0d0af9a30f02af7dab0efe31f', class: "label" }, validateProps.h("slot", { key: '8e46957fbe92d115588ae779315f259bf039ff97' }))));
	    }
	    static get delegatesFocus() { return true; }
	    get host() { return validateProps.getElement(this); }
	};

	pLinkPure_cjs_entry.p_link_pure = LinkPure;

	
	return pLinkPure_cjs_entry;
}

var pLinkSocial_cjs_entry = {};

var hasRequiredPLinkSocial_cjs_entry;

function requirePLinkSocial_cjs_entry () {
	if (hasRequiredPLinkSocial_cjs_entry) return pLinkSocial_cjs_entry;
	hasRequiredPLinkSocial_cjs_entry = 1;

	Object.defineProperty(pLinkSocial_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const warnIfDeprecatedComponentIsUsed = requireWarnIfDeprecatedComponentIsUsed6c2a81ac();
	const theme = requireThemeBfc10573();
	const throwIfInvalidLinkUsage = requireThrowIfInvalidLinkUsageCf66fcfc();
	const linkStyles = requireLinkStylesA7b4953d();
	requireGetOnlyChildOfKindHTMLElementOrThrowF7285231();
	requireGetDirectChildHTMLElements31d23fa9();
	requireGetHTMLElements3f1c700f();
	requireTransformSelectorToDirectChildSelectorC1b1f9b0();
	requireLinkButtonStylesAafed6b0();
	requireButtonLinkPureUtils1db4d1d1();
	requireIsParentOfKindB7d9f81c();
	requireColorSchemeStyles4bc3d59c();
	requireHoverMediaQuery5e6deda8();
	requireBorderRadiusSmall5f37fc45();
	requireTextSmallStyle7246779a();
	requireTextShared9135e2ef();
	requireFontLineHeight78b03658();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireSpacingStaticSmall2130ed04();

	const propTypes = {
	    icon: validateProps.AllowedTypes.string,
	    iconSource: validateProps.AllowedTypes.string,
	    href: validateProps.AllowedTypes.string,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    target: validateProps.AllowedTypes.string,
	    rel: validateProps.AllowedTypes.string,
	    hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	};
	const LinkSocial = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.icon = undefined;
	        this.iconSource = undefined;
	        this.href = undefined;
	        this.theme = 'light';
	        this.target = '_self';
	        this.rel = undefined;
	        this.hideLabel = false;
	    }
	    componentWillLoad() {
	        throwIfInvalidLinkUsage.throwIfInvalidLinkUsage(this.host, this.href);
	        warnIfDeprecatedComponentIsUsed.warnIfDeprecatedComponentIsUsed(this.host, 'Use p-link component with corresponding social icon instead.');
	        validateProps.doNothing(); // TODO: this function does nothing but treats for unknowns reasons e.g. getThemedColors to be bundled into main chunk
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, linkStyles.getComponentCss, this.icon, this.iconSource, 'primary', this.hideLabel, !this.href, this.theme);
	        const TagType = this.href === undefined ? 'span' : 'a';
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(TagType, { key: 'd647a7241b71a7cb8cfca7e15827fccd077ae7df', class: "root", ...(TagType === 'a' && {
	                href: this.href,
	                target: this.target,
	                rel: this.rel,
	            }) }, validateProps.h(PrefixedTagNames.pIcon, { key: '0cd5edce0647c7c42aa7c8f129275b89c5134b16', class: "icon", size: "inherit", name: this.icon, source: this.iconSource, theme: this.theme, "aria-hidden": "true" }), validateProps.h("span", { key: '62b02c1229e4a629cd2ec427f396405ecb81e3b3', class: "label" }, validateProps.h("slot", { key: '73a26d758cab482aee1540eece4f00db8e9817cd' }))));
	    }
	    static get delegatesFocus() { return true; }
	    get host() { return validateProps.getElement(this); }
	};

	pLinkSocial_cjs_entry.p_link_social = LinkSocial;

	
	return pLinkSocial_cjs_entry;
}

var pLinkTileModelSignature_cjs_entry = {};

var throwIfElementIsNotOfKind4014bcee = {};

var hasRequiredThrowIfElementIsNotOfKind4014bcee;

function requireThrowIfElementIsNotOfKind4014bcee () {
	if (hasRequiredThrowIfElementIsNotOfKind4014bcee) return throwIfElementIsNotOfKind4014bcee;
	hasRequiredThrowIfElementIsNotOfKind4014bcee = 1;

	const validateProps = requireValidatePropsF6586828();

	const throwIfElementIsNotOfKind = (host, element, tagName) => {
	    const prefixedTagName = validateProps.getPrefixedTagNames(host)[validateProps.paramCaseToCamelCase(tagName)];
	    const actualTagName = validateProps.getTagName(element);
	    if (actualTagName !== prefixedTagName) {
	        validateProps.throwException(`child ${actualTagName} of ${validateProps.getTagName(host)} has to be a ${prefixedTagName}.`);
	    }
	};

	throwIfElementIsNotOfKind4014bcee.throwIfElementIsNotOfKind = throwIfElementIsNotOfKind;

	
	return throwIfElementIsNotOfKind4014bcee;
}

var hasRequiredPLinkTileModelSignature_cjs_entry;

function requirePLinkTileModelSignature_cjs_entry () {
	if (hasRequiredPLinkTileModelSignature_cjs_entry) return pLinkTileModelSignature_cjs_entry;
	hasRequiredPLinkTileModelSignature_cjs_entry = 1;

	Object.defineProperty(pLinkTileModelSignature_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const groupDirectionStyles = requireGroupDirectionStylesC4bd8b11();
	const tileBaseStyles = requireTileBaseStyles0dff2b0f();
	const getNamedSlot = requireGetNamedSlotA0cdbdbc();
	const throwIfElementIsNotOfKind = requireThrowIfElementIsNotOfKind4014bcee();
	const fontWeightStyles = requireFontWeightStylesB74e8683();
	const spacingFluidLarge = requireSpacingFluidLarge6087a0f7();
	const spacingFluidMedium = requireSpacingFluidMedium88ab712b();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const spacingFluidSmall = requireSpacingFluidSmall2c6caae7();
	requireTextShared9135e2ef();
	requireFontLineHeight78b03658();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextLarge05a4bc90();
	requireColorSchemeStyles4bc3d59c();
	requireHoverMediaQuery5e6deda8();
	requireTextIconStyles990609fb();
	requireBorderRadiusLargeA0aa3a01();
	requireSpacingStaticMedium94812711();
	requireFontWeightSemiBold4482c830();
	requireFontSizeTextSmall508930e5();

	const getNamedSlotOrThrow = (el, slotName) => {
	    return (getNamedSlot.getNamedSlot(el, slotName) ||
	        validateProps.throwException(`named slot='${slotName}' is missing for component ${validateProps.getTagNameWithoutPrefix(el)}.`));
	};

	// array is redefined instead of using the one from in model-signature
	// because it is created via Object.keys(MODEL_SIGNATURES_MANIFEST) would bundle the entire manifest into both chunks
	const LINK_TILE_MODEL_SIGNATURE_MODELS = [
	    '718',
	    '911',
	    'boxster',
	    'cayenne',
	    'cayman',
	    'macan',
	    'panamera',
	    'taycan',
	    'turbo-s',
	    'turbo',
	];
	const LINK_TILE_MODEL_SIGNATURE_HEADING_TAGS = ['h2', 'h3', 'h4', 'h5', 'h6'];
	const setRequiredPropsOfSlottedLinks = (linkElements) => {
	    linkElements.forEach((link) => {
	        link.theme = 'dark';
	        link.variant = link.slot;
	    });
	};
	const getLinkOrSlottedAnchorElement = (linkElement) => {
	    return linkElement.href ? linkElement : linkElement.querySelector('a');
	};

	const getComponentCss = (aspectRatio, weight, direction, hasDescription) => {
	    const tileBaseStyles$1 = tileBaseStyles.getTileBaseStyles(aspectRatio);
	    return validateProps.getCss({
	        ...tileBaseStyles$1,
	        '@global': {
	            ...tileBaseStyles$1['@global'],
	            [LINK_TILE_MODEL_SIGNATURE_HEADING_TAGS.join(',')]: {
	                margin: validateProps.addImportantToRule(0),
	            },
	        },
	        content: {
	            ...tileBaseStyles$1.content,
	            flexDirection: 'column',
	            bottom: 0,
	            padding: `${spacingFluidLarge.spacingFluidLarge} ${spacingFluidMedium.spacingFluidMedium} ${spacingFluidMedium.spacingFluidMedium}`,
	            ...tileBaseStyles.gradientToTopStyle,
	        },
	        signature: {
	            position: 'absolute',
	            top: spacingFluidMedium.spacingFluidMedium,
	            left: spacingFluidMedium.spacingFluidMedium,
	            right: spacingFluidMedium.spacingFluidMedium,
	            display: 'flex',
	        },
	        heading: {
	            margin: 0,
	            ...tileBaseStyles.textLargeStyle,
	            hyphens: 'inherit',
	            ...validateProps.buildResponsiveStyles(weight, (w) => ({ fontWeight: fontWeightStyles.getFontWeight(w) })),
	        },
	        ...(hasDescription && {
	            description: {
	                margin: '-12px 0 0 ', // TODO: perhaps gap should be overridden instead
	                ...textSmallStyle.textSmallStyle,
	                hyphens: 'inherit',
	            },
	        }),
	        'link-group': {
	            display: 'flex',
	            width: '100%',
	            gap: spacingFluidSmall.spacingFluidSmall,
	            ...validateProps.buildResponsiveStyles(direction, groupDirectionStyles.getGroupDirectionJssStyles),
	        },
	        'link-overlay': {
	            // covers entire tile, used for expanded click-area only
	            position: 'fixed',
	            inset: 0,
	        },
	    });
	};

	const propTypes = {
	    model: validateProps.AllowedTypes.oneOf(LINK_TILE_MODEL_SIGNATURE_MODELS),
	    weight: validateProps.AllowedTypes.breakpoint(tileBaseStyles.TILE_WEIGHTS),
	    aspectRatio: validateProps.AllowedTypes.breakpoint(tileBaseStyles.TILE_ASPECT_RATIOS),
	    heading: validateProps.AllowedTypes.string,
	    description: validateProps.AllowedTypes.string,
	    linkDirection: validateProps.AllowedTypes.breakpoint(groupDirectionStyles.GROUP_DIRECTIONS),
	    headingTag: validateProps.AllowedTypes.oneOf(LINK_TILE_MODEL_SIGNATURE_HEADING_TAGS),
	};
	const LinkTileModelSignature = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.model = '911';
	        this.weight = 'semi-bold';
	        this.aspectRatio = '3:4';
	        this.heading = undefined;
	        this.description = undefined;
	        this.linkDirection = { base: 'column', xs: 'row' };
	        this.headingTag = 'h2';
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        // If we do this earlier than render, there are cases where primaryLink.href is undefined
	        // TODO: Here and in other components, validation happens only on initial render. We could extend this to watch props of the required slots.
	        const primaryLink = getNamedSlotOrThrow(this.host, 'primary');
	        const secondaryLink = getNamedSlotOrThrow(this.host, 'secondary');
	        throwIfElementIsNotOfKind.throwIfElementIsNotOfKind(this.host, primaryLink, 'p-link');
	        throwIfElementIsNotOfKind.throwIfElementIsNotOfKind(this.host, secondaryLink, 'p-link');
	        setRequiredPropsOfSlottedLinks([primaryLink, secondaryLink]);
	        const linkEl = getLinkOrSlottedAnchorElement(primaryLink); // support for slotted a tag within p-link
	        validateProps.attachComponentCss(this.host, getComponentCss, this.aspectRatio, this.weight, this.linkDirection, !!this.description);
	        const overlayLinkProps = {
	            class: 'link-overlay',
	            href: linkEl.href,
	            target: linkEl.target || '_self',
	            download: linkEl.download,
	            rel: linkEl.rel,
	            tabIndex: -1,
	            'aria-hidden': 'true',
	        };
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h("div", { key: 'f7e709fc0e4bbf9fc36e29bd522788cdf63c1941', class: "root" }, validateProps.h("div", { key: '2a672bed78a9b7d3569a8b748cb11c38245a7d9c', class: "image-container" }, validateProps.h("slot", { key: '7c660ee1bb559c6cec36fcb0452a3c83b84dcfb0' })), validateProps.h("div", { key: 'd3ca31c0cab26d26c56c844aa38a33d13acecbb9', class: "signature" }, validateProps.h(PrefixedTagNames.pModelSignature, { key: 'f93bc6f0022a5554fca9f7c9589b3aa7cf718fb2', theme: "dark", model: this.model })), validateProps.h("div", { key: 'f0589e5a4f8cf1de990a6fb138e0496c6286e194', class: "content" }, validateProps.h("a", { key: '4728265ad883ea0160975558f728b556b0669428', ...overlayLinkProps }), validateProps.h(this.headingTag, { key: '3b576df279603a064ede0836a0dd1f77b04fcf9a', class: "heading" }, this.heading), this.description && validateProps.h("p", { class: "description" }, this.description), validateProps.h("div", { key: 'cfc1b77d1ef244d1ddb11395f0ca46904592f11c', class: "link-group", role: "group" }, validateProps.h("slot", { key: '9e59b0a3a614b7d78dd64e480fb4d57e87e9846f', name: "primary" }), validateProps.h("slot", { key: '5410e1bff96341f1975ee0cf0d169d69cd8db062', name: "secondary" })))));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pLinkTileModelSignature_cjs_entry.p_link_tile_model_signature = LinkTileModelSignature;

	
	return pLinkTileModelSignature_cjs_entry;
}

var pLinkTileProduct_cjs_entry = {};

var textXSmallStyle1145ee25 = {};

var hasRequiredTextXSmallStyle1145ee25;

function requireTextXSmallStyle1145ee25 () {
	if (hasRequiredTextXSmallStyle1145ee25) return textXSmallStyle1145ee25;
	hasRequiredTextXSmallStyle1145ee25 = 1;

	const textShared = requireTextShared9135e2ef();
	const fontSizeTextXSmall = requireFontSizeTextXSmallE59d35d7();

	const textXSmallStyle = {
	    font: `${textShared._textFontPartA}${fontSizeTextXSmall.fontSizeTextXSmall}${textShared._textFontPartB}`,
	    ...textShared.fontHyphenationStyle,
	};

	textXSmallStyle1145ee25.textXSmallStyle = textXSmallStyle;

	
	return textXSmallStyle1145ee25;
}

var hasRequiredPLinkTileProduct_cjs_entry;

function requirePLinkTileProduct_cjs_entry () {
	if (hasRequiredPLinkTileProduct_cjs_entry) return pLinkTileProduct_cjs_entry;
	hasRequiredPLinkTileProduct_cjs_entry = 1;

	Object.defineProperty(pLinkTileProduct_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const theme = requireThemeBfc10573();
	const getNamedSlot = requireGetNamedSlotA0cdbdbc();
	const getOnlyChildOfKindHTMLElementOrThrow = requireGetOnlyChildOfKindHTMLElementOrThrowF7285231();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const borderRadiusMedium = requireBorderRadiusMedium758b9411();
	const spacingFluidXSmall = requireSpacingFluidXSmall0dd753ae();
	const borderRadiusLarge = requireBorderRadiusLargeA0aa3a01();
	const spacingFluidSmall = requireSpacingFluidSmall2c6caae7();
	const spacingFluidMedium = requireSpacingFluidMedium88ab712b();
	const headingSmallStyle = requireHeadingSmallStyle0707b97f();
	const textShared = requireTextShared9135e2ef();
	const textXSmallStyle = requireTextXSmallStyle1145ee25();
	const fontSizeTextXXSmall = requireFontSizeTextXXSmallA02f9c40();
	requireGetDirectChildHTMLElements31d23fa9();
	requireGetHTMLElements3f1c700f();
	requireTransformSelectorToDirectChildSelectorC1b1f9b0();
	requireHeadingSharedAa59e66d();
	requireFontLineHeight78b03658();
	requireFontWeightSemiBold4482c830();
	requireFontVariant6ba3b7cb();
	requireFontSizeHeadingSmallA15141a5();
	requireFontSizeTextSmall508930e5();
	requireFontWeightRegularD0c768ac();
	requireFontSizeTextXSmallE59d35d7();

	const textXXSmallStyle = {
	    font: `${textShared._textFontPartA}${fontSizeTextXXSmall.fontSizeTextXXSmall}${textShared._textFontPartB}`,
	    ...textShared.fontHyphenationStyle,
	};

	const TILE_PRODUCT_ASPECT_RATIOS = ['3:4', '9:16'];
	const headerSlot = 'header';
	const anchorSlot = 'anchor';

	const throwIfInvalidLinkTileProductUsage = (host, hrefValue) => {
	    let invalidA11y = false;
	    if (!hrefValue) {
	        if (!getNamedSlot.getNamedSlot(host, anchorSlot)) {
	            throwMissingHrefAndSlottedLinkException(host);
	        }
	        try {
	            const linkElement = getOnlyChildOfKindHTMLElementOrThrow.getOnlyChildOfKindHTMLElementOrThrow(host, 'a');
	            if (!linkElement.textContent.trim() && !linkElement.getAttribute('aria-label')) {
	                invalidA11y = true;
	            }
	        }
	        catch {
	            throwMissingHrefAndSlottedLinkException(host);
	        }
	    }
	    if (invalidA11y) {
	        throwMissingSlottedLinkA11yException(host);
	    }
	};
	const throwMissingHrefAndSlottedLinkException = (host) => validateProps.throwException(`usage of ${validateProps.getTagNameWithoutPrefix(host)} is not valid. Please provide a href property or a single and direct <a> child element in the anchor slot.`);
	const throwMissingSlottedLinkA11yException = (host) => validateProps.throwException(`usage of ${validateProps.getTagNameWithoutPrefix(host)} is not valid. Anchor tag must have slotted text content or an aria-label attribute for accessibility.`);

	const slottedAnchorSelector = `a[slot='${anchorSlot}']`;
	const anchorJssStyle = {
	    position: 'absolute',
	    inset: 0,
	    zIndex: 1, // necessary to be on top of img
	    borderRadius: borderRadiusMedium.borderRadiusMedium,
	};
	const getMultilineEllipsis = (lineClamp) => {
	    return {
	        display: '-webkit-box',
	        WebkitLineClamp: lineClamp,
	        WebkitBoxOrient: 'vertical',
	        overflow: 'hidden',
	    };
	};
	const getComponentCss = (hasLikeButton, hasSlottedAnchor, hasPriceOriginal, hasDescription, aspectRatio, theme) => {
	    const { primaryColor, contrastHighColor, contrastMediumColor, backgroundSurfaceColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, contrastHighColor: contrastHighColorDark, contrastMediumColor: contrastMediumColorDark, backgroundSurfaceColor: backgroundSurfaceColorDark, } = validateProps.getThemedColors('dark');
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                position: 'relative', // needed for ::slotted(a) to overlay correctly
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            [`slot[name="${headerSlot}"]`]: {
	                display: 'block', // to ensure correct like button positioning when slot is unused
	            },
	            ...validateProps.addImportantToEachRule({
	                '::slotted': {
	                    ...(hasSlottedAnchor && {
	                        [`&(${slottedAnchorSelector})`]: {
	                            ...anchorJssStyle,
	                            textIndent: '-999999px', // hide anchor label visually but still usable for a11y (only works in RTL-mode because of `overflow: hidden;` parent)
	                        },
	                        ...validateProps.getFocusJssStyle(theme, { slotted: slottedAnchorSelector }),
	                    }),
	                    [`&([slot="${headerSlot}"])`]: {
	                        display: 'flex',
	                        flexWrap: 'wrap',
	                        gap: spacingFluidXSmall.spacingFluidXSmall,
	                    },
	                    '&(img), &(picture)': {
	                        display: 'block',
	                        width: '100%',
	                        height: '100%',
	                        objectFit: 'cover',
	                        borderRadius: borderRadiusLarge.borderRadiusLarge,
	                        overflow: 'hidden', // needed for picture > img to have correct border-radius
	                    },
	                },
	            }),
	            ...(hasPriceOriginal && {
	                s: {
	                    color: contrastMediumColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        color: contrastMediumColorDark,
	                    }),
	                },
	            }),
	        },
	        root: {
	            display: 'flex',
	            flexDirection: 'column',
	            aspectRatio: '3/4',
	            overflow: 'hidden', // TODO: discussable if we should prevent text to overflow .root, – e.g. it also prevents a popover from being shown correctly
	            boxSizing: 'border-box',
	            borderRadius: borderRadiusMedium.borderRadiusMedium,
	            padding: spacingFluidSmall.spacingFluidSmall,
	            color: primaryColor,
	            backgroundColor: backgroundSurfaceColor,
	            ...validateProps.buildResponsiveStyles(aspectRatio, (ratio) => ({
	                aspectRatio: ratio.replace(':', '/'),
	            })),
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                color: primaryColorDark,
	                backgroundColor: backgroundSurfaceColorDark,
	            }),
	        },
	        ...(!hasSlottedAnchor && {
	            anchor: {
	                ...anchorJssStyle,
	                ...validateProps.getFocusJssStyle(theme),
	            },
	        }),
	        header: {
	            display: 'flex',
	            gap: spacingFluidSmall.spacingFluidSmall,
	            justifyContent: 'space-between',
	            alignItems: 'flex-start',
	        },
	        ...(hasLikeButton && {
	            button: {
	                position: 'relative',
	                zIndex: 2, // Necessary to be on top of anchor link
	            },
	        }),
	        image: {
	            aspectRatio: '8/9',
	            margin: `${spacingFluidSmall.spacingFluidSmall} auto ${spacingFluidXSmall.spacingFluidXSmall}`,
	            overflow: 'hidden',
	            transition: validateProps.getTransition('transform', 'moderate'),
	            [validateProps.getMediaQueryMin('s')]: {
	                padding: `0 ${spacingFluidMedium.spacingFluidMedium}`, // ensures image is not getting to large
	            },
	            ...hoverMediaQuery.hoverMediaQuery({
	                '.root:hover &': {
	                    transform: 'scale3d(1.05,1.05,1.05)',
	                },
	            }),
	        },
	        wrapper: {
	            display: 'flex',
	            flexDirection: 'column',
	            margin: 'auto',
	            textAlign: 'center',
	        },
	        heading: {
	            margin: '0 0 2px', // ua-style reset
	            ...headingSmallStyle.headingSmallStyle,
	            ...textShared.fontHyphenationStyle,
	            ...getMultilineEllipsis(3),
	        },
	        price: {
	            margin: 0, // ua-style reset
	            ...textXSmallStyle.textXSmallStyle,
	            ...(hasPriceOriginal && {
	                display: 'flex',
	                flexWrap: 'wrap',
	                justifyContent: 'center',
	                columnGap: spacingFluidXSmall.spacingFluidXSmall,
	            }),
	        },
	        ...(hasDescription && {
	            description: {
	                margin: 0, // ua-style reset
	                ...textXXSmallStyle,
	                ...getMultilineEllipsis(2),
	                color: contrastHighColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: contrastHighColorDark,
	                }),
	            },
	        }),
	        ...(hasPriceOriginal && {
	            'sr-only': validateProps.getHiddenTextJssStyle(),
	        }),
	    });
	};

	const propTypes = {
	    heading: validateProps.AllowedTypes.string,
	    price: validateProps.AllowedTypes.string,
	    priceOriginal: validateProps.AllowedTypes.string,
	    description: validateProps.AllowedTypes.string,
	    likeButton: validateProps.AllowedTypes.boolean,
	    liked: validateProps.AllowedTypes.boolean,
	    href: validateProps.AllowedTypes.string,
	    aspectRatio: validateProps.AllowedTypes.breakpoint(TILE_PRODUCT_ASPECT_RATIOS),
	    target: validateProps.AllowedTypes.string,
	    rel: validateProps.AllowedTypes.string,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const LinkTileProduct = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.like = validateProps.createEvent(this, "like", 3);
	        this.onLikeClick = () => {
	            this.like.emit({
	                liked: this.liked,
	            });
	        };
	        this.heading = undefined;
	        this.price = undefined;
	        this.priceOriginal = undefined;
	        this.description = undefined;
	        this.likeButton = true;
	        this.liked = false;
	        this.href = undefined;
	        this.aspectRatio = '3:4';
	        this.target = '_self';
	        this.rel = undefined;
	        this.theme = 'light';
	    }
	    componentWillLoad() {
	        throwIfInvalidLinkTileProductUsage(this.host, this.href);
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.likeButton, !this.href, !!this.priceOriginal, !!this.description, this.aspectRatio, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        const headerId = 'header';
	        const headingId = 'heading';
	        const priceId = 'price';
	        const descriptionId = 'description';
	        return (validateProps.h("div", { key: '05fd98de3818639409831385f0ac70aa950fead6', class: "root" }, this.href ? (validateProps.h("a", { class: "anchor", href: this.href, target: this.target, rel: this.rel, "aria-labelledby": `${headingId} ${priceId}`, "aria-describedby": `${headerId} ${descriptionId}` })) : (validateProps.h("slot", { name: anchorSlot })), validateProps.h("div", { key: '5fc0a41edadd95b87848f3b718a2d31ae9a6d547', id: headerId, class: "header" }, validateProps.h("slot", { key: '3a28b707406057b1f64f238608363d3a3353d654', name: headerSlot }), this.likeButton && (validateProps.h(PrefixedTagNames.pButtonPure, { class: "button", type: "button", icon: this.liked ? 'heart-filled' : 'heart', hideLabel: true, onClick: this.onLikeClick, theme: this.theme }, this.liked ? 'Remove from wishlist' : 'Add to wishlist'))), validateProps.h("div", { key: 'b30212dc3c5361620d340247fe60b88fcd2353ac', class: "image" }, validateProps.h("slot", { key: '5575fc633482cac1e5393913be84eed785dd906d' })), validateProps.h("div", { key: '03aa5e6f878ac3511f8c4cba0322975617968dbc', class: "wrapper" }, this.heading && (validateProps.h("h3", { id: headingId, class: "heading" }, this.heading)), this.price && (validateProps.h("p", { id: priceId, class: "price" }, this.priceOriginal ? (validateProps.h(validateProps.Fragment, null, validateProps.h("span", { class: "sr-only" }, "sale price"), this.price, validateProps.h("span", { class: "sr-only" }, "original price"), validateProps.h("s", null, this.priceOriginal))) : (this.price))), this.description && (validateProps.h("p", { id: descriptionId, class: "description" }, this.description)))));
	    }
	    static get delegatesFocus() { return true; }
	    get host() { return validateProps.getElement(this); }
	};

	pLinkTileProduct_cjs_entry.p_link_tile_product = LinkTileProduct;

	
	return pLinkTileProduct_cjs_entry;
}

var pLinkTile_cjs_entry = {};

var hasRequiredPLinkTile_cjs_entry;

function requirePLinkTile_cjs_entry () {
	if (hasRequiredPLinkTile_cjs_entry) return pLinkTile_cjs_entry;
	hasRequiredPLinkTile_cjs_entry = 1;

	Object.defineProperty(pLinkTile_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const linkAriaAttribute = requireLinkAriaAttribute5de11e89();
	const linkTileUtils = requireLinkTileUtilsF366cfed();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed2d6d1d94();
	requireFontWeightStylesB74e8683();
	requireFontWeightRegularD0c768ac();
	requireFontWeightSemiBold4482c830();
	requireTileBaseStyles0dff2b0f();
	requireTextShared9135e2ef();
	requireFontLineHeight78b03658();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextLarge05a4bc90();
	requireColorSchemeStyles4bc3d59c();
	requireHoverMediaQuery5e6deda8();
	requireTextIconStyles990609fb();
	requireBorderRadiusLargeA0aa3a01();
	requireSpacingStaticMedium94812711();
	requireFontSizeTextMedium88887ad8();
	requireSpacingFluidMedium88ab712b();
	requireSpacingFluidLarge6087a0f7();
	requireThemeBfc10573();
	requireHelperA66adcf2();

	const getComponentCss = (...args) => {
	    return validateProps.getCss({
	        ...linkTileUtils.getButtonLinkTileStyles(...args),
	        'link-overlay': {
	            // covers entire tile, used for expanded click-area only
	            position: 'fixed',
	            inset: 0,
	        },
	    });
	};

	const propTypes = {
	    ...linkTileUtils.sharedTilePropTypes,
	    weight: validateProps.AllowedTypes.breakpoint(linkTileUtils.LINK_TILE_WEIGHTS),
	    href: validateProps.AllowedTypes.string,
	    target: validateProps.AllowedTypes.string,
	    download: validateProps.AllowedTypes.string,
	    rel: validateProps.AllowedTypes.string,
	    aria: validateProps.AllowedTypes.aria(linkAriaAttribute.LINK_ARIA_ATTRIBUTES),
	};
	const LinkTile = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.size = 'default';
	        this.weight = 'semi-bold';
	        this.background = 'dark';
	        this.aspectRatio = '4:3';
	        this.label = undefined;
	        this.description = undefined;
	        this.align = 'bottom';
	        this.gradient = true;
	        this.compact = false;
	        this.href = undefined;
	        this.target = '_self';
	        this.download = undefined;
	        this.rel = undefined;
	        this.aria = undefined;
	    }
	    componentWillLoad() {
	        linkTileUtils.throwIfAlignTopAndNotCompact(this.host, this.align, this.compact);
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        this.compact = validateProps.parseJSON(this.compact); // parsing the value just once per lifecycle
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'weight', {
	            semibold: 'semi-bold',
	        });
	        validateProps.attachComponentCss(this.host, getComponentCss, this.aspectRatio, this.size, this.weight, // potentially breakpoint customizable, so we can't easily access the deprecation map
	        this.background, this.align, this.compact, this.gradient);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        const linkProps = {
	            theme: this.background,
	            variant: 'secondary',
	            aria: this.aria,
	        };
	        const sharedLinkProps = {
	            href: this.href,
	            target: this.target,
	            download: this.download,
	            rel: this.rel,
	        };
	        const link = (validateProps.h(PrefixedTagNames.pLink, { ...sharedLinkProps, ...linkProps, key: "link-or-button", class: "link-or-button" }, this.label));
	        const linkPure = (validateProps.h(PrefixedTagNames.pLinkPure, { ...sharedLinkProps, ...linkProps, key: "link-or-button-pure", class: "link-or-button-pure", hideLabel: true, icon: "arrow-right" }, this.label));
	        return (validateProps.h("div", { key: 'c3581e529d14eb479f476462dc49f6a82993f556', class: "root" }, validateProps.h("div", { key: '5357a2e7dd6db758fc00129b9faaf8fcf2f83e2d', class: "image-container" }, validateProps.h("slot", { key: '394e225896f15623e076feb88943933524171461' })), validateProps.h("div", { key: 'ba64c4ba28c7a041d91bcdfd6db0876ffb2ea1e2', class: "content" }, validateProps.h("a", { key: '7e27f4b3dca9a90143b879a75ce943d1184cfcf4', ...sharedLinkProps, class: "link-overlay", tabIndex: -1, "aria-hidden": "true" }), validateProps.h("p", { key: 'dc9e56b522799fdb3e3cd5f6f45161d082c7e808' }, this.description), typeof this.compact === 'boolean' ? (this.compact ? linkPure : link) : [linkPure, link])));
	    }
	    static get delegatesFocus() { return true; }
	    get host() { return validateProps.getElement(this); }
	};

	pLinkTile_cjs_entry.p_link_tile = LinkTile;

	
	return pLinkTile_cjs_entry;
}

var pLink_cjs_entry = {};

var hasRequiredPLink_cjs_entry;

function requirePLink_cjs_entry () {
	if (hasRequiredPLink_cjs_entry) return pLink_cjs_entry;
	hasRequiredPLink_cjs_entry = 1;

	Object.defineProperty(pLink_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const linkAriaAttribute = requireLinkAriaAttribute5de11e89();
	const buttonLinkPureUtils = requireButtonLinkPureUtils1db4d1d1();
	const isSsrHydration = requireIsSsrHydration9278b79b();
	const theme = requireThemeBfc10573();
	const throwIfInvalidLinkUsage = requireThrowIfInvalidLinkUsageCf66fcfc();
	const linkButtonVariant = requireLinkButtonVariant3104b925();
	const linkStyles = requireLinkStylesA7b4953d();
	requireIsParentOfKindB7d9f81c();
	requireGetOnlyChildOfKindHTMLElementOrThrowF7285231();
	requireGetDirectChildHTMLElements31d23fa9();
	requireGetHTMLElements3f1c700f();
	requireTransformSelectorToDirectChildSelectorC1b1f9b0();
	requireLinkButtonStylesAafed6b0();
	requireColorSchemeStyles4bc3d59c();
	requireHoverMediaQuery5e6deda8();
	requireBorderRadiusSmall5f37fc45();
	requireTextSmallStyle7246779a();
	requireTextShared9135e2ef();
	requireFontLineHeight78b03658();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireSpacingStaticSmall2130ed04();

	const propTypes = {
	    variant: validateProps.AllowedTypes.oneOf(linkButtonVariant.LINK_BUTTON_VARIANTS),
	    icon: validateProps.AllowedTypes.string,
	    iconSource: validateProps.AllowedTypes.string,
	    href: validateProps.AllowedTypes.string,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    target: validateProps.AllowedTypes.string,
	    download: validateProps.AllowedTypes.string,
	    rel: validateProps.AllowedTypes.string,
	    hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	    aria: validateProps.AllowedTypes.aria(linkAriaAttribute.LINK_ARIA_ATTRIBUTES),
	};
	const Link = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.variant = 'primary';
	        this.icon = 'none';
	        this.iconSource = undefined;
	        this.href = undefined;
	        this.theme = 'light';
	        this.target = '_self';
	        this.download = undefined;
	        this.rel = undefined;
	        this.hideLabel = false;
	        this.aria = undefined;
	    }
	    componentWillLoad() {
	        if (!isSsrHydration.isSsrHydration(this.host)) {
	            // when ssr rendered component is partially hydrated before being rerendered by its parent (e.g. link-tile)
	            // it has no href prop and no slotted anchor, so validation fails
	            throwIfInvalidLinkUsage.throwIfInvalidLinkUsage(this.host, this.href);
	        }
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, linkStyles.getComponentCss, this.icon, this.iconSource, this.variant, this.hideLabel, !this.href, this.theme);
	        const TagType = this.href === undefined ? 'span' : 'a';
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(TagType, { key: 'fe89db9c73da6ef39a4deab011fa55c1c16869e6', class: "root", ...(TagType === 'a' && {
	                href: this.href,
	                target: this.target,
	                download: this.download,
	                rel: this.rel,
	                ...validateProps.parseAndGetAriaAttributes(this.aria),
	            }) }, buttonLinkPureUtils.hasVisibleIcon(this.icon, this.iconSource) && (validateProps.h(PrefixedTagNames.pIcon, { class: "icon", size: "inherit", name: this.iconSource ? undefined : this.icon, source: this.iconSource, theme: this.theme, "aria-hidden": "true" })), validateProps.h("span", { key: '82ee5abe943838a47cb82f11f3702776e5b28f7f', class: "label" }, validateProps.h("slot", { key: 'b9c3ee8cc13c3a418ab844ca4b389963093f3122' }))));
	    }
	    static get delegatesFocus() { return true; }
	    get host() { return validateProps.getElement(this); }
	};

	pLink_cjs_entry.p_link = Link;

	
	return pLink_cjs_entry;
}

var pMarque_cjs_entry = {};

var hasRequiredPMarque_cjs_entry;

function requirePMarque_cjs_entry () {
	if (hasRequiredPMarque_cjs_entry) return pMarque_cjs_entry;
	hasRequiredPMarque_cjs_entry = 1;

	Object.defineProperty(pMarque_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const getCDNBaseURL = requireGetCDNBaseURLE7722df3();
	const linkAriaAttribute = requireLinkAriaAttribute5de11e89();
	const warnIfDeprecatedComponentIsUsed = requireWarnIfDeprecatedComponentIsUsed6c2a81ac();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();

	const MARQUES_MANIFEST = { "porscheMarqueTrademark": { "medium": { "1x": { "png": "porsche-marque-trademark.medium.min.da075315857e239ff46bf4c150648ff0@1x.png", "webp": "porsche-marque-trademark.medium.min.5c6af9aa7946fea34f60c8f8c95d0188@1x.webp" }, "2x": { "png": "porsche-marque-trademark.medium.min.aa801f42028b1c385a5e26ae115da598@2x.png", "webp": "porsche-marque-trademark.medium.min.fff6e9b91481cc5b1fc6c9b62987ccaf@2x.webp" }, "3x": { "png": "porsche-marque-trademark.medium.min.824818d15eaf445f50e0a2391613f214@3x.png", "webp": "porsche-marque-trademark.medium.min.f67092ff6b5f4ecb4add73d6ae153db0@3x.webp" } }, "small": { "1x": { "png": "porsche-marque-trademark.small.min.020244b41a29323e2a7932a264514cdf@1x.png", "webp": "porsche-marque-trademark.small.min.783639706bead66b2d56e3b8b64bd61f@1x.webp" }, "2x": { "png": "porsche-marque-trademark.small.min.92184fae44511ceda8320443c17110b1@2x.png", "webp": "porsche-marque-trademark.small.min.760a57efa93d4e7e16e26128ec7ead46@2x.webp" }, "3x": { "png": "porsche-marque-trademark.small.min.fd545cea4298f5d797246d5805711646@3x.png", "webp": "porsche-marque-trademark.small.min.1726036a7829347e1e24d1eb54fc0d64@3x.webp" } } }, "porscheMarque": { "medium": { "1x": { "png": "porsche-marque.medium.min.a98627440b05154565f9f9dfc1ad6187@1x.png", "webp": "porsche-marque.medium.min.fa908e4dfdc5536b0e933e1670d20e1f@1x.webp" }, "2x": { "png": "porsche-marque.medium.min.089d6dd560fff7a2bf613ae6d528990e@2x.png", "webp": "porsche-marque.medium.min.7f0893dc57f2607a2cb0b817d96cb985@2x.webp" }, "3x": { "png": "porsche-marque.medium.min.2cb874345ef290831c929f6caabfeef8@3x.png", "webp": "porsche-marque.medium.min.3534cf066b4e2e737dca62de495f9616@3x.webp" } }, "small": { "1x": { "png": "porsche-marque.small.min.ac2042736af5512cf547c89fa7924c4f@1x.png", "webp": "porsche-marque.small.min.005debed5bf72cf0a9a791b1521f5e1d@1x.webp" }, "2x": { "png": "porsche-marque.small.min.22f1e9dc90399d9a5287eda689b60dba@2x.png", "webp": "porsche-marque.small.min.df4317325d04ffef28c7839aa6d499a0@2x.webp" }, "3x": { "png": "porsche-marque.small.min.49209245f04eadef8817b9bbae80d3e1@3x.png", "webp": "porsche-marque.small.min.cfd6149aaa3bc5b3b522538e5f650890@3x.webp" } } }, "porscheMarque75": { "medium": { "1x": { "png": "porsche-marque75.medium.min.0a02e2256062de963f2fef2c02d20200@1x.png", "webp": "porsche-marque75.medium.min.99b2d657558f0531d639782974e8fd06@1x.webp" }, "2x": { "png": "porsche-marque75.medium.min.1d41ecfb8f5277d3f4bd65d25d22eea3@2x.png", "webp": "porsche-marque75.medium.min.e32580cd1ac179e354ed8fcb31694168@2x.webp" }, "3x": { "png": "porsche-marque75.medium.min.373bcb5f89d31c8b6084e66e902b9f4c@3x.png", "webp": "porsche-marque75.medium.min.4a003d1e5e81db062bf92d52ba797087@3x.webp" } }, "small": { "1x": { "png": "porsche-marque75.small.min.f5b37fe12cd4487432ff77fdd8469f7d@1x.png", "webp": "porsche-marque75.small.min.146b06cffe2b11c07f3113a51f337b98@1x.webp" }, "2x": { "png": "porsche-marque75.small.min.20d86908f2190640a6f24fce1ee49035@2x.png", "webp": "porsche-marque75.small.min.025770f8db54857874c130999b370ed8@2x.webp" }, "3x": { "png": "porsche-marque75.small.min.e89b13e14a088a273107bf1057f7f67d@3x.png", "webp": "porsche-marque75.small.min.a725d2ec7bd07be17afd8feb2589b156@3x.webp" } } } };

	const MARQUE_VARIANTS = ['75-years', 'default'];
	const getInnerManifest = (variant, trademark) => MARQUES_MANIFEST[variant === '75-years' ? 'porscheMarque75' : `porscheMarque${trademark ? 'Trademark' : ''}`];
	const buildSrcSet = (innerManifest, size, format) => 
	// eslint-disable-next-line @typescript-eslint/no-unsafe-argument
	Object.entries(innerManifest[size])
	    .map(([resolution, fileName]) => `${getCDNBaseURL.getCDNBaseURL()}/marque/${fileName[format]} ${resolution}`)
	    .join();
	const buildImgSrc = (innerManifest) => `${getCDNBaseURL.getCDNBaseURL()}/marque/${innerManifest.medium['2x'].png}`;

	const baseSizes = {
	    small: {
	        width: '100px',
	        height: '60px',
	    },
	    medium: {
	        width: '120px',
	        height: '72px',
	    },
	};
	const getComponentCss = (size) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                position: 'relative',
	                display: 'inline-flex',
	                verticalAlign: 'top',
	                ...validateProps.addImportantToEachRule({
	                    outline: 0,
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            a: {
	                display: 'block',
	                textDecoration: 'none',
	                outline: 0,
	                '&::before': {
	                    // needs to be defined always to have correct custom click area
	                    content: '""',
	                    position: 'absolute',
	                    inset: 0,
	                    borderRadius: '1px',
	                },
	                ...validateProps.getFocusJssStyle('light', { pseudo: true }), // TODO: we need to support theme
	            },
	            picture: {
	                display: 'block',
	                ...(size === 'responsive'
	                    ? {
	                        ...baseSizes.small,
	                        [validateProps.getMediaQueryMin('l')]: baseSizes.medium,
	                    }
	                    : baseSizes[size]),
	            },
	            img: {
	                display: 'block',
	                width: '100%',
	                height: 'auto',
	            },
	        },
	    });
	};

	const MARQUE_SIZES = ['responsive', 'small', 'medium'];

	const propTypes = {
	    trademark: validateProps.AllowedTypes.boolean,
	    variant: validateProps.AllowedTypes.oneOf(MARQUE_VARIANTS),
	    size: validateProps.AllowedTypes.oneOf(MARQUE_SIZES),
	    href: validateProps.AllowedTypes.string,
	    target: validateProps.AllowedTypes.string,
	    aria: validateProps.AllowedTypes.aria(linkAriaAttribute.LINK_ARIA_ATTRIBUTES),
	};
	const Marque = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.trademark = true;
	        this.variant = 'default';
	        this.size = 'responsive';
	        this.href = undefined;
	        this.target = '_self';
	        this.aria = undefined;
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedComponentIsUsed.warnIfDeprecatedComponentIsUsed(this.host, 'Please use new p-wordmark component instead.');
	        validateProps.attachComponentCss(this.host, getComponentCss, this.size);
	        const innerManifest = getInnerManifest(this.variant, this.trademark);
	        const mediumMedia = `(min-width: ${validateProps.breakpoint.l}px)`;
	        const picture = window.PDS_SKIP_FETCH ? undefined :  (validateProps.h("picture", { key: '7154c646e93fde297bcb3dcba9fa003cfa012fe0' }, this.size === 'responsive'
	            ? [
	                validateProps.h("source", { key: "medium-webp", srcSet: buildSrcSet(innerManifest, 'medium', 'webp'), media: mediumMedia, type: "image/webp" }),
	                validateProps.h("source", { key: "medium-png", srcSet: buildSrcSet(innerManifest, 'medium', 'png'), media: mediumMedia, type: "image/png" }),
	                validateProps.h("source", { key: "small-webp", srcSet: buildSrcSet(innerManifest, 'small', 'webp'), type: "image/webp" }),
	                validateProps.h("source", { key: "small-png", srcSet: buildSrcSet(innerManifest, 'small', 'png'), type: "image/png" }),
	            ]
	            : [
	                validateProps.h("source", { key: "webp", srcSet: buildSrcSet(innerManifest, this.size, 'webp'), type: "image/webp" }),
	                validateProps.h("source", { key: "png", srcSet: buildSrcSet(innerManifest, this.size, 'png'), type: "image/png" }),
	            ], validateProps.h("img", { key: '636711426085a4cde4660d1742484fe5a14b41c9', src: buildImgSrc(innerManifest), alt: "Porsche" })));
	        return (validateProps.h(validateProps.Host, { key: '1d97b4f2827a29b301051d423bb64ec6ec35341a' }, this.href === undefined ? (picture) : (validateProps.h("a", { href: this.href, target: this.target, ...validateProps.parseAndGetAriaAttributes(this.aria) }, picture))));
	    }
	    static get delegatesFocus() { return true; }
	    get host() { return validateProps.getElement(this); }
	};

	pMarque_cjs_entry.p_marque = Marque;

	
	return pMarque_cjs_entry;
}

var pModal_cjs_entry = {};

var hasRequiredPModal_cjs_entry;

function requirePModal_cjs_entry () {
	if (hasRequiredPModal_cjs_entry) return pModal_cjs_entry;
	hasRequiredPModal_cjs_entry = 1;

	Object.defineProperty(pModal_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const modalFlyoutUtils = requireModalFlyoutUtils950041a2();
	const hasNamedSlot = requireHasNamedSlotA96fd22a();
	const hasHeading = requireHasHeading6f9fd2ca();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed0dc3288b();
	const setScrollLock = requireSetScrollLock68edfbd1();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const constants = requireConstantsCa271244();
	const headingShared = requireHeadingSharedAa59e66d();
	const fontSizeHeadingLarge = requireFontSizeHeadingLargeC355151d();
	const gridExtendedOffsetBase = requireGridExtendedOffsetBaseFb9830f6();
	const borderRadiusMedium = requireBorderRadiusMedium758b9411();
	requireGetHTMLElements3f1c700f();
	requireGetNamedSlotA0cdbdbc();
	requireHelperA66adcf2();
	requireFontLineHeight78b03658();
	requireFontWeightSemiBold4482c830();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextLarge05a4bc90();

	const warnIfAriaAndHeadingPropsAreUndefined = (host, hasHeading, aria) => {
	    if (!hasHeading && !aria) {
	        validateProps.consoleWarn(`heading or aria has to be set via property for component ${validateProps.getTagNameWithoutPrefix(host)} in order to ensure accessibility.`);
	    }
	};

	const headingLargeStyle = {
	    font: `${headingShared._headingFontPartA}${fontSizeHeadingLarge.fontSizeHeadingLarge}${headingShared._headingFontPartB}`,
	};

	const unpackChildren = (el) => {
	    return Array.from(el.children, (child) => child.children ? [child].concat(unpackChildren(child)) : child)
	        .flat()
	        .map((child) => (child.shadowRoot ? [child].concat(unpackChildren(child.shadowRoot)) : child))
	        .flat();
	};
	// TODO: could be extended by audio[controls], video[controls], [contenteditable]:not([contenteditable="false"]) or iframe
	const isFocusableElement = (el) => {
	    const { nodeName } = el;
	    return (((nodeName === 'INPUT' && el.type !== 'hidden') ||
	        nodeName === 'TEXTAREA' ||
	        nodeName === 'SELECT' ||
	        nodeName === 'BUTTON' ||
	        (nodeName === 'A' && !!el.href)) &&
	        el.tabIndex >= 0 &&
	        !el.disabled);
	};
	const getFirstAndLastFocusableElement = (host, closeButton) => {
	    const focusableElements = (closeButton ? [closeButton] : []).concat(unpackChildren(host).filter(isFocusableElement));
	    return [focusableElements[0], focusableElements.pop()];
	};
	let documentKeydownListener;
	const setFocusTrap = (host, isOpen, firstFocusableElement, closeBtn, // irrelevant for disconnectedCallback
	closeFn // irrelevant for disconnectedCallback
	) => {
	    let focusableElements = [];
	    document.removeEventListener('keydown', documentKeydownListener);
	    if (isOpen) {
	        focusableElements = getFirstAndLastFocusableElement(host, closeBtn);
	        documentKeydownListener = (e) => {
	            const { key, shiftKey } = e;
	            const { activeElement } = host.shadowRoot;
	            if (key === 'Escape') {
	                closeFn();
	            }
	            else if (key === 'Tab') {
	                if (shiftKey && activeElement === firstFocusableElement) {
	                    // when component is opened initially, the dialog is focused and shift + tab would break out of cycle
	                    e.preventDefault();
	                    focusableElements[1]?.focus();
	                }
	                else if (!focusableElements.filter((x) => x).length) {
	                    // if we don't have any focusableElements we need to prevent Tab here
	                    e.preventDefault();
	                }
	                // all other cases respect the natural tab order
	                // the cycle itself is accomplished within setFirstAndLastFocusableElementKeydownListener
	            }
	        };
	        document.addEventListener('keydown', documentKeydownListener);
	    }
	    setFirstAndLastFocusableElementKeydownListener(focusableElements);
	};
	/** cache of previous first and last focusable element so we are able to remove them again */
	let FOCUSABLE_ELEMENT_CACHE = [];
	/** cache of previous event handler pair so we are able to remove them again */
	let KEYDOWN_EVENT_HANDLER_CACHE = [];
	const setFirstAndLastFocusableElementKeydownListener = (focusableElements) => {
	    // remove previous handlers if there are any
	    if (FOCUSABLE_ELEMENT_CACHE.length) {
	        FOCUSABLE_ELEMENT_CACHE.forEach((el, idx) => el.removeEventListener('keydown', KEYDOWN_EVENT_HANDLER_CACHE[idx]));
	    }
	    // create, apply and save new handlers for future removal
	    if (focusableElements.filter((x) => x).length) {
	        FOCUSABLE_ELEMENT_CACHE = [...focusableElements]; // prevent mutation
	        KEYDOWN_EVENT_HANDLER_CACHE = focusableElements.map((el, idx) => {
	            const handler = (e) => {
	                if (e.key === 'Tab' && ((idx === 0 && e.shiftKey) || (idx === 1 && !e.shiftKey))) {
	                    e.preventDefault();
	                    focusableElements[idx === 0 ? 1 : 0].focus();
	                }
	            };
	            el.addEventListener('keydown', handler);
	            return handler;
	        });
	    }
	};

	const MODAL_ARIA_ATTRIBUTES = ['aria-label'];
	const clickStartedInScrollbarTrack = (host, e) => {
	    const hasScrollbars = host.scrollHeight > host.offsetHeight;
	    if (!hasScrollbars) {
	        return false;
	    }
	    else {
	        const hasOverlayScrollbars = host.scrollWidth === host.offsetWidth;
	        return e.clientX > host.clientWidth - (hasOverlayScrollbars ? 17 : 0);
	    }
	};

	const cssVariableSpacingTop = '--p-modal-spacing-top';
	const cssVariableSpacingBottom = '--p-modal-spacing-bottom';
	const mediaQueryXl = validateProps.getMediaQueryMin('xl');
	const { primaryColor: darkThemePrimaryColor, contrastHighColor: darkThemeContrastHighColor } = validateProps.getThemedColors('dark');
	const stretchToFullModalWidthClassName = 'stretch-to-full-modal-width';
	const marginTopBottomFallback = 'clamp(16px, 7vh, 192px)';
	const marginTopBottomXlandXxlFallback = 'min(192px, 10vh)';
	const footerShadowClass = 'footer--shadow';
	const getFullscreenJssStyles = (fullscreen) => {
	    return fullscreen
	        ? {
	            minWidth: '100%',
	            maxWidth: 'none',
	            minHeight: '100%',
	            margin: 0,
	            borderRadius: 0,
	        }
	        : {
	            minWidth: '276px', // on viewport 320px: calc(${gridColumnWidthBase} * 6 + ${gridGap} * 5)
	            maxWidth: '1535.5px', // on viewport 1920px: `calc(${gridColumnWidthXXL} * 14 + ${gridGap} * 13)`
	            minHeight: 'auto',
	            margin: `var(${cssVariableSpacingTop},${marginTopBottomFallback}) ${gridExtendedOffsetBase.gridExtendedOffsetBase} var(${cssVariableSpacingBottom},${marginTopBottomFallback})`,
	            borderRadius: borderRadiusMedium.borderRadiusMedium,
	        };
	};
	const isFullscreenForXl = (fullscreen) => {
	    const fullscreenParsed = validateProps.parseJSON(fullscreen);
	    if (typeof fullscreenParsed === 'boolean') {
	        return fullscreenParsed;
	    }
	    else {
	        const entries = Object.entries(fullscreenParsed);
	        const [lastTrueBreakpoint] = entries.filter(([, val]) => val).pop() || [];
	        const [lastFalseBreakpoint] = entries.filter(([, val]) => !val).pop() || [];
	        return validateProps.breakpoints.indexOf(lastTrueBreakpoint) > validateProps.breakpoints.indexOf(lastFalseBreakpoint);
	    }
	};
	const getSlottedJssStyle = (marginValue, hasHeader, hasDismissButton) => {
	    const marginPx = `${-marginValue}px`;
	    return {
	        [`&(.${stretchToFullModalWidthClassName})`]: {
	            width: `calc(100% + ${marginValue * 2}px)`,
	            margin: `0 ${marginPx}`,
	        },
	        ...(!hasHeader && {
	            [`&(.${stretchToFullModalWidthClassName}:first-child)`]: {
	                marginTop: hasDismissButton ? `${-marginValue / 16}rem` : marginPx,
	            },
	        }),
	        [`&(.${stretchToFullModalWidthClassName}:last-child)`]: {
	            marginBottom: marginPx,
	        },
	    };
	};
	const getComponentCss = (isOpen, backdrop, isFullscreen, hasDismissButton, hasHeader, hasFooter, theme) => {
	    const { primaryColor, backgroundColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, backgroundColor: backgroundColorDark } = validateProps.getThemedColors('dark');
	    const isFullscreenForXlAndXxl = isFullscreenForXl(isFullscreen);
	    const duration = isOpen ? 'moderate' : 'short';
	    const easing = isOpen ? 'in' : 'out';
	    const contentPadding = '32px';
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                overflowY: 'auto', // overrideable
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                    ...validateProps.getBackdropJssStyle(isOpen, constants.MODAL_Z_INDEX, theme, duration, backdrop),
	                }),
	            },
	            '::slotted': validateProps.addImportantToEachRule(validateProps.mergeDeep(getSlottedJssStyle(32, hasHeader, hasDismissButton), validateProps.buildResponsiveStyles(isFullscreen, (fullscreenValue) => ({
	                [`&(.${stretchToFullModalWidthClassName}`]: {
	                    '&:first-child)': {
	                        borderRadius: fullscreenValue ? 0 : '8px 8px 0 0',
	                    },
	                    '&:last-child)': {
	                        borderRadius: fullscreenValue ? 0 : '0 0 8px 8px',
	                    },
	                },
	            })))),
	            h2: {
	                ...headingLargeStyle,
	                margin: 0,
	                color: primaryColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: primaryColorDark,
	                }),
	            },
	        },
	        'scroll-container': {
	            display: 'flex',
	            inset: 0, // TODO: is this still needed?
	            height: '100%',
	            overflowY: 'inherit',
	            alignItems: 'center',
	            justifyContent: 'center',
	            flexWrap: 'wrap',
	        },
	        root: validateProps.mergeDeep({
	            color: primaryColor, // enables color inheritance for slotted content
	            position: 'relative',
	            boxSizing: 'border-box',
	            transform: isOpen ? 'translateY(0%)' : 'translateY(25%)',
	            opacity: isOpen ? 1 : 0,
	            transition: `${validateProps.getTransition('opacity', duration, easing)}, ${validateProps.getTransition('transform', duration, easing)}`,
	            paddingTop: hasDismissButton ? '2rem' : contentPadding, // rem value needed to prevent overlapping of close button and contents in scaling mode
	            ...(!hasFooter && { paddingBottom: contentPadding }),
	            background: backgroundColor,
	            outline: validateProps.isHighContrastMode ? '1px solid transparent' : 0,
	            // TODO: getFocusJssStyle() can't be re-used atm, but as soon as component is refactored to `<dialog />` then no
	            //  focus should be necessary at all because focus is auto forwarded to dismiss button.
	            // ::after to be above sticky footer without z-index games
	            '&:focus::after': {
	                content: '""',
	                position: 'fixed',
	                border: `${validateProps.borderWidthBase} solid`,
	                pointerEvents: 'none', // fix text selection in focus state
	                ...validateProps.buildResponsiveStyles(isFullscreen, (fullscreenValue) => ({
	                    borderRadius: fullscreenValue ? 0 : '12px',
	                    borderColor: fullscreenValue ? primaryColor : darkThemePrimaryColor,
	                    inset: fullscreenValue ? 0 : '-4px',
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        borderColor: darkThemePrimaryColor,
	                    }),
	                })),
	            },
	            '&:not(:focus-visible)::before': {
	                border: 0,
	            },
	            [mediaQueryXl]: {
	                margin: isFullscreenForXlAndXxl
	                    ? 0
	                    : `var(${cssVariableSpacingTop},${marginTopBottomXlandXxlFallback}) ${gridExtendedOffsetBase.gridExtendedOffsetBase} var(${cssVariableSpacingBottom},${marginTopBottomXlandXxlFallback})`,
	            },
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                color: primaryColorDark,
	                background: backgroundColorDark,
	            }),
	        }, validateProps.buildResponsiveStyles(isFullscreen, getFullscreenJssStyles) // potentially needs to be merged with mediaQueryXl
	        ),
	        ...(hasHeader && {
	            header: {
	                padding: `0 ${contentPadding} 8px`,
	            },
	        }),
	        content: {
	            ...(hasFooter && {
	                position: 'relative', // to make sure content isn't above sticky footer, but might affect consumer's absolute positioning
	                zIndex: 0,
	            }),
	            padding: `0 ${contentPadding}`,
	        },
	        ...(hasFooter && {
	            footer: {
	                position: 'sticky',
	                background: backgroundColor,
	                padding: contentPadding,
	                bottom: 0,
	                borderBottomLeftRadius: borderRadiusMedium.borderRadiusMedium,
	                borderBottomRightRadius: borderRadiusMedium.borderRadiusMedium,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    background: backgroundColorDark,
	                }),
	            },
	            [footerShadowClass]: {
	                boxShadow: `${validateProps.isThemeDark(theme) ? modalFlyoutUtils.scrollShadowColorDark : modalFlyoutUtils.scrollShadowColor} 0 -5px 10px`,
	                clipPath: 'inset(-20px 0 0 0)', // crop leaking box-shadow on left and right side
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    boxShadow: `${modalFlyoutUtils.scrollShadowColorDark} 0 -5px 10px`,
	                }),
	            },
	        }),
	        ...(hasDismissButton && {
	            controls: {
	                position: 'absolute',
	                top: '8px',
	                right: '8px',
	                left: '8px',
	                display: 'flex',
	                justifyContent: 'flex-end',
	                zIndex: 1, // To assure controls are on top when using stretchToFullModalWidthClassName and transformed slotted content
	            },
	            dismiss: {
	                border: `2px solid ${backgroundColor}`, // needed to enlarge button slightly without affecting the hover area (are equal now).
	                borderRadius: '4px',
	                background: backgroundColor,
	                ...hoverMediaQuery.hoverMediaQuery({
	                    '&:hover': {
	                        background: darkThemeContrastHighColor,
	                        borderColor: darkThemeContrastHighColor,
	                    },
	                }),
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    background: backgroundColorDark,
	                    borderColor: backgroundColorDark,
	                }),
	            },
	        }),
	    });
	};

	const propTypes = {
	    open: validateProps.AllowedTypes.boolean,
	    disableCloseButton: validateProps.AllowedTypes.boolean,
	    dismissButton: validateProps.AllowedTypes.boolean,
	    disableBackdropClick: validateProps.AllowedTypes.boolean,
	    heading: validateProps.AllowedTypes.string,
	    backdrop: validateProps.AllowedTypes.oneOf(validateProps.BACKDROPS),
	    fullscreen: validateProps.AllowedTypes.breakpoint('boolean'),
	    aria: validateProps.AllowedTypes.aria(MODAL_ARIA_ATTRIBUTES),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Modal = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.close = validateProps.createEvent(this, "close", 3);
	        this.dismiss = validateProps.createEvent(this, "dismiss", 3);
	        // eslint-disable-next-line @typescript-eslint/member-ordering
	        this.onScroll = validateProps.throttle(100, () => {
	            // using an intersection observer would be so much easier but very tricky with the current layout
	            // also transform scale3d has an impact on the intersection observer, causing it to trigger
	            // initially and after the transition which makes the shadow appear later
	            // using an invisible element after the dialog div would work
	            // but layout with position: fixed and flex for vertical/horizontal centering scrollable content
	            // causes tons of problems, also considering fullscreen mode, etc.
	            // see https://stackoverflow.com/questions/33454533/cant-scroll-to-top-of-flex-item-that-is-overflowing-container
	            const { scrollHeight, clientHeight, scrollTop } = this.scrollContainerEl;
	            if (scrollHeight > clientHeight) {
	                const shouldApplyShadow = scrollHeight - clientHeight > scrollTop + parseInt(getComputedStyle(this.dialog).marginBottom, 10);
	                this.footer.classList.toggle(footerShadowClass, shouldApplyShadow);
	            }
	        });
	        this.onSlotChange = () => {
	            if (this.open) {
	                // 1 tick delay is needed so that web components can be bootstrapped
	                setTimeout(() => {
	                    this.updateFocusTrap(true);
	                    this.dialog.focus(); // set initial focus
	                });
	            }
	            if (this.hasFooter) {
	                this.onScroll();
	            }
	        };
	        this.onMouseDown = (e) => {
	            if (e.composedPath()[0] === this.scrollContainerEl &&
	                !clickStartedInScrollbarTrack(this.scrollContainerEl, e)) {
	                this.dismissModal();
	            }
	        };
	        this.dismissModal = () => {
	            if (this.hasDismissButton) {
	                this.dismiss.emit();
	                this.close.emit();
	            }
	        };
	        this.open = false;
	        this.disableCloseButton = undefined;
	        this.dismissButton = true;
	        this.disableBackdropClick = false;
	        this.heading = undefined;
	        this.backdrop = 'blur';
	        this.fullscreen = false;
	        this.aria = undefined;
	        this.theme = 'light';
	    }
	    get hasDismissButton() {
	        return this.disableCloseButton ? false : this.dismissButton;
	    }
	    openChangeHandler(isOpen) {
	        this.updateFocusTrap(isOpen);
	        if (isOpen) {
	            this.focusedElBeforeOpen = document.activeElement;
	        }
	        else {
	            this.focusedElBeforeOpen?.focus();
	        }
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    componentDidLoad() {
	        // in case modal is rendered with open prop
	        if (this.open) {
	            this.updateFocusTrap(true);
	        }
	        modalFlyoutUtils.getShadowRootHTMLElements(this.host, 'slot').forEach((element) => element.addEventListener('slotchange', this.onSlotChange));
	    }
	    componentDidRender() {
	        // TODO: should this really be executed on every rerender, e.g. prop change?
	        if (this.open) {
	            // reset scroll top to zero in case content is longer than viewport height, - some timeout is needed although it shouldn't
	            for (let i = 0; i < 4; i++) {
	                setTimeout(() => (this.scrollContainerEl.scrollTop = 0), i * 5);
	            }
	            if (this.hasFooter) {
	                this.onScroll();
	            }
	            this.dialog.focus(); // needs to happen after render
	        }
	    }
	    disconnectedCallback() {
	        this.updateFocusTrap(false);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'disableCloseButton', 'Please use dismissButton prop instead.');
	        this.hasHeader = hasHeading.hasHeading(this.host, this.heading);
	        this.hasFooter = hasNamedSlot.hasNamedSlot(this.host, 'footer');
	        if (this.open) {
	            warnIfAriaAndHeadingPropsAreUndefined(this.host, this.hasHeader, this.aria);
	        }
	        validateProps.attachComponentCss(this.host, getComponentCss, this.open, this.backdrop, this.fullscreen, this.hasDismissButton, this.hasHeader, this.hasFooter, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(validateProps.Host, { key: '47b1d53c3044d16c516e08bed2deb3b77420a849' }, validateProps.h("div", { key: 'e284dbe6634b1e4b6007300ca0ebb9e1912869e3', class: "scroll-container", onScroll: this.hasFooter && this.onScroll, onMouseDown: !this.disableBackdropClick && this.onMouseDown, ref: (el) => (this.scrollContainerEl = el) }, validateProps.h("div", { key: 'fe51385fbb198bfb8b184b6418f2b14b9043e85d', class: "root", role: "dialog", ...validateProps.parseAndGetAriaAttributes({
	                'aria-modal': true,
	                'aria-label': this.heading,
	                'aria-hidden': !this.open,
	                ...validateProps.parseAndGetAriaAttributes(this.aria),
	            }), tabIndex: -1, inert: this.open ? null : true, ref: (el) => (this.dialog = el) }, this.hasDismissButton && (validateProps.h("div", { class: "controls" }, validateProps.h(PrefixedTagNames.pButtonPure, { class: "dismiss", type: "button", ref: (el) => (this.dismissBtn = el), hideLabel: true, icon: "close", onClick: this.dismissModal, theme: this.theme }, "Dismiss modal"))), this.hasHeader && (validateProps.h("div", { key: "heading", class: "header" }, this.heading ? validateProps.h("h2", null, this.heading) : validateProps.h("slot", { name: "heading" }))), validateProps.h("div", { key: 'd54ce863d8a37aace8653139ea3022824256e8ed', class: "content" }, validateProps.h("slot", { key: 'd4373b75ed405e5ad4d4b1dd78085a9124888222' })), this.hasFooter && (validateProps.h("div", { key: "footer", class: "footer", ref: (el) => (this.footer = el) }, validateProps.h("slot", { name: "footer" })))))));
	    }
	    updateFocusTrap(isOpen) {
	        setFocusTrap(this.host, isOpen, this.dialog, !this.disableCloseButton && this.dismissBtn, this.dismissModal);
	        setScrollLock.setScrollLock(isOpen);
	    }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "open": ["openChangeHandler"]
	    }; }
	};

	pModal_cjs_entry.p_modal = Modal;

	
	return pModal_cjs_entry;
}

var pModelSignature_cjs_entry = {};

var hasRequiredPModelSignature_cjs_entry;

function requirePModelSignature_cjs_entry () {
	if (hasRequiredPModelSignature_cjs_entry) return pModelSignature_cjs_entry;
	hasRequiredPModelSignature_cjs_entry = 1;

	Object.defineProperty(pModelSignature_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const theme = requireThemeBfc10573();
	const getCDNBaseURL = requireGetCDNBaseURLE7722df3();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();

	const MODEL_SIGNATURES_MANIFEST = { "718": { "src": "718.min.493a9e3509d6e263fa2207150082def5.svg", "width": 79, "height": 26 }, "911": { "src": "911.min.b68f913216168583298ccf83f1a6b8d5.svg", "width": 94, "height": 25 }, "boxster": { "src": "boxster.min.c321738789b37fda4bba3f7c587542aa.svg", "width": 239, "height": 26 }, "cayenne": { "src": "cayenne.min.25562011631a831516f91ec31d144104.svg", "width": 245, "height": 35 }, "cayman": { "src": "cayman.min.cc8919694c002873e1bb6a3c1dae5d41.svg", "width": 229, "height": 35 }, "macan": { "src": "macan.min.a1844f4c8d23b75e371745e9b8eb49b9.svg", "width": 196, "height": 26 }, "panamera": { "src": "panamera.min.6dae8095186567168f85c145845f090c.svg", "width": 260, "height": 25 }, "taycan": { "src": "taycan.min.df444c6f4cc1f627ceaf1b02584d6bea.svg", "width": 167, "height": 36 }, "turbo-s": { "src": "turbo-s.min.73f1e10731caffe93c07d96fa08546c1.svg", "width": 199, "height": 25 }, "turbo": { "src": "turbo.min.6a4084a8704a6c47a099b2de56b22aef.svg", "width": 143, "height": 25 } };

	const forcedColorsMediaQuery = (style) => {
	    return { '@media (forced-colors: active)': style };
	};

	const MODEL_SIGNATURE_FETCH_PRIORITY = ['low', 'high', 'auto'];
	const MODEL_SIGNATURE_SIZES = ['small', 'inherit'];
	const MODEL_SIGNATURE_MODELS = Object.keys(MODEL_SIGNATURES_MANIFEST);
	const MODEL_SIGNATURE_COLORS = [
	    'primary',
	    'contrast-low',
	    'contrast-medium',
	    'contrast-high',
	    'inherit',
	];
	const getSvgUrl = (model) => {
	    return `${getCDNBaseURL.getCDNBaseURL()}/model-signatures/${MODEL_SIGNATURES_MANIFEST[model].src}`;
	};

	const cssVariableWidth = '--p-model-signature-width';
	const cssVariableHeight = '--p-model-signature-height';
	const cssVariableColor = '--p-model-signature-color';
	const { canvasTextColor } = validateProps.getHighContrastColors();
	const getThemedColor = (color, themedColors) => {
	    const colorMap = {
	        primary: themedColors.primaryColor,
	        inherit: 'black',
	        'contrast-low': themedColors.contrastLowColor,
	        'contrast-medium': themedColors.contrastMediumColor,
	        'contrast-high': themedColors.contrastHighColor,
	    };
	    return colorMap[color];
	};
	const getComponentCss = (model, safeZone, size, color, theme) => {
	    const { width, height } = MODEL_SIGNATURES_MANIFEST[model];
	    const isSizeInherit = size === 'inherit';
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'inline-block',
	                verticalAlign: 'top',
	                maxWidth: '100%',
	                maxHeight: '100%',
	                // width + height style can't be !important atm to be backwards compatible with e.g. `<p-model-signature size="inherit" style="height: 50px"/>`
	                width: `var(${cssVariableWidth},${isSizeInherit ? 'auto' : width + 'px'})`,
	                height: `var(${cssVariableHeight},auto)`,
	                ...validateProps.addImportantToEachRule({
	                    mask: `url(${getSvgUrl(model)}) no-repeat left top / contain`,
	                    aspectRatio: `${width} / ${safeZone ? 36 : height}`, // 36px is the max-height for SVG model signature creation
	                    background: `var(${cssVariableColor},${getThemedColor(color, validateProps.getThemedColors(theme))})`,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        background: `var(${cssVariableColor},${getThemedColor(color, validateProps.getThemedColors('dark'))})`,
	                    }),
	                    ...forcedColorsMediaQuery({
	                        background: canvasTextColor,
	                    }),
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            '::slotted(:is(img,video))': validateProps.addImportantToEachRule({
	                display: 'block', // prevents unintended bottom white-space
	                width: '100%',
	                height: '100%',
	                objectFit: 'cover',
	            }),
	            // the <img /> is only needed for a11y compliance because of alt text and to handle the fetch priority
	            img: {
	                position: 'absolute', // prevents unintended bottom white-space
	                opacity: 0,
	                width: '1px',
	                height: '1px',
	            },
	        },
	    });
	};

	const propTypes = {
	    model: validateProps.AllowedTypes.oneOf(MODEL_SIGNATURE_MODELS),
	    safeZone: validateProps.AllowedTypes.boolean,
	    fetchPriority: validateProps.AllowedTypes.oneOf(MODEL_SIGNATURE_FETCH_PRIORITY),
	    lazy: validateProps.AllowedTypes.boolean,
	    size: validateProps.AllowedTypes.oneOf(MODEL_SIGNATURE_SIZES),
	    color: validateProps.AllowedTypes.oneOf(MODEL_SIGNATURE_COLORS),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const ModelSignature = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.model = '911';
	        this.safeZone = true;
	        this.fetchPriority = 'auto';
	        this.lazy = false;
	        this.size = 'small';
	        this.color = 'primary';
	        this.theme = 'light';
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.model, this.safeZone, this.size, this.color, this.theme);
	        const fetchPriority = this.fetchPriority !== 'auto' ? this.fetchPriority : null;
	        const loading = this.lazy === true ? 'lazy' : null;
	        return (validateProps.h(validateProps.Host, { key: 'e6c3a286e6eda9c11ad236dbffc37fcf077c634c' }, validateProps.h("slot", { key: 'e97f5d0a6b2236b1e453c85033a72c41c73c4737' }), validateProps.h("img", { key: '9b19c047b343aaf217d1c5b33cfa51118677f275', fetchpriority: fetchPriority, loading: loading, src: getSvgUrl(this.model), alt: this.model })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pModelSignature_cjs_entry.p_model_signature = ModelSignature;

	
	return pModelSignature_cjs_entry;
}

var pMultiSelect_2_cjs_entry = {};

var popoverResetStylesFad56b6d = {};

var scrollerPopoverUtils89485ebc = {};

var hasRequiredScrollerPopoverUtils89485ebc;

function requireScrollerPopoverUtils89485ebc () {
	if (hasRequiredScrollerPopoverUtils89485ebc) return scrollerPopoverUtils89485ebc;
	hasRequiredScrollerPopoverUtils89485ebc = 1;

	// This class is shared since the popover needs to register a scroll listener to this node in order to hide the popover when the table is scrolled
	const scrollAreaClass = 'scroll-area';

	scrollerPopoverUtils89485ebc.scrollAreaClass = scrollAreaClass;

	
	return scrollerPopoverUtils89485ebc;
}

var hasRequiredPopoverResetStylesFad56b6d;

function requirePopoverResetStylesFad56b6d () {
	if (hasRequiredPopoverResetStylesFad56b6d) return popoverResetStylesFad56b6d;
	hasRequiredPopoverResetStylesFad56b6d = 1;

	const validateProps = requireValidatePropsF6586828();
	const scrollerPopoverUtils = requireScrollerPopoverUtils89485ebc();

	const addNativePopoverScrollAndResizeListeners = (host, table, nativePopover, callback) => {
	    const tableScrollArea = table.shadowRoot
	        .querySelector(validateProps.getPrefixedTagNames(host).pScroller)
	        .shadowRoot.querySelector(`.${scrollerPopoverUtils.scrollAreaClass}`);
	    const hidePopover = () => {
	        nativePopover.hidePopover();
	        callback?.();
	        window.removeEventListener('resize', hidePopover);
	        tableScrollArea.removeEventListener('scroll', hidePopover);
	    };
	    window.addEventListener('resize', hidePopover, { once: true });
	    tableScrollArea.addEventListener('scroll', hidePopover, { once: true });
	};

	/**
	 * Checks if the given host element is within a specific component based on the component's tag name.
	 *
	 * @param {HTMLElement} host - The element to check.
	 * @param {keyof PrefixedTagNames} component - The tag name of the component to check against.
	 * @returns {HTMLElement | null} The closest ancestor element that matches the component's tag name, or null if not found.
	 */
	const findClosestComponent = (host, component) => host.closest(validateProps.getPrefixedTagNames(host)[component]);

	const detectNativePopoverCase = (host, nested) => {
	    if (validateProps.getHasNativePopoverSupport()) {
	        const parentTableElement = findClosestComponent(nested ? host.getRootNode().host : host, 'pTable');
	        if (!!parentTableElement) {
	            return true;
	        }
	    }
	};

	/**
	 * Checks if a click event occurred outside the specified element.
	 *
	 * @param {Event} e - The click event object.
	 * @param {HTMLElement} host - The host element to compare against.
	 * @returns {boolean} - Returns true if the click event occurred outside the host element, otherwise false.
	 */
	const isClickOutside = (e, host) => !e.composedPath().includes(host);

	// Used for elements that must overflow `overflow:hidden` containers, are positioned absolute and wrapped within a native `popover` element.
	const getPopoverResetJssStyle = () => {
	    return {
	        position: 'absolute',
	        border: 'none',
	        background: 'none',
	        pointerEvents: 'all',
	        padding: 0,
	        margin: 0,
	        overflow: 'initial',
	        '&:-internal-popover-in-top-layer::backdrop': {
	            display: 'none',
	        },
	    };
	};

	popoverResetStylesFad56b6d.addNativePopoverScrollAndResizeListeners = addNativePopoverScrollAndResizeListeners;
	popoverResetStylesFad56b6d.detectNativePopoverCase = detectNativePopoverCase;
	popoverResetStylesFad56b6d.findClosestComponent = findClosestComponent;
	popoverResetStylesFad56b6d.getPopoverResetJssStyle = getPopoverResetJssStyle;
	popoverResetStylesFad56b6d.isClickOutside = isClickOutside;

	
	return popoverResetStylesFad56b6d;
}

var placeholderE6dd9abf = {};

var hasRequiredPlaceholderE6dd9abf;

function requirePlaceholderE6dd9abf () {
	if (hasRequiredPlaceholderE6dd9abf) return placeholderE6dd9abf;
	hasRequiredPlaceholderE6dd9abf = 1;

	/**
	 * Generates placeholder styles for an input element.
	 *
	 * @param {JssStyle} styles - The styles to apply to the placeholder.
	 * @returns {JssStyle} - The generated placeholder styles.
	 */
	const getPlaceholderJssStyle = (styles) => ({
	    '&::placeholder': styles,
	    '&::-webkit-input-placeholder': styles /* Chrome/Opera/Safari */,
	    '&::-moz-placeholder': styles /* Firefox 19+ */,
	    '&:-moz-placeholder': styles /* Firefox 18- */,
	});

	placeholderE6dd9abf.getPlaceholderJssStyle = getPlaceholderJssStyle;

	
	return placeholderE6dd9abf;
}

var hasRequiredPMultiSelect_2_cjs_entry;

function requirePMultiSelect_2_cjs_entry () {
	if (hasRequiredPMultiSelect_2_cjs_entry) return pMultiSelect_2_cjs_entry;
	hasRequiredPMultiSelect_2_cjs_entry = 1;

	Object.defineProperty(pMultiSelect_2_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const setAttributes = requireSetAttributes642a7e67();
	const getNativePopoverDropdownPosition = requireGetNativePopoverDropdownPosition06475061();
	const popoverResetStyles = requirePopoverResetStylesFad56b6d();
	const getClosestHTMLElement = requireGetClosestHTMLElement83d01a84();
	const buttonHandling = requireButtonHandlingB33ae166();
	const required = requireRequiredF3c463a3();
	const theme = requireThemeBfc10573();
	const throwIfElementIsNotOfKind = requireThrowIfElementIsNotOfKind4014bcee();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const placeholder = requirePlaceholderE6dd9abf();
	const label = requireLabel5379ea8c();
	const formStyles = requireFormStyles7e9d1c43();
	const fontLineHeight = requireFontLineHeight78b03658();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const throwIfParentIsNotOfKind = requireThrowIfParentIsNotOfKindEb817ad3();
	requireScrollerPopoverUtils89485ebc();
	requireHasNamedSlotA96fd22a();
	requireGetNamedSlotA0cdbdbc();
	requireFontSizeTextXSmallE59d35d7();
	requireHasDescriptionBbe55afe();
	requireIsParentOfKindB7d9f81c();
	requireSpacingStaticMedium94812711();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();

	const INTERNAL_MULTI_SELECT_SLOT = 'internal-select';
	const syncMultiSelectOptionProps = (options, theme) => {
	    options
	        .filter((option) => option.theme !== theme)
	        .forEach((option) => {
	        option.theme = theme;
	        validateProps.forceUpdate(option);
	    });
	};
	const initNativeMultiSelect = (host, name, disabled, required) => {
	    const nativeSelect = document.createElement('select');
	    setAttributes.setAttributes(nativeSelect, {
	        multiple: 'true',
	        'aria-hidden': 'true',
	        tabindex: '-1',
	        slot: INTERNAL_MULTI_SELECT_SLOT,
	    });
	    syncNativeMultiSelect(nativeSelect, name, disabled, required);
	    host.prepend(nativeSelect);
	    return nativeSelect;
	};
	const syncNativeMultiSelect = (nativeSelect, name, disabled, required) => {
	    validateProps.setAttribute(nativeSelect, 'name', name);
	    nativeSelect.toggleAttribute('disabled', disabled);
	    nativeSelect.toggleAttribute('required', required);
	};
	const updateNativeOptions = (nativeSelect, multiSelectOptions) => {
	    nativeSelect.innerHTML = getSelectedOptions(multiSelectOptions)
	        .map((option) => `<option value="${option.value}" selected="${option.selected}">${option.textContent}</option>`)
	        .join('');
	};
	const updateOptionsFilterState = (searchString, options) => {
	    options.forEach((option) => (option.hidden = !option.textContent.toLowerCase().includes(searchString.toLowerCase())));
	};
	const hasFilterOptionResults = (options) => options.some((option) => !option.hidden);
	const resetFilteredOptions = (options) => options.forEach((option) => (option.hidden = false));
	const getSelectedOptions = (options) => options.filter((option) => option.selected);
	const getSelectedOptionValues = (options) => options.filter((option) => option.selected).map((option) => option.value);
	const getSelectedOptionsString = (options) => getSelectedOptions(options)
	    .map((option) => option.textContent)
	    .join(', ');
	const getUsableOptions = (options) => options.filter((option) => !option.hidden && !option.disabled);
	const getHighlightedOption = (options) => options.find((option) => option.highlighted);
	const setSelectedOptions = (options, value) => {
	    const selectedValues = new Set(value);
	    options.forEach((option) => {
	        const shouldBeSelected = selectedValues.has(option.value);
	        if ((option.selected ?? false) !== shouldBeSelected) {
	            option.selected = shouldBeSelected;
	            validateProps.forceUpdate(option);
	        }
	    });
	    const valuesNotIncluded = value.filter((val) => !options.some((option) => option.value === val));
	    if (valuesNotIncluded.length > 0) {
	        validateProps.consoleWarn('The following values are not included in the options of the p-multi-select:', valuesNotIncluded.join(', '));
	    }
	};
	const setHighlightedOption = (option, highlighted) => {
	    option.highlighted = highlighted;
	    validateProps.forceUpdate(option);
	};
	const getHighlightedOptionIndex = (options) => options.indexOf(getHighlightedOption(options));
	const setNextOptionHighlighted = (host, options, newIndex) => {
	    const oldIndex = getHighlightedOptionIndex(options);
	    if (oldIndex !== -1) {
	        setHighlightedOption(options[oldIndex], false);
	    }
	    setHighlightedOption(options[newIndex], true);
	    handleDropdownScroll(host, options[newIndex]);
	};
	const setFirstOptionHighlighted = (host, options) => {
	    const validOptions = getUsableOptions(options);
	    setNextOptionHighlighted(host, options, options.indexOf(validOptions[0]));
	};
	const setLastOptionHighlighted = (host, options) => {
	    const validOptions = getUsableOptions(options);
	    setNextOptionHighlighted(host, options, options.indexOf(validOptions.at(-1)));
	};
	const resetHighlightedOptions = (options) => options.forEach((option) => setHighlightedOption(option, false));
	const resetSelectedOptions = (options) => options.forEach((option) => {
	    if (option.selected) {
	        option.selected = false;
	        validateProps.forceUpdate(option);
	    }
	});
	const getNewOptionIndex = (options, direction) => {
	    const validItems = getUsableOptions(options);
	    const validMax = validItems.length - 1;
	    if (validMax < 0) {
	        return;
	    }
	    const oldIndex = getHighlightedOptionIndex(validItems);
	    let newIndex = oldIndex;
	    if (direction === 'down') {
	        newIndex = oldIndex < validMax ? oldIndex + 1 : 0;
	    }
	    else if (direction === 'up') {
	        newIndex = oldIndex > 0 ? oldIndex - 1 : validMax;
	    }
	    return options.indexOf(validItems[newIndex]);
	};
	const updateHighlightedOption = (host, options, direction) => {
	    const newIndex = getNewOptionIndex(options, direction);
	    setNextOptionHighlighted(host, options, newIndex);
	};
	/**
	 * Handles scrolling within the list to ensure that the highlighted item is always visible.
	 * @param {HTMLElement} scrollElement - The HTML element to be scrolled.
	 * @param {HTMLElement} element - The element to scroll to.
	 * @returns {void}
	 */
	const handleDropdownScroll = (scrollElement, element) => {
	    const { maxHeight } = getComputedStyle(scrollElement);
	    const hostElementHeight = parseInt(maxHeight, 10);
	    if (scrollElement.scrollHeight > hostElementHeight) {
	        element.scrollIntoView();
	    }
	};
	const getDropdownDirection = (direction, host, options) => {
	    if (direction !== 'auto') {
	        return direction;
	    }
	    else if (host) {
	        const visibleOptionsLength = options.filter((option) => !option.hidden).length;
	        return getNativePopoverDropdownPosition.determineDropdownDirection(host, visibleOptionsLength);
	    }
	    else {
	        return 'down';
	    }
	};

	const getComponentCss$1 = (direction, isOpen, isDisabled, hideLabel, state, isWithinForm, isNativePopoverCase, theme) => {
	    const { contrastHighColor } = validateProps.getThemedColors(theme);
	    const { contrastHighColor: contrastHighColorDark } = validateProps.getThemedColors('dark');
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...(isWithinForm &&
	                validateProps.addImportantToEachRule({
	                    [`::slotted([slot=${INTERNAL_MULTI_SELECT_SLOT}])`]: {
	                        position: 'absolute',
	                        opacity: 0,
	                        height: '0px',
	                        bottom: 0,
	                    },
	                })),
	            // TODO: re-use select-wrapper-style
	            input: getInputStyles(isDisabled, direction, isOpen, state, theme),
	        },
	        root: {
	            display: 'grid',
	            gap: spacingStaticXSmall.spacingStaticXSmall,
	            ...(isWithinForm && {
	                position: 'relative', // Necessary for native HTML validation box positioning (internal-select)
	            }),
	        },
	        wrapper: {
	            position: 'relative',
	            display: 'grid',
	            gridTemplateColumns: `minmax(0, 1fr) auto auto ${formStyles.formElementLayeredSafeZone}`,
	        },
	        // TODO: extract for multi-select, select-wrapper and text-field (not gridArea and placeSelf)
	        icon: {
	            gridArea: '1/3',
	            placeSelf: 'center',
	            padding: formStyles.formButtonOrIconPadding,
	            pointerEvents: 'none',
	            transform: 'rotate3d(0,0,1,0.0001deg)', // needs to be a little more than 0 for correct direction in safari
	            transition: validateProps.getTransition('transform'),
	            '&--rotate': {
	                transform: 'rotate3d(0,0,1,180deg)',
	            },
	        },
	        // TODO: extract for multi-select, select-wrapper and text-field (not gridArea and placeSelf)
	        button: {
	            gridArea: '1/2',
	            placeSelf: 'center',
	            padding: formStyles.formButtonOrIconPadding,
	        },
	        listbox: getListStyles(isOpen, direction, theme),
	        // TODO: extract (maybe even as functional component) and re-use in multi-select and select-wrapper
	        'no-results': {
	            padding: `${spacingStaticSmall.spacingStaticSmall} 12px`,
	            boxSizing: 'border-box',
	            color: contrastHighColor,
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                color: contrastHighColorDark,
	            }),
	            ...getNativePopoverDropdownPosition.getNoResultsOptionJssStyle(),
	        },
	        // TODO: maybe we should extract it as functional component too
	        'sr-only': validateProps.getHiddenTextJssStyle(),
	        // .label / .required
	        ...label.getFunctionalComponentLabelStyles(isDisabled, hideLabel, theme),
	        // .message
	        ...required.getFunctionalComponentStateMessageStyles(theme, state),
	        ...(isNativePopoverCase && {
	            popover: {
	                ...popoverResetStyles.getPopoverResetJssStyle(),
	            },
	        }),
	    });
	};
	// TODO: use getSlottedTextFieldTextareaSelectStyles() instead an manipulate selectors like done with PIN Code or even better make it configurable as parameter
	const getInputStyles = (isDisabled, direction, isOpen, state, theme) => {
	    const isDirectionDown = direction === 'down';
	    const { primaryColor, disabledColor, backgroundColor, contrastMediumColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, disabledColor: disabledColorDark, backgroundColor: backgroundColorDark, contrastMediumColor: contrastMediumColorDark, } = validateProps.getThemedColors('dark');
	    const { formStateColor, formStateHoverColor } = required.getThemedFormStateColors(theme, state);
	    const { formStateColor: formStateColorDark, formStateHoverColor: formStateHoverColorDark } = required.getThemedFormStateColors('dark', state);
	    return {
	        gridArea: '1/1/1/-1',
	        flex: 1,
	        minWidth: 0,
	        // TODO: abstract and re-use for multi-select, select-wrapper and text-field-wrapper
	        height: `calc(${fontLineHeight.fontLineHeight} + 10px + ${validateProps.borderWidthBase} * 2 + ${spacingStaticSmall.spacingStaticSmall} * 2)`, // we need 10px additionally so input height becomes 54px, // we need 6px additionally so input height becomes 50px
	        font: textSmallStyle.textSmallStyle.font.replace('ex', 'ex + 6px'), // a minimum line-height is needed for input, otherwise value is scrollable in Chrome, +6px is alig
	        margin: 0, // necessary reset for iOS Safari 15 (and maybe other browsers)
	        padding: `${formStyles.formElementPaddingVertical} ${formStyles.formElementPaddingHorizontal}`,
	        paddingInlineEnd: formStyles.getCalculatedFormElementPaddingHorizontal(2),
	        boxSizing: 'border-box',
	        outline: 0,
	        WebkitAppearance: 'none', // iOS safari
	        appearance: 'none',
	        ...textSmallStyle.textSmallStyle,
	        textOverflow: 'ellipsis',
	        '&:disabled': {
	            cursor: 'not-allowed',
	        },
	        transition: `${validateProps.getTransition('background-color')}, ${validateProps.getTransition('border-color')}, ${validateProps.getTransition('color')}`, // for smooth transitions between e.g. disabled states
	        color: primaryColor,
	        '&:not(:focus)': {
	            ...placeholder.getPlaceholderJssStyle({ color: primaryColor, opacity: 1 }),
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, placeholder.getPlaceholderJssStyle({ color: primaryColorDark, opacity: 1 })),
	        }, // Opacity fixes placeholder being shown lighter in firefox
	        ...hoverMediaQuery.hoverMediaQuery({
	            '&:hover:not(:disabled):not(:focus),label:hover~.wrapper &:not(:disabled):not(:focus)': {
	                borderColor: isOpen ? primaryColor : formStateHoverColor || primaryColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    borderColor: isOpen ? primaryColorDark : formStateHoverColorDark || primaryColorDark,
	                }),
	            },
	        }),
	        ...(!isDisabled && {
	            // TODO: getFocusJssStyle() can't be re-used because focus style differs for form elements
	            '&:focus': {
	                borderColor: primaryColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    borderColor: primaryColorDark,
	                }),
	            },
	        }),
	        background: backgroundColor,
	        border: `${validateProps.borderWidthBase} solid ${isOpen ? primaryColor : formStateColor || contrastMediumColor}`,
	        borderRadius: borderRadiusSmall.borderRadiusSmall,
	        ...(isOpen && {
	            [isDirectionDown ? 'paddingBottom' : 'paddingTop']: `calc(${formStyles.formElementPaddingVertical} + 1px)`, // Add padding to keep same height when border changes
	            [isDirectionDown ? 'borderBottom' : 'borderTop']: validateProps.addImportantToRule(`1px solid ${contrastMediumColor}`),
	            [isDirectionDown ? 'borderBottomLeftRadius' : 'borderTopLeftRadius']: 0,
	            [isDirectionDown ? 'borderBottomRightRadius' : 'borderTopRightRadius']: 0,
	        }),
	        ...(isDisabled && {
	            ...placeholder.getPlaceholderJssStyle({ color: disabledColor }),
	            cursor: 'not-allowed',
	            color: disabledColor,
	            borderColor: disabledColor,
	            WebkitTextFillColor: disabledColor,
	        }),
	        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	            color: primaryColorDark,
	            background: backgroundColorDark,
	            border: `${validateProps.borderWidthBase} solid ${isOpen ? primaryColorDark : formStateColorDark || contrastMediumColorDark}`,
	            ...(isOpen && {
	                [isDirectionDown ? 'borderBottom' : 'borderTop']: validateProps.addImportantToRule(`1px solid ${contrastMediumColorDark}`),
	            }),
	            ...(isDisabled && {
	                ...placeholder.getPlaceholderJssStyle({ color: disabledColorDark }),
	                color: disabledColorDark,
	                borderColor: disabledColorDark,
	                WebkitTextFillColor: disabledColorDark,
	            }),
	        }),
	    };
	};
	const getListStyles = (isOpen, direction, theme) => {
	    const isDirectionDown = direction === 'down';
	    const { primaryColor, backgroundColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, backgroundColor: backgroundColorDark } = validateProps.getThemedColors('dark');
	    return {
	        position: 'absolute',
	        margin: 0,
	        display: isOpen ? 'flex' : 'none',
	        flexDirection: 'column',
	        gap: spacingStaticSmall.spacingStaticSmall,
	        padding: '6px',
	        ...textSmallStyle.textSmallStyle,
	        zIndex: 10,
	        left: 0,
	        right: 0,
	        [isDirectionDown ? 'top' : 'bottom']: '100%',
	        boxSizing: 'border-box',
	        maxHeight: `${8.5 * (getNativePopoverDropdownPosition.MULTI_SELECT_OPTION_HEIGHT + 8) + 6 + 2}px`, // 8.5 options * option height + 8px gap + additional spacing (6px = padding, 2px = border)
	        overflowY: 'auto',
	        WebkitOverflowScrolling: 'touch',
	        background: backgroundColor,
	        border: `2px solid ${primaryColor}`,
	        [isDirectionDown ? 'borderTop' : 'borderBottom']: 'none',
	        borderRadius: borderRadiusSmall.borderRadiusSmall,
	        [isDirectionDown ? 'borderTopLeftRadius' : 'borderBottomLeftRadius']: 0,
	        [isDirectionDown ? 'borderTopRightRadius' : 'borderBottomRightRadius']: 0,
	        scrollbarWidth: 'thin', // firefox
	        scrollbarColor: 'auto', // firefox
	        transition: validateProps.getTransition('border-color'),
	        transform: 'translate3d(0,0,0)', // fix iOS bug if less than 5 items are displayed
	        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	            background: backgroundColorDark,
	            borderColor: primaryColorDark,
	        }),
	    };
	};

	const propTypes$1 = {
	    label: validateProps.AllowedTypes.string,
	    description: validateProps.AllowedTypes.string,
	    name: validateProps.AllowedTypes.string,
	    value: validateProps.AllowedTypes.array(validateProps.AllowedTypes.string),
	    state: validateProps.AllowedTypes.oneOf(required.FORM_STATES),
	    message: validateProps.AllowedTypes.string,
	    hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	    disabled: validateProps.AllowedTypes.boolean,
	    required: validateProps.AllowedTypes.boolean,
	    dropdownDirection: validateProps.AllowedTypes.oneOf(getNativePopoverDropdownPosition.SELECT_DROPDOWN_DIRECTIONS),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const MultiSelect = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.update = validateProps.createEvent(this, "update", 3);
	        this.multiSelectOptions = [];
	        this.preventOptionUpdate = false; // Used to prevent value watcher from updating options when options are already updated
	        this.isNativePopoverCase = false;
	        this.onSlotchange = () => {
	            this.updateOptions();
	            setSelectedOptions(this.multiSelectOptions, this.value);
	            if (this.isWithinForm) {
	                updateNativeOptions(this.nativeSelect, this.multiSelectOptions);
	            }
	            // Necessary to update selected options in placeholder
	            validateProps.forceUpdate(this.host);
	        };
	        this.updateOptions = () => {
	            this.multiSelectOptions = Array.from(this.host.children).filter((el) => el.tagName !== 'SELECT' && el.slot !== 'label' && el.slot !== 'description' && el.slot !== 'message');
	            this.multiSelectOptions.forEach((child) => throwIfElementIsNotOfKind.throwIfElementIsNotOfKind(this.host, child, 'p-multi-select-option'));
	        };
	        this.onInputChange = (e) => {
	            if (e.target.value.startsWith(' ')) {
	                this.resetFilter();
	            }
	            else {
	                updateOptionsFilterState(e.target.value, this.multiSelectOptions);
	                this.hasFilterResults = hasFilterOptionResults(this.multiSelectOptions);
	            }
	            // in case input is focused via tab instead of click
	            this.isOpen = true;
	        };
	        this.onInputClick = () => {
	            this.isOpen = true;
	            if (this.isNativePopoverCase) {
	                this.popoverElement.showPopover();
	            }
	        };
	        this.onResetClick = () => {
	            resetSelectedOptions(this.multiSelectOptions);
	            this.value = this.currentValue;
	            this.inputElement.focus();
	            this.emitUpdateEvent();
	            validateProps.forceUpdate(this.host);
	        };
	        this.onClickOutside = (e) => {
	            if (this.isOpen && popoverResetStyles.isClickOutside(e, this.inputContainer) && popoverResetStyles.isClickOutside(e, this.listElement)) {
	                this.isOpen = false;
	                this.resetFilter();
	            }
	        };
	        this.resetFilter = () => {
	            this.inputElement.value = '';
	            resetFilteredOptions(this.multiSelectOptions);
	        };
	        this.onInputKeyDown = (e) => {
	            switch (e.key) {
	                case 'ArrowUp':
	                case 'Up':
	                    e.preventDefault();
	                    this.cycleDropdown('up');
	                    break;
	                case 'ArrowDown':
	                case 'Down':
	                    e.preventDefault();
	                    this.cycleDropdown('down');
	                    break;
	                case 'Enter':
	                    const highlightedOption = getHighlightedOption(this.multiSelectOptions);
	                    if (highlightedOption) {
	                        highlightedOption.selected = !highlightedOption.selected;
	                        this.value = this.currentValue;
	                        this.emitUpdateEvent();
	                        this.updateSrHighlightedOptionText();
	                        validateProps.forceUpdate(highlightedOption);
	                    }
	                    else {
	                        if (this.isWithinForm) {
	                            buttonHandling.handleButtonEvent(e, this.host, () => 'submit', () => this.disabled);
	                        }
	                    }
	                    break;
	                case 'Escape':
	                    this.isOpen = false;
	                    resetHighlightedOptions(this.multiSelectOptions);
	                    break;
	                case 'Tab':
	                    // If there is a value the reset button will be focused and the dropdown stays open
	                    if (!this.currentValue.length) {
	                        this.isOpen = false;
	                    }
	                    resetHighlightedOptions(this.multiSelectOptions);
	                    break;
	                case 'PageUp':
	                    if (this.isOpen) {
	                        e.preventDefault();
	                        setFirstOptionHighlighted(this.listElement, this.multiSelectOptions);
	                    }
	                    break;
	                case 'PageDown':
	                    if (this.isOpen) {
	                        e.preventDefault();
	                        setLastOptionHighlighted(this.listElement, this.multiSelectOptions);
	                    }
	                    break;
	                // TODO: seems to be difficult to combine multiple keys as native select does
	            }
	        };
	        this.updateSrHighlightedOptionText = () => {
	            const highlightedOptionIndex = getHighlightedOptionIndex(this.multiSelectOptions);
	            // TODO: Does this consider hidden/disabled options?
	            const highlightedOption = this.multiSelectOptions[highlightedOptionIndex];
	            this.srHighlightedOptionText =
	                highlightedOption &&
	                    `${highlightedOption.textContent}${highlightedOption.selected ? ', selected' : ' not selected'} (${highlightedOptionIndex + 1} of ${this.multiSelectOptions.length})`;
	        };
	        this.emitUpdateEvent = () => {
	            this.update.emit({
	                value: this.currentValue,
	                name: this.name,
	            });
	        };
	        this.label = '';
	        this.description = '';
	        this.name = undefined;
	        this.value = [];
	        this.state = 'none';
	        this.message = '';
	        this.hideLabel = false;
	        this.disabled = false;
	        this.required = false;
	        this.dropdownDirection = 'auto';
	        this.theme = 'light';
	        this.isOpen = false;
	        this.srHighlightedOptionText = '';
	        this.hasFilterResults = true;
	    }
	    get currentValue() {
	        return getSelectedOptionValues(this.multiSelectOptions);
	    }
	    updateOptionHandler(e) {
	        e.target.selected = !e.target.selected;
	        validateProps.forceUpdate(e.target);
	        this.preventOptionUpdate = true; // Avoid unnecessary looping over options in setSelectedOptions in value watcher
	        this.value = this.currentValue;
	        e.stopPropagation();
	        this.emitUpdateEvent();
	    }
	    onValueChange() {
	        // When setting initial value the watcher gets called before the options are defined
	        if (this.multiSelectOptions.length > 0) {
	            if (!this.preventOptionUpdate) {
	                setSelectedOptions(this.multiSelectOptions, this.value);
	            }
	            this.preventOptionUpdate = false;
	            if (this.isWithinForm) {
	                updateNativeOptions(this.nativeSelect, this.multiSelectOptions);
	            }
	        }
	    }
	    connectedCallback() {
	        document.addEventListener('mousedown', this.onClickOutside, true);
	        this.form = getClosestHTMLElement.getClosestHTMLElement(this.host, 'form');
	        this.isWithinForm = !!this.form;
	        this.isNativePopoverCase = popoverResetStyles.detectNativePopoverCase(this.host, false);
	        if (this.isNativePopoverCase) {
	            this.parentTableElement = popoverResetStyles.findClosestComponent(this.host, 'pTable');
	        }
	    }
	    componentWillLoad() {
	        this.updateOptions();
	        // Use initial value to set options
	        setSelectedOptions(this.multiSelectOptions, this.value);
	        if (this.isWithinForm) {
	            this.nativeSelect = initNativeMultiSelect(this.host, this.name, this.disabled, this.required);
	            updateNativeOptions(this.nativeSelect, this.multiSelectOptions);
	        }
	    }
	    componentDidLoad() {
	        validateProps.getShadowRootHTMLElement(this.host, 'slot').addEventListener('slotchange', this.onSlotchange);
	    }
	    componentDidRender() {
	        if (this.isNativePopoverCase) {
	            popoverResetStyles.addNativePopoverScrollAndResizeListeners(this.host, this.parentTableElement, this.popoverElement, () => {
	                this.isOpen = false;
	            });
	            if (this.isOpen) {
	                getNativePopoverDropdownPosition.getNativePopoverDropdownPosition(this.inputElement, this.multiSelectOptions.filter((option) => !option.hidden).length, this.popoverElement, this.dropdownDirection);
	                this.popoverElement.showPopover();
	            }
	            else {
	                this.popoverElement.hidePopover();
	            }
	        }
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    componentWillUpdate() {
	        if (this.isWithinForm) {
	            syncNativeMultiSelect(this.nativeSelect, this.name, this.disabled, this.required);
	        }
	    }
	    disconnectedCallback() {
	        document.removeEventListener('mousedown', this.onClickOutside, true);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes$1);
	        validateProps.attachComponentCss(this.host, getComponentCss$1, getDropdownDirection(this.dropdownDirection, this.inputContainer, this.multiSelectOptions), this.isOpen, this.disabled, this.hideLabel, this.state, this.isWithinForm, this.isNativePopoverCase, this.theme);
	        syncMultiSelectOptionProps(this.multiSelectOptions, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        const optionsSelectedId = 'options-selected';
	        const dropdownId = 'list';
	        const inputId = 'filter';
	        return (validateProps.h("div", { key: 'd0b7a30beddd875719e64c905537cfc5e9335ecd', class: "root" }, validateProps.h(label.Label, { key: 'e23302c3f6d74103c7a2c1d6032a95929130eba8', host: this.host, label: this.label, description: this.description, htmlFor: inputId, isRequired: this.required, isDisabled: this.disabled }), this.currentValue.length > 0 && (validateProps.h("span", { id: optionsSelectedId, class: "sr-only" }, getSelectedOptions(this.multiSelectOptions).length, " options selected")), validateProps.h("div", { key: '3c8bc9381a144c4b47105ab8caba62f0d8572c8f', class: { wrapper: true, disabled: this.disabled }, ref: (el) => (this.inputContainer = el) }, validateProps.h("input", { key: '26c04e81760ea3525c7f5cebbc05a341463d56aa', id: inputId, role: "combobox", placeholder: getSelectedOptionsString(this.multiSelectOptions) || null, autoComplete: "off", disabled: this.disabled, required: this.required, onInput: this.onInputChange, onClick: this.onInputClick, onKeyDown: this.onInputKeyDown, ref: (el) => (this.inputElement = el), "aria-invalid": this.state === 'error' ? 'true' : null, ...getNativePopoverDropdownPosition.getFilterInputAriaAttributes(this.isOpen, this.required, label.labelId, `${label.descriptionId} ${optionsSelectedId} ${required.messageId}`, dropdownId) }), validateProps.h(PrefixedTagNames.pIcon, { key: '706724cab6662edc7269058ba24e9dd2a413ea83', class: { icon: true, 'icon--rotate': this.isOpen }, name: "arrow-head-down", theme: this.theme, color: this.disabled ? 'state-disabled' : 'primary', "aria-hidden": "true" }), this.currentValue.length > 0 && (validateProps.h(PrefixedTagNames.pButtonPure, { class: "button", icon: "close", hideLabel: "true", theme: this.theme, onClick: this.onResetClick, onKeyDown: (e) => e.key === 'Tab' && (this.isOpen = false), disabled: this.disabled }, "Reset selection")), validateProps.h("div", { key: '8d997a5f65d52497a6a00a3f1d3f38e1c7a148a1', ...(this.isNativePopoverCase && {
	                popover: 'auto',
	                class: 'popover',
	                ...(this.popoverElement?.matches(':popover-open') && {
	                    'popover-open': true,
	                }),
	            }), ref: (el) => (this.popoverElement = el) }, validateProps.h("div", { key: '6f17f0673d7e89fe16cdcd2dbb107f8926cf714f', id: dropdownId, class: "listbox", ...getNativePopoverDropdownPosition.getListAriaAttributes(this.label, this.required, true, this.isOpen, true), ref: (el) => (this.listElement = el) }, !this.hasFilterResults && (validateProps.h("div", { class: "no-results", "aria-live": "polite", role: "status" }, validateProps.h("span", { "aria-hidden": "true" }, "---"), validateProps.h("span", { class: "sr-only" }, "No results found"))), validateProps.h("slot", { key: '10b0d03829877b3b09a2bbe6b8b900f827a719a0' })))), validateProps.h(required.StateMessage, { key: 'cce2faa09fcec122bd96e0a0fb2909d58edeb3d5', state: this.state, message: this.message, theme: this.theme, host: this.host }), validateProps.h("span", { key: 'ca25fdd32ba939690f4167f8eea4d06931e88f46', class: "sr-only", role: "status", "aria-live": "assertive", "aria-relevant": "additions text" }, this.srHighlightedOptionText), this.isWithinForm && validateProps.h("slot", { name: INTERNAL_MULTI_SELECT_SLOT })));
	    }
	    cycleDropdown(direction) {
	        this.isOpen = true;
	        updateHighlightedOption(this.listElement, this.multiSelectOptions, direction);
	        this.updateSrHighlightedOptionText();
	    }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "value": ["onValueChange"]
	    }; }
	};

	const getComponentCss = (theme) => {
	    const { primaryColor, contrastHighColor, backgroundSurfaceColor, disabledColor, contrastLowColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, disabledColor: disabledColorDark, contrastHighColor: contrastHighColorDark, backgroundSurfaceColor: backgroundSurfaceColorDark, contrastLowColor: contrastLowColorDark, } = validateProps.getThemedColors('dark');
	    const { highlightColor } = validateProps.getHighContrastColors();
	    return validateProps.getCss({
	        '@global': {
	            ':host': validateProps.addImportantToEachRule({
	                scrollMarginTop: spacingStaticSmall.spacingStaticSmall, // Creates top margin when navigating with keyboard and list is scrolled automatically
	                ...colorSchemeStyles.hostHiddenStyles,
	            }),
	        },
	        option: {
	            display: 'flex',
	            justifyContent: 'space-between',
	            gap: '12px',
	            padding: `${spacingStaticSmall.spacingStaticSmall} 12px`,
	            flex: `1 0 calc(${fontLineHeight.fontLineHeight} + ${spacingStaticSmall.spacingStaticSmall} * 2)`,
	            color: contrastHighColor,
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                color: contrastHighColorDark,
	            }),
	            cursor: 'pointer',
	            textAlign: 'start',
	            wordBreak: 'break-word',
	            boxSizing: 'border-box',
	            borderRadius: borderRadiusSmall.borderRadiusSmall,
	            transition: `${validateProps.getTransition('background-color')}, ${validateProps.getTransition('color')}`,
	            ...getNativePopoverDropdownPosition.getNoResultsOptionJssStyle(),
	            ...hoverMediaQuery.hoverMediaQuery({
	                '&:not([aria-disabled]):not(.option--disabled):not([role=status]):hover': {
	                    color: validateProps.isHighContrastMode ? highlightColor : primaryColor,
	                    background: contrastLowColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        color: validateProps.isHighContrastMode ? highlightColor : primaryColorDark,
	                        background: contrastLowColorDark,
	                    }),
	                },
	            }),
	            '&--selected': {
	                background: backgroundSurfaceColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    background: backgroundSurfaceColorDark,
	                }),
	            },
	            '&--highlighted': {
	                background: contrastLowColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    background: contrastLowColorDark,
	                }),
	            },
	            '&--highlighted, &--selected': {
	                color: validateProps.isHighContrastMode ? highlightColor : primaryColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: validateProps.isHighContrastMode ? highlightColor : primaryColorDark,
	                }),
	            },
	            '&--disabled': {
	                cursor: 'not-allowed',
	                color: disabledColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: disabledColorDark,
	                }),
	            },
	            '&--hidden': {
	                display: 'none',
	            },
	        },
	        checkbox: {
	            pointerEvents: 'none', // Avoid checkbox label click which updates input within p-checkbox-wrapper
	        },
	    });
	};

	const propTypes = {
	    value: validateProps.AllowedTypes.string,
	    disabled: validateProps.AllowedTypes.boolean,
	};
	const MultiSelectOption = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.onClick = () => {
	            this.host.dispatchEvent(new CustomEvent('internalOptionUpdate', {
	                bubbles: true,
	            }));
	        };
	        this.value = undefined;
	        this.disabled = false;
	    }
	    connectedCallback() {
	        throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-multi-select');
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        const { theme = 'light', selected, highlighted, hidden, textContent } = this.host;
	        validateProps.attachComponentCss(this.host, getComponentCss, theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(validateProps.Host, { key: '9dc3f4b0ea66278d708599bb982d388fe4eae314', onClick: !this.disabled && this.onClick }, validateProps.h("div", { key: '1b3c8b11e135555068ea0099bd4eb364d0a0483d', class: {
	                option: true,
	                'option--selected': selected,
	                'option--highlighted': highlighted,
	                'option--disabled': this.disabled,
	            } }, validateProps.h(PrefixedTagNames.pCheckboxWrapper, { key: '3609a4020660d6f5f0527b80e8248aeaf21a1b96', class: "checkbox", theme: theme }, validateProps.h("input", { key: 'ef562781448ec5ae6b66a238efecda883d0ec995', role: "option", type: "checkbox", checked: selected, disabled: this.disabled, ...getNativePopoverDropdownPosition.getOptionAriaAttributes(selected, this.disabled, hidden, !!this.value), "aria-label": textContent, tabindex: "-1" }), validateProps.h("slot", { key: '0149d8b48323b8437c9cfae9ebfa53668ecfd0c6', slot: "label" })))));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pMultiSelect_2_cjs_entry.p_multi_select = MultiSelect;
	pMultiSelect_2_cjs_entry.p_multi_select_option = MultiSelectOption;

	
	return pMultiSelect_2_cjs_entry;
}

var pPagination_cjs_entry = {};

var hasRequiredPPagination_cjs_entry;

function requirePPagination_cjs_entry () {
	if (hasRequiredPPagination_cjs_entry) return pPagination_cjs_entry;
	hasRequiredPPagination_cjs_entry = 1;

	Object.defineProperty(pPagination_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed0dc3288b();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const getMediaQueryMax = requireGetMediaQueryMaxBbf4c490();
	const fontLineHeight = requireFontLineHeight78b03658();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	requireHelperA66adcf2();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();

	/**
	 * Universal pagination model generation algorithm
	 *
	 * The idea behind this module is to move the logic of creating pagination out of the component
	 * and place it in a separate module.
	 *
	 * Adapted from ultimate-pagination
	 * https://github.com/ultimate-pagination/ultimate-pagination
	 */
	var ItemType;
	(function (ItemType) {
	    ItemType[ItemType["PAGE"] = 0] = "PAGE";
	    ItemType[ItemType["ELLIPSIS"] = 1] = "ELLIPSIS";
	    ItemType[ItemType["PREVIOUS"] = 2] = "PREVIOUS";
	    ItemType[ItemType["NEXT"] = 3] = "NEXT";
	})(ItemType || (ItemType = {}));
	const ellipsisItem = {
	    type: ItemType.ELLIPSIS,
	    isActive: false,
	};
	const createPreviousPageLink = (options) => {
	    const { activePage } = options;
	    return {
	        type: ItemType.PREVIOUS,
	        value: Math.max(1, activePage - 1),
	        isActive: activePage > 1,
	    };
	};
	const createNextPageLink = (options) => {
	    const { activePage, pageTotal } = options;
	    return {
	        type: ItemType.NEXT,
	        value: Math.min(pageTotal, activePage + 1),
	        isActive: activePage < pageTotal,
	    };
	};
	const createPageFunctionFactory = ({ activePage }) => {
	    return (pageNumber) => ({
	        type: ItemType.PAGE,
	        value: pageNumber,
	        isActive: pageNumber === activePage,
	        isBeforeCurrent: pageNumber === activePage - 1,
	        isBeforeBeforeCurrent: pageNumber === activePage - 2,
	        isAfterCurrent: pageNumber === activePage + 1,
	        isAfterAfterCurrent: pageNumber === activePage + 2,
	    });
	};
	const createRange = (start, end) => Array.from(Array(end - start + 1), (_, i) => i + start);
	const createPaginationItems = (options) => {
	    const { pageTotal, activePage, showLastPage } = options;
	    const pageRange = 1;
	    const boundaryPagesRange = 1;
	    const ellipsisSize = 1;
	    const paginationItems = [createPreviousPageLink(options)];
	    const createPage = createPageFunctionFactory(options);
	    // Simplify generation of pages if number of available items is equal or greater than total pages to show
	    if (1 + 2 * ellipsisSize + 2 * boundaryPagesRange >= pageTotal) {
	        const allPages = createRange(1, pageTotal).map(createPage);
	        paginationItems.push(...allPages);
	    }
	    else {
	        // Add first page
	        paginationItems.push(createPage(1));
	        // Calculate group of middle pages
	        const middlePagesStart = Math.min(Math.max(activePage - pageRange, 2 + ellipsisSize), pageTotal - ellipsisSize - 2 - (showLastPage ? 1 : 0));
	        const middlePagesEnd = middlePagesStart + 2;
	        const middlePages = createRange(middlePagesStart, middlePagesEnd).map(createPage);
	        // Calculate and add ellipsis before group of middle pages
	        const firstEllipsisPageNumber = middlePagesStart - 1;
	        const showPageInsteadOfFirstEllipsis = firstEllipsisPageNumber === 2;
	        const firstEllipsisOrPage = showPageInsteadOfFirstEllipsis ? createPage(firstEllipsisPageNumber) : ellipsisItem;
	        if (showPageInsteadOfFirstEllipsis && pageTotal > 5) {
	            paginationItems.push(ellipsisItem);
	        }
	        paginationItems.push(firstEllipsisOrPage);
	        // Add group of middle pages
	        paginationItems.push(...middlePages);
	        // Calculate and add ellipsis after group of middle pages
	        const lastEllipsisPageNumber = middlePagesEnd + 1;
	        const showPageInsteadOfLastEllipsis = lastEllipsisPageNumber === pageTotal - (showLastPage ? 1 : 0);
	        const lastEllipsisOrPage = showPageInsteadOfLastEllipsis ? createPage(lastEllipsisPageNumber) : ellipsisItem;
	        paginationItems.push(lastEllipsisOrPage);
	        if (showPageInsteadOfLastEllipsis && pageTotal > 5) {
	            paginationItems.push(ellipsisItem);
	        }
	        // Add last page
	        if (showLastPage) {
	            paginationItems.push(createPage(pageTotal));
	        }
	    }
	    paginationItems.push(createNextPageLink(options));
	    return paginationItems;
	};
	const getCurrentActivePage = (activePage, totalPages) => {
	    // Obviously we can't be on a negative or 0 page.
	    if (activePage < 1) {
	        activePage = 1;
	    }
	    // If the user has done something like /page/99999 we want to clamp that back down.
	    if (activePage > totalPages) {
	        activePage = totalPages;
	    }
	    return activePage;
	};
	const getTotalPages = (totalItemsCount, itemsPerPage) => {
	    if (totalItemsCount < 1) {
	        totalItemsCount = 1;
	    }
	    if (itemsPerPage < 1) {
	        itemsPerPage = 1;
	    }
	    return Math.ceil(totalItemsCount / itemsPerPage);
	};

	const mediaQueryMinS = validateProps.getMediaQueryMin('s');
	const mediaQueryMaxS = getMediaQueryMax.getMediaQueryMax('s');
	// button size needs to be fluid between 320px and 360px viewport width, so that the pagination fits into 320px viewport
	// and text scale 200% works (almost) on mobile viewports too
	const buttonSize = `clamp(36px, calc(${fontLineHeight.fontLineHeight} + 10vw - 20px), 40px)`;
	const disabledCursorStyle = {
	    cursor: 'default',
	    pointerEvents: 'none', // prevents :hover (has no effect when forced), maybe we can remove it since CSS selectors already cover desired behavior
	};
	const hiddenStyle = { display: 'none' };
	const getComponentCss = (activePage, pageTotal, showLastPage, theme) => {
	    const { primaryColor, disabledColor, hoverColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, disabledColor: disabledColorDark, hoverColor: hoverColorDark, } = validateProps.getThemedColors('dark');
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            nav: {
	                display: 'flex',
	                justifyContent: 'center',
	                userSelect: 'none',
	            },
	            ul: {
	                display: 'flex',
	                gap: spacingStaticXSmall.spacingStaticXSmall,
	                margin: 0,
	                padding: 0,
	                [mediaQueryMinS]: {
	                    gap: spacingStaticSmall.spacingStaticSmall,
	                },
	            },
	            li: {
	                listStyleType: 'none',
	                ...(pageTotal > 5 && {
	                    // max 5 items including ellipsis at the same time on mobile
	                    [mediaQueryMaxS]: {
	                        [activePage < 4
	                            ? // we are at the start, so let's hide start ellipsis and 2 items before end ellipsis
	                                '&.ellip-start,&:nth-child(6),&:nth-child(7),&:not(.ellip):nth-child(8)'
	                            : pageTotal - activePage < 3
	                                ? // we are at the end, so let's hide end ellipsis and 2 items after start ellipsis
	                                    '&.ellip-end, &.ellip-start + &:not(.current), &.ellip-start + &:not(.current) + &:not(.current)'
	                                : // we are at in the middle, so let's hide elements after start and before end ellipsis
	                                    '&.ellip-start + &:not(.current), &.current-1, &.current\\+1, &.current\\+1 + &:not(.ellip)']: hiddenStyle,
	                        // without last page we need to adjust end page handling
	                        ...(!showLastPage &&
	                            (pageTotal - activePage < 2
	                                ? { [`&.current-2${pageTotal - activePage === 1 ? ',&.current-1' : ''}`]: hiddenStyle }
	                                : activePage > 2 && {
	                                    '&.current\\+1,&.current\\+2': hiddenStyle,
	                                    '&.ellip-end': { display: 'initial' },
	                                })),
	                    },
	                }),
	                [mediaQueryMinS]: {
	                    // prev
	                    '&:first-child': { marginInlineEnd: spacingStaticSmall.spacingStaticSmall },
	                    // next
	                    '&:last-child': { marginInlineStart: spacingStaticSmall.spacingStaticSmall },
	                    ...(pageTotal < 8
	                        ? { '&.ellip': hiddenStyle }
	                        : // max 7 items including ellipsis at the same time on tablet
	                            {
	                                // we are at the start, so let's hide start ellipsis
	                                ...(activePage <= 4 && { '&.ellip-start': hiddenStyle }),
	                                // we are at the end, so let's hide end ellipsis
	                                ...(pageTotal - activePage < 4 && { '&.ellip-end:nth-last-child(3)': hiddenStyle }),
	                                // we are at the end without last page, so let's hide end ellipsis
	                                ...(pageTotal - activePage < 3 && { '&.ellip-end:nth-last-child(2)': hiddenStyle }),
	                            }),
	                },
	            },
	            span: {
	                display: 'flex',
	                justifyContent: 'center',
	                alignItems: 'center',
	                transition: `${validateProps.getTransition('background-color')}, ${validateProps.getTransition('border-color')}, ${validateProps.getTransition('color')}`, // for smooth transition between states
	                position: 'relative',
	                width: buttonSize,
	                height: buttonSize,
	                boxSizing: 'border-box',
	                ...textSmallStyle.textSmallStyle,
	                whiteSpace: 'nowrap',
	                cursor: 'pointer',
	                color: primaryColor,
	                borderRadius: borderRadiusSmall.borderRadiusSmall,
	                borderColor: 'transparent', // default value is needed for smooth transition
	                outline: 0, // TODO: only relevant for VRT testing with forced states - prevents :focus style
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: primaryColorDark,
	                }),
	                ...hoverMediaQuery.hoverMediaQuery({
	                    '&:not([aria-disabled]):not(.ellipsis):hover': {
	                        ...validateProps.frostedGlassStyle,
	                        background: hoverColor,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            background: hoverColorDark,
	                        }),
	                    },
	                }),
	                '&[aria-current]': {
	                    ...disabledCursorStyle,
	                    color: primaryColor,
	                    border: `${validateProps.borderWidthBase} solid ${primaryColor}`,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        color: primaryColorDark,
	                        borderColor: primaryColorDark,
	                    }),
	                },
	                '&[aria-disabled]': {
	                    ...disabledCursorStyle,
	                    color: disabledColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        color: disabledColorDark,
	                    }),
	                },
	                // TODO :not(.ellipsis) is only needed for VRT states tests to work properly
	                '&:not(.ellipsis)': validateProps.getFocusJssStyle(theme),
	            },
	        },
	        ellipsis: {
	            ...disabledCursorStyle,
	            '&::after': {
	                content: '"…"',
	            },
	        },
	    });
	};

	const propTypes = {
	    totalItemsCount: validateProps.AllowedTypes.number,
	    itemsPerPage: validateProps.AllowedTypes.number,
	    activePage: validateProps.AllowedTypes.number,
	    showLastPage: validateProps.AllowedTypes.boolean,
	    allyLabel: validateProps.AllowedTypes.string,
	    allyLabelPrev: validateProps.AllowedTypes.string,
	    allyLabelPage: validateProps.AllowedTypes.string,
	    allyLabelNext: validateProps.AllowedTypes.string,
	    intl: validateProps.AllowedTypes.shape({
	        root: validateProps.AllowedTypes.string,
	        prev: validateProps.AllowedTypes.string,
	        next: validateProps.AllowedTypes.string,
	        page: validateProps.AllowedTypes.string,
	    }),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Pagination = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.pageChange = validateProps.createEvent(this, "pageChange", 3);
	        this.update = validateProps.createEvent(this, "update", 3);
	        this.totalItemsCount = 1;
	        this.itemsPerPage = 1;
	        this.activePage = 1;
	        this.maxNumberOfPageLinks = undefined;
	        this.showLastPage = true;
	        this.allyLabel = undefined;
	        this.allyLabelPrev = undefined;
	        this.allyLabelPage = undefined;
	        this.allyLabelNext = undefined;
	        this.intl = {
	            root: 'Pagination',
	            prev: 'Previous page',
	            next: 'Next page',
	            page: 'Page',
	        };
	        this.theme = 'light';
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    disconnectedCallback() {
	        validateProps.unobserveBreakpointChange(this.host);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'maxNumberOfPageLinks');
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'allyLabel', 'Please use intl prop with intl.root instead.');
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'allyLabelNext', 'Please use intl prop with intl.next instead.');
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'allyLabelPrev', 'Please use intl prop with intl.prev instead.');
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'allyLabelPage', 'Please use intl prop with intl.page instead.');
	        const pageTotal = getTotalPages(this.totalItemsCount, this.itemsPerPage);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.activePage, pageTotal, this.showLastPage, this.theme);
	        const paginationItems = createPaginationItems({
	            activePage: getCurrentActivePage(this.activePage, pageTotal),
	            pageTotal,
	            showLastPage: this.showLastPage,
	        });
	        const parsedIntl = validateProps.parseJSONAttribute(this.intl);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h("nav", { key: '8577d31ced38b0be383254beb10e1800bd106522', role: "navigation", "aria-label": this.allyLabel || parsedIntl.root }, validateProps.h("ul", { key: '47fbf315df59141747302c40c2638787ba674d7e' }, paginationItems.map((pageModel, index) => {
	            const { type, isActive, value, isBeforeCurrent, isAfterCurrent, isBeforeBeforeCurrent, isAfterAfterCurrent, } = pageModel;
	            const spanProps = {
	                role: 'button',
	                tabIndex: isActive ? 0 : null,
	                onClick: () => this.onClick(value),
	                onKeyDown: (e) => this.onKeyDown(e, value),
	            };
	            const iconProps = {
	                theme: this.theme,
	                color: isActive ? 'primary' : 'state-disabled',
	                'aria-hidden': 'true',
	            };
	            switch (type) {
	                case ItemType.PREVIOUS:
	                    return (validateProps.h("li", { key: "prev", class: "prev" }, validateProps.h("span", { ...spanProps, "aria-label": this.allyLabelPrev || parsedIntl.prev, "aria-disabled": isActive ? null : 'true' }, validateProps.h(PrefixedTagNames.pIcon, { ...iconProps, name: "arrow-left" }))));
	                case ItemType.ELLIPSIS:
	                    return (validateProps.h("li", { key: "ellip", class: { ellip: true, [`ellip-${index === 2 ? 'start' : 'end'}`]: true } }, validateProps.h("span", { class: "ellipsis" })));
	                case ItemType.PAGE:
	                    return (validateProps.h("li", { key: value, class: {
	                            current: isActive,
	                            'current-1': isBeforeCurrent,
	                            'current+1': isAfterCurrent,
	                            'current-2': isBeforeBeforeCurrent,
	                            'current+2': isAfterAfterCurrent,
	                        } }, validateProps.h("span", { ...spanProps, tabIndex: 0, "aria-label": `${this.allyLabelPage || parsedIntl.page} ${value}`, "aria-current": isActive ? 'page' : null }, value)));
	                case ItemType.NEXT:
	                    return (validateProps.h("li", { key: "next", class: "next" }, validateProps.h("span", { ...spanProps, "aria-label": this.allyLabelNext || parsedIntl.next, "aria-disabled": isActive ? null : 'true' }, validateProps.h(PrefixedTagNames.pIcon, { ...iconProps, name: "arrow-right" }))));
	            }
	        }))));
	    }
	    onKeyDown(event, page) {
	        // from https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/button_role
	        const { key } = event;
	        if (key === ' ' || key === 'Enter' || key === 'Spacebar') {
	            event.preventDefault(); // prevent the default action to stop scrolling when space is pressed
	            this.onClick(page);
	        }
	    }
	    onClick(page) {
	        if (page !== this.activePage) {
	            this.update.emit({ page, previousPage: this.activePage });
	            this.pageChange.emit({ page, previousPage: this.activePage });
	            this.activePage = page; // TODO: should become a controlled component
	        }
	    }
	    static get delegatesFocus() { return true; }
	    get host() { return validateProps.getElement(this); }
	};

	pPagination_cjs_entry.p_pagination = Pagination;

	
	return pPagination_cjs_entry;
}

var pPinCode_cjs_entry = {};

var hasRequiredPPinCode_cjs_entry;

function requirePPinCode_cjs_entry () {
	if (hasRequiredPPinCode_cjs_entry) return pPinCode_cjs_entry;
	hasRequiredPPinCode_cjs_entry = 1;

	Object.defineProperty(pPinCode_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const setAttributes = requireSetAttributes642a7e67();
	const getClosestHTMLElement = requireGetClosestHTMLElement83d01a84();
	const required = requireRequiredF3c463a3();
	const isWithinForm = requireIsWithinForm3637a500();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const formStyles = requireFormStyles7e9d1c43();
	const label = requireLabel5379ea8c();
	const initialLoadingController = requireInitialLoadingController44585a09();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const getMediaQueryMax = requireGetMediaQueryMaxBbf4c490();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const fontLineHeight = requireFontLineHeight78b03658();
	requireHasNamedSlotA96fd22a();
	requireGetNamedSlotA0cdbdbc();
	requireTextSmallStyle7246779a();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireHoverMediaQuery5e6deda8();
	requireSpacingStaticMedium94812711();
	requireBorderRadiusSmall5f37fc45();
	requireFontSizeTextXSmallE59d35d7();
	requireHasDescriptionBbe55afe();
	requireIsParentOfKindB7d9f81c();

	const PIN_CODE_TYPES = ['number', 'password'];
	const PIN_CODE_LENGTHS = [1, 2, 3, 4, 5, 6];
	const removeSlottedSelector = (styles) => Object.fromEntries(Object.entries(styles).map(([key, value]) => {
	    value = typeof value === 'object' ? removeSlottedSelector(value) : value;
	    return [key.replace(/::slotted\(([^,]+)\)/g, '$1'), value];
	}));
	const removeStyles = (selector, styles) => Object.fromEntries(Object.entries(styles)
	    .filter(([key]) => key !== selector)
	    .map(([key, value]) => {
	    value = typeof value === 'object' ? removeStyles(selector, value) : value;
	    return [key, value];
	}));
	const warnAboutTransformedValue = (host, length) => {
	    const warningPrefix = `Property value of component ${validateProps.getTagNameWithoutPrefix(host)}:`;
	    validateProps.consoleWarn(warningPrefix, length
	        ? `Provided value has too many characters and was truncated to the max length of ${length}.`
	        : 'Provided value contains characters that are not of type number, the value was therefore reset.');
	};
	const isInputOnlyDigits = (input) => /^[0-9]*$/.test(input);
	const hasInputOnlyDigitsOrWhitespaces = (input) => /^[\d ]+$/.test(input);
	const getConcatenatedInputValues = (pinCodeElements) => pinCodeElements.map((el) => el.value || ' ').join('');
	// reset value if it contains invalid characters and cut string if pasted value is longer than pin code length
	const getSanitisedValue = (host, value, length) => {
	    if (value && !hasInputOnlyDigitsOrWhitespaces(value)) {
	        warnAboutTransformedValue(host);
	        return '';
	    }
	    else if (removeWhiteSpaces(value)?.length > length) {
	        warnAboutTransformedValue(host, length);
	        return value.slice(0, length);
	    }
	    else {
	        return value;
	    }
	};
	const removeWhiteSpaces = (value) => value.replace(/\s/g, '');
	const initHiddenInput = (host, name, value, disabled, required) => {
	    const hiddenInput = document.createElement('input');
	    setAttributes.setAttributes(hiddenInput, {
	        'aria-hidden': 'true',
	        slot: 'internal-input',
	        tabindex: '-1',
	    });
	    syncHiddenInput(hiddenInput, name, value, disabled, required);
	    host.prepend(hiddenInput);
	    return hiddenInput;
	};
	const syncHiddenInput = (hiddenInput, name, value, disabled, required) => {
	    setAttributes.setAttributes(hiddenInput, {
	        ...(name && { name }),
	        value: removeWhiteSpaces(value),
	    });
	    hiddenInput.toggleAttribute('disabled', disabled);
	    hiddenInput.toggleAttribute('required', required);
	};
	// This reproduces native behavior where the form is only submittable under certain circumstances
	const isFormSubmittable = (host, form) => {
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(host);
	    return !!(form.querySelectorAll('input:not([type=submit]):not([type=hidden])').length === 1 || // other sibling form elements e.g. select, textarea do not prevent submission
	        Array.from(form.querySelectorAll(`${PrefixedTagNames.pButton},${PrefixedTagNames.pButtonPure},button[type=submit],input[type=submit]`)).some((el) => el.type === 'submit'));
	};
	/**
	 * Determines if the current input element corresponds to the first non-filled input
	 *
	 * @param {number} index - The index of the current input element.
	 * @param {string} value - The input value.
	 * @param {number} length - The total number of input elements.
	 * @returns {boolean} - True if the current input should have a specific identifier, indicating it corresponds to the first non-filled input; otherwise, false.
	 */
	const isCurrentInput = (index, value, length) => {
	    if (!value) {
	        return index === 0; // No value entered at all: set current-input id on the first input element
	    }
	    const firstWhitespaceIndex = value.indexOf(' ');
	    if (firstWhitespaceIndex === -1) {
	        return index === length - 1; // All inputs have a value: set current-input id on the last input element
	    }
	    return index === firstWhitespaceIndex; // Some value is entered: set current-input id on the first input element which does not have a value
	};

	const getComponentCss = (hideLabel, state, isDisabled, isLoading, isWithinForm, length, theme) => {
	    const inputSize = `calc(${fontLineHeight.fontLineHeight} + 10px + ${validateProps.borderWidthBase} * 2 + ${spacingStaticSmall.spacingStaticSmall} * 2)`; // equivalent to calculation of input height within form-styles
	    const inputStyles = removeStyles('input[readonly]', removeSlottedSelector(formStyles.getSlottedTextFieldTextareaSelectStyles('input', state, isLoading, theme, {
	        // TODO: move into getSlottedTextFieldTextareaSelectStyles()
	        padding: `${formStyles.formElementPaddingVertical} ${spacingStaticXSmall.spacingStaticXSmall}`,
	        // TODO: move into getSlottedTextFieldTextareaSelectStyles() via parameter, e.g. textAlign=center|start
	        textAlign: 'center',
	        // TODO: move into getSlottedTextFieldTextareaSelectStyles() via parameter, e.g. size=max|min
	        width: inputSize,
	        ...(length > 4 && {
	            [getMediaQueryMax.getMediaQueryMax('xs')]: {
	                // TODO: instead of having dedicated css rules depending on length we should try to implement a fluid one fits all solution
	                width: `calc((276px - (${spacingStaticSmall.spacingStaticSmall} * ${length - 1})) / ${length})`, // calculate the max with of the inputs that fit into grid in viewport base (276px)
	            },
	        }),
	        // TODO: move into getSlottedTextFieldTextareaSelectStyles() via parameter, e.g. isLoading
	        ...(isLoading && {
	            opacity: 0.2, // TODO: not in sync with e.g. checkbox/radio-button loading style
	            cursor: 'not-allowed',
	        }),
	        // since @playwright/test@1.40.1 this does not work anymore in Webkit browser engine for unknown reasons
	        /* ...Object.fromEntries(
	          Array.from(Array(length)).map((_, i) => {
	            return [`&:nth-of-type(${i + 1})`, { gridArea: `1/${i + 1}` }];
	          })
	        ),*/
	        '&:nth-of-type(1)': { gridArea: '1/1' },
	        '&:nth-of-type(2)': { gridArea: '1/2' },
	        '&:nth-of-type(3)': { gridArea: '1/3' },
	        '&:nth-of-type(4)': { gridArea: '1/4' },
	        '&:nth-of-type(5)': { gridArea: '1/5' },
	        '&:nth-of-type(6)': { gridArea: '1/6' },
	    })));
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            // input
	            ...inputStyles,
	            ...(isWithinForm &&
	                validateProps.addImportantToEachRule({
	                    '::slotted([slot=internal-input])': {
	                        position: 'absolute',
	                        height: inputSize,
	                        width: 0,
	                        opacity: 0,
	                    },
	                })),
	        },
	        root: {
	            display: 'grid',
	            gap: spacingStaticXSmall.spacingStaticXSmall,
	        },
	        wrapper: {
	            display: 'grid',
	            gridTemplateColumns: `repeat(${length}, minmax(0, 1fr))`,
	            justifySelf: 'flex-start',
	            gap: spacingStaticSmall.spacingStaticSmall,
	        },
	        ...(isLoading && {
	            spinner: {
	                gridArea: '1/1/1/-1',
	                placeSelf: 'center',
	                width: inputSize,
	                height: inputSize,
	                pointerEvents: 'none',
	            },
	        }),
	        // .label / .required
	        ...label.getFunctionalComponentLabelStyles(isDisabled, hideLabel, theme),
	        // .message
	        ...required.getFunctionalComponentStateMessageStyles(theme, state),
	        // .loading
	        ...initialLoadingController.getFunctionalComponentLoadingMessageStyles(),
	    });
	};

	const propTypes = {
	    label: validateProps.AllowedTypes.string,
	    description: validateProps.AllowedTypes.string,
	    name: validateProps.AllowedTypes.string,
	    length: validateProps.AllowedTypes.oneOf(PIN_CODE_LENGTHS),
	    hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	    state: validateProps.AllowedTypes.oneOf(required.FORM_STATES),
	    disabled: validateProps.AllowedTypes.boolean,
	    loading: validateProps.AllowedTypes.boolean,
	    required: validateProps.AllowedTypes.boolean,
	    message: validateProps.AllowedTypes.string,
	    type: validateProps.AllowedTypes.oneOf(PIN_CODE_TYPES),
	    value: validateProps.AllowedTypes.string,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const PinCode = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.update = validateProps.createEvent(this, "update", 3);
	        this.controllerHost = new initialLoadingController.ControllerHost(this);
	        this.loadingCtrl = new initialLoadingController.InitialLoadingController(this.controllerHost);
	        this.inputElements = [];
	        this.onInput = (event) => {
	            // Validation already happened in the beforeinput event
	            const { target } = event;
	            // Android keyboard suggestion calls single input event and inputs everything in the first input. By updating our value to what has been input, the component will update and distribute the values to the corresponding inputs.
	            if (target.value.length >= this.length) {
	                const sanitisedValue = removeWhiteSpaces(getSanitisedValue(this.host, target.value, this.length));
	                this.updateValue(sanitisedValue);
	                this.focusFirstEmptyOrLastInput(sanitisedValue);
	            }
	            else {
	                // iOS keyboard suggestion calls separate input events for each digit
	                this.updateValue(getConcatenatedInputValues(this.inputElements));
	                target.nextElementSibling?.focus();
	            }
	        };
	        this.onKeyDown = (event) => {
	            const { key, target, target: { previousElementSibling, nextElementSibling }, } = event;
	            if (key === 'Backspace' || key === 'Delete') {
	                // transfer focus backward/forward, if the input value is empty
	                if (!target.value) {
	                    event.preventDefault();
	                    if (key === 'Backspace' && previousElementSibling) {
	                        previousElementSibling.value = '';
	                        previousElementSibling.focus();
	                    }
	                    else if (key === 'Delete' && nextElementSibling) {
	                        nextElementSibling.value = '';
	                        nextElementSibling.focus();
	                    }
	                }
	                target.value = '';
	                this.updateValue(getConcatenatedInputValues(this.inputElements));
	            }
	            else if (key === 'Enter') {
	                if (isWithinForm.isWithinForm && isFormSubmittable(this.host, this.form)) {
	                    this.form.requestSubmit();
	                }
	            }
	            // workaround since 'Dead' key e.g. ^¨ can not be prevented with e.preventDefault()
	            // workaround for ^ in firefox key: 'Process'
	            else if (key === 'Dead' || key === 'Process') {
	                target.blur();
	                requestAnimationFrame(() => target.focus());
	            }
	        };
	        this.onPaste = (event) => {
	            const sanitisedPastedValue = removeWhiteSpaces(getSanitisedValue(this.host, event.clipboardData.getData('Text'), this.length));
	            if (sanitisedPastedValue !== this.value) {
	                this.updateValue(sanitisedPastedValue);
	                this.focusFirstEmptyOrLastInput(sanitisedPastedValue);
	            }
	            event.preventDefault();
	        };
	        this.updateValue = (newValue) => {
	            this.value = newValue;
	            this.update.emit({ value: newValue, isComplete: removeWhiteSpaces(newValue).length === this.length });
	        };
	        this.focusFirstEmptyOrLastInput = (sanitisedValue) => {
	            this.inputElements[sanitisedValue.length === this.length ? sanitisedValue.length - 1 : sanitisedValue.length]?.focus();
	        };
	        this.label = '';
	        this.description = '';
	        this.name = undefined;
	        this.length = 4;
	        this.hideLabel = false;
	        this.state = 'none';
	        this.disabled = false;
	        this.loading = false;
	        this.required = false;
	        this.message = '';
	        this.type = 'number';
	        this.value = '';
	        this.theme = 'light';
	    }
	    componentWillLoad() {
	        this.form = getClosestHTMLElement.getClosestHTMLElement(this.host, 'form');
	        this.isWithinForm = !!this.form;
	        if (this.isWithinForm) {
	            this.hiddenInput = initHiddenInput(this.host, this.name, this.value, this.disabled, this.required);
	        }
	        this.value = getSanitisedValue(this.host, this.value, this.length);
	    }
	    componentDidLoad() {
	        // The beforeinput event is the only event which fires and can be prevented reliably on all keyboard types
	        this.inputElements.forEach((input) => input.addEventListener('beforeinput', (event) => {
	            const { data, inputType, target } = event;
	            // This is equivalent to maxLength={1} but since some keyboard suggestions fire a single input event we cant use the maxLength attribute
	            // This causes the keyboard suggestion to only work if input is empty
	            const preventMultipleInput = inputType === 'insertText' && target.value.length >= 1;
	            const preventNonDigitInput = data && !isInputOnlyDigits(data);
	            if (preventMultipleInput || preventNonDigitInput || this.loading) {
	                event.preventDefault();
	            }
	        }));
	    }
	    componentWillUpdate() {
	        if (this.isWithinForm) {
	            syncHiddenInput(this.hiddenInput, this.name, this.value, this.disabled, this.required);
	        }
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.hideLabel, this.state, this.disabled, this.loading, this.isWithinForm, this.length, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        // reset array of input elements
	        this.inputElements = [];
	        const currentInputId = 'current-input';
	        return (validateProps.h("div", { key: '9d77d84be840fbe07fb0bd6952d9c22bf2c03136', class: "root" }, validateProps.h(label.Label, { key: 'ee3e3924df807571a8456c24daed5a5c9b1bebe1', host: this.host, label: this.label, description: this.description, htmlFor: currentInputId, isRequired: this.required, isLoading: this.loading, isDisabled: this.disabled }), validateProps.h("div", { key: '73432cea3f352e26c61372f8e1f5b9743c0b1c25', class: "wrapper", onKeyDown: this.onKeyDown, onPaste: this.onPaste, onInput: this.onInput }, Array.from(Array(this.length), (_, index) => (validateProps.h("input", { key: index, ...(isCurrentInput(index, this.value, this.length) && { id: currentInputId }), type: this.type === 'number' ? 'text' : this.type, "aria-label": `${index + 1}-${this.length}`, "aria-describedby": `${label.labelId} ${label.descriptionId} ${required.messageId}`, "aria-invalid": this.state === 'error' ? 'true' : null, "aria-disabled": this.loading ? 'true' : null, autoComplete: "one-time-code", pattern: "\\d*", inputMode: "numeric" // get numeric keyboard on mobile
	            ,
	            value: this.value[index] === ' ' ? null : this.value[index], disabled: this.disabled, required: this.required, ref: (el) => this.inputElements.push(el) }))), this.loading && (validateProps.h(PrefixedTagNames.pSpinner, { class: "spinner", size: "inherit", theme: this.theme, "aria-hidden": "true" }))), validateProps.h(required.StateMessage, { key: 'a7788716a44fc3fdd3368ba5812897c2fb1db6a9', state: this.state, message: this.message, theme: this.theme, host: this.host }), this.isWithinForm && validateProps.h("slot", { name: "internal-input" }), validateProps.h(initialLoadingController.LoadingMessage, { key: '75616cf23346c54fc80ebacccb0a3b5e163e5a08', loading: this.loading, initialLoading: this.loadingCtrl.initialLoading })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pPinCode_cjs_entry.p_pin_code = PinCode;

	
	return pPinCode_cjs_entry;
}

var pPopover_cjs_entry = {};

var hasRequiredPPopover_cjs_entry;

function requirePPopover_cjs_entry () {
	if (hasRequiredPPopover_cjs_entry) return pPopover_cjs_entry;
	hasRequiredPPopover_cjs_entry = 1;

	Object.defineProperty(pPopover_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const popoverResetStyles = requirePopoverResetStylesFad56b6d();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const constants = requireConstantsCa271244();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const fontLineHeight = requireFontLineHeight78b03658();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const theme = requireThemeBfc10573();
	requireScrollerPopoverUtils89485ebc();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();

	const { canvasColor, canvasTextColor } = validateProps.getHighContrastColors();
	const directionPositionMap = {
	    top: {
	        bottom: '100%',
	        left: '50%',
	        transform: 'translate3d(-50%, 0, 0)', // translate3d used to fix Safari shadow bug
	    },
	    right: {
	        top: '50%',
	        left: '100%',
	        transform: 'translate3d(0, -50%, 0)',
	    },
	    bottom: {
	        top: '100%',
	        left: '50%',
	        transform: 'translate3d(-50%, 0, 0)',
	    },
	    left: {
	        top: '50%',
	        right: '100%',
	        transform: 'translate3d(0, -50%, 0)',
	    },
	};
	const borderWidth = '12px';
	const transparentColor = 'transparent';
	const join = (...arr) => arr.join(' ');
	const getDirectionArrowMap = (theme) => {
	    const { backgroundColor, backgroundSurfaceColor } = validateProps.getThemedColors(theme);
	    const { backgroundSurfaceColor: backgroundSurfaceColorDark } = validateProps.getThemedColors('dark');
	    const isDark = validateProps.isThemeDark(theme);
	    return {
	        top: {
	            top: 0,
	            left: '50%',
	            transform: 'translateX(-50%)',
	            borderWidth: join(borderWidth, borderWidth, 0),
	            ...(validateProps.isHighContrastMode
	                ? {
	                    borderColor: join(canvasTextColor, canvasColor, canvasColor),
	                }
	                : {
	                    borderColor: join(isDark ? backgroundSurfaceColor : backgroundColor, transparentColor, transparentColor),
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        borderColor: join(backgroundSurfaceColorDark, transparentColor, transparentColor),
	                    }),
	                }),
	        },
	        right: {
	            top: '50%',
	            right: 0,
	            transform: 'translateY(-50%)',
	            borderWidth: join(borderWidth, borderWidth, borderWidth, 0),
	            ...(validateProps.isHighContrastMode
	                ? {
	                    borderColor: join(canvasColor, canvasTextColor, canvasColor, canvasColor),
	                }
	                : {
	                    borderColor: join(transparentColor, isDark ? backgroundSurfaceColor : backgroundColor, transparentColor, transparentColor),
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        borderColor: join(transparentColor, backgroundSurfaceColorDark, transparentColor, transparentColor),
	                    }),
	                }),
	        },
	        bottom: {
	            bottom: 0,
	            left: '50%',
	            transform: 'translateX(-50%)',
	            borderWidth: join(0, borderWidth, borderWidth),
	            ...(validateProps.isHighContrastMode
	                ? {
	                    borderColor: join(canvasColor, canvasColor, canvasTextColor),
	                }
	                : {
	                    borderColor: join(transparentColor, transparentColor, isDark ? backgroundSurfaceColor : backgroundColor),
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        borderColor: join(transparentColor, transparentColor, backgroundSurfaceColorDark),
	                    }),
	                }),
	        },
	        left: {
	            top: '50%',
	            left: 0,
	            transform: 'translateY(-50%)',
	            borderWidth: join(borderWidth, 0, borderWidth, borderWidth),
	            ...(validateProps.isHighContrastMode
	                ? {
	                    borderColor: join(canvasColor, canvasColor, canvasColor, canvasTextColor),
	                }
	                : {
	                    borderColor: join(transparentColor, transparentColor, transparentColor, isDark ? backgroundSurfaceColor : backgroundColor),
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        borderColor: join(transparentColor, transparentColor, transparentColor, backgroundSurfaceColorDark),
	                    }),
	                }),
	        },
	    };
	};
	const getComponentCss = (direction, isNativePopoverCase, theme) => {
	    const { hoverColor, backgroundColor, primaryColor, backgroundSurfaceColor } = validateProps.getThemedColors(theme);
	    const { hoverColor: hoverColorDark, primaryColor: primaryColorDark, backgroundSurfaceColor: backgroundSurfaceColorDark, } = validateProps.getThemedColors('dark');
	    const shadowColor = 'rgba(0,0,0,0.3)';
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'inline-block',
	                verticalAlign: 'top',
	                ...validateProps.addImportantToEachRule({
	                    position: 'relative',
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            p: {
	                ...textSmallStyle.textSmallStyle,
	                margin: 0,
	            },
	            button: {
	                display: 'block',
	                WebkitAppearance: 'none', // iOS safari
	                appearance: 'none',
	                background: 'transparent',
	                border: 0,
	                padding: 0,
	                cursor: 'pointer',
	                ...textSmallStyle.textSmallStyle,
	                width: fontLineHeight.fontLineHeight, // width needed to improve ssr support
	                height: fontLineHeight.fontLineHeight, // height needed to improve ssr support
	                borderRadius: '50%',
	                // TODO: we should try to use getHoverStyle()
	                ...hoverMediaQuery.hoverMediaQuery({
	                    transition: validateProps.getTransition('background-color'),
	                    '&:hover': {
	                        ...validateProps.frostedGlassStyle,
	                        backgroundColor: hoverColor,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            backgroundColor: hoverColorDark,
	                        }),
	                    },
	                }),
	                ...validateProps.getFocusJssStyle(theme, { offset: 0 }),
	            },
	        },
	        label: validateProps.getHiddenTextJssStyle(),
	        icon: {
	            transform: 'translate3d(0,0,0)', // Fixes movement on hover in Safari
	        },
	        spacer: {
	            ...(isNativePopoverCase
	                ? {
	                    ...popoverResetStyles.getPopoverResetJssStyle(),
	                }
	                : {
	                    inset: `${-safeZonePx}px`,
	                }),
	            position: 'absolute',
	            zIndex: constants.POPOVER_Z_INDEX,
	            filter: `drop-shadow(0 0 16px ${shadowColor})`,
	            backdropFilter: 'drop-shadow(0px 0px 0px transparent)', // fixes issues with Chrome >= 105 where filter: drop-shadow is not applied correctly after animation ends
	            pointerEvents: 'none',
	            animation: `${validateProps.motionDurationShort} $fadeIn ${validateProps.motionEasingBase} forwards`
	                ,
	            '&::before': {
	                content: '""',
	                position: 'absolute',
	                borderStyle: 'solid',
	                ...getDirectionArrowMap(theme)[direction],
	            },
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                filter: `drop-shadow(0 0 16px ${shadowColor})`,
	            }),
	        },
	        popover: {
	            position: 'absolute',
	            maxWidth: 'min(90vw, 27rem)',
	            width: 'max-content',
	            boxSizing: 'border-box',
	            background: validateProps.isThemeDark(theme) ? backgroundSurfaceColor : backgroundColor,
	            padding: '8px 16px',
	            pointerEvents: 'auto',
	            ...directionPositionMap[direction],
	            ...textSmallStyle.textSmallStyle,
	            listStyleType: 'none',
	            color: primaryColor,
	            whiteSpace: 'inherit',
	            borderRadius: borderRadiusSmall.borderRadiusSmall,
	            ...(validateProps.isHighContrastMode && {
	                outline: `1px solid ${canvasTextColor}`,
	            }),
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                background: backgroundSurfaceColorDark,
	                color: primaryColorDark,
	            }),
	        },
	        '@keyframes fadeIn': {
	            from: {
	                opacity: 0,
	            },
	            to: {
	                opacity: 1,
	            },
	        },
	    });
	};

	const POPOVER_DIRECTIONS = ['top', 'right', 'bottom', 'left'];
	const POPOVER_ARIA_ATTRIBUTES = ['aria-label'];
	const safeZonePx = 16;
	const updatePopoverStyles = (host, spacer, popover, direction, isNative = false, theme) => {
	    // Reset margin so that it can be recalculated correctly
	    popover.style.margin = '0';
	    if (!isElementWithinViewport(spacer, popover, direction)) {
	        direction = getAutoDirection(spacer, popover);
	        validateProps.attachComponentCss(host, getComponentCss, direction, isNative, theme);
	    }
	    // Set margin via inline style to make attachComponentCss cacheable
	    popover.style.margin = getPopoverMargin(spacer, popover, direction);
	};
	const updateNativePopoverStyles = (nativePopover, nativeButton) => {
	    const { left, top, width, height } = nativeButton.getBoundingClientRect();
	    nativePopover.style.left = `${left + window.scrollX - safeZonePx}px`;
	    nativePopover.style.top = `${top + window.scrollY - safeZonePx}px`;
	    nativePopover.style.width = `${width + safeZonePx * 2}px`;
	    nativePopover.style.height = `${height + safeZonePx * 2}px`;
	};
	const getDocumentHeightWidthWithoutSafeZone = () => {
	    const { clientWidth, clientHeight } = document.documentElement;
	    return { clientWidth: clientWidth - safeZonePx, clientHeight: clientHeight - safeZonePx };
	};
	const isElementWithinViewport = (spacer, popover, direction) => {
	    const { clientWidth, clientHeight } = getDocumentHeightWidthWithoutSafeZone();
	    const spacerRect = spacer.getBoundingClientRect();
	    const popoverRect = popover.getBoundingClientRect();
	    const isWithinXAxis = spacerRect.left >= safeZonePx && spacerRect.right <= clientWidth;
	    const isWithinYAxis = spacerRect.top >= safeZonePx && spacerRect.bottom <= clientHeight;
	    switch (direction) {
	        case 'top':
	            return isWithinXAxis && popoverRect.top >= safeZonePx;
	        case 'right':
	            return isWithinYAxis && popoverRect.right <= clientWidth;
	        case 'bottom':
	            return isWithinXAxis && popoverRect.bottom <= clientHeight;
	        case 'left':
	            return isWithinYAxis && popoverRect.left >= safeZonePx;
	    }
	};
	const calcSpaceForDirections = (spacer, popover) => {
	    const { clientWidth, clientHeight } = document.documentElement;
	    const spacerRect = spacer.getBoundingClientRect();
	    const popoverRect = popover.getBoundingClientRect();
	    // determine the **theoretically** maximum available space in all directions within viewport
	    return {
	        top: spacerRect.top - popoverRect.height,
	        right: clientWidth - (spacerRect.right + popoverRect.width),
	        bottom: clientHeight - (spacerRect.bottom + popoverRect.height),
	        left: spacerRect.left - popoverRect.width,
	    };
	};
	const getAutoDirection = (spacer, popover) => {
	    const directionSpaces = calcSpaceForDirections(spacer, popover);
	    // Find direction with the most space
	    return Object.keys(directionSpaces).reduce((resultDirection, currentDirection) => directionSpaces[resultDirection] >= directionSpaces[currentDirection] ? resultDirection : currentDirection, 'bottom');
	};
	const getPopoverMargin = (spacer, popover, direction) => {
	    const { clientWidth, clientHeight } = getDocumentHeightWidthWithoutSafeZone();
	    const spacerRect = spacer.getBoundingClientRect();
	    const popoverRect = popover.getBoundingClientRect();
	    // check x-axis offset is relevant for popover
	    if (['top', 'bottom'].includes(direction) && popoverRect.width > spacerRect.width) {
	        // check if popover exceeds left side of viewport
	        if (popoverRect.left < safeZonePx) {
	            return `0 0 0 ${Math.min(safeZonePx - popoverRect.left, spacerRect.left - popoverRect.left)}px`;
	        }
	        // check if popover exceeds right side of viewport
	        else if (popoverRect.right > clientWidth) {
	            return `0 0 0 ${Math.max(clientWidth - popoverRect.right, spacerRect.right - popoverRect.right)}px`;
	        }
	    }
	    // check y-axis offset is relevant for popover
	    else if (['left', 'right'].includes(direction) && popoverRect.height > spacerRect.height) {
	        // check if popover exceeds top side of viewport
	        if (popoverRect.top < safeZonePx) {
	            return `${Math.min(safeZonePx - popoverRect.top, spacerRect.top - popoverRect.top)}px 0 0 0`;
	        }
	        // check if popover exceeds bottom side of viewport
	        else if (popoverRect.bottom > clientHeight) {
	            return `${Math.max(clientHeight - popoverRect.bottom, spacerRect.bottom - popoverRect.bottom)}px 0 0 0`;
	        }
	    }
	    else {
	        return '0';
	    }
	};
	const registeredPopovers = [];
	const addDocumentEventListener = (popover) => {
	    if (!registeredPopovers.includes(popover)) {
	        registeredPopovers.push(popover);
	        document.addEventListener('mousedown', onDocumentMousedown); // multiple calls don't add multiple listeners
	        document.addEventListener('keydown', onDocumentKeydown); // multiple calls don't add multiple listeners
	    }
	};
	const removeDocumentEventListener = (popover) => {
	    const index = registeredPopovers.indexOf(popover);
	    if (index > -1) {
	        registeredPopovers.splice(index, 1);
	    }
	    if (registeredPopovers.length === 0) {
	        document.removeEventListener('mousedown', onDocumentMousedown);
	        document.removeEventListener('keydown', onDocumentKeydown);
	    }
	};
	const onDocumentMousedown = (e) => {
	    const popover = registeredPopovers.find((popoverItem) => popoverItem.open && popoverResetStyles.isClickOutside(e, popoverItem.host));
	    if (popover) {
	        popover.open = false;
	    }
	};
	const onDocumentKeydown = (e) => {
	    const { key } = e;
	    const isEscape = key === 'Escape';
	    if (isEscape || key === 'Enter' || key === 'SpaceBar' || key === ' ') {
	        const popover = registeredPopovers.find((popoverItem) => popoverItem.open && (isEscape || popoverResetStyles.isClickOutside(e, popoverItem.host)));
	        if (popover) {
	            popover.open = false;
	        }
	    }
	};

	const propTypes = {
	    direction: validateProps.AllowedTypes.oneOf(POPOVER_DIRECTIONS),
	    description: validateProps.AllowedTypes.string,
	    aria: validateProps.AllowedTypes.aria(POPOVER_ARIA_ATTRIBUTES),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Popover = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.isNativePopoverCase = false;
	        this.onKeydown = (e) => {
	            if (e.key === 'Escape') {
	                this.button.focus();
	            }
	        };
	        this.onToggle = (e) => {
	            if (e.newState === 'open') {
	                validateProps.forceUpdate(this.host); // Necessary to update popover styles since opening of native popover doesn't trigger rerender
	            }
	        };
	        this.direction = 'bottom';
	        this.description = undefined;
	        this.aria = undefined;
	        this.theme = 'light';
	        this.open = false;
	    }
	    connectedCallback() {
	        addDocumentEventListener(this);
	        this.isNativePopoverCase = popoverResetStyles.detectNativePopoverCase(this.host, false);
	        if (this.isNativePopoverCase) {
	            this.parentTableElement = popoverResetStyles.findClosestComponent(this.host, 'pTable');
	        }
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    componentDidRender() {
	        if (this.isNativePopoverCase && this.spacer?.matches(':popover-open')) {
	            popoverResetStyles.addNativePopoverScrollAndResizeListeners(this.host, this.parentTableElement, this.spacer);
	            // Set new popover position depending on button position
	            updateNativePopoverStyles(this.spacer, this.button);
	            // Update popover styles with new position
	            updatePopoverStyles(this.host, this.spacer, this.popover, this.direction, this.isNativePopoverCase, this.theme);
	        }
	        else {
	            if (this.open) {
	                // calculate / update position only possible after render
	                updatePopoverStyles(this.host, this.spacer, this.popover, this.direction, false, this.theme);
	            }
	        }
	    }
	    disconnectedCallback() {
	        removeDocumentEventListener(this);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.direction, this.isNativePopoverCase, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(validateProps.Host, { key: '128cef418e478cdf0b7e303dd560dc245409745b', onKeydown: this.onKeydown }, validateProps.h("button", { key: '5f6c4dcfb10cc3b8384400fd2e745484061a0704', type: "button", ...(this.isNativePopoverCase ? { popoverTarget: 'spacer' } : { onClick: () => (this.open = !this.open) }), ...validateProps.parseAndGetAriaAttributes({
	                ...validateProps.parseAndGetAriaAttributes(this.aria),
	                ...(!this.isNativePopoverCase && { 'aria-expanded': this.open }),
	            }), ref: (el) => (this.button = el) }, validateProps.h(PrefixedTagNames.pIcon, { key: '7a04f5e1c643f8fc37fcbc5009ae28ceb0681f49', class: "icon", name: "information", theme: this.theme }), validateProps.h("span", { key: '7c3ac5b2579b3d03d2ce79421e4ebfa1294f52c7', class: "label" }, "More information")), (this.open || this.isNativePopoverCase) && (validateProps.h("div", { class: "spacer", ref: (el) => (this.spacer = el), ...(this.isNativePopoverCase && { popover: 'auto', id: 'spacer', onToggle: this.onToggle }) }, validateProps.h("div", { class: "popover", ref: (el) => (this.popover = el) }, this.description ? validateProps.h("p", null, this.description) : validateProps.h("slot", null))))));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pPopover_cjs_entry.p_popover = Popover;

	
	return pPopover_cjs_entry;
}

var pRadioButtonWrapper_cjs_entry = {};

var hasRequiredPRadioButtonWrapper_cjs_entry;

function requirePRadioButtonWrapper_cjs_entry () {
	if (hasRequiredPRadioButtonWrapper_cjs_entry) return pRadioButtonWrapper_cjs_entry;
	hasRequiredPRadioButtonWrapper_cjs_entry = 1;

	Object.defineProperty(pRadioButtonWrapper_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const required = requireRequiredF3c463a3();
	const theme = requireThemeBfc10573();
	const getOnlyChildOfKindHTMLElementOrThrow = requireGetOnlyChildOfKindHTMLElementOrThrowF7285231();
	const checkboxRadioStyles = requireCheckboxRadioStylesE83cbdf9();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const isDisabledOrLoading = requireIsDisabledOrLoadingB1f56d7f();
	const escapeHashCharacter = requireEscapeHashCharacterB9f68bcf();
	const label = requireLabel5379ea8c();
	const initialLoadingController = requireInitialLoadingController44585a09();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const fontLineHeight = requireFontLineHeight78b03658();
	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	requireHasNamedSlotA96fd22a();
	requireGetNamedSlotA0cdbdbc();
	requireTextSmallStyle7246779a();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireGetDirectChildHTMLElements31d23fa9();
	requireGetHTMLElements3f1c700f();
	requireTransformSelectorToDirectChildSelectorC1b1f9b0();
	requireHoverMediaQuery5e6deda8();
	requireFontSizeTextXSmallE59d35d7();
	requireGetClosestHTMLElement83d01a84();
	requireHasDescriptionBbe55afe();
	requireIsParentOfKindB7d9f81c();

	const getCheckedSVGBackgroundImage = (fill) => {
	    return escapeHashCharacter.getInlineSVGBackgroundImage(`<circle fill="${fill}" cx="12" cy="12" r="6"/>`);
	};
	const getComponentCss = (hideLabel, state, isDisabled, isLoading, theme) => {
	    const checkedIconColor = validateProps.isHighContrastMode
	        ? validateProps.getHighContrastColors().canvasColor
	        : escapeHashCharacter.escapeHashCharacter(validateProps.getInvertedThemedColors(theme).primaryColor);
	    const checkedIconColorDark = validateProps.isHighContrastMode
	        ? validateProps.getHighContrastColors().canvasColor
	        : escapeHashCharacter.escapeHashCharacter(validateProps.getInvertedThemedColors('dark').primaryColor);
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            // ::slotted(input)
	            ...validateProps.addImportantToEachRule(validateProps.mergeDeep(checkboxRadioStyles.getSlottedCheckboxRadioButtonStyles(state, isDisabled, isLoading, theme), {
	                '::slotted': {
	                    '&(input)': {
	                        gridArea: '1/1',
	                        borderRadius: '50%',
	                    },
	                    // TODO: is it somehow useful possible to make following styles configurable by paramter?
	                    ...(!isLoading && {
	                        '&(input:checked)': {
	                            backgroundImage: getCheckedSVGBackgroundImage(checkedIconColor),
	                            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                                backgroundImage: getCheckedSVGBackgroundImage(checkedIconColorDark),
	                            }),
	                        },
	                    }),
	                },
	            })),
	        },
	        root: {
	            display: 'grid',
	            gridTemplateColumns: 'auto minmax(0, 1fr)',
	            rowGap: spacingStaticXSmall.spacingStaticXSmall,
	        },
	        wrapper: {
	            display: 'grid',
	            gridArea: '1/1',
	            alignSelf: 'flex-start', // in case label becomes multiline
	            ...(isDisabledOrLoading.isDisabledOrLoading(isDisabled, isLoading) && {
	                // TODO: maybe .wrapper should handle it for all form components while pointer-events: none is set to input
	                cursor: 'not-allowed',
	            }),
	        },
	        ...(isLoading && {
	            // TODO: extract for checkbox-wrapper and radio-button-wrapper (not gridArea and placeSelf)
	            spinner: {
	                position: 'relative', // ensure correct stacking, can be removed as soon as focus for input is handled with outline
	                gridArea: '1/1',
	                placeSelf: 'center',
	                width: fontLineHeight.fontLineHeight,
	                height: fontLineHeight.fontLineHeight,
	                font: `${fontSizeTextSmall.fontSizeTextSmall} ${fontLineHeight.fontFamily}`, // needed for correct width and height definition based on ex-unit
	                pointerEvents: 'none',
	            },
	        }),
	        // .label / .required
	        ...label.getFunctionalComponentLabelStyles(isDisabled || isLoading, hideLabel, theme, {
	            gridArea: '1/2',
	        }, {
	            paddingTop: '2px', // compensate vertical alignment
	            paddingInlineStart: spacingStaticSmall.spacingStaticSmall, // asymmetric padding used instead of gap to prevent not clickable area between label and input
	        }),
	        // .message
	        ...required.getFunctionalComponentStateMessageStyles(theme, state, {
	            gridColumn: '1/3',
	        }),
	        // .loading
	        ...initialLoadingController.getFunctionalComponentLoadingMessageStyles(),
	    });
	};

	const propTypes = {
	    label: validateProps.AllowedTypes.string,
	    state: validateProps.AllowedTypes.oneOf(required.FORM_STATES),
	    message: validateProps.AllowedTypes.string,
	    hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	    loading: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const RadioButtonWrapper = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.controllerHost = new initialLoadingController.ControllerHost(this);
	        this.loadingCtrl = new initialLoadingController.InitialLoadingController(this.controllerHost);
	        this.observeAttributes = () => {
	            validateProps.observeAttributes(this.input, ['disabled', 'required'], () => validateProps.forceUpdate(this.host));
	        };
	        this.label = '';
	        this.state = 'none';
	        this.message = '';
	        this.hideLabel = false;
	        this.loading = false;
	        this.theme = 'light';
	    }
	    connectedCallback() {
	        checkboxRadioStyles.applyCheckboxRadioButtonSafariRenderingFix(this.host);
	        this.observeAttributes(); // on every reconnect
	    }
	    componentWillLoad() {
	        this.input = getOnlyChildOfKindHTMLElementOrThrow.getOnlyChildOfKindHTMLElementOrThrow(this.host, 'input[type=radio]');
	        this.observeAttributes(); // once initially
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    componentDidRender() {
	        /*
	         * This is a workaround to improve accessibility because the input and the label/description/message text are placed in different DOM.
	         * Referencing ID's from outside the component is impossible because the web component’s DOM is separate.
	         * We have to wait for full support of the Accessibility Object Model (AOM) to provide the relationship between shadow DOM and slots
	         */
	        validateProps.setAriaAttributes(this.input, {
	            label: this.label,
	            message: this.message,
	            state: this.state,
	        });
	    }
	    disconnectedCallback() {
	        validateProps.unobserveAttributes(this.input);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        const { disabled } = this.input;
	        const isLoading = this.loading && !this.input.checked; // spinner is only displayed when radio is not checked already
	        validateProps.attachComponentCss(this.host, getComponentCss, this.hideLabel, this.state, disabled, isLoading, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h("div", { key: 'e546723ec30f763a2ca4e732f62b1812c0a949d0', class: "root" }, validateProps.h(label.Label, { key: '50aa4d11d4e291ea409329fbaf67d4cb34cdfbd0', host: this.host, label: this.label, isLoading: isLoading, isDisabled: disabled, formElement: this.input }), validateProps.h("div", { key: 'ef53b552f4da0733349a5e1b51dd78e85cc3567b', class: "wrapper" }, validateProps.h("slot", { key: 'b560651c5670b339b8ee27f5a5d9f979212b8040' }), isLoading && (validateProps.h(PrefixedTagNames.pSpinner, { class: "spinner", size: "inherit", theme: this.theme, "aria-hidden": "true" }))), validateProps.h(required.StateMessage, { key: 'a5a98654b212b0ff367c6d1937b068748bb33008', state: this.state, message: this.message, theme: this.theme, host: this.host }), validateProps.h(initialLoadingController.LoadingMessage, { key: 'edf32dc9835718bd8d5409e8ba70ec789a4d98cf', loading: isLoading, initialLoading: this.loadingCtrl.initialLoading })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pRadioButtonWrapper_cjs_entry.p_radio_button_wrapper = RadioButtonWrapper;

	
	return pRadioButtonWrapper_cjs_entry;
}

var pScroller_cjs_entry = {};

var scrolling7e2aff99 = {};

var hasRequiredScrolling7e2aff99;

function requireScrolling7e2aff99 () {
	if (hasRequiredScrolling7e2aff99) return scrolling7e2aff99;
	hasRequiredScrolling7e2aff99 = 1;

	requireValidatePropsF6586828();
	const scrollerPopoverUtils = requireScrollerPopoverUtils89485ebc();
	const getHTMLElements = requireGetHTMLElements3f1c700f();

	const SCROLLER_ARIA_ATTRIBUTES = ['role'];
	/** @deprecated */
	const GRADIENT_COLOR_SCHEMES = ['default', 'surface'];
	const GRADIENT_COLORS = ['background-base', 'background-surface'];
	const SCROLL_INDICATOR_POSITIONS = ['top', 'center'];
	const getScrollPositionAfterPrevNextClick = (scrollAreaElement, direction) => {
	    const { scrollLeft } = scrollAreaElement;
	    const scrollByX = getScrollByX(scrollAreaElement);
	    return direction === 'next' ? scrollLeft + scrollByX : scrollLeft - scrollByX;
	};
	const getScrollerElements = (scrollerElement) => {
	    return getHTMLElements.getHTMLElements(scrollerElement.shadowRoot, `.${scrollerPopoverUtils.scrollAreaClass},.action-prev`);
	};
	const isScrollable = (isPrevHidden, isNextHidden) => {
	    return !(isPrevHidden && isNextHidden);
	};

	const scrollElementTo = (el, amount) => {
	    el.scrollTo({
	        left: amount,
	        behavior: 'smooth', // TODO: make conditional so we don't need to wait in e2e or vrt tests
	    });
	};
	const getScrollByX = (scrollAreaElement) => {
	    return Math.round(scrollAreaElement.offsetWidth * 0.2);
	};
	const FOCUS_PADDING_WIDTH = 4;
	const getScrollActivePosition = (elements, direction, activeElementIndex, scrollerElement) => {
	    const { offsetLeft: activeElementOffsetLeft, offsetWidth: activeElementOffsetWidth } = elements[activeElementIndex <= 0 ? 0 : activeElementIndex] || {}; // empty object fallback for tabs without children
	    // offsetLeft: is the number of pixels that the upper left corner of the current element is offset to the left within the offsetParent node
	    // offsetParent: is a reference to the element which is the closest (nearest in the containment hierarchy) positioned ancestor element
	    // which usually is an element with a non-static position
	    // - in chrome this seems to respect shadow DOM and therefore is the div.scroll-wrapper element in p-scroller
	    // - in firefox and safari this is not the case and some other parent element (up to the body element) is used
	    // this obviously leads to completely wrong calculations which are being corrected
	    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetLeft
	    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent
	    const correctedActiveElementOffsetLeft = elements[0]?.offsetLeft === 0 ? activeElementOffsetLeft : activeElementOffsetLeft - scrollerElement.offsetLeft;
	    const [scrollAreaElement, prevGradientElement] = getScrollerElements(scrollerElement);
	    let scrollPosition;
	    if (direction === 'next') {
	        if (activeElementIndex === elements.length - 1) {
	            // go to last element
	            scrollPosition = correctedActiveElementOffsetLeft - FOCUS_PADDING_WIDTH;
	        }
	        else {
	            // go to next element
	            scrollPosition = correctedActiveElementOffsetLeft - prevGradientElement.offsetWidth + FOCUS_PADDING_WIDTH * 2;
	        }
	    }
	    else {
	        if (activeElementIndex === 0) {
	            // go to first element
	            scrollPosition = 0;
	        }
	        else {
	            // go to prev element
	            scrollPosition =
	                correctedActiveElementOffsetLeft +
	                    activeElementOffsetWidth +
	                    prevGradientElement.offsetWidth -
	                    scrollAreaElement.offsetWidth;
	        }
	    }
	    return scrollPosition;
	};

	scrolling7e2aff99.GRADIENT_COLORS = GRADIENT_COLORS;
	scrolling7e2aff99.GRADIENT_COLOR_SCHEMES = GRADIENT_COLOR_SCHEMES;
	scrolling7e2aff99.SCROLLER_ARIA_ATTRIBUTES = SCROLLER_ARIA_ATTRIBUTES;
	scrolling7e2aff99.SCROLL_INDICATOR_POSITIONS = SCROLL_INDICATOR_POSITIONS;
	scrolling7e2aff99.getScrollActivePosition = getScrollActivePosition;
	scrolling7e2aff99.getScrollPositionAfterPrevNextClick = getScrollPositionAfterPrevNextClick;
	scrolling7e2aff99.isScrollable = isScrollable;
	scrolling7e2aff99.scrollElementTo = scrollElementTo;

	
	return scrolling7e2aff99;
}

var hasRequiredPScroller_cjs_entry;

function requirePScroller_cjs_entry () {
	if (hasRequiredPScroller_cjs_entry) return pScroller_cjs_entry;
	hasRequiredPScroller_cjs_entry = 1;

	Object.defineProperty(pScroller_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const scrollerPopoverUtils = requireScrollerPopoverUtils89485ebc();
	const getHTMLElements = requireGetHTMLElements3f1c700f();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed2d6d1d94();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed0dc3288b();
	const scrolling = requireScrolling7e2aff99();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const fontLineHeight = requireFontLineHeight78b03658();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const dropShadowShared = requireDropShadowShared6e50faf3();
	requireHelperA66adcf2();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();

	const dropShadowLowStyle = {
	    boxShadow: `0px 3px 8px ${dropShadowShared._dropShadowBackgroundColor}`, // filter: drop-shadow() causes visual glitches in Firefox in combination with frostedGlassStyle
	};

	const gradientColorLight = {
	    'background-base': '255,255,255',
	    'background-surface': '238,239,242',
	};
	const gradientColorDark = {
	    'background-base': '14,14,18',
	    'background-surface': '33,34,37',
	};
	const gradientColorMap = {
	    auto: gradientColorLight,
	    light: gradientColorLight,
	    dark: gradientColorDark,
	};
	const getGradient = (theme, gradientColorTheme) => {
	    const gradientColor = gradientColorMap[theme][gradientColorTheme];
	    return (`rgba(${gradientColor},1) 20%,` +
	        `rgba(${gradientColor},0.6) 48%,` +
	        `rgba(${gradientColor},0.3) 68%,` +
	        `rgba(${gradientColor},0)`);
	};
	const prevNextWrapperWidth = `calc(${fontLineHeight.fontLineHeight} + 24px)`;
	const getComponentCss = (gradientColor, isNextHidden, isPrevHidden, scrollIndicatorPosition, hasScrollbar, theme) => {
	    const { backgroundColor, backgroundSurfaceColor, hoverColor } = validateProps.getThemedColors(theme);
	    const { backgroundColor: backgroundColorDark, backgroundSurfaceColor: backgroundSurfaceColorDark, hoverColor: hoverColorDark, } = validateProps.getThemedColors('dark');
	    const backgroundColorLight = {
	        'background-base': backgroundColor,
	        'background-surface': backgroundSurfaceColor,
	    };
	    const backgroundColorMap = {
	        auto: backgroundColorLight,
	        light: backgroundColorLight,
	        dark: {
	            'background-base': backgroundSurfaceColorDark,
	            'background-surface': backgroundColorDark,
	        },
	    };
	    const actionPrevNextStyles = {
	        position: 'absolute',
	        top: 0,
	        bottom: 0,
	        direction: 'ltr',
	        width: prevNextWrapperWidth,
	        padding: '4px 0',
	        pointerEvents: 'none',
	        display: 'flex',
	        alignItems: scrollIndicatorPosition === 'center' ? 'center' : 'flex-start',
	    };
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    height: 'inherit',
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            button: {
	                display: 'flex',
	                pointerEvents: 'auto',
	                alignItems: 'center',
	                justifyContent: 'center',
	                ...textSmallStyle.textSmallStyle,
	                height: `calc(${fontLineHeight.fontLineHeight} + 4px)`,
	                width: `calc(${fontLineHeight.fontLineHeight} + 4px)`,
	                border: 0,
	                outline: 0,
	                cursor: 'pointer',
	                background: backgroundColorMap[theme][gradientColor],
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    background: backgroundColorMap.dark[gradientColor],
	                }),
	                borderRadius: borderRadiusSmall.borderRadiusSmall,
	                ...validateProps.frostedGlassStyle,
	                visibility: 'hidden',
	                ...(!validateProps.isThemeDark(theme) && dropShadowLowStyle),
	                ...hoverMediaQuery.hoverMediaQuery({
	                    transition: validateProps.getTransition('background-color'),
	                    '&:hover': {
	                        ...validateProps.frostedGlassStyle,
	                        background: hoverColor,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            background: hoverColorDark,
	                        }),
	                    },
	                }),
	            },
	        },
	        root: {
	            position: 'relative',
	            display: 'grid',
	            gridTemplateColumns: `${prevNextWrapperWidth} minmax(0, 1fr) ${prevNextWrapperWidth}`,
	            margin: '0 -4px',
	            height: 'inherit',
	        },
	        'scroll-area': {
	            gridArea: '1 / 1 / 1 / -1',
	            padding: '4px',
	            overflow: 'auto hidden',
	            ...(!hasScrollbar && {
	                // If scrollbar is disabled - hide scrollbar
	                msOverflowStyle: 'none' /* IE and Edge */,
	                scrollbarWidth: 'none' /* Firefox */,
	                '&::-webkit-scrollbar': {
	                    display: 'none',
	                },
	            }),
	        },
	        // Extra wrapper needed to compensate different offset parent calculation depending on browser.
	        // Needed for position of status bar.
	        'scroll-wrapper': {
	            position: 'relative',
	            display: 'inline-flex',
	            minHeight: '28px',
	            minWidth: '100%',
	            verticalAlign: 'top',
	            borderRadius: borderRadiusSmall.borderRadiusSmall,
	            ...validateProps.getFocusJssStyle(theme),
	        },
	        trigger: {
	            position: 'absolute',
	            top: 0,
	            bottom: 0,
	            width: '1px',
	            visibility: 'hidden',
	            '&:first-of-type': {
	                left: 0,
	            },
	            '&:last-of-type': {
	                right: 0,
	            },
	        },
	        'action-prev': {
	            ...actionPrevNextStyles,
	            left: '-1px', // ensures that the gradient always overlays the content (e.g. when zoomed)
	            justifyContent: 'flex-start',
	            background: `linear-gradient(to right, ${getGradient(theme, gradientColor)} 100%)`,
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                background: `linear-gradient(to right, ${getGradient('dark', gradientColor)} 100%)`,
	            }),
	            visibility: isPrevHidden ? 'hidden' : 'inherit',
	            '& button': {
	                marginLeft: '8px',
	                // hide buttons on mobile (actually devices not supporting hover)
	                ...hoverMediaQuery.hoverMediaQuery({
	                    visibility: isPrevHidden ? 'hidden' : 'inherit',
	                }),
	            },
	        },
	        'action-next': {
	            ...actionPrevNextStyles,
	            right: '-1px', // ensures that the gradient always overlays the content (e.g. when zoomed)
	            justifyContent: 'flex-end',
	            background: `linear-gradient(to left, ${getGradient(theme, gradientColor)} 100%)`,
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                background: `linear-gradient(to left, ${getGradient('dark', gradientColor)} 100%)`,
	            }),
	            visibility: isNextHidden ? 'hidden' : 'inherit',
	            '& button': {
	                marginRight: '8px',
	                // hide buttons on mobile (actually devices not supporting hover)
	                ...hoverMediaQuery.hoverMediaQuery({
	                    visibility: isNextHidden ? 'hidden' : 'inherit',
	                }),
	            },
	        },
	        icon: {
	            '&:dir(rtl)': {
	                transform: 'scaleX(-1)',
	            },
	        },
	    });
	};

	const propTypes = {
	    gradientColorScheme: validateProps.AllowedTypes.oneOf([undefined, ...scrolling.GRADIENT_COLOR_SCHEMES]),
	    gradientColor: validateProps.AllowedTypes.oneOf(scrolling.GRADIENT_COLORS),
	    scrollToPosition: validateProps.AllowedTypes.shape({
	        scrollPosition: validateProps.AllowedTypes.number,
	        isSmooth: validateProps.AllowedTypes.boolean,
	    }),
	    scrollIndicatorPosition: validateProps.AllowedTypes.oneOf([
	        undefined,
	        ...scrolling.SCROLL_INDICATOR_POSITIONS,
	    ]),
	    alignScrollIndicator: validateProps.AllowedTypes.oneOf(scrolling.SCROLL_INDICATOR_POSITIONS),
	    scrollbar: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    aria: validateProps.AllowedTypes.aria(scrolling.SCROLLER_ARIA_ATTRIBUTES),
	};
	const Scroller = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.initIntersectionObserver = () => {
	            const [firstTrigger, lastTrigger] = getHTMLElements.getHTMLElements(this.host.shadowRoot, '.trigger');
	            this.intersectionObserver = new IntersectionObserver((entries) => {
	                for (const { target, isIntersecting } of entries) {
	                    if (target === firstTrigger) {
	                        this.isPrevHidden = isIntersecting;
	                    }
	                    else if (target === lastTrigger) {
	                        this.isNextHidden = isIntersecting;
	                    }
	                }
	            }, {
	                root: this.scrollAreaElement,
	                // Defines the percentage of how much of the target (trigger) is visible within the element specified (this.host).
	                // In this case 0.9px of the trigger have to be hidden to show the gradient
	                threshold: 0.1,
	            });
	            this.intersectionObserver.observe(firstTrigger);
	            this.intersectionObserver.observe(lastTrigger);
	        };
	        this.scrollOnPrevNextClick = (direction) => {
	            const scrollPosition = scrolling.getScrollPositionAfterPrevNextClick(this.scrollAreaElement, direction);
	            scrolling.scrollElementTo(this.scrollAreaElement, scrollPosition);
	        };
	        this.gradientColorScheme = undefined;
	        this.gradientColor = 'background-base';
	        this.scrollToPosition = undefined;
	        this.scrollIndicatorPosition = undefined;
	        this.alignScrollIndicator = 'center';
	        this.theme = 'light';
	        this.scrollbar = false;
	        this.aria = undefined;
	        this.isPrevHidden = true;
	        this.isNextHidden = true;
	    }
	    scrollToPositionHandler() {
	        // TODO: does this.scrollToPosition already have the new value? or why aren't we using the first parameter of this function
	        this.scrollToPosition = validateProps.parseJSONAttribute(this.scrollToPosition);
	        // watcher might trigger before ref is defined with ssr
	        if (this.scrollAreaElement) {
	            const { scrollPosition, isSmooth } = this.scrollToPosition;
	            if (isSmooth) {
	                scrolling.scrollElementTo(this.scrollAreaElement, scrollPosition);
	            }
	            else {
	                this.scrollAreaElement.scrollLeft = scrollPosition;
	            }
	        }
	    }
	    connectedCallback() {
	        if (this.scrollAreaElement) {
	            this.scrollToPosition = validateProps.parseJSONAttribute(this.scrollToPosition);
	        }
	    }
	    componentDidLoad() {
	        this.initIntersectionObserver();
	        if (this.scrollToPosition) {
	            this.scrollToPositionHandler();
	        }
	    }
	    componentShouldUpdate(newVal, oldVal, propName) {
	        return (!(propName === 'scrollToPosition' && !scrolling.isScrollable(this.isNextHidden, this.isPrevHidden)) && // should only update if scrollable
	            validateProps.hasPropValueChanged(newVal, oldVal));
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'gradientColorScheme', 'Please use gradientColor prop instead.');
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'scrollIndicatorPosition', 'Please use alignScrollIndicator prop instead.');
	        const deprecationMap = {
	            default: 'background-base',
	            surface: 'background-surface',
	        };
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'gradientColorScheme', deprecationMap);
	        validateProps.attachComponentCss(this.host, getComponentCss, deprecationMap[this.gradientColorScheme] || this.gradientColor, this.isNextHidden, this.isPrevHidden, this.scrollIndicatorPosition || this.alignScrollIndicator, this.scrollbar, this.theme);
	        const renderPrevNextButton = (direction) => {
	            const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	            // TODO: why not use p-button?
	            return (validateProps.h("div", { key: direction, class: direction === 'next' ? 'action-next' : 'action-prev' }, validateProps.h("button", { type: "button", tabIndex: -1, onClick: () => this.scrollOnPrevNextClick(direction), "aria-hidden": "true", "aria-label": direction }, validateProps.h(PrefixedTagNames.pIcon, { class: "icon", name: direction === 'next' ? 'arrow-head-right' : 'arrow-head-left', theme: this.theme }))));
	        };
	        return (validateProps.h("div", { class: "root" }, validateProps.h("div", { class: scrollerPopoverUtils.scrollAreaClass, ref: (el) => (this.scrollAreaElement = el) }, validateProps.h("div", { class: "scroll-wrapper", role: validateProps.parseAndGetAriaAttributes(this.aria)?.role || null, tabIndex: scrolling.isScrollable(this.isPrevHidden, this.isNextHidden) ? 0 : null }, validateProps.h("slot", null), validateProps.h("div", { class: "trigger" }), validateProps.h("div", { class: "trigger" }))), ['prev', 'next'].map(renderPrevNextButton)));
	    }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "scrollToPosition": ["scrollToPositionHandler"]
	    }; }
	};

	pScroller_cjs_entry.p_scroller = Scroller;

	
	return pScroller_cjs_entry;
}

var pSegmentedControl_2_cjs_entry = {};

var throwIfChildrenAreNotOfKind81b825bd = {};

var hasRequiredThrowIfChildrenAreNotOfKind81b825bd;

function requireThrowIfChildrenAreNotOfKind81b825bd () {
	if (hasRequiredThrowIfChildrenAreNotOfKind81b825bd) return throwIfChildrenAreNotOfKind81b825bd;
	hasRequiredThrowIfChildrenAreNotOfKind81b825bd = 1;

	const validateProps = requireValidatePropsF6586828();

	const updateParent = (host) => {
	    validateProps.forceUpdate(host.parentElement);
	};

	const areAllChildrenOfKind = (element, tagName) => {
	    const children = Array.from(element.children);
	    const prefixedElementTagName = validateProps.getPrefixedTagNames(element)[validateProps.paramCaseToCamelCase(tagName)];
	    return !children.some((child) => validateProps.getTagName(child) !== prefixedElementTagName);
	};

	const throwIfChildrenAreNotOfKind = (element, tagName) => {
	    if (!areAllChildrenOfKind(element, tagName)) {
	        const allowedTagName = validateProps.getPrefixedTagNames(element)[validateProps.paramCaseToCamelCase(tagName)];
	        const actualTagNames = Array.from(element.children, validateProps.getTagName)
	            .filter((actualTagName) => actualTagName !== allowedTagName)
	            .join(', ');
	        validateProps.throwException(`child HTMLElements of ${validateProps.getTagNameWithoutPrefix(element)} should be of kind ${allowedTagName} but got ${actualTagNames}.`);
	    }
	};

	throwIfChildrenAreNotOfKind81b825bd.throwIfChildrenAreNotOfKind = throwIfChildrenAreNotOfKind;
	throwIfChildrenAreNotOfKind81b825bd.updateParent = updateParent;

	
	return throwIfChildrenAreNotOfKind81b825bd;
}

var hasRequiredPSegmentedControl_2_cjs_entry;

function requirePSegmentedControl_2_cjs_entry () {
	if (hasRequiredPSegmentedControl_2_cjs_entry) return pSegmentedControl_2_cjs_entry;
	hasRequiredPSegmentedControl_2_cjs_entry = 1;

	Object.defineProperty(pSegmentedControl_2_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed0dc3288b();
	const theme = requireThemeBfc10573();
	const throwIfChildrenAreNotOfKind = requireThrowIfChildrenAreNotOfKind81b825bd();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const textXSmallStyle = requireTextXSmallStyle1145ee25();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const hasDocument = requireHasDocument079654e6();
	const fontLineHeight = requireFontLineHeight78b03658();
	const getClickedItem = requireGetClickedItemDb2d9f29();
	const throwIfParentIsNotOfKind = requireThrowIfParentIsNotOfKindEb817ad3();
	const getButtonBaseAriaAttributes = requireGetButtonBaseAriaAttributes2b382c95();
	requireHelperA66adcf2();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireFontSizeTextXSmallE59d35d7();
	requireIsParentOfKindB7d9f81c();
	requireIsDisabledOrLoadingB1f56d7f();

	const throwIfPropIsUndefined = (element, propName, value) => {
	    if (value === undefined) {
	        validateProps.throwException(`the required property '${propName}' is undefined on ${validateProps.getTagNameWithoutPrefix(element)}.`);
	    }
	};

	const MIN_ITEM_WIDTH = 46;
	const MAX_ITEM_WIDTH = 220;
	const getComponentCss$1 = (maxWidth, columns) => {
	    maxWidth = (maxWidth > MAX_ITEM_WIDTH && MAX_ITEM_WIDTH) || (maxWidth < MIN_ITEM_WIDTH && MIN_ITEM_WIDTH) || maxWidth;
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'grid',
	                ...validateProps.addImportantToEachRule({
	                    gridAutoRows: '1fr', // for equal height
	                    ...validateProps.buildResponsiveStyles(columns, (col) => ({
	                        gridTemplateColumns: col === 'auto' ? `repeat(auto-fit, ${maxWidth}px)` : `repeat(${col}, minmax(0, 1fr))`,
	                    })),
	                    gap: '6px',
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	        },
	    });
	};

	const ITEM_PADDING = '17px';
	const { font: BUTTON_FONT } = textSmallStyle.textSmallStyle;
	const { font: LABEL_FONT } = textXSmallStyle.textXSmallStyle;
	const ICON_SIZE = '1.5rem';
	const ICON_MARGIN = '.25rem';
	const getColors = (isDisabled, isSelected, theme) => {
	    const { primaryColor, contrastMediumColor, disabledColor, contrastLowColor } = validateProps.getThemedColors(theme);
	    const { highlightColor } = validateProps.getHighContrastColors();
	    return {
	        buttonColor: isDisabled ? disabledColor : primaryColor,
	        labelColor: isDisabled ? disabledColor : contrastMediumColor,
	        borderColor: isSelected ? (validateProps.isHighContrastMode ? highlightColor : primaryColor) : contrastLowColor,
	        hoverBorderColor: primaryColor,
	    };
	};
	const getItemPadding = (hasIconAndSlottedContent) => hasIconAndSlottedContent ? `13px ${ITEM_PADDING} 13px 13px` : `13px ${ITEM_PADDING}`;
	const getComponentCss = (isDisabled, isSelected, hasIcon, hasSlottedContent, theme) => {
	    const { buttonColor, labelColor, borderColor, hoverBorderColor } = getColors(isDisabled, isSelected, theme);
	    const { buttonColor: buttonColorDark, labelColor: labelColorDark, borderColor: borderColorDark, hoverBorderColor: hoverBorderColorDark, } = getColors(isDisabled, isSelected, 'dark');
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    outline: 0,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            // All width relevant styling has to be kept in sync with the tempDiv of the p-segmented-control utils
	            button: {
	                position: 'relative',
	                display: 'block',
	                height: '100%',
	                width: '100%',
	                padding: getItemPadding(hasIcon && hasSlottedContent),
	                margin: 0, // Removes default button margin on safari 15
	                border: `${validateProps.borderWidthBase} solid ${borderColor}`,
	                borderRadius: borderRadiusSmall.borderRadiusSmall,
	                background: 'transparent',
	                color: buttonColor,
	                ...textSmallStyle.textSmallStyle,
	                ...(isDisabled
	                    ? {
	                        cursor: 'not-allowed',
	                    }
	                    : {
	                        cursor: 'pointer',
	                        ...(!isSelected &&
	                            hoverMediaQuery.hoverMediaQuery({
	                                transition: validateProps.getTransition('border-color'),
	                                '&:hover': {
	                                    borderColor: hoverBorderColor,
	                                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                                        borderColor: hoverBorderColorDark,
	                                    }),
	                                },
	                            })),
	                    }),
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    borderColor: borderColorDark,
	                    color: buttonColorDark,
	                }),
	                ...validateProps.getFocusJssStyle(theme),
	            },
	            // label
	            span: {
	                display: 'block',
	                ...textXSmallStyle.textXSmallStyle,
	                overflowWrap: 'normal',
	                color: labelColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: labelColorDark,
	                }),
	            },
	        },
	        ...(hasIcon && {
	            icon: {
	                height: ICON_SIZE,
	                width: ICON_SIZE,
	                ...(hasSlottedContent && {
	                    marginInlineEnd: ICON_MARGIN,
	                }),
	            },
	        }),
	    });
	};

	const SEGMENTED_CONTROL_BACKGROUND_COLORS = ['background-surface', 'background-default']; // 'background-color' prop is deprecated
	const SEGMENTED_CONTROL_COLUMNS = ['auto', ...Array.from(Array(25), (_, i) => i + 1)];
	// Expect Porsche Next to be available and use sans-serif (wide font for safety buffer) as fallback
	const tempFont = 'Porsche Next, sans-serif';
	// temporary dom node to measure max-width of children content
	// All width relevant styling has to be kept in sync with the button of the p-segmented-control-item
	const tempDiv = hasDocument.hasDocument ? document.createElement('div') : undefined;
	if (tempDiv) {
	    tempDiv.style.position = 'absolute';
	    tempDiv.style.visibility = 'hidden';
	    tempDiv.style.padding = `0 ${ITEM_PADDING}`; // Uses the largest possible padding of the item
	    tempDiv.style.border = `${validateProps.borderWidthBase} solid`;
	    tempDiv.style.boxSizing = 'border-box';
	    tempDiv.style.font = BUTTON_FONT.replace(fontLineHeight.fontFamily, tempFont);
	}
	const tempLabel = hasDocument.hasDocument ? document.createElement('div') : undefined;
	if (tempLabel) {
	    tempLabel.style.font = LABEL_FONT.replace(fontLineHeight.fontFamily, tempFont);
	}
	const tempIcon = hasDocument.hasDocument ? document.createElement('div') : undefined;
	if (tempIcon) {
	    tempIcon.style.display = 'inline-block';
	    tempIcon.style.width = ICON_SIZE;
	    tempIcon.style.marginRight = ICON_MARGIN;
	}
	const getItemMaxWidth = (host) => {
	    tempDiv.innerHTML = '';
	    host.shadowRoot.append(tempDiv);
	    const widths = Array.from(host.children, (item) => {
	        tempDiv.innerHTML = item.innerHTML;
	        if (item.icon || item.iconSource) {
	            tempDiv.prepend(tempIcon);
	        }
	        if (item.label) {
	            tempLabel.innerHTML = item.label;
	            tempDiv.prepend(tempLabel);
	        }
	        return parseFloat(getComputedStyle(tempDiv).width);
	    });
	    tempDiv.remove();
	    return Math.max(...widths);
	};
	const syncSegmentedControlItemsProps = (host, value, theme) => {
	    Array.from(host.children).forEach((item) => {
	        item.selected = item.value === value;
	        item.theme = theme;
	        validateProps.forceUpdate(item);
	    });
	};

	const propTypes$1 = {
	    backgroundColor: validateProps.AllowedTypes.oneOf([
	        undefined,
	        ...SEGMENTED_CONTROL_BACKGROUND_COLORS,
	    ]),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    value: validateProps.AllowedTypes.oneOf([validateProps.AllowedTypes.string, validateProps.AllowedTypes.number]),
	    columns: validateProps.AllowedTypes.breakpoint(SEGMENTED_CONTROL_COLUMNS),
	};
	const SegmentedControl = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.segmentedControlChange = validateProps.createEvent(this, "segmentedControlChange", 3);
	        this.update = validateProps.createEvent(this, "update", 3);
	        this.updateValue = (item) => {
	            if (item) {
	                this.value = item.value; // causes rerender
	                this.update.emit({ value: this.value });
	                this.segmentedControlChange.emit({ value: this.value });
	                item.focus();
	            }
	        };
	        this.backgroundColor = undefined;
	        this.theme = 'light';
	        this.value = undefined;
	        this.columns = 'auto';
	    }
	    connectedCallback() {
	        throwIfChildrenAreNotOfKind.throwIfChildrenAreNotOfKind(this.host, 'p-segmented-control-item');
	        // child property changes to label or icon are detected via prop watchers within child
	        // here we take care of dom changes like adding/removing a child or changing its content
	        validateProps.observeChildren(this.host, () => {
	            throwIfChildrenAreNotOfKind.throwIfChildrenAreNotOfKind(this.host, 'p-segmented-control-item');
	            validateProps.forceUpdate(this.host);
	        });
	    }
	    componentDidLoad() {
	        this.host.addEventListener('click', (e) => this.updateValue(getClickedItem.getClickedItem(this.host, 'p-segmented-control-item', e.composedPath())));
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    disconnectedCallback() {
	        validateProps.unobserveChildren(this.host);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes$1);
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'backgroundColor');
	        validateProps.attachComponentCss(this.host, getComponentCss$1, getItemMaxWidth(this.host), this.columns);
	        syncSegmentedControlItemsProps(this.host, this.value, this.theme);
	        return (validateProps.h(validateProps.Host, { key: '66bf92c3f6324c28d72416ee89b248af46211180', role: "group" }, validateProps.h("slot", { key: 'ba7eb83c6cb3300e2fc8c33e4cd9e881811f619b' })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	const getButtonAttributes = (isSelected, isDisabled) => ({
	    ...getButtonBaseAriaAttributes.getButtonBaseAriaAttributes(isDisabled, false),
	    ...validateProps.parseAndGetAriaAttributes({ 'aria-pressed': isSelected }),
	});
	const getIconColor = (isDisabled) => {
	    return !isDisabled ? 'primary' : 'contrast-medium';
	};

	const propTypes = {
	    value: validateProps.AllowedTypes.oneOf([validateProps.AllowedTypes.string, validateProps.AllowedTypes.number]),
	    disabled: validateProps.AllowedTypes.boolean,
	    label: validateProps.AllowedTypes.string,
	    icon: validateProps.AllowedTypes.string,
	    iconSource: validateProps.AllowedTypes.string,
	};
	const SegmentedControlItem = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.value = undefined;
	        this.disabled = false;
	        this.label = undefined;
	        this.icon = undefined;
	        this.iconSource = undefined;
	    }
	    handleLabelChange() {
	        // when these props change, we inform the parent to recalculate the max width for all items
	        throwIfChildrenAreNotOfKind.updateParent(this.host);
	    }
	    onClick(e) {
	        if (this.disabled || this.host.selected) {
	            e.stopPropagation();
	        }
	    }
	    connectedCallback() {
	        throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-segmented-control');
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        // this additional validation is still needed because undefined is allowed with current propTypes
	        throwIfPropIsUndefined(this.host, 'value', this.value);
	        const hasIcon = !!this.icon || !!this.iconSource;
	        const hasSlottedContent = !!this.host.innerHTML;
	        validateProps.attachComponentCss(this.host, getComponentCss, this.disabled, this.host.selected, hasIcon, hasSlottedContent, this.host.theme || 'light' // default as fallback
	        );
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h("button", { key: '897efa30c92c247df7b00441ac12350c44c6b199', type: "button", ...getButtonAttributes(this.host.selected, this.disabled) }, this.label && validateProps.h("span", null, this.label), hasIcon && (validateProps.h(PrefixedTagNames.pIcon, { class: "icon", size: "inherit", name: this.icon, source: this.iconSource, color: getIconColor(this.disabled), theme: this.host.theme || 'light', "aria-hidden": "true" })), validateProps.h("slot", { key: '8c1b78c56a2d8fa40d4a7d62fdd73caa7755465b' })));
	    }
	    static get delegatesFocus() { return true; }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "label": ["handleLabelChange"],
	        "icon": ["handleLabelChange"],
	        "iconSource": ["handleLabelChange"]
	    }; }
	};

	pSegmentedControl_2_cjs_entry.p_segmented_control = SegmentedControl;
	pSegmentedControl_2_cjs_entry.p_segmented_control_item = SegmentedControlItem;

	
	return pSegmentedControl_2_cjs_entry;
}

var pSelect_2_cjs_entry = {};

var hasRequiredPSelect_2_cjs_entry;

function requirePSelect_2_cjs_entry () {
	if (hasRequiredPSelect_2_cjs_entry) return pSelect_2_cjs_entry;
	hasRequiredPSelect_2_cjs_entry = 1;

	Object.defineProperty(pSelect_2_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const setAttributes = requireSetAttributes642a7e67();
	const getNativePopoverDropdownPosition = requireGetNativePopoverDropdownPosition06475061();
	const popoverResetStyles = requirePopoverResetStylesFad56b6d();
	const getClosestHTMLElement = requireGetClosestHTMLElement83d01a84();
	const required = requireRequiredF3c463a3();
	const theme = requireThemeBfc10573();
	const throwIfElementIsNotOfKind = requireThrowIfElementIsNotOfKind4014bcee();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const formStyles = requireFormStyles7e9d1c43();
	const placeholder = requirePlaceholderE6dd9abf();
	const label = requireLabel5379ea8c();
	const fontLineHeight = requireFontLineHeight78b03658();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const throwIfParentIsNotOfKind = requireThrowIfParentIsNotOfKindEb817ad3();
	requireScrollerPopoverUtils89485ebc();
	requireHasNamedSlotA96fd22a();
	requireGetNamedSlotA0cdbdbc();
	requireSpacingStaticMedium94812711();
	requireFontSizeTextXSmallE59d35d7();
	requireHasDescriptionBbe55afe();
	requireIsParentOfKindB7d9f81c();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();

	// The amount of time in ms after the last key press before the searchString will get cleared
	const SELECT_SEARCH_TIMEOUT = 500;
	// The amount of options to be jumped when performing a page-based navigation using PageUp or PageDown.
	const PAGE_UP_DOWN_STEP_AMOUNT = 10;
	/**
	 * Handles scrolling within the list to ensure that the highlighted item is always visible.
	 * @param {HTMLElement} scrollElement - The HTML element to be scrolled.
	 * @param {HTMLElement} element - The element to scroll to.
	 * @returns {void}
	 */
	const handleSelectDropdownScroll = (scrollElement, element) => {
	    const { maxHeight } = getComputedStyle(scrollElement);
	    const hostElementHeight = parseInt(maxHeight, 10);
	    // TODO: If dropdown was closed this might get called too early before the list is opened which causes the scrollHeight to be 0
	    if (scrollElement.scrollHeight > hostElementHeight) {
	        element.scrollIntoView({
	            block: 'nearest',
	            // behavior: 'smooth' // Intentionally not smooth since highlighted options can quickly change when searching
	        });
	    }
	};
	/**
	 * Determines the action to be taken based on a keyboard event and the state of the select menu.
	 *
	 * @param {KeyboardEvent} event - The keyboard event triggering the action.
	 * @param {boolean} menuOpen - A boolean indicating whether the select menu is open or closed.
	 * @returns {SelectAction} - The corresponding action to be performed.
	 */
	const getActionFromKeyboardEvent = (event, menuOpen) => {
	    const { key, altKey, ctrlKey, metaKey } = event;
	    const openKeys = ['ArrowDown', 'ArrowUp', 'Enter', ' ']; // all keys that will do the default open action
	    // handle opening when closed
	    if (!menuOpen && openKeys.includes(key)) {
	        return 'Open';
	    }
	    // home and end move the selected option when open or closed
	    if (key === 'Home') {
	        return 'First';
	    }
	    if (key === 'End') {
	        return 'Last';
	    }
	    // handle typing characters when open or closed
	    if (key === 'Backspace' || key === 'Clear' || (key.length === 1 && key !== ' ' && !altKey && !ctrlKey && !metaKey)) {
	        return 'Type';
	    }
	    // handle keys when open
	    if (menuOpen) {
	        if (key === 'ArrowUp' && altKey) {
	            return 'CloseSelect';
	        }
	        else if (key === 'ArrowDown' && !altKey) {
	            return 'Next';
	        }
	        else if (key === 'ArrowUp') {
	            return 'Previous';
	        }
	        else if (key === 'PageUp') {
	            return 'PageUp';
	        }
	        else if (key === 'PageDown') {
	            return 'PageDown';
	        }
	        else if (key === 'Escape') {
	            return 'Close';
	        }
	        else if (key === 'Enter' || key === ' ' || key === 'Tab') {
	            return 'CloseSelect';
	        }
	    }
	};
	/**
	 * Gets the updated index based on the current index, maximum index, and the select action.
	 *
	 * @param {number} currentIndex - The current index in the list of options.
	 * @param {number} maxIndex - The maximum index in the list of options.
	 * @param {SelectAction} action - The select action indicating how to update the index.
	 * @returns {number} - The updated index after applying the specified action.
	 */
	const getUpdatedIndex = (currentIndex, maxIndex, action) => {
	    switch (action) {
	        case 'First':
	            return 0;
	        case 'Last':
	            return maxIndex;
	        case 'Previous':
	            return Math.max(0, currentIndex - 1);
	        case 'Next':
	            return Math.min(maxIndex, currentIndex + 1);
	        case 'PageUp':
	            return Math.max(0, currentIndex - PAGE_UP_DOWN_STEP_AMOUNT);
	        case 'PageDown':
	            return Math.min(maxIndex, currentIndex + PAGE_UP_DOWN_STEP_AMOUNT);
	        default:
	            return currentIndex;
	    }
	};
	/**
	 * Sets the next option in a select dropdown as highlighted, updating the visual state and handling scrolling.
	 *
	 * @template T - The type of options in the dropdown.
	 * @param {HTMLElement} listElement - The parent element containing the dropdown options.
	 * @param {T[]} options - The array of options in the dropdown.
	 * @param {number} newIndex - The index of the option to be highlighted.
	 * @returns {void}
	 */
	const setNextSelectOptionHighlighted = (listElement, options, newIndex) => {
	    const oldIndex = getHighlightedSelectOptionIndex(options);
	    const usableOptions = getUsableSelectOptions(options);
	    if (oldIndex !== -1) {
	        setHighlightedSelectOption(usableOptions[oldIndex], false);
	    }
	    setHighlightedSelectOption(usableOptions[newIndex], true);
	    handleSelectDropdownScroll(listElement, usableOptions[newIndex]);
	};
	/**
	 * Filters an array of select options to include only those that are usable (not hidden or disabled).
	 *
	 * @template T - The type of options in the array.
	 * @param {T[]} options - The array of select options to filter.
	 * @returns {T[]} - An array of usable select options.
	 */
	const getUsableSelectOptions = (options) => options.filter((option) => !option.hidden && !option.disabled);
	/**
	 * Filters an array of select options based on a filter string, considering visibility and usability.
	 *
	 * @template T - The type of options in the array.
	 * @param {T[]} options - The array of select options to filter.
	 * @param {string} filter - The filter string to match against option text content.
	 * @returns {T[]} - An array of filtered and usable select options.
	 */
	const filterSelectOptions = (options, filter) => getUsableSelectOptions(options).filter((option) => option.textContent.trim().toLowerCase().indexOf(filter.toLowerCase()) === 0);
	/**
	 * Determines the index of the next matching select option based on a filter string.
	 *
	 * @template T - The type of options in the array.
	 * @param {T[]} options - The array of select options to search.
	 * @param {string} filter - The filter string to match against option text content.
	 * @returns {number} - The index of the next matching select option, or -1 if none is found.
	 */
	const getMatchingSelectOptionIndex = (options, filter) => {
	    const usableOptions = getUsableSelectOptions(options);
	    const startIndex = getHighlightedSelectOptionIndex(options) + 1;
	    // Shift already searched options to the end of the array in order to find the next matching option
	    const orderedOptions = [...usableOptions.slice(startIndex), ...usableOptions.slice(0, startIndex)];
	    const firstMatch = filterSelectOptions(orderedOptions, filter)[0];
	    const allSameLetter = (str) => str.split('').every((letter) => letter === str[0]);
	    // first check if there is an exact match for the typed string
	    if (firstMatch) {
	        return usableOptions.indexOf(firstMatch);
	    }
	    // if the same letter is being repeated, cycle through first-letter matches
	    else if (allSameLetter(filter)) {
	        const matches = filterSelectOptions(orderedOptions, filter[0]);
	        return usableOptions.indexOf(matches[0]);
	    }
	    // No matching option found
	    else {
	        return -1;
	    }
	};
	/**
	 * Sets the highlighted state of a select option and triggers an update.
	 *
	 * @template T - The type of the select option.
	 * @param {T} option - The select option to set the highlighted state for.
	 * @param {boolean} highlighted - The new highlighted state.
	 * @returns {void}
	 */
	const setHighlightedSelectOption = (option, highlighted) => {
	    option.highlighted = highlighted;
	    validateProps.forceUpdate(option);
	};
	/**
	 * Gets the index of the currently highlighted select option.
	 *
	 * @template T - The type of options in the array.
	 * @param {T[]} options - The array of select options.
	 * @returns {number} - The index of the highlighted select option, or -1 if none is highlighted.
	 */
	const getHighlightedSelectOptionIndex = (options) => getUsableSelectOptions(options).indexOf(getHighlightedSelectOption(options));
	/**
	 * Gets the currently highlighted select option.
	 *
	 * @template T - The type of options in the array.
	 * @param {T[]} options - The array of select options.
	 * @returns {T} - The currently highlighted select option, or undefined if none is highlighted.
	 */
	const getHighlightedSelectOption = (options) => options.find((option) => option.highlighted);

	const INTERNAL_SELECT_SLOT = 'internal-select';
	const syncSelectOptionProps = (options, theme) => {
	    options
	        .filter((option) => option.theme !== theme)
	        .forEach((option) => {
	        option.theme = theme;
	        validateProps.forceUpdate(option);
	    });
	};
	const getSelectedOptionString = (options) => options.find((option) => option.selected)?.textContent ?? '';
	const resetSelectedOption = (options) => {
	    const currentSelectedOption = options.find((option) => option.selected);
	    if (currentSelectedOption) {
	        currentSelectedOption.selected = false;
	        validateProps.forceUpdate(currentSelectedOption);
	    }
	};
	const updateSelectOptions = (options, value) => {
	    resetSelectedOption(options);
	    if (value === undefined) {
	        // Option without value for empty selection
	        const optionToSelect = options.find((option) => option.value === undefined);
	        if (optionToSelect) {
	            optionToSelect.selected = true;
	            validateProps.forceUpdate(optionToSelect);
	        }
	    }
	    else {
	        // TODO: Do we want to cover multiple options with the same value?
	        const optionToSelect = options.find((option) => option.value === value);
	        if (!optionToSelect) {
	            // TODO: Add select node
	            validateProps.consoleWarn('The provided value is not included in the options of the p-select:', value);
	        }
	        else {
	            optionToSelect.selected = true;
	            validateProps.forceUpdate(optionToSelect);
	        }
	    }
	};
	const setSelectedOption = (options, selectedOption) => {
	    resetSelectedOption(options);
	    selectedOption.selected = true;
	    validateProps.forceUpdate(selectedOption);
	};
	// TODO: Mostly same as multi-select
	// TODO: Extract slot name into const
	const initNativeSelect = (host, name, disabled, required) => {
	    const nativeSelect = document.createElement('select');
	    setAttributes.setAttributes(nativeSelect, {
	        'aria-hidden': 'true',
	        tabindex: '-1',
	        slot: INTERNAL_SELECT_SLOT,
	    });
	    syncNativeSelect(nativeSelect, name, disabled, required);
	    host.prepend(nativeSelect);
	    return nativeSelect;
	};
	// TODO: Same as multi-select
	const syncNativeSelect = (nativeSelect, name, disabled, required) => {
	    validateProps.setAttribute(nativeSelect, 'name', name);
	    nativeSelect.toggleAttribute('disabled', disabled);
	    nativeSelect.toggleAttribute('required', required);
	};
	const updateNativeSelectOption = (nativeSelect, selectOptions) => {
	    const selectedOption = selectOptions.find((option) => option.selected);
	    // Check for value since empty option can also be selected
	    nativeSelect.innerHTML = selectedOption?.value ? `<option value="${selectedOption.value}" selected></option>` : '';
	};
	// TODO: This is copied from multi-select, extract and reuse in both components
	const getSelectDropdownDirection = (direction, host, options) => {
	    if (direction !== 'auto') {
	        return direction;
	    }
	    else if (host) {
	        const visibleOptionsLength = options.filter((option) => !option.hidden).length;
	        return getNativePopoverDropdownPosition.determineDropdownDirection(host, visibleOptionsLength);
	    }
	    else {
	        return 'down';
	    }
	};
	const getSrHighlightedOptionText = (options) => {
	    const highlightedOptionIndex = getHighlightedSelectOptionIndex(options);
	    const highlightedOption = getUsableSelectOptions(options)[highlightedOptionIndex];
	    return (highlightedOption &&
	        `${highlightedOption.textContent || 'Empty option'}${highlightedOption.selected ? ', selected' : ' not selected'} (${highlightedOptionIndex + 1} of ${options.length})`);
	};

	const getComponentCss$1 = (direction, isOpen, isDisabled, hideLabel, state, isWithinForm, isNativePopoverCase, theme) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': validateProps.addImportantToEachRule({
	                ...colorSchemeStyles.colorSchemeStyles,
	                ...colorSchemeStyles.hostHiddenStyles,
	            }),
	            ...(isWithinForm &&
	                validateProps.addImportantToEachRule({
	                    [`::slotted([slot=${INTERNAL_SELECT_SLOT}])`]: {
	                        position: 'absolute',
	                        opacity: 0,
	                        height: '0px',
	                        bottom: 0,
	                    },
	                })),
	            // TODO: re-use select-wrapper-style
	            button: getButtonStyles(isDisabled, direction, isOpen, state, theme),
	        },
	        root: {
	            display: 'grid',
	            gap: spacingStaticXSmall.spacingStaticXSmall,
	            ...(isWithinForm && {
	                position: 'relative', // Necessary for native HTML validation box positioning (internal-select)
	            }),
	        },
	        wrapper: {
	            position: 'relative',
	            display: 'grid',
	            gridTemplateColumns: `minmax(0, 1fr) auto auto ${formStyles.formElementLayeredSafeZone}`,
	        },
	        icon: {
	            gridArea: '1/3',
	            placeSelf: 'center',
	            padding: formStyles.formButtonOrIconPadding,
	            pointerEvents: 'none',
	            transform: 'rotate3d(0,0,1,0.0001deg)', // needs to be a little more than 0 for correct direction in safari
	            transition: validateProps.getTransition('transform'),
	            '&--rotate': {
	                transform: 'rotate3d(0,0,1,180deg)',
	            },
	        },
	        listbox: getListStyles(isOpen, direction, theme),
	        'sr-only': validateProps.getHiddenTextJssStyle(),
	        // .label / .required
	        ...label.getFunctionalComponentLabelStyles(isDisabled, hideLabel, theme),
	        // .message
	        ...required.getFunctionalComponentStateMessageStyles(theme, state),
	        ...(isNativePopoverCase && {
	            popover: {
	                ...popoverResetStyles.getPopoverResetJssStyle(),
	            },
	        }),
	    });
	};
	// TODO: Rename to JSSStyles
	// TODO: use getSlottedTextFieldTextareaSelectStyles() instead an manipulate selectors like done with PIN Code or even better make it configurable as parameter
	const getButtonStyles = (isDisabled, direction, isOpen, state, theme) => {
	    const isDirectionDown = direction === 'down';
	    const { primaryColor, disabledColor, backgroundColor, contrastMediumColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, disabledColor: disabledColorDark, backgroundColor: backgroundColorDark, contrastMediumColor: contrastMediumColorDark, } = validateProps.getThemedColors('dark');
	    const { formStateColor, formStateHoverColor } = required.getThemedFormStateColors(theme, state);
	    const { formStateColor: formStateColorDark, formStateHoverColor: formStateHoverColorDark } = required.getThemedFormStateColors('dark', state);
	    return {
	        textAlign: 'start', // TODO: Newly added (rest is copied from select-wrapper-dropdown), share rest for both components
	        overflowX: 'hidden', // TODO: Newly added (rest is copied from select-wrapper-dropdown), share rest for both components
	        whiteSpace: 'nowrap', // TODO: Newly added (rest is copied from select-wrapper-dropdown), share rest for both components
	        gridArea: '1/1/1/-1',
	        flex: 1,
	        minWidth: 0,
	        // TODO: abstract and re-use for multi-select, select-wrapper and text-field-wrapper
	        height: `calc(${fontLineHeight.fontLineHeight} + 10px + ${validateProps.borderWidthBase} * 2 + ${spacingStaticSmall.spacingStaticSmall} * 2)`, // we need 10px additionally so input height becomes 54px, // we need 6px additionally so input height becomes 50px
	        font: textSmallStyle.textSmallStyle.font.replace('ex', 'ex + 6px'), // a minimum line-height is needed for input, otherwise value is scrollable in Chrome, +6px is alig
	        margin: 0, // necessary reset for iOS Safari 15 (and maybe other browsers)
	        padding: `${formStyles.formElementPaddingVertical} ${formStyles.formElementPaddingHorizontal}`,
	        paddingInlineEnd: formStyles.getCalculatedFormElementPaddingHorizontal(1),
	        boxSizing: 'border-box',
	        outline: 0,
	        WebkitAppearance: 'none', // iOS safari
	        appearance: 'none',
	        ...textSmallStyle.textSmallStyle,
	        textOverflow: 'ellipsis',
	        cursor: 'pointer',
	        '&:disabled': {
	            cursor: 'not-allowed',
	        },
	        transition: `${validateProps.getTransition('background-color')}, ${validateProps.getTransition('border-color')}, ${validateProps.getTransition('color')}`, // for smooth transitions between e.g. disabled states
	        color: primaryColor,
	        '&:not(:focus)': {
	            ...placeholder.getPlaceholderJssStyle({ color: primaryColor, opacity: 1 }),
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, placeholder.getPlaceholderJssStyle({ color: primaryColorDark, opacity: 1 })),
	        }, // Opacity fixes placeholder being shown lighter in firefox
	        ...hoverMediaQuery.hoverMediaQuery({
	            '&:hover:not(:disabled):not(:focus),label:hover~.wrapper &:not(:disabled):not(:focus)': {
	                borderColor: isOpen ? primaryColor : formStateHoverColor || primaryColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    borderColor: isOpen ? primaryColorDark : formStateHoverColorDark || primaryColorDark,
	                }),
	            },
	        }),
	        ...(!isDisabled && {
	            '&:focus': {
	                borderColor: primaryColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    borderColor: primaryColorDark,
	                }),
	            },
	        }),
	        background: backgroundColor,
	        border: `${validateProps.borderWidthBase} solid ${isOpen ? primaryColor : formStateColor || contrastMediumColor}`,
	        borderRadius: borderRadiusSmall.borderRadiusSmall,
	        ...(isOpen && {
	            [isDirectionDown ? 'paddingBottom' : 'paddingTop']: `calc(${formStyles.formElementPaddingVertical} + 1px)`, // Add padding to keep same height when border changes
	            [isDirectionDown ? 'borderBottom' : 'borderTop']: validateProps.addImportantToRule(`1px solid ${contrastMediumColor}`),
	            [isDirectionDown ? 'borderBottomLeftRadius' : 'borderTopLeftRadius']: 0,
	            [isDirectionDown ? 'borderBottomRightRadius' : 'borderTopRightRadius']: 0,
	        }),
	        ...(isDisabled && {
	            ...placeholder.getPlaceholderJssStyle({ color: disabledColor }),
	            cursor: 'not-allowed',
	            color: disabledColor,
	            borderColor: disabledColor,
	            WebkitTextFillColor: disabledColor,
	        }),
	        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	            color: primaryColorDark,
	            background: backgroundColorDark,
	            border: `${validateProps.borderWidthBase} solid ${isOpen ? primaryColorDark : formStateColorDark || contrastMediumColorDark}`,
	            ...(isOpen && {
	                [isDirectionDown ? 'borderBottom' : 'borderTop']: validateProps.addImportantToRule(`1px solid ${contrastMediumColorDark}`),
	            }),
	            ...(isDisabled && {
	                ...placeholder.getPlaceholderJssStyle({ color: disabledColorDark }),
	                color: disabledColorDark,
	                borderColor: disabledColorDark,
	                WebkitTextFillColor: disabledColorDark,
	            }),
	        }),
	    };
	};
	// TODO: Rename to JSSStyles
	// TODO: Copied from multi-select, extract and use in select and multi-select
	const getListStyles = (isOpen, direction, theme) => {
	    const isDirectionDown = direction === 'down';
	    const { primaryColor, backgroundColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, backgroundColor: backgroundColorDark } = validateProps.getThemedColors('dark');
	    return {
	        position: 'absolute',
	        margin: 0,
	        display: isOpen ? 'flex' : 'none',
	        flexDirection: 'column',
	        gap: spacingStaticSmall.spacingStaticSmall,
	        padding: '6px',
	        ...textSmallStyle.textSmallStyle,
	        zIndex: 10,
	        // TODO: Inset inline 0
	        left: 0,
	        right: 0,
	        [isDirectionDown ? 'top' : 'bottom']: '100%',
	        boxSizing: 'border-box',
	        maxHeight: `${8.5 * (getNativePopoverDropdownPosition.MULTI_SELECT_OPTION_HEIGHT + 8) + 6 + 2}px`, // 8.5 options * option height + 8px gap + additional spacing (6px = padding, 2px = border)
	        overflowY: 'auto',
	        WebkitOverflowScrolling: 'touch',
	        background: backgroundColor,
	        border: `2px solid ${primaryColor}`,
	        [isDirectionDown ? 'borderTop' : 'borderBottom']: 'none',
	        borderRadius: borderRadiusSmall.borderRadiusSmall,
	        [isDirectionDown ? 'borderTopLeftRadius' : 'borderBottomLeftRadius']: 0,
	        [isDirectionDown ? 'borderTopRightRadius' : 'borderBottomRightRadius']: 0,
	        scrollbarWidth: 'thin', // firefox
	        scrollbarColor: 'auto', // firefox
	        transition: validateProps.getTransition('border-color'),
	        transform: 'translate3d(0,0,0)', // fix iOS bug if less than 5 items are displayed
	        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	            background: backgroundColorDark,
	            borderColor: primaryColorDark,
	        }),
	    };
	};

	const propTypes$1 = {
	    label: validateProps.AllowedTypes.string,
	    description: validateProps.AllowedTypes.string,
	    name: validateProps.AllowedTypes.string,
	    value: validateProps.AllowedTypes.string,
	    state: validateProps.AllowedTypes.oneOf(required.FORM_STATES),
	    message: validateProps.AllowedTypes.string,
	    hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	    disabled: validateProps.AllowedTypes.boolean,
	    required: validateProps.AllowedTypes.boolean,
	    dropdownDirection: validateProps.AllowedTypes.oneOf(getNativePopoverDropdownPosition.SELECT_DROPDOWN_DIRECTIONS),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Select = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.update = validateProps.createEvent(this, "update", 3);
	        this.selectOptions = [];
	        this.preventOptionUpdate = false; // Used to prevent value watcher from updating options when options are already updated
	        this.searchString = '';
	        this.searchTimeout = null;
	        this.isNativePopoverCase = false;
	        this.onSlotchange = () => {
	            this.updateOptions();
	            updateSelectOptions(this.selectOptions, this.value);
	            if (this.isWithinForm) {
	                updateNativeSelectOption(this.nativeSelect, this.selectOptions);
	            }
	            // Necessary to update selected options in placeholder
	            validateProps.forceUpdate(this.host);
	        };
	        this.updateOptions = () => {
	            this.selectOptions = Array.from(this.host.children).filter((el) => el.tagName !== 'SELECT' && el.slot !== 'label' && el.slot !== 'description' && el.slot !== 'message');
	            this.selectOptions.forEach((child) => throwIfElementIsNotOfKind.throwIfElementIsNotOfKind(this.host, child, 'p-select-option'));
	        };
	        this.updateSelectedOption = (selectedOption) => {
	            // option can be undefined when no option is highlighted and keyboard action calls this
	            if (selectedOption) {
	                this.preventOptionUpdate = true; // Avoid unnecessary updating of options in value watcher
	                setSelectedOption(this.selectOptions, selectedOption);
	                this.value = selectedOption.value;
	                this.emitUpdateEvent();
	                this.updateSrHighlightedOptionText();
	            }
	            this.updateMenuState(false);
	            this.combobox.focus();
	        };
	        this.onComboClick = () => {
	            this.updateMenuState(!this.isOpen);
	        };
	        this.updateMenuState = (open) => {
	            if (this.isOpen === open) {
	                return;
	            }
	            this.isOpen = open;
	            if (this.isNativePopoverCase) {
	                if (this.isOpen) {
	                    getNativePopoverDropdownPosition.getNativePopoverDropdownPosition(this.combobox, this.selectOptions.filter((option) => !option.hidden).length, this.popoverElement, this.dropdownDirection);
	                    this.popoverElement.showPopover();
	                }
	                else {
	                    this.popoverElement.hidePopover();
	                }
	            }
	        };
	        this.onComboKeyDown = (event) => {
	            const { key } = event;
	            const action = getActionFromKeyboardEvent(event, this.isOpen);
	            switch (action) {
	                case 'Last':
	                case 'First':
	                    this.updateMenuState(true);
	                // intentional fallthrough
	                case 'Next':
	                case 'Previous':
	                case 'PageUp':
	                case 'PageDown':
	                    event.preventDefault();
	                    setNextSelectOptionHighlighted(this.listElement, this.selectOptions, getUpdatedIndex(getHighlightedSelectOptionIndex(this.selectOptions), getUsableSelectOptions(this.selectOptions).length - 1, action));
	                    this.updateSrHighlightedOptionText();
	                    break;
	                case 'CloseSelect':
	                    event.preventDefault();
	                    this.updateSelectedOption(getHighlightedSelectOption(this.selectOptions));
	                // intentional fallthrough
	                case 'Close':
	                    event.preventDefault();
	                    this.updateMenuState(false);
	                    break;
	                case 'Type':
	                    this.onComboType(key);
	                    break;
	                case 'Open':
	                    event.preventDefault();
	                    this.updateMenuState(true);
	                    break;
	            }
	        };
	        this.onComboType = (letter) => {
	            this.updateMenuState(true);
	            this.updateSearchString(letter);
	            const matchingIndex = getMatchingSelectOptionIndex(this.selectOptions, this.searchString);
	            if (matchingIndex !== -1) {
	                setNextSelectOptionHighlighted(this.listElement, this.selectOptions, matchingIndex);
	                this.updateSrHighlightedOptionText();
	            }
	            else {
	                window.clearTimeout(this.searchTimeout);
	                this.searchString = '';
	            }
	        };
	        this.updateSearchString = (char) => {
	            // reset typing timeout and start new timeout
	            // this allows us to make multiple-letter matches, like a native select
	            if (this.searchTimeout) {
	                window.clearTimeout(this.searchTimeout);
	            }
	            this.searchTimeout = window.setTimeout(() => {
	                this.searchString = '';
	            }, SELECT_SEARCH_TIMEOUT);
	            // add most recent letter to saved search string
	            this.searchString += char;
	        };
	        this.updateSrHighlightedOptionText = () => {
	            this.srHighlightedOptionText = getSrHighlightedOptionText(this.selectOptions);
	        };
	        this.onClickOutside = (e) => {
	            if (this.isOpen && popoverResetStyles.isClickOutside(e, this.comboboxContainer) && popoverResetStyles.isClickOutside(e, this.listElement)) {
	                this.isOpen = false;
	            }
	        };
	        this.emitUpdateEvent = () => {
	            this.update.emit({
	                value: this.value,
	                name: this.name,
	            });
	        };
	        this.label = '';
	        this.description = '';
	        this.name = undefined;
	        this.value = undefined;
	        this.state = 'none';
	        this.message = '';
	        this.hideLabel = false;
	        this.disabled = false;
	        this.required = false;
	        this.dropdownDirection = 'auto';
	        this.theme = 'light';
	        this.isOpen = false;
	        this.srHighlightedOptionText = '';
	    }
	    updateOptionHandler(e) {
	        e.stopPropagation();
	        this.updateSelectedOption(e.target);
	    }
	    onValueChange() {
	        // When setting initial value the watcher gets called before the options are defined
	        if (this.selectOptions.length > 0) {
	            if (!this.preventOptionUpdate) {
	                updateSelectOptions(this.selectOptions, this.value);
	            }
	            this.preventOptionUpdate = false;
	            if (this.isWithinForm) {
	                updateNativeSelectOption(this.nativeSelect, this.selectOptions);
	            }
	        }
	    }
	    connectedCallback() {
	        document.addEventListener('mousedown', this.onClickOutside, true);
	        this.form = getClosestHTMLElement.getClosestHTMLElement(this.host, 'form');
	        this.isWithinForm = !!this.form;
	        this.isNativePopoverCase = popoverResetStyles.detectNativePopoverCase(this.host, false);
	        if (this.isNativePopoverCase) {
	            this.parentTableElement = popoverResetStyles.findClosestComponent(this.host, 'pTable');
	        }
	    }
	    componentWillLoad() {
	        this.updateOptions();
	        updateSelectOptions(this.selectOptions, this.value);
	        if (this.isWithinForm) {
	            this.nativeSelect = initNativeSelect(this.host, this.name, this.disabled, this.required);
	            updateNativeSelectOption(this.nativeSelect, this.selectOptions);
	        }
	    }
	    componentDidLoad() {
	        validateProps.getShadowRootHTMLElement(this.host, 'slot').addEventListener('slotchange', this.onSlotchange);
	    }
	    componentDidRender() {
	        if (this.isNativePopoverCase && this.isOpen) {
	            popoverResetStyles.addNativePopoverScrollAndResizeListeners(this.host, this.parentTableElement, this.popoverElement, () => {
	                this.isOpen = false;
	            });
	        }
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    componentWillUpdate() {
	        if (this.isWithinForm) {
	            syncNativeSelect(this.nativeSelect, this.name, this.disabled, this.required);
	        }
	    }
	    disconnectedCallback() {
	        document.removeEventListener('mousedown', this.onClickOutside, true);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes$1);
	        validateProps.attachComponentCss(this.host, getComponentCss$1, getSelectDropdownDirection(this.dropdownDirection, this.comboboxContainer, this.selectOptions), this.isOpen, this.disabled, this.hideLabel, this.state, this.isWithinForm, this.isNativePopoverCase, this.theme);
	        syncSelectOptionProps(this.selectOptions, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        const buttonId = 'value';
	        const dropdownId = 'list';
	        const descriptionId = this.description ? 'description' : undefined;
	        const selectMessageId = required.hasMessage(this.host, this.message, this.state) ? required.messageId : undefined;
	        const ariaDescribedBy = descriptionId && selectMessageId
	            ? `${descriptionId} ${selectMessageId}`
	            : descriptionId || selectMessageId || undefined;
	        return (validateProps.h("div", { key: '4dfa31041f10bc62d9e3343622db203a8642efeb', class: "root" }, validateProps.h(label.Label, { key: '535655dfccff1dad72d96703168d094ff8685f56', host: this.host, label: this.label, description: this.description, htmlFor: buttonId, isRequired: this.required, isDisabled: this.disabled }), validateProps.h("span", { key: '8818a46b3789444a29de8b494420f49e55ce8603', class: "sr-only" }, getSelectedOptionString(this.selectOptions) || 'No option', " selected, ", this.selectOptions.length, " options in total"), validateProps.h("div", { key: '62967b435de21f11680a52ada51fef3f22d13045', class: { wrapper: true, disabled: this.disabled }, ref: (el) => (this.comboboxContainer = el) }, validateProps.h("button", { key: 'bdf07e4cf7f36b8c57466ce12f37ef8782512cf6', type: "button", role: "combobox", id: buttonId, ...getNativePopoverDropdownPosition.getComboboxAriaAttributes(this.isOpen, this.required, label.labelId, ariaDescribedBy, dropdownId), disabled: this.disabled, onClick: this.onComboClick, onKeyDown: this.onComboKeyDown, ref: (el) => (this.combobox = el) }, getSelectedOptionString(this.selectOptions)), validateProps.h(PrefixedTagNames.pIcon, { key: 'c9bf79441270cfa570a587e7a256c85b087f4d1a', class: { icon: true, 'icon--rotate': this.isOpen }, name: "arrow-head-down", theme: this.theme, color: this.disabled ? 'state-disabled' : 'primary', "aria-hidden": "true" }), validateProps.h("div", { key: '765f8afbcd4c8f89def548296ea20b87458de9d4', ...(this.isNativePopoverCase && {
	                popover: 'auto',
	                class: 'popover',
	                ...(this.popoverElement?.matches(':popover-open') && {
	                    'popover-open': true,
	                }),
	            }), ref: (el) => (this.popoverElement = el) }, validateProps.h("div", { key: '74d6398199ecc3d51d88b0544b8d63db197805e1', id: dropdownId, class: "listbox", ...getNativePopoverDropdownPosition.getListAriaAttributes(this.label, this.required, false, this.isOpen), tabindex: "-1", ref: (el) => (this.listElement = el) }, validateProps.h("slot", { key: '0aff7009a9eb71772bf9bed98f6233e6e00b9a27' })))), validateProps.h(required.StateMessage, { key: '4525ef78f940df7cf8acd182e8ace50147bbff66', state: this.state, message: this.message, theme: this.theme, host: this.host }), validateProps.h("span", { key: 'de0c6f5bc836a2492f43b8375fa7a1c22d616e00', class: "sr-only", role: "status", "aria-live": "assertive", "aria-relevant": "additions text" }, this.srHighlightedOptionText), this.isWithinForm && validateProps.h("slot", { name: INTERNAL_SELECT_SLOT })));
	    }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "value": ["onValueChange"]
	    }; }
	};

	// TODO: Partially copied from getOnlyChildrenOfKindHTMLElementOrThrow, maybe change getOnlyChildrenOfKindHTMLElementOrThrow to make it usable here
	const validateSelectOption = (slot, host) => {
	    const directChildren = slot.assignedNodes();
	    const notValid = directChildren.some((child) => {
	        return !((child.nodeType === Node.ELEMENT_NODE && child.tagName.toLowerCase() === 'img') ||
	            child.nodeType === Node.TEXT_NODE);
	    });
	    if (notValid) {
	        validateProps.consoleError(`child HTMLElements of ${validateProps.getTagNameWithoutPrefix(host)} are invalid. Expected all of: #text or <img />.`, host);
	    }
	};

	// TODO: Enforce order of slotted text, img
	const getComponentCss = (theme) => {
	    return validateProps.getCss({
	        '@global': validateProps.addImportantToEachRule({
	            ':host': {
	                scrollMargin: '6px', // Aligns option when list is scrolled by navigating with keyboard
	                ...colorSchemeStyles.hostHiddenStyles,
	            },
	            '::slotted(img)': {
	                height: fontLineHeight.fontLineHeight,
	                borderRadius: borderRadiusSmall.borderRadiusSmall,
	            },
	        }),
	        ...getOptionStyles(theme),
	        icon: {
	            marginInlineStart: 'auto',
	        },
	    });
	};
	// TODO: Copied from multi-select and select-wrapper-dropdown, extract and reuse
	const getOptionStyles = (theme) => {
	    const { primaryColor: primaryColorDark, contrastHighColor: contrastHighColorDark, disabledColor: disabledColorDark, backgroundSurfaceColor: backgroundSurfaceColorDark, contrastLowColor: contrastLowColorDark, } = validateProps.getThemedColors('dark');
	    const { primaryColor, contrastHighColor, backgroundSurfaceColor, disabledColor, contrastLowColor } = validateProps.getThemedColors(theme);
	    const { highlightColor } = validateProps.getHighContrastColors();
	    return {
	        option: {
	            display: 'flex',
	            // justifyContent: 'space-between', // TODO: Commenented out
	            gap: '12px',
	            padding: `${spacingStaticSmall.spacingStaticSmall} 12px`,
	            flex: `1 0 calc(${fontLineHeight.fontLineHeight} + ${spacingStaticSmall.spacingStaticSmall} * 2)`,
	            minHeight: `calc(${fontLineHeight.fontLineHeight} + ${spacingStaticSmall.spacingStaticSmall} * 2)`, // TODO: Added this line to preserve height for empty option
	            color: contrastHighColor,
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                color: contrastHighColorDark,
	            }),
	            cursor: 'pointer',
	            textAlign: 'start',
	            wordBreak: 'break-word',
	            boxSizing: 'border-box',
	            borderRadius: borderRadiusSmall.borderRadiusSmall,
	            transition: `${validateProps.getTransition('background-color')}, ${validateProps.getTransition('color')}`,
	            ...getNativePopoverDropdownPosition.getNoResultsOptionJssStyle(),
	            ...hoverMediaQuery.hoverMediaQuery({
	                '&:not([aria-disabled]):not(.option--disabled):not([role=status]):hover': {
	                    color: validateProps.isHighContrastMode ? highlightColor : primaryColor,
	                    background: contrastLowColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        color: validateProps.isHighContrastMode ? highlightColor : primaryColorDark,
	                        background: contrastLowColorDark,
	                    }),
	                },
	            }),
	            '&--selected': {
	                cursor: 'default',
	                pointerEvents: 'none',
	                background: backgroundSurfaceColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    background: backgroundSurfaceColorDark,
	                }),
	            },
	            '&--highlighted': {
	                background: contrastLowColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    background: contrastLowColorDark,
	                }),
	            },
	            '&--highlighted, &--selected': {
	                color: validateProps.isHighContrastMode ? highlightColor : primaryColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: validateProps.isHighContrastMode ? highlightColor : primaryColorDark,
	                }),
	            },
	            '&--disabled': {
	                cursor: 'not-allowed',
	                color: disabledColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: disabledColorDark,
	                }),
	            },
	            '&--hidden': {
	                display: 'none',
	            },
	        },
	    };
	};

	const propTypes = {
	    value: validateProps.AllowedTypes.string,
	    disabled: validateProps.AllowedTypes.boolean,
	};
	const SelectOption = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.onClick = () => {
	            this.host.dispatchEvent(new CustomEvent('internalOptionUpdate', {
	                bubbles: true,
	            }));
	        };
	        this.onSlotChange = (e) => {
	            validateSelectOption(e.target, this.host);
	        };
	        this.value = undefined;
	        this.disabled = false;
	    }
	    connectedCallback() {
	        throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-select');
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        const { theme = 'light', selected, highlighted, hidden } = this.host;
	        validateProps.attachComponentCss(this.host, getComponentCss, theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(validateProps.Host, { key: 'fe8d58172447c6d338c493c085ac7b1470eea219', onClick: !this.disabled && this.onClick }, validateProps.h("div", { key: 'e909499ea957e72a9bac3c0c0d9fbc20090dc42c', role: "option", class: {
	                option: true,
	                'option--selected': selected,
	                'option--highlighted': highlighted,
	                'option--disabled': this.disabled,
	            }, ...getNativePopoverDropdownPosition.getOptionAriaAttributes(selected, this.disabled, hidden, !!this.value) }, validateProps.h("slot", { key: '33825020940cf1979a2fe5508da6f954059ddf87', onSlotchange: this.onSlotChange }), selected && (validateProps.h(PrefixedTagNames.pIcon, { class: "icon", "aria-hidden": "true", name: "check", color: this.disabled ? 'state-disabled' : 'primary', theme: theme })))));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pSelect_2_cjs_entry.p_select = Select;
	pSelect_2_cjs_entry.p_select_option = SelectOption;

	
	return pSelect_2_cjs_entry;
}

var pSelectWrapper_2_cjs_entry = {};

var propertyObserverE214b5c5 = {};

var hasRequiredPropertyObserverE214b5c5;

function requirePropertyObserverE214b5c5 () {
	if (hasRequiredPropertyObserverE214b5c5) return propertyObserverE214b5c5;
	hasRequiredPropertyObserverE214b5c5 = 1;

	// inspired by react
	// https://github.com/facebook/react/blob/c88fb49d37fd01024e0a254a37b7810d107bdd1d/packages/react-dom/src/client/inputValueTracking.js#L53
	const observeProperties = (node, props, callback) => {
	    const proto = Object.getPrototypeOf(node);
	    const properties = props.reduce((result, prop) => {
	        const descriptor = Object.getOwnPropertyDescriptor(proto, prop);
	        if (
	        // node.hasOwnProperty(prop) || // this condition breaks p-text-field-wrapper type="search" clear button functionality in react
	        typeof descriptor === 'undefined' ||
	            typeof descriptor.get !== 'function' ||
	            typeof descriptor.set !== 'function') {
	            return result;
	        }
	        else {
	            // eslint-disable-next-line @typescript-eslint/unbound-method
	            const { get, set } = descriptor;
	            return {
	                ...result,
	                [prop]: {
	                    configurable: true,
	                    get() {
	                        return get.call(this);
	                    },
	                    set(val) {
	                        set.call(this, val);
	                        callback();
	                    },
	                },
	            };
	        }
	    }, {});
	    Object.defineProperties(node, properties);
	};

	propertyObserverE214b5c5.observeProperties = observeProperties;

	
	return propertyObserverE214b5c5;
}

var throwIfRootNodeIsNotOneOfKind8d4ae960 = {};

var hasRequiredThrowIfRootNodeIsNotOneOfKind8d4ae960;

function requireThrowIfRootNodeIsNotOneOfKind8d4ae960 () {
	if (hasRequiredThrowIfRootNodeIsNotOneOfKind8d4ae960) return throwIfRootNodeIsNotOneOfKind8d4ae960;
	hasRequiredThrowIfRootNodeIsNotOneOfKind8d4ae960 = 1;

	const validateProps = requireValidatePropsF6586828();

	const throwIfRootNodeIsNotOneOfKind = (element, tagNames) => {
	    const shadowHost = element.getRootNode()?.host;
	    const actualTagName = shadowHost && validateProps.getTagName(shadowHost);
	    const prefixedTagNames = validateProps.getPrefixedTagNames(element);
	    const allowedTagNames = tagNames.map((tagName) => prefixedTagNames[validateProps.paramCaseToCamelCase(tagName)]);
	    if (!allowedTagNames.includes(actualTagName)) {
	        validateProps.throwException(`${validateProps.getTagNameWithoutPrefix(element)} can't be used like this.`);
	    }
	};

	throwIfRootNodeIsNotOneOfKind8d4ae960.throwIfRootNodeIsNotOneOfKind = throwIfRootNodeIsNotOneOfKind;

	
	return throwIfRootNodeIsNotOneOfKind8d4ae960;
}

var hasRequiredPSelectWrapper_2_cjs_entry;

function requirePSelectWrapper_2_cjs_entry () {
	if (hasRequiredPSelectWrapper_2_cjs_entry) return pSelectWrapper_2_cjs_entry;
	hasRequiredPSelectWrapper_2_cjs_entry = 1;

	Object.defineProperty(pSelectWrapper_2_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const required = requireRequiredF3c463a3();
	const label = requireLabel5379ea8c();
	const theme = requireThemeBfc10573();
	const getOnlyChildOfKindHTMLElementOrThrow = requireGetOnlyChildOfKindHTMLElementOrThrowF7285231();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const formStyles = requireFormStyles7e9d1c43();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const popoverResetStyles = requirePopoverResetStylesFad56b6d();
	const getNativePopoverDropdownPosition = requireGetNativePopoverDropdownPosition06475061();
	const isSsrHydration = requireIsSsrHydration9278b79b();
	const propertyObserver = requirePropertyObserverE214b5c5();
	const throwIfRootNodeIsNotOneOfKind = requireThrowIfRootNodeIsNotOneOfKind8d4ae960();
	const getHTMLElements = requireGetHTMLElements3f1c700f();
	const hasAttribute = requireHasAttributeBf22c03a();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const fontLineHeight = requireFontLineHeight78b03658();
	const fontWeightSemiBold = requireFontWeightSemiBold4482c830();
	requireHasNamedSlotA96fd22a();
	requireGetNamedSlotA0cdbdbc();
	requireFontSizeTextXSmallE59d35d7();
	requireGetClosestHTMLElement83d01a84();
	requireHasDescriptionBbe55afe();
	requireIsParentOfKindB7d9f81c();
	requireGetDirectChildHTMLElements31d23fa9();
	requireTransformSelectorToDirectChildSelectorC1b1f9b0();
	requireSpacingStaticMedium94812711();
	requireScrollerPopoverUtils89485ebc();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();

	const getSlotTextContent = (el, slotName) => validateProps.getHTMLElement(el, `[slot="${slotName}"]`)?.textContent;

	const isTouchDevice = () => {
	    if (!validateProps.hasWindow) {
	        return;
	    }
	    return !!('ontouchstart' in window || window.navigator.maxTouchPoints > 0);
	};

	const DROPDOWN_DIRECTIONS_INTERNAL = ['down', 'up'];
	const DROPDOWN_DIRECTIONS = [...DROPDOWN_DIRECTIONS_INTERNAL, 'auto'];
	const isCustomDropdown = (filter, native) => {
	    if (filter) {
	        return true;
	    }
	    else if (native) {
	        return false;
	    }
	    else {
	        return !isTouchDevice();
	    }
	};

	const getComponentCss$1 = (isDisabled, hasCustomDropdown, hideLabel, state, theme) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            // ::slotted(select)
	            ...validateProps.addImportantToEachRule(formStyles.getSlottedTextFieldTextareaSelectStyles('select', state, false, theme, {
	                gridArea: '1/1/1/-1',
	                position: 'static',
	                zIndex: 0, // TODO: overrides global style.css in e2e and vrts
	                cursor: 'pointer',
	                // TODO: move into getSlottedTextFieldTextareaSelectStyles()
	                padding: `${formStyles.formElementPaddingVertical} ${formStyles.formElementPaddingHorizontal}`,
	                paddingInlineEnd: formStyles.getCalculatedFormElementPaddingHorizontal(1),
	                // TODO: needs to be aligned with multi-select
	                ...(hasCustomDropdown && !isDisabled && { borderColor: 'transparent' }),
	            })),
	        },
	        root: {
	            display: 'grid',
	            gap: spacingStaticXSmall.spacingStaticXSmall,
	        },
	        wrapper: {
	            display: 'grid',
	            gridTemplateColumns: `minmax(0, 1fr) auto ${formStyles.formElementLayeredSafeZone}`,
	        },
	        // TODO: extract for multi-select, select-wrapper and text-field (not gridArea and placeSelf)
	        icon: {
	            gridArea: '1/2',
	            placeSelf: 'center',
	            position: 'relative',
	            zIndex: 2, // ensures icon is above input or button of select dropdown
	            pointerEvents: 'none',
	            padding: formStyles.formButtonOrIconPadding,
	            transform: 'rotate3d(0,0,1,0.0001deg)', // needs to be a little more than 0 for correct direction in safari
	            transition: validateProps.getTransition('transform'),
	            '&--open': {
	                transform: 'rotate3d(0,0,1,180deg)',
	            },
	        },
	        dropdown: {
	            gridArea: '1/1/1/-1',
	        },
	        // .label / .required
	        ...label.getFunctionalComponentLabelStyles(isDisabled, hideLabel, theme),
	        // .message
	        ...required.getFunctionalComponentStateMessageStyles(theme, state),
	    });
	};

	const propTypes = {
	    label: validateProps.AllowedTypes.string,
	    description: validateProps.AllowedTypes.string,
	    state: validateProps.AllowedTypes.oneOf(required.FORM_STATES),
	    message: validateProps.AllowedTypes.string,
	    hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	    filter: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    dropdownDirection: validateProps.AllowedTypes.oneOf(DROPDOWN_DIRECTIONS),
	    native: validateProps.AllowedTypes.boolean,
	};
	const SelectWrapper = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.label = '';
	        this.description = '';
	        this.state = 'none';
	        this.message = '';
	        this.hideLabel = false;
	        this.filter = false;
	        this.theme = 'light';
	        this.dropdownDirection = 'auto';
	        this.native = false;
	    }
	    connectedCallback() {
	        this.observeAttributes(); // on every reconnect
	    }
	    componentWillLoad() {
	        this.select = getOnlyChildOfKindHTMLElementOrThrow.getOnlyChildOfKindHTMLElementOrThrow(this.host, 'select');
	        this.observeAttributes(); // once initially
	        this.hasCustomDropdown = isCustomDropdown(this.filter, this.native);
	        if (this.hasCustomDropdown) {
	            validateProps.setAttribute(this.select, 'tabindex', '-1');
	            validateProps.setAttribute(this.select, 'aria-hidden', 'true');
	        }
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    componentDidRender() {
	        /*
	         * This is a workaround to improve accessibility because the select and the label/description/message text are placed in different DOM.
	         * Referencing ID's from outside the component is impossible because the web component’s DOM is separate.
	         * We have to wait for full support of the Accessibility Object Model (AOM) to provide the relationship between shadow DOM and slots.
	         */
	        if (!this.hasCustomDropdown) {
	            validateProps.setAriaAttributes(this.select, {
	                label: this.label,
	                message: this.message || this.description,
	                state: this.state,
	            });
	        }
	    }
	    disconnectedCallback() {
	        validateProps.unobserveAttributes(this.select);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        const { disabled } = this.select;
	        validateProps.attachComponentCss(this.host, getComponentCss$1, disabled, this.hasCustomDropdown, this.hideLabel, this.state, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h("div", { key: '239de345d29b0b05236333e42732f68f680e9740', class: "root" }, validateProps.h(label.Label, { key: '20a659b3840868010427dea54a105f9b9f9582a3', host: this.host, label: this.label, description: this.description, isDisabled: disabled, formElement: this.select }), validateProps.h("div", { key: '2978bdd5ce9a45ef7b54087ee63bcd8dffb5c851', class: "wrapper" }, validateProps.h("slot", { key: 'd601d051aa2090766f1a889a0f41519b0d59fa9b' }), validateProps.h(PrefixedTagNames.pIcon, { key: '326282745b8c8c9b895dc555d93bb9e3bdb1d572', class: "icon", name: "arrow-head-down", theme: this.theme, color: disabled ? 'state-disabled' : 'primary', "aria-hidden": "true", ref: (el) => (this.iconElement = el) }), this.hasCustomDropdown && !disabled && (validateProps.h(PrefixedTagNames.pSelectWrapperDropdown, { class: "dropdown", selectRef: this.select, label: this.label || getSlotTextContent(this.host, 'label'), message: this.message || getSlotTextContent(this.host, 'message'), description: this.description || getSlotTextContent(this.host, 'description'), state: this.state, direction: this.dropdownDirection, filter: this.filter, theme: this.theme, required: label.isRequiredAndParentNotRequired(this.host, this.select), disabled: disabled, onOpenChange: (isOpen) => this.iconElement.classList.toggle('icon--open', isOpen) }))), validateProps.h(required.StateMessage, { key: '364b867ad056ee38b6844c7003d7804b84907979', state: this.state, message: this.message, theme: this.theme, host: this.host })));
	    }
	    observeAttributes() {
	        validateProps.observeAttributes(this.select, ['disabled', 'required'], () => validateProps.forceUpdate(this.host));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	/**
	 * Handles scrolling within the list to ensure that the highlighted item is always visible.
	 * @param {HTMLElement} ul - The HTML element to be scrolled.
	 * @param {number} highlightedIndex - The index of the currently highlighted item within the element.
	 * @returns {void}
	 */
	const handleScroll = (ul, highlightedIndex) => {
	    const { maxHeight } = getComputedStyle(ul);
	    const hostElementHeight = parseInt(maxHeight, 10);
	    if (ul.scrollHeight > hostElementHeight) {
	        const highlightedNode = getHTMLElements.getHTMLElements(ul, 'li')[highlightedIndex];
	        if (highlightedNode) {
	            highlightedNode.scrollIntoView({ block: 'nearest' });
	        }
	    }
	};
	const getOptionsElements = (select) => Array.from(select.options);
	const getOptionMaps = (options) => options.map((item) => {
	    const { selected, parentElement, previousElementSibling } = item;
	    const option = {
	        value: item.text,
	        disabled: hasAttribute.hasAttribute(item, 'disabled'),
	        hidden: false,
	        initiallyHidden: hasAttribute.hasAttribute(item, 'hidden'),
	        selected,
	        highlighted: selected,
	        ...(validateProps.getTagName(parentElement) === 'optgroup' &&
	            previousElementSibling === null && { title: parentElement.label }),
	    };
	    return option;
	});
	const setSelectedOptionMaps = (options, newIndex) => options.map((item, idx) => ({
	    ...item,
	    selected: idx === newIndex,
	    highlighted: idx === newIndex,
	    hidden: false,
	}));
	const setHighlightedOptionMaps = (options, newIndex) => options.map((item, idx) => ({
	    ...item,
	    highlighted: idx === newIndex,
	}));
	const resetHighlightedToSelectedOptionMaps = (options) => options.map((item) => ({ ...item, highlighted: item.selected }));
	const setFirstHighlightedOptionMaps = (options) => setHighlightedOptionMaps(options, 0);
	const setLastHighlightedOptionMaps = (options) => setHighlightedOptionMaps(options, options.length - 1);
	const getHighlightedOptionMapIndex = (arr) => arr.findIndex((item) => item.highlighted);
	const getSelectedOptionMap = (arr) => arr.find((item) => item.selected);
	const getValidOptions = (options) => options.filter((item) => !item.hidden && !item.initiallyHidden && !item.disabled);
	const getAmountOfVisibleOptionsAndOptgroups = (options) => {
	    return options.reduce((count, { hidden, initiallyHidden, title }) => {
	        count += !hidden && !initiallyHidden ? 1 : 0;
	        count += title ? 1 : 0;
	        return count;
	    }, 0);
	};
	const getMatchingOptionMaps = (options, searchString) => {
	    const lowerCaseSearchString = searchString.toLowerCase();
	    return lowerCaseSearchString && options.filter((item) => item.value.toLowerCase() === lowerCaseSearchString);
	};
	const getFirstMatchingOptionMapIndex = (options, key) => {
	    // TODO: what about other characters?
	    if ([...'abcdefghijklmnopqrstuvwxyzäöüß1234567890'].includes(key)) {
	        const lowerCaseSearchString = key.toLowerCase();
	        const firstMatchingIndex = lowerCaseSearchString && options.findIndex((item) => item.value.toLowerCase().startsWith(lowerCaseSearchString));
	        // jump to last item if no match is found
	        return firstMatchingIndex >= 0 ? firstMatchingIndex : options.length - 1;
	    }
	};
	const setHighlightedFirstMatchingOptionMaps = (options, key) => {
	    const targetIndex = getFirstMatchingOptionMapIndex(options, key);
	    return targetIndex >= 0 ? options.map((item, idx) => ({ ...item, highlighted: idx === targetIndex })) : options;
	};
	const setFilteredOptionMaps = (options, searchString) => {
	    const lowerCaseSearchString = searchString.toLowerCase();
	    return options.map((item) => ({
	        ...item,
	        hidden: !item.initiallyHidden && !item.value.toLowerCase().includes(lowerCaseSearchString),
	    }));
	};
	const resetFilteredOptionMaps = (options) => options.map((item) => ({
	    ...item,
	    hidden: false,
	}));
	const hasFilterResults = (options) => options.some((item) => !item.hidden && !item.initiallyHidden);
	const getNewOptionMapIndex = (options, direction) => {
	    const validItems = getValidOptions(options);
	    const validMax = validItems.length - 1;
	    // prob. needs to be <= 0
	    if (validMax < 0) {
	        return;
	    }
	    let i = getHighlightedOptionMapIndex(validItems);
	    if (direction === 'down') {
	        i = i < validMax ? i + 1 : 0;
	    }
	    else if (direction === 'up') {
	        i = i > 0 ? i - 1 : validMax;
	    }
	    return options.indexOf(validItems[i]);
	};
	const getDropdownVisibility = (isOpen, type, resetFilter) => {
	    if (isOpen && (type === 'hide' || type === 'toggle')) {
	        if (resetFilter) {
	            resetFilter();
	        }
	        return false;
	    }
	    else if (!isOpen && (type === 'show' || type === 'toggle')) {
	        return true;
	    }
	    else {
	        return isOpen;
	    }
	};

	const dropdownPositionVar = '--p-internal-dropdown-position';
	const getButtonStyles = (direction, isOpen, state, theme) => {
	    const { primaryColor, disabledColor, contrastMediumColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, disabledColor: disabledColorDark, contrastMediumColor: contrastMediumColorDark, } = validateProps.getThemedColors('dark');
	    const { formStateHoverColor, formStateColor } = required.getThemedFormStateColors(theme, state);
	    const { formStateHoverColor: formStateHoverColorDark, formStateColor: formStateColorDark } = required.getThemedFormStateColors('dark', state);
	    const isDirectionDown = direction === 'down';
	    return {
	        '@global': {
	            // TODO: extract generic default button/anchor reset style
	            button: {
	                position: 'absolute',
	                inset: 0,
	                width: '100%', // fixes Firefox positioning issue
	                height: '100%', // fixes Firefox positioning issue
	                margin: 0,
	                padding: 0,
	                background: 'transparent',
	                border: `${validateProps.borderWidthBase} solid ${isOpen ? primaryColor : formStateColor || contrastMediumColor}`, // using border of styled select below for label:hover selector
	                borderRadius: borderRadiusSmall.borderRadiusSmall,
	                outline: '0',
	                cursor: 'pointer',
	                transition: validateProps.getTransition('border-color'), // background and text color are handled on select
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    borderColor: isOpen ? primaryColorDark : formStateColorDark || contrastMediumColorDark,
	                }),
	                // TODO: getFocusJssStyle() can't be re-used because focus style differs for form elements
	                '&:focus, &:focus ~ ul': {
	                    borderColor: primaryColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        borderColor: primaryColorDark,
	                    }),
	                },
	                ...hoverMediaQuery.hoverMediaQuery({
	                    '&:not(:disabled):not(:focus):hover': {
	                        borderColor: isOpen ? primaryColor : formStateHoverColor || primaryColor,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            borderColor: isOpen ? primaryColorDark : formStateHoverColorDark || primaryColorDark,
	                        }),
	                    },
	                }),
	                '&:disabled': {
	                    cursor: 'not-allowed',
	                    borderColor: disabledColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        borderColor: disabledColorDark,
	                    }),
	                },
	                ...(isOpen && {
	                    [isDirectionDown ? 'borderBottomLeftRadius' : 'borderTopLeftRadius']: 0,
	                    [isDirectionDown ? 'borderBottomRightRadius' : 'borderTopRightRadius']: 0,
	                }),
	            },
	        },
	    };
	};
	const getFilterStyles = (direction, isOpen, state, disabled, theme) => {
	    const { primaryColor, backgroundColor, disabledColor, contrastMediumColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, backgroundColor: backgroundColorDark, disabledColor: disabledColorDark, contrastMediumColor: contrastMediumColorDark, } = validateProps.getThemedColors('dark');
	    const { formStateHoverColor, formStateColor } = required.getThemedFormStateColors(theme, state);
	    const { formStateHoverColor: formStateHoverColorDark, formStateColor: formStateColorDark } = required.getThemedFormStateColors('dark', state);
	    const isDirectionDown = direction === 'down';
	    const placeHolderJssStyle = {
	        opacity: 1,
	        color: disabled ? disabledColor : primaryColor,
	    };
	    const placeHolderDarkJssStyle = {
	        opacity: 1,
	        color: disabled ? disabledColorDark : primaryColorDark,
	    };
	    return {
	        '@global': {
	            input: {
	                display: 'block',
	                position: 'absolute',
	                inset: validateProps.borderWidthBase,
	                width: 'calc(100% - 4px)', // fixes Firefox positioning issue, 4px = 2 x borderWidthBase
	                height: 'calc(100% - 4px)', // fixes Firefox positioning issue, 4px = 2 x borderWidthBase
	                zIndex: 1,
	                font: textSmallStyle.textSmallStyle.font.replace('ex', 'ex + 6px'), // a minimum line-height is needed for input, otherwise value is scrollable in Chrome, +6px is alig
	                margin: 0, // necessary reset for iOS Safari 15 (and maybe other browsers)
	                // TODO: could be done with css subgrid much more elegant in the near future
	                //  or move input into select-wrapper and handle it the same like multi-select
	                padding: `${formStyles.formElementPaddingVertical} ${formStyles.formElementPaddingHorizontal}`,
	                paddingInlineEnd: formStyles.getCalculatedFormElementPaddingHorizontal(1),
	                outline: '0',
	                WebkitAppearance: 'none', // iOS safari
	                appearance: 'none',
	                boxSizing: 'border-box',
	                border: '0', // done via span
	                borderRadius: borderRadiusSmall.borderRadiusSmall, // for white corners
	                opacity: 0, // is used to overlay input on focus
	                ...textSmallStyle.textSmallStyle,
	                textIndent: 0,
	                cursor: disabled ? 'not-allowed' : 'text',
	                color: primaryColor,
	                background: backgroundColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: primaryColorDark,
	                    background: backgroundColorDark,
	                }),
	                '&::placeholder': {
	                    ...placeHolderJssStyle,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, placeHolderDarkJssStyle),
	                },
	                '&::-webkit-input-placeholder': {
	                    ...placeHolderJssStyle,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, placeHolderDarkJssStyle),
	                },
	                '&::-moz-placeholder': {
	                    ...placeHolderJssStyle,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, placeHolderDarkJssStyle),
	                },
	                '&:not(:disabled):focus': {
	                    opacity: 1, // to display value while typing
	                    '&+span, &~ ul': {
	                        borderColor: primaryColor,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            borderColor: primaryColorDark,
	                        }),
	                    },
	                },
	                ...hoverMediaQuery.hoverMediaQuery({
	                    '&:not(:disabled)': {
	                        '&+span:hover': {
	                            borderColor: isOpen ? primaryColor : formStateHoverColor || primaryColor,
	                            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                                borderColor: isOpen ? primaryColorDark : formStateHoverColorDark || primaryColorDark,
	                            }),
	                        },
	                        '&:hover': {
	                            '&+span, &~ul': {
	                                borderColor: isOpen ? primaryColor : formStateHoverColor || primaryColor,
	                                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                                    borderColor: isOpen ? primaryColorDark : formStateHoverColorDark || primaryColorDark,
	                                }),
	                            },
	                        },
	                    },
	                }),
	                // TODO: we should try to get rid of the span and apply the border-styles on either select or input
	                '&+span': {
	                    // for focus outline and clicking arrow since input ends left of the icon
	                    position: 'absolute',
	                    inset: 0,
	                    transition: validateProps.getTransition('border-color'),
	                    pointerEvents: 'all',
	                    cursor: disabled ? 'not-allowed' : 'pointer',
	                    border: `${validateProps.borderWidthBase} solid ${isOpen ? primaryColor : formStateColor || contrastMediumColor}`,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        borderColor: isOpen ? primaryColorDark : formStateColorDark || contrastMediumColorDark,
	                    }),
	                    borderRadius: borderRadiusSmall.borderRadiusSmall,
	                    ...(isOpen && {
	                        [isDirectionDown ? 'borderBottomLeftRadius' : 'borderTopLeftRadius']: 0,
	                        [isDirectionDown ? 'borderBottomRightRadius' : 'borderTopRightRadius']: 0,
	                    }),
	                },
	            },
	        },
	    };
	};
	const getListStyles = (direction, theme) => {
	    const isDirectionDown = direction === 'down';
	    const { primaryColor: primaryColorDark, backgroundColor: backgroundColorDark, contrastMediumColor: contrastMediumColorDark, disabledColor: disabledColorDark, contrastHighColor: contrastHighColorDark, backgroundSurfaceColor: backgroundSurfaceColorDark, contrastLowColor: contrastLowColorDark, } = validateProps.getThemedColors('dark');
	    const { primaryColor, backgroundColor, contrastMediumColor, contrastHighColor, backgroundSurfaceColor, disabledColor, contrastLowColor, } = validateProps.getThemedColors(theme);
	    const { highlightColor } = validateProps.getHighContrastColors();
	    return {
	        '@global': {
	            ul: {
	                display: 'flex',
	                flexDirection: 'column',
	                gap: spacingStaticSmall.spacingStaticSmall,
	                position: `var(${dropdownPositionVar}, absolute)`, // for vrt tests
	                padding: '6px',
	                margin: 0,
	                background: backgroundColor,
	                ...textSmallStyle.textSmallStyle,
	                color: contrastHighColor,
	                zIndex: 10,
	                left: 0,
	                right: 0,
	                [isDirectionDown ? 'top' : 'bottom']: 'calc(100% - 2px)', // 2px border + 2px safety for rounded corners
	                boxSizing: 'border-box',
	                maxHeight: `${8.5 * (getNativePopoverDropdownPosition.OPTION_HEIGHT + 8) + 6 + 2}px`, // 8px = gap, 6px = padding, 2px = border
	                overflowY: 'auto',
	                WebkitOverflowScrolling: 'touch',
	                scrollBehavior: 'smooth',
	                border: `2px solid ${primaryColor}`,
	                [isDirectionDown ? 'borderTop' : 'borderBottom']: validateProps.addImportantToRule(`1px solid ${contrastMediumColor}`),
	                ...(isDirectionDown
	                    ? ['borderBottomLeftRadius', 'borderBottomRightRadius']
	                    : ['borderTopLeftRadius', 'borderTopRightRadius']).reduce((result, curr) => ({ ...result, [curr]: borderRadiusSmall.borderRadiusSmall }), {}),
	                scrollbarWidth: 'thin', // firefox
	                scrollbarColor: 'auto', // firefox
	                transition: validateProps.getTransition('border-color'),
	                transform: 'translate3d(0,0,0)', // fix iOS bug if less than 5 items are displayed
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: contrastHighColorDark,
	                    background: backgroundColorDark,
	                    borderColor: primaryColorDark,
	                    [isDirectionDown ? 'borderTopColor' : 'borderBottomColor']: validateProps.addImportantToRule(contrastMediumColorDark),
	                }),
	            },
	        },
	        option: {
	            display: 'flex',
	            justifyContent: 'space-between',
	            gap: '12px',
	            padding: `${spacingStaticSmall.spacingStaticSmall} 12px`,
	            flex: `1 0 calc(${fontLineHeight.fontLineHeight} + ${spacingStaticSmall.spacingStaticSmall} * 2)`,
	            cursor: 'pointer',
	            textAlign: 'start',
	            wordBreak: 'break-word',
	            boxSizing: 'border-box',
	            borderRadius: borderRadiusSmall.borderRadiusSmall,
	            transition: `${validateProps.getTransition('background-color')}, ${validateProps.getTransition('color')}`,
	            ...getNativePopoverDropdownPosition.getNoResultsOptionJssStyle(),
	            ...hoverMediaQuery.hoverMediaQuery({
	                '&:not([aria-disabled]):not(.option--disabled):not([role=status]):hover': {
	                    color: validateProps.isHighContrastMode ? highlightColor : primaryColor,
	                    background: contrastLowColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        color: validateProps.isHighContrastMode ? highlightColor : primaryColorDark,
	                        background: contrastLowColorDark,
	                    }),
	                },
	            }),
	            '&--selected': {
	                cursor: 'default',
	                pointerEvents: 'none',
	                background: backgroundSurfaceColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    background: backgroundSurfaceColorDark,
	                }),
	            },
	            '&--highlighted': {
	                background: contrastLowColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    background: contrastLowColorDark,
	                }),
	            },
	            '&--highlighted, &--selected': {
	                color: validateProps.isHighContrastMode ? highlightColor : primaryColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: validateProps.isHighContrastMode ? highlightColor : primaryColorDark,
	                }),
	            },
	            '&--disabled': {
	                cursor: 'not-allowed',
	                color: disabledColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: disabledColorDark,
	                }),
	            },
	            '&--hidden': {
	                display: 'none',
	            },
	        },
	        optgroup: {
	            color: contrastMediumColor,
	            display: 'block',
	            padding: '3px 14px',
	            fontWeight: fontWeightSemiBold.fontWeightSemiBold,
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                color: contrastMediumColorDark,
	            }),
	            '&:not(:first-child)': {
	                marginTop: spacingStaticSmall.spacingStaticSmall,
	            },
	            '&~$option': {
	                paddingLeft: '24px',
	            },
	        },
	    };
	};
	const getComponentCss = (direction, isOpen, state, disabled, filter, isNativePopoverCase, theme) => {
	    return validateProps.getCss(
	    // merge because of global styles
	    validateProps.mergeDeep({
	        '@global': {
	            ':host': {
	                display: 'block',
	                position: 'relative',
	            },
	        },
	        'sr-text': {
	            display: 'none',
	        },
	        ...(isNativePopoverCase && {
	            popover: {
	                ...popoverResetStyles.getPopoverResetJssStyle(),
	            },
	        }),
	    }, filter
	        ? getFilterStyles(direction, isOpen, state, disabled, theme)
	        : getButtonStyles(direction, isOpen, state, theme), isOpen && getListStyles(direction, theme)));
	};

	const SelectWrapperDropdown = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.isNativePopoverCase = false;
	        this.onClickOutside = (e) => {
	            if (this.isOpen && popoverResetStyles.isClickOutside(e, this.host)) {
	                this.setDropdownVisibility('hide');
	            }
	        };
	        this.setDropdownVisibility = (type) => {
	            this.isOpen = getDropdownVisibility(this.isOpen, type, this.filter && this.resetFilter);
	            this.onOpenChange(this.isOpen);
	            if (this.isNativePopoverCase) {
	                if (this.isOpen) {
	                    getNativePopoverDropdownPosition.getNativePopoverDropdownPosition(this.host, getAmountOfVisibleOptionsAndOptgroups(this.optionMaps), this.popoverElement, this.direction);
	                    this.popoverElement.showPopover();
	                }
	                else {
	                    this.popoverElement.hidePopover();
	                }
	            }
	        };
	        this.onComboboxKeyDown = (e) => {
	            switch (e.key) {
	                case 'ArrowUp':
	                case 'Up':
	                    e.preventDefault();
	                    this.cycleDropdown('up');
	                    break;
	                case 'ArrowDown':
	                case 'Down':
	                    e.preventDefault();
	                    this.cycleDropdown('down');
	                    break;
	                case ' ':
	                case 'Spacebar':
	                case 'Enter':
	                    if (this.filter) {
	                        if (e.key === 'Enter') {
	                            e.preventDefault();
	                            const matchingOptions = getMatchingOptionMaps(this.optionMaps, this.searchString);
	                            if (matchingOptions.length === 1) {
	                                this.setOptionSelected(this.optionMaps.indexOf(matchingOptions[0]));
	                            }
	                            else {
	                                this.setOptionSelected(getHighlightedOptionMapIndex(this.optionMaps));
	                            }
	                        }
	                    }
	                    else {
	                        e.preventDefault();
	                        if (this.isOpen) {
	                            this.setOptionSelected(getHighlightedOptionMapIndex(this.optionMaps));
	                        }
	                        else {
	                            this.setDropdownVisibility('show');
	                        }
	                    }
	                    break;
	                case 'Escape':
	                case 'Tab':
	                    this.setDropdownVisibility('hide');
	                    this.resetHighlightedToSelectedOptionMaps();
	                    break;
	                case 'PageUp':
	                    if (this.isOpen) {
	                        e.preventDefault();
	                        this.optionMaps = setFirstHighlightedOptionMaps(this.optionMaps);
	                    }
	                    break;
	                case 'PageDown':
	                    if (this.isOpen) {
	                        e.preventDefault();
	                        this.optionMaps = setLastHighlightedOptionMaps(this.optionMaps);
	                    }
	                    break;
	                default:
	                    if (!this.filter) {
	                        // TODO: seems to be difficult to combine multiple keys as native select does
	                        this.optionMaps = setHighlightedFirstMatchingOptionMaps(this.optionMaps, e.key);
	                    }
	            }
	        };
	        this.syncSelectedIndex = () => {
	            this.optionMaps = setSelectedOptionMaps(this.optionMaps, this.selectedIndex);
	        };
	        this.setOptionMaps = () => {
	            this.optionMaps = setSelectedOptionMaps(getOptionMaps(getOptionsElements(this.selectRef)), this.selectedIndex);
	        };
	        this.resetHighlightedToSelectedOptionMaps = () => {
	            this.optionMaps = resetHighlightedToSelectedOptionMaps(this.optionMaps);
	        };
	        this.setOptionSelected = (newIndex) => {
	            this.setDropdownVisibility('hide');
	            if (this.selectedIndex !== newIndex) {
	                this.selectRef.selectedIndex = newIndex;
	                this.selectRef.dispatchEvent(new Event('change', { bubbles: true }));
	            }
	            else {
	                this.resetHighlightedToSelectedOptionMaps();
	                this.resetFilter();
	            }
	        };
	        this.resetFilter = () => {
	            if (this.filter) {
	                this.searchString = '';
	                this.optionMaps = resetFilteredOptionMaps(this.optionMaps);
	                this.inputElement.value = '';
	            }
	        };
	        this.onFilterChange = (e) => {
	            this.searchString = e.target.value;
	            if (this.searchString.startsWith(' ')) {
	                this.resetFilter();
	            }
	            else {
	                this.optionMaps = setFilteredOptionMaps(this.optionMaps, this.searchString);
	            }
	            // in case input is focused via tab instead of click
	            this.setDropdownVisibility('show');
	        };
	        this.selectRef = undefined;
	        this.label = undefined;
	        this.description = undefined;
	        this.message = undefined;
	        this.state = undefined;
	        this.direction = 'auto';
	        this.theme = 'light';
	        this.filter = false;
	        this.required = false;
	        this.disabled = false;
	        this.onOpenChange = undefined;
	        this.isOpenOverride = false;
	        this.isOpen = this.isOpenOverride;
	        this.optionMaps = [];
	        this.searchString = '';
	    }
	    get selectedIndex() {
	        return this.selectRef.selectedIndex;
	    }
	    connectedCallback() {
	        throwIfRootNodeIsNotOneOfKind.throwIfRootNodeIsNotOneOfKind(this.host, ['p-select-wrapper']);
	        validateProps.observeChildren(this.selectRef, () => {
	            this.setOptionMaps();
	            this.observeOptions(); // new option might have been added
	        }, 
	        // unfortunately we can't observe hidden property of option elements via observeProperties
	        // therefore we do it here via attribute
	        ['hidden', 'disabled', 'selected']);
	        this.isNativePopoverCase = popoverResetStyles.detectNativePopoverCase(this.host, true);
	        if (this.isNativePopoverCase) {
	            this.parentTableElement = popoverResetStyles.findClosestComponent(this.host.getRootNode().host, 'pTable');
	        }
	    }
	    componentDidRender() {
	        if (this.isOpen) {
	            handleScroll(this.listElement, getHighlightedOptionMapIndex(this.optionMaps));
	            if (this.isNativePopoverCase) {
	                popoverResetStyles.addNativePopoverScrollAndResizeListeners(this.host, this.parentTableElement, this.popoverElement, () => {
	                    this.setDropdownVisibility('hide');
	                });
	            }
	        }
	    }
	    componentWillLoad() {
	        if (!isSsrHydration.isSsrHydration(this.host)) {
	            // when ssr rendered component is partially hydrated before being rerendered by its parent select-wrapper
	            // it has no select ref and options can't be accessed
	            this.observeProperties();
	            document.addEventListener('mousedown', this.onClickOutside, true);
	        }
	    }
	    disconnectedCallback() {
	        document.removeEventListener('mousedown', this.onClickOutside, true);
	        validateProps.unobserveChildren(this.host);
	    }
	    render() {
	        validateProps.attachComponentCss(this.host, getComponentCss, this.direction === 'auto'
	            ? getNativePopoverDropdownPosition.determineDropdownDirection(this.host, getAmountOfVisibleOptionsAndOptgroups(this.optionMaps))
	            : this.direction, this.isOpen, this.state, this.disabled, this.filter, this.isNativePopoverCase, this.theme);
	        // TODO: part won't be needed as soon as button/input of select-wrapper-dropdown is part of shadow dom of select-wrapper itself
	        const part = 'select-wrapper-dropdown';
	        const dropdownId = 'list';
	        const labelId = 'label';
	        const descriptionId = this.description && 'description';
	        const buttonId = 'value';
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(validateProps.Host, { key: '11793a6769e76400d106704b74544fe5d53eb152' }, this.filter ? ([
	            validateProps.h("input", { key: "input", type: "text", role: "combobox", disabled: this.disabled, placeholder: getSelectedOptionMap(this.optionMaps)?.value || null, autoComplete: "off", value: this.searchString, ...getNativePopoverDropdownPosition.getFilterInputAriaAttributes(this.isOpen, this.required, labelId, descriptionId, dropdownId, getHighlightedOptionMapIndex(this.optionMaps)), onKeyDown: this.onComboboxKeyDown, onInput: this.onFilterChange, onClick: () => this.setDropdownVisibility('show'), ref: (el) => (this.inputElement = el) }),
	            validateProps.h("span", { part: part, key: "span", onClick: this.disabled ? undefined : () => this.setDropdownVisibility('toggle') }),
	        ]) : (validateProps.h("button", { part: part, type: "button", role: "combobox", id: buttonId, disabled: this.disabled, ...getNativePopoverDropdownPosition.getSelectDropdownButtonAriaAttributes(this.isOpen, labelId, descriptionId, dropdownId, getHighlightedOptionMapIndex(this.optionMaps)), onClick: () => this.setDropdownVisibility('toggle'), onKeyDown: this.onComboboxKeyDown })), [
	            validateProps.h("div", { class: "sr-text", id: labelId }, getSelectedOptionMap(this.optionMaps)?.value, ", ", this.label, !!this.message && `. ${this.message}`),
	            this.description && (validateProps.h("div", { class: "sr-text", id: descriptionId }, this.description)),
	            validateProps.h("div", { ...(this.isNativePopoverCase && {
	                    popover: 'auto',
	                    class: 'popover',
	                    ...(this.popoverElement?.matches(':popover-open') && {
	                        'popover-open': true,
	                    }),
	                }), ref: (el) => (this.popoverElement = el) }, this.isOpen && (validateProps.h("ul", { id: dropdownId, role: "listbox", tabIndex: -1, ...getNativePopoverDropdownPosition.getListAriaAttributes(this.label, this.required, this.filter, this.isOpen), ref: (el) => (this.listElement = el) }, this.filter && !hasFilterResults(this.optionMaps) ? (validateProps.h("li", { class: "option", "aria-live": "polite", role: "status" }, validateProps.h("span", { "aria-hidden": "true" }, "---"), validateProps.h("span", { class: "option__sr" }, "No results found"))) : (this.optionMaps.map((option, index) => {
	                const { value, disabled, hidden, initiallyHidden, selected, highlighted, title } = option;
	                return [
	                    title && (validateProps.h("span", { class: "optgroup", role: "presentation" }, title)),
	                    validateProps.h("li", { id: `option-${index}`, role: "option", class: {
	                            option: true,
	                            'option--selected': selected,
	                            'option--highlighted': highlighted,
	                            'option--disabled': disabled,
	                            'option--hidden': hidden || initiallyHidden,
	                        }, onClick: !selected && !disabled ? () => this.setOptionSelected(index) : undefined, ...getNativePopoverDropdownPosition.getOptionAriaAttributes(selected, disabled, hidden, !!value) }, value, selected && !disabled && (validateProps.h(PrefixedTagNames.pIcon, { "aria-hidden": "true", name: "check", color: disabled ? 'state-disabled' : 'primary', theme: this.theme }))),
	                ];
	            }))))),
	        ]));
	    }
	    observeProperties() {
	        this.setOptionMaps(); // initial
	        this.observeOptions(); // initial
	        propertyObserver.observeProperties(this.selectRef, ['value', 'selectedIndex'], this.syncSelectedIndex);
	    }
	    observeOptions() {
	        getOptionsElements(this.selectRef).forEach((el) => propertyObserver.observeProperties(el, ['selected', 'disabled'], this.setOptionMaps));
	    }
	    cycleDropdown(direction) {
	        if (this.isOpen) {
	            const newIndex = getNewOptionMapIndex(this.optionMaps, direction);
	            this.optionMaps = setHighlightedOptionMaps(this.optionMaps, newIndex);
	        }
	        this.setDropdownVisibility('show');
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pSelectWrapper_2_cjs_entry.p_select_wrapper = SelectWrapper;
	pSelectWrapper_2_cjs_entry.p_select_wrapper_dropdown = SelectWrapperDropdown;

	
	return pSelectWrapper_2_cjs_entry;
}

var pSpinner_cjs_entry = {};

var hasRequiredPSpinner_cjs_entry;

function requirePSpinner_cjs_entry () {
	if (hasRequiredPSpinner_cjs_entry) return pSpinner_cjs_entry;
	hasRequiredPSpinner_cjs_entry = 1;

	Object.defineProperty(pSpinner_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();

	const SPINNER_SIZES = ['small', 'medium', 'large', 'inherit'];
	const SPINNER_ARIA_ATTRIBUTES = ['aria-label'];

	const sizeSmall = '48px';
	const sizeMedium = '72px';
	const sizeLarge = '104px';
	const sizeMap = {
	    small: { height: sizeSmall, width: sizeSmall },
	    medium: { height: sizeMedium, width: sizeMedium },
	    large: { height: sizeLarge, width: sizeLarge },
	    inherit: { height: 'inherit', width: 'inherit' },
	};
	const getComponentCss = (size, theme) => {
	    const strokeDasharray = '57'; // C = 2πR
	    const animationDuration = `var(${validateProps.cssVariableAnimationDuration}, ${validateProps.motionDurationVeryLong})`;
	    const { primaryColor, contrastMediumColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, contrastMediumColor: contrastMediumColorDark } = validateProps.getThemedColors('dark');
	    const { canvasColor, canvasTextColor } = validateProps.getHighContrastColors();
	    const firstHighContrastStrokeColor = validateProps.isHighContrastMode && canvasTextColor;
	    const lastHighContrastStrokeColor = validateProps.isHighContrastMode && canvasColor;
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'inline-flex',
	                ...validateProps.addImportantToEachRule({
	                    verticalAlign: 'top',
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            svg: {
	                display: 'block', // for correct vertical alignment
	                fill: 'none',
	                animation: `$rotate ${animationDuration} steps(50) infinite`,
	            },
	            circle: {
	                '&:first-child': {
	                    // TODO: High Contrast Mode should be handled within a local color helper function
	                    stroke: firstHighContrastStrokeColor || contrastMediumColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        stroke: firstHighContrastStrokeColor || contrastMediumColorDark,
	                    }),
	                },
	                '&:last-child': {
	                    animation: `$dash ${animationDuration} steps(50) infinite`,
	                    // TODO: High Contrast Mode should be handled within a local color helper function
	                    stroke: lastHighContrastStrokeColor || primaryColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        stroke: lastHighContrastStrokeColor || primaryColorDark,
	                    }),
	                    strokeDasharray: strokeDasharray
	                        ,
	                    strokeLinecap: 'round',
	                },
	            },
	            '@keyframes rotate': {
	                '0%': {
	                    transform: 'rotateZ(0deg)',
	                },
	                '100%': {
	                    transform: 'rotateZ(360deg)',
	                },
	            },
	            '@keyframes dash': {
	                '0%': {
	                    strokeDashoffset: 57,
	                    transform: 'rotateZ(0)',
	                },
	                '50%, 75%': {
	                    strokeDashoffset: 20,
	                    transform: 'rotateZ(80deg)',
	                },
	                '100%': {
	                    strokeDashoffset: 57,
	                    transform: 'rotateZ(360deg)',
	                },
	            },
	        },
	        root: {
	            display: 'block',
	            ...validateProps.buildResponsiveStyles(size, (s) => sizeMap[s]),
	            strokeWidth: 1.5,
	        },
	        'sr-only': validateProps.getHiddenTextJssStyle(),
	    });
	};

	const propTypes = {
	    size: validateProps.AllowedTypes.breakpoint(SPINNER_SIZES),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    aria: validateProps.AllowedTypes.aria(SPINNER_ARIA_ATTRIBUTES),
	};
	const Spinner = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.size = 'small';
	        this.theme = 'light';
	        this.aria = undefined;
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.size, this.theme);
	        return (validateProps.h("span", { key: 'ec0ea6bbdfc7b2d53a7e79ae4514bcbb2a234dd0', class: "root", role: "alert", "aria-live": "assertive", ...validateProps.parseAndGetAriaAttributes(this.aria) }, validateProps.h("span", { key: '5fd0f211e4ec9e5b2ca6bebf3d0c6492785a2bd5', class: "sr-only" }, "\u00A0"), validateProps.h("svg", { key: '063845afee7eabf61faed13de9f481f05a70bb2e', viewBox: "-16 -16 32 32", width: "100%", height: "100%", focusable: "false", "aria-hidden": "true" }, validateProps.h("circle", { key: 'db16009336b58c7d0b38ad97a397e2472ffd9f9a', r: "9" }), validateProps.h("circle", { key: 'f8e3f94b57831c2309dc7357f6b9d5bb47629f18', r: "9" }))));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pSpinner_cjs_entry.p_spinner = Spinner;

	
	return pSpinner_cjs_entry;
}

var pStepperHorizontal_2_cjs_entry = {};

var hasRequiredPStepperHorizontal_2_cjs_entry;

function requirePStepperHorizontal_2_cjs_entry () {
	if (hasRequiredPStepperHorizontal_2_cjs_entry) return pStepperHorizontal_2_cjs_entry;
	hasRequiredPStepperHorizontal_2_cjs_entry = 1;

	Object.defineProperty(pStepperHorizontal_2_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const scrolling = requireScrolling7e2aff99();
	const theme = requireThemeBfc10573();
	const throwIfChildrenAreNotOfKind = requireThrowIfChildrenAreNotOfKind81b825bd();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const fontSizeText = requireFontSizeText728b6387();
	const getClickedItem = requireGetClickedItemDb2d9f29();
	const throwIfParentIsNotOfKind = requireThrowIfParentIsNotOfKindEb817ad3();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const escapeHashCharacter = requireEscapeHashCharacterB9f68bcf();
	const spacingFluidXSmall = requireSpacingFluidXSmall0dd753ae();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const fontLineHeight = requireFontLineHeight78b03658();
	requireScrollerPopoverUtils89485ebc();
	requireGetHTMLElements3f1c700f();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireFontSizeTextXXSmallA02f9c40();
	requireFontSizeTextXSmallE59d35d7();
	requireFontSizeTextMedium88887ad8();
	requireFontSizeTextLarge05a4bc90();
	requireFontSizeTextXLarge0ecf9ef3();
	requireIsParentOfKindB7d9f81c();

	const throwIfChildCountIsExceeded = (element, allowedAmount) => {
	    const childCount = element.children.length;
	    if (childCount > allowedAmount) {
	        validateProps.throwException(`only ${allowedAmount} children are allowed in ${validateProps.getTagNameWithoutPrefix(element)} but got ${childCount}.`);
	    }
	};

	const getComponentCss$1 = (size) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	        },
	        scroller: {
	            ...textSmallStyle.textSmallStyle,
	            ...validateProps.buildResponsiveStyles(size, (s) => ({ fontSize: fontSizeText.fontSizeText[s] })),
	        },
	    });
	};

	const STEPPER_HORIZONTAL_SIZES = ['small', 'medium'];
	const getIndexOfStepWithStateCurrent = (stepperHorizontalItems) => {
	    return stepperHorizontalItems.findIndex((item) => item.state === 'current');
	};
	const throwIfMultipleCurrentStates = (host, stepperHorizontalItems) => {
	    const currentStateCount = stepperHorizontalItems.filter((item) => item.state === 'current').length;
	    if (currentStateCount > 1) {
	        validateProps.throwException(`only one child with current state is allowed in ${validateProps.getTagNameWithoutPrefix(host)} but got ${currentStateCount}.`);
	    }
	};
	const syncStepperHorizontalItemsProps = (host, theme) => {
	    Array.from(host.children).forEach((item) => {
	        item.theme = theme;
	        validateProps.forceUpdate(item);
	    });
	};

	const propTypes$1 = {
	    size: validateProps.AllowedTypes.breakpoint(STEPPER_HORIZONTAL_SIZES),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const StepperHorizontal = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.stepChange = validateProps.createEvent(this, "stepChange", 3);
	        this.update = validateProps.createEvent(this, "update", 3);
	        this.stepperHorizontalItems = [];
	        this.onClickScroller = (e) => {
	            const target = getClickedItem.getClickedItem(this.host, 'p-stepper-horizontal-item', e.composedPath());
	            if (target) {
	                const clickedStepIndex = this.stepperHorizontalItems.indexOf(target);
	                this.update.emit({ activeStepIndex: clickedStepIndex });
	                this.stepChange.emit({ activeStepIndex: clickedStepIndex });
	            }
	        };
	        this.validateComponent = () => {
	            throwIfChildrenAreNotOfKind.throwIfChildrenAreNotOfKind(this.host, 'p-stepper-horizontal-item');
	            throwIfChildCountIsExceeded(this.host, 9);
	            this.stepperHorizontalItems = Array.from(this.host.children);
	            throwIfMultipleCurrentStates(this.host, this.stepperHorizontalItems);
	        };
	        this.scrollIntoView = () => {
	            const newStepIndex = getIndexOfStepWithStateCurrent(this.stepperHorizontalItems);
	            // If state is set to undefined index is -1
	            if (newStepIndex !== -1) {
	                const scrollActivePosition = scrolling.getScrollActivePosition(this.stepperHorizontalItems, newStepIndex > this.currentStepIndex ? 'next' : 'prev', newStepIndex, this.scrollerElement);
	                this.currentStepIndex = newStepIndex;
	                this.scrollerElement.scrollToPosition = {
	                    scrollPosition: scrollActivePosition,
	                    isSmooth: true,
	                };
	            }
	        };
	        this.observeBreakpointChange = () => {
	            if (typeof validateProps.parseJSON(this.size) === 'object') {
	                validateProps.observeBreakpointChange(this.host, this.scrollIntoView);
	            }
	        };
	        this.onSlotChange = () => {
	            this.validateComponent();
	            this.currentStepIndex = getIndexOfStepWithStateCurrent(this.stepperHorizontalItems);
	            this.scrollIntoView();
	        };
	        this.size = 'small';
	        this.theme = 'light';
	    }
	    connectedCallback() {
	        this.validateComponent(); // on every reconnect
	        this.observeBreakpointChange();
	    }
	    componentWillLoad() {
	        // Initial validation
	        this.validateComponent();
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    componentDidLoad() {
	        this.currentStepIndex = getIndexOfStepWithStateCurrent(this.stepperHorizontalItems);
	        this.observeBreakpointChange();
	        // Sometimes lifecycle gets called after disconnectedCallback()
	        if (this.scrollerElement) {
	            // Initial scroll current into view
	            this.scrollerElement.scrollToPosition = {
	                scrollPosition: scrolling.getScrollActivePosition(this.stepperHorizontalItems, 'next', this.currentStepIndex, this.scrollerElement),
	                isSmooth: false,
	            };
	        }
	        // TODO: would be great to use this in jsx but that doesn't work reliable and causes jsdom-polyfill unit test to fail
	        validateProps.getShadowRootHTMLElement(this.host, 'slot').addEventListener('slotchange', this.onSlotChange);
	    }
	    componentDidUpdate() {
	        throwIfMultipleCurrentStates(this.host, this.stepperHorizontalItems);
	        this.scrollIntoView();
	    }
	    disconnectedCallback() {
	        validateProps.unobserveBreakpointChange(this.host);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes$1);
	        validateProps.attachComponentCss(this.host, getComponentCss$1, this.size);
	        syncStepperHorizontalItemsProps(this.host, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(validateProps.Host, { key: '548c9450a044bc70b73a200d76ec4524f00a5d06' }, validateProps.h(PrefixedTagNames.pScroller, { key: '8cf89fd3acc13e6a3b34bf6ee85a29167bcc2320', class: "scroller", aria: { role: 'list' }, theme: this.theme, onClick: this.onClickScroller, ref: (el) => (this.scrollerElement = el) }, validateProps.h("slot", { key: '2208b99f5581756f5bb2b86dd33309fc56c4abc3' }))));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	const STEPPER_ITEM_STATES = ['current', 'complete', 'warning'];
	const isStateCompleteOrWarning = (state) => {
	    return state === 'complete' || state === 'warning';
	};
	const getStepperHorizontalIconName = (state) => {
	    return state === 'complete' ? 'success' : 'warning';
	};
	const throwIfCurrentAndDisabled = (host) => {
	    if (host.state === 'current' &&
	        host.disabled) {
	        validateProps.throwException(`using state='current' and disabled='true' for ${validateProps.getTagNameWithoutPrefix(host)} is not allowed.`);
	    }
	};
	const isItemClickable = (state, disabled) => {
	    return !!state && isStateCompleteOrWarning(state) && !disabled;
	};

	const getSVGPath = (stepCount, numberedCircleColors, isStateCurrent) => {
	    // # of the hexcolor starts a fragment identifier in URLs, so we have to replace it with the escaped value of # = %23
	    numberedCircleColors = Object.entries(numberedCircleColors).reduce((result, [key, value]) => ({ ...result, [key]: escapeHashCharacter.escapeHashCharacter(value) }), {});
	    const { disabledColor, invertedBaseColor, primaryColor } = numberedCircleColors;
	    const fillColor = isStateCurrent ? invertedBaseColor : disabledColor;
	    const svgCirclePath = `<circle fill="${isStateCurrent ? primaryColor : 'none'}"${isStateCurrent ? '' : ` stroke="${fillColor}"`} stroke-width="1px" cx="12" cy="12" r="9"/>`;
	    // Full SVG is provided by design (./numbers_raw.svg), created with illustrator and optimized with ImageOptim.
	    // The optimized file can be found in ./numbers_optim.svg.
	    // TODO: could certainly be optimized size wise by exporting icons larger and having less decimals
	    const svgNumberedCirclePaths = [
	        `${svgCirclePath}<path fill="${fillColor}" d="m12.33 8.67-2.43.91v-.94l2.6-1.03h.85v8.78h-1.02z"/>`,
	        `${svgCirclePath}<path fill="${fillColor}" d="m9.46 15.58c0-1.35.73-2.07 1.7-2.72l.95-.63c.78-.52 1.57-1.05 1.57-2.24 0-1.12-.62-1.58-1.7-1.58s-1.68.48-1.78 1.97h-.96c.06-1.82.78-2.91 2.74-2.91s2.72.92 2.72 2.52-.92 2.23-1.79 2.8l-.95.63c-1.11.75-1.52 1.18-1.52 2.01v.16h4.17v.81h-5.15v-.81z"/>`,
	        `${svgCirclePath}<path fill="${fillColor}" d="m10.1 13.73c.1 1.43.63 2 1.92 2 1.2 0 1.8-.49 1.8-1.68 0-1.08-.51-1.66-1.8-1.66h-.89v-.9h.83c1.12 0 1.66-.56 1.66-1.53 0-1.08-.64-1.55-1.73-1.55s-1.69.49-1.79 1.97h-.97c.1-1.79.84-2.91 2.76-2.91s2.74.92 2.74 2.49c0 .79-.38 1.54-1.16 1.9.84.28 1.36.92 1.36 2.19 0 1.54-.97 2.49-2.81 2.49-1.96 0-2.8-.9-2.88-2.81z"/>`,
	        `${svgCirclePath}<path fill="${fillColor}" d="m8.87 13.6 3.54-5.99h1.43v5.89h1.25v.86h-1.25v2.02h-.99v-2.02h-3.98zm3.98-.1v-4.98l-2.91 4.98z"/>`,
	        `${svgCirclePath}<path fill="${fillColor}" d="m9.34 12.45.42-4.83h4.71v.94h-3.9l-.26 2.95c.38-.43 1-.68 1.79-.68 1.86 0 2.76.9 2.76 2.81 0 2.06-1.03 2.91-2.86 2.91s-2.74-.84-2.81-2.51h.97c.06 1.13.57 1.7 1.84 1.7 1.39 0 1.85-.68 1.85-2.06s-.48-2-1.85-2c-1.07 0-1.54.42-1.75 1.17h-.91v-.39z"/>`,
	        `${svgCirclePath}<path fill="${fillColor}" d="m9.97 11.02 2.22-3.4h1.1l-2.27 3.44c.33-.16.69-.23 1.1-.23 1.84 0 2.76.9 2.76 2.81 0 2.06-1.04 2.91-2.86 2.91s-2.87-.85-2.87-2.91c0-1.08.3-1.8.83-2.61zm2.05 4.71c1.38 0 1.84-.68 1.84-2.05s-.47-2.01-1.84-2.01-1.85.64-1.85 2.01.46 2.05 1.85 2.05z"/>`,
	        `${svgCirclePath}<path fill="${fillColor}" d="m9.21 7.61h5.57v.74l-3.58 8.04h-1.05l3.54-7.84h-4.49v-.94z"/>`,
	        `${svgCirclePath}<path fill="${fillColor}" d="m10.47 11.94c-.65-.33-1.13-.92-1.13-2.01 0-1.53.85-2.47 2.66-2.47s2.66.94 2.66 2.47c0 1.08-.47 1.68-1.15 2.01.92.35 1.34 1.07 1.34 2.11 0 1.73-.99 2.49-2.86 2.49s-2.86-.76-2.86-2.49c0-1.04.41-1.76 1.33-2.11zm1.53 3.78c1.27 0 1.85-.51 1.85-1.69 0-1.1-.58-1.61-1.85-1.61s-1.85.52-1.85 1.61c0 1.18.58 1.69 1.85 1.69zm1.65-5.76c0-1.1-.56-1.56-1.65-1.56s-1.65.47-1.65 1.56c0 1 .46 1.6 1.65 1.6s1.65-.6 1.65-1.6z"/>`,
	        `${svgCirclePath}<path fill="${fillColor}" d="m9.16 10.33c0-2.03 1.02-2.86 2.83-2.86s2.82.81 2.82 2.85c0 1.11-.3 1.82-.81 2.64l-2.18 3.44h-1.1l2.18-3.37c-.31.14-.65.2-1.01.2-1.82 0-2.74-.99-2.74-2.9zm4.65 0c0-1.23-.47-1.92-1.81-1.92s-1.81.69-1.81 1.92c0 1.37.49 2.05 1.81 2.05s1.81-.68 1.81-2.05z"/>`,
	    ];
	    return svgNumberedCirclePaths[stepCount];
	};
	const getComponentCss = (state, disabled, theme) => {
	    const { primaryColor, hoverColor, disabledColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, hoverColor: hoverColorDark, disabledColor: disabledColorDark, } = validateProps.getThemedColors('dark');
	    const isStateCurrent = state === 'current';
	    const isStateCurrentOrUndefined = !state || isStateCurrent;
	    const isDisabled = !state || disabled;
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                ...(isStateCurrentOrUndefined &&
	                    Array.from(Array(9)).reduce((result, _, i) => ({
	                        ...result,
	                        [`&(:nth-of-type(${i + 1})) $button::before`]: {
	                            backgroundImage: escapeHashCharacter.getInlineSVGBackgroundImage(getSVGPath(i, {
	                                primaryColor,
	                                invertedBaseColor: validateProps.getInvertedThemedColors(theme).primaryColor,
	                                disabledColor,
	                            }, isStateCurrent)),
	                            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                                backgroundImage: escapeHashCharacter.getInlineSVGBackgroundImage(getSVGPath(i, {
	                                    primaryColor: primaryColorDark,
	                                    invertedBaseColor: validateProps.getInvertedThemedColors('dark').primaryColor,
	                                    disabledColor: disabledColorDark,
	                                }, isStateCurrent)),
	                            }),
	                        },
	                    }), {})),
	                ...validateProps.addImportantToEachRule({
	                    fontSize: 'inherit',
	                    ...colorSchemeStyles.hostHiddenStyles,
	                    '&(:not(:last-of-type))': {
	                        marginInlineEnd: spacingFluidXSmall.spacingFluidXSmall,
	                    },
	                }),
	            },
	            button: {
	                display: 'flex',
	                position: 'relative',
	                gap: '3px',
	                color: isDisabled ? disabledColor : primaryColor,
	                padding: '4px 10px 4px 6px',
	                margin: 0, // Removes default button margin on safari 15
	                background: 0,
	                border: 0,
	                ...textSmallStyle.textSmallStyle,
	                fontSize: 'inherit',
	                width: 'max-content',
	                cursor: isDisabled ? 'not-allowed' : 'pointer',
	                borderRadius: borderRadiusSmall.borderRadiusSmall,
	                ...(isStateCurrent && {
	                    ...validateProps.frostedGlassStyle,
	                    background: hoverColor,
	                }),
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: isDisabled ? disabledColorDark : primaryColorDark,
	                    ...(isStateCurrent && {
	                        background: hoverColorDark,
	                    }),
	                }),
	                ...(!isDisabled &&
	                    hoverMediaQuery.hoverMediaQuery({
	                        transition: validateProps.getTransition('background-color'),
	                        '&:hover': {
	                            ...validateProps.frostedGlassStyle,
	                            background: hoverColor,
	                            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                                background: hoverColorDark,
	                            }),
	                        },
	                    })),
	                ...(isStateCurrentOrUndefined && {
	                    // counter
	                    // Pseudo element is needed to center the counter to the text, as it is not working optimal directly on the button
	                    '&::before': {
	                        content: '""',
	                        height: fontLineHeight.fontLineHeight,
	                        width: fontLineHeight.fontLineHeight,
	                    },
	                }),
	                ...validateProps.getFocusJssStyle(theme, { offset: '-2px' }),
	            },
	        },
	        ...(!isStateCurrentOrUndefined && {
	            // complete / warning icons via icon component
	            icon: {
	                height: fontLineHeight.fontLineHeight,
	                width: fontLineHeight.fontLineHeight,
	            },
	        }),
	        'sr-only': validateProps.getHiddenTextJssStyle(),
	    });
	};

	const propTypes = {
	    state: validateProps.AllowedTypes.oneOf([undefined, ...STEPPER_ITEM_STATES]),
	    disabled: validateProps.AllowedTypes.boolean,
	};
	const StepperHorizontalItem = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.state = undefined;
	        this.disabled = false;
	    }
	    onClick(e) {
	        if (!isItemClickable(this.state, this.disabled)) {
	            e.stopPropagation();
	        }
	    }
	    onStateChange() {
	        throwIfChildrenAreNotOfKind.updateParent(this.host);
	    }
	    connectedCallback() {
	        throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-stepper-horizontal');
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        throwIfCurrentAndDisabled(this.host);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.state, this.disabled, this.host.theme || 'light');
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(validateProps.Host, { key: '15c426f897eb924bf6f18d6ec19333d3ba24d610', role: "listitem" }, validateProps.h("button", { key: '3fac76614592cb9cb57840d0af7e7381c1b73c53', type: "button", "aria-disabled": !this.state || this.disabled ? 'true' : null, "aria-current": this.state === 'current' ? 'step' : null }, isStateCompleteOrWarning(this.state) && (validateProps.h(PrefixedTagNames.pIcon, { class: "icon", name: getStepperHorizontalIconName(this.state), size: "inherit", theme: this.host.theme || 'light', color: this.disabled ? 'state-disabled' : `notification-${getStepperHorizontalIconName(this.state)}`, "aria-hidden": "true" })), this.state && validateProps.h("span", { class: "sr-only" }, this.state, ": "), validateProps.h("slot", { key: '896e25c1ba217464b102ec68b2649e039e8e4775' }))));
	    }
	    static get delegatesFocus() { return true; }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "state": ["onStateChange"]
	    }; }
	};

	pStepperHorizontal_2_cjs_entry.p_stepper_horizontal = StepperHorizontal;
	pStepperHorizontal_2_cjs_entry.p_stepper_horizontal_item = StepperHorizontalItem;

	
	return pStepperHorizontal_2_cjs_entry;
}

var pSwitch_cjs_entry = {};

var hasRequiredPSwitch_cjs_entry;

function requirePSwitch_cjs_entry () {
	if (hasRequiredPSwitch_cjs_entry) return pSwitch_cjs_entry;
	hasRequiredPSwitch_cjs_entry = 1;

	Object.defineProperty(pSwitch_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const isDisabledOrLoading = requireIsDisabledOrLoadingB1f56d7f();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed2d6d1d94();
	const theme = requireThemeBfc10573();
	const alignLabel = requireAlignLabel7a9d9074();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const initialLoadingController = requireInitialLoadingController44585a09();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const getButtonBaseAriaAttributes = requireGetButtonBaseAriaAttributes2b382c95();
	requireHelperA66adcf2();
	requireTextShared9135e2ef();
	requireFontLineHeight78b03658();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();

	const getColors = (checked, disabled, loading, theme) => {
	    const { primaryColor, contrastMediumColor, successColor, successColorDarken, disabledColor } = validateProps.getThemedColors(theme);
	    const { backgroundColor: lightThemeBackgroundColor } = validateProps.getThemedColors('light');
	    const { canvasColor, canvasTextColor } = validateProps.getHighContrastColors();
	    const checkedColor = validateProps.isHighContrastMode ? canvasTextColor : successColor;
	    const disabledOrLoadingColor = isDisabledOrLoading.isDisabledOrLoading(disabled, loading) && disabledColor;
	    return {
	        buttonBorderColor: disabledOrLoadingColor || (checked ? checkedColor : contrastMediumColor),
	        buttonBorderColorHover: checked ? (validateProps.isHighContrastMode ? primaryColor : successColorDarken) : primaryColor,
	        buttonBackgroundColor: checked ? disabledOrLoadingColor || checkedColor : 'transparent',
	        buttonBackgroundColorHover: checked ? (validateProps.isHighContrastMode ? checkedColor : successColorDarken) : 'transparent',
	        toggleBackgroundColor: (loading && 'transparent') ||
	            (disabled && !checked && disabledColor) ||
	            (checked
	                ? validateProps.isHighContrastMode
	                    ? canvasColor
	                    : lightThemeBackgroundColor
	                : validateProps.isHighContrastMode
	                    ? canvasTextColor
	                    : primaryColor),
	        toggleBackgroundColorHover: checked
	            ? lightThemeBackgroundColor
	            : validateProps.isHighContrastMode
	                ? canvasTextColor
	                : primaryColor,
	        textColor: disabledOrLoadingColor || primaryColor,
	    };
	};
	const getComponentCss = (alignLabel, hideLabel, stretch, checked, disabled, loading, theme) => {
	    const { buttonBorderColor, buttonBorderColorHover, buttonBackgroundColor, buttonBackgroundColorHover, toggleBackgroundColor, toggleBackgroundColorHover, textColor, } = getColors(checked, disabled, loading, theme);
	    const { buttonBorderColor: buttonBorderColorDark, buttonBorderColorHover: buttonBorderColorHoverDark, buttonBackgroundColor: buttonBackgroundColorDark, buttonBackgroundColorHover: buttonBackgroundColorHoverDark, toggleBackgroundColor: toggleBackgroundColorDark, toggleBackgroundColorHover: toggleBackgroundColorHoverDark, textColor: textColorDark, } = getColors(checked, disabled, loading, 'dark');
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                ...validateProps.buildResponsiveStyles(stretch, (stretchValue) => ({
	                    display: stretchValue ? 'flex' : 'inline-flex',
	                })),
	                ...validateProps.addImportantToEachRule({
	                    outline: 0, // custom element is able to delegate the focus
	                    gap: spacingStaticSmall.spacingStaticSmall,
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                    ...validateProps.buildResponsiveStyles(stretch, (stretchValue) => ({
	                        justifyContent: stretchValue ? 'space-between' : 'flex-start',
	                        width: stretchValue ? '100%' : 'auto', // prevents adjusting its size when used as flex or grid child
	                        ...(!stretchValue && { verticalAlign: 'top' }),
	                    })),
	                }),
	            },
	            button: {
	                display: 'flex',
	                alignItems: 'center',
	                flexShrink: 0,
	                width: '48px',
	                height: '28px',
	                boxSizing: 'border-box',
	                border: `${validateProps.borderWidthBase} solid ${buttonBorderColor}`,
	                borderRadius: '14px',
	                backgroundColor: buttonBackgroundColor,
	                cursor: isDisabledOrLoading.isDisabledOrLoading(disabled, loading) ? 'not-allowed' : 'pointer',
	                transition: `${validateProps.getTransition('background-color')}, ${validateProps.getTransition('border-color')}, ${validateProps.getTransition('color')}`,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    borderColor: buttonBorderColorDark,
	                    backgroundColor: buttonBackgroundColorDark,
	                }),
	                margin: 0, // Removes default button margin on safari 15
	                padding: 0,
	                WebkitAppearance: 'none', // iOS safari
	                appearance: 'none',
	                ...(!isDisabledOrLoading.isDisabledOrLoading(disabled, loading) &&
	                    hoverMediaQuery.hoverMediaQuery({
	                        '&:hover': {
	                            borderColor: buttonBorderColorHover,
	                            backgroundColor: buttonBackgroundColorHover,
	                            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                                borderColor: buttonBorderColorHoverDark,
	                                backgroundColor: buttonBackgroundColorHoverDark,
	                            }),
	                            '& .toggle': {
	                                backgroundColor: toggleBackgroundColorHover,
	                                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                                    backgroundColor: toggleBackgroundColorHoverDark,
	                                }),
	                            },
	                        },
	                    })),
	                ...validateProps.getFocusJssStyle(theme),
	            },
	            label: {
	                ...textSmallStyle.textSmallStyle,
	                minWidth: 0, // prevents flex child to overflow max available parent size
	                minHeight: 0, // prevents flex child to overflow max available parent size
	                cursor: isDisabledOrLoading.isDisabledOrLoading(disabled, loading) ? 'not-allowed' : 'pointer',
	                color: textColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: textColorDark,
	                }),
	                ...validateProps.mergeDeep(validateProps.buildResponsiveStyles(alignLabel, (alignLabelValue) => ({
	                    // TODO: we should remove 'left' here and map the value in the component class already to 'start' but might be difficult due to breakpoint customizable prop value
	                    order: alignLabelValue === 'left' || alignLabelValue === 'start' ? -1 : 0,
	                })), validateProps.buildResponsiveStyles(hideLabel, (isHidden) => validateProps.getHiddenTextJssStyle(isHidden, {
	                    paddingTop: '2px', // currently, line-height of textSmall doesn't match height of switch
	                }))),
	            },
	        },
	        toggle: {
	            display: 'flex',
	            alignItems: 'center',
	            justifyContent: 'center',
	            width: '20px',
	            height: '20px',
	            borderRadius: '50%',
	            backgroundColor: toggleBackgroundColor,
	            transition: `${validateProps.getTransition('background-color')}, ${validateProps.getTransition('transform')}`,
	            transform: `translate3d(${checked ? '22px' : '2px'}, 0, 0)`,
	            '&:dir(rtl)': {
	                transform: `translate3d(${checked ? '-22px' : '-2px'}, 0, 0)`,
	            },
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                backgroundColor: toggleBackgroundColorDark,
	            }),
	        },
	        ...(loading && {
	            spinner: {
	                width: '28px',
	                height: '28px',
	            },
	        }),
	        // .loading
	        ...initialLoadingController.getFunctionalComponentLoadingMessageStyles(),
	    });
	};

	const getSwitchButtonAriaAttributes = (isDisabled, isLoading, isChecked) => {
	    return {
	        ...getButtonBaseAriaAttributes.getButtonBaseAriaAttributes(isDisabled, isLoading),
	        'aria-checked': isChecked ? 'true' : 'false',
	    };
	};

	const propTypes = {
	    alignLabel: validateProps.AllowedTypes.breakpoint(alignLabel.ALIGN_LABELS),
	    hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	    stretch: validateProps.AllowedTypes.breakpoint('boolean'),
	    checked: validateProps.AllowedTypes.boolean,
	    disabled: validateProps.AllowedTypes.boolean,
	    loading: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Switch = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.switchChange = validateProps.createEvent(this, "switchChange", 3);
	        this.update = validateProps.createEvent(this, "update", 3);
	        this.controllerHost = new initialLoadingController.ControllerHost(this);
	        this.loadingCtrl = new initialLoadingController.InitialLoadingController(this.controllerHost);
	        this.onSwitchClick = () => {
	            this.update.emit({ checked: !this.checked });
	            this.switchChange.emit({ checked: !this.checked });
	        };
	        this.alignLabel = 'end';
	        this.hideLabel = false;
	        this.stretch = false;
	        this.checked = false;
	        this.disabled = false;
	        this.loading = false;
	        this.theme = 'light';
	    }
	    onClick(e) {
	        if (isDisabledOrLoading.isDisabledOrLoading(this.disabled, this.loading)) {
	            e.stopPropagation();
	        }
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        const alignLabelDeprecationMap = {
	            left: 'start',
	            right: 'end',
	        };
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'alignLabel', alignLabelDeprecationMap);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.alignLabel, this.hideLabel, this.stretch, this.checked, this.disabled, this.loading, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(validateProps.Host, { key: 'b819912a5280748e085400ae18a12095175a99c0' }, validateProps.h("button", { key: 'd2b717f7f92f58ff84a8f243c7bb812bb9686e67', ...getSwitchButtonAriaAttributes(this.disabled, this.loading, this.checked), id: "switch", type: "button", role: "switch", "aria-labelledby": "label" // only relevant for axe-core because of https://github.com/dequelabs/axe-core/issues/1393
	            ,
	            "aria-describedby": this.loading ? initialLoadingController.loadingId : undefined, onClick: this.onSwitchClick }, validateProps.h("span", { key: 'a57ed6f1d431cba92fecf66b0537d8203ee79c10', class: "toggle" }, this.loading && (validateProps.h(PrefixedTagNames.pSpinner, { class: "spinner", size: "inherit", theme: this.theme, "aria-hidden": "true" })))), validateProps.h("label", { key: '0cea4f8855851a6395ff0edb3748134dc8b9b53c', id: "label", htmlFor: "switch" }, validateProps.h("slot", { key: '7a1b2daa39f77ff4e1cf5a463e56180fce4f8cc1' })), validateProps.h(initialLoadingController.LoadingMessage, { key: '201174a4ae7df8450448a89ee2070e9405dfccfa', loading: this.loading, initialLoading: this.loadingCtrl.initialLoading })));
	    }
	    static get delegatesFocus() { return true; }
	    get host() { return validateProps.getElement(this); }
	};

	pSwitch_cjs_entry.p_switch = Switch;

	
	return pSwitch_cjs_entry;
}

var pTable_7_cjs_entry = {};

var hasRequiredPTable_7_cjs_entry;

function requirePTable_7_cjs_entry () {
	if (hasRequiredPTable_7_cjs_entry) return pTable_7_cjs_entry;
	hasRequiredPTable_7_cjs_entry = 1;

	Object.defineProperty(pTable_7_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const hasNamedSlot = requireHasNamedSlotA96fd22a();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const schemedHighContrastMediaQuery = requireSchemedHighContrastMediaQuery462417a0();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const spacingFluidMedium = requireSpacingFluidMedium88ab712b();
	const throwIfParentIsNotOfKind = requireThrowIfParentIsNotOfKindEb817ad3();
	const spacingFluidSmall = requireSpacingFluidSmall2c6caae7();
	const fontSizeTextXSmall = requireFontSizeTextXSmallE59d35d7();
	const fontLineHeight = requireFontLineHeight78b03658();
	const fontWeightSemiBold = requireFontWeightSemiBold4482c830();
	const getAttribute = requireGetAttribute9c66ed26();
	const hasAttribute = requireHasAttributeBf22c03a();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	requireGetNamedSlotA0cdbdbc();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireIsParentOfKindB7d9f81c();

	const throwIfElementHasAttribute = (el, name) => {
	    if (hasAttribute.hasAttribute(el, name)) {
	        validateProps.throwException(`attribute ${name}='${getAttribute.getAttribute(el, name)}' needs to be set as property.`);
	    }
	};

	const cssVariableTableHoverColor = '--p-internal-table-hover-color';
	const cssVariableTableBorderColor = '--p-internal-table-border-color';
	const cssVariableTableHeadCellIconFilter = '--p-internal-table-head-cell-icon-filter';
	const getComponentCss$6 = (theme) => {
	    const { primaryColor, hoverColor, contrastLowColor } = validateProps.doGetThemedColors(theme);
	    const { primaryColor: primaryColorDark, hoverColor: hoverColorDark, contrastLowColor: contrastLowColorDark, } = validateProps.doGetThemedColors('dark');
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...textSmallStyle.textSmallStyle,
	                    color: primaryColor,
	                    textAlign: 'start',
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        color: primaryColorDark,
	                    }),
	                }),
	            },
	            '::slotted(*)': validateProps.addImportantToEachRule({
	                [cssVariableTableHoverColor]: hoverColor,
	                [cssVariableTableBorderColor]: contrastLowColor,
	                [cssVariableTableHeadCellIconFilter]: validateProps.isThemeDark(theme) ? 'invert(100%)' : 'none',
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    [cssVariableTableHoverColor]: hoverColorDark,
	                    [cssVariableTableBorderColor]: contrastLowColorDark,
	                    [cssVariableTableHeadCellIconFilter]: 'invert(100%)',
	                }),
	                ...(validateProps.isHighContrastMode &&
	                    schemedHighContrastMediaQuery.getSchemedHighContrastMediaQuery({
	                        [cssVariableTableHeadCellIconFilter]: 'none',
	                    }, {
	                        [cssVariableTableHeadCellIconFilter]: 'invert(100%)',
	                    })),
	            }),
	        },
	        caption: {
	            marginBottom: spacingFluidMedium.spacingFluidMedium,
	        },
	        table: {
	            display: 'table',
	            borderCollapse: 'collapse',
	            width: '100%',
	            whiteSpace: 'nowrap', // shouldn't be inherited for caption, that's why it's defined here
	        },
	    });
	};

	const warnIfCaptionIsMissing = (host, caption) => {
	    if (!caption && !hasNamedSlot.hasNamedSlot(host, 'caption')) {
	        validateProps.consoleWarn(`caption has to be set via property or named slot for component ${validateProps.getTagNameWithoutPrefix(host)} in order to ensure accessibility.`);
	    }
	};
	const SORT_EVENT_NAME = 'internalSortingChange';

	const propTypes$2 = {
	    caption: validateProps.AllowedTypes.string,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Table = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.sortingChange = validateProps.createEvent(this, "sortingChange", 3);
	        this.update = validateProps.createEvent(this, "update", 3);
	        this.caption = undefined;
	        this.theme = 'light';
	    }
	    componentWillLoad() {
	        warnIfCaptionIsMissing(this.host, this.caption);
	        this.host.shadowRoot.addEventListener(SORT_EVENT_NAME, (e) => {
	            e.stopPropagation();
	            this.update.emit(e.detail);
	            this.sortingChange.emit(e.detail);
	        });
	    }
	    render() {
	        validateProps.validateProps(this, propTypes$2);
	        validateProps.attachComponentCss(this.host, getComponentCss$6, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        const hasSlottedCaption = hasNamedSlot.hasNamedSlot(this.host, 'caption');
	        const captionId = 'caption';
	        const tableAttr = this.caption
	            ? { 'aria-label': this.caption }
	            : hasSlottedCaption && { 'aria-labelledby': captionId };
	        return (validateProps.h(validateProps.Host, { key: '9a7493fec24e58e8fffe8650d75c51697d0d1c8c' }, hasSlottedCaption && (validateProps.h("div", { id: captionId, class: "caption" }, validateProps.h("slot", { name: "caption" }))), validateProps.h(PrefixedTagNames.pScroller, { key: 'a43ae61d784f2e5d399450f4ef0fa07c40118834', scrollbar: true, theme: this.theme }, validateProps.h("div", { key: '70696c2401d6ccde1e38795da6141d4133bf5772', class: "table", role: "table", ...tableAttr }, validateProps.h("slot", { key: '04315cc6daa6dbf5c4d234f7e5cdb631e735c727' })))));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	const getComponentCss$5 = () => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'table-row-group',
	                ...validateProps.addImportantToEachRule(colorSchemeStyles.hostHiddenStyles),
	            },
	        },
	    });
	};

	const TableBody = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	    }
	    connectedCallback() {
	        throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-table');
	    }
	    render() {
	        validateProps.attachComponentCss(this.host, getComponentCss$5);
	        return (validateProps.h(validateProps.Host, { key: '1770f89491b59dcb8c38f3f9e8f8577a92f085a8', role: "rowgroup" }, validateProps.h("slot", { key: '1c573ef7582b91863fd1894e6313ae5e562de6d2' })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	const getComponentCss$4 = (multiline) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'table-cell',
	                verticalAlign: 'middle',
	                ...validateProps.addImportantToEachRule({
	                    padding: spacingFluidSmall.spacingFluidSmall,
	                    margin: 0,
	                    whiteSpace: multiline ? 'normal' : 'nowrap',
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	        },
	    });
	};

	const propTypes$1 = {
	    multiline: validateProps.AllowedTypes.boolean,
	};
	const TableCell = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.multiline = false;
	    }
	    connectedCallback() {
	        throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-table-row');
	    }
	    render() {
	        validateProps.validateProps(this, propTypes$1);
	        validateProps.attachComponentCss(this.host, getComponentCss$4, this.multiline);
	        return (validateProps.h(validateProps.Host, { key: 'f0b31f8bdd3749419cb11d776191169b1f692b7c', role: "cell" }, validateProps.h("slot", { key: 'fcd997fc16ac81eb5189fc0b41a9604b2411fe7f' })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	const getComponentCss$3 = () => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'table-header-group',
	                ...validateProps.addImportantToEachRule({
	                    fontSize: fontSizeTextXSmall.fontSizeTextXSmall,
	                    lineHeight: fontLineHeight.fontLineHeight,
	                    fontWeight: fontWeightSemiBold.fontWeightSemiBold,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	        },
	    });
	};

	const TableHead = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	    }
	    connectedCallback() {
	        throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-table');
	    }
	    render() {
	        validateProps.attachComponentCss(this.host, getComponentCss$3);
	        return (validateProps.h(validateProps.Host, { key: '913b2756e3bf41e22e3fe3be5310caec06f5a215', role: "rowgroup" }, validateProps.h("slot", { key: '33917327bab0f9df338c64b426555c3f17eaa027' })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	const isDirectionAsc = (dir) => dir === 'asc';
	const getAriaSort = (sort) => {
	    return sort?.active ? (isDirectionAsc(sort.direction) ? 'ascending' : 'descending') : null;
	};
	const toggleDirection = (dir) => (isDirectionAsc(dir) ? 'desc' : 'asc');
	const createSortedEventInitDictDetail = (sort) => ({
	    bubbles: true,
	    detail: { ...sort, active: true, direction: sort.active ? toggleDirection(sort.direction) : sort.direction },
	});
	const isSortable = (active, direction) => {
	    return active !== undefined && direction !== undefined;
	};

	const { hoverColor } = validateProps.getThemedColors('light'); // hover color and focus color are the same for light and dark
	const buttonBeforeOffsetVertical = '-2px';
	const buttonBeforeOffsetHorizontal = '-4px';
	const getComponentCss$2 = (active, direction, hideLabel, multiline) => {
	    const sortable = isSortable(active, direction);
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'table-cell',
	                ...validateProps.addImportantToEachRule({
	                    padding: `2px ${spacingFluidSmall.spacingFluidSmall} ${spacingFluidSmall.spacingFluidSmall}`,
	                    verticalAlign: 'bottom',
	                    whiteSpace: multiline ? 'normal' : 'nowrap',
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...(sortable
	                ? {
	                    button: {
	                        position: 'relative',
	                        display: 'flex',
	                        gap: spacingStaticXSmall.spacingStaticXSmall,
	                        width: 'auto',
	                        margin: 0, // Removes default button margin on safari 15
	                        padding: 0,
	                        font: 'inherit',
	                        color: 'inherit',
	                        alignItems: 'flex-end',
	                        WebkitAppearance: 'none', // iOS safari
	                        appearance: 'none',
	                        background: 'transparent',
	                        textAlign: 'start',
	                        border: 0,
	                        zIndex: 0,
	                        cursor: 'pointer',
	                        // TODO: re-think if ::before is still needed
	                        '&::before': {
	                            content: '""',
	                            position: 'absolute',
	                            inset: `${buttonBeforeOffsetVertical} ${buttonBeforeOffsetHorizontal}`,
	                            borderRadius: borderRadiusSmall.borderRadiusSmall,
	                            zIndex: -1, // needed so that text behind element is selectable and/or visible
	                            transition: validateProps.getTransition('background-color'),
	                        },
	                        ...hoverMediaQuery.hoverMediaQuery({
	                            '&:hover, &:focus-visible': {
	                                '& .icon': {
	                                    opacity: 1,
	                                },
	                            },
	                            '&:hover::before': {
	                                ...validateProps.frostedGlassStyle,
	                                backgroundColor: hoverColor,
	                            },
	                        }),
	                        // TODO: to be future proof, we need to pass theme parameter
	                        ...validateProps.getFocusJssStyle('light', { pseudo: true, offset: '-2px' }),
	                    },
	                }
	                : hideLabel && {
	                    span: {
	                        ...validateProps.getHiddenTextJssStyle(),
	                        display: 'block',
	                        border: 0,
	                    },
	                }),
	        },
	        ...(sortable && {
	            icon: {
	                transition: validateProps.getTransition('opacity'),
	                opacity: active ? 1 : 0,
	                transform: `rotate3d(0,0,1,${isDirectionAsc(direction) ? 0 : 180}deg)`,
	                transformOrigin: '50% 50%', // for iOS
	                filter: `var(${cssVariableTableHeadCellIconFilter})`,
	            },
	        }),
	    });
	};

	const propTypes = {
	    sort: validateProps.AllowedTypes.shape({
	        id: validateProps.AllowedTypes.string,
	        active: validateProps.AllowedTypes.boolean,
	        direction: validateProps.AllowedTypes.oneOf([undefined, 'asc', 'desc']),
	    }),
	    hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	    multiline: validateProps.AllowedTypes.boolean,
	};
	const TableHeadCell = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.onButtonClick = () => {
	            this.host.dispatchEvent(new CustomEvent(SORT_EVENT_NAME, createSortedEventInitDictDetail(this.sort)));
	        };
	        this.sort = undefined;
	        this.hideLabel = false;
	        this.multiline = false;
	    }
	    connectedCallback() {
	        throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-table-head-row');
	        throwIfElementHasAttribute(this.host, 'sort');
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        const { active, direction } = this.sort || {};
	        validateProps.attachComponentCss(this.host, getComponentCss$2, active, direction, this.hideLabel, this.multiline);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(validateProps.Host, { key: '14c1502e11a4912fe37087d8779543a073583070', scope: "col", role: "columnheader", "aria-sort": getAriaSort(this.sort) }, isSortable(active, direction) ? (validateProps.h("button", { type: "button", onClick: this.onButtonClick }, validateProps.h("slot", null), validateProps.h(PrefixedTagNames.pIcon, { class: "icon", color: "inherit", size: "x-small", name: "arrow-up", "aria-hidden": "true" }))) : (validateProps.h("span", null, validateProps.h("slot", null)))));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	const getComponentCss$1 = () => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'table-row',
	                ...validateProps.addImportantToEachRule(colorSchemeStyles.hostHiddenStyles),
	            },
	        },
	    });
	};

	const TableHeadRow = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	    }
	    connectedCallback() {
	        throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-table-head');
	    }
	    render() {
	        validateProps.attachComponentCss(this.host, getComponentCss$1);
	        return (validateProps.h(validateProps.Host, { key: 'd47a159b59c0356148caf5079f43f11c701ca0ae', role: "row" }, validateProps.h("slot", { key: '44673c0675aed5247f6a9ccc2a4a355fcb720088' })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	const getComponentCss = () => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'table-row',
	                ...validateProps.addImportantToEachRule({
	                    borderTop: `1px solid var(${cssVariableTableBorderColor})`,
	                    borderBottom: `1px solid var(${cssVariableTableBorderColor})`,
	                    transition: validateProps.getTransition('background'),
	                    ...colorSchemeStyles.hostHiddenStyles,
	                    ...hoverMediaQuery.hoverMediaQuery({
	                        '&(:hover)': {
	                            // ...frostedGlassStyle, // will result in not smooth transition when applied
	                            background: `var(${cssVariableTableHoverColor})`,
	                        },
	                    }),
	                }),
	            },
	        },
	    });
	};

	const TableRow = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	    }
	    connectedCallback() {
	        throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-table-body');
	    }
	    render() {
	        validateProps.attachComponentCss(this.host, getComponentCss);
	        return (validateProps.h(validateProps.Host, { key: '7ca360e05927719e4ffd6376115a48c1bc7591ab', role: "row" }, validateProps.h("slot", { key: '77a26b8bae553385479a9b60a3d639e369e3478f' })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pTable_7_cjs_entry.p_table = Table;
	pTable_7_cjs_entry.p_table_body = TableBody;
	pTable_7_cjs_entry.p_table_cell = TableCell;
	pTable_7_cjs_entry.p_table_head = TableHead;
	pTable_7_cjs_entry.p_table_head_cell = TableHeadCell;
	pTable_7_cjs_entry.p_table_head_row = TableHeadRow;
	pTable_7_cjs_entry.p_table_row = TableRow;

	
	return pTable_7_cjs_entry;
}

var pTabs_2_cjs_entry = {};

var tabsBarUtils981cace8 = {};

var hasRequiredTabsBarUtils981cace8;

function requireTabsBarUtils981cace8 () {
	if (hasRequiredTabsBarUtils981cace8) return tabsBarUtils981cace8;
	hasRequiredTabsBarUtils981cace8 = 1;

	const validateProps = requireValidatePropsF6586828();
	const getAttribute = requireGetAttribute9c66ed26();

	const TABS_BAR_SIZES = ['small', 'medium'];
	/** @deprecated */
	const TABS_BAR_WEIGHTS_DEPRECATED = ['semibold'];
	const TABS_BAR_WEIGHTS = ['regular', 'semi-bold', ...TABS_BAR_WEIGHTS_DEPRECATED];
	const sanitizeActiveTabIndex = (index, tabElementsCount) => {
	    const maxIndex = tabElementsCount - 1; // can be -1 without children
	    if (index === undefined || index === null || maxIndex < 0 || index < 0 || index > maxIndex) {
	        return undefined;
	    }
	    else {
	        return index;
	    }
	};
	const getTransformation = (el = {}) => {
	    const rect = el.getBoundingClientRect();
	    return `transform: translate3d(${el.offsetLeft > 0 ? el.offsetLeft : 0}px,0,0);width: ${rect.width}px`;
	};
	const getPrevNextTabIndex = (direction, tabElementsLength, focusedTabIndex) => {
	    const newTabIndex = focusedTabIndex + (direction === 'next' ? 1 : -1);
	    return (newTabIndex + tabElementsLength) % tabElementsLength;
	};
	const getFocusedTabIndex = (tabElements) => {
	    const indexOfActiveElement = tabElements.indexOf(document.activeElement);
	    return indexOfActiveElement < 0 ? 0 : indexOfActiveElement;
	};
	const setBarStyle = (tabElements, activeTabIndex, barElement) => {
	    // in frameworks, when chunk is already loaded, the watcher for activeTabIndex can trigger
	    // before the component is rendered, therefore barElement is not defined, yet
	    if (barElement) {
	        // el.ariaSelected isn't supported in firefox, therefore we need to read the attribute
	        // https://caniuse.com/mdn-api_element_ariaselected
	        const currentActiveTabElement = tabElements.find((el) => getAttribute.getAttribute(el, 'aria-selected') === 'true' || getAttribute.getAttribute(el, 'aria-current') === 'true');
	        if (currentActiveTabElement) {
	            // for initial activeTabIndex > 0 and resized window with fluid font-size for size="medium"
	            // we need to adjust the starting point of the transition
	            validateProps.setAttribute(barElement, 'style', 'transition: none;' + getTransformation(currentActiveTabElement));
	        }
	        const newActiveTabElement = tabElements[activeTabIndex];
	        if (newActiveTabElement) {
	            validateProps.setAttribute(barElement, 'style', getTransformation(newActiveTabElement));
	        }
	        // when there was an active item before, we need to reset the animation
	        if (currentActiveTabElement) {
	            // reset animation that hides the bar after the transition
	            barElement.style.animation = 'none';
	            window.requestAnimationFrame(() => (barElement.style.animation = ''));
	        }
	    }
	};

	tabsBarUtils981cace8.TABS_BAR_SIZES = TABS_BAR_SIZES;
	tabsBarUtils981cace8.TABS_BAR_WEIGHTS = TABS_BAR_WEIGHTS;
	tabsBarUtils981cace8.getFocusedTabIndex = getFocusedTabIndex;
	tabsBarUtils981cace8.getPrevNextTabIndex = getPrevNextTabIndex;
	tabsBarUtils981cace8.sanitizeActiveTabIndex = sanitizeActiveTabIndex;
	tabsBarUtils981cace8.setBarStyle = setBarStyle;

	
	return tabsBarUtils981cace8;
}

var hasRequiredPTabs_2_cjs_entry;

function requirePTabs_2_cjs_entry () {
	if (hasRequiredPTabs_2_cjs_entry) return pTabs_2_cjs_entry;
	hasRequiredPTabs_2_cjs_entry = 1;

	Object.defineProperty(pTabs_2_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const setAttributes = requireSetAttributes642a7e67();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed0dc3288b();
	const scrolling = requireScrolling7e2aff99();
	const theme = requireThemeBfc10573();
	const throwIfChildrenAreNotOfKind = requireThrowIfChildrenAreNotOfKind81b825bd();
	const tabsBarUtils = requireTabsBarUtils981cace8();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const throwIfParentIsNotOfKind = requireThrowIfParentIsNotOfKindEb817ad3();
	requireHelperA66adcf2();
	requireScrollerPopoverUtils89485ebc();
	requireGetHTMLElements3f1c700f();
	requireGetAttribute9c66ed26();
	requireIsParentOfKindB7d9f81c();

	const getComponentCss$1 = () => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	        },
	        root: {
	            marginBottom: '8px',
	        },
	    });
	};

	const syncTabsItemsProps = (items, theme) => {
	    items.forEach((item) => {
	        item.theme = theme;
	        validateProps.forceUpdate(item);
	    });
	};

	const propTypes$1 = {
	    size: validateProps.AllowedTypes.breakpoint(tabsBarUtils.TABS_BAR_SIZES),
	    weight: validateProps.AllowedTypes.oneOf(tabsBarUtils.TABS_BAR_WEIGHTS),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    gradientColorScheme: validateProps.AllowedTypes.oneOf([undefined, ...scrolling.GRADIENT_COLOR_SCHEMES]),
	    gradientColor: validateProps.AllowedTypes.oneOf(scrolling.GRADIENT_COLORS),
	    activeTabIndex: validateProps.AllowedTypes.number,
	};
	const Tabs = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.tabChange = validateProps.createEvent(this, "tabChange", 3);
	        this.update = validateProps.createEvent(this, "update", 3);
	        this.defineTabsItemElements = () => {
	            throwIfChildrenAreNotOfKind.throwIfChildrenAreNotOfKind(this.host, 'p-tabs-item');
	            this.tabsItemElements = Array.from(this.host.children);
	        };
	        this.setAccessibilityAttributes = () => {
	            this.tabsItemElements.forEach((tab, index) => {
	                const attrs = {
	                    role: 'tabpanel',
	                    'aria-label': tab.label,
	                };
	                setAttributes.setAttributes(tab, attrs);
	                if (index === this.activeTabIndex) {
	                    validateProps.removeAttribute(tab, 'hidden');
	                    validateProps.setAttribute(tab, 'tabindex', '0');
	                }
	                else {
	                    validateProps.setAttribute(tab, 'hidden');
	                    validateProps.removeAttribute(tab, 'tabindex');
	                }
	            });
	        };
	        this.onTabsBarUpdate = (e) => {
	            e.stopPropagation(); // prevent double event emission because of identical name
	            this.activeTabIndex = e.detail.activeTabIndex;
	        };
	        this.size = 'small';
	        this.weight = 'regular';
	        this.theme = 'light';
	        this.gradientColorScheme = undefined;
	        this.gradientColor = 'background-base';
	        this.activeTabIndex = 0;
	        this.tabsItemElements = [];
	    }
	    activeTabHandler(newValue) {
	        this.setAccessibilityAttributes();
	        this.update.emit({ activeTabIndex: newValue });
	        this.tabChange.emit({ activeTabIndex: newValue });
	    }
	    componentWillLoad() {
	        this.defineTabsItemElements();
	    }
	    componentDidLoad() {
	        validateProps.getShadowRootHTMLElement(this.host, 'slot').addEventListener('slotchange', this.defineTabsItemElements);
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    componentDidRender() {
	        this.setAccessibilityAttributes();
	    }
	    render() {
	        validateProps.validateProps(this, propTypes$1);
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'gradientColorScheme', 'Please use gradientColor prop instead.');
	        validateProps.attachComponentCss(this.host, getComponentCss$1);
	        syncTabsItemsProps(this.tabsItemElements, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(validateProps.Host, { key: '2f8c7e28ffe8b1b478d734da7f3aa9caa198c363' }, validateProps.h(PrefixedTagNames.pTabsBar, { key: '4e68e3ce4e389f2b7204552ade2b257af653e2fb', class: "root", size: this.size, weight: this.weight, theme: this.theme, gradientColorScheme: this.gradientColorScheme, gradientColor: this.gradientColor, activeTabIndex: this.activeTabIndex, onUpdate: this.onTabsBarUpdate, onTabChange: (e) => e.stopPropagation() }, this.tabsItemElements.map((tab, index) => (validateProps.h("button", { key: index, type: "button" }, tab.label)))), validateProps.h("slot", { key: '86028e4f0c99c4f390abf7cb3d2858008a054ed0' })));
	    }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "activeTabIndex": ["activeTabHandler"]
	    }; }
	};

	const getComponentCss = (theme) => {
	    const { primaryColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark } = validateProps.getThemedColors('dark');
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    color: primaryColor, // enables color inheritance for e.g. slotted anchor
	                    borderRadius: '2px',
	                    ...colorSchemeStyles.hostHiddenStyles,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        color: primaryColorDark,
	                    }),
	                    ...validateProps.getFocusJssStyle(theme, { slotted: true }),
	                }),
	            },
	        },
	    });
	};

	const propTypes = {
	    label: validateProps.AllowedTypes.string,
	};
	const TabsItem = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.label = undefined;
	    }
	    handleLabelChange() {
	        throwIfChildrenAreNotOfKind.updateParent(this.host);
	    }
	    connectedCallback() {
	        throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-tabs');
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.host.theme || 'light' // default as fallback
	        );
	        return validateProps.h("slot", { key: 'a08e53f71b982a45d13289618c2d054b52009520' });
	    }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "label": ["handleLabelChange"]
	    }; }
	};

	pTabs_2_cjs_entry.p_tabs = Tabs;
	pTabs_2_cjs_entry.p_tabs_item = TabsItem;

	
	return pTabs_2_cjs_entry;
}

var pTabsBar_cjs_entry = {};

var hasRequiredPTabsBar_cjs_entry;

function requirePTabsBar_cjs_entry () {
	if (hasRequiredPTabsBar_cjs_entry) return pTabsBar_cjs_entry;
	hasRequiredPTabsBar_cjs_entry = 1;

	Object.defineProperty(pTabsBar_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const setAttributes = requireSetAttributes642a7e67();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed2d6d1d94();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed0dc3288b();
	const scrolling = requireScrolling7e2aff99();
	const theme = requireThemeBfc10573();
	const getDirectChildHTMLElements = requireGetDirectChildHTMLElements31d23fa9();
	const tabsBarUtils = requireTabsBarUtils981cace8();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const fontWeightStyles = requireFontWeightStylesB74e8683();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const fontSizeText = requireFontSizeText728b6387();
	requireHelperA66adcf2();
	requireScrollerPopoverUtils89485ebc();
	requireGetHTMLElements3f1c700f();
	requireTransformSelectorToDirectChildSelectorC1b1f9b0();
	requireGetAttribute9c66ed26();
	requireFontWeightRegularD0c768ac();
	requireFontWeightSemiBold4482c830();
	requireTextShared9135e2ef();
	requireFontLineHeight78b03658();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireFontSizeTextXXSmallA02f9c40();
	requireFontSizeTextXSmallE59d35d7();
	requireFontSizeTextMedium88887ad8();
	requireFontSizeTextLarge05a4bc90();
	requireFontSizeTextXLarge0ecf9ef3();

	const isShadowRootParentOfKind = (element, tagName) => {
	    const parentElement = element.getRootNode().host;
	    return !!(parentElement && validateProps.getTagName(parentElement) === validateProps.getPrefixedTagNames(element)[validateProps.paramCaseToCamelCase(tagName)]);
	};

	/* eslint-disable prefer-arrow/prefer-arrow-functions */
	function getOnlyChildrenOfKindHTMLElementOrThrow(element, selector) {
	    const directChildren = getDirectChildHTMLElements.getDirectChildHTMLElements(element, selector);
	    const notValid = directChildren.some((child) => child.tagName !== directChildren[0].tagName);
	    if (notValid) {
	        validateProps.throwException(`child HTMLElements of ${validateProps.getTagNameWithoutPrefix(element)} are invalid. Expected all of: ${selector.replace(/,/g, ' or ')}.`);
	    }
	    return directChildren;
	}

	const scrollerAnimatedCssClass = 'scroller--animated';
	const targetSelectors = ['a', 'button'];
	const transformSelector = (selector) => targetSelectors.map((tag) => selector.replace(/\[role]/g, tag)).join();
	const getComponentCss = (size, weight, theme) => {
	    const { primaryColor, hoverColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, hoverColor: hoverColorDark } = validateProps.getThemedColors('dark');
	    const barJssStyle = {
	        position: 'absolute',
	        height: '2px',
	        left: 0,
	        ...(validateProps.isHighContrastMode
	            ? {
	                background: validateProps.getHighContrastColors().canvasTextColor,
	            }
	            : {
	                background: primaryColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    background: primaryColorDark,
	                }),
	            }),
	    };
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    position: 'relative',
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...validateProps.addImportantToEachRule({
	                '::slotted': {
	                    // TODO: produces duplicated css code in SSR context, we should try to make use of multiple selector like
	                    //  `::slotted(:is(a,button))`.
	                    ...validateProps.getFocusJssStyle(theme, { slotted: 'a', offset: '1px' }),
	                    ...validateProps.getFocusJssStyle(theme, { slotted: 'button', offset: '1px' }),
	                },
	                // would be nice to use shared selector like '::slotted([role])'
	                // but this doesn't work reliably when rendering in browser
	                [transformSelector('::slotted([role])')]: {
	                    ...validateProps.getResetInitialStylesForSlottedAnchor,
	                    display: 'inline-block',
	                    position: 'relative',
	                    margin: '0 0 4px 0',
	                    verticalAlign: 'top',
	                    // TODO: can we use `all: 'inherit'` instead?
	                    fontFamily: 'inherit',
	                    fontStyle: 'inherit',
	                    fontVariant: 'inherit',
	                    fontWeight: 'inherit',
	                    fontSize: 'inherit',
	                    lineHeight: 'inherit',
	                    whiteSpace: 'nowrap',
	                    boxSizing: 'border-box',
	                    WebkitAppearance: 'none', // iOS safari
	                    appearance: 'none',
	                    outlineOffset: '1px',
	                    textDecoration: 'none',
	                    textAlign: 'start',
	                    border: 0,
	                    color: primaryColor,
	                    cursor: 'pointer',
	                    borderRadius: borderRadiusSmall.borderRadiusSmall,
	                    zIndex: 0, // needed for ::before pseudo element to be visible
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        color: primaryColorDark,
	                    }),
	                    ...hoverMediaQuery.hoverMediaQuery({
	                        '&::before': {
	                            content: '""',
	                            position: 'absolute',
	                            inset: '-2px -4px',
	                            borderRadius: borderRadiusSmall.borderRadiusSmall,
	                            zIndex: -1, // Stack the pseudo-element behind the button to avoid overlay of frosted-glass effect with label text
	                            transition: validateProps.getTransition('background-color'),
	                        },
	                    }),
	                },
	                ...hoverMediaQuery.hoverMediaQuery({
	                    [transformSelector('::slotted([role]:hover)::before')]: {
	                        ...validateProps.frostedGlassStyle,
	                        background: hoverColor,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            background: hoverColorDark,
	                        }),
	                    },
	                }),
	                // basic invisible bar, that will be delayed via transition: visibility
	                [transformSelector('::slotted([role])::after')]: {
	                    content: '""',
	                    visibility: 'hidden',
	                },
	                // visible bar for selected tab
	                [transformSelector('::slotted([role][aria-selected="true"])::after, ::slotted([role][aria-current="true"])::after')]: {
	                    ...barJssStyle,
	                    right: '0px',
	                    bottom: validateProps.isHighContrastMode ? '-4px' : '-6px',
	                    visibility: 'inherit',
	                },
	                [transformSelector('::slotted([role]:not(:last-child))')]: {
	                    marginInlineEnd: spacingStaticMedium.spacingStaticMedium,
	                },
	            }),
	        },
	        scroller: {
	            ...textSmallStyle.textSmallStyle,
	            fontWeight: fontWeightStyles.getFontWeight(weight),
	            ...validateProps.buildResponsiveStyles(size, (s) => ({ fontSize: fontSizeText.fontSizeText[s] })),
	        },
	        // conditionally applied and removed based on if activeTabIndex exists
	        [scrollerAnimatedCssClass]: {
	            ['& ' +
	                transformSelector('::slotted([role][aria-selected="true"])::after, ::slotted([role][aria-current="true"])::after')]: {
	                transition: validateProps.addImportantToRule(`visibility 0s linear var(${validateProps.cssVariableTransitionDuration}, ${validateProps.motionDurationModerate})`), // bar appears after transition
	            },
	        },
	        // moving bar
	        bar: {
	            ...barJssStyle,
	            width: 0, // actual width and transform is set via inline css
	            bottom: validateProps.isHighContrastMode ? '0' : '-2px',
	            visibility: 'inherit',
	            transition: `${validateProps.getTransition('transform', 'moderate')}, ${validateProps.getTransition('width', 'moderate')}`,
	            animation: `$hide 0s var(${validateProps.cssVariableAnimationDuration},0.5s) forwards`, // auto hide bar after transition, needs to be a little longer in Safari
	        },
	        '@keyframes hide': {
	            to: {
	                visibility: 'hidden',
	            },
	        },
	    });
	};

	const propTypes = {
	    size: validateProps.AllowedTypes.breakpoint(tabsBarUtils.TABS_BAR_SIZES),
	    weight: validateProps.AllowedTypes.oneOf(tabsBarUtils.TABS_BAR_WEIGHTS),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    gradientColorScheme: validateProps.AllowedTypes.oneOf([undefined, ...scrolling.GRADIENT_COLOR_SCHEMES]),
	    gradientColor: validateProps.AllowedTypes.oneOf(scrolling.GRADIENT_COLORS),
	    activeTabIndex: validateProps.AllowedTypes.number,
	};
	const TabsBar = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.tabChange = validateProps.createEvent(this, "tabChange", 3);
	        this.update = validateProps.createEvent(this, "update", 3);
	        this.internalTabIndex = this.activeTabIndex; // to not override and mutate external prop value
	        this.direction = 'next';
	        this.setAccessibilityAttributes = () => {
	            this.tabElements.forEach((tab, index) => {
	                const isCurrent = this.internalTabIndex === index;
	                const attrs = this.areTabsButtons
	                    ? {
	                        role: 'tab',
	                        tabindex: isCurrent || 0 === index ? '0' : '-1',
	                        'aria-selected': isCurrent ? 'true' : 'false',
	                    }
	                    : {
	                        'aria-current': isCurrent ? 'true' : 'false',
	                    };
	                setAttributes.setAttributes(tab, attrs);
	            });
	        };
	        this.setTabElements = () => {
	            this.tabElements = getOnlyChildrenOfKindHTMLElementOrThrow(this.host, 'a,button');
	            this.areTabsButtons = this.tabElements[0]?.tagName === 'BUTTON';
	            this.internalTabIndex = tabsBarUtils.sanitizeActiveTabIndex(this.activeTabIndex, this.tabElements.length); // since watcher doesn't trigger on first render
	        };
	        this.onClick = (e) => {
	            // e.target can be nested span or font element within a or button when page is translated
	            const newTabIndex = this.tabElements.findIndex((el) => el.contains(e.target));
	            if (newTabIndex >= 0) {
	                this.onTabClick(newTabIndex);
	            }
	        };
	        this.onTabClick = (newTabIndex) => {
	            this.update.emit({ activeTabIndex: newTabIndex });
	            this.tabChange.emit({ activeTabIndex: newTabIndex });
	        };
	        this.onKeydown = (e) => {
	            let upcomingFocusedTabIndex;
	            const focusedTabIndex = this.hasPTabsParent ? this.internalTabIndex || 0 : tabsBarUtils.getFocusedTabIndex(this.tabElements);
	            switch (e.key) {
	                case 'ArrowLeft':
	                case 'Left':
	                    upcomingFocusedTabIndex = tabsBarUtils.getPrevNextTabIndex('prev', this.tabElements.length, focusedTabIndex);
	                    break;
	                case 'ArrowRight':
	                case 'Right':
	                    upcomingFocusedTabIndex = tabsBarUtils.getPrevNextTabIndex('next', this.tabElements.length, focusedTabIndex);
	                    break;
	                case 'Home':
	                    upcomingFocusedTabIndex = 0;
	                    break;
	                case 'End':
	                    upcomingFocusedTabIndex = this.tabElements.length - 1;
	                    break;
	                // the slotted buttons have a different tabbing sequence in chrome and safari and it appears that on hitting
	                // tab the first slotted one with tabindex=0 becomes focused instead of the one after,
	                // therefor the 'Tab' case needs to be handled
	                case 'Tab':
	                    const { target } = e;
	                    const { tabIndex } = target;
	                    target.tabIndex = null;
	                    setTimeout(() => {
	                        target.tabIndex = tabIndex;
	                    });
	                    return;
	                default:
	                    return;
	            }
	            if (this.hasPTabsParent) {
	                this.onTabClick(upcomingFocusedTabIndex);
	            }
	            this.tabElements[upcomingFocusedTabIndex].focus();
	            e.preventDefault();
	        };
	        this.scrollActiveTabIntoView = (isSmooth = true) => {
	            // scrollAreaElement might be undefined in certain scenarios with framework routing involved
	            // where the activeTabIndex watcher triggers this function before the scroller is rendered and the ref defined
	            if (this.scrollerElement && this.internalTabIndex !== undefined) {
	                const scrollActivePosition = scrolling.getScrollActivePosition(this.tabElements, this.direction, this.internalTabIndex, this.scrollerElement);
	                this.scrollerElement.scrollToPosition = {
	                    scrollPosition: scrollActivePosition,
	                    isSmooth,
	                };
	            }
	        };
	        this.setBarStyle = () => {
	            tabsBarUtils.setBarStyle(this.tabElements, this.internalTabIndex, this.barElement);
	        };
	        this.observeBreakpointChange = () => {
	            if (typeof validateProps.parseJSON(this.size) === 'object') {
	                validateProps.observeBreakpointChange(this.host, () => {
	                    this.setBarStyle();
	                    this.scrollActiveTabIntoView(false);
	                });
	            }
	        };
	        this.size = 'small';
	        this.weight = 'regular';
	        this.theme = 'light';
	        this.gradientColorScheme = undefined;
	        this.gradientColor = 'background-base';
	        this.activeTabIndex = undefined;
	        this.tabElements = [];
	    }
	    activeTabIndexHandler(_newValue, oldValue) {
	        // in Angular, when chunk is already loaded and component is rendered almost identical after navigation
	        // (or with hot reloading in stackblitz) this watcher is called between `connectedCallback` and `componentDidLoad`
	        // this would reset `this.activeTabIndex` to undefined when `this.tabElements = []`
	        // so we have a separate `this.internalTabIndex` to not override the prop value
	        // https://github.com/porsche-design-system/porsche-design-system/issues/2674
	        this.setTabElements();
	        this.direction = this.internalTabIndex > oldValue || oldValue === undefined ? 'next' : 'prev';
	        this.setBarStyle();
	        this.scrollActiveTabIntoView();
	    }
	    connectedCallback() {
	        this.hasPTabsParent = isShadowRootParentOfKind(this.host, 'p-tabs');
	        this.observeBreakpointChange(); // on reconnect
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    componentWillLoad() {
	        this.setTabElements();
	    }
	    componentDidLoad() {
	        this.scrollActiveTabIntoView(false);
	        this.observeBreakpointChange(); // initially or slow prop binding
	        // TODO: would be great to use this in jsx but that doesn't work reliable or triggers initially when component is rendered via framework
	        validateProps.getShadowRootHTMLElement(this.host, 'slot').addEventListener('slotchange', () => {
	            this.setTabElements();
	            this.setBarStyle();
	        });
	    }
	    disconnectedCallback() {
	        validateProps.unobserveBreakpointChange(this.host);
	    }
	    componentDidRender() {
	        // 1 tick delay to prevent transition
	        window.requestAnimationFrame(() => {
	            this.scrollerElement.classList.toggle(scrollerAnimatedCssClass, this.internalTabIndex !== undefined);
	        });
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'gradientColorScheme', 'Please use gradientColor prop instead.');
	        const deprecationMap = {
	            semibold: 'semi-bold',
	        };
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'weight', deprecationMap);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.size, (deprecationMap[this.weight] || this.weight), this.theme);
	        this.setAccessibilityAttributes();
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(PrefixedTagNames.pScroller, { key: '54eec87eb9aba4d2cf005b5d0490cba0d1785c66', class: "scroller", ...(this.areTabsButtons && { aria: { role: 'tablist' } }), theme: this.theme, gradientColorScheme: this.gradientColorScheme, gradientColor: this.gradientColor, alignScrollIndicator: "top", ref: (el) => (this.scrollerElement = el), onClick: this.onClick, onKeyDown: this.onKeydown }, validateProps.h("slot", { key: '4448c9d046758f7e8126b5d33789b1a1722bc89f' }), validateProps.h("span", { key: '0dcb3e9537aac52a81e1b382169b3408375bcca4', class: "bar", ref: (el) => (this.barElement = el) })));
	    }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "activeTabIndex": ["activeTabIndexHandler"]
	    }; }
	};

	pTabsBar_cjs_entry.p_tabs_bar = TabsBar;

	
	return pTabsBar_cjs_entry;
}

var pTagDismissible_cjs_entry = {};

var tagSharedUtils369a2a7e = {};

var hasRequiredTagSharedUtils369a2a7e;

function requireTagSharedUtils369a2a7e () {
	if (hasRequiredTagSharedUtils369a2a7e) return tagSharedUtils369a2a7e;
	hasRequiredTagSharedUtils369a2a7e = 1;

	/** @deprecated */
	const TAG_DISMISSIBLE_COLORS_DEPRECATED = ['background-default']; // 'background-default' is deprecated (replaced with 'background-base')
	const TAG_DISMISSIBLE_COLORS = [
	    'background-base',
	    'background-surface',
	    ...TAG_DISMISSIBLE_COLORS_DEPRECATED,
	];
	const TAG_DISMISSIBLE_ARIA_ATTRIBUTES = ['aria-label'];

	const getThemedBackgroundColor = (tagColor, themedColors) => {
	    const colorMap = {
	        'background-base': themedColors.backgroundColor,
	        'background-surface': themedColors.backgroundSurfaceColor,
	        primary: themedColors.primaryColor,
	        'notification-info-soft': themedColors.infoSoftColor,
	        'notification-warning-soft': themedColors.warningSoftColor,
	        'notification-success-soft': themedColors.successSoftColor,
	        'notification-error-soft': themedColors.errorSoftColor,
	    };
	    return colorMap[tagColor];
	};

	tagSharedUtils369a2a7e.TAG_DISMISSIBLE_ARIA_ATTRIBUTES = TAG_DISMISSIBLE_ARIA_ATTRIBUTES;
	tagSharedUtils369a2a7e.TAG_DISMISSIBLE_COLORS = TAG_DISMISSIBLE_COLORS;
	tagSharedUtils369a2a7e.getThemedBackgroundColor = getThemedBackgroundColor;

	
	return tagSharedUtils369a2a7e;
}

var hasRequiredPTagDismissible_cjs_entry;

function requirePTagDismissible_cjs_entry () {
	if (hasRequiredPTagDismissible_cjs_entry) return pTagDismissible_cjs_entry;
	hasRequiredPTagDismissible_cjs_entry = 1;

	Object.defineProperty(pTagDismissible_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed2d6d1d94();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const tagSharedUtils = requireTagSharedUtils369a2a7e();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const fontSizeTextXSmall = requireFontSizeTextXSmallE59d35d7();
	requireHelperA66adcf2();
	requireTextShared9135e2ef();
	requireFontLineHeight78b03658();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();

	const getComponentCss = (color, hasLabel, theme) => {
	    const themedColors = validateProps.getThemedColors(theme);
	    const themedColorsDark = validateProps.getThemedColors('dark');
	    const { primaryColor, hoverColor, contrastHighColor } = themedColors;
	    const { primaryColor: primaryColorDark, hoverColor: hoverColorDark, contrastHighColor: contrastHighColorDark, } = themedColorsDark;
	    const backgroundColor = tagSharedUtils.getThemedBackgroundColor(color, themedColors);
	    const backgroundColorDark = tagSharedUtils.getThemedBackgroundColor(color, themedColorsDark);
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'inline-block',
	                verticalAlign: 'top',
	                ...validateProps.addImportantToEachRule({
	                    outline: 0,
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            button: {
	                display: 'flex',
	                position: 'relative',
	                alignItems: 'center',
	                gap: '12px',
	                minHeight: '54px',
	                padding: '4px 12px',
	                margin: 0, // Removes default button margin on safari 15
	                borderRadius: borderRadiusSmall.borderRadiusSmall,
	                border: 0,
	                cursor: 'pointer',
	                background: backgroundColor,
	                color: primaryColor,
	                textAlign: 'start',
	                ...textSmallStyle.textSmallStyle,
	                ...(validateProps.isHighContrastMode && {
	                    // TODO: using border would increase the dimension but using outline interferes with the focus style
	                    outline: '1px solid transparent',
	                }),
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    background: backgroundColorDark,
	                    color: primaryColorDark,
	                }),
	                ...hoverMediaQuery.hoverMediaQuery({
	                    '&:hover > .icon': {
	                        backgroundColor: hoverColor,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            backgroundColor: hoverColorDark,
	                        }),
	                    },
	                }),
	                ...validateProps.getFocusJssStyle(theme),
	            },
	        },
	        ...(hasLabel && {
	            label: {
	                display: 'block',
	                marginBottom: '-4px',
	                color: contrastHighColor,
	                fontSize: fontSizeTextXSmall.fontSizeTextXSmall,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: contrastHighColorDark,
	                }),
	            },
	        }),
	        icon: {
	            padding: '4px',
	            marginInlineEnd: '-2px', // compensate white space of svg icon and optimize visual alignment
	            transition: validateProps.getTransition('background-color'),
	            borderRadius: borderRadiusSmall.borderRadiusSmall,
	        },
	        'sr-only': validateProps.getHiddenTextJssStyle(),
	    });
	};

	const propTypes = {
	    color: validateProps.AllowedTypes.oneOf(tagSharedUtils.TAG_DISMISSIBLE_COLORS),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    label: validateProps.AllowedTypes.string,
	    aria: validateProps.AllowedTypes.aria(tagSharedUtils.TAG_DISMISSIBLE_ARIA_ATTRIBUTES),
	};
	const TagDismissible = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.color = 'background-surface';
	        this.theme = 'light';
	        this.label = undefined;
	        this.aria = undefined;
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        const deprecationMap = {
	            'background-default': 'background-base',
	        };
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'color', deprecationMap);
	        validateProps.attachComponentCss(this.host, getComponentCss, (deprecationMap[this.color] || this.color), !!this.label, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h("button", { key: '033898486d55e9439e85fc55f8330f1341628a1a', type: "button", ...validateProps.parseAndGetAriaAttributes(this.aria) }, validateProps.h("span", { key: '630bddc63d99b36ccf8883c55537eccf6f43f003', class: "sr-only" }, "Remove:"), validateProps.h("span", { key: 'c3e3c46f36c3b4558f5455cdec3deab1d7cfa5c7' }, this.label && validateProps.h("span", { class: "label" }, this.label), validateProps.h("slot", { key: '6b4d6156157be4588da72e49bf964c93bd798a44' })), validateProps.h(PrefixedTagNames.pIcon, { key: 'f4741962744f99c12916fae52211dae888dc0f28', class: "icon", name: "close", theme: this.theme, "aria-hidden": "true" })));
	    }
	    static get delegatesFocus() { return true; }
	    get host() { return validateProps.getElement(this); }
	};

	pTagDismissible_cjs_entry.p_tag_dismissible = TagDismissible;

	
	return pTagDismissible_cjs_entry;
}

var pTag_cjs_entry = {};

var hasRequiredPTag_cjs_entry;

function requirePTag_cjs_entry () {
	if (hasRequiredPTag_cjs_entry) return pTag_cjs_entry;
	hasRequiredPTag_cjs_entry = 1;

	Object.defineProperty(pTag_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const tagSharedUtils = requireTagSharedUtils369a2a7e();
	const getDirectChildHTMLElement = requireGetDirectChildHTMLElementC5dd1dc2();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed2d6d1d94();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const textXSmallStyle = requireTextXSmallStyle1145ee25();
	requireTransformSelectorToDirectChildSelectorC1b1f9b0();
	requireHelperA66adcf2();
	requireTextShared9135e2ef();
	requireFontLineHeight78b03658();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextXSmallE59d35d7();

	const getThemeForIcon = (color, theme) => {
	    return color === 'neutral-contrast-high' || color === 'primary' ? (validateProps.isThemeDark(theme) ? 'light' : 'dark') : theme;
	};
	/** @deprecated */
	const TAG_COLORS_DEPRECATED = [
	    'neutral-contrast-high', // 'notification-contrast-high' is deprecated (replaced with 'primary')
	    'notification-neutral', // 'notification-neutral' is deprecated (replaced with 'notification-info-soft')
	    'notification-warning',
	    'notification-success',
	    'notification-error',
	];
	const TAG_COLORS = [
	    ...tagSharedUtils.TAG_DISMISSIBLE_COLORS,
	    'primary',
	    'notification-info-soft',
	    'notification-warning-soft',
	    'notification-success-soft',
	    'notification-error-soft',
	    ...TAG_COLORS_DEPRECATED,
	];
	const getThemedBackgroundHoverColor = (tagColor, themedColors, theme) => {
	    const isDark = validateProps.isThemeDark(theme);
	    const keySuffix = isDark ? 'Lighten' : 'Darken';
	    const colorMap = {
	        'background-base': themedColors[`backgroundColor${keySuffix}`],
	        'background-surface': themedColors[`backgroundSurfaceColor${keySuffix}`],
	        primary: isDark ? themedColors.contrastHighColorLighten : themedColors.contrastHighColor,
	        'notification-info-soft': themedColors[`infoSoftColor${keySuffix}`],
	        'notification-success-soft': themedColors[`successSoftColor${keySuffix}`],
	        'notification-error-soft': themedColors[`errorSoftColor${keySuffix}`],
	        'notification-warning-soft': themedColors[`warningSoftColor${keySuffix}`],
	    };
	    return colorMap[tagColor];
	};

	const getColors = (themedColors, tagColor, theme) => {
	    const { primaryColor } = tagColor === 'primary' ? validateProps.getInvertedThemedColors(theme) : themedColors;
	    return {
	        primaryColor,
	        backgroundColor: tagSharedUtils.getThemedBackgroundColor(tagColor, themedColors),
	        backgroundHoverColor: getThemedBackgroundHoverColor(tagColor, themedColors, theme),
	    };
	};
	const getComponentCss = (tagColor, isFocusable, theme) => {
	    const themedColors = validateProps.getThemedColors(theme);
	    const themedColorsDark = validateProps.getThemedColors('dark');
	    const { primaryColor, backgroundColor, backgroundHoverColor } = getColors(themedColors, tagColor, theme);
	    const { primaryColor: primaryColorDark, backgroundColor: backgroundColorDark, backgroundHoverColor: backgroundHoverColorDark, } = getColors(themedColorsDark, tagColor, 'dark');
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'inline-flex',
	                verticalAlign: 'top',
	                whiteSpace: 'nowrap',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            span: {
	                display: 'flex',
	                gap: '2px',
	                alignItems: 'center',
	                position: 'relative',
	                padding: '4px 9px',
	                borderRadius: borderRadiusSmall.borderRadiusSmall,
	                background: backgroundColor,
	                color: primaryColor,
	                font: textXSmallStyle.textXSmallStyle.font,
	                ...(validateProps.isHighContrastMode && {
	                    outline: '1px solid transparent',
	                }),
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    background: backgroundColorDark,
	                    color: primaryColorDark,
	                }),
	                ...(isFocusable &&
	                    hoverMediaQuery.hoverMediaQuery({
	                        transition: validateProps.getTransition('background-color'),
	                        '&:hover': {
	                            background: backgroundHoverColor,
	                            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                                background: backgroundHoverColorDark,
	                            }),
	                        },
	                    })),
	            },
	            '::slotted': validateProps.addImportantToEachRule({
	                '&(a),&(button)': {
	                    ...validateProps.getResetInitialStylesForSlottedAnchor,
	                    display: 'inline',
	                    position: 'static',
	                    textDecoration: 'underline',
	                    cursor: 'pointer',
	                    font: 'inherit',
	                    color: 'inherit',
	                    WebkitAppearance: 'none', // iOS safari
	                    appearance: 'none',
	                    border: 0,
	                    textAlign: 'start',
	                },
	                '&(a)::before,&(button)::before': {
	                    content: '""',
	                    position: 'absolute',
	                    inset: 0,
	                    borderRadius: '4px',
	                },
	                ...validateProps.getFocusJssStyle(theme, { slotted: 'a', pseudo: true }),
	                ...validateProps.getFocusJssStyle(theme, { slotted: 'button', pseudo: true }),
	                '&(br)': {
	                    display: 'none',
	                },
	            }),
	        },
	        icon: {
	            marginInlineStart: '-2px', // compensate white space of svg icon and optimize visual alignment
	            alignSelf: 'flex-start',
	            ...(['neutral-contrast-high', 'primary'].includes(tagColor) && {
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    filter: 'invert(1)',
	                }),
	            }),
	        },
	    });
	};

	const propTypes = {
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    color: validateProps.AllowedTypes.oneOf(TAG_COLORS),
	    icon: validateProps.AllowedTypes.string, // TODO: we could use AllowedTypes.oneOf<IconName>(Object.keys(ICONS_MANIFEST) as IconName[]) but then main chunk will increase
	    iconSource: validateProps.AllowedTypes.string,
	};
	const Tag = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.theme = 'light';
	        this.color = 'background-surface';
	        this.icon = undefined;
	        this.iconSource = undefined;
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        const deprecationMap = {
	            'background-default': 'background-base',
	            'neutral-contrast-high': 'primary',
	            'notification-neutral': 'notification-info-soft',
	            'notification-warning': 'notification-warning-soft',
	            'notification-success': 'notification-success-soft',
	            'notification-error': 'notification-error-soft',
	        };
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'color', deprecationMap);
	        validateProps.attachComponentCss(this.host, getComponentCss, (deprecationMap[this.color] || this.color), !!getDirectChildHTMLElement.getDirectChildHTMLElement(this.host, 'a,button'), this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h("span", { key: '6e3bf9b19a065078fed2d9746fb5d9dd8a4bef81' }, (this.icon || this.iconSource) && (validateProps.h(PrefixedTagNames.pIcon, { class: "icon", name: this.icon, source: this.iconSource, color: "primary", size: "x-small", theme: getThemeForIcon(this.color, this.theme), "aria-hidden": "true" })), validateProps.h("div", { key: 'e32c3281d40856418ff56ac0060e93e38dbac5e0', class: "label" }, validateProps.h("slot", { key: '7e24b9e0b69ec8595651e2757a586f647f306837' }))));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pTag_cjs_entry.p_tag = Tag;

	
	return pTag_cjs_entry;
}

var pTextFieldWrapper_cjs_entry = {};

var hasRequiredPTextFieldWrapper_cjs_entry;

function requirePTextFieldWrapper_cjs_entry () {
	if (hasRequiredPTextFieldWrapper_cjs_entry) return pTextFieldWrapper_cjs_entry;
	hasRequiredPTextFieldWrapper_cjs_entry = 1;

	Object.defineProperty(pTextFieldWrapper_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const buttonHandling = requireButtonHandlingB33ae166();
	const required = requireRequiredF3c463a3();
	const isWithinForm = requireIsWithinForm3637a500();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed0dc3288b();
	const propertyObserver = requirePropertyObserverE214b5c5();
	const theme = requireThemeBfc10573();
	const getOnlyChildOfKindHTMLElementOrThrow = requireGetOnlyChildOfKindHTMLElementOrThrowF7285231();
	const hasDocument = requireHasDocument079654e6();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const formStyles = requireFormStyles7e9d1c43();
	const label = requireLabel5379ea8c();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	requireGetClosestHTMLElement83d01a84();
	requireSetAttributes642a7e67();
	requireHasNamedSlotA96fd22a();
	requireGetNamedSlotA0cdbdbc();
	requireTextSmallStyle7246779a();
	requireTextShared9135e2ef();
	requireFontLineHeight78b03658();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireHelperA66adcf2();
	requireGetDirectChildHTMLElements31d23fa9();
	requireGetHTMLElements3f1c700f();
	requireTransformSelectorToDirectChildSelectorC1b1f9b0();
	requireHoverMediaQuery5e6deda8();
	requireSpacingStaticSmall2130ed04();
	requireSpacingStaticMedium94812711();
	requireBorderRadiusSmall5f37fc45();
	requireFontSizeTextXSmallE59d35d7();
	requireHasDescriptionBbe55afe();
	requireIsParentOfKindB7d9f81c();

	const UNIT_POSITIONS = ['prefix', 'suffix'];
	const hasCounterAndIsTypeText = (el) => isType(el.type, 'text') && validateProps.hasCounter(el);
	const hasUnitAndIsTypeTextOrNumber = ({ type }, unit) => {
	    return !!unit && (isType(type, 'text') || isType(type, 'number'));
	};
	const isType = (inputType, typeToValidate) => inputType === typeToValidate;
	const hasLocateAction = (icon) => icon === 'locate';
	const getInputPaddingLeftOrRight = (unitElementWidth) => {
	    return `calc(${unitElementWidth}px - ${validateProps.borderWidthBase})`;
	};
	const setInputStyles = (input, unitOrCounterElement, unitPosition) => {
	    if (unitOrCounterElement) {
	        input.style.removeProperty(cssVariableInputPaddingStart);
	        input.style.removeProperty(cssVariableInputPaddingEnd);
	        input.style.setProperty(unitPosition === 'prefix' ? cssVariableInputPaddingStart : cssVariableInputPaddingEnd, getInputPaddingLeftOrRight(unitOrCounterElement.offsetWidth), // in case fonts are not loaded, this value is wrong
	        'important');
	    }
	};
	const throwIfUnitLengthExceeded = (unit) => {
	    if (unit.length > 5) {
	        validateProps.throwException(`unit='${unit}' passed to p-text-field-wrapper exceeds the maximum length of 5.`);
	    }
	};
	const addInputEventListenerForSearch = (input, inputChangeCallback) => {
	    input.addEventListener('input', (e) => {
	        inputChangeCallback(!!e.target.value);
	    });
	    input.addEventListener('keydown', (e) => {
	        if (e.key === 'Escape' && e.target.value) {
	            e.preventDefault();
	            e.target.value = '';
	            // need to emit event so consumer's change listeners fire for resetting a search, etc.
	            dispatchInputEvent(e.target);
	        }
	    });
	};
	const dispatchInputEvent = (el) => {
	    // { bubbles: true } is crucial for react onChange callback getting invoked
	    el.dispatchEvent(new Event('input', { bubbles: true }));
	};
	// eslint-disable-next-line no-underscore-dangle
	const _hasShowPickerSupport = () => {
	    return (hasDocument.hasDocument &&
	        'showPicker' in HTMLInputElement.prototype &&
	        // TODO: it would be better to determinate support by checking for existence of "calendar-picker-indicator"
	        !!window.navigator.userAgent.match(/chrome|chromium|crios|edg/i));
	};
	const hasShowPickerSupport = _hasShowPickerSupport();
	const showCustomCalendarOrTimeIndicator = (isCalendar, isTime) => {
	    return hasShowPickerSupport && (isCalendar || isTime);
	};

	const cssVariableInputPaddingStart = '--p-internal-text-field-input-padding-start';
	const cssVariableInputPaddingEnd = '--p-internal-text-field-input-padding-end';
	const getComponentCss = (isDisabled, hideLabel, state, hasUnitOrVisibleCounter, unitPosition, inputType, showPasswordToggle, isWithinForm, hasSubmitButton, theme) => {
	    const isSearch = isType(inputType, 'search');
	    const isPassword = isType(inputType, 'password');
	    const isNumber = isType(inputType, 'number');
	    const isCalendar = isType(inputType, 'date') || isType(inputType, 'week') || isType(inputType, 'month');
	    const isTime = isType(inputType, 'time');
	    const isSearchOrPassword = isSearch || (isPassword && showPasswordToggle);
	    const isSearchWithoutFormOrSubmitButton = isSearch && (!isWithinForm || !hasSubmitButton);
	    const isSearchWithForm = isSearch && isWithinForm;
	    const isCalendarOrTimeWithCustomIndicator = showCustomCalendarOrTimeIndicator(isCalendar, isTime);
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            // ::slotted(input)
	            ...validateProps.addImportantToEachRule({
	                ...formStyles.getSlottedTextFieldTextareaSelectStyles('input', state, false, theme, {
	                    gridArea: '1/1/1/-1',
	                    padding: `${formStyles.formElementPaddingVertical} ${formStyles.formElementPaddingHorizontal}`,
	                    paddingInlineStart: `var(${cssVariableInputPaddingStart})`, // iOS Safari 14.5 can't handle padding-inline shorthand with css variables
	                    paddingInlineEnd: `var(${cssVariableInputPaddingEnd})`, // iOS Safari 14.5 can't handle padding-inline shorthand with css variables
	                    // TODO: move into getSlottedTextFieldTextareaSelectStyles()
	                    ...(isNumber && {
	                        MozAppearance: 'textfield', // hides up/down spin button for Firefox
	                    }),
	                    ...((isCalendar || isTime) && {
	                        // for native placeholder color in safari, background has to be a special value, `transparent` or `rgba(0,0,0,0)` won't work
	                        // this works nice for `theme="light"`, but for `theme="dark"` placeholder appears blue which is still better
	                        // than having invisible dots or colons for data/time or not seeing the value at all after selection
	                        // found on https://browserstrangeness.bitbucket.io/css_hacks.html#safari
	                        '@supports (-webkit-hyphens: none)': {
	                            background: 'rgba(0,0,1,0)',
	                            color: validateProps.isThemeDark(theme) ? validateProps.getThemedColors(theme).primaryColor : 'initial',
	                        },
	                    }),
	                }),
	                // TODO: move into getSlottedTextFieldTextareaSelectStyles()
	                '::slotted': {
	                    '&(input:-internal-autofill-selected),&(input:-internal-autofill-previewed),&(input:-webkit-autofill),&(input:-webkit-autofill:focus)': {
	                        WebkitBackgroundClip: 'padding-box', // reset webkit autofill styles
	                    },
	                },
	            }),
	        },
	        root: {
	            [cssVariableInputPaddingStart]: isSearchWithoutFormOrSubmitButton
	                ? formStyles.getCalculatedFormElementPaddingHorizontal(1)
	                : formStyles.formElementPaddingHorizontal,
	            [cssVariableInputPaddingEnd]: isSearchOrPassword || isCalendarOrTimeWithCustomIndicator
	                ? formStyles.getCalculatedFormElementPaddingHorizontal(isSearchWithForm && hasSubmitButton ? 2 : 1)
	                : formStyles.formElementPaddingHorizontal,
	            display: 'grid',
	            gap: spacingStaticXSmall.spacingStaticXSmall,
	        },
	        wrapper: {
	            display: 'grid',
	            gridTemplateColumns: `${formStyles.formElementLayeredSafeZone} auto minmax(0, 1fr) auto auto ${formStyles.formElementLayeredSafeZone}`,
	        },
	        ...((isSearchOrPassword || isCalendarOrTimeWithCustomIndicator) && {
	            // TODO: extract for multi-select, select-wrapper and text-field (not gridArea and placeSelf) like done for unit class
	            button: {
	                gridArea: '1/5',
	                placeSelf: 'center',
	                padding: formStyles.formButtonOrIconPadding,
	                // TODO: maybe we should render hidden button conditionally, needs to be checked if a11y compliant
	                '&:not([hidden])~.button': {
	                    gridArea: '1/4',
	                },
	            },
	        }),
	        ...(isSearchWithoutFormOrSubmitButton && {
	            // TODO: extract for multi-select, select-wrapper and text-field (not gridArea and placeSelf) like done for unit class
	            icon: {
	                gridArea: '1/2',
	                placeSelf: 'center',
	                padding: formStyles.formButtonOrIconPadding,
	                pointerEvents: 'none',
	            },
	        }),
	        ...(hasUnitOrVisibleCounter && {
	            'unit-counter': {
	                ...formStyles.getUnitCounterJssStyle(isDisabled, theme),
	                gridArea: `1/${unitPosition === 'suffix' ? 5 : 1}/1/${unitPosition === 'suffix' ? 7 : 3}`,
	                placeSelf: 'center',
	                paddingInline: unitPosition === 'suffix'
	                    ? `${formStyles.formElementLayeredGap} calc(${formStyles.formElementPaddingHorizontal} + ${validateProps.borderWidthBase})`
	                    : `calc(${formStyles.formElementPaddingHorizontal} + ${validateProps.borderWidthBase}) ${formStyles.formElementLayeredGap}`, // padding needed for correct input padding synchronisation
	            },
	        }),
	        // TODO: maybe we should extract it as functional component too
	        'sr-only': validateProps.getHiddenTextJssStyle(),
	        // .label / .required
	        ...label.getFunctionalComponentLabelStyles(isDisabled, hideLabel, theme),
	        // .message
	        ...required.getFunctionalComponentStateMessageStyles(theme, state),
	    });
	};

	const propTypes = {
	    label: validateProps.AllowedTypes.string,
	    unit: validateProps.AllowedTypes.string,
	    unitPosition: validateProps.AllowedTypes.oneOf(UNIT_POSITIONS),
	    description: validateProps.AllowedTypes.string,
	    state: validateProps.AllowedTypes.oneOf(required.FORM_STATES),
	    message: validateProps.AllowedTypes.string,
	    hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	    showCharacterCount: validateProps.AllowedTypes.boolean,
	    showCounter: validateProps.AllowedTypes.boolean,
	    actionIcon: validateProps.AllowedTypes.oneOf([undefined, 'locate']),
	    actionLoading: validateProps.AllowedTypes.boolean,
	    submitButton: validateProps.AllowedTypes.boolean,
	    showPasswordToggle: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const TextFieldWrapper = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.action = validateProps.createEvent(this, "action", 3);
	        this.onLabelClick = () => {
	            this.input.focus();
	        };
	        this.togglePassword = () => {
	            this.input.type = isType(this.input.type, 'password') ? 'text' : 'password';
	            this.showPassword = !this.showPassword;
	            this.onLabelClick();
	        };
	        this.onSubmit = (event) => {
	            buttonHandling.handleButtonEvent(event, this.host, () => 'submit', () => this.input.disabled);
	        };
	        this.onClear = () => {
	            this.onLabelClick();
	            this.input.value = '';
	            dispatchInputEvent(this.input);
	        };
	        this.observeAttributes = () => {
	            validateProps.observeAttributes(this.input, ['disabled', 'readonly', 'required', 'maxlength'], () => {
	                this.updateCounterVisibility();
	                validateProps.forceUpdate(this.host);
	            });
	        };
	        this.updateCounterVisibility = () => {
	            this.hasCounter = hasCounterAndIsTypeText(this.input);
	            this.isCounterVisible =
	                this.hasCounter && (typeof this.showCharacterCount === 'undefined' ? this.showCounter : this.showCharacterCount);
	            this.hasUnit = !this.isCounterVisible && hasUnitAndIsTypeTextOrNumber(this.input, this.unit);
	        };
	        this.setInputStyles = () => {
	            setInputStyles(this.input, this.unitOrCounterElement, this.isCounterVisible ? 'suffix' : this.unitPosition);
	        };
	        this.addInputEventListenerForCounter = (characterCountElement, counterElement, inputChangeCallback) => {
	            validateProps.updateCounter(this.input, characterCountElement, counterElement); // Initial value
	            // When value changes programmatically
	            propertyObserver.observeProperties(this.input, ['value'], () => {
	                validateProps.updateCounter(this.input, characterCountElement, counterElement, inputChangeCallback);
	            });
	            this.eventListener = validateProps.inputEventListenerCurry(characterCountElement, counterElement, inputChangeCallback);
	            this.input.removeEventListener('input', this.eventListener);
	            this.input.addEventListener('input', this.eventListener);
	        };
	        this.label = '';
	        this.unit = '';
	        this.unitPosition = 'prefix';
	        this.description = '';
	        this.state = 'none';
	        this.message = '';
	        this.hideLabel = false;
	        this.showCharacterCount = undefined;
	        this.showCounter = true;
	        this.actionIcon = undefined;
	        this.actionLoading = false;
	        this.submitButton = true;
	        this.showPasswordToggle = true;
	        this.theme = 'light';
	        this.showPassword = false;
	        this.isClearable = false;
	    }
	    onShowCounterChange() {
	        this.updateCounterVisibility();
	    }
	    connectedCallback() {
	        this.observeAttributes(); // on every reconnect
	    }
	    componentWillLoad() {
	        this.input = getOnlyChildOfKindHTMLElementOrThrow.getOnlyChildOfKindHTMLElementOrThrow(this.host, ['text', 'number', 'email', 'tel', 'search', 'url', 'date', 'time', 'month', 'week', 'password']
	            .map((v) => `input[type=${v}]`)
	            .join());
	        const { type } = this.input;
	        this.observeAttributes(); // once initially
	        this.isSearch = isType(type, 'search');
	        this.isPassword = isType(type, 'password');
	        this.isCalendar = isType(type, 'date') || isType(type, 'week') || isType(type, 'month');
	        this.isTime = isType(type, 'time');
	        this.isWithinForm = isWithinForm.isWithinForm(this.host);
	        this.hasAction = hasLocateAction(this.actionIcon);
	        this.updateCounterVisibility();
	        if (this.isSearch) {
	            this.isClearable = !!this.input.value;
	            // detect programmatic value changes like it happens in frameworks
	            propertyObserver.observeProperties(this.input, ['value'], () => (this.isClearable = !!this.input.value));
	        }
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    componentDidLoad() {
	        if (this.isSearch) {
	            addInputEventListenerForSearch(this.input, (hasValue) => (this.isClearable = hasValue));
	        }
	    }
	    componentDidRender() {
	        // needs to happen after render in order to have unitOrCounterElement defined
	        this.setInputStyles();
	        if (this.isCounterVisible || this.hasCounter) {
	            // renders innerHTML of unitOrCounterElement initially and on every input event
	            this.addInputEventListenerForCounter(this.ariaElement, this.isCounterVisible && this.unitOrCounterElement, this.setInputStyles);
	            this.setInputStyles(); // set style initially after componentDidRender already ran with empty unitOrCounterElement
	        }
	        /*
	         * This is a workaround to improve accessibility because the input and the label/description/message text are placed in different DOM.
	         * Referencing ID's from outside the component is impossible because the web component’s DOM is separate.
	         * We have to wait for full support of the Accessibility Object Model (AOM) to provide the relationship between shadow DOM and slots
	         */
	        validateProps.setAriaAttributes(this.input, {
	            label: this.label,
	            message: this.message || this.description,
	            state: this.state,
	        });
	    }
	    disconnectedCallback() {
	        validateProps.unobserveAttributes(this.input);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'showCharacterCount', 'Please use showCounter prop instead.');
	        throwIfUnitLengthExceeded(this.unit);
	        const { readOnly, disabled, type } = this.input;
	        validateProps.attachComponentCss(this.host, getComponentCss, disabled, this.hideLabel, this.state, this.hasUnit || this.isCounterVisible, this.isCounterVisible ? 'suffix' : this.unitPosition, this.isPassword ? 'password' : type, this.showPasswordToggle, this.isWithinForm, this.submitButton, this.theme);
	        const disabledOrReadOnly = disabled || readOnly;
	        const buttonProps = {
	            hideLabel: true,
	            theme: this.theme,
	            class: 'button',
	        };
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h("div", { key: 'ce95531dc832c2c0f3dc575228d71dfafc2a22e1', class: "root" }, validateProps.h(label.Label, { key: 'dc58225beb15e2c285ce24b537beb680e5a4cd13', host: this.host, label: this.label, description: this.description, formElement: this.input, isDisabled: disabled }), validateProps.h("div", { key: 'd2a6e0bb3ff68c814f288165c0dd0e13fb67ba9d', class: "wrapper" }, validateProps.h("slot", { key: '7b1cd7286f39341075d25e941dc770592f0922d9' }), this.hasCounter && validateProps.h("span", { class: "sr-only", ref: (el) => (this.ariaElement = el), "aria-live": "polite" }), (this.hasUnit || this.isCounterVisible) && (validateProps.h("span", { class: "unit-counter", ref: (el) => (this.unitOrCounterElement = el), "aria-hidden": "true" }, this.unit)), this.isPassword && this.showPasswordToggle ? (validateProps.h(PrefixedTagNames.pButtonPure, { ...buttonProps, type: "button", icon: this.showPassword ? 'view-off' : 'view', disabled: disabled, onClick: this.togglePassword, aria: { 'aria-pressed': this.showPassword ? 'true' : 'false' } }, "Toggle password visibility")) : showCustomCalendarOrTimeIndicator(this.isCalendar, this.isTime) ? (validateProps.h(PrefixedTagNames.pButtonPure, { ...buttonProps, type: "button", icon: this.isCalendar ? 'calendar' : 'clock', disabled: disabled, onClick: () => this.input.showPicker() }, "Show $", this.isCalendar ? 'date' : 'time', " picker")) : (this.isSearch && [
	            // TODO: create an own component, which would fix SSR support too
	            this.isWithinForm && this.submitButton ? (validateProps.h(PrefixedTagNames.pButtonPure, { ...buttonProps, key: "btn-submit", type: "submit", icon: "search", disabled: disabledOrReadOnly, onClick: this.onSubmit }, "Search")) : (validateProps.h(PrefixedTagNames.pIcon, { key: "icon", class: "icon", name: "search", color: "state-disabled", theme: this.theme, "aria-hidden": "true" })),
	            validateProps.h(PrefixedTagNames.pButtonPure, { ...buttonProps, key: "btn-clear", type: "button", icon: "close", tabIndex: -1, hidden: !this.isClearable, disabled: disabledOrReadOnly, onClick: this.onClear }, "Clear field"),
	            this.hasAction && (validateProps.h(PrefixedTagNames.pButtonPure, { ...buttonProps, key: "btn-action", type: "button", icon: "locate", hidden: this.isClearable, disabled: disabledOrReadOnly, onClick: !this.actionLoading ? this.action.emit : null, loading: this.actionLoading }, "Locate me")),
	        ])), validateProps.h(required.StateMessage, { key: '2fb17d15f0ca5e2637fd00c87c2e4c09e5d35891', state: this.state, message: this.message, theme: this.theme, host: this.host })));
	    }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "showCounter": ["onShowCounterChange"]
	    }; }
	};

	pTextFieldWrapper_cjs_entry.p_text_field_wrapper = TextFieldWrapper;

	
	return pTextFieldWrapper_cjs_entry;
}

var pTextList_2_cjs_entry = {};

var hasRequiredPTextList_2_cjs_entry;

function requirePTextList_2_cjs_entry () {
	if (hasRequiredPTextList_2_cjs_entry) return pTextList_2_cjs_entry;
	hasRequiredPTextList_2_cjs_entry = 1;

	Object.defineProperty(pTextList_2_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed0dc3288b();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();
	const throwIfParentIsNotOfKind = requireThrowIfParentIsNotOfKindEb817ad3();
	requireHelperA66adcf2();
	requireTextShared9135e2ef();
	requireFontLineHeight78b03658();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireIsParentOfKindB7d9f81c();

	/** @deprecated */
	const LIST_TYPES = ['unordered', 'ordered'];
	/** @deprecated */
	const ORDER_TYPES = ['numbered', 'alphabetically'];
	const TEXT_LIST_TYPES = ['unordered', 'numbered', 'alphabetically'];
	const isListTypeOrdered = (type) => type !== 'unordered';
	const isListTypeNumbered = (type) => type === 'numbered';

	const cssVariablePaddingTop = '--p-internal-text-list-padding-top';
	const cssVariablePaddingBottom = '--p-internal-text-list-padding-bottom';
	const cssVariablePseudoSpace = '--p-internal-text-list-pseudo-space';
	const cssVariableUnorderedGridColumn = '--p-internal-text-list-unordered-grid-column';
	const cssVariableUnorderedPseudoContent = '--p-internal-text-list-unordered-pseudo-content';
	const cssVariableOrderedGridColumn = '--p-internal-text-list-ordered-grid-column';
	const cssVariableOrderedPseudoSuffix = '--p-internal-text-list-ordered-pseudo-suffix';
	const counter = 'p-text-list-counter';
	const getComponentCss$1 = (type, theme) => {
	    const isOrderedList = isListTypeOrdered(type);
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    counterReset: counter,
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            'ol,ul': {
	                ...textSmallStyle.textSmallStyle,
	                margin: 0,
	                padding: `var(${cssVariablePaddingTop},0) 0 var(${cssVariablePaddingBottom},0) 0`,
	                listStyleType: 'none',
	                color: validateProps.getThemedColors(theme).primaryColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: validateProps.getThemedColors('dark').primaryColor,
	                }),
	            },
	            // css selector for text-list-item
	            '::slotted(*)': validateProps.addImportantToEachRule({
	                [cssVariablePaddingTop]: spacingStaticXSmall.spacingStaticXSmall, // padding top for nested list
	                [cssVariablePaddingBottom]: spacingStaticMedium.spacingStaticMedium, // padding bottom for nested list, TODO: in case it's last root list item with a nested list it would result in outer spacing which is not desired
	                [cssVariablePseudoSpace]: isOrderedList
	                    ? `var(${cssVariableOrderedGridColumn},1.5rem)`
	                    : `var(${cssVariableUnorderedGridColumn},.375rem)`,
	                '&::before': isOrderedList
	                    ? {
	                        content: `counters(${counter},'.',${isListTypeNumbered(type) ? 'decimal' : 'lower-latin'}) var(${cssVariableOrderedPseudoSuffix},'.')`,
	                        counterIncrement: counter,
	                        justifySelf: 'flex-end',
	                        whiteSpace: 'nowrap',
	                    }
	                    : {
	                        content: `var(${cssVariableUnorderedPseudoContent},'•')`,
	                    },
	            }),
	        },
	    });
	};

	const propTypes = {
	    listType: validateProps.AllowedTypes.oneOf([undefined, ...LIST_TYPES]),
	    orderType: validateProps.AllowedTypes.oneOf([undefined, ...ORDER_TYPES]),
	    type: validateProps.AllowedTypes.oneOf(TEXT_LIST_TYPES),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const TextList = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.listType = undefined;
	        this.orderType = undefined;
	        this.type = 'unordered';
	        this.theme = 'light';
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'listType', 'Please use type prop instead.');
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'orderType', 'Please use type prop instead.');
	        validateProps.attachComponentCss(this.host, getComponentCss$1, this.listType === 'ordered' ? this.orderType || 'numbered' : this.type, this.theme);
	        const TagType = isListTypeOrdered(this.listType || this.type) ? 'ol' : 'ul';
	        return (validateProps.h(TagType, { key: 'fe124d601d727f34ebef76d12258d56dadbf1375' }, validateProps.h("slot", { key: '823a57e097870be095ea3c522bff6905a068985f' })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	const getComponentCss = () => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'grid',
	                ...validateProps.addImportantToEachRule({
	                    gridTemplateColumns: `var(${cssVariablePseudoSpace}) 1fr`,
	                    columnGap: spacingStaticMedium.spacingStaticMedium,
	                    font: 'inherit', // ensures style can't be overwritten from outside
	                    color: 'inherit', // ensures style can't be overwritten from outside
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...validateProps.addImportantToEachRule({
	                '::slotted(*)': {
	                    [cssVariableUnorderedGridColumn]: '.625rem', // reserves space for ::before (nested unordered list)
	                    [cssVariableUnorderedPseudoContent]: '"–"', // custom ::before char "–" (nested unordered list)
	                    [cssVariableOrderedGridColumn]: '2rem', // reserves space for ::before (nested ordered list)
	                    [cssVariableOrderedPseudoSuffix]: '""', // don't show ::before suffix "." (nested ordered list)
	                },
	                '::slotted(*:last-child)': {
	                    gridColumn: 2,
	                },
	            }),
	        },
	    });
	};

	const TextListItem = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	    }
	    connectedCallback() {
	        throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-text-list');
	    }
	    render() {
	        validateProps.attachComponentCss(this.host, getComponentCss);
	        return (validateProps.h(validateProps.Host, { key: '2a4426ff1efff041bb50b23144b1d257bcd97f31', role: "listitem" }, validateProps.h("span", { key: '00dffbee29b728707eeffbcc74ef4b5080fce9e2' }, validateProps.h("slot", { key: '42c11bde5b01d62da4bafb3e8c1b7899fbb23acd' }))));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pTextList_2_cjs_entry.p_text_list = TextList;
	pTextList_2_cjs_entry.p_text_list_item = TextListItem;

	
	return pTextList_2_cjs_entry;
}

var pText_cjs_entry = {};

var hasRequiredPText_cjs_entry;

function requirePText_cjs_entry () {
	if (hasRequiredPText_cjs_entry) return pText_cjs_entry;
	hasRequiredPText_cjs_entry = 1;

	Object.defineProperty(pText_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const typographyAlign = requireTypographyAlign25ce02f4();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed2d6d1d94();
	const theme = requireThemeBfc10573();
	const textSize = requireTextSizeBe3fca13();
	const typographyTextColor = requireTypographyTextColor524bae09();
	const typographyTextWeight = requireTypographyTextWeight02ea3596();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const typographyStyles = requireTypographyStyles1a447490();
	const fontWeightStyles = requireFontWeightStylesB74e8683();
	const fontSizeTextXXSmall = requireFontSizeTextXXSmallA02f9c40();
	const fontSizeTextXSmall = requireFontSizeTextXSmallE59d35d7();
	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();
	const fontSizeTextMedium = requireFontSizeTextMedium88887ad8();
	const fontSizeTextLarge = requireFontSizeTextLarge05a4bc90();
	const fontSizeTextXLarge = requireFontSizeTextXLarge0ecf9ef3();
	const textSmallStyle = requireTextSmallStyle7246779a();
	requireGetDirectChildHTMLElementC5dd1dc2();
	requireTransformSelectorToDirectChildSelectorC1b1f9b0();
	requireHelperA66adcf2();
	requireTextIconStyles990609fb();
	requireFontWeightRegularD0c768ac();
	requireFontWeightSemiBold4482c830();
	requireTextShared9135e2ef();
	requireFontLineHeight78b03658();
	requireFontVariant6ba3b7cb();

	const TEXT_TAGS = ['p', 'span', 'div', 'address', 'blockquote', 'figcaption', 'cite', 'time', 'legend'];
	const getTextTagType = (host, tag) => {
	    if (typographyAlign.hasSpecificDirectChildTag(host, TEXT_TAGS.join())) {
	        return 'div';
	    }
	    else {
	        return tag;
	    }
	};

	const sizeMap = {
	    'xx-small': fontSizeTextXXSmall.fontSizeTextXXSmall,
	    'x-small': fontSizeTextXSmall.fontSizeTextXSmall,
	    small: fontSizeTextSmall.fontSizeTextSmall,
	    medium: fontSizeTextMedium.fontSizeTextMedium,
	    large: fontSizeTextLarge.fontSizeTextLarge,
	    'x-large': fontSizeTextXLarge.fontSizeTextXLarge,
	};
	const getComponentCss = (size, weight, align, color, ellipsis, theme) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            [`::slotted(:is(${TEXT_TAGS.join()}))`]: validateProps.addImportantToEachRule(typographyStyles.getTypographySlottedJssStyle()),
	        },
	        root: typographyStyles.getTypographyRootJssStyle(textSmallStyle.textSmallStyle, validateProps.buildResponsiveStyles(size, (sizeValue) => ({
	            fontSize: sizeValue === 'inherit' ? sizeValue : sizeMap[sizeValue],
	            fontWeight: fontWeightStyles.getFontWeight(weight),
	        })), align, color, ellipsis, theme),
	    });
	};

	const propTypes = {
	    tag: validateProps.AllowedTypes.oneOf(TEXT_TAGS),
	    size: validateProps.AllowedTypes.breakpoint(textSize.TEXT_SIZES),
	    weight: validateProps.AllowedTypes.oneOf(typographyTextWeight.TYPOGRAPHY_TEXT_WEIGHTS),
	    align: validateProps.AllowedTypes.oneOf(typographyAlign.TYPOGRAPHY_ALIGNS),
	    color: validateProps.AllowedTypes.oneOf(typographyTextColor.TYPOGRAPHY_TEXT_COLORS),
	    ellipsis: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Text = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.tag = 'p';
	        this.size = 'small';
	        this.weight = 'regular';
	        this.align = 'start';
	        this.color = 'primary';
	        this.ellipsis = false;
	        this.theme = 'light';
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        const colorDeprecationMap = {
	            brand: 'primary',
	            default: 'primary',
	            'neutral-contrast-low': 'contrast-low',
	            'neutral-contrast-medium': 'contrast-medium',
	            'neutral-contrast-high': 'contrast-high',
	            'notification-neutral': 'notification-info',
	        };
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'color', colorDeprecationMap);
	        const weightDeprecationMap = {
	            thin: 'regular',
	            semibold: 'semi-bold',
	        };
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'weight', weightDeprecationMap);
	        const alignDeprecationMap = {
	            left: 'start',
	            right: 'end',
	        };
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'align', alignDeprecationMap);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.size, (weightDeprecationMap[this.weight] || this.weight), (alignDeprecationMap[this.align] || this.align), (colorDeprecationMap[this.color] || this.color), this.ellipsis, this.theme);
	        const TagType = getTextTagType(this.host, this.tag);
	        return (validateProps.h(TagType, { key: '09b0c07a31c3e302a8c70e43600a0d427c836a4d', class: "root" }, validateProps.h("slot", { key: 'be096650e674ba9bf9166ad13283815181bcc796' })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pText_cjs_entry.p_text = Text;

	
	return pText_cjs_entry;
}

var pTextareaWrapper_cjs_entry = {};

var hasRequiredPTextareaWrapper_cjs_entry;

function requirePTextareaWrapper_cjs_entry () {
	if (hasRequiredPTextareaWrapper_cjs_entry) return pTextareaWrapper_cjs_entry;
	hasRequiredPTextareaWrapper_cjs_entry = 1;

	Object.defineProperty(pTextareaWrapper_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const required = requireRequiredF3c463a3();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed0dc3288b();
	const propertyObserver = requirePropertyObserverE214b5c5();
	const theme = requireThemeBfc10573();
	const getOnlyChildOfKindHTMLElementOrThrow = requireGetOnlyChildOfKindHTMLElementOrThrowF7285231();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const formStyles = requireFormStyles7e9d1c43();
	const label = requireLabel5379ea8c();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	requireHasNamedSlotA96fd22a();
	requireGetNamedSlotA0cdbdbc();
	requireHelperA66adcf2();
	requireGetDirectChildHTMLElements31d23fa9();
	requireGetHTMLElements3f1c700f();
	requireTransformSelectorToDirectChildSelectorC1b1f9b0();
	requireHoverMediaQuery5e6deda8();
	requireSpacingStaticSmall2130ed04();
	requireSpacingStaticMedium94812711();
	requireFontLineHeight78b03658();
	requireBorderRadiusSmall5f37fc45();
	requireFontSizeTextXSmallE59d35d7();
	requireGetClosestHTMLElement83d01a84();
	requireHasDescriptionBbe55afe();
	requireIsParentOfKindB7d9f81c();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();

	const spacingStaticLarge = '32px';

	const getComponentCss = (isDisabled, hideLabel, state, hasCounter, theme) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            // ::slotted(textarea)
	            ...validateProps.mergeDeep(validateProps.addImportantToEachRule(formStyles.getSlottedTextFieldTextareaSelectStyles('textarea', state, false, theme, {
	                gridArea: '1/1',
	                // TODO: move into getSlottedTextFieldTextareaSelectStyles()
	                font: textSmallStyle.textSmallStyle.font, // to override line-height
	                // TODO: move into getSlottedTextFieldTextareaSelectStyles()
	                padding: hasCounter
	                    ? `12px ${formStyles.formElementPaddingHorizontal} ${spacingStaticLarge}`
	                    : `12px ${formStyles.formElementPaddingHorizontal}`,
	            })), {
	                // TODO: is it possible to move into getSlottedTextFieldTextareaSelectStyles()?
	                '::slotted(textarea)': {
	                    height: 'auto', // removes !important from getBaseChildStyles
	                    minHeight: '200px', // min-height should be overridable
	                    resize: 'vertical', // overridable, too
	                },
	            }),
	        },
	        root: {
	            display: 'grid',
	            gap: spacingStaticXSmall.spacingStaticXSmall,
	        },
	        wrapper: {
	            display: 'grid',
	        },
	        ...(hasCounter && {
	            counter: {
	                ...formStyles.getUnitCounterJssStyle(isDisabled, theme),
	                gridArea: '1/1',
	                placeSelf: 'flex-end',
	                padding: `6px calc(${formStyles.formElementPaddingHorizontal} + ${validateProps.borderWidthBase})`,
	            },
	            // TODO: maybe we should extract it as functional component too
	            'sr-only': validateProps.getHiddenTextJssStyle(),
	        }),
	        // .label / .required
	        ...label.getFunctionalComponentLabelStyles(isDisabled, hideLabel, theme),
	        // .message
	        ...required.getFunctionalComponentStateMessageStyles(theme, state),
	    });
	};

	const propTypes = {
	    label: validateProps.AllowedTypes.string,
	    description: validateProps.AllowedTypes.string,
	    state: validateProps.AllowedTypes.oneOf(required.FORM_STATES),
	    message: validateProps.AllowedTypes.string,
	    hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	    showCharacterCount: validateProps.AllowedTypes.boolean,
	    showCounter: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const TextareaWrapper = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.observeAttributes = () => {
	            validateProps.observeAttributes(this.textarea, ['disabled', 'readonly', 'required', 'maxlength'], () => {
	                validateProps.forceUpdate(this.host);
	                this.updateCounterVisibility();
	            });
	        };
	        this.updateCounterVisibility = () => {
	            this.hasCounter =
	                validateProps.hasCounter(this.textarea) &&
	                    (typeof this.showCharacterCount === 'undefined' ? this.showCounter : this.showCharacterCount);
	        };
	        this.addInputEventListenerForCounter = (characterCountElement, counterElement, inputChangeCallback) => {
	            validateProps.updateCounter(this.textarea, characterCountElement, counterElement); // Initial value
	            // When value changes programmatically
	            propertyObserver.observeProperties(this.textarea, ['value'], () => {
	                validateProps.updateCounter(this.textarea, characterCountElement, counterElement, inputChangeCallback);
	            });
	            this.eventListener = validateProps.inputEventListenerCurry(characterCountElement, counterElement, inputChangeCallback);
	            this.textarea.removeEventListener('input', this.eventListener);
	            this.textarea.addEventListener('input', this.eventListener);
	        };
	        this.label = '';
	        this.description = '';
	        this.state = 'none';
	        this.message = '';
	        this.hideLabel = false;
	        this.showCharacterCount = undefined;
	        this.showCounter = true;
	        this.theme = 'light';
	    }
	    onShowCounterChange() {
	        this.updateCounterVisibility();
	    }
	    connectedCallback() {
	        this.observeAttributes(); // on every reconnect
	    }
	    componentWillLoad() {
	        this.textarea = getOnlyChildOfKindHTMLElementOrThrow.getOnlyChildOfKindHTMLElementOrThrow(this.host, 'textarea');
	        this.observeAttributes(); // once initially
	        this.updateCounterVisibility();
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    componentDidRender() {
	        if (this.hasCounter) {
	            this.addInputEventListenerForCounter(this.ariaElement, this.counterElement);
	        }
	        /*
	         * This is a workaround to improve accessibility because the textarea and the label/description/message text are placed in different DOM.
	         * Referencing ID's from outside the component is impossible because the web component’s DOM is separate.
	         * We have to wait for full support of the Accessibility Object Model (AOM) to provide the relationship between shadow DOM and slots.
	         */
	        validateProps.setAriaAttributes(this.textarea, {
	            label: this.label,
	            message: this.message || this.description,
	            state: this.state,
	        });
	    }
	    disconnectedCallback() {
	        validateProps.unobserveAttributes(this.textarea);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'showCharacterCount', 'Please use showCounter prop instead.');
	        const { disabled } = this.textarea;
	        validateProps.attachComponentCss(this.host, getComponentCss, disabled, this.hideLabel, this.state, this.hasCounter, this.theme);
	        return (validateProps.h("div", { key: '3c110f602e3d6fa83b208cc0a480aca1f220ebac', class: "root" }, validateProps.h(label.Label, { key: 'a61d20fffdfa8350201d97cbbe960301dba28928', host: this.host, label: this.label, description: this.description, isDisabled: disabled, formElement: this.textarea }), validateProps.h("div", { key: 'cdfd949ae5be24f1ddc8a3f6d7302c09c85a960a', class: "wrapper" }, validateProps.h("slot", { key: 'ad9efc4bfbc0a921f7c395a3f3d0138c259afb89' }), this.hasCounter && validateProps.h("span", { class: "counter", "aria-hidden": "true", ref: (el) => (this.counterElement = el) }), this.hasCounter && validateProps.h("span", { class: "sr-only", ref: (el) => (this.ariaElement = el), "aria-live": "polite" })), validateProps.h(required.StateMessage, { key: '6636805ded43174111a1b351d1feec0af30d37c0', state: this.state, message: this.message, theme: this.theme, host: this.host })));
	    }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "showCounter": ["onShowCounterChange"]
	    }; }
	};

	pTextareaWrapper_cjs_entry.p_textarea_wrapper = TextareaWrapper;

	
	return pTextareaWrapper_cjs_entry;
}

var pToast_2_cjs_entry = {};

var hasRequiredPToast_2_cjs_entry;

function requirePToast_2_cjs_entry () {
	if (hasRequiredPToast_2_cjs_entry) return pToast_2_cjs_entry;
	hasRequiredPToast_2_cjs_entry = 1;

	Object.defineProperty(pToast_2_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const constants = requireConstantsCa271244();
	const gridExtendedOffsetBase = requireGridExtendedOffsetBaseFb9830f6();
	const theme = requireThemeBfc10573();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed2d6d1d94();
	const throwIfRootNodeIsNotOneOfKind = requireThrowIfRootNodeIsNotOneOfKind8d4ae960();
	const inlineNotificationUtils = requireInlineNotificationUtils60940706();
	const dropShadowHighStyle = requireDropShadowHighStyle7edcadc6();
	const textSmallStyle = requireTextSmallStyle7246779a();
	requireHelperA66adcf2();
	requireGetMediaQueryMaxBbf4c490();
	requireSpacingStaticMedium94812711();
	requireBorderRadiusSmall5f37fc45();
	requireSpacingStaticXSmallB7d708b8();
	requireSpacingStaticSmall2130ed04();
	requireBannerUtils2cc83734();
	requireDropShadowShared6e50faf3();
	requireTextShared9135e2ef();
	requireFontLineHeight78b03658();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();

	const cssVariablePositionBottom = '--p-toast-position-bottom'; // CSS custom property exposed as public interface
	const cssVariablePositionBottomInternal = '--p-internal-toast-position-bottom';
	const ANIMATION_DURATION = validateProps.motionDurationModerate;
	const duration = ANIMATION_DURATION;
	const getKeyframes = (direction, outsideStyle) => {
	    const insideStyle = { opacity: 1, transform: 'translate3d(0,0,0)' };
	    return direction === 'in'
	        ? {
	            from: outsideStyle,
	            to: insideStyle,
	        }
	        : {
	            from: insideStyle,
	            to: outsideStyle,
	        };
	};
	const getKeyframesMobile = (direction, bottomVar) => getKeyframes(direction, {
	    opacity: 0,
	    transform: `translate3d(0,calc(var(${bottomVar}) + 100%),0)`, // space before and after "+" is crucial
	});
	const toastCloseClassName = 'close';
	const getComponentCss$1 = () => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': validateProps.addImportantToEachRule({
	                position: 'fixed',
	                insetInline: gridExtendedOffsetBase.gridExtendedOffsetBase,
	                // Needs a not overridable internal css variable to cover default position depending on viewport size and to handle animation properly.
	                // In addition, a public css variable can be passed to overwrite the default position.
	                [cssVariablePositionBottomInternal]: `var(${cssVariablePositionBottom}, 56px)`,
	                bottom: `var(${cssVariablePositionBottomInternal})`,
	                zIndex: constants.TOAST_Z_INDEX,
	                [validateProps.getMediaQueryMin('s')]: {
	                    insetInline: '64px auto',
	                    maxWidth: 'min(42rem, calc(100vw - 64px * 2))',
	                    [cssVariablePositionBottomInternal]: `var(${cssVariablePositionBottom}, 64px)`,
	                    bottom: `var(${cssVariablePositionBottomInternal})`,
	                },
	                ...colorSchemeStyles.colorSchemeStyles,
	                ...colorSchemeStyles.hostHiddenStyles,
	            }),
	            '@keyframes in': getKeyframesMobile('in', cssVariablePositionBottomInternal),
	            '@keyframes out': getKeyframesMobile('out', cssVariablePositionBottomInternal),
	        },
	        hydrated: {
	            animation: `${duration} $in ${validateProps.motionEasingIn} forwards`,
	        },
	        [toastCloseClassName]: {
	            animation: validateProps.addImportantToRule(`${ANIMATION_DURATION} $out ${validateProps.motionEasingOut} forwards`),
	        },
	    });
	};

	const TOAST_DEFAULT_TIMEOUT = 6000;
	const MOTION_DURATION = parseFloat(ANIMATION_DURATION) * 1000;
	class ToastManagerClass {
	    constructor() {
	        this.dismissToastItem = () => {
	            this.removeTimeout();
	            this.message = undefined;
	            this.onDismissCallback();
	            setTimeout(() => validateProps.forceUpdate(this.toastEl), 
	            // respect --p-temporary-toast-timeout css variable to override timeout during e2e and vrt tests
	            MOTION_DURATION
	                );
	        };
	    }
	    register(toastElement, onDismiss) {
	        if (this.toastEl) {
	            validateProps.throwException('p-toast was rendered multiple times.');
	        }
	        this.toastEl = toastElement;
	        this.onDismissCallback = onDismiss;
	    }
	    unregister() {
	        this.toastEl = null;
	        this.message = undefined;
	        this.removeTimeout();
	    }
	    addMessage(message) {
	        if (!this.toastEl) {
	            validateProps.throwException('missing p-toast element.');
	        }
	        if (!message.text) {
	            validateProps.throwException('p-toast empty text provided to addMessage().');
	        }
	        const msg = {
	            state: message.state || 'info', // info is our default state
	            text: message.text.replace(/<(?!br)[^>]*>/g, ''), // strip all html tags except linebreaks
	        };
	        if (!this.message) {
	            validateProps.forceUpdate(this.toastEl);
	        }
	        else if (this.message.text !== message.text) {
	            this.dismissToastItem();
	        }
	        this.message = msg;
	    }
	    getToast() {
	        this.startTimeout();
	        return this.message;
	    }
	    startTimeout() {
	        if (this.message) {
	            {
	                this.timeout = setTimeout(this.dismissToastItem, TOAST_DEFAULT_TIMEOUT);
	            }
	        }
	    }
	    removeTimeout() {
	        clearTimeout(this.timeout);
	        this.timeout = null;
	    }
	}
	const toastManager = new ToastManagerClass();

	const propTypes$1 = {
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Toast = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.theme = 'light';
	    }
	    addMessage(message) {
	        toastManager.addMessage(message);
	    }
	    connectedCallback() {
	        toastManager.register(this.host, () => this.toastItemElement.classList.add(toastCloseClassName));
	    }
	    componentDidLoad() {
	        this.host.addEventListener('dismiss', (e) => {
	            e.stopPropagation(); // to cancel bubbling chain from toast-item
	            toastManager.dismissToastItem();
	        });
	    }
	    componentShouldUpdate(_, __, propName) {
	        return propName !== 'theme';
	    }
	    disconnectedCallback() {
	        toastManager.unregister();
	    }
	    render() {
	        validateProps.validateProps(this, propTypes$1);
	        validateProps.attachComponentCss(this.host, getComponentCss$1);
	        this.toastItemElement?.classList.remove(toastCloseClassName);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        const toast = toastManager.getToast();
	        return (validateProps.h(validateProps.Host, { key: '1b7d7d7b762af1986cdaf114a60428d0043ccdab' }, toast && (validateProps.h(PrefixedTagNames.pToastItem, { ...toast, theme: this.theme, ref: (el) => (this.toastItemElement = el) }))));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	/** @deprecated */
	const TOAST_STATES_DEPRECATED = ['neutral']; // state neutral as default state is deprecated in v3 (new state: 'info')
	const TOAST_STATES = ['info', 'success', ...TOAST_STATES_DEPRECATED];

	const getComponentCss = (state, theme) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'grid',
	                ...inlineNotificationUtils.getNotificationRootJssStyle(state, false, true, theme),
	                ...dropShadowHighStyle.dropShadowHighStyle,
	            },
	            p: {
	                ...textSmallStyle.textSmallStyle,
	                margin: 0,
	                color: validateProps.getThemedColors(theme).primaryColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: validateProps.getThemedColors('dark').primaryColor,
	                }),
	            },
	        },
	        icon: inlineNotificationUtils.getNotificationIconJssStyle(),
	        content: inlineNotificationUtils.getNotificationContentJssStyle(),
	    });
	};

	const propTypes = {
	    text: validateProps.AllowedTypes.string,
	    state: validateProps.AllowedTypes.oneOf(TOAST_STATES),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const ToastItem = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.dismiss = validateProps.createEvent(this, "dismiss", 7);
	        this.text = '';
	        this.state = 'info';
	        this.theme = 'light';
	    }
	    connectedCallback() {
	        throwIfRootNodeIsNotOneOfKind.throwIfRootNodeIsNotOneOfKind(this.host, ['p-toast']);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'state', {
	            neutral: 'info',
	        });
	        validateProps.attachComponentCss(this.host, getComponentCss, this.state, this.theme);
	        const toastId = 'toast';
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(validateProps.Host, { key: 'f9f2fcaf07d4b09dd4f8fa15f7803840e51ff06d' }, validateProps.h(PrefixedTagNames.pIcon, { key: 'bdbdf25fa1e6ad7cedb8010e0dd55e557ac9e98b', class: "icon", name: inlineNotificationUtils.getInlineNotificationIconName(this.state), color: `notification-${this.state}`, theme: this.theme, "aria-hidden": "true" }), validateProps.h("p", { key: 'c496689d997875ecc0631be55024fc8562ff49c1', id: toastId, class: "content", role: "status", "aria-live": "polite", innerHTML: this.text }), validateProps.h(PrefixedTagNames.pButtonPure, { key: 'e44128039d6c8626597713cf5f39f390bc93cc3a', theme: this.theme, class: "close", type: "button", icon: "close", hideLabel: true, "aria-controls": toastId, onClick: this.dismiss.emit }, "Close notification message")));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pToast_2_cjs_entry.p_toast = Toast;
	pToast_2_cjs_entry.p_toast_item = ToastItem;

	
	return pToast_2_cjs_entry;
}

var pWordmark_cjs_entry = {};

var hasRequiredPWordmark_cjs_entry;

function requirePWordmark_cjs_entry () {
	if (hasRequiredPWordmark_cjs_entry) return pWordmark_cjs_entry;
	hasRequiredPWordmark_cjs_entry = 1;

	Object.defineProperty(pWordmark_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const linkAriaAttribute = requireLinkAriaAttribute5de11e89();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();

	const WORDMARK_SIZES = ['small', 'inherit'];

	const getComponentCss = (size, theme) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                position: 'relative',
	                display: 'inline-block',
	                verticalAlign: 'top',
	                ...validateProps.addImportantToEachRule({
	                    outline: 0,
	                    maxWidth: '100%',
	                    maxHeight: '100%',
	                    boxSizing: 'content-box', // needed for correct height calculation when padding is set on host (e.g. custom click area)
	                    ...(size !== 'inherit' && {
	                        height: 'clamp(0.63rem, 0.42vw + 0.5rem, 1rem)',
	                        // workaround for Safari to optimize image rendering
	                        '@supports (height: round(down, 1px, 1px))': {
	                            height: 'round(down, clamp(0.63rem, 0.42vw + 0.5rem, 1rem), 1px)',
	                        },
	                    }),
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            'a, svg': {
	                display: 'block',
	                maxWidth: '100%',
	                maxHeight: '100%',
	                height: 'inherit',
	            },
	            a: {
	                textDecoration: 'none',
	                '&::before': {
	                    // needs to be defined always to have correct custom click area
	                    content: '""',
	                    position: 'absolute',
	                    inset: 0,
	                    borderRadius: '1px',
	                },
	                ...validateProps.getFocusJssStyle('light', { pseudo: true }), // TODO: we need to support theme
	            },
	            svg: validateProps.isHighContrastMode
	                ? {
	                    fill: validateProps.getHighContrastColors().canvasTextColor,
	                }
	                : {
	                    fill: validateProps.getThemedColors(theme).primaryColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        fill: validateProps.getThemedColors('dark').primaryColor,
	                    }),
	                },
	        },
	    });
	};

	const propTypes = {
	    size: validateProps.AllowedTypes.oneOf(WORDMARK_SIZES),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    href: validateProps.AllowedTypes.string,
	    target: validateProps.AllowedTypes.string,
	    aria: validateProps.AllowedTypes.aria(linkAriaAttribute.LINK_ARIA_ATTRIBUTES),
	};
	const Wordmark = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.size = 'small';
	        this.theme = 'light';
	        this.href = undefined;
	        this.target = '_self';
	        this.aria = undefined;
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.size, this.theme);
	        // optimized with SVGO, see docs in assets folder
	        const svg = (validateProps.h("svg", { key: 'c8f8623ad8d033f8de9e245f4f3f74b2e9140a71', xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 4500 300" }, validateProps.h("title", { key: 'd04656613425a352a738223876a22c608dd4f8e0' }, "Porsche"), validateProps.h("path", { key: 'd97e748e559e5353298f1228c9bb4ce4f8ef45f5', d: "M502 221c48.1 0 74-25.9 74-74V74c0-48.1-25.9-74-74-74H0v300h68v-79h434zm6-143v65c0 7.8-4.2 12-12 12H68V66h428c7.8 0 12 4.2 12 12zm228 222c-48.1 0-74-25.9-74-74V74c0-48.1 25.9-74 74-74h417c48.1 0 74 25.9 74 74v152c0 48.1-25.9 74-74 74H736zm411-66c7.8 0 12-4.2 12-12V78c0-7.8-4.2-12-12-12H742c-7.8 0-12 4.2-12 12v144c0 7.8 4.2 12 12 12h405zm675-36c39.844 16.757 67.853 56.1 68 102h-68c0-54-25-79-79-79h-361v79h-68V0h502c48.1 0 74 25.9 74 74v50.14c0 46.06-23.75 71.76-68 73.86zm-12-43c7.8 0 12-4.2 12-12V78c0-7.8-4.2-12-12-12h-428v89h428zm162-81c0-48.1 25.9-74 74-74h492v56h-486c-7.8 0-12 4.2-12 12v42c0 7.8 4.2 12 12 12h422c48.1 0 74 25.9 74 74v30c0 48.1-25.9 74-74 74h-492v-56h486c7.8 0 12-4.2 12-12v-42c0-7.8-4.2-12-12-12h-422c-48.1 0-74-25.9-74-74V74zm661 0c0-48.1 25.9-74 74-74h480v66h-474c-7.8 0-12 4.2-12 12v144c0 7.8 4.2 12 12 12h474v66h-480c-48.1 0-74-25.9-74-74V74zM3817 0v300h-68V183h-407v117h-68V0h68v117h407V0h68zm156 56v66h527v56h-527v66h527v56h-595V0h595v56h-527z" })));
	        return (validateProps.h(validateProps.Host, { key: 'bb0f70332e3796db6f5b61d868fcb57eac77c6e7' }, this.href === undefined ? (svg) : (validateProps.h("a", { href: this.href, target: this.target, ...validateProps.parseAndGetAriaAttributes(this.aria) }, svg))));
	    }
	    static get delegatesFocus() { return true; }
	    get host() { return validateProps.getElement(this); }
	};

	pWordmark_cjs_entry.p_wordmark = Wordmark;

	
	return pWordmark_cjs_entry;
}

var porscheDesignSystem_cjs = {};

var hasRequiredPorscheDesignSystem_cjs;

function requirePorscheDesignSystem_cjs () {
	if (hasRequiredPorscheDesignSystem_cjs) return porscheDesignSystem_cjs;
	hasRequiredPorscheDesignSystem_cjs = 1;

	Object.defineProperty(porscheDesignSystem_cjs, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const appGlobals = requireAppGlobals999bcb42();
	requireGetCDNBaseURLE7722df3();

	/*
	 Stencil Client Patch Browser v4.14.1 | MIT Licensed | https://stenciljs.com
	 */
	const patchBrowser = () => {
	    const importMeta = (typeof document === 'undefined' ? new (createCommonjsRequire("/src/lib")('u' + 'rl').URL)('file:' + __filename).href : (document.currentScript && document.currentScript.src || new URL('porsche-design-system.cjs.js', document.baseURI).href));
	    const opts = {};
	    if (importMeta !== '') {
	        opts.resourcesUrl = new URL('.', importMeta).href;
	    }
	    return validateProps.promiseResolve(opts);
	};

	patchBrowser().then(async (options) => {
	  if(!window.PDS_SKIP_FETCH) { appGlobals.globalScripts(); }
	  return validateProps.bootstrapLazy(JSON.parse("[[\"p-table_7.cjs\",[[1,\"p-table\",{\"caption\":[1],\"theme\":[1]}],[1,\"p-table-body\"],[1,\"p-table-cell\",{\"multiline\":[4]}],[1,\"p-table-head\"],[1,\"p-table-head-cell\",{\"sort\":[16],\"hideLabel\":[4,\"hide-label\"],\"multiline\":[4]}],[1,\"p-table-head-row\"],[1,\"p-table-row\"]]],[\"p-flex_2.cjs\",[[1,\"p-flex\",{\"inline\":[8],\"wrap\":[1],\"direction\":[1],\"justifyContent\":[1,\"justify-content\"],\"alignItems\":[1,\"align-items\"],\"alignContent\":[1,\"align-content\"]}],[1,\"p-flex-item\",{\"width\":[1],\"offset\":[1],\"alignSelf\":[1,\"align-self\"],\"grow\":[8],\"shrink\":[8],\"flex\":[1]}]]],[\"p-flyout-navigation_2.cjs\",[[1,\"p-flyout-navigation\",{\"open\":[4],\"activeIdentifier\":[1,\"active-identifier\"],\"theme\":[1],\"aria\":[1],\"flyoutNavigationItemElements\":[32]},null,{\"open\":[\"openChangeHandler\"]}],[1,\"p-flyout-navigation-item\",{\"label\":[1],\"identifier\":[1]}]]],[\"p-grid_2.cjs\",[[1,\"p-grid\",{\"direction\":[1],\"wrap\":[1],\"gutter\":[8]}],[1,\"p-grid-item\",{\"size\":[8],\"offset\":[8]}]]],[\"p-multi-select_2.cjs\",[[1,\"p-multi-select\",{\"label\":[1],\"description\":[1],\"name\":[1],\"value\":[1040],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"disabled\":[4],\"required\":[4],\"dropdownDirection\":[1,\"dropdown-direction\"],\"theme\":[1],\"isOpen\":[32],\"srHighlightedOptionText\":[32],\"hasFilterResults\":[32]},[[0,\"internalOptionUpdate\",\"updateOptionHandler\"]],{\"value\":[\"onValueChange\"]}],[1,\"p-multi-select-option\",{\"value\":[1],\"disabled\":[4]}]]],[\"p-segmented-control_2.cjs\",[[1,\"p-segmented-control\",{\"backgroundColor\":[1,\"background-color\"],\"theme\":[1],\"value\":[8],\"columns\":[8]}],[17,\"p-segmented-control-item\",{\"value\":[8],\"disabled\":[4],\"label\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"]},[[2,\"click\",\"onClick\"]],{\"label\":[\"handleLabelChange\"],\"icon\":[\"handleLabelChange\"],\"iconSource\":[\"handleLabelChange\"]}]]],[\"p-select-wrapper_2.cjs\",[[1,\"p-select-wrapper\",{\"label\":[1],\"description\":[1],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"filter\":[4],\"theme\":[1],\"dropdownDirection\":[1,\"dropdown-direction\"],\"native\":[4]}],[1,\"p-select-wrapper-dropdown\",{\"selectRef\":[16],\"label\":[1],\"description\":[1],\"message\":[1],\"state\":[1],\"direction\":[1],\"theme\":[1],\"filter\":[4],\"required\":[4],\"disabled\":[4],\"onOpenChange\":[16],\"isOpenOverride\":[4,\"is-open-override\"],\"isOpen\":[32],\"optionMaps\":[32],\"searchString\":[32]}]]],[\"p-select_2.cjs\",[[1,\"p-select\",{\"label\":[1],\"description\":[1],\"name\":[1],\"value\":[1025],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"disabled\":[4],\"required\":[4],\"dropdownDirection\":[1,\"dropdown-direction\"],\"theme\":[1],\"isOpen\":[32],\"srHighlightedOptionText\":[32]},[[0,\"internalOptionUpdate\",\"updateOptionHandler\"]],{\"value\":[\"onValueChange\"]}],[1,\"p-select-option\",{\"value\":[1],\"disabled\":[4]}]]],[\"p-stepper-horizontal_2.cjs\",[[1,\"p-stepper-horizontal\",{\"size\":[1],\"theme\":[1]}],[17,\"p-stepper-horizontal-item\",{\"state\":[1],\"disabled\":[4]},[[2,\"click\",\"onClick\"]],{\"state\":[\"onStateChange\"]}]]],[\"p-tabs_2.cjs\",[[1,\"p-tabs\",{\"size\":[1],\"weight\":[1],\"theme\":[1],\"gradientColorScheme\":[1,\"gradient-color-scheme\"],\"gradientColor\":[1,\"gradient-color\"],\"activeTabIndex\":[1026,\"active-tab-index\"],\"tabsItemElements\":[32]},null,{\"activeTabIndex\":[\"activeTabHandler\"]}],[1,\"p-tabs-item\",{\"label\":[1]},null,{\"label\":[\"handleLabelChange\"]}]]],[\"p-text-list_2.cjs\",[[1,\"p-text-list\",{\"listType\":[1,\"list-type\"],\"orderType\":[1,\"order-type\"],\"type\":[1],\"theme\":[1]}],[1,\"p-text-list-item\"]]],[\"p-toast_2.cjs\",[[1,\"p-toast\",{\"theme\":[1],\"addMessage\":[64]}],[1,\"p-toast-item\",{\"text\":[1],\"state\":[1],\"theme\":[1]}]]],[\"p-accordion.cjs\",[[1,\"p-accordion\",{\"size\":[1],\"theme\":[1],\"heading\":[1],\"headingTag\":[1,\"heading-tag\"],\"tag\":[1],\"open\":[4],\"compact\":[4],\"sticky\":[4]}]]],[\"p-banner.cjs\",[[1,\"p-banner\",{\"open\":[4],\"heading\":[1],\"headingTag\":[1,\"heading-tag\"],\"description\":[1],\"state\":[1],\"dismissButton\":[4,\"dismiss-button\"],\"persistent\":[4],\"width\":[1],\"theme\":[1]},null,{\"open\":[\"openChangeHandler\"]}]]],[\"p-button.cjs\",[[17,\"p-button\",{\"type\":[1],\"name\":[1],\"value\":[1],\"disabled\":[4],\"loading\":[4],\"variant\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"hideLabel\":[8,\"hide-label\"],\"theme\":[1],\"aria\":[1]},[[2,\"click\",\"onClick\"]]]]],[\"p-button-group.cjs\",[[1,\"p-button-group\",{\"direction\":[1]}]]],[\"p-button-pure.cjs\",[[17,\"p-button-pure\",{\"type\":[1],\"name\":[1],\"value\":[1],\"disabled\":[4],\"loading\":[4],\"size\":[1],\"weight\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"underline\":[4],\"active\":[4],\"hideLabel\":[8,\"hide-label\"],\"alignLabel\":[1,\"align-label\"],\"stretch\":[8],\"theme\":[1],\"aria\":[1]},[[2,\"click\",\"onClick\"]]]]],[\"p-button-tile.cjs\",[[17,\"p-button-tile\",{\"size\":[1],\"weight\":[1],\"background\":[1],\"aspectRatio\":[1,\"aspect-ratio\"],\"label\":[1],\"description\":[1],\"align\":[1],\"gradient\":[4],\"compact\":[1032],\"type\":[1],\"disabled\":[4],\"loading\":[4],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"aria\":[1]},[[2,\"click\",\"onClick\"]]]]],[\"p-carousel.cjs\",[[1,\"p-carousel\",{\"heading\":[1],\"headingSize\":[1,\"heading-size\"],\"description\":[1],\"alignHeader\":[1,\"align-header\"],\"rewind\":[4],\"wrapContent\":[4,\"wrap-content\"],\"width\":[1],\"slidesPerPage\":[1032,\"slides-per-page\"],\"disablePagination\":[1032,\"disable-pagination\"],\"pagination\":[1032],\"aria\":[1],\"intl\":[1],\"theme\":[1],\"activeSlideIndex\":[2,\"active-slide-index\"],\"skipLinkTarget\":[1,\"skip-link-target\"],\"amountOfPages\":[32]},null,{\"activeSlideIndex\":[\"activeSlideHandler\"]}]]],[\"p-checkbox-wrapper.cjs\",[[1,\"p-checkbox-wrapper\",{\"label\":[1],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"loading\":[4],\"theme\":[1]},[[0,\"keydown\",\"onKeydown\"]]]]],[\"p-content-wrapper.cjs\",[[1,\"p-content-wrapper\",{\"width\":[1],\"backgroundColor\":[1,\"background-color\"],\"theme\":[1]}]]],[\"p-crest.cjs\",[[17,\"p-crest\",{\"href\":[1],\"target\":[1],\"aria\":[1]}]]],[\"p-display.cjs\",[[1,\"p-display\",{\"tag\":[1],\"size\":[1],\"align\":[1],\"color\":[1],\"ellipsis\":[4],\"theme\":[1]}]]],[\"p-divider.cjs\",[[1,\"p-divider\",{\"color\":[1],\"orientation\":[1],\"direction\":[1],\"theme\":[1]}]]],[\"p-fieldset.cjs\",[[1,\"p-fieldset\",{\"label\":[1],\"labelSize\":[1,\"label-size\"],\"required\":[4],\"state\":[1],\"message\":[1],\"theme\":[1]}]]],[\"p-fieldset-wrapper.cjs\",[[1,\"p-fieldset-wrapper\",{\"label\":[1],\"labelSize\":[1,\"label-size\"],\"required\":[4],\"state\":[1],\"message\":[1],\"theme\":[1]}]]],[\"p-flyout.cjs\",[[1,\"p-flyout\",{\"open\":[4],\"position\":[1],\"theme\":[1],\"aria\":[1]},null,{\"open\":[\"openChangeHandler\"]}]]],[\"p-heading.cjs\",[[1,\"p-heading\",{\"tag\":[1],\"size\":[1],\"align\":[1],\"color\":[1],\"ellipsis\":[4],\"theme\":[1]}]]],[\"p-headline.cjs\",[[1,\"p-headline\",{\"variant\":[1],\"tag\":[1],\"align\":[1],\"color\":[1],\"ellipsis\":[4],\"theme\":[1]}]]],[\"p-icon.cjs\",[[1,\"p-icon\",{\"name\":[1],\"source\":[1],\"color\":[1],\"size\":[1],\"lazy\":[4],\"theme\":[1],\"aria\":[1]}]]],[\"p-inline-notification.cjs\",[[1,\"p-inline-notification\",{\"heading\":[1],\"headingTag\":[1,\"heading-tag\"],\"description\":[1],\"state\":[1],\"dismissButton\":[4,\"dismiss-button\"],\"persistent\":[4],\"actionLabel\":[1,\"action-label\"],\"actionLoading\":[4,\"action-loading\"],\"actionIcon\":[1,\"action-icon\"],\"theme\":[1]}]]],[\"p-link.cjs\",[[17,\"p-link\",{\"variant\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"href\":[1],\"theme\":[1],\"target\":[1],\"download\":[1],\"rel\":[1],\"hideLabel\":[8,\"hide-label\"],\"aria\":[1]}]]],[\"p-link-pure.cjs\",[[17,\"p-link-pure\",{\"alignLabel\":[1,\"align-label\"],\"stretch\":[8],\"size\":[1],\"weight\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"underline\":[4],\"href\":[1],\"active\":[4],\"hideLabel\":[8,\"hide-label\"],\"theme\":[1],\"target\":[1],\"download\":[1],\"rel\":[1],\"aria\":[1]}]]],[\"p-link-social.cjs\",[[17,\"p-link-social\",{\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"href\":[1],\"theme\":[1],\"target\":[1],\"rel\":[1],\"hideLabel\":[8,\"hide-label\"]}]]],[\"p-link-tile.cjs\",[[17,\"p-link-tile\",{\"size\":[1],\"weight\":[1],\"background\":[1],\"aspectRatio\":[1,\"aspect-ratio\"],\"label\":[1],\"description\":[1],\"align\":[1],\"gradient\":[4],\"compact\":[1032],\"href\":[1],\"target\":[1],\"download\":[1],\"rel\":[1],\"aria\":[1]}]]],[\"p-link-tile-model-signature.cjs\",[[1,\"p-link-tile-model-signature\",{\"model\":[1],\"weight\":[1],\"aspectRatio\":[1,\"aspect-ratio\"],\"heading\":[1],\"description\":[1],\"linkDirection\":[1,\"link-direction\"],\"headingTag\":[1,\"heading-tag\"]}]]],[\"p-link-tile-product.cjs\",[[17,\"p-link-tile-product\",{\"heading\":[1],\"price\":[1],\"priceOriginal\":[1,\"price-original\"],\"description\":[1],\"likeButton\":[4,\"like-button\"],\"liked\":[4],\"href\":[1],\"aspectRatio\":[1,\"aspect-ratio\"],\"target\":[1],\"rel\":[1],\"theme\":[1]}]]],[\"p-marque.cjs\",[[17,\"p-marque\",{\"trademark\":[4],\"variant\":[1],\"size\":[1],\"href\":[1],\"target\":[1],\"aria\":[1]}]]],[\"p-modal.cjs\",[[1,\"p-modal\",{\"open\":[4],\"disableCloseButton\":[4,\"disable-close-button\"],\"dismissButton\":[4,\"dismiss-button\"],\"disableBackdropClick\":[4,\"disable-backdrop-click\"],\"heading\":[1],\"backdrop\":[1],\"fullscreen\":[8],\"aria\":[1],\"theme\":[1]},null,{\"open\":[\"openChangeHandler\"]}]]],[\"p-model-signature.cjs\",[[1,\"p-model-signature\",{\"model\":[1],\"safeZone\":[4,\"safe-zone\"],\"fetchPriority\":[1,\"fetch-priority\"],\"lazy\":[4],\"size\":[1],\"color\":[1],\"theme\":[1]}]]],[\"p-pagination.cjs\",[[17,\"p-pagination\",{\"totalItemsCount\":[2,\"total-items-count\"],\"itemsPerPage\":[2,\"items-per-page\"],\"activePage\":[1026,\"active-page\"],\"maxNumberOfPageLinks\":[8,\"max-number-of-page-links\"],\"showLastPage\":[4,\"show-last-page\"],\"allyLabel\":[1,\"ally-label\"],\"allyLabelPrev\":[1,\"ally-label-prev\"],\"allyLabelPage\":[1,\"ally-label-page\"],\"allyLabelNext\":[1,\"ally-label-next\"],\"intl\":[1],\"theme\":[1]}]]],[\"p-pin-code.cjs\",[[1,\"p-pin-code\",{\"label\":[1],\"description\":[1],\"name\":[1],\"length\":[2],\"hideLabel\":[8,\"hide-label\"],\"state\":[1],\"disabled\":[4],\"loading\":[4],\"required\":[4],\"message\":[1],\"type\":[1],\"value\":[1025],\"theme\":[1]}]]],[\"p-popover.cjs\",[[1,\"p-popover\",{\"direction\":[1],\"description\":[1],\"aria\":[1],\"theme\":[1],\"open\":[32]}]]],[\"p-radio-button-wrapper.cjs\",[[1,\"p-radio-button-wrapper\",{\"label\":[1],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"loading\":[4],\"theme\":[1]}]]],[\"p-scroller.cjs\",[[1,\"p-scroller\",{\"gradientColorScheme\":[1,\"gradient-color-scheme\"],\"gradientColor\":[1,\"gradient-color\"],\"scrollToPosition\":[1025,\"scroll-to-position\"],\"scrollIndicatorPosition\":[1,\"scroll-indicator-position\"],\"alignScrollIndicator\":[1,\"align-scroll-indicator\"],\"theme\":[1],\"scrollbar\":[4],\"aria\":[1],\"isPrevHidden\":[32],\"isNextHidden\":[32]},null,{\"scrollToPosition\":[\"scrollToPositionHandler\"]}]]],[\"p-spinner.cjs\",[[1,\"p-spinner\",{\"size\":[1],\"theme\":[1],\"aria\":[1]}]]],[\"p-switch.cjs\",[[17,\"p-switch\",{\"alignLabel\":[1,\"align-label\"],\"hideLabel\":[8,\"hide-label\"],\"stretch\":[8],\"checked\":[4],\"disabled\":[4],\"loading\":[4],\"theme\":[1]},[[2,\"click\",\"onClick\"]]]]],[\"p-tabs-bar.cjs\",[[1,\"p-tabs-bar\",{\"size\":[1],\"weight\":[1],\"theme\":[1],\"gradientColorScheme\":[1,\"gradient-color-scheme\"],\"gradientColor\":[1,\"gradient-color\"],\"activeTabIndex\":[2,\"active-tab-index\"],\"tabElements\":[32]},null,{\"activeTabIndex\":[\"activeTabIndexHandler\"]}]]],[\"p-tag.cjs\",[[1,\"p-tag\",{\"theme\":[1],\"color\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"]}]]],[\"p-tag-dismissible.cjs\",[[17,\"p-tag-dismissible\",{\"color\":[1],\"theme\":[1],\"label\":[1],\"aria\":[1]}]]],[\"p-text.cjs\",[[1,\"p-text\",{\"tag\":[1],\"size\":[1],\"weight\":[1],\"align\":[1],\"color\":[1],\"ellipsis\":[4],\"theme\":[1]}]]],[\"p-text-field-wrapper.cjs\",[[1,\"p-text-field-wrapper\",{\"label\":[1],\"unit\":[1],\"unitPosition\":[1,\"unit-position\"],\"description\":[1],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"showCharacterCount\":[4,\"show-character-count\"],\"showCounter\":[4,\"show-counter\"],\"actionIcon\":[1,\"action-icon\"],\"actionLoading\":[4,\"action-loading\"],\"submitButton\":[4,\"submit-button\"],\"showPasswordToggle\":[4,\"show-password-toggle\"],\"theme\":[1],\"showPassword\":[32],\"isClearable\":[32]},null,{\"showCounter\":[\"onShowCounterChange\"]}]]],[\"p-textarea-wrapper.cjs\",[[1,\"p-textarea-wrapper\",{\"label\":[1],\"description\":[1],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"showCharacterCount\":[4,\"show-character-count\"],\"showCounter\":[4,\"show-counter\"],\"theme\":[1]},null,{\"showCounter\":[\"onShowCounterChange\"]}]]],[\"p-wordmark.cjs\",[[17,\"p-wordmark\",{\"size\":[1],\"theme\":[1],\"href\":[1],\"target\":[1],\"aria\":[1]}]]]]"), options);
	});

	porscheDesignSystem_cjs.setNonce = validateProps.setNonce;

	
	return porscheDesignSystem_cjs;
}

var dynamicModules;

function getDynamicModules() {
	return dynamicModules || (dynamicModules = {
		"/src/index.js": requireSrc,
		"/src/lib/align-label-7a9d9074.js": requireAlignLabel7a9d9074,
		"/src/lib/app-globals-999bcb42.js": requireAppGlobals999bcb42,
		"/src/lib/banner-utils-2cc83734.js": requireBannerUtils2cc83734,
		"/src/lib/borderRadiusLarge-a0aa3a01.js": requireBorderRadiusLargeA0aa3a01,
		"/src/lib/borderRadiusMedium-758b9411.js": requireBorderRadiusMedium758b9411,
		"/src/lib/borderRadiusSmall-5f37fc45.js": requireBorderRadiusSmall5f37fc45,
		"/src/lib/button-handling-b33ae166.js": requireButtonHandlingB33ae166,
		"/src/lib/button-link-pure-utils-1db4d1d1.js": requireButtonLinkPureUtils1db4d1d1,
		"/src/lib/button-type-ae0c09db.js": requireButtonTypeAe0c09db,
		"/src/lib/checkbox-radio-styles-e83cbdf9.js": requireCheckboxRadioStylesE83cbdf9,
		"/src/lib/color-scheme-styles-4bc3d59c.js": requireColorSchemeStyles4bc3d59c,
		"/src/lib/constants-ca271244.js": requireConstantsCa271244,
		"/src/lib/displayShared-43dd15a5.js": requireDisplayShared43dd15a5,
		"/src/lib/dropShadowHighStyle-7edcadc6.js": requireDropShadowHighStyle7edcadc6,
		"/src/lib/dropShadowShared-6e50faf3.js": requireDropShadowShared6e50faf3,
		"/src/lib/escapeHashCharacter-b9f68bcf.js": requireEscapeHashCharacterB9f68bcf,
		"/src/lib/fieldset-utils-a0590284.js": requireFieldsetUtilsA0590284,
		"/src/lib/flyout-dialog-reset-styles-a29edb86.js": requireFlyoutDialogResetStylesA29edb86,
		"/src/lib/font-weight-styles-b74e8683.js": requireFontWeightStylesB74e8683,
		"/src/lib/fontLineHeight-78b03658.js": requireFontLineHeight78b03658,
		"/src/lib/fontSizeHeadingLarge-c355151d.js": requireFontSizeHeadingLargeC355151d,
		"/src/lib/fontSizeHeadingMedium-c49ab5a2.js": requireFontSizeHeadingMediumC49ab5a2,
		"/src/lib/fontSizeHeadingSmall-a15141a5.js": requireFontSizeHeadingSmallA15141a5,
		"/src/lib/fontSizeText-728b6387.js": requireFontSizeText728b6387,
		"/src/lib/fontSizeTextLarge-05a4bc90.js": requireFontSizeTextLarge05a4bc90,
		"/src/lib/fontSizeTextMedium-88887ad8.js": requireFontSizeTextMedium88887ad8,
		"/src/lib/fontSizeTextSmall-508930e5.js": requireFontSizeTextSmall508930e5,
		"/src/lib/fontSizeTextXLarge-0ecf9ef3.js": requireFontSizeTextXLarge0ecf9ef3,
		"/src/lib/fontSizeTextXSmall-e59d35d7.js": requireFontSizeTextXSmallE59d35d7,
		"/src/lib/fontSizeTextXXSmall-a02f9c40.js": requireFontSizeTextXXSmallA02f9c40,
		"/src/lib/fontVariant-6ba3b7cb.js": requireFontVariant6ba3b7cb,
		"/src/lib/fontWeightRegular-d0c768ac.js": requireFontWeightRegularD0c768ac,
		"/src/lib/fontWeightSemiBold-4482c830.js": requireFontWeightSemiBold4482c830,
		"/src/lib/form-styles-7e9d1c43.js": requireFormStyles7e9d1c43,
		"/src/lib/get-button-base-aria-attributes-2b382c95.js": requireGetButtonBaseAriaAttributes2b382c95,
		"/src/lib/get-native-popover-dropdown-position-06475061.js": requireGetNativePopoverDropdownPosition06475061,
		"/src/lib/getAttribute-9c66ed26.js": requireGetAttribute9c66ed26,
		"/src/lib/getCDNBaseURL-e7722df3.js": requireGetCDNBaseURLE7722df3,
		"/src/lib/getClickedItem-db2d9f29.js": requireGetClickedItemDb2d9f29,
		"/src/lib/getClosestHTMLElement-83d01a84.js": requireGetClosestHTMLElement83d01a84,
		"/src/lib/getDirectChildHTMLElement-c5dd1dc2.js": requireGetDirectChildHTMLElementC5dd1dc2,
		"/src/lib/getDirectChildHTMLElements-31d23fa9.js": requireGetDirectChildHTMLElements31d23fa9,
		"/src/lib/getHTMLElements-3f1c700f.js": requireGetHTMLElements3f1c700f,
		"/src/lib/getMediaQueryMax-bbf4c490.js": requireGetMediaQueryMaxBbf4c490,
		"/src/lib/getNamedSlot-a0cdbdbc.js": requireGetNamedSlotA0cdbdbc,
		"/src/lib/getOnlyChildOfKindHTMLElementOrThrow-f7285231.js": requireGetOnlyChildOfKindHTMLElementOrThrowF7285231,
		"/src/lib/gridBasicOffset-eafb13d6.js": requireGridBasicOffsetEafb13d6,
		"/src/lib/gridExtendedOffsetBase-fb9830f6.js": requireGridExtendedOffsetBaseFb9830f6,
		"/src/lib/gridExtendedOffsetXXL-c7a41e50.js": requireGridExtendedOffsetXXLC7a41e50,
		"/src/lib/gridGap-b5b73e4a.js": requireGridGapB5b73e4a,
		"/src/lib/group-direction-styles-c4bd8b11.js": requireGroupDirectionStylesC4bd8b11,
		"/src/lib/has-document-079654e6.js": requireHasDocument079654e6,
		"/src/lib/hasAttribute-bf22c03a.js": requireHasAttributeBf22c03a,
		"/src/lib/hasDescription-bbe55afe.js": requireHasDescriptionBbe55afe,
		"/src/lib/hasHeading-6f9fd2ca.js": requireHasHeading6f9fd2ca,
		"/src/lib/hasNamedSlot-a96fd22a.js": requireHasNamedSlotA96fd22a,
		"/src/lib/heading-tag-6cfe20fe.js": requireHeadingTag6cfe20fe,
		"/src/lib/headingMediumStyle-1c9f0c45.js": requireHeadingMediumStyle1c9f0c45,
		"/src/lib/headingShared-aa59e66d.js": requireHeadingSharedAa59e66d,
		"/src/lib/headingSmallStyle-0707b97f.js": requireHeadingSmallStyle0707b97f,
		"/src/lib/headingXXLargeStyle-139a1eb3.js": requireHeadingXXLargeStyle139a1eb3,
		"/src/lib/helper-a66adcf2.js": requireHelperA66adcf2,
		"/src/lib/hover-media-query-5e6deda8.js": requireHoverMediaQuery5e6deda8,
		"/src/lib/index.cjs.js": requireIndex_cjs,
		"/src/lib/initial-loading-controller-44585a09.js": requireInitialLoadingController44585a09,
		"/src/lib/inline-notification-utils-60940706.js": requireInlineNotificationUtils60940706,
		"/src/lib/is-ssr-hydration-9278b79b.js": requireIsSsrHydration9278b79b,
		"/src/lib/isDisabledOrLoading-b1f56d7f.js": requireIsDisabledOrLoadingB1f56d7f,
		"/src/lib/isParentOfKind-b7d9f81c.js": requireIsParentOfKindB7d9f81c,
		"/src/lib/isWithinForm-3637a500.js": requireIsWithinForm3637a500,
		"/src/lib/label-5379ea8c.js": requireLabel5379ea8c,
		"/src/lib/link-aria-attribute-5de11e89.js": requireLinkAriaAttribute5de11e89,
		"/src/lib/link-button-pure-styles-67cba12c.js": requireLinkButtonPureStyles67cba12c,
		"/src/lib/link-button-styles-aafed6b0.js": requireLinkButtonStylesAafed6b0,
		"/src/lib/link-button-variant-3104b925.js": requireLinkButtonVariant3104b925,
		"/src/lib/link-styles-a7b4953d.js": requireLinkStylesA7b4953d,
		"/src/lib/link-tile-utils-f366cfed.js": requireLinkTileUtilsF366cfed,
		"/src/lib/loader.cjs.js": requireLoader_cjs,
		"/src/lib/modal-flyout-utils-950041a2.js": requireModalFlyoutUtils950041a2,
		"/src/lib/p-accordion.cjs.entry.js": requirePAccordion_cjs_entry,
		"/src/lib/p-banner.cjs.entry.js": requirePBanner_cjs_entry,
		"/src/lib/p-button-group.cjs.entry.js": requirePButtonGroup_cjs_entry,
		"/src/lib/p-button-pure.cjs.entry.js": requirePButtonPure_cjs_entry,
		"/src/lib/p-button-tile.cjs.entry.js": requirePButtonTile_cjs_entry,
		"/src/lib/p-button.cjs.entry.js": requirePButton_cjs_entry,
		"/src/lib/p-carousel.cjs.entry.js": requirePCarousel_cjs_entry,
		"/src/lib/p-checkbox-wrapper.cjs.entry.js": requirePCheckboxWrapper_cjs_entry,
		"/src/lib/p-content-wrapper.cjs.entry.js": requirePContentWrapper_cjs_entry,
		"/src/lib/p-crest.cjs.entry.js": requirePCrest_cjs_entry,
		"/src/lib/p-display.cjs.entry.js": requirePDisplay_cjs_entry,
		"/src/lib/p-divider.cjs.entry.js": requirePDivider_cjs_entry,
		"/src/lib/p-fieldset-wrapper.cjs.entry.js": requirePFieldsetWrapper_cjs_entry,
		"/src/lib/p-fieldset.cjs.entry.js": requirePFieldset_cjs_entry,
		"/src/lib/p-flex_2.cjs.entry.js": requirePFlex_2_cjs_entry,
		"/src/lib/p-flyout-navigation_2.cjs.entry.js": requirePFlyoutNavigation_2_cjs_entry,
		"/src/lib/p-flyout.cjs.entry.js": requirePFlyout_cjs_entry,
		"/src/lib/p-grid_2.cjs.entry.js": requirePGrid_2_cjs_entry,
		"/src/lib/p-heading.cjs.entry.js": requirePHeading_cjs_entry,
		"/src/lib/p-headline.cjs.entry.js": requirePHeadline_cjs_entry,
		"/src/lib/p-icon.cjs.entry.js": requirePIcon_cjs_entry,
		"/src/lib/p-inline-notification.cjs.entry.js": requirePInlineNotification_cjs_entry,
		"/src/lib/p-link-pure.cjs.entry.js": requirePLinkPure_cjs_entry,
		"/src/lib/p-link-social.cjs.entry.js": requirePLinkSocial_cjs_entry,
		"/src/lib/p-link-tile-model-signature.cjs.entry.js": requirePLinkTileModelSignature_cjs_entry,
		"/src/lib/p-link-tile-product.cjs.entry.js": requirePLinkTileProduct_cjs_entry,
		"/src/lib/p-link-tile.cjs.entry.js": requirePLinkTile_cjs_entry,
		"/src/lib/p-link.cjs.entry.js": requirePLink_cjs_entry,
		"/src/lib/p-marque.cjs.entry.js": requirePMarque_cjs_entry,
		"/src/lib/p-modal.cjs.entry.js": requirePModal_cjs_entry,
		"/src/lib/p-model-signature.cjs.entry.js": requirePModelSignature_cjs_entry,
		"/src/lib/p-multi-select_2.cjs.entry.js": requirePMultiSelect_2_cjs_entry,
		"/src/lib/p-pagination.cjs.entry.js": requirePPagination_cjs_entry,
		"/src/lib/p-pin-code.cjs.entry.js": requirePPinCode_cjs_entry,
		"/src/lib/p-popover.cjs.entry.js": requirePPopover_cjs_entry,
		"/src/lib/p-radio-button-wrapper.cjs.entry.js": requirePRadioButtonWrapper_cjs_entry,
		"/src/lib/p-scroller.cjs.entry.js": requirePScroller_cjs_entry,
		"/src/lib/p-segmented-control_2.cjs.entry.js": requirePSegmentedControl_2_cjs_entry,
		"/src/lib/p-select_2.cjs.entry.js": requirePSelect_2_cjs_entry,
		"/src/lib/p-select-wrapper_2.cjs.entry.js": requirePSelectWrapper_2_cjs_entry,
		"/src/lib/p-spinner.cjs.entry.js": requirePSpinner_cjs_entry,
		"/src/lib/p-stepper-horizontal_2.cjs.entry.js": requirePStepperHorizontal_2_cjs_entry,
		"/src/lib/p-switch.cjs.entry.js": requirePSwitch_cjs_entry,
		"/src/lib/p-table_7.cjs.entry.js": requirePTable_7_cjs_entry,
		"/src/lib/p-tabs_2.cjs.entry.js": requirePTabs_2_cjs_entry,
		"/src/lib/p-tabs-bar.cjs.entry.js": requirePTabsBar_cjs_entry,
		"/src/lib/p-tag-dismissible.cjs.entry.js": requirePTagDismissible_cjs_entry,
		"/src/lib/p-tag.cjs.entry.js": requirePTag_cjs_entry,
		"/src/lib/p-text-field-wrapper.cjs.entry.js": requirePTextFieldWrapper_cjs_entry,
		"/src/lib/p-text-list_2.cjs.entry.js": requirePTextList_2_cjs_entry,
		"/src/lib/p-text.cjs.entry.js": requirePText_cjs_entry,
		"/src/lib/p-textarea-wrapper.cjs.entry.js": requirePTextareaWrapper_cjs_entry,
		"/src/lib/p-toast_2.cjs.entry.js": requirePToast_2_cjs_entry,
		"/src/lib/p-wordmark.cjs.entry.js": requirePWordmark_cjs_entry,
		"/src/lib/placeholder-e6dd9abf.js": requirePlaceholderE6dd9abf,
		"/src/lib/popover-reset-styles-fad56b6d.js": requirePopoverResetStylesFad56b6d,
		"/src/lib/porsche-design-system.cjs.js": requirePorscheDesignSystem_cjs,
		"/src/lib/property-observer-e214b5c5.js": requirePropertyObserverE214b5c5,
		"/src/lib/required-f3c463a3.js": requireRequiredF3c463a3,
		"/src/lib/schemed-high-contrast-media-query-462417a0.js": requireSchemedHighContrastMediaQuery462417a0,
		"/src/lib/scroller-popover-utils-89485ebc.js": requireScrollerPopoverUtils89485ebc,
		"/src/lib/scrolling-7e2aff99.js": requireScrolling7e2aff99,
		"/src/lib/setAttributes-642a7e67.js": requireSetAttributes642a7e67,
		"/src/lib/setScrollLock-68edfbd1.js": requireSetScrollLock68edfbd1,
		"/src/lib/spacingFluidLarge-6087a0f7.js": requireSpacingFluidLarge6087a0f7,
		"/src/lib/spacingFluidMedium-88ab712b.js": requireSpacingFluidMedium88ab712b,
		"/src/lib/spacingFluidSmall-2c6caae7.js": requireSpacingFluidSmall2c6caae7,
		"/src/lib/spacingFluidXSmall-0dd753ae.js": requireSpacingFluidXSmall0dd753ae,
		"/src/lib/spacingStaticMedium-94812711.js": requireSpacingStaticMedium94812711,
		"/src/lib/spacingStaticSmall-2130ed04.js": requireSpacingStaticSmall2130ed04,
		"/src/lib/spacingStaticXSmall-b7d708b8.js": requireSpacingStaticXSmallB7d708b8,
		"/src/lib/tabs-bar-utils-981cace8.js": requireTabsBarUtils981cace8,
		"/src/lib/tag-shared-utils-369a2a7e.js": requireTagSharedUtils369a2a7e,
		"/src/lib/text-icon-styles-990609fb.js": requireTextIconStyles990609fb,
		"/src/lib/text-size-be3fca13.js": requireTextSizeBe3fca13,
		"/src/lib/textShared-9135e2ef.js": requireTextShared9135e2ef,
		"/src/lib/textSmallStyle-7246779a.js": requireTextSmallStyle7246779a,
		"/src/lib/textXSmallStyle-1145ee25.js": requireTextXSmallStyle1145ee25,
		"/src/lib/theme-bfc10573.js": requireThemeBfc10573,
		"/src/lib/throwIfChildrenAreNotOfKind-81b825bd.js": requireThrowIfChildrenAreNotOfKind81b825bd,
		"/src/lib/throwIfElementIsNotOfKind-4014bcee.js": requireThrowIfElementIsNotOfKind4014bcee,
		"/src/lib/throwIfInvalidLinkUsage-cf66fcfc.js": requireThrowIfInvalidLinkUsageCf66fcfc,
		"/src/lib/throwIfParentIsNotOfKind-eb817ad3.js": requireThrowIfParentIsNotOfKindEb817ad3,
		"/src/lib/throwIfRootNodeIsNotOneOfKind-8d4ae960.js": requireThrowIfRootNodeIsNotOneOfKind8d4ae960,
		"/src/lib/tile-base-styles-0dff2b0f.js": requireTileBaseStyles0dff2b0f,
		"/src/lib/transformSelectorToDirectChildSelector-c1b1f9b0.js": requireTransformSelectorToDirectChildSelectorC1b1f9b0,
		"/src/lib/typography-align-25ce02f4.js": requireTypographyAlign25ce02f4,
		"/src/lib/typography-styles-1a447490.js": requireTypographyStyles1a447490,
		"/src/lib/typography-text-color-524bae09.js": requireTypographyTextColor524bae09,
		"/src/lib/typography-text-weight-02ea3596.js": requireTypographyTextWeight02ea3596,
		"/src/lib/validateProps-f6586828.js": requireValidatePropsF6586828,
		"/src/lib/warnIfDeprecatedComponentIsUsed-6c2a81ac.js": requireWarnIfDeprecatedComponentIsUsed6c2a81ac,
		"/src/lib/warnIfDeprecatedPropIsUsed-0dc3288b.js": requireWarnIfDeprecatedPropIsUsed0dc3288b,
		"/src/lib/warnIfDeprecatedPropValueIsUsed-2d6d1d94.js": requireWarnIfDeprecatedPropValueIsUsed2d6d1d94
	});
}

function createCommonjsRequire(originalModuleDir) {
	function handleRequire(path) {
		var resolvedPath = commonjsResolve(path, originalModuleDir);
		if (resolvedPath !== null) {
			return getDynamicModules()[resolvedPath]();
		}
		throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
	}
	handleRequire.resolve = function (path) {
		var resolvedPath = commonjsResolve(path, originalModuleDir);
		if (resolvedPath !== null) {
			return resolvedPath;
		}
		return require.resolve(path);
	};
	return handleRequire;
}

function commonjsResolve (path, originalModuleDir) {
	var shouldTryNodeModules = isPossibleNodeModulesPath(path);
	path = normalize(path);
	var relPath;
	if (path[0] === '/') {
		originalModuleDir = '';
	}
	var modules = getDynamicModules();
	var checkedExtensions = ['', '.js', '.json'];
	while (true) {
		if (!shouldTryNodeModules) {
			relPath = normalize(originalModuleDir + '/' + path);
		} else {
			relPath = normalize(originalModuleDir + '/node_modules/' + path);
		}

		if (relPath.endsWith('/..')) {
			break; // Travelled too far up, avoid infinite loop
		}

		for (var extensionIndex = 0; extensionIndex < checkedExtensions.length; extensionIndex++) {
			var resolvedPath = relPath + checkedExtensions[extensionIndex];
			if (modules[resolvedPath]) {
				return resolvedPath;
			}
		}
		if (!shouldTryNodeModules) break;
		var nextDir = normalize(originalModuleDir + '/..');
		if (nextDir === originalModuleDir) break;
		originalModuleDir = nextDir;
	}
	return null;
}

function isPossibleNodeModulesPath (modulePath) {
	var c0 = modulePath[0];
	if (c0 === '/' || c0 === '\\') return false;
	var c1 = modulePath[1], c2 = modulePath[2];
	if ((c0 === '.' && (!c1 || c1 === '/' || c1 === '\\')) ||
		(c0 === '.' && c1 === '.' && (!c2 || c2 === '/' || c2 === '\\'))) return false;
	if (c1 === ':' && (c2 === '/' || c2 === '\\')) return false;
	return true;
}

function normalize (path) {
	path = path.replace(/\\/g, '/');
	var parts = path.split('/');
	var slashed = parts[0] === '';
	for (var i = 1; i < parts.length; i++) {
		if (parts[i] === '.' || parts[i] === '') {
			parts.splice(i--, 1);
		}
	}
	for (var i = 1; i < parts.length; i++) {
		if (parts[i] !== '..') continue;
		if (i > 0 && parts[i - 1] !== '..' && parts[i - 1] !== '.') {
			parts.splice(--i, 2);
			i--;
		}
	}
	path = parts.join('/');
	if (slashed && path[0] !== '/') path = '/' + path;
	else if (path.length === 0) path = '.';
	return path;
}

var validatePropsF6586828 = {};

var hasRequiredValidatePropsF6586828;

function requireValidatePropsF6586828 () {
	if (hasRequiredValidatePropsF6586828) return validatePropsF6586828;
	hasRequiredValidatePropsF6586828 = 1;
	(function (exports) {

		function _interopNamespace(e) {
		  if (e && e.__esModule) return e;
		  var n = Object.create(null);
		  if (e) {
		    Object.keys(e).forEach(function (k) {
		      if (k !== 'default') {
		        var d = Object.getOwnPropertyDescriptor(e, k);
		        Object.defineProperty(n, k, d.get ? d : {
		          enumerable: true,
		          get: function () {
		            return e[k];
		          }
		        });
		      }
		    });
		  }
		  n['default'] = e;
		  return Object.freeze(n);
		}

		const NAMESPACE = 'porsche-design-system';

		/**
		 * Virtual DOM patching algorithm based on Snabbdom by
		 * Simon Friis Vindum (@paldepind)
		 * Licensed under the MIT License
		 * https://github.com/snabbdom/snabbdom/blob/master/LICENSE
		 *
		 * Modified for Stencil's renderer and slot projection
		 */
		let scopeId;
		let hostTagName;
		let useNativeShadowDom = false;
		let isSvgMode = false;
		let queuePending = false;
		const createTime = (fnName, tagName = '') => {
		    {
		        return () => {
		            return;
		        };
		    }
		};
		const uniqueTime = (key, measureText) => {
		    {
		        return () => {
		            return;
		        };
		    }
		};
		/**
		 * Constant for styles to be globally applied to `slot-fb` elements for pseudo-slot behavior.
		 *
		 * Two cascading rules must be used instead of a `:not()` selector due to Stencil browser
		 * support as of Stencil v4.
		 */
		const SLOT_FB_CSS = 'slot-fb{display:contents}slot-fb[hidden]{display:none}';
		const XLINK_NS = 'http://www.w3.org/1999/xlink';
		/**
		 * Default style mode id
		 */
		/**
		 * Reusable empty obj/array
		 * Don't add values to these!!
		 */
		const EMPTY_OBJ = {};
		/**
		 * Namespaces
		 */
		const SVG_NS = 'http://www.w3.org/2000/svg';
		const HTML_NS = 'http://www.w3.org/1999/xhtml';
		const isDef = (v) => v != null;
		/**
		 * Check whether a value is a 'complex type', defined here as an object or a
		 * function.
		 *
		 * @param o the value to check
		 * @returns whether it's a complex type or not
		 */
		const isComplexType = (o) => {
		    // https://jsperf.com/typeof-fn-object/5
		    o = typeof o;
		    return o === 'object' || o === 'function';
		};
		/**
		 * Helper method for querying a `meta` tag that contains a nonce value
		 * out of a DOM's head.
		 *
		 * @param doc The DOM containing the `head` to query against
		 * @returns The content of the meta tag representing the nonce value, or `undefined` if no tag
		 * exists or the tag has no content.
		 */
		function queryNonceMetaTagContent(doc) {
		    var _a, _b, _c;
		    return (_c = (_b = (_a = doc.head) === null || _a === void 0 ? void 0 : _a.querySelector('meta[name="csp-nonce"]')) === null || _b === void 0 ? void 0 : _b.getAttribute('content')) !== null && _c !== void 0 ? _c : undefined;
		}
		/**
		 * Production h() function based on Preact by
		 * Jason Miller (@developit)
		 * Licensed under the MIT License
		 * https://github.com/developit/preact/blob/master/LICENSE
		 *
		 * Modified for Stencil's compiler and vdom
		 */
		// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;
		// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;
		const h = (nodeName, vnodeData, ...children) => {
		    let child = null;
		    let key = null;
		    let simple = false;
		    let lastSimple = false;
		    const vNodeChildren = [];
		    const walk = (c) => {
		        for (let i = 0; i < c.length; i++) {
		            child = c[i];
		            if (Array.isArray(child)) {
		                walk(child);
		            }
		            else if (child != null && typeof child !== 'boolean') {
		                if ((simple = typeof nodeName !== 'function' && !isComplexType(child))) {
		                    child = String(child);
		                }
		                if (simple && lastSimple) {
		                    // If the previous child was simple (string), we merge both
		                    vNodeChildren[vNodeChildren.length - 1].$text$ += child;
		                }
		                else {
		                    // Append a new vNode, if it's text, we create a text vNode
		                    vNodeChildren.push(simple ? newVNode(null, child) : child);
		                }
		                lastSimple = simple;
		            }
		        }
		    };
		    walk(children);
		    if (vnodeData) {
		        if (vnodeData.key) {
		            key = vnodeData.key;
		        }
		        // normalize class / className attributes
		        {
		            const classData = vnodeData.className || vnodeData.class;
		            if (classData) {
		                vnodeData.class =
		                    typeof classData !== 'object'
		                        ? classData
		                        : Object.keys(classData)
		                            .filter((k) => classData[k])
		                            .join(' ');
		            }
		        }
		    }
		    if (typeof nodeName === 'function') {
		        // nodeName is a functional component
		        return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils);
		    }
		    const vnode = newVNode(nodeName, null);
		    vnode.$attrs$ = vnodeData;
		    if (vNodeChildren.length > 0) {
		        vnode.$children$ = vNodeChildren;
		    }
		    {
		        vnode.$key$ = key;
		    }
		    return vnode;
		};
		/**
		 * A utility function for creating a virtual DOM node from a tag and some
		 * possible text content.
		 *
		 * @param tag the tag for this element
		 * @param text possible text content for the node
		 * @returns a newly-minted virtual DOM node
		 */
		const newVNode = (tag, text) => {
		    const vnode = {
		        $flags$: 0,
		        $tag$: tag,
		        $text$: text,
		        $elm$: null,
		        $children$: null,
		    };
		    {
		        vnode.$attrs$ = null;
		    }
		    {
		        vnode.$key$ = null;
		    }
		    return vnode;
		};
		const Host = {};
		/**
		 * Check whether a given node is a Host node or not
		 *
		 * @param node the virtual DOM node to check
		 * @returns whether it's a Host node or not
		 */
		const isHost = (node) => node && node.$tag$ === Host;
		/**
		 * Implementation of {@link d.FunctionalUtilities} for Stencil's VDom.
		 *
		 * Note that these functions convert from {@link d.VNode} to
		 * {@link d.ChildNode} to give functional component developers a friendly
		 * interface.
		 */
		const vdomFnUtils = {
		    forEach: (children, cb) => children.map(convertToPublic).forEach(cb),
		    map: (children, cb) => children.map(convertToPublic).map(cb).map(convertToPrivate),
		};
		/**
		 * Convert a {@link d.VNode} to a {@link d.ChildNode} in order to present a
		 * friendlier public interface (hence, 'convertToPublic').
		 *
		 * @param node the virtual DOM node to convert
		 * @returns a converted child node
		 */
		const convertToPublic = (node) => ({
		    vattrs: node.$attrs$,
		    vchildren: node.$children$,
		    vkey: node.$key$,
		    vname: node.$name$,
		    vtag: node.$tag$,
		    vtext: node.$text$,
		});
		/**
		 * Convert a {@link d.ChildNode} back to an equivalent {@link d.VNode} in
		 * order to use the resulting object in the virtual DOM. The initial object was
		 * likely created as part of presenting a public API, so converting it back
		 * involved making it 'private' again (hence, `convertToPrivate`).
		 *
		 * @param node the child node to convert
		 * @returns a converted virtual DOM node
		 */
		const convertToPrivate = (node) => {
		    if (typeof node.vtag === 'function') {
		        const vnodeData = Object.assign({}, node.vattrs);
		        if (node.vkey) {
		            vnodeData.key = node.vkey;
		        }
		        if (node.vname) {
		            vnodeData.name = node.vname;
		        }
		        return h(node.vtag, vnodeData, ...(node.vchildren || []));
		    }
		    const vnode = newVNode(node.vtag, node.vtext);
		    vnode.$attrs$ = node.vattrs;
		    vnode.$children$ = node.vchildren;
		    vnode.$key$ = node.vkey;
		    vnode.$name$ = node.vname;
		    return vnode;
		};
		/**
		 * Parse a new property value for a given property type.
		 *
		 * While the prop value can reasonably be expected to be of `any` type as far as TypeScript's type checker is concerned,
		 * it is not safe to assume that the string returned by evaluating `typeof propValue` matches:
		 *   1. `any`, the type given to `propValue` in the function signature
		 *   2. the type stored from `propType`.
		 *
		 * This function provides the capability to parse/coerce a property's value to potentially any other JavaScript type.
		 *
		 * Property values represented in TSX preserve their type information. In the example below, the number 0 is passed to
		 * a component. This `propValue` will preserve its type information (`typeof propValue === 'number'`). Note that is
		 * based on the type of the value being passed in, not the type declared of the class member decorated with `@Prop`.
		 * ```tsx
		 * <my-cmp prop-val={0}></my-cmp>
		 * ```
		 *
		 * HTML prop values on the other hand, will always a string
		 *
		 * @param propValue the new value to coerce to some type
		 * @param propType the type of the prop, expressed as a binary number
		 * @returns the parsed/coerced value
		 */
		const parsePropertyValue = (propValue, propType) => {
		    // ensure this value is of the correct prop type
		    if (propValue != null && !isComplexType(propValue)) {
		        if (propType & 4 /* MEMBER_FLAGS.Boolean */) {
		            // per the HTML spec, any string value means it is a boolean true value
		            // but we'll cheat here and say that the string "false" is the boolean false
		            return propValue === 'false' ? false : propValue === '' || !!propValue;
		        }
		        if (propType & 2 /* MEMBER_FLAGS.Number */) {
		            // force it to be a number
		            return parseFloat(propValue);
		        }
		        if (propType & 1 /* MEMBER_FLAGS.String */) {
		            // could have been passed as a number or boolean
		            // but we still want it as a string
		            return String(propValue);
		        }
		        // redundant return here for better minification
		        return propValue;
		    }
		    // not sure exactly what type we want
		    // so no need to change to a different type
		    return propValue;
		};
		const getElement = (ref) => (getHostRef(ref).$hostElement$ );
		const createEvent = (ref, name, flags) => {
		    const elm = getElement(ref);
		    return {
		        emit: (detail) => {
		            return emitEvent(elm, name, {
		                bubbles: !!(flags & 4 /* EVENT_FLAGS.Bubbles */),
		                composed: !!(flags & 2 /* EVENT_FLAGS.Composed */),
		                cancelable: !!(flags & 1 /* EVENT_FLAGS.Cancellable */),
		                detail,
		            });
		        },
		    };
		};
		/**
		 * Helper function to create & dispatch a custom Event on a provided target
		 * @param elm the target of the Event
		 * @param name the name to give the custom Event
		 * @param opts options for configuring a custom Event
		 * @returns the custom Event
		 */
		const emitEvent = (elm, name, opts) => {
		    const ev = plt.ce(name, opts);
		    elm.dispatchEvent(ev);
		    return ev;
		};
		/**
		 * Production setAccessor() function based on Preact by
		 * Jason Miller (@developit)
		 * Licensed under the MIT License
		 * https://github.com/developit/preact/blob/master/LICENSE
		 *
		 * Modified for Stencil's compiler and vdom
		 */
		/**
		 * When running a VDom render set properties present on a VDom node onto the
		 * corresponding HTML element.
		 *
		 * Note that this function has special functionality for the `class`,
		 * `style`, `key`, and `ref` attributes, as well as event handlers (like
		 * `onClick`, etc). All others are just passed through as-is.
		 *
		 * @param elm the HTMLElement onto which attributes should be set
		 * @param memberName the name of the attribute to set
		 * @param oldValue the old value for the attribute
		 * @param newValue the new value for the attribute
		 * @param isSvg whether we're in an svg context or not
		 * @param flags bitflags for Vdom variables
		 */
		const setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {
		    if (oldValue !== newValue) {
		        let isProp = isMemberInElement(elm, memberName);
		        let ln = memberName.toLowerCase();
		        if (memberName === 'class') {
		            const classList = elm.classList;
		            const oldClasses = parseClassList(oldValue);
		            const newClasses = parseClassList(newValue);
		            classList.remove(...oldClasses.filter((c) => c && !newClasses.includes(c)));
		            classList.add(...newClasses.filter((c) => c && !oldClasses.includes(c)));
		        }
		        else if (memberName === 'style') {
		            // update style attribute, css properties and values
		            {
		                for (const prop in oldValue) {
		                    if (!newValue || newValue[prop] == null) {
		                        if (prop.includes('-')) {
		                            elm.style.removeProperty(prop);
		                        }
		                        else {
		                            elm.style[prop] = '';
		                        }
		                    }
		                }
		            }
		            for (const prop in newValue) {
		                if (!oldValue || newValue[prop] !== oldValue[prop]) {
		                    if (prop.includes('-')) {
		                        elm.style.setProperty(prop, newValue[prop]);
		                    }
		                    else {
		                        elm.style[prop] = newValue[prop];
		                    }
		                }
		            }
		        }
		        else if (memberName === 'key')
		            ;
		        else if (memberName === 'ref') {
		            // minifier will clean this up
		            if (newValue) {
		                newValue(elm);
		            }
		        }
		        else if ((!isProp ) &&
		            memberName[0] === 'o' &&
		            memberName[1] === 'n') {
		            // Event Handlers
		            // so if the member name starts with "on" and the 3rd characters is
		            // a capital letter, and it's not already a member on the element,
		            // then we're assuming it's an event listener
		            if (memberName[2] === '-') {
		                // on- prefixed events
		                // allows to be explicit about the dom event to listen without any magic
		                // under the hood:
		                // <my-cmp on-click> // listens for "click"
		                // <my-cmp on-Click> // listens for "Click"
		                // <my-cmp on-ionChange> // listens for "ionChange"
		                // <my-cmp on-EVENTS> // listens for "EVENTS"
		                memberName = memberName.slice(3);
		            }
		            else if (isMemberInElement(win, ln)) {
		                // standard event
		                // the JSX attribute could have been "onMouseOver" and the
		                // member name "onmouseover" is on the window's prototype
		                // so let's add the listener "mouseover", which is all lowercased
		                memberName = ln.slice(2);
		            }
		            else {
		                // custom event
		                // the JSX attribute could have been "onMyCustomEvent"
		                // so let's trim off the "on" prefix and lowercase the first character
		                // and add the listener "myCustomEvent"
		                // except for the first character, we keep the event name case
		                memberName = ln[2] + memberName.slice(3);
		            }
		            if (oldValue || newValue) {
		                // Need to account for "capture" events.
		                // If the event name ends with "Capture", we'll update the name to remove
		                // the "Capture" suffix and make sure the event listener is setup to handle the capture event.
		                const capture = memberName.endsWith(CAPTURE_EVENT_SUFFIX);
		                // Make sure we only replace the last instance of "Capture"
		                memberName = memberName.replace(CAPTURE_EVENT_REGEX, '');
		                if (oldValue) {
		                    plt.rel(elm, memberName, oldValue, capture);
		                }
		                if (newValue) {
		                    plt.ael(elm, memberName, newValue, capture);
		                }
		            }
		        }
		        else {
		            // Set property if it exists and it's not a SVG
		            const isComplex = isComplexType(newValue);
		            if ((isProp || (isComplex && newValue !== null)) && !isSvg) {
		                try {
		                    if (!elm.tagName.includes('-')) {
		                        const n = newValue == null ? '' : newValue;
		                        // Workaround for Safari, moving the <input> caret when re-assigning the same valued
		                        if (memberName === 'list') {
		                            isProp = false;
		                        }
		                        else if (oldValue == null || elm[memberName] != n) {
		                            elm[memberName] = n;
		                        }
		                    }
		                    else {
		                        elm[memberName] = newValue;
		                    }
		                }
		                catch (e) {
		                    /**
		                     * in case someone tries to set a read-only property, e.g. "namespaceURI", we just ignore it
		                     */
		                }
		            }
		            /**
		             * Need to manually update attribute if:
		             * - memberName is not an attribute
		             * - if we are rendering the host element in order to reflect attribute
		             * - if it's a SVG, since properties might not work in <svg>
		             * - if the newValue is null/undefined or 'false'.
		             */
		            let xlink = false;
		            {
		                if (ln !== (ln = ln.replace(/^xlink\:?/, ''))) {
		                    memberName = ln;
		                    xlink = true;
		                }
		            }
		            if (newValue == null || newValue === false) {
		                if (newValue !== false || elm.getAttribute(memberName) === '') {
		                    if (xlink) {
		                        elm.removeAttributeNS(XLINK_NS, memberName);
		                    }
		                    else {
		                        elm.removeAttribute(memberName);
		                    }
		                }
		            }
		            else if ((!isProp || flags & 4 /* VNODE_FLAGS.isHost */ || isSvg) && !isComplex) {
		                newValue = newValue === true ? '' : newValue;
		                if (xlink) {
		                    elm.setAttributeNS(XLINK_NS, memberName, newValue);
		                }
		                else {
		                    elm.setAttribute(memberName, newValue);
		                }
		            }
		        }
		    }
		};
		const parseClassListRegex = /\s/;
		/**
		 * Parsed a string of classnames into an array
		 * @param value className string, e.g. "foo bar baz"
		 * @returns list of classes, e.g. ["foo", "bar", "baz"]
		 */
		const parseClassList = (value) => (!value ? [] : value.split(parseClassListRegex));
		const CAPTURE_EVENT_SUFFIX = 'Capture';
		const CAPTURE_EVENT_REGEX = new RegExp(CAPTURE_EVENT_SUFFIX + '$');
		const updateElement = (oldVnode, newVnode, isSvgMode, memberName) => {
		    // if the element passed in is a shadow root, which is a document fragment
		    // then we want to be adding attrs/props to the shadow root's "host" element
		    // if it's not a shadow root, then we add attrs/props to the same element
		    const elm = newVnode.$elm$.nodeType === 11 /* NODE_TYPE.DocumentFragment */ && newVnode.$elm$.host
		        ? newVnode.$elm$.host
		        : newVnode.$elm$;
		    const oldVnodeAttrs = (oldVnode && oldVnode.$attrs$) || EMPTY_OBJ;
		    const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;
		    {
		        // remove attributes no longer present on the vnode by setting them to undefined
		        for (memberName of sortedAttrNames(Object.keys(oldVnodeAttrs))) {
		            if (!(memberName in newVnodeAttrs)) {
		                setAccessor(elm, memberName, oldVnodeAttrs[memberName], undefined, isSvgMode, newVnode.$flags$);
		            }
		        }
		    }
		    // add new & update changed attributes
		    for (memberName of sortedAttrNames(Object.keys(newVnodeAttrs))) {
		        setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode, newVnode.$flags$);
		    }
		};
		/**
		 * Sort a list of attribute names to ensure that all the attribute names which
		 * are _not_ `"ref"` come before `"ref"`. Preserve the order of the non-ref
		 * attributes.
		 *
		 * **Note**: if the supplied attributes do not include `'ref'` then the same
		 * (by reference) array will be returned without modification.
		 *
		 * @param attrNames attribute names to sort
		 * @returns a list of attribute names, sorted if they include `"ref"`
		 */
		function sortedAttrNames(attrNames) {
		    return attrNames.includes('ref')
		        ? // we need to sort these to ensure that `'ref'` is the last attr
		            [...attrNames.filter((attr) => attr !== 'ref'), 'ref']
		        : // no need to sort, return the original array
		            attrNames;
		}
		/**
		 * Create a DOM Node corresponding to one of the children of a given VNode.
		 *
		 * @param oldParentVNode the parent VNode from the previous render
		 * @param newParentVNode the parent VNode from the current render
		 * @param childIndex the index of the VNode, in the _new_ parent node's
		 * children, for which we will create a new DOM node
		 * @param parentElm the parent DOM node which our new node will be a child of
		 * @returns the newly created node
		 */
		const createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {
		    // tslint:disable-next-line: prefer-const
		    const newVNode = newParentVNode.$children$[childIndex];
		    let i = 0;
		    let elm;
		    let childNode;
		    if (newVNode.$text$ !== null) {
		        // create text node
		        elm = newVNode.$elm$ = doc.createTextNode(newVNode.$text$);
		    }
		    else {
		        if (!isSvgMode) {
		            isSvgMode = newVNode.$tag$ === 'svg';
		        }
		        // create element
		        elm = newVNode.$elm$ = (doc.createElementNS(isSvgMode ? SVG_NS : HTML_NS, newVNode.$tag$)
		            );
		        if (isSvgMode && newVNode.$tag$ === 'foreignObject') {
		            isSvgMode = false;
		        }
		        // add css classes, attrs, props, listeners, etc.
		        {
		            updateElement(null, newVNode, isSvgMode);
		        }
		        if (isDef(scopeId) && elm['s-si'] !== scopeId) {
		            // if there is a scopeId and this is the initial render
		            // then let's add the scopeId as a css class
		            elm.classList.add((elm['s-si'] = scopeId));
		        }
		        if (newVNode.$children$) {
		            for (i = 0; i < newVNode.$children$.length; ++i) {
		                // create the node
		                childNode = createElm(oldParentVNode, newVNode, i);
		                // return node could have been null
		                if (childNode) {
		                    // append our new node
		                    elm.appendChild(childNode);
		                }
		            }
		        }
		        {
		            if (newVNode.$tag$ === 'svg') {
		                // Only reset the SVG context when we're exiting <svg> element
		                isSvgMode = false;
		            }
		            else if (elm.tagName === 'foreignObject') {
		                // Reenter SVG context when we're exiting <foreignObject> element
		                isSvgMode = true;
		            }
		        }
		    }
		    // This needs to always happen so we can hide nodes that are projected
		    // to another component but don't end up in a slot
		    elm['s-hn'] = hostTagName;
		    return elm;
		};
		/**
		 * Create DOM nodes corresponding to a list of {@link d.Vnode} objects and
		 * add them to the DOM in the appropriate place.
		 *
		 * @param parentElm the DOM node which should be used as a parent for the new
		 * DOM nodes
		 * @param before a child of the `parentElm` which the new children should be
		 * inserted before (optional)
		 * @param parentVNode the parent virtual DOM node
		 * @param vnodes the new child virtual DOM nodes to produce DOM nodes for
		 * @param startIdx the index in the child virtual DOM nodes at which to start
		 * creating DOM nodes (inclusive)
		 * @param endIdx the index in the child virtual DOM nodes at which to stop
		 * creating DOM nodes (inclusive)
		 */
		const addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {
		    let containerElm = (parentElm);
		    let childNode;
		    if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {
		        containerElm = containerElm.shadowRoot;
		    }
		    for (; startIdx <= endIdx; ++startIdx) {
		        if (vnodes[startIdx]) {
		            childNode = createElm(null, parentVNode, startIdx);
		            if (childNode) {
		                vnodes[startIdx].$elm$ = childNode;
		                containerElm.insertBefore(childNode, before);
		            }
		        }
		    }
		};
		/**
		 * Remove the DOM elements corresponding to a list of {@link d.VNode} objects.
		 * This can be used to, for instance, clean up after a list of children which
		 * should no longer be shown.
		 *
		 * This function also handles some of Stencil's slot relocation logic.
		 *
		 * @param vnodes a list of virtual DOM nodes to remove
		 * @param startIdx the index at which to start removing nodes (inclusive)
		 * @param endIdx the index at which to stop removing nodes (inclusive)
		 */
		const removeVnodes = (vnodes, startIdx, endIdx) => {
		    for (let index = startIdx; index <= endIdx; ++index) {
		        const vnode = vnodes[index];
		        if (vnode) {
		            const elm = vnode.$elm$;
		            nullifyVNodeRefs(vnode);
		            if (elm) {
		                // remove the vnode's element from the dom
		                elm.remove();
		            }
		        }
		    }
		};
		/**
		 * Reconcile the children of a new VNode with the children of an old VNode by
		 * traversing the two collections of children, identifying nodes that are
		 * conserved or changed, calling out to `patch` to make any necessary
		 * updates to the DOM, and rearranging DOM nodes as needed.
		 *
		 * The algorithm for reconciling children works by analyzing two 'windows' onto
		 * the two arrays of children (`oldCh` and `newCh`). We keep track of the
		 * 'windows' by storing start and end indices and references to the
		 * corresponding array entries. Initially the two 'windows' are basically equal
		 * to the entire array, but we progressively narrow the windows until there are
		 * no children left to update by doing the following:
		 *
		 * 1. Skip any `null` entries at the beginning or end of the two arrays, so
		 *    that if we have an initial array like the following we'll end up dealing
		 *    only with a window bounded by the highlighted elements:
		 *
		 *    [null, null, VNode1 , ... , VNode2, null, null]
		 *                 ^^^^^^         ^^^^^^
		 *
		 * 2. Check to see if the elements at the head and tail positions are equal
		 *    across the windows. This will basically detect elements which haven't
		 *    been added, removed, or changed position, i.e. if you had the following
		 *    VNode elements (represented as HTML):
		 *
		 *    oldVNode: `<div><p><span>HEY</span></p></div>`
		 *    newVNode: `<div><p><span>THERE</span></p></div>`
		 *
		 *    Then when comparing the children of the `<div>` tag we check the equality
		 *    of the VNodes corresponding to the `<p>` tags and, since they are the
		 *    same tag in the same position, we'd be able to avoid completely
		 *    re-rendering the subtree under them with a new DOM element and would just
		 *    call out to `patch` to handle reconciling their children and so on.
		 *
		 * 3. Check, for both windows, to see if the element at the beginning of the
		 *    window corresponds to the element at the end of the other window. This is
		 *    a heuristic which will let us identify _some_ situations in which
		 *    elements have changed position, for instance it _should_ detect that the
		 *    children nodes themselves have not changed but merely moved in the
		 *    following example:
		 *
		 *    oldVNode: `<div><element-one /><element-two /></div>`
		 *    newVNode: `<div><element-two /><element-one /></div>`
		 *
		 *    If we find cases like this then we also need to move the concrete DOM
		 *    elements corresponding to the moved children to write the re-order to the
		 *    DOM.
		 *
		 * 4. Finally, if VNodes have the `key` attribute set on them we check for any
		 *    nodes in the old children which have the same key as the first element in
		 *    our window on the new children. If we find such a node we handle calling
		 *    out to `patch`, moving relevant DOM nodes, and so on, in accordance with
		 *    what we find.
		 *
		 * Finally, once we've narrowed our 'windows' to the point that either of them
		 * collapse (i.e. they have length 0) we then handle any remaining VNode
		 * insertion or deletion that needs to happen to get a DOM state that correctly
		 * reflects the new child VNodes. If, for instance, after our window on the old
		 * children has collapsed we still have more nodes on the new children that
		 * we haven't dealt with yet then we need to add them, or if the new children
		 * collapse but we still have unhandled _old_ children then we need to make
		 * sure the corresponding DOM nodes are removed.
		 *
		 * @param parentElm the node into which the parent VNode is rendered
		 * @param oldCh the old children of the parent node
		 * @param newVNode the new VNode which will replace the parent
		 * @param newCh the new children of the parent node
		 * @param isInitialRender whether or not this is the first render of the vdom
		 */
		const updateChildren = (parentElm, oldCh, newVNode, newCh, isInitialRender = false) => {
		    let oldStartIdx = 0;
		    let newStartIdx = 0;
		    let idxInOld = 0;
		    let i = 0;
		    let oldEndIdx = oldCh.length - 1;
		    let oldStartVnode = oldCh[0];
		    let oldEndVnode = oldCh[oldEndIdx];
		    let newEndIdx = newCh.length - 1;
		    let newStartVnode = newCh[0];
		    let newEndVnode = newCh[newEndIdx];
		    let node;
		    let elmToMove;
		    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
		        if (oldStartVnode == null) {
		            // VNode might have been moved left
		            oldStartVnode = oldCh[++oldStartIdx];
		        }
		        else if (oldEndVnode == null) {
		            oldEndVnode = oldCh[--oldEndIdx];
		        }
		        else if (newStartVnode == null) {
		            newStartVnode = newCh[++newStartIdx];
		        }
		        else if (newEndVnode == null) {
		            newEndVnode = newCh[--newEndIdx];
		        }
		        else if (isSameVnode(oldStartVnode, newStartVnode, isInitialRender)) {
		            // if the start nodes are the same then we should patch the new VNode
		            // onto the old one, and increment our `newStartIdx` and `oldStartIdx`
		            // indices to reflect that. We don't need to move any DOM Nodes around
		            // since things are matched up in order.
		            patch(oldStartVnode, newStartVnode, isInitialRender);
		            oldStartVnode = oldCh[++oldStartIdx];
		            newStartVnode = newCh[++newStartIdx];
		        }
		        else if (isSameVnode(oldEndVnode, newEndVnode, isInitialRender)) {
		            // likewise, if the end nodes are the same we patch new onto old and
		            // decrement our end indices, and also likewise in this case we don't
		            // need to move any DOM Nodes.
		            patch(oldEndVnode, newEndVnode, isInitialRender);
		            oldEndVnode = oldCh[--oldEndIdx];
		            newEndVnode = newCh[--newEndIdx];
		        }
		        else if (isSameVnode(oldStartVnode, newEndVnode, isInitialRender)) {
		            patch(oldStartVnode, newEndVnode, isInitialRender);
		            // We need to move the element for `oldStartVnode` into a position which
		            // will be appropriate for `newEndVnode`. For this we can use
		            // `.insertBefore` and `oldEndVnode.$elm$.nextSibling`. If there is a
		            // sibling for `oldEndVnode.$elm$` then we want to move the DOM node for
		            // `oldStartVnode` between `oldEndVnode` and it's sibling, like so:
		            //
		            // <old-start-node />
		            // <some-intervening-node />
		            // <old-end-node />
		            // <!-- ->              <-- `oldStartVnode.$elm$` should be inserted here
		            // <next-sibling />
		            //
		            // If instead `oldEndVnode.$elm$` has no sibling then we just want to put
		            // the node for `oldStartVnode` at the end of the children of
		            // `parentElm`. Luckily, `Node.nextSibling` will return `null` if there
		            // aren't any siblings, and passing `null` to `Node.insertBefore` will
		            // append it to the children of the parent element.
		            parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
		            oldStartVnode = oldCh[++oldStartIdx];
		            newEndVnode = newCh[--newEndIdx];
		        }
		        else if (isSameVnode(oldEndVnode, newStartVnode, isInitialRender)) {
		            patch(oldEndVnode, newStartVnode, isInitialRender);
		            // We've already checked above if `oldStartVnode` and `newStartVnode` are
		            // the same node, so since we're here we know that they are not. Thus we
		            // can move the element for `oldEndVnode` _before_ the element for
		            // `oldStartVnode`, leaving `oldStartVnode` to be reconciled in the
		            // future.
		            parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);
		            oldEndVnode = oldCh[--oldEndIdx];
		            newStartVnode = newCh[++newStartIdx];
		        }
		        else {
		            // Here we do some checks to match up old and new nodes based on the
		            // `$key$` attribute, which is set by putting a `key="my-key"` attribute
		            // in the JSX for a DOM element in the implementation of a Stencil
		            // component.
		            //
		            // First we check to see if there are any nodes in the array of old
		            // children which have the same key as the first node in the new
		            // children.
		            idxInOld = -1;
		            {
		                for (i = oldStartIdx; i <= oldEndIdx; ++i) {
		                    if (oldCh[i] && oldCh[i].$key$ !== null && oldCh[i].$key$ === newStartVnode.$key$) {
		                        idxInOld = i;
		                        break;
		                    }
		                }
		            }
		            if (idxInOld >= 0) {
		                // We found a node in the old children which matches up with the first
		                // node in the new children! So let's deal with that
		                elmToMove = oldCh[idxInOld];
		                if (elmToMove.$tag$ !== newStartVnode.$tag$) {
		                    // the tag doesn't match so we'll need a new DOM element
		                    node = createElm(oldCh && oldCh[newStartIdx], newVNode, idxInOld);
		                }
		                else {
		                    patch(elmToMove, newStartVnode, isInitialRender);
		                    // invalidate the matching old node so that we won't try to update it
		                    // again later on
		                    oldCh[idxInOld] = undefined;
		                    node = elmToMove.$elm$;
		                }
		                newStartVnode = newCh[++newStartIdx];
		            }
		            else {
		                // We either didn't find an element in the old children that matches
		                // the key of the first new child OR the build is not using `key`
		                // attributes at all. In either case we need to create a new element
		                // for the new node.
		                node = createElm(oldCh && oldCh[newStartIdx], newVNode, newStartIdx);
		                newStartVnode = newCh[++newStartIdx];
		            }
		            if (node) {
		                // if we created a new node then handle inserting it to the DOM
		                {
		                    oldStartVnode.$elm$.parentNode.insertBefore(node, oldStartVnode.$elm$);
		                }
		            }
		        }
		    }
		    if (oldStartIdx > oldEndIdx) {
		        // we have some more new nodes to add which don't match up with old nodes
		        addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode, newCh, newStartIdx, newEndIdx);
		    }
		    else if (newStartIdx > newEndIdx) {
		        // there are nodes in the `oldCh` array which no longer correspond to nodes
		        // in the new array, so lets remove them (which entails cleaning up the
		        // relevant DOM nodes)
		        removeVnodes(oldCh, oldStartIdx, oldEndIdx);
		    }
		};
		/**
		 * Compare two VNodes to determine if they are the same
		 *
		 * **NB**: This function is an equality _heuristic_ based on the available
		 * information set on the two VNodes and can be misleading under certain
		 * circumstances. In particular, if the two nodes do not have `key` attrs
		 * (available under `$key$` on VNodes) then the function falls back on merely
		 * checking that they have the same tag.
		 *
		 * So, in other words, if `key` attrs are not set on VNodes which may be
		 * changing order within a `children` array or something along those lines then
		 * we could obtain a false negative and then have to do needless re-rendering
		 * (i.e. we'd say two VNodes aren't equal when in fact they should be).
		 *
		 * @param leftVNode the first VNode to check
		 * @param rightVNode the second VNode to check
		 * @param isInitialRender whether or not this is the first render of the vdom
		 * @returns whether they're equal or not
		 */
		const isSameVnode = (leftVNode, rightVNode, isInitialRender = false) => {
		    // compare if two vnode to see if they're "technically" the same
		    // need to have the same element tag, and same key to be the same
		    if (leftVNode.$tag$ === rightVNode.$tag$) {
		        // this will be set if JSX tags in the build have `key` attrs set on them
		        // we only want to check this if we're not on the first render since on
		        // first render `leftVNode.$key$` will always be `null`, so we can be led
		        // astray and, for instance, accidentally delete a DOM node that we want to
		        // keep around.
		        if (!isInitialRender) {
		            return leftVNode.$key$ === rightVNode.$key$;
		        }
		        return true;
		    }
		    return false;
		};
		/**
		 * Handle reconciling an outdated VNode with a new one which corresponds to
		 * it. This function handles flushing updates to the DOM and reconciling the
		 * children of the two nodes (if any).
		 *
		 * @param oldVNode an old VNode whose DOM element and children we want to update
		 * @param newVNode a new VNode representing an updated version of the old one
		 * @param isInitialRender whether or not this is the first render of the vdom
		 */
		const patch = (oldVNode, newVNode, isInitialRender = false) => {
		    const elm = (newVNode.$elm$ = oldVNode.$elm$);
		    const oldChildren = oldVNode.$children$;
		    const newChildren = newVNode.$children$;
		    const tag = newVNode.$tag$;
		    const text = newVNode.$text$;
		    if (text === null) {
		        {
		            // test if we're rendering an svg element, or still rendering nodes inside of one
		            // only add this to the when the compiler sees we're using an svg somewhere
		            isSvgMode = tag === 'svg' ? true : tag === 'foreignObject' ? false : isSvgMode;
		        }
		        {
		            if (tag === 'slot' && !useNativeShadowDom) ;
		            else {
		                // either this is the first render of an element OR it's an update
		                // AND we already know it's possible it could have changed
		                // this updates the element's css classes, attrs, props, listeners, etc.
		                updateElement(oldVNode, newVNode, isSvgMode);
		            }
		        }
		        if (oldChildren !== null && newChildren !== null) {
		            // looks like there's child vnodes for both the old and new vnodes
		            // so we need to call `updateChildren` to reconcile them
		            updateChildren(elm, oldChildren, newVNode, newChildren, isInitialRender);
		        }
		        else if (newChildren !== null) {
		            // no old child vnodes, but there are new child vnodes to add
		            if (oldVNode.$text$ !== null) {
		                // the old vnode was text, so be sure to clear it out
		                elm.textContent = '';
		            }
		            // add the new vnode children
		            addVnodes(elm, null, newVNode, newChildren, 0, newChildren.length - 1);
		        }
		        else if (oldChildren !== null) {
		            // no new child vnodes, but there are old child vnodes to remove
		            removeVnodes(oldChildren, 0, oldChildren.length - 1);
		        }
		        if (isSvgMode && tag === 'svg') {
		            isSvgMode = false;
		        }
		    }
		    else if (oldVNode.$text$ !== text) {
		        // update the text content for the text only vnode
		        // and also only if the text is different than before
		        elm.data = text;
		    }
		};
		/**
		 * 'Nullify' any VDom `ref` callbacks on a VDom node or its children by calling
		 * them with `null`. This signals that the DOM element corresponding to the VDom
		 * node has been removed from the DOM.
		 *
		 * @param vNode a virtual DOM node
		 */
		const nullifyVNodeRefs = (vNode) => {
		    {
		        vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);
		        vNode.$children$ && vNode.$children$.map(nullifyVNodeRefs);
		    }
		};
		/**
		 * The main entry point for Stencil's virtual DOM-based rendering engine
		 *
		 * Given a {@link d.HostRef} container and some virtual DOM nodes, this
		 * function will handle creating a virtual DOM tree with a single root, patching
		 * the current virtual DOM tree onto an old one (if any), dealing with slot
		 * relocation, and reflecting attributes.
		 *
		 * @param hostRef data needed to root and render the virtual DOM tree, such as
		 * the DOM node into which it should be rendered.
		 * @param renderFnResults the virtual DOM nodes to be rendered
		 * @param isInitialLoad whether or not this is the first call after page load
		 */
		const renderVdom = (hostRef, renderFnResults, isInitialLoad = false) => {
		    const hostElm = hostRef.$hostElement$;
		    const cmpMeta = hostRef.$cmpMeta$;
		    const oldVNode = hostRef.$vnode$ || newVNode(null, null);
		    // if `renderFnResults` is a Host node then we can use it directly. If not,
		    // we need to call `h` again to wrap the children of our component in a
		    // 'dummy' Host node (well, an empty vnode) since `renderVdom` assumes
		    // implicitly that the top-level vdom node is 1) an only child and 2)
		    // contains attrs that need to be set on the host element.
		    const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);
		    hostTagName = hostElm.tagName;
		    // On the first render and *only* on the first render we want to check for
		    // any attributes set on the host element which are also set on the vdom
		    // node. If we find them, we override the value on the VDom node attrs with
		    // the value from the host element, which allows developers building apps
		    // with Stencil components to override e.g. the `role` attribute on a
		    // component even if it's already set on the `Host`.
		    if (isInitialLoad && rootVnode.$attrs$) {
		        for (const key of Object.keys(rootVnode.$attrs$)) {
		            // We have a special implementation in `setAccessor` for `style` and
		            // `class` which reconciles values coming from the VDom with values
		            // already present on the DOM element, so we don't want to override those
		            // attributes on the VDom tree with values from the host element if they
		            // are present.
		            //
		            // Likewise, `ref` and `key` are special internal values for the Stencil
		            // runtime and we don't want to override those either.
		            if (hostElm.hasAttribute(key) && !['key', 'ref', 'style', 'class'].includes(key)) {
		                rootVnode.$attrs$[key] = hostElm[key];
		            }
		        }
		    }
		    rootVnode.$tag$ = null;
		    rootVnode.$flags$ |= 4 /* VNODE_FLAGS.isHost */;
		    hostRef.$vnode$ = rootVnode;
		    rootVnode.$elm$ = oldVNode.$elm$ = (hostElm.shadowRoot || hostElm );
		    {
		        scopeId = hostElm['s-sc'];
		    }
		    useNativeShadowDom = (cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) !== 0;
		    // synchronous patch
		    patch(oldVNode, rootVnode, isInitialLoad);
		};
		const attachToAncestor = (hostRef, ancestorComponent) => {
		    if (ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent['s-p']) {
		        ancestorComponent['s-p'].push(new Promise((r) => (hostRef.$onRenderResolve$ = r)));
		    }
		};
		const scheduleUpdate = (hostRef, isInitialLoad) => {
		    {
		        hostRef.$flags$ |= 16 /* HOST_FLAGS.isQueuedForUpdate */;
		    }
		    if (hostRef.$flags$ & 4 /* HOST_FLAGS.isWaitingForChildren */) {
		        hostRef.$flags$ |= 512 /* HOST_FLAGS.needsRerender */;
		        return;
		    }
		    attachToAncestor(hostRef, hostRef.$ancestorComponent$);
		    // there is no ancestor component or the ancestor component
		    // has already fired off its lifecycle update then
		    // fire off the initial update
		    const dispatch = () => dispatchHooks(hostRef, isInitialLoad);
		    return writeTask(dispatch) ;
		};
		/**
		 * Dispatch initial-render and update lifecycle hooks, enqueuing calls to
		 * component lifecycle methods like `componentWillLoad` as well as
		 * {@link updateComponent}, which will kick off the virtual DOM re-render.
		 *
		 * @param hostRef a reference to a host DOM node
		 * @param isInitialLoad whether we're on the initial load or not
		 * @returns an empty Promise which is used to enqueue a series of operations for
		 * the component
		 */
		const dispatchHooks = (hostRef, isInitialLoad) => {
		    const endSchedule = createTime('scheduleUpdate', hostRef.$cmpMeta$.$tagName$);
		    const instance = hostRef.$lazyInstance$ ;
		    // We're going to use this variable together with `enqueue` to implement a
		    // little promise-based queue. We start out with it `undefined`. When we add
		    // the first function to the queue we'll set this variable to be that
		    // function's return value. When we attempt to add subsequent values to the
		    // queue we'll check that value and, if it was a `Promise`, we'll then chain
		    // the new function off of that `Promise` using `.then()`. This will give our
		    // queue two nice properties:
		    //
		    // 1. If all functions added to the queue are synchronous they'll be called
		    //    synchronously right away.
		    // 2. If all functions added to the queue are asynchronous they'll all be
		    //    called in order after `dispatchHooks` exits.
		    let maybePromise;
		    if (isInitialLoad) {
		        {
		            hostRef.$flags$ |= 256 /* HOST_FLAGS.isListenReady */;
		            if (hostRef.$queuedListeners$) {
		                hostRef.$queuedListeners$.map(([methodName, event]) => safeCall(instance, methodName, event));
		                hostRef.$queuedListeners$ = undefined;
		            }
		        }
		        {
		            // If `componentWillLoad` returns a `Promise` then we want to wait on
		            // whatever's going on in that `Promise` before we launch into
		            // rendering the component, doing other lifecycle stuff, etc. So
		            // in that case we assign the returned promise to the variable we
		            // declared above to hold a possible 'queueing' Promise
		            maybePromise = safeCall(instance, 'componentWillLoad');
		        }
		    }
		    else {
		        {
		            // Like `componentWillLoad` above, we allow Stencil component
		            // authors to return a `Promise` from this lifecycle callback, and
		            // we specify that our runtime will wait for that `Promise` to
		            // resolve before the component re-renders. So if the method
		            // returns a `Promise` we need to keep it around!
		            maybePromise = safeCall(instance, 'componentWillUpdate');
		        }
		    }
		    endSchedule();
		    return enqueue(maybePromise, () => updateComponent(hostRef, instance, isInitialLoad));
		};
		/**
		 * This function uses a Promise to implement a simple first-in, first-out queue
		 * of functions to be called.
		 *
		 * The queue is ordered on the basis of the first argument. If it's
		 * `undefined`, then nothing is on the queue yet, so the provided function can
		 * be called synchronously (although note that this function may return a
		 * `Promise`). The idea is that then the return value of that enqueueing
		 * operation is kept around, so that if it was a `Promise` then subsequent
		 * functions can be enqueued by calling this function again with that `Promise`
		 * as the first argument.
		 *
		 * @param maybePromise either a `Promise` which should resolve before the next function is called or an 'empty' sentinel
		 * @param fn a function to enqueue
		 * @returns either a `Promise` or the return value of the provided function
		 */
		const enqueue = (maybePromise, fn) => isPromisey(maybePromise) ? maybePromise.then(fn) : fn();
		/**
		 * Check that a value is a `Promise`. To check, we first see if the value is an
		 * instance of the `Promise` global. In a few circumstances, in particular if
		 * the global has been overwritten, this is could be misleading, so we also do
		 * a little 'duck typing' check to see if the `.then` property of the value is
		 * defined and a function.
		 *
		 * @param maybePromise it might be a promise!
		 * @returns whether it is or not
		 */
		const isPromisey = (maybePromise) => maybePromise instanceof Promise ||
		    (maybePromise && maybePromise.then && typeof maybePromise.then === 'function');
		/**
		 * Update a component given reference to its host elements and so on.
		 *
		 * @param hostRef an object containing references to the element's host node,
		 * VDom nodes, and other metadata
		 * @param instance a reference to the underlying host element where it will be
		 * rendered
		 * @param isInitialLoad whether or not this function is being called as part of
		 * the first render cycle
		 */
		const updateComponent = async (hostRef, instance, isInitialLoad) => {
		    var _a;
		    const elm = hostRef.$hostElement$;
		    const endUpdate = createTime('update', hostRef.$cmpMeta$.$tagName$);
		    const rc = elm['s-rc'];
		    const endRender = createTime('render', hostRef.$cmpMeta$.$tagName$);

		    //========= PDS PATCH START
		    if (elm.hasDSR) {
		        elm.shadowRoot.innerHTML = '';
		        delete elm.hasDSR;
		    }
		    //========= PDS PATCH END

		    {
		        callRender(hostRef, instance, elm, isInitialLoad);
		    }
		    if (rc) {
		        // ok, so turns out there are some child host elements
		        // waiting on this parent element to load
		        // let's fire off all update callbacks waiting
		        rc.map((cb) => cb());
		        elm['s-rc'] = undefined;
		    }
		    endRender();
		    endUpdate();
		    {
		        const childrenPromises = (_a = elm['s-p']) !== null && _a !== void 0 ? _a : [];
		        const postUpdate = () => postUpdateComponent(hostRef);
		        if (childrenPromises.length === 0) {
		            postUpdate();
		        }
		        else {
		            Promise.all(childrenPromises).then(postUpdate);
		            hostRef.$flags$ |= 4 /* HOST_FLAGS.isWaitingForChildren */;
		            childrenPromises.length = 0;
		        }
		    }
		};
		/**
		 * Handle making the call to the VDom renderer with the proper context given
		 * various build variables
		 *
		 * @param hostRef an object containing references to the element's host node,
		 * VDom nodes, and other metadata
		 * @param instance a reference to the underlying host element where it will be
		 * rendered
		 * @param elm the Host element for the component
		 * @param isInitialLoad whether or not this function is being called as part of
		 * @returns an empty promise
		 */
		const callRender = (hostRef, instance, elm, isInitialLoad) => {
		    try {
		        /**
		         * minification optimization: `allRenderFn` is `true` if all components have a `render`
		         * method, so we can call the method immediately. If not, check before calling it.
		         */
		        instance = instance.render() ;
		        {
		            hostRef.$flags$ &= ~16 /* HOST_FLAGS.isQueuedForUpdate */;
		        }
		        {
		            hostRef.$flags$ |= 2 /* HOST_FLAGS.hasRendered */;
		        }
		        {
		            {
		                // looks like we've got child nodes to render into this host element
		                // or we need to update the css class/attrs on the host element
		                // DOM WRITE!
		                {
		                    renderVdom(hostRef, instance, isInitialLoad);
		                }
		            }
		        }
		    }
		    catch (e) {
		        consoleError$1(e, hostRef.$hostElement$);
		    }
		    return null;
		};
		const postUpdateComponent = (hostRef) => {
		    const tagName = hostRef.$cmpMeta$.$tagName$;
		    const elm = hostRef.$hostElement$;
		    const endPostUpdate = createTime('postUpdate', tagName);
		    const instance = hostRef.$lazyInstance$ ;
		    const ancestorComponent = hostRef.$ancestorComponent$;
		    {
		        safeCall(instance, 'componentDidRender');
		    }
		    if (!(hostRef.$flags$ & 64 /* HOST_FLAGS.hasLoadedComponent */)) {
		        hostRef.$flags$ |= 64 /* HOST_FLAGS.hasLoadedComponent */;
		        {
		            // DOM WRITE!
		            addHydratedFlag(elm);
		        }
		        {
		            safeCall(instance, 'componentDidLoad');
		        }
		        endPostUpdate();
		        {
		            hostRef.$onReadyResolve$(elm);
		            if (!ancestorComponent) {
		                appDidLoad();
		            }
		        }
		    }
		    else {
		        {
		            safeCall(instance, 'componentDidUpdate');
		        }
		        endPostUpdate();
		    }
		    {
		        hostRef.$onInstanceResolve$(elm);
		    }
		    // load events fire from bottom to top
		    // the deepest elements load first then bubbles up
		    {
		        if (hostRef.$onRenderResolve$) {
		            hostRef.$onRenderResolve$();
		            hostRef.$onRenderResolve$ = undefined;
		        }
		        if (hostRef.$flags$ & 512 /* HOST_FLAGS.needsRerender */) {
		            nextTick(() => scheduleUpdate(hostRef, false));
		        }
		        hostRef.$flags$ &= ~(4 /* HOST_FLAGS.isWaitingForChildren */ | 512 /* HOST_FLAGS.needsRerender */);
		    }
		    // ( •_•)
		    // ( •_•)>⌐■-■
		    // (⌐■_■)
		};
		const forceUpdate = (ref) => {
		    {
		        const hostRef = getHostRef(ref);
		        const isConnected = hostRef.$hostElement$.isConnected;
		        if (isConnected &&
		            (hostRef.$flags$ & (2 /* HOST_FLAGS.hasRendered */ | 16 /* HOST_FLAGS.isQueuedForUpdate */)) === 2 /* HOST_FLAGS.hasRendered */) {
		            scheduleUpdate(hostRef, false);
		        }
		        // Returns "true" when the forced update was successfully scheduled
		        return isConnected;
		    }
		};
		const appDidLoad = (who) => {
		    // on appload
		    // we have finish the first big initial render
		    {
		        addHydratedFlag(doc.documentElement);
		    }
		    nextTick(() => emitEvent(win, 'appload', { detail: { namespace: NAMESPACE } }));
		};
		/**
		 * Allows to safely call a method, e.g. `componentDidLoad`, on an instance,
		 * e.g. custom element node. If a build figures out that e.g. no component
		 * has a `componentDidLoad` method, the instance method gets removed from the
		 * output bundle and this function returns `undefined`.
		 * @param instance any object that may or may not contain methods
		 * @param method method name
		 * @param arg single arbitrary argument
		 * @returns result of method call if it exists, otherwise `undefined`
		 */
		const safeCall = (instance, method, arg) => {
		    if (instance && instance[method]) {
		        try {
		            return instance[method](arg);
		        }
		        catch (e) {
		            consoleError$1(e);
		        }
		    }
		    return undefined;
		};
		const addHydratedFlag = (elm) => elm.classList.add('hydrated')
		    ;
		const getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);
		const setValue = (ref, propName, newVal, cmpMeta) => {
		    // check our new property value against our internal value
		    const hostRef = getHostRef(ref);
		    const elm = hostRef.$hostElement$ ;
		    const oldVal = hostRef.$instanceValues$.get(propName);
		    const flags = hostRef.$flags$;
		    const instance = hostRef.$lazyInstance$ ;
		    newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);
		    // explicitly check for NaN on both sides, as `NaN === NaN` is always false
		    const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);
		    const didValueChange = newVal !== oldVal && !areBothNaN;
		    if ((!(flags & 8 /* HOST_FLAGS.isConstructingInstance */) || oldVal === undefined) && didValueChange) {
		        // gadzooks! the property's value has changed!!
		        // set our new value!
		        hostRef.$instanceValues$.set(propName, newVal);
		        if (instance) {
		            // get an array of method names of watch functions to call
		            if (cmpMeta.$watchers$ && flags & 128 /* HOST_FLAGS.isWatchReady */) {
		                const watchMethods = cmpMeta.$watchers$[propName];
		                if (watchMethods) {
		                    // this instance is watching for when this property changed
		                    watchMethods.map((watchMethodName) => {
		                        try {
		                            // fire off each of the watch methods that are watching this property
		                            instance[watchMethodName](newVal, oldVal, propName);
		                        }
		                        catch (e) {
		                            consoleError$1(e, elm);
		                        }
		                    });
		                }
		            }
		            if ((flags & (2 /* HOST_FLAGS.hasRendered */ | 16 /* HOST_FLAGS.isQueuedForUpdate */)) === 2 /* HOST_FLAGS.hasRendered */) {
		                if (instance.componentShouldUpdate) {
		                    if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {
		                        return;
		                    }
		                }
		                // looks like this value actually changed, so we've got work to do!
		                // but only if we've already rendered, otherwise just chill out
		                // queue that we need to do an update, but don't worry about queuing
		                // up millions cuz this function ensures it only runs once
		                scheduleUpdate(hostRef, false);
		            }
		        }
		    }
		};
		/**
		 * Attach a series of runtime constructs to a compiled Stencil component
		 * constructor, including getters and setters for the `@Prop` and `@State`
		 * decorators, callbacks for when attributes change, and so on.
		 *
		 * @param Cstr the constructor for a component that we need to process
		 * @param cmpMeta metadata collected previously about the component
		 * @param flags a number used to store a series of bit flags
		 * @returns a reference to the same constructor passed in (but now mutated)
		 */
		const proxyComponent = (Cstr, cmpMeta, flags) => {
		    var _a;
		    const prototype = Cstr.prototype;
		    if (cmpMeta.$members$) {
		        if (Cstr.watchers) {
		            cmpMeta.$watchers$ = Cstr.watchers;
		        }
		        // It's better to have a const than two Object.entries()
		        const members = Object.entries(cmpMeta.$members$);
		        members.map(([memberName, [memberFlags]]) => {
		            if ((memberFlags & 31 /* MEMBER_FLAGS.Prop */ ||
		                    ((flags & 2 /* PROXY_FLAGS.proxyState */) && memberFlags & 32 /* MEMBER_FLAGS.State */))) {
		                // proxyComponent - prop
		                Object.defineProperty(prototype, memberName, {
		                    get() {
		                        // proxyComponent, get value
		                        return getValue(this, memberName);
		                    },
		                    set(newValue) {
		                        // proxyComponent, set value
		                        setValue(this, memberName, newValue, cmpMeta);
		                    },
		                    configurable: true,
		                    enumerable: true,
		                });
		            }
		            else if (flags & 1 /* PROXY_FLAGS.isElementConstructor */ &&
		                memberFlags & 64 /* MEMBER_FLAGS.Method */) {
		                // proxyComponent - method
		                Object.defineProperty(prototype, memberName, {
		                    value(...args) {
		                        var _a;
		                        const ref = getHostRef(this);
		                        return (_a = ref === null || ref === void 0 ? void 0 : ref.$onInstancePromise$) === null || _a === void 0 ? void 0 : _a.then(() => { var _a; return (_a = ref.$lazyInstance$) === null || _a === void 0 ? void 0 : _a[memberName](...args); });
		                    },
		                });
		            }
		        });
		        if ((flags & 1 /* PROXY_FLAGS.isElementConstructor */)) {
		            const attrNameToPropName = new Map();
		            prototype.attributeChangedCallback = function (attrName, oldValue, newValue) {
		                plt.jmp(() => {
		                    var _a;
		                    const propName = attrNameToPropName.get(attrName);
		                    //  In a web component lifecycle the attributeChangedCallback runs prior to connectedCallback
		                    //  in the case where an attribute was set inline.
		                    //  ```html
		                    //    <my-component some-attribute="some-value"></my-component>
		                    //  ```
		                    //
		                    //  There is an edge case where a developer sets the attribute inline on a custom element and then
		                    //  programmatically changes it before it has been upgraded as shown below:
		                    //
		                    //  ```html
		                    //    <!-- this component has _not_ been upgraded yet -->
		                    //    <my-component id="test" some-attribute="some-value"></my-component>
		                    //    <script>
		                    //      // grab non-upgraded component
		                    //      el = document.querySelector("#test");
		                    //      el.someAttribute = "another-value";
		                    //      // upgrade component
		                    //      customElements.define('my-component', MyComponent);
		                    //    </script>
		                    //  ```
		                    //  In this case if we do not un-shadow here and use the value of the shadowing property, attributeChangedCallback
		                    //  will be called with `newValue = "some-value"` and will set the shadowed property (this.someAttribute = "another-value")
		                    //  to the value that was set inline i.e. "some-value" from above example. When
		                    //  the connectedCallback attempts to un-shadow it will use "some-value" as the initial value rather than "another-value"
		                    //
		                    //  The case where the attribute was NOT set inline but was not set programmatically shall be handled/un-shadowed
		                    //  by connectedCallback as this attributeChangedCallback will not fire.
		                    //
		                    //  https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties
		                    //
		                    //  TODO(STENCIL-16) we should think about whether or not we actually want to be reflecting the attributes to
		                    //  properties here given that this goes against best practices outlined here
		                    //  https://developers.google.com/web/fundamentals/web-components/best-practices#avoid-reentrancy
		                    if (this.hasOwnProperty(propName)) {
		                        newValue = this[propName];
		                        delete this[propName];
		                    }
		                    else if (prototype.hasOwnProperty(propName) &&
		                        typeof this[propName] === 'number' &&
		                        this[propName] == newValue) {
		                        // if the propName exists on the prototype of `Cstr`, this update may be a result of Stencil using native
		                        // APIs to reflect props as attributes. Calls to `setAttribute(someElement, propName)` will result in
		                        // `propName` to be converted to a `DOMString`, which may not be what we want for other primitive props.
		                        return;
		                    }
		                    else if (propName == null) {
		                        // At this point we should know this is not a "member", so we can treat it like watching an attribute
		                        // on a vanilla web component
		                        const hostRef = getHostRef(this);
		                        const flags = hostRef === null || hostRef === void 0 ? void 0 : hostRef.$flags$;
		                        // We only want to trigger the callback(s) if:
		                        // 1. The instance is ready
		                        // 2. The watchers are ready
		                        // 3. The value has changed
		                        if (flags &&
		                            !(flags & 8 /* HOST_FLAGS.isConstructingInstance */) &&
		                            flags & 128 /* HOST_FLAGS.isWatchReady */ &&
		                            newValue !== oldValue) {
		                            const instance = hostRef.$lazyInstance$ ;
		                            const entry = (_a = cmpMeta.$watchers$) === null || _a === void 0 ? void 0 : _a[attrName];
		                            entry === null || entry === void 0 ? void 0 : entry.forEach((callbackName) => {
		                                if (instance[callbackName] != null) {
		                                    instance[callbackName].call(instance, newValue, oldValue, attrName);
		                                }
		                            });
		                        }
		                        return;
		                    }
		                    this[propName] = newValue === null && typeof this[propName] === 'boolean' ? false : newValue;
		                });
		            };
		            // Create an array of attributes to observe
		            // This list in comprised of all strings used within a `@Watch()` decorator
		            // on a component as well as any Stencil-specific "members" (`@Prop()`s and `@State()`s).
		            // As such, there is no way to guarantee type-safety here that a user hasn't entered
		            // an invalid attribute.
		            Cstr.observedAttributes = Array.from(new Set([
		                ...Object.keys((_a = cmpMeta.$watchers$) !== null && _a !== void 0 ? _a : {}),
		                ...members
		                    .filter(([_, m]) => m[0] & 15 /* MEMBER_FLAGS.HasAttribute */)
		                    .map(([propName, m]) => {
		                    const attrName = m[1] || propName;
		                    attrNameToPropName.set(attrName, propName);
		                    return attrName;
		                }),
		            ]));
		        }
		    }
		    return Cstr;
		};
		/**
		 * Initialize a Stencil component given a reference to its host element, its
		 * runtime bookkeeping data structure, runtime metadata about the component,
		 * and (optionally) an HMR version ID.
		 *
		 * @param elm a host element
		 * @param hostRef the element's runtime bookkeeping object
		 * @param cmpMeta runtime metadata for the Stencil component
		 * @param hmrVersionId an (optional) HMR version ID
		 */
		const initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId) => {
		    let Cstr;
		    // initializeComponent
		    if ((hostRef.$flags$ & 32 /* HOST_FLAGS.hasInitializedComponent */) === 0) {
		        // Let the runtime know that the component has been initialized
		        hostRef.$flags$ |= 32 /* HOST_FLAGS.hasInitializedComponent */;
		        const bundleId = cmpMeta.$lazyBundleId$;
		        if (bundleId) {
		            // lazy loaded components
		            // request the component's implementation to be
		            // wired up with the host element
		            Cstr = loadModule(cmpMeta);
		            if (Cstr.then) {
		                // Await creates a micro-task avoid if possible
		                const endLoad = uniqueTime();
		                Cstr = await Cstr;
		                endLoad();
		            }
		            if (!Cstr.isProxied) {
		                // we've never proxied this Constructor before
		                // let's add the getters/setters to its prototype before
		                // the first time we create an instance of the implementation
		                {
		                    cmpMeta.$watchers$ = Cstr.watchers;
		                }
		                proxyComponent(Cstr, cmpMeta, 2 /* PROXY_FLAGS.proxyState */);
		                Cstr.isProxied = true;
		            }
		            const endNewInstance = createTime('createInstance', cmpMeta.$tagName$);
		            // ok, time to construct the instance
		            // but let's keep track of when we start and stop
		            // so that the getters/setters don't incorrectly step on data
		            {
		                hostRef.$flags$ |= 8 /* HOST_FLAGS.isConstructingInstance */;
		            }
		            // construct the lazy-loaded component implementation
		            // passing the hostRef is very important during
		            // construction in order to directly wire together the
		            // host element and the lazy-loaded instance
		            try {
		                new Cstr(hostRef);
		            }
		            catch (e) {
		                consoleError$1(e);
		            }
		            {
		                hostRef.$flags$ &= ~8 /* HOST_FLAGS.isConstructingInstance */;
		            }
		            {
		                hostRef.$flags$ |= 128 /* HOST_FLAGS.isWatchReady */;
		            }
		            endNewInstance();
		            fireConnectedCallback(hostRef.$lazyInstance$);
		        }
		        else {
		            // sync constructor component
		            Cstr = elm.constructor;
		            // wait for the CustomElementRegistry to mark the component as ready before setting `isWatchReady`. Otherwise,
		            // watchers may fire prematurely if `customElements.get()`/`customElements.whenDefined()` resolves _before_
		            // Stencil has completed instantiating the component.
		            customElements.whenDefined(cmpMeta.$tagName$).then(() => (hostRef.$flags$ |= 128 /* HOST_FLAGS.isWatchReady */));
		        }
		    }
		    // we've successfully created a lazy instance
		    const ancestorComponent = hostRef.$ancestorComponent$;
		    const schedule = () => scheduleUpdate(hostRef, true);
		    if (ancestorComponent && ancestorComponent['s-rc']) {
		        // this is the initial load and this component it has an ancestor component
		        // but the ancestor component has NOT fired its will update lifecycle yet
		        // so let's just cool our jets and wait for the ancestor to continue first
		        // this will get fired off when the ancestor component
		        // finally gets around to rendering its lazy self
		        // fire off the initial update
		        ancestorComponent['s-rc'].push(schedule);
		    }
		    else {
		        schedule();
		    }
		};
		const fireConnectedCallback = (instance) => {
		    {
		        safeCall(instance, 'connectedCallback');
		    }
		};
		const connectedCallback = (elm) => {
		    if ((plt.$flags$ & 1 /* PLATFORM_FLAGS.isTmpDisconnected */) === 0) {
		        const hostRef = getHostRef(elm);
		        const cmpMeta = hostRef.$cmpMeta$;
		        const endConnected = createTime('connectedCallback', cmpMeta.$tagName$);
		        if (!(hostRef.$flags$ & 1 /* HOST_FLAGS.hasConnected */)) {
		            // first time this component has connected
		            hostRef.$flags$ |= 1 /* HOST_FLAGS.hasConnected */;
		            {
		                // find the first ancestor component (if there is one) and register
		                // this component as one of the actively loading child components for its ancestor
		                let ancestorComponent = elm;
		                while ((ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host)) {
		                    // climb up the ancestors looking for the first
		                    // component that hasn't finished its lifecycle update yet
		                    if (ancestorComponent['s-p']) {
		                        // we found this components first ancestor component
		                        // keep a reference to this component's ancestor component
		                        attachToAncestor(hostRef, (hostRef.$ancestorComponent$ = ancestorComponent));
		                        break;
		                    }
		                }
		            }
		            // Lazy properties
		            // https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties
		            if (cmpMeta.$members$) {
		                Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {
		                    if (memberFlags & 31 /* MEMBER_FLAGS.Prop */ && elm.hasOwnProperty(memberName)) {
		                        const value = elm[memberName];
		                        delete elm[memberName];
		                        elm[memberName] = value;
		                    }
		                });
		            }
		            {
		                initializeComponent(elm, hostRef, cmpMeta);
		            }
		        }
		        else {
		            // not the first time this has connected
		            // reattach any event listeners to the host
		            // since they would have been removed when disconnected
		            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$);
		            // fire off connectedCallback() on component instance
		            if (hostRef === null || hostRef === void 0 ? void 0 : hostRef.$lazyInstance$) {
		                fireConnectedCallback(hostRef.$lazyInstance$);
		            }
		            else if (hostRef === null || hostRef === void 0 ? void 0 : hostRef.$onReadyPromise$) {
		                hostRef.$onReadyPromise$.then(() => fireConnectedCallback(hostRef.$lazyInstance$));
		            }
		        }
		        endConnected();
		    }
		};
		const disconnectInstance = (instance) => {
		    {
		        safeCall(instance, 'disconnectedCallback');
		    }
		};
		const disconnectedCallback = async (elm) => {
		    if ((plt.$flags$ & 1 /* PLATFORM_FLAGS.isTmpDisconnected */) === 0) {
		        const hostRef = getHostRef(elm);
		        {
		            if (hostRef.$rmListeners$) {
		                hostRef.$rmListeners$.map((rmListener) => rmListener());
		                hostRef.$rmListeners$ = undefined;
		            }
		        }
		        if (hostRef === null || hostRef === void 0 ? void 0 : hostRef.$lazyInstance$) {
		            disconnectInstance(hostRef.$lazyInstance$);
		        }
		        else if (hostRef === null || hostRef === void 0 ? void 0 : hostRef.$onReadyPromise$) {
		            hostRef.$onReadyPromise$.then(() => disconnectInstance(hostRef.$lazyInstance$));
		        }
		    }
		};
		const bootstrapLazy = (lazyBundles, options = {}) => {
		    var _a;
		    const endBootstrap = createTime();
		    const cmpTags = [];
		    const exclude = options.exclude || [];
		    const customElements = win.customElements;
		    const head = doc.head;
		    const metaCharset = /*@__PURE__*/ head.querySelector('meta[charset]');
		    const dataStyles = /*@__PURE__*/ doc.createElement('style');
		    const deferredConnectedCallbacks = [];
		    let appLoadFallback;
		    let isBootstrapping = true;
		    Object.assign(plt, options);
		    plt.$resourcesUrl$ = new URL(options.resourcesUrl || './', doc.baseURI).href;
		    let hasSlotRelocation = false;
		    lazyBundles.map((lazyBundle) => {
		        lazyBundle[1].map((compactMeta) => {
		            var _a;
		            const cmpMeta = {
		                $flags$: compactMeta[0],
		                $tagName$: compactMeta[1],
		                $members$: compactMeta[2],
		                $listeners$: compactMeta[3],
		            };
		            // Check if we are using slots outside the shadow DOM in this component.
		            // We'll use this information later to add styles for `slot-fb` elements
		            if (cmpMeta.$flags$ & 4 /* CMP_FLAGS.hasSlotRelocation */) {
		                hasSlotRelocation = true;
		            }
		            {
		                cmpMeta.$members$ = compactMeta[2];
		            }
		            {
		                cmpMeta.$listeners$ = compactMeta[3];
		            }
		            {
		                cmpMeta.$watchers$ = (_a = compactMeta[4]) !== null && _a !== void 0 ? _a : {};
		            }
		            const tagName = options.transformTagName
		                ? options.transformTagName(cmpMeta.$tagName$)
		                : cmpMeta.$tagName$;
		            const HostElement = class extends HTMLElement {
		                // StencilLazyHost
		                constructor(self) {
		                    // @ts-ignore
		                    super(self);
		                    self = this;
		                    registerHost(self, cmpMeta);
		                    if (cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) {
		                        // this component is using shadow dom
		                        // and this browser supports shadow dom
		                        // add the read-only property "shadowRoot" to the host element
		                        // adding the shadow root build conditionals to minimize runtime
		                        {
		                            //========= PDS PATCH START
		                            let ssrInnerHTML = '';
		                            if (self.shadowRoot) {
		                              ssrInnerHTML = self.shadowRoot.innerHTML;
		                              self.hasDSR = true;
		                            }
		                            //========= PDS PATCH END

		                            {
		                                //========= PDS PATCH START
		                                // in dsr ponyfilled browsers (e.g. Safari), the shadowRoot is already attached
		                                // and a 2nd attempt fails, therefore this needs to always run without SSR
		                                // and only with SSR for browsers that are not ponyfilled
		                                if (!self.hasDSR || HTMLTemplateElement.prototype.hasOwnProperty('shadowRoot')) {
		                                //========= PDS PATCH END

		                                self.attachShadow({
		                                    mode: 'open',
		                                    delegatesFocus: !!(cmpMeta.$flags$ & 16 /* CMP_FLAGS.shadowDelegatesFocus */),
		                                });

		                                //========= PDS PATCH START
		                                    self.shadowRoot.innerHTML = ssrInnerHTML;
		                                }
		                                //========= PDS PATCH END

		                            }
		                        }
		                    }
		                }
		                connectedCallback() {
		                    if (appLoadFallback) {
		                        clearTimeout(appLoadFallback);
		                        appLoadFallback = null;
		                    }
		                    if (isBootstrapping) {
		                        // connectedCallback will be processed once all components have been registered
		                        deferredConnectedCallbacks.push(this);
		                    }
		                    else {
		                        plt.jmp(() => connectedCallback(this));
		                    }
		                }
		                disconnectedCallback() {
		                    plt.jmp(() => disconnectedCallback(this));
		                }
		                componentOnReady() {
		                    return getHostRef(this).$onReadyPromise$;
		                }
		            };
		            cmpMeta.$lazyBundleId$ = lazyBundle[0];
		            if (!exclude.includes(tagName) && !customElements.get(tagName)) {
		                cmpTags.push(tagName);
		                customElements.define(tagName, proxyComponent(HostElement, cmpMeta, 1 /* PROXY_FLAGS.isElementConstructor */));
		            }
		        });
		    });
		    // Only bother generating CSS if we have components
		    // TODO(STENCIL-1118): Add test cases for CSS content based on conditionals
		    if (cmpTags.length > 0) {
		        // Add styles for `slot-fb` elements if any of our components are using slots outside the Shadow DOM
		        if (hasSlotRelocation) {
		            dataStyles.textContent += SLOT_FB_CSS;
		        }
		        // If we have styles, add them to the DOM
		        if (dataStyles.innerHTML.length) {
		            dataStyles.setAttribute('data-styles', '');
		            // Apply CSP nonce to the style tag if it exists
		            const nonce = (_a = plt.$nonce$) !== null && _a !== void 0 ? _a : queryNonceMetaTagContent(doc);
		            if (nonce != null) {
		                dataStyles.setAttribute('nonce', nonce);
		            }
		            // Insert the styles into the document head
		            // NOTE: this _needs_ to happen last so we can ensure the nonce (and other attributes) are applied
		            head.insertBefore(dataStyles, metaCharset ? metaCharset.nextSibling : head.firstChild);
		        }
		    }
		    // Process deferred connectedCallbacks now all components have been registered
		    isBootstrapping = false;
		    if (deferredConnectedCallbacks.length) {
		        deferredConnectedCallbacks.map((host) => host.connectedCallback());
		    }
		    else {
		        {
		            plt.jmp(() => (appLoadFallback = setTimeout(appDidLoad, 30)));
		        }
		    }
		    // Fallback appLoad event
		    endBootstrap();
		};
		const Fragment = (_, children) => children;
		const addHostEventListeners = (elm, hostRef, listeners, attachParentListeners) => {
		    if (listeners) {
		        listeners.map(([flags, name, method]) => {
		            const target = elm;
		            const handler = hostListenerProxy(hostRef, method);
		            const opts = hostListenerOpts(flags);
		            plt.ael(target, name, handler, opts);
		            (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));
		        });
		    }
		};
		const hostListenerProxy = (hostRef, methodName) => (ev) => {
		    try {
		        {
		            if (hostRef.$flags$ & 256 /* HOST_FLAGS.isListenReady */) {
		                // instance is ready, let's call it's member method for this event
		                hostRef.$lazyInstance$[methodName](ev);
		            }
		            else {
		                (hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([methodName, ev]);
		            }
		        }
		    }
		    catch (e) {
		        consoleError$1(e);
		    }
		};
		// prettier-ignore
		const hostListenerOpts = (flags) => supportsListenerOptions
		    ? ({
		        passive: (flags & 1 /* LISTENER_FLAGS.Passive */) !== 0,
		        capture: (flags & 2 /* LISTENER_FLAGS.Capture */) !== 0,
		    })
		    : (flags & 2 /* LISTENER_FLAGS.Capture */) !== 0;
		/**
		 * Assigns the given value to the nonce property on the runtime platform object.
		 * During runtime, this value is used to set the nonce attribute on all dynamically created script and style tags.
		 * @param nonce The value to be assigned to the platform nonce property.
		 * @returns void
		 */
		const setNonce = (nonce) => (plt.$nonce$ = nonce);
		/**
		 * A WeakMap mapping runtime component references to their corresponding host reference
		 * instances.
		 *
		 * **Note**: If we're in an HMR context we need to store a reference to this
		 * value on `window` in order to maintain the mapping of {@link d.RuntimeRef}
		 * to {@link d.HostRef} across HMR updates.
		 *
		 * This is necessary because when HMR updates for a component are processed by
		 * the browser-side dev server client the JS bundle for that component is
		 * re-fetched. Since the module containing {@link hostRefs} is included in
		 * that bundle, if we do not store a reference to it the new iteration of the
		 * component will not have access to the previous hostRef map, leading to a
		 * bug where the new version of the component cannot properly initialize.
		 */
		const hostRefs = new WeakMap();
		/**
		 * Given a {@link d.RuntimeRef} retrieve the corresponding {@link d.HostRef}
		 *
		 * @param ref the runtime ref of interest
		 * @returns the Host reference (if found) or undefined
		 */
		const getHostRef = (ref) => hostRefs.get(ref);
		/**
		 * Register a lazy instance with the {@link hostRefs} object so it's
		 * corresponding {@link d.HostRef} can be retrieved later.
		 *
		 * @param lazyInstance the lazy instance of interest
		 * @param hostRef that instances `HostRef` object
		 * @returns a reference to the host ref WeakMap
		 */
		const registerInstance = (lazyInstance, hostRef) => hostRefs.set((hostRef.$lazyInstance$ = lazyInstance), hostRef);
		/**
		 * Register a host element for a Stencil component, setting up various metadata
		 * and callbacks based on {@link BUILD} flags as well as the component's runtime
		 * metadata.
		 *
		 * @param hostElement the host element to register
		 * @param cmpMeta runtime metadata for that component
		 * @returns a reference to the host ref WeakMap
		 */
		const registerHost = (hostElement, cmpMeta) => {
		    const hostRef = {
		        $flags$: 0,
		        $hostElement$: hostElement,
		        $cmpMeta$: cmpMeta,
		        $instanceValues$: new Map(),
		    };
		    {
		        hostRef.$onInstancePromise$ = new Promise((r) => (hostRef.$onInstanceResolve$ = r));
		    }
		    {
		        hostRef.$onReadyPromise$ = new Promise((r) => (hostRef.$onReadyResolve$ = r));
		        hostElement['s-p'] = [];
		        hostElement['s-rc'] = [];
		    }
		    addHostEventListeners(hostElement, hostRef, cmpMeta.$listeners$);
		    return hostRefs.set(hostElement, hostRef);
		};
		const isMemberInElement = (elm, memberName) => memberName in elm;
		const consoleError$1 = (e, el) => (0, console.error)(e, el);
		const cmpModules = /*@__PURE__*/ new Map();
		const loadModule = (cmpMeta, hostRef, hmrVersionId) => {
		    // loadModuleImport
		    const exportName = cmpMeta.$tagName$.replace(/-/g, '_');
		    const bundleId = cmpMeta.$lazyBundleId$;
		    const module = cmpModules.get(bundleId) ;
		    if (module) {
		        return module[exportName];
		    }
		    /*!__STENCIL_STATIC_IMPORT_SWITCH__*/
		    return Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(createCommonjsRequire("/src/lib")(
		    /* @vite-ignore */
		    /* webpackInclude: /\.entry\.js$/ */
		    /* webpackExclude: /\.system\.entry\.js$/ */
		    /* webpackMode: "lazy" */
		    `./${bundleId}.entry.js${''}`)); }).then((importedModule) => {
		        {
		            cmpModules.set(bundleId, importedModule);
		        }
		        return importedModule[exportName];
		    }, consoleError$1);
		};
		const win = typeof window !== 'undefined' ? window : {};
		const doc = win.document || { head: {} };
		const plt = {
		    $flags$: 0,
		    $resourcesUrl$: '',
		    jmp: (h) => h(),
		    raf: (h) => requestAnimationFrame(h),
		    ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),
		    rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),
		    ce: (eventName, opts) => new CustomEvent(eventName, opts),
		};
		const supportsListenerOptions = /*@__PURE__*/ (() => {
		    let supportsListenerOptions = false;
		    try {
		        doc.addEventListener('e', null, Object.defineProperty({}, 'passive', {
		            get() {
		                supportsListenerOptions = true;
		            },
		        }));
		    }
		    catch (e) { }
		    return supportsListenerOptions;
		})();
		const promiseResolve = (v) => Promise.resolve(v);
		const queueDomReads = [];
		const queueDomWrites = [];
		const queueTask = (queue, write) => (cb) => {
		    queue.push(cb);
		    if (!queuePending) {
		        queuePending = true;
		        if (write && plt.$flags$ & 4 /* PLATFORM_FLAGS.queueSync */) {
		            nextTick(flush);
		        }
		        else {
		            plt.raf(flush);
		        }
		    }
		};
		const consume = (queue) => {
		    for (let i = 0; i < queue.length; i++) {
		        try {
		            queue[i](performance.now());
		        }
		        catch (e) {
		            consoleError$1(e);
		        }
		    }
		    queue.length = 0;
		};
		const flush = () => {
		    // always force a bunch of medium callbacks to run, but still have
		    // a throttle on how many can run in a certain time
		    // DOM READS!!!
		    consume(queueDomReads);
		    // DOM WRITES!!!
		    {
		        consume(queueDomWrites);
		        if ((queuePending = queueDomReads.length > 0)) {
		            // still more to do yet, but we've run out of time
		            // let's let this thing cool off and try again in the next tick
		            plt.raf(flush);
		        }
		    }
		};
		const nextTick = (cb) => promiseResolve().then(cb);
		const writeTask = /*@__PURE__*/ queueTask(queueDomWrites, true);

		const TAG_NAMES = ['p-accordion', 'p-banner', 'p-button', 'p-button-group', 'p-button-pure', 'p-button-tile', 'p-carousel', 'p-checkbox-wrapper', 'p-content-wrapper', 'p-crest', 'p-display', 'p-divider', 'p-fieldset', 'p-fieldset-wrapper', 'p-flex', 'p-flex-item', 'p-flyout', 'p-flyout-navigation', 'p-flyout-navigation-item', 'p-grid', 'p-grid-item', 'p-heading', 'p-headline', 'p-icon', 'p-inline-notification', 'p-link', 'p-link-pure', 'p-link-social', 'p-link-tile', 'p-link-tile-model-signature', 'p-link-tile-product', 'p-marque', 'p-modal', 'p-model-signature', 'p-multi-select', 'p-multi-select-option', 'p-pagination', 'p-pin-code', 'p-popover', 'p-radio-button-wrapper', 'p-scroller', 'p-segmented-control', 'p-segmented-control-item', 'p-select', 'p-select-option', 'p-select-wrapper', 'p-select-wrapper-dropdown', 'p-spinner', 'p-stepper-horizontal', 'p-stepper-horizontal-item', 'p-switch', 'p-table', 'p-table-body', 'p-table-cell', 'p-table-head', 'p-table-head-cell', 'p-table-head-row', 'p-table-row', 'p-tabs', 'p-tabs-bar', 'p-tabs-item', 'p-tag', 'p-tag-dismissible', 'p-text', 'p-text-field-wrapper', 'p-text-list', 'p-text-list-item', 'p-textarea-wrapper', 'p-toast', 'p-toast-item', 'p-wordmark'];

		function _extends() {
		  _extends = Object.assign ? Object.assign.bind() : function (target) {
		    for (var i = 1; i < arguments.length; i++) {
		      var source = arguments[i];
		      for (var key in source) {
		        if (Object.prototype.hasOwnProperty.call(source, key)) {
		          target[key] = source[key];
		        }
		      }
		    }
		    return target;
		  };
		  return _extends.apply(this, arguments);
		}

		var _typeof$1 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

		var isBrowser = (typeof window === "undefined" ? "undefined" : _typeof$1(window)) === "object" && (typeof document === "undefined" ? "undefined" : _typeof$1(document)) === 'object' && document.nodeType === 9;

		function _typeof(o) {
		  "@babel/helpers - typeof";

		  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
		    return typeof o;
		  } : function (o) {
		    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
		  }, _typeof(o);
		}

		function toPrimitive(t, r) {
		  if ("object" != _typeof(t) || !t) return t;
		  var e = t[Symbol.toPrimitive];
		  if (void 0 !== e) {
		    var i = e.call(t, r || "default");
		    if ("object" != _typeof(i)) return i;
		    throw new TypeError("@@toPrimitive must return a primitive value.");
		  }
		  return ("string" === r ? String : Number)(t);
		}

		function toPropertyKey(t) {
		  var i = toPrimitive(t, "string");
		  return "symbol" == _typeof(i) ? i : i + "";
		}

		function _defineProperties(target, props) {
		  for (var i = 0; i < props.length; i++) {
		    var descriptor = props[i];
		    descriptor.enumerable = descriptor.enumerable || false;
		    descriptor.configurable = true;
		    if ("value" in descriptor) descriptor.writable = true;
		    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
		  }
		}
		function _createClass(Constructor, protoProps, staticProps) {
		  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
		  if (staticProps) _defineProperties(Constructor, staticProps);
		  Object.defineProperty(Constructor, "prototype", {
		    writable: false
		  });
		  return Constructor;
		}

		function _setPrototypeOf(o, p) {
		  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
		    o.__proto__ = p;
		    return o;
		  };
		  return _setPrototypeOf(o, p);
		}

		function _inheritsLoose(subClass, superClass) {
		  subClass.prototype = Object.create(superClass.prototype);
		  subClass.prototype.constructor = subClass;
		  _setPrototypeOf(subClass, superClass);
		}

		function _assertThisInitialized(self) {
		  if (self === void 0) {
		    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		  }
		  return self;
		}

		function _objectWithoutPropertiesLoose(source, excluded) {
		  if (source == null) return {};
		  var target = {};
		  var sourceKeys = Object.keys(source);
		  var key, i;
		  for (i = 0; i < sourceKeys.length; i++) {
		    key = sourceKeys[i];
		    if (excluded.indexOf(key) >= 0) continue;
		    target[key] = source[key];
		  }
		  return target;
		}

		var plainObjectConstrurctor = {}.constructor;
		function cloneStyle(style) {
		  if (style == null || typeof style !== 'object') return style;
		  if (Array.isArray(style)) return style.map(cloneStyle);
		  if (style.constructor !== plainObjectConstrurctor) return style;
		  var newStyle = {};

		  for (var name in style) {
		    newStyle[name] = cloneStyle(style[name]);
		  }

		  return newStyle;
		}

		/**
		 * Create a rule instance.
		 */

		function createRule(name, decl, options) {
		  if (name === void 0) {
		    name = 'unnamed';
		  }

		  var jss = options.jss;
		  var declCopy = cloneStyle(decl);
		  var rule = jss.plugins.onCreateRule(name, declCopy, options);
		  if (rule) return rule; // It is an at-rule and it has no instance.

		  return null;
		}

		var join = function join(value, by) {
		  var result = '';

		  for (var i = 0; i < value.length; i++) {
		    // Remove !important from the value, it will be readded later.
		    if (value[i] === '!important') break;
		    if (result) result += by;
		    result += value[i];
		  }

		  return result;
		};
		/**
		 * Converts JSS array value to a CSS string.
		 *
		 * `margin: [['5px', '10px']]` > `margin: 5px 10px;`
		 * `border: ['1px', '2px']` > `border: 1px, 2px;`
		 * `margin: [['5px', '10px'], '!important']` > `margin: 5px 10px !important;`
		 * `color: ['red', !important]` > `color: red !important;`
		 */


		var toCssValue = function toCssValue(value) {
		  if (!Array.isArray(value)) return value;
		  var cssValue = ''; // Support space separated values via `[['5px', '10px']]`.

		  if (Array.isArray(value[0])) {
		    for (var i = 0; i < value.length; i++) {
		      if (value[i] === '!important') break;
		      if (cssValue) cssValue += ', ';
		      cssValue += join(value[i], ' ');
		    }
		  } else cssValue = join(value, ', '); // Add !important, because it was ignored.


		  if (value[value.length - 1] === '!important') {
		    cssValue += ' !important';
		  }

		  return cssValue;
		};

		function getWhitespaceSymbols(options) {
		  if (options && options.format === false) {
		    return {
		      linebreak: '',
		      space: ''
		    };
		  }

		  return {
		    linebreak: '\n',
		    space: ' '
		  };
		}

		/**
		 * Indent a string.
		 * http://jsperf.com/array-join-vs-for
		 */

		function indentStr(str, indent) {
		  var result = '';

		  for (var index = 0; index < indent; index++) {
		    result += '  ';
		  }

		  return result + str;
		}
		/**
		 * Converts a Rule to CSS string.
		 */


		function toCss(selector, style, options) {
		  if (options === void 0) {
		    options = {};
		  }

		  var result = '';
		  if (!style) return result;
		  var _options = options,
		      _options$indent = _options.indent,
		      indent = _options$indent === void 0 ? 0 : _options$indent;
		  var fallbacks = style.fallbacks;

		  if (options.format === false) {
		    indent = -Infinity;
		  }

		  var _getWhitespaceSymbols = getWhitespaceSymbols(options),
		      linebreak = _getWhitespaceSymbols.linebreak,
		      space = _getWhitespaceSymbols.space;

		  if (selector) indent++; // Apply fallbacks first.

		  if (fallbacks) {
		    // Array syntax {fallbacks: [{prop: value}]}
		    if (Array.isArray(fallbacks)) {
		      for (var index = 0; index < fallbacks.length; index++) {
		        var fallback = fallbacks[index];

		        for (var prop in fallback) {
		          var value = fallback[prop];

		          if (value != null) {
		            if (result) result += linebreak;
		            result += indentStr(prop + ":" + space + toCssValue(value) + ";", indent);
		          }
		        }
		      }
		    } else {
		      // Object syntax {fallbacks: {prop: value}}
		      for (var _prop in fallbacks) {
		        var _value = fallbacks[_prop];

		        if (_value != null) {
		          if (result) result += linebreak;
		          result += indentStr(_prop + ":" + space + toCssValue(_value) + ";", indent);
		        }
		      }
		    }
		  }

		  for (var _prop2 in style) {
		    var _value2 = style[_prop2];

		    if (_value2 != null && _prop2 !== 'fallbacks') {
		      if (result) result += linebreak;
		      result += indentStr(_prop2 + ":" + space + toCssValue(_value2) + ";", indent);
		    }
		  } // Allow empty style in this case, because properties will be added dynamically.


		  if (!result && !options.allowEmpty) return result; // When rule is being stringified before selector was defined.

		  if (!selector) return result;
		  indent--;
		  if (result) result = "" + linebreak + result + linebreak;
		  return indentStr("" + selector + space + "{" + result, indent) + indentStr('}', indent);
		}

		var escapeRegex = /([[\].#*$><+~=|^:(),"'`\s])/g;
		var nativeEscape = typeof CSS !== 'undefined' && CSS.escape;
		var escape = (function (str) {
		  return nativeEscape ? nativeEscape(str) : str.replace(escapeRegex, '\\$1');
		});

		var BaseStyleRule =
		/*#__PURE__*/
		function () {
		  function BaseStyleRule(key, style, options) {
		    this.type = 'style';
		    this.isProcessed = false;
		    var sheet = options.sheet,
		        Renderer = options.Renderer;
		    this.key = key;
		    this.options = options;
		    this.style = style;
		    if (sheet) this.renderer = sheet.renderer;else if (Renderer) this.renderer = new Renderer();
		  }
		  /**
		   * Get or set a style property.
		   */


		  var _proto = BaseStyleRule.prototype;

		  _proto.prop = function prop(name, value, options) {
		    // It's a getter.
		    if (value === undefined) return this.style[name]; // Don't do anything if the value has not changed.

		    var force = options ? options.force : false;
		    if (!force && this.style[name] === value) return this;
		    var newValue = value;

		    if (!options || options.process !== false) {
		      newValue = this.options.jss.plugins.onChangeValue(value, name, this);
		    }

		    var isEmpty = newValue == null || newValue === false;
		    var isDefined = name in this.style; // Value is empty and wasn't defined before.

		    if (isEmpty && !isDefined && !force) return this; // We are going to remove this value.

		    var remove = isEmpty && isDefined;
		    if (remove) delete this.style[name];else this.style[name] = newValue; // Renderable is defined if StyleSheet option `link` is true.

		    if (this.renderable && this.renderer) {
		      if (remove) this.renderer.removeProperty(this.renderable, name);else this.renderer.setProperty(this.renderable, name, newValue);
		      return this;
		    }

		    return this;
		  };

		  return BaseStyleRule;
		}();
		var StyleRule =
		/*#__PURE__*/
		function (_BaseStyleRule) {
		  _inheritsLoose(StyleRule, _BaseStyleRule);

		  function StyleRule(key, style, options) {
		    var _this;

		    _this = _BaseStyleRule.call(this, key, style, options) || this;
		    var selector = options.selector,
		        scoped = options.scoped,
		        sheet = options.sheet,
		        generateId = options.generateId;

		    if (selector) {
		      _this.selectorText = selector;
		    } else if (scoped !== false) {
		      _this.id = generateId(_assertThisInitialized(_assertThisInitialized(_this)), sheet);
		      _this.selectorText = "." + escape(_this.id);
		    }

		    return _this;
		  }
		  /**
		   * Set selector string.
		   * Attention: use this with caution. Most browsers didn't implement
		   * selectorText setter, so this may result in rerendering of entire Style Sheet.
		   */


		  var _proto2 = StyleRule.prototype;

		  /**
		   * Apply rule to an element inline.
		   */
		  _proto2.applyTo = function applyTo(renderable) {
		    var renderer = this.renderer;

		    if (renderer) {
		      var json = this.toJSON();

		      for (var prop in json) {
		        renderer.setProperty(renderable, prop, json[prop]);
		      }
		    }

		    return this;
		  }
		  /**
		   * Returns JSON representation of the rule.
		   * Fallbacks are not supported.
		   * Useful for inline styles.
		   */
		  ;

		  _proto2.toJSON = function toJSON() {
		    var json = {};

		    for (var prop in this.style) {
		      var value = this.style[prop];
		      if (typeof value !== 'object') json[prop] = value;else if (Array.isArray(value)) json[prop] = toCssValue(value);
		    }

		    return json;
		  }
		  /**
		   * Generates a CSS string.
		   */
		  ;

		  _proto2.toString = function toString(options) {
		    var sheet = this.options.sheet;
		    var link = sheet ? sheet.options.link : false;
		    var opts = link ? _extends({}, options, {
		      allowEmpty: true
		    }) : options;
		    return toCss(this.selectorText, this.style, opts);
		  };

		  _createClass(StyleRule, [{
		    key: "selector",
		    set: function set(selector) {
		      if (selector === this.selectorText) return;
		      this.selectorText = selector;
		      var renderer = this.renderer,
		          renderable = this.renderable;
		      if (!renderable || !renderer) return;
		      var hasChanged = renderer.setSelector(renderable, selector); // If selector setter is not implemented, rerender the rule.

		      if (!hasChanged) {
		        renderer.replaceRule(renderable, this);
		      }
		    }
		    /**
		     * Get selector string.
		     */
		    ,
		    get: function get() {
		      return this.selectorText;
		    }
		  }]);

		  return StyleRule;
		}(BaseStyleRule);
		var pluginStyleRule = {
		  onCreateRule: function onCreateRule(key, style, options) {
		    if (key[0] === '@' || options.parent && options.parent.type === 'keyframes') {
		      return null;
		    }

		    return new StyleRule(key, style, options);
		  }
		};

		var defaultToStringOptions = {
		  indent: 1,
		  children: true
		};
		var atRegExp = /@([\w-]+)/;
		/**
		 * Conditional rule for @media, @supports
		 */

		var ConditionalRule =
		/*#__PURE__*/
		function () {
		  function ConditionalRule(key, styles, options) {
		    this.type = 'conditional';
		    this.isProcessed = false;
		    this.key = key;
		    var atMatch = key.match(atRegExp);
		    this.at = atMatch ? atMatch[1] : 'unknown'; // Key might contain a unique suffix in case the `name` passed by user was duplicate.

		    this.query = options.name || "@" + this.at;
		    this.options = options;
		    this.rules = new RuleList(_extends({}, options, {
		      parent: this
		    }));

		    for (var name in styles) {
		      this.rules.add(name, styles[name]);
		    }

		    this.rules.process();
		  }
		  /**
		   * Get a rule.
		   */


		  var _proto = ConditionalRule.prototype;

		  _proto.getRule = function getRule(name) {
		    return this.rules.get(name);
		  }
		  /**
		   * Get index of a rule.
		   */
		  ;

		  _proto.indexOf = function indexOf(rule) {
		    return this.rules.indexOf(rule);
		  }
		  /**
		   * Create and register rule, run plugins.
		   */
		  ;

		  _proto.addRule = function addRule(name, style, options) {
		    var rule = this.rules.add(name, style, options);
		    if (!rule) return null;
		    this.options.jss.plugins.onProcessRule(rule);
		    return rule;
		  }
		  /**
		   * Replace rule, run plugins.
		   */
		  ;

		  _proto.replaceRule = function replaceRule(name, style, options) {
		    var newRule = this.rules.replace(name, style, options);
		    if (newRule) this.options.jss.plugins.onProcessRule(newRule);
		    return newRule;
		  }
		  /**
		   * Generates a CSS string.
		   */
		  ;

		  _proto.toString = function toString(options) {
		    if (options === void 0) {
		      options = defaultToStringOptions;
		    }

		    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
		        linebreak = _getWhitespaceSymbols.linebreak;

		    if (options.indent == null) options.indent = defaultToStringOptions.indent;
		    if (options.children == null) options.children = defaultToStringOptions.children;

		    if (options.children === false) {
		      return this.query + " {}";
		    }

		    var children = this.rules.toString(options);
		    return children ? this.query + " {" + linebreak + children + linebreak + "}" : '';
		  };

		  return ConditionalRule;
		}();
		var keyRegExp = /@container|@media|@supports\s+/;
		var pluginConditionalRule = {
		  onCreateRule: function onCreateRule(key, styles, options) {
		    return keyRegExp.test(key) ? new ConditionalRule(key, styles, options) : null;
		  }
		};

		var defaultToStringOptions$1 = {
		  indent: 1,
		  children: true
		};
		var nameRegExp = /@keyframes\s+([\w-]+)/;
		/**
		 * Rule for @keyframes
		 */

		var KeyframesRule =
		/*#__PURE__*/
		function () {
		  function KeyframesRule(key, frames, options) {
		    this.type = 'keyframes';
		    this.at = '@keyframes';
		    this.isProcessed = false;
		    var nameMatch = key.match(nameRegExp);

		    if (nameMatch && nameMatch[1]) {
		      this.name = nameMatch[1];
		    } else {
		      this.name = 'noname';
		    }

		    this.key = this.type + "-" + this.name;
		    this.options = options;
		    var scoped = options.scoped,
		        sheet = options.sheet,
		        generateId = options.generateId;
		    this.id = scoped === false ? this.name : escape(generateId(this, sheet));
		    this.rules = new RuleList(_extends({}, options, {
		      parent: this
		    }));

		    for (var name in frames) {
		      this.rules.add(name, frames[name], _extends({}, options, {
		        parent: this
		      }));
		    }

		    this.rules.process();
		  }
		  /**
		   * Generates a CSS string.
		   */


		  var _proto = KeyframesRule.prototype;

		  _proto.toString = function toString(options) {
		    if (options === void 0) {
		      options = defaultToStringOptions$1;
		    }

		    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
		        linebreak = _getWhitespaceSymbols.linebreak;

		    if (options.indent == null) options.indent = defaultToStringOptions$1.indent;
		    if (options.children == null) options.children = defaultToStringOptions$1.children;

		    if (options.children === false) {
		      return this.at + " " + this.id + " {}";
		    }

		    var children = this.rules.toString(options);
		    if (children) children = "" + linebreak + children + linebreak;
		    return this.at + " " + this.id + " {" + children + "}";
		  };

		  return KeyframesRule;
		}();
		var keyRegExp$1 = /@keyframes\s+/;
		var refRegExp$1 = /\$([\w-]+)/g;

		var findReferencedKeyframe = function findReferencedKeyframe(val, keyframes) {
		  if (typeof val === 'string') {
		    return val.replace(refRegExp$1, function (match, name) {
		      if (name in keyframes) {
		        return keyframes[name];
		      }
		      return match;
		    });
		  }

		  return val;
		};
		/**
		 * Replace the reference for a animation name.
		 */


		var replaceRef = function replaceRef(style, prop, keyframes) {
		  var value = style[prop];
		  var refKeyframe = findReferencedKeyframe(value, keyframes);

		  if (refKeyframe !== value) {
		    style[prop] = refKeyframe;
		  }
		};

		var pluginKeyframesRule = {
		  onCreateRule: function onCreateRule(key, frames, options) {
		    return typeof key === 'string' && keyRegExp$1.test(key) ? new KeyframesRule(key, frames, options) : null;
		  },
		  // Animation name ref replacer.
		  onProcessStyle: function onProcessStyle(style, rule, sheet) {
		    if (rule.type !== 'style' || !sheet) return style;
		    if ('animation-name' in style) replaceRef(style, 'animation-name', sheet.keyframes);
		    if ('animation' in style) replaceRef(style, 'animation', sheet.keyframes);
		    return style;
		  },
		  onChangeValue: function onChangeValue(val, prop, rule) {
		    var sheet = rule.options.sheet;

		    if (!sheet) {
		      return val;
		    }

		    switch (prop) {
		      case 'animation':
		        return findReferencedKeyframe(val, sheet.keyframes);

		      case 'animation-name':
		        return findReferencedKeyframe(val, sheet.keyframes);

		      default:
		        return val;
		    }
		  }
		};

		var KeyframeRule =
		/*#__PURE__*/
		function (_BaseStyleRule) {
		  _inheritsLoose(KeyframeRule, _BaseStyleRule);

		  function KeyframeRule() {
		    return _BaseStyleRule.apply(this, arguments) || this;
		  }

		  var _proto = KeyframeRule.prototype;

		  /**
		   * Generates a CSS string.
		   */
		  _proto.toString = function toString(options) {
		    var sheet = this.options.sheet;
		    var link = sheet ? sheet.options.link : false;
		    var opts = link ? _extends({}, options, {
		      allowEmpty: true
		    }) : options;
		    return toCss(this.key, this.style, opts);
		  };

		  return KeyframeRule;
		}(BaseStyleRule);
		var pluginKeyframeRule = {
		  onCreateRule: function onCreateRule(key, style, options) {
		    if (options.parent && options.parent.type === 'keyframes') {
		      return new KeyframeRule(key, style, options);
		    }

		    return null;
		  }
		};

		var FontFaceRule =
		/*#__PURE__*/
		function () {
		  function FontFaceRule(key, style, options) {
		    this.type = 'font-face';
		    this.at = '@font-face';
		    this.isProcessed = false;
		    this.key = key;
		    this.style = style;
		    this.options = options;
		  }
		  /**
		   * Generates a CSS string.
		   */


		  var _proto = FontFaceRule.prototype;

		  _proto.toString = function toString(options) {
		    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
		        linebreak = _getWhitespaceSymbols.linebreak;

		    if (Array.isArray(this.style)) {
		      var str = '';

		      for (var index = 0; index < this.style.length; index++) {
		        str += toCss(this.at, this.style[index]);
		        if (this.style[index + 1]) str += linebreak;
		      }

		      return str;
		    }

		    return toCss(this.at, this.style, options);
		  };

		  return FontFaceRule;
		}();
		var keyRegExp$2 = /@font-face/;
		var pluginFontFaceRule = {
		  onCreateRule: function onCreateRule(key, style, options) {
		    return keyRegExp$2.test(key) ? new FontFaceRule(key, style, options) : null;
		  }
		};

		var ViewportRule =
		/*#__PURE__*/
		function () {
		  function ViewportRule(key, style, options) {
		    this.type = 'viewport';
		    this.at = '@viewport';
		    this.isProcessed = false;
		    this.key = key;
		    this.style = style;
		    this.options = options;
		  }
		  /**
		   * Generates a CSS string.
		   */


		  var _proto = ViewportRule.prototype;

		  _proto.toString = function toString(options) {
		    return toCss(this.key, this.style, options);
		  };

		  return ViewportRule;
		}();
		var pluginViewportRule = {
		  onCreateRule: function onCreateRule(key, style, options) {
		    return key === '@viewport' || key === '@-ms-viewport' ? new ViewportRule(key, style, options) : null;
		  }
		};

		var SimpleRule =
		/*#__PURE__*/
		function () {
		  function SimpleRule(key, value, options) {
		    this.type = 'simple';
		    this.isProcessed = false;
		    this.key = key;
		    this.value = value;
		    this.options = options;
		  }
		  /**
		   * Generates a CSS string.
		   */
		  // eslint-disable-next-line no-unused-vars


		  var _proto = SimpleRule.prototype;

		  _proto.toString = function toString(options) {
		    if (Array.isArray(this.value)) {
		      var str = '';

		      for (var index = 0; index < this.value.length; index++) {
		        str += this.key + " " + this.value[index] + ";";
		        if (this.value[index + 1]) str += '\n';
		      }

		      return str;
		    }

		    return this.key + " " + this.value + ";";
		  };

		  return SimpleRule;
		}();
		var keysMap = {
		  '@charset': true,
		  '@import': true,
		  '@namespace': true
		};
		var pluginSimpleRule = {
		  onCreateRule: function onCreateRule(key, value, options) {
		    return key in keysMap ? new SimpleRule(key, value, options) : null;
		  }
		};

		var plugins = [pluginStyleRule, pluginConditionalRule, pluginKeyframesRule, pluginKeyframeRule, pluginFontFaceRule, pluginViewportRule, pluginSimpleRule];

		var defaultUpdateOptions = {
		  process: true
		};
		var forceUpdateOptions = {
		  force: true,
		  process: true
		  /**
		   * Contains rules objects and allows adding/removing etc.
		   * Is used for e.g. by `StyleSheet` or `ConditionalRule`.
		   */

		};

		var RuleList =
		/*#__PURE__*/
		function () {
		  // Rules registry for access by .get() method.
		  // It contains the same rule registered by name and by selector.
		  // Original styles object.
		  // Used to ensure correct rules order.
		  function RuleList(options) {
		    this.map = {};
		    this.raw = {};
		    this.index = [];
		    this.counter = 0;
		    this.options = options;
		    this.classes = options.classes;
		    this.keyframes = options.keyframes;
		  }
		  /**
		   * Create and register rule.
		   *
		   * Will not render after Style Sheet was rendered the first time.
		   */


		  var _proto = RuleList.prototype;

		  _proto.add = function add(name, decl, ruleOptions) {
		    var _this$options = this.options,
		        parent = _this$options.parent,
		        sheet = _this$options.sheet,
		        jss = _this$options.jss,
		        Renderer = _this$options.Renderer,
		        generateId = _this$options.generateId,
		        scoped = _this$options.scoped;

		    var options = _extends({
		      classes: this.classes,
		      parent: parent,
		      sheet: sheet,
		      jss: jss,
		      Renderer: Renderer,
		      generateId: generateId,
		      scoped: scoped,
		      name: name,
		      keyframes: this.keyframes,
		      selector: undefined
		    }, ruleOptions); // When user uses .createStyleSheet(), duplicate names are not possible, but
		    // `sheet.addRule()` opens the door for any duplicate rule name. When this happens
		    // we need to make the key unique within this RuleList instance scope.


		    var key = name;

		    if (name in this.raw) {
		      key = name + "-d" + this.counter++;
		    } // We need to save the original decl before creating the rule
		    // because cache plugin needs to use it as a key to return a cached rule.


		    this.raw[key] = decl;

		    if (key in this.classes) {
		      // E.g. rules inside of @media container
		      options.selector = "." + escape(this.classes[key]);
		    }

		    var rule = createRule(key, decl, options);
		    if (!rule) return null;
		    this.register(rule);
		    var index = options.index === undefined ? this.index.length : options.index;
		    this.index.splice(index, 0, rule);
		    return rule;
		  }
		  /**
		   * Replace rule.
		   * Create a new rule and remove old one instead of overwriting
		   * because we want to invoke onCreateRule hook to make plugins work.
		   */
		  ;

		  _proto.replace = function replace(name, decl, ruleOptions) {
		    var oldRule = this.get(name);
		    var oldIndex = this.index.indexOf(oldRule);

		    if (oldRule) {
		      this.remove(oldRule);
		    }

		    var options = ruleOptions;
		    if (oldIndex !== -1) options = _extends({}, ruleOptions, {
		      index: oldIndex
		    });
		    return this.add(name, decl, options);
		  }
		  /**
		   * Get a rule by name or selector.
		   */
		  ;

		  _proto.get = function get(nameOrSelector) {
		    return this.map[nameOrSelector];
		  }
		  /**
		   * Delete a rule.
		   */
		  ;

		  _proto.remove = function remove(rule) {
		    this.unregister(rule);
		    delete this.raw[rule.key];
		    this.index.splice(this.index.indexOf(rule), 1);
		  }
		  /**
		   * Get index of a rule.
		   */
		  ;

		  _proto.indexOf = function indexOf(rule) {
		    return this.index.indexOf(rule);
		  }
		  /**
		   * Run `onProcessRule()` plugins on every rule.
		   */
		  ;

		  _proto.process = function process() {
		    var plugins = this.options.jss.plugins; // We need to clone array because if we modify the index somewhere else during a loop
		    // we end up with very hard-to-track-down side effects.

		    this.index.slice(0).forEach(plugins.onProcessRule, plugins);
		  }
		  /**
		   * Register a rule in `.map`, `.classes` and `.keyframes` maps.
		   */
		  ;

		  _proto.register = function register(rule) {
		    this.map[rule.key] = rule;

		    if (rule instanceof StyleRule) {
		      this.map[rule.selector] = rule;
		      if (rule.id) this.classes[rule.key] = rule.id;
		    } else if (rule instanceof KeyframesRule && this.keyframes) {
		      this.keyframes[rule.name] = rule.id;
		    }
		  }
		  /**
		   * Unregister a rule.
		   */
		  ;

		  _proto.unregister = function unregister(rule) {
		    delete this.map[rule.key];

		    if (rule instanceof StyleRule) {
		      delete this.map[rule.selector];
		      delete this.classes[rule.key];
		    } else if (rule instanceof KeyframesRule) {
		      delete this.keyframes[rule.name];
		    }
		  }
		  /**
		   * Update the function values with a new data.
		   */
		  ;

		  _proto.update = function update() {
		    var name;
		    var data;
		    var options;

		    if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {
		      name = arguments.length <= 0 ? undefined : arguments[0];
		      data = arguments.length <= 1 ? undefined : arguments[1];
		      options = arguments.length <= 2 ? undefined : arguments[2];
		    } else {
		      data = arguments.length <= 0 ? undefined : arguments[0];
		      options = arguments.length <= 1 ? undefined : arguments[1];
		      name = null;
		    }

		    if (name) {
		      this.updateOne(this.get(name), data, options);
		    } else {
		      for (var index = 0; index < this.index.length; index++) {
		        this.updateOne(this.index[index], data, options);
		      }
		    }
		  }
		  /**
		   * Execute plugins, update rule props.
		   */
		  ;

		  _proto.updateOne = function updateOne(rule, data, options) {
		    if (options === void 0) {
		      options = defaultUpdateOptions;
		    }

		    var _this$options2 = this.options,
		        plugins = _this$options2.jss.plugins,
		        sheet = _this$options2.sheet; // It is a rules container like for e.g. ConditionalRule.

		    if (rule.rules instanceof RuleList) {
		      rule.rules.update(data, options);
		      return;
		    }

		    var style = rule.style;
		    plugins.onUpdate(data, rule, sheet, options); // We rely on a new `style` ref in case it was mutated during onUpdate hook.

		    if (options.process && style && style !== rule.style) {
		      // We need to run the plugins in case new `style` relies on syntax plugins.
		      plugins.onProcessStyle(rule.style, rule, sheet); // Update and add props.

		      for (var prop in rule.style) {
		        var nextValue = rule.style[prop];
		        var prevValue = style[prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
		        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.

		        if (nextValue !== prevValue) {
		          rule.prop(prop, nextValue, forceUpdateOptions);
		        }
		      } // Remove props.


		      for (var _prop in style) {
		        var _nextValue = rule.style[_prop];
		        var _prevValue = style[_prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
		        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.

		        if (_nextValue == null && _nextValue !== _prevValue) {
		          rule.prop(_prop, null, forceUpdateOptions);
		        }
		      }
		    }
		  }
		  /**
		   * Convert rules to a CSS string.
		   */
		  ;

		  _proto.toString = function toString(options) {
		    var str = '';
		    var sheet = this.options.sheet;
		    var link = sheet ? sheet.options.link : false;

		    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
		        linebreak = _getWhitespaceSymbols.linebreak;

		    for (var index = 0; index < this.index.length; index++) {
		      var rule = this.index[index];
		      var css = rule.toString(options); // No need to render an empty rule.

		      if (!css && !link) continue;
		      if (str) str += linebreak;
		      str += css;
		    }

		    return str;
		  };

		  return RuleList;
		}();

		var StyleSheet =
		/*#__PURE__*/
		function () {
		  function StyleSheet(styles, options) {
		    this.attached = false;
		    this.deployed = false;
		    this.classes = {};
		    this.keyframes = {};
		    this.options = _extends({}, options, {
		      sheet: this,
		      parent: this,
		      classes: this.classes,
		      keyframes: this.keyframes
		    });

		    if (options.Renderer) {
		      this.renderer = new options.Renderer(this);
		    }

		    this.rules = new RuleList(this.options);

		    for (var name in styles) {
		      this.rules.add(name, styles[name]);
		    }

		    this.rules.process();
		  }
		  /**
		   * Attach renderable to the render tree.
		   */


		  var _proto = StyleSheet.prototype;

		  _proto.attach = function attach() {
		    if (this.attached) return this;
		    if (this.renderer) this.renderer.attach();
		    this.attached = true; // Order is important, because we can't use insertRule API if style element is not attached.

		    if (!this.deployed) this.deploy();
		    return this;
		  }
		  /**
		   * Remove renderable from render tree.
		   */
		  ;

		  _proto.detach = function detach() {
		    if (!this.attached) return this;
		    if (this.renderer) this.renderer.detach();
		    this.attached = false;
		    return this;
		  }
		  /**
		   * Add a rule to the current stylesheet.
		   * Will insert a rule also after the stylesheet has been rendered first time.
		   */
		  ;

		  _proto.addRule = function addRule(name, decl, options) {
		    var queue = this.queue; // Plugins can create rules.
		    // In order to preserve the right order, we need to queue all `.addRule` calls,
		    // which happen after the first `rules.add()` call.

		    if (this.attached && !queue) this.queue = [];
		    var rule = this.rules.add(name, decl, options);
		    if (!rule) return null;
		    this.options.jss.plugins.onProcessRule(rule);

		    if (this.attached) {
		      if (!this.deployed) return rule; // Don't insert rule directly if there is no stringified version yet.
		      // It will be inserted all together when .attach is called.

		      if (queue) queue.push(rule);else {
		        this.insertRule(rule);

		        if (this.queue) {
		          this.queue.forEach(this.insertRule, this);
		          this.queue = undefined;
		        }
		      }
		      return rule;
		    } // We can't add rules to a detached style node.
		    // We will redeploy the sheet once user will attach it.


		    this.deployed = false;
		    return rule;
		  }
		  /**
		   * Replace a rule in the current stylesheet.
		   */
		  ;

		  _proto.replaceRule = function replaceRule(nameOrSelector, decl, options) {
		    var oldRule = this.rules.get(nameOrSelector);
		    if (!oldRule) return this.addRule(nameOrSelector, decl, options);
		    var newRule = this.rules.replace(nameOrSelector, decl, options);

		    if (newRule) {
		      this.options.jss.plugins.onProcessRule(newRule);
		    }

		    if (this.attached) {
		      if (!this.deployed) return newRule; // Don't replace / delete rule directly if there is no stringified version yet.
		      // It will be inserted all together when .attach is called.

		      if (this.renderer) {
		        if (!newRule) {
		          this.renderer.deleteRule(oldRule);
		        } else if (oldRule.renderable) {
		          this.renderer.replaceRule(oldRule.renderable, newRule);
		        }
		      }

		      return newRule;
		    } // We can't replace rules to a detached style node.
		    // We will redeploy the sheet once user will attach it.


		    this.deployed = false;
		    return newRule;
		  }
		  /**
		   * Insert rule into the StyleSheet
		   */
		  ;

		  _proto.insertRule = function insertRule(rule) {
		    if (this.renderer) {
		      this.renderer.insertRule(rule);
		    }
		  }
		  /**
		   * Create and add rules.
		   * Will render also after Style Sheet was rendered the first time.
		   */
		  ;

		  _proto.addRules = function addRules(styles, options) {
		    var added = [];

		    for (var name in styles) {
		      var rule = this.addRule(name, styles[name], options);
		      if (rule) added.push(rule);
		    }

		    return added;
		  }
		  /**
		   * Get a rule by name or selector.
		   */
		  ;

		  _proto.getRule = function getRule(nameOrSelector) {
		    return this.rules.get(nameOrSelector);
		  }
		  /**
		   * Delete a rule by name.
		   * Returns `true`: if rule has been deleted from the DOM.
		   */
		  ;

		  _proto.deleteRule = function deleteRule(name) {
		    var rule = typeof name === 'object' ? name : this.rules.get(name);

		    if (!rule || // Style sheet was created without link: true and attached, in this case we
		    // won't be able to remove the CSS rule from the DOM.
		    this.attached && !rule.renderable) {
		      return false;
		    }

		    this.rules.remove(rule);

		    if (this.attached && rule.renderable && this.renderer) {
		      return this.renderer.deleteRule(rule.renderable);
		    }

		    return true;
		  }
		  /**
		   * Get index of a rule.
		   */
		  ;

		  _proto.indexOf = function indexOf(rule) {
		    return this.rules.indexOf(rule);
		  }
		  /**
		   * Deploy pure CSS string to a renderable.
		   */
		  ;

		  _proto.deploy = function deploy() {
		    if (this.renderer) this.renderer.deploy();
		    this.deployed = true;
		    return this;
		  }
		  /**
		   * Update the function values with a new data.
		   */
		  ;

		  _proto.update = function update() {
		    var _this$rules;

		    (_this$rules = this.rules).update.apply(_this$rules, arguments);

		    return this;
		  }
		  /**
		   * Updates a single rule.
		   */
		  ;

		  _proto.updateOne = function updateOne(rule, data, options) {
		    this.rules.updateOne(rule, data, options);
		    return this;
		  }
		  /**
		   * Convert rules to a CSS string.
		   */
		  ;

		  _proto.toString = function toString(options) {
		    return this.rules.toString(options);
		  };

		  return StyleSheet;
		}();

		var PluginsRegistry =
		/*#__PURE__*/
		function () {
		  function PluginsRegistry() {
		    this.plugins = {
		      internal: [],
		      external: []
		    };
		    this.registry = {};
		  }

		  var _proto = PluginsRegistry.prototype;

		  /**
		   * Call `onCreateRule` hooks and return an object if returned by a hook.
		   */
		  _proto.onCreateRule = function onCreateRule(name, decl, options) {
		    for (var i = 0; i < this.registry.onCreateRule.length; i++) {
		      var rule = this.registry.onCreateRule[i](name, decl, options);
		      if (rule) return rule;
		    }

		    return null;
		  }
		  /**
		   * Call `onProcessRule` hooks.
		   */
		  ;

		  _proto.onProcessRule = function onProcessRule(rule) {
		    if (rule.isProcessed) return;
		    var sheet = rule.options.sheet;

		    for (var i = 0; i < this.registry.onProcessRule.length; i++) {
		      this.registry.onProcessRule[i](rule, sheet);
		    }

		    if (rule.style) this.onProcessStyle(rule.style, rule, sheet);
		    rule.isProcessed = true;
		  }
		  /**
		   * Call `onProcessStyle` hooks.
		   */
		  ;

		  _proto.onProcessStyle = function onProcessStyle(style, rule, sheet) {
		    for (var i = 0; i < this.registry.onProcessStyle.length; i++) {
		      rule.style = this.registry.onProcessStyle[i](rule.style, rule, sheet);
		    }
		  }
		  /**
		   * Call `onProcessSheet` hooks.
		   */
		  ;

		  _proto.onProcessSheet = function onProcessSheet(sheet) {
		    for (var i = 0; i < this.registry.onProcessSheet.length; i++) {
		      this.registry.onProcessSheet[i](sheet);
		    }
		  }
		  /**
		   * Call `onUpdate` hooks.
		   */
		  ;

		  _proto.onUpdate = function onUpdate(data, rule, sheet, options) {
		    for (var i = 0; i < this.registry.onUpdate.length; i++) {
		      this.registry.onUpdate[i](data, rule, sheet, options);
		    }
		  }
		  /**
		   * Call `onChangeValue` hooks.
		   */
		  ;

		  _proto.onChangeValue = function onChangeValue(value, prop, rule) {
		    var processedValue = value;

		    for (var i = 0; i < this.registry.onChangeValue.length; i++) {
		      processedValue = this.registry.onChangeValue[i](processedValue, prop, rule);
		    }

		    return processedValue;
		  }
		  /**
		   * Register a plugin.
		   */
		  ;

		  _proto.use = function use(newPlugin, options) {
		    if (options === void 0) {
		      options = {
		        queue: 'external'
		      };
		    }

		    var plugins = this.plugins[options.queue]; // Avoids applying same plugin twice, at least based on ref.

		    if (plugins.indexOf(newPlugin) !== -1) {
		      return;
		    }

		    plugins.push(newPlugin);
		    this.registry = [].concat(this.plugins.external, this.plugins.internal).reduce(function (registry, plugin) {
		      for (var name in plugin) {
		        if (name in registry) {
		          registry[name].push(plugin[name]);
		        }
		      }

		      return registry;
		    }, {
		      onCreateRule: [],
		      onProcessRule: [],
		      onProcessStyle: [],
		      onProcessSheet: [],
		      onChangeValue: [],
		      onUpdate: []
		    });
		  };

		  return PluginsRegistry;
		}();

		/**
		 * Sheets registry to access all instances in one place.
		 */

		var SheetsRegistry =
		/*#__PURE__*/
		function () {
		  function SheetsRegistry() {
		    this.registry = [];
		  }

		  var _proto = SheetsRegistry.prototype;

		  /**
		   * Register a Style Sheet.
		   */
		  _proto.add = function add(sheet) {
		    var registry = this.registry;
		    var index = sheet.options.index;
		    if (registry.indexOf(sheet) !== -1) return;

		    if (registry.length === 0 || index >= this.index) {
		      registry.push(sheet);
		      return;
		    } // Find a position.


		    for (var i = 0; i < registry.length; i++) {
		      if (registry[i].options.index > index) {
		        registry.splice(i, 0, sheet);
		        return;
		      }
		    }
		  }
		  /**
		   * Reset the registry.
		   */
		  ;

		  _proto.reset = function reset() {
		    this.registry = [];
		  }
		  /**
		   * Remove a Style Sheet.
		   */
		  ;

		  _proto.remove = function remove(sheet) {
		    var index = this.registry.indexOf(sheet);
		    this.registry.splice(index, 1);
		  }
		  /**
		   * Convert all attached sheets to a CSS string.
		   */
		  ;

		  _proto.toString = function toString(_temp) {
		    var _ref = _temp === void 0 ? {} : _temp,
		        attached = _ref.attached,
		        options = _objectWithoutPropertiesLoose(_ref, ["attached"]);

		    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
		        linebreak = _getWhitespaceSymbols.linebreak;

		    var css = '';

		    for (var i = 0; i < this.registry.length; i++) {
		      var sheet = this.registry[i];

		      if (attached != null && sheet.attached !== attached) {
		        continue;
		      }

		      if (css) css += linebreak;
		      css += sheet.toString(options);
		    }

		    return css;
		  };

		  _createClass(SheetsRegistry, [{
		    key: "index",

		    /**
		     * Current highest index number.
		     */
		    get: function get() {
		      return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;
		    }
		  }]);

		  return SheetsRegistry;
		}();

		/**
		 * This is a global sheets registry. Only DomRenderer will add sheets to it.
		 * On the server one should use an own SheetsRegistry instance and add the
		 * sheets to it, because you need to make sure to create a new registry for
		 * each request in order to not leak sheets across requests.
		 */

		var sheets = new SheetsRegistry();

		/* eslint-disable */

		/**
		 * Now that `globalThis` is available on most platforms
		 * (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis#browser_compatibility)
		 * we check for `globalThis` first. `globalThis` is necessary for jss
		 * to run in Agoric's secure version of JavaScript (SES). Under SES,
		 * `globalThis` exists, but `window`, `self`, and `Function('return
		 * this')()` are all undefined for security reasons.
		 *
		 * https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
		 */
		var globalThis$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' && window.Math === Math ? window : typeof self !== 'undefined' && self.Math === Math ? self : Function('return this')();

		var ns = '2f1acc6c3a606b082e5eef5e54414ffb';
		if (globalThis$1[ns] == null) globalThis$1[ns] = 0; // Bundle may contain multiple JSS versions at the same time. In order to identify
		// the current version with just one short number and use it for classes generation
		// we use a counter. Also it is more accurate, because user can manually reevaluate
		// the module.

		var moduleId = globalThis$1[ns]++;
		/**
		 * Returns a function which generates unique class names based on counters.
		 * When new generator function is created, rule counter is reseted.
		 * We need to reset the rule counter for SSR for each request.
		 */

		var createGenerateId = function createGenerateId(options) {
		  if (options === void 0) {
		    options = {};
		  }

		  var ruleCounter = 0;

		  var generateId = function generateId(rule, sheet) {
		    ruleCounter += 1;

		    var jssId = '';
		    var prefix = '';

		    if (sheet) {
		      if (sheet.options.classNamePrefix) {
		        prefix = sheet.options.classNamePrefix;
		      }

		      if (sheet.options.jss.id != null) {
		        jssId = String(sheet.options.jss.id);
		      }
		    }

		    if (options.minify) {
		      // Using "c" because a number can't be the first char in a class name.
		      return "" + (prefix || 'c') + moduleId + jssId + ruleCounter;
		    }

		    return prefix + rule.key + "-" + moduleId + (jssId ? "-" + jssId : '') + "-" + ruleCounter;
		  };

		  return generateId;
		};

		/**
		 * Cache the value from the first time a function is called.
		 */

		var memoize = function memoize(fn) {
		  var value;
		  return function () {
		    if (!value) value = fn();
		    return value;
		  };
		};
		/**
		 * Get a style property value.
		 */


		var getPropertyValue = function getPropertyValue(cssRule, prop) {
		  try {
		    // Support CSSTOM.
		    if (cssRule.attributeStyleMap) {
		      return cssRule.attributeStyleMap.get(prop);
		    }

		    return cssRule.style.getPropertyValue(prop);
		  } catch (err) {
		    // IE may throw if property is unknown.
		    return '';
		  }
		};
		/**
		 * Set a style property.
		 */


		var setProperty = function setProperty(cssRule, prop, value) {
		  try {
		    var cssValue = value;

		    if (Array.isArray(value)) {
		      cssValue = toCssValue(value);
		    } // Support CSSTOM.


		    if (cssRule.attributeStyleMap) {
		      cssRule.attributeStyleMap.set(prop, cssValue);
		    } else {
		      var indexOfImportantFlag = cssValue ? cssValue.indexOf('!important') : -1;
		      var cssValueWithoutImportantFlag = indexOfImportantFlag > -1 ? cssValue.substr(0, indexOfImportantFlag - 1) : cssValue;
		      cssRule.style.setProperty(prop, cssValueWithoutImportantFlag, indexOfImportantFlag > -1 ? 'important' : '');
		    }
		  } catch (err) {
		    // IE may throw if property is unknown.
		    return false;
		  }

		  return true;
		};
		/**
		 * Remove a style property.
		 */


		var removeProperty = function removeProperty(cssRule, prop) {
		  try {
		    // Support CSSTOM.
		    if (cssRule.attributeStyleMap) {
		      cssRule.attributeStyleMap.delete(prop);
		    } else {
		      cssRule.style.removeProperty(prop);
		    }
		  } catch (err) {
		  }
		};
		/**
		 * Set the selector.
		 */


		var setSelector = function setSelector(cssRule, selectorText) {
		  cssRule.selectorText = selectorText; // Return false if setter was not successful.
		  // Currently works in chrome only.

		  return cssRule.selectorText === selectorText;
		};
		/**
		 * Gets the `head` element upon the first call and caches it.
		 * We assume it can't be null.
		 */


		var getHead = memoize(function () {
		  return document.querySelector('head');
		});
		/**
		 * Find attached sheet with an index higher than the passed one.
		 */

		function findHigherSheet(registry, options) {
		  for (var i = 0; i < registry.length; i++) {
		    var sheet = registry[i];

		    if (sheet.attached && sheet.options.index > options.index && sheet.options.insertionPoint === options.insertionPoint) {
		      return sheet;
		    }
		  }

		  return null;
		}
		/**
		 * Find attached sheet with the highest index.
		 */


		function findHighestSheet(registry, options) {
		  for (var i = registry.length - 1; i >= 0; i--) {
		    var sheet = registry[i];

		    if (sheet.attached && sheet.options.insertionPoint === options.insertionPoint) {
		      return sheet;
		    }
		  }

		  return null;
		}
		/**
		 * Find a comment with "jss" inside.
		 */


		function findCommentNode(text) {
		  var head = getHead();

		  for (var i = 0; i < head.childNodes.length; i++) {
		    var node = head.childNodes[i];

		    if (node.nodeType === 8 && node.nodeValue.trim() === text) {
		      return node;
		    }
		  }

		  return null;
		}
		/**
		 * Find a node before which we can insert the sheet.
		 */


		function findPrevNode(options) {
		  var registry = sheets.registry;

		  if (registry.length > 0) {
		    // Try to insert before the next higher sheet.
		    var sheet = findHigherSheet(registry, options);

		    if (sheet && sheet.renderer) {
		      return {
		        parent: sheet.renderer.element.parentNode,
		        node: sheet.renderer.element
		      };
		    } // Otherwise insert after the last attached.


		    sheet = findHighestSheet(registry, options);

		    if (sheet && sheet.renderer) {
		      return {
		        parent: sheet.renderer.element.parentNode,
		        node: sheet.renderer.element.nextSibling
		      };
		    }
		  } // Try to find a comment placeholder if registry is empty.


		  var insertionPoint = options.insertionPoint;

		  if (insertionPoint && typeof insertionPoint === 'string') {
		    var comment = findCommentNode(insertionPoint);

		    if (comment) {
		      return {
		        parent: comment.parentNode,
		        node: comment.nextSibling
		      };
		    } // If user specifies an insertion point and it can't be found in the document -
		  }

		  return false;
		}
		/**
		 * Insert style element into the DOM.
		 */


		function insertStyle(style, options) {
		  var insertionPoint = options.insertionPoint;
		  var nextNode = findPrevNode(options);

		  if (nextNode !== false && nextNode.parent) {
		    nextNode.parent.insertBefore(style, nextNode.node);
		    return;
		  } // Works with iframes and any node types.


		  if (insertionPoint && typeof insertionPoint.nodeType === 'number') {
		    var insertionPointElement = insertionPoint;
		    var parentNode = insertionPointElement.parentNode;
		    if (parentNode) parentNode.insertBefore(style, insertionPointElement.nextSibling);
		    return;
		  }

		  getHead().appendChild(style);
		}
		/**
		 * Read jss nonce setting from the page if the user has set it.
		 */


		var getNonce = memoize(function () {
		  var node = document.querySelector('meta[property="csp-nonce"]');
		  return node ? node.getAttribute('content') : null;
		});

		var _insertRule = function insertRule(container, rule, index) {
		  try {
		    if ('insertRule' in container) {
		      container.insertRule(rule, index);
		    } // Keyframes rule.
		    else if ('appendRule' in container) {
		        container.appendRule(rule);
		      }
		  } catch (err) {
		    return false;
		  }

		  return container.cssRules[index];
		};

		var getValidRuleInsertionIndex = function getValidRuleInsertionIndex(container, index) {
		  var maxIndex = container.cssRules.length; // In case previous insertion fails, passed index might be wrong

		  if (index === undefined || index > maxIndex) {
		    // eslint-disable-next-line no-param-reassign
		    return maxIndex;
		  }

		  return index;
		};

		var createStyle = function createStyle() {
		  var el = document.createElement('style'); // Without it, IE will have a broken source order specificity if we
		  // insert rules after we insert the style tag.
		  // It seems to kick-off the source order specificity algorithm.

		  el.textContent = '\n';
		  return el;
		};

		var DomRenderer =
		/*#__PURE__*/
		function () {
		  // Will be empty if link: true option is not set, because
		  // it is only for use together with insertRule API.
		  function DomRenderer(sheet) {
		    this.getPropertyValue = getPropertyValue;
		    this.setProperty = setProperty;
		    this.removeProperty = removeProperty;
		    this.setSelector = setSelector;
		    this.hasInsertedRules = false;
		    this.cssRules = [];
		    // There is no sheet when the renderer is used from a standalone StyleRule.
		    if (sheet) sheets.add(sheet);
		    this.sheet = sheet;

		    var _ref = this.sheet ? this.sheet.options : {},
		        media = _ref.media,
		        meta = _ref.meta,
		        element = _ref.element;

		    this.element = element || createStyle();
		    this.element.setAttribute('data-jss', '');
		    if (media) this.element.setAttribute('media', media);
		    if (meta) this.element.setAttribute('data-meta', meta);
		    var nonce = getNonce();
		    if (nonce) this.element.setAttribute('nonce', nonce);
		  }
		  /**
		   * Insert style element into render tree.
		   */


		  var _proto = DomRenderer.prototype;

		  _proto.attach = function attach() {
		    // In the case the element node is external and it is already in the DOM.
		    if (this.element.parentNode || !this.sheet) return;
		    insertStyle(this.element, this.sheet.options); // When rules are inserted using `insertRule` API, after `sheet.detach().attach()`
		    // most browsers create a new CSSStyleSheet, except of all IEs.

		    var deployed = Boolean(this.sheet && this.sheet.deployed);

		    if (this.hasInsertedRules && deployed) {
		      this.hasInsertedRules = false;
		      this.deploy();
		    }
		  }
		  /**
		   * Remove style element from render tree.
		   */
		  ;

		  _proto.detach = function detach() {
		    if (!this.sheet) return;
		    var parentNode = this.element.parentNode;
		    if (parentNode) parentNode.removeChild(this.element); // In the most browsers, rules inserted using insertRule() API will be lost when style element is removed.
		    // Though IE will keep them and we need a consistent behavior.

		    if (this.sheet.options.link) {
		      this.cssRules = [];
		      this.element.textContent = '\n';
		    }
		  }
		  /**
		   * Inject CSS string into element.
		   */
		  ;

		  _proto.deploy = function deploy() {
		    var sheet = this.sheet;
		    if (!sheet) return;

		    if (sheet.options.link) {
		      this.insertRules(sheet.rules);
		      return;
		    }

		    this.element.textContent = "\n" + sheet.toString() + "\n";
		  }
		  /**
		   * Insert RuleList into an element.
		   */
		  ;

		  _proto.insertRules = function insertRules(rules, nativeParent) {
		    for (var i = 0; i < rules.index.length; i++) {
		      this.insertRule(rules.index[i], i, nativeParent);
		    }
		  }
		  /**
		   * Insert a rule into element.
		   */
		  ;

		  _proto.insertRule = function insertRule(rule, index, nativeParent) {
		    if (nativeParent === void 0) {
		      nativeParent = this.element.sheet;
		    }

		    if (rule.rules) {
		      var parent = rule;
		      var latestNativeParent = nativeParent;

		      if (rule.type === 'conditional' || rule.type === 'keyframes') {
		        var _insertionIndex = getValidRuleInsertionIndex(nativeParent, index); // We need to render the container without children first.


		        latestNativeParent = _insertRule(nativeParent, parent.toString({
		          children: false
		        }), _insertionIndex);

		        if (latestNativeParent === false) {
		          return false;
		        }

		        this.refCssRule(rule, _insertionIndex, latestNativeParent);
		      }

		      this.insertRules(parent.rules, latestNativeParent);
		      return latestNativeParent;
		    }

		    var ruleStr = rule.toString();
		    if (!ruleStr) return false;
		    var insertionIndex = getValidRuleInsertionIndex(nativeParent, index);

		    var nativeRule = _insertRule(nativeParent, ruleStr, insertionIndex);

		    if (nativeRule === false) {
		      return false;
		    }

		    this.hasInsertedRules = true;
		    this.refCssRule(rule, insertionIndex, nativeRule);
		    return nativeRule;
		  };

		  _proto.refCssRule = function refCssRule(rule, index, cssRule) {
		    rule.renderable = cssRule; // We only want to reference the top level rules, deleteRule API doesn't support removing nested rules
		    // like rules inside media queries or keyframes

		    if (rule.options.parent instanceof StyleSheet) {
		      this.cssRules.splice(index, 0, cssRule);
		    }
		  }
		  /**
		   * Delete a rule.
		   */
		  ;

		  _proto.deleteRule = function deleteRule(cssRule) {
		    var sheet = this.element.sheet;
		    var index = this.indexOf(cssRule);
		    if (index === -1) return false;
		    sheet.deleteRule(index);
		    this.cssRules.splice(index, 1);
		    return true;
		  }
		  /**
		   * Get index of a CSS Rule.
		   */
		  ;

		  _proto.indexOf = function indexOf(cssRule) {
		    return this.cssRules.indexOf(cssRule);
		  }
		  /**
		   * Generate a new CSS rule and replace the existing one.
		   */
		  ;

		  _proto.replaceRule = function replaceRule(cssRule, rule) {
		    var index = this.indexOf(cssRule);
		    if (index === -1) return false;
		    this.element.sheet.deleteRule(index);
		    this.cssRules.splice(index, 1);
		    return this.insertRule(rule, index);
		  }
		  /**
		   * Get all rules elements.
		   */
		  ;

		  _proto.getRules = function getRules() {
		    return this.element.sheet.cssRules;
		  };

		  return DomRenderer;
		}();

		var instanceCounter = 0;

		var Jss =
		/*#__PURE__*/
		function () {
		  function Jss(options) {
		    this.id = instanceCounter++;
		    this.version = "10.10.0";
		    this.plugins = new PluginsRegistry();
		    this.options = {
		      id: {
		        minify: false
		      },
		      createGenerateId: createGenerateId,
		      Renderer: isBrowser ? DomRenderer : null,
		      plugins: []
		    };
		    this.generateId = createGenerateId({
		      minify: false
		    });

		    for (var i = 0; i < plugins.length; i++) {
		      this.plugins.use(plugins[i], {
		        queue: 'internal'
		      });
		    }

		    this.setup(options);
		  }
		  /**
		   * Prepares various options, applies plugins.
		   * Should not be used twice on the same instance, because there is no plugins
		   * deduplication logic.
		   */


		  var _proto = Jss.prototype;

		  _proto.setup = function setup(options) {
		    if (options === void 0) {
		      options = {};
		    }

		    if (options.createGenerateId) {
		      this.options.createGenerateId = options.createGenerateId;
		    }

		    if (options.id) {
		      this.options.id = _extends({}, this.options.id, options.id);
		    }

		    if (options.createGenerateId || options.id) {
		      this.generateId = this.options.createGenerateId(this.options.id);
		    }

		    if (options.insertionPoint != null) this.options.insertionPoint = options.insertionPoint;

		    if ('Renderer' in options) {
		      this.options.Renderer = options.Renderer;
		    } // eslint-disable-next-line prefer-spread


		    if (options.plugins) this.use.apply(this, options.plugins);
		    return this;
		  }
		  /**
		   * Create a Style Sheet.
		   */
		  ;

		  _proto.createStyleSheet = function createStyleSheet(styles, options) {
		    if (options === void 0) {
		      options = {};
		    }

		    var _options = options,
		        index = _options.index;

		    if (typeof index !== 'number') {
		      index = sheets.index === 0 ? 0 : sheets.index + 1;
		    }

		    var sheet = new StyleSheet(styles, _extends({}, options, {
		      jss: this,
		      generateId: options.generateId || this.generateId,
		      insertionPoint: this.options.insertionPoint,
		      Renderer: this.options.Renderer,
		      index: index
		    }));
		    this.plugins.onProcessSheet(sheet);
		    return sheet;
		  }
		  /**
		   * Detach the Style Sheet and remove it from the registry.
		   */
		  ;

		  _proto.removeStyleSheet = function removeStyleSheet(sheet) {
		    sheet.detach();
		    sheets.remove(sheet);
		    return this;
		  }
		  /**
		   * Create a rule without a Style Sheet.
		   * [Deprecated] will be removed in the next major version.
		   */
		  ;

		  _proto.createRule = function createRule$1(name, style, options) {
		    if (style === void 0) {
		      style = {};
		    }

		    if (options === void 0) {
		      options = {};
		    }

		    // Enable rule without name for inline styles.
		    if (typeof name === 'object') {
		      return this.createRule(undefined, name, style);
		    }

		    var ruleOptions = _extends({}, options, {
		      name: name,
		      jss: this,
		      Renderer: this.options.Renderer
		    });

		    if (!ruleOptions.generateId) ruleOptions.generateId = this.generateId;
		    if (!ruleOptions.classes) ruleOptions.classes = {};
		    if (!ruleOptions.keyframes) ruleOptions.keyframes = {};

		    var rule = createRule(name, style, ruleOptions);

		    if (rule) this.plugins.onProcessRule(rule);
		    return rule;
		  }
		  /**
		   * Register plugin. Passed function will be invoked with a rule instance.
		   */
		  ;

		  _proto.use = function use() {
		    var _this = this;

		    for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
		      plugins[_key] = arguments[_key];
		    }

		    plugins.forEach(function (plugin) {
		      _this.plugins.use(plugin);
		    });
		    return this;
		  };

		  return Jss;
		}();

		var createJss = function createJss(options) {
		  return new Jss(options);
		};

		/**
		 * SheetsManager is like a WeakMap which is designed to count StyleSheet
		 * instances and attach/detach automatically.
		 * Used in react-jss.
		 */

		var SheetsManager =
		/*#__PURE__*/
		function () {
		  function SheetsManager() {
		    this.length = 0;
		    this.sheets = new WeakMap();
		  }

		  var _proto = SheetsManager.prototype;

		  _proto.get = function get(key) {
		    var entry = this.sheets.get(key);
		    return entry && entry.sheet;
		  };

		  _proto.add = function add(key, sheet) {
		    if (this.sheets.has(key)) return;
		    this.length++;
		    this.sheets.set(key, {
		      sheet: sheet,
		      refs: 0
		    });
		  };

		  _proto.manage = function manage(key) {
		    var entry = this.sheets.get(key);

		    if (entry) {
		      if (entry.refs === 0) {
		        entry.sheet.attach();
		      }

		      entry.refs++;
		      return entry.sheet;
		    }
		    return undefined;
		  };

		  _proto.unmanage = function unmanage(key) {
		    var entry = this.sheets.get(key);

		    if (entry) {
		      if (entry.refs > 0) {
		        entry.refs--;
		        if (entry.refs === 0) entry.sheet.detach();
		      }
		    }
		  };

		  _createClass(SheetsManager, [{
		    key: "size",
		    get: function get() {
		      return this.length;
		    }
		  }]);

		  return SheetsManager;
		}();

		/**
		* Export a constant indicating if this browser has CSSTOM support.
		* https://developers.google.com/web/updates/2018/03/cssom
		*/
		var hasCSSTOMSupport = typeof CSS === 'object' && CSS != null && 'number' in CSS;

		/**
		 * Extracts a styles object with only props that contain function values.
		 */
		function getDynamicStyles(styles) {
		  var to = null;

		  for (var key in styles) {
		    var value = styles[key];
		    var type = typeof value;

		    if (type === 'function') {
		      if (!to) to = {};
		      to[key] = value;
		    } else if (type === 'object' && value !== null && !Array.isArray(value)) {
		      var extracted = getDynamicStyles(value);

		      if (extracted) {
		        if (!to) to = {};
		        to[key] = extracted;
		      }
		    }
		  }

		  return to;
		}

		/**
		 * A better abstraction over CSS.
		 *
		 * @copyright Oleg Isonen (Slobodskoi) / Isonen 2014-present
		 * @website https://github.com/cssinjs/jss
		 * @license MIT
		 */
		var index = createJss();

		const jss_esm = /*#__PURE__*/Object.freeze({
		  __proto__: null,
		  'default': index,
		  RuleList: RuleList,
		  SheetsManager: SheetsManager,
		  SheetsRegistry: SheetsRegistry,
		  create: createJss,
		  createGenerateId: createGenerateId,
		  createRule: createRule,
		  getDynamicStyles: getDynamicStyles,
		  hasCSSTOMSupport: hasCSSTOMSupport,
		  sheets: sheets,
		  toCssValue: toCssValue
		});

		var at = '@global';
		var atPrefix = '@global ';

		var GlobalContainerRule =
		/*#__PURE__*/
		function () {
		  function GlobalContainerRule(key, styles, options) {
		    this.type = 'global';
		    this.at = at;
		    this.isProcessed = false;
		    this.key = key;
		    this.options = options;
		    this.rules = new RuleList(_extends({}, options, {
		      parent: this
		    }));

		    for (var selector in styles) {
		      this.rules.add(selector, styles[selector]);
		    }

		    this.rules.process();
		  }
		  /**
		   * Get a rule.
		   */


		  var _proto = GlobalContainerRule.prototype;

		  _proto.getRule = function getRule(name) {
		    return this.rules.get(name);
		  }
		  /**
		   * Create and register rule, run plugins.
		   */
		  ;

		  _proto.addRule = function addRule(name, style, options) {
		    var rule = this.rules.add(name, style, options);
		    if (rule) this.options.jss.plugins.onProcessRule(rule);
		    return rule;
		  }
		  /**
		   * Replace rule, run plugins.
		   */
		  ;

		  _proto.replaceRule = function replaceRule(name, style, options) {
		    var newRule = this.rules.replace(name, style, options);
		    if (newRule) this.options.jss.plugins.onProcessRule(newRule);
		    return newRule;
		  }
		  /**
		   * Get index of a rule.
		   */
		  ;

		  _proto.indexOf = function indexOf(rule) {
		    return this.rules.indexOf(rule);
		  }
		  /**
		   * Generates a CSS string.
		   */
		  ;

		  _proto.toString = function toString(options) {
		    return this.rules.toString(options);
		  };

		  return GlobalContainerRule;
		}();

		var GlobalPrefixedRule =
		/*#__PURE__*/
		function () {
		  function GlobalPrefixedRule(key, style, options) {
		    this.type = 'global';
		    this.at = at;
		    this.isProcessed = false;
		    this.key = key;
		    this.options = options;
		    var selector = key.substr(atPrefix.length);
		    this.rule = options.jss.createRule(selector, style, _extends({}, options, {
		      parent: this
		    }));
		  }

		  var _proto2 = GlobalPrefixedRule.prototype;

		  _proto2.toString = function toString(options) {
		    return this.rule ? this.rule.toString(options) : '';
		  };

		  return GlobalPrefixedRule;
		}();

		var separatorRegExp$1 = /\s*,\s*/g;

		function addScope(selector, scope) {
		  var parts = selector.split(separatorRegExp$1);
		  var scoped = '';

		  for (var i = 0; i < parts.length; i++) {
		    scoped += scope + " " + parts[i].trim();
		    if (parts[i + 1]) scoped += ', ';
		  }

		  return scoped;
		}

		function handleNestedGlobalContainerRule(rule, sheet) {
		  var options = rule.options,
		      style = rule.style;
		  var rules = style ? style[at] : null;
		  if (!rules) return;

		  for (var name in rules) {
		    sheet.addRule(name, rules[name], _extends({}, options, {
		      selector: addScope(name, rule.selector)
		    }));
		  }

		  delete style[at];
		}

		function handlePrefixedGlobalRule(rule, sheet) {
		  var options = rule.options,
		      style = rule.style;

		  for (var prop in style) {
		    if (prop[0] !== '@' || prop.substr(0, at.length) !== at) continue;
		    var selector = addScope(prop.substr(at.length), rule.selector);
		    sheet.addRule(selector, style[prop], _extends({}, options, {
		      selector: selector
		    }));
		    delete style[prop];
		  }
		}
		/**
		 * Convert nested rules to separate, remove them from original styles.
		 */


		function jssGlobal() {
		  function onCreateRule(name, styles, options) {
		    if (!name) return null;

		    if (name === at) {
		      return new GlobalContainerRule(name, styles, options);
		    }

		    if (name[0] === '@' && name.substr(0, atPrefix.length) === atPrefix) {
		      return new GlobalPrefixedRule(name, styles, options);
		    }

		    var parent = options.parent;

		    if (parent) {
		      if (parent.type === 'global' || parent.options.parent && parent.options.parent.type === 'global') {
		        options.scoped = false;
		      }
		    }

		    if (!options.selector && options.scoped === false) {
		      options.selector = name;
		    }

		    return null;
		  }

		  function onProcessRule(rule, sheet) {
		    if (rule.type !== 'style' || !sheet) return;
		    handleNestedGlobalContainerRule(rule, sheet);
		    handlePrefixedGlobalRule(rule, sheet);
		  }

		  return {
		    onCreateRule: onCreateRule,
		    onProcessRule: onProcessRule
		  };
		}

		var separatorRegExp = /\s*,\s*/g;
		var parentRegExp = /&/g;
		var refRegExp = /\$([\w-]+)/g;
		/**
		 * Convert nested rules to separate, remove them from original styles.
		 */

		function jssNested() {
		  // Get a function to be used for $ref replacement.
		  function getReplaceRef(container, sheet) {
		    return function (match, key) {
		      var rule = container.getRule(key) || sheet && sheet.getRule(key);

		      if (rule) {
		        return rule.selector;
		      }
		      return key;
		    };
		  }

		  function replaceParentRefs(nestedProp, parentProp) {
		    var parentSelectors = parentProp.split(separatorRegExp);
		    var nestedSelectors = nestedProp.split(separatorRegExp);
		    var result = '';

		    for (var i = 0; i < parentSelectors.length; i++) {
		      var parent = parentSelectors[i];

		      for (var j = 0; j < nestedSelectors.length; j++) {
		        var nested = nestedSelectors[j];
		        if (result) result += ', '; // Replace all & by the parent or prefix & with the parent.

		        result += nested.indexOf('&') !== -1 ? nested.replace(parentRegExp, parent) : parent + " " + nested;
		      }
		    }

		    return result;
		  }

		  function getOptions(rule, container, prevOptions) {
		    // Options has been already created, now we only increase index.
		    if (prevOptions) return _extends({}, prevOptions, {
		      index: prevOptions.index + 1
		    });
		    var nestingLevel = rule.options.nestingLevel;
		    nestingLevel = nestingLevel === undefined ? 1 : nestingLevel + 1;

		    var options = _extends({}, rule.options, {
		      nestingLevel: nestingLevel,
		      index: container.indexOf(rule) + 1 // We don't need the parent name to be set options for chlid.

		    });

		    delete options.name;
		    return options;
		  }

		  function onProcessStyle(style, rule, sheet) {
		    if (rule.type !== 'style') return style;
		    var styleRule = rule;
		    var container = styleRule.options.parent;
		    var options;
		    var replaceRef;

		    for (var prop in style) {
		      var isNested = prop.indexOf('&') !== -1;
		      var isNestedConditional = prop[0] === '@';
		      if (!isNested && !isNestedConditional) continue;
		      options = getOptions(styleRule, container, options);

		      if (isNested) {
		        var selector = replaceParentRefs(prop, styleRule.selector); // Lazily create the ref replacer function just once for
		        // all nested rules within the sheet.

		        if (!replaceRef) replaceRef = getReplaceRef(container, sheet); // Replace all $refs.

		        selector = selector.replace(refRegExp, replaceRef);
		        var name = styleRule.key + "-" + prop;

		        if ('replaceRule' in container) {
		          // for backward compatibility
		          container.replaceRule(name, style[prop], _extends({}, options, {
		            selector: selector
		          }));
		        } else {
		          container.addRule(name, style[prop], _extends({}, options, {
		            selector: selector
		          }));
		        }
		      } else if (isNestedConditional) {
		        // Place conditional right after the parent rule to ensure right ordering.
		        container.addRule(prop, {}, options).addRule(styleRule.key, style[prop], {
		          selector: styleRule.selector
		        });
		      }

		      delete style[prop];
		    }

		    return style;
		  }

		  return {
		    onProcessStyle: onProcessStyle
		  };
		}

		/* eslint-disable no-var, prefer-template */
		var uppercasePattern = /[A-Z]/g;
		var msPattern = /^ms-/;
		var cache = {};

		function toHyphenLower(match) {
		  return '-' + match.toLowerCase()
		}

		function hyphenateStyleName(name) {
		  if (cache.hasOwnProperty(name)) {
		    return cache[name]
		  }

		  var hName = name.replace(uppercasePattern, toHyphenLower);
		  return (cache[name] = msPattern.test(hName) ? '-' + hName : hName)
		}

		/**
		 * Convert camel cased property names to dash separated.
		 */

		function convertCase(style) {
		  var converted = {};

		  for (var prop in style) {
		    var key = prop.indexOf('--') === 0 ? prop : hyphenateStyleName(prop);
		    converted[key] = style[prop];
		  }

		  if (style.fallbacks) {
		    if (Array.isArray(style.fallbacks)) converted.fallbacks = style.fallbacks.map(convertCase);else converted.fallbacks = convertCase(style.fallbacks);
		  }

		  return converted;
		}
		/**
		 * Allow camel cased property names by converting them back to dasherized.
		 */


		function camelCase() {
		  function onProcessStyle(style) {
		    if (Array.isArray(style)) {
		      // Handle rules like @font-face, which can have multiple styles in an array
		      for (var index = 0; index < style.length; index++) {
		        style[index] = convertCase(style[index]);
		      }

		      return style;
		    }

		    return convertCase(style);
		  }

		  function onChangeValue(value, prop, rule) {
		    if (prop.indexOf('--') === 0) {
		      return value;
		    }

		    var hyphenatedProp = hyphenateStyleName(prop); // There was no camel case in place

		    if (prop === hyphenatedProp) return value;
		    rule.prop(hyphenatedProp, value); // Core will ignore that property value we set the proper one above.

		    return null;
		  }

		  return {
		    onProcessStyle: onProcessStyle,
		    onChangeValue: onChangeValue
		  };
		}

		function getAugmentedNamespace(n) {
			if (n.__esModule) return n;
			var a = Object.defineProperty({}, '__esModule', {value: true});
			Object.keys(n).forEach(function (k) {
				var d = Object.getOwnPropertyDescriptor(n, k);
				Object.defineProperty(a, k, d.get ? d : {
					enumerable: true,
					get: function () {
						return n[k];
					}
				});
			});
			return a;
		}

		var _tslib$1 = {};

		(function (exports) {

		Object.defineProperty(exports, '__esModule', { value: true });

		/*! *****************************************************************************
		Copyright (c) Microsoft Corporation.

		Permission to use, copy, modify, and/or distribute this software for any
		purpose with or without fee is hereby granted.

		THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
		REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
		AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
		INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
		LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
		OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
		PERFORMANCE OF THIS SOFTWARE.
		***************************************************************************** */

		exports.__assign = function () {
			exports.__assign =
				Object.assign ||
				function __assign(t) {
					for (var s, i = 1, n = arguments.length; i < n; i++) {
						s = arguments[i];
						for (var p in s)
							if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
					}
					return t;
				};
			return exports.__assign.apply(this, arguments);
		};
		}(_tslib$1));

		const require$$1 = /*@__PURE__*/getAugmentedNamespace(jss_esm);

		/**
		 * The custom `sort` method for
		 * for the [`css-mqpacker`](https://www.npmjs.com/package/css-mqpacker) or
		 * [`pleeease`](https://www.npmjs.com/package/pleeease) which using `css-mqpacker`
		 * or, perhaps, something else ))
		 *
		 * @module sort-css-media-queries
		 * @author Oleg Dutchenko <dutchenko.o.wezom@gmail.com>
		 * @version 1.5.0
		 */

		// ----------------------------------------
		// Private
		// ----------------------------------------

		const minMaxWidth = /(!?\(\s*min(-device-)?-width)(.|\n)+\(\s*max(-device)?-width/i;
		const minWidth = /\(\s*min(-device)?-width/i;
		const maxMinWidth = /(!?\(\s*max(-device)?-width)(.|\n)+\(\s*min(-device)?-width/i;
		const maxWidth = /\(\s*max(-device)?-width/i;

		const isMinWidth = _testQuery(minMaxWidth, maxMinWidth, minWidth);
		const isMaxWidth = _testQuery(maxMinWidth, minMaxWidth, maxWidth);

		const minMaxHeight = /(!?\(\s*min(-device)?-height)(.|\n)+\(\s*max(-device)?-height/i;
		const minHeight = /\(\s*min(-device)?-height/i;
		const maxMinHeight = /(!?\(\s*max(-device)?-height)(.|\n)+\(\s*min(-device)?-height/i;
		const maxHeight = /\(\s*max(-device)?-height/i;

		const isMinHeight = _testQuery(minMaxHeight, maxMinHeight, minHeight);
		const isMaxHeight = _testQuery(maxMinHeight, minMaxHeight, maxHeight);

		const isPrint = /print/i;
		const isPrintOnly = /^print$/i;

		const maxValue = Number.MAX_VALUE;

		/**
		 * Obtain the length of the media request in pixels.
		 * Copy from original source `function inspectLength (length)`
		 * {@link https://github.com/hail2u/node-css-mqpacker/blob/master/index.js#L58}
		 * @private
		 * @param {string} length
		 * @return {number}
		 */
		function _getQueryLength (length) {
		  length = /(-?\d*\.?\d+)(ch|em|ex|px|rem)/.exec(length);

		  if (length === null) {
		    return maxValue
		  }

		  let number = length[1];
		  const unit = length[2];

		  switch (unit) {
		    case 'ch':
		      number = parseFloat(number) * 8.8984375;
		      break

		    case 'em':
		    case 'rem':
		      number = parseFloat(number) * 16;
		      break

		    case 'ex':
		      number = parseFloat(number) * 8.296875;
		      break

		    case 'px':
		      number = parseFloat(number);
		      break
		  }

		  return +number
		}

		/**
		 * Wrapper for creating test functions
		 * @private
		 * @param {RegExp} doubleTestTrue
		 * @param {RegExp} doubleTestFalse
		 * @param {RegExp} singleTest
		 * @return {Function}
		 */
		function _testQuery (doubleTestTrue, doubleTestFalse, singleTest) {
		  /**
		   * @param {string} query
		   * @return {boolean}
		   */
		  return function (query) {
		    if (doubleTestTrue.test(query)) {
		      return true
		    } else if (doubleTestFalse.test(query)) {
		      return false
		    }
		    return singleTest.test(query)
		  }
		}

		/**
		 * @private
		 * @param {string} a
		 * @param {string} b
		 * @return {number|null}
		 */
		function _testIsPrint (a, b) {
		  const isPrintA = isPrint.test(a);
		  const isPrintOnlyA = isPrintOnly.test(a);

		  const isPrintB = isPrint.test(b);
		  const isPrintOnlyB = isPrintOnly.test(b);

		  if (isPrintA && isPrintB) {
		    if (!isPrintOnlyA && isPrintOnlyB) {
		      return 1
		    }
		    if (isPrintOnlyA && !isPrintOnlyB) {
		      return -1
		    }
		    return a.localeCompare(b)
		  }
		  if (isPrintA) {
		    return 1
		  }
		  if (isPrintB) {
		    return -1
		  }

		  return null
		}

		// ----------------------------------------
		// Public
		// ----------------------------------------

		/**
		 * Sorting an array with media queries
		 * according to the mobile-first methodology.
		 * @param {string} a
		 * @param {string} b
		 * @return {number} 1 / 0 / -1
		 */
		function sortCSSmq$1 (a, b) {
		  const testIsPrint = _testIsPrint(a, b);
		  if (testIsPrint !== null) {
		    return testIsPrint
		  }

		  const minA = isMinWidth(a) || isMinHeight(a);
		  const maxA = isMaxWidth(a) || isMaxHeight(a);

		  const minB = isMinWidth(b) || isMinHeight(b);
		  const maxB = isMaxWidth(b) || isMaxHeight(b);

		  if (minA && maxB) {
		    return -1
		  }
		  if (maxA && minB) {
		    return 1
		  }

		  let lengthA = _getQueryLength(a);
		  let lengthB = _getQueryLength(b);

		  if (lengthA === maxValue && lengthB === maxValue) {
		    return a.localeCompare(b)
		  } else if (lengthA === maxValue) {
		    return 1
		  } else if (lengthB === maxValue) {
		    return -1
		  }

		  if (lengthA > lengthB) {
		    if (maxA) {
		      return -1
		    }
		    return 1
		  }

		  if (lengthA < lengthB) {
		    if (maxA) {
		      return 1
		    }
		    return -1
		  }

		  return a.localeCompare(b)
		}

		/**
		 * Sorting an array with media queries
		 * according to the desktop-first methodology.
		 * @param {string} a
		 * @param {string} b
		 * @return {number} 1 / 0 / -1
		 */
		sortCSSmq$1.desktopFirst = function (a, b) {
		  const testIsPrint = _testIsPrint(a, b);
		  if (testIsPrint !== null) {
		    return testIsPrint
		  }

		  const minA = isMinWidth(a) || isMinHeight(a);
		  const maxA = isMaxWidth(a) || isMaxHeight(a);

		  const minB = isMinWidth(b) || isMinHeight(b);
		  const maxB = isMaxWidth(b) || isMaxHeight(b);

		  if (minA && maxB) {
		    return 1
		  }
		  if (maxA && minB) {
		    return -1
		  }

		  const lengthA = _getQueryLength(a);
		  const lengthB = _getQueryLength(b);

		  if (lengthA === maxValue && lengthB === maxValue) {
		    return a.localeCompare(b)
		  } else if (lengthA === maxValue) {
		    return 1
		  } else if (lengthB === maxValue) {
		    return -1
		  }

		  if (lengthA > lengthB) {
		    if (maxA) {
		      return -1
		    }
		    return 1
		  }

		  if (lengthA < lengthB) {
		    if (maxA) {
		      return 1
		    }
		    return -1
		  }

		  return -(a.localeCompare(b))
		};

		// ----------------------------------------
		// Exports
		// ----------------------------------------

		var sortCssMediaQueries = sortCSSmq$1;

		var _tslib = _tslib$1;
		var jss$1 = require$$1;
		var sortCSSmq = sortCssMediaQueries;

		function _interopDefaultLegacy$1(e) {
			return e && typeof e === 'object' && 'default' in e ? e : { default: e };
		}

		var sortCSSmq__default = /*#__PURE__*/ _interopDefaultLegacy$1(sortCSSmq);

		function isPlainObject(sample) {
			return (
				sample !== null && typeof sample === 'object' && Array.isArray(sample) === false
			);
		}
		var UN_QUERIED = '__UN_QUERIED';
		function recursiveInnerAndGetQueries(pluginOptions, rules) {
			var queries = {
				groups: {},
				groupsSortNames: []
			};
			for (var index = 0; index < rules.length; index++) {
				var rule = rules[index];
				var query =
					rule.type === 'conditional' && typeof rule.query === 'string'
						? rule.query
						: UN_QUERIED;
				if (!queries.groups.hasOwnProperty(query)) {
					queries.groupsSortNames.push(query);
					queries.groups[query] = [];
				}
				queries.groups[query].push(index);
				// eslint-disable-next-line @typescript-eslint/no-use-before-define
				recursive(pluginOptions, rule);
			}
			queries.groupsSortNames.sort(function (a, b) {
				var aWeight = a === UN_QUERIED ? 0 : a.length;
				var bWeight = b === UN_QUERIED ? 0 : b.length;
				if (aWeight > 0 && bWeight > 0) {
					if (pluginOptions.desktopFirst) {
						return sortCSSmq__default['default'].desktopFirst(a, b);
					} else {
						return sortCSSmq__default['default'](a, b);
					}
				} else {
					return aWeight - bWeight;
				}
			});
			return queries;
		}
		function recursive(pluginOptions, data) {
			if (isPlainObject(data) && data.rules instanceof jss$1.RuleList) {
				data.rules.toString = function (options) {
					if (options === void 0) {
						options = {};
					}
					var str = '';
					var sheet = this.options.sheet;
					var link = sheet ? sheet.options.link : false;
					var _a = recursiveInnerAndGetQueries(pluginOptions, this.index),
						groups = _a.groups,
						groupsSortNames = _a.groupsSortNames;
					for (var i = 0; i < groupsSortNames.length; i++) {
						var groupName = groupsSortNames[i];
						var group = groups[groupsSortNames[i]];
						if (groupName !== UN_QUERIED && pluginOptions.combineMediaQueries) {
							str += '\n' + groupName + ' {';
							for (var i_1 = 0; i_1 < group.length; i_1++) {
								var rule = this.index[group[i_1]];
								var css = rule.rules.toString(
									_tslib.__assign(_tslib.__assign({}, options), {
										indent: (options.indent || 0) + 1
									})
								);
								if (!css && !link) continue;
								if (str) str += '\n';
								str += css;
							}
							str += '\n}\n';
						} else {
							for (var i_2 = 0; i_2 < group.length; i_2++) {
								var rule = this.index[group[i_2]];
								var css = rule.toString(options);
								if (!css && !link) continue;
								if (str) str += '\n';
								str += css;
							}
						}
					}
					return str;
				};
			}
		}
		function jssCombineAndSortMQ(options) {
			if (options === void 0) {
				options = {};
			}
			return {
				onProcessSheet: function (sheet) {
					recursive(options, sheet);
				}
			};
		}

		var dist = jssCombineAndSortMQ;

		const paramCaseToCamelCase = (str) => {
		    return str.replace(/-(\w)/g, (_, group) => group.toUpperCase());
		};

		// NOTE: these utils are in the same file on purpose
		// to force them being bundled into our core chunk
		const getTagName = (el) => el.tagName.toLowerCase();
		const getTagNameWithoutPrefix = (host) => {
		    const tagName = getTagName(host);
		    const [, tagNameWithoutPrefix = ''] = /^(?:[a-z-]+-)?(p-[a-z-]+)$/.exec(tagName) || [];
		    return (tagNameWithoutPrefix || tagName); // return tagName as fallback for default tags
		};
		const tagNamesWithoutTextAndHeadline = TAG_NAMES.filter((item) => item !== 'p-text' && item !== 'p-heading' && item !== 'p-headline' && item !== 'p-display');
		const PREFIXED_TAG_NAMES_CACHE = new Map();
		// TODO: typing support for components is missing
		const getPrefixedTagNames = (host) => {
		    const [, prefix = ''] = /^([a-z-]+)-p-[a-z-]+$/.exec(getTagName(host)) || [];
		    if (!PREFIXED_TAG_NAMES_CACHE.has(prefix)) {
		        const tagNames = tagNamesWithoutTextAndHeadline.reduce(prefix
		            ? (result, tag) => ({
		                ...result,
		                [paramCaseToCamelCase(tag)]: `${prefix}-${tag}`,
		            })
		            : (result, tag) => ({
		                ...result,
		                [paramCaseToCamelCase(tag)]: tag,
		            }), {});
		        PREFIXED_TAG_NAMES_CACHE.set(prefix, tagNames);
		    }
		    return PREFIXED_TAG_NAMES_CACHE.get(prefix);
		};

		const prefix = `[Porsche Design System v${"3.15.0-rc.5"}]` // this part isn't covered by unit tests
		    ;
		const consoleWarn = (...messages) => {
		    console.warn(prefix, ...messages); // eslint-disable-line no-console
		};
		const consoleError = (...messages) => {
		    console.error(prefix, ...messages); // eslint-disable-line no-console
		};
		const throwException = (message) => {
		    throw new Error(`${prefix} ${message}`); // eslint-disable-line fp/no-throw
		};

		function getHTMLElement(element, selector) {
		    return element?.querySelector(selector);
		}

		function getShadowRootHTMLElement(element, selector) {
		    return getHTMLElement(element.shadowRoot, selector);
		}

		const removeAttribute = (el, attributeName) => {
		    el.removeAttribute(attributeName);
		};

		const setAttribute = (el, attributeName, attributeValue = '') => {
		    el.setAttribute(attributeName, attributeValue);
		};

		const parseJSONAttribute = (attribute) => {
		    return typeof attribute === 'string'
		        ? // input is potentially JSON parsable string, e.g. "{ 'aria-label': 'Some label' }"
		            JSON.parse(attribute
		                .replace(/(?<!\\)'/g, '"') // convert single quotes to double quotes except the ones which are escaped by backslash
		                .replace(/\\(?!u0027)/g, '') // remove string escapes except the ones followed by unicode u0027
		                .replace(/[\s"]?([\w-]+)[\s"]?:/g, '"$1":') // wrap keys in double quotes
		            )
		        : // input is object, e.g. { 'aria-label': 'Some label' }
		            attribute;
		};

		const hasWindow = typeof window !== 'undefined';

		const setAriaAttributes = (el, opts) => {
		    const { label, message, state } = opts;
		    if (label) {
		        setAttribute(el, 'aria-label', `${label}${message ? `. ${message}` : ''}`);
		    }
		    if (state === 'error') {
		        setAttribute(el, 'aria-invalid', 'true');
		    }
		    else {
		        removeAttribute(el, 'aria-invalid');
		    }
		};
		const parseAndGetAriaAttributes = (rawAttributes) => {
		    if (rawAttributes) {
		        return Object.fromEntries(Object.entries(parseJSONAttribute(rawAttributes)).map(([key, val]) => [
		            key,
		            // convert booleans to strings so that values are properly set and not just result in attributes without a value when true in jsx
		            typeof val === 'boolean' ? `${val}` : val,
		        ]));
		    }
		};
		const isHighContrastMode = hasWindow && window.matchMedia?.('(forced-colors: active)').matches;

		const attributeMutationMap = new Map();
		const attributeObserver = hasWindow &&
		    new MutationObserver((mutations) => {
		        mutations
		            // reduce array to only entries that have really a changed value
		            .filter((mutation) => mutation.oldValue !== mutation.target.getAttribute(mutation.attributeName))
		            // remove duplicates so we execute callback only once per node
		            .filter((mutation, idx, arr) => arr.findIndex((m) => m.target === mutation.target) === idx)
		            .forEach((mutation) => attributeMutationMap.get(mutation.target)?.());
		    });
		const observeAttributes = (node, attributes, callback) => {
		    // node might not be defined in connectedCallback
		    if (node) {
		        attributeMutationMap.set(node, callback);
		        attributeObserver.observe(node, { attributeFilter: attributes, attributeOldValue: true });
		    }
		};
		const unobserveAttributes = (node) => {
		    attributeMutationMap.delete(node);
		};

		const parseJSON = (prop) => {
		    if (typeof prop === 'string') {
		        try {
		            // prop is potentially JSON parsable string, e.g. "{ base: 'block', l: 'inline' }" or "true" or "false"
		            return JSON.parse(prop
		                .replace(/'/g, '"') // convert single quotes to double quotes
		                .replace(/[\s"]?([a-z]+)[\s"]?:([^//])/g, '"$1":$2') // wrap keys in double quotes if they don't have them but ignore potential urls
		            );
		        }
		        catch {
		            // prop is string, e.g. "block" or "inline"
		            return prop;
		        }
		    }
		    else {
		        // prop is object, e.g. { base: 'block', l: 'inline' } or number, e.g. 123 or boolean, e.g. true
		        return prop;
		    }
		};

		const borderWidthBase = '2px';

		const backdropFilter = 'blur(32px)';
		const frostedGlassStyle = {
		    WebkitBackdropFilter: backdropFilter,
		    backdropFilter,
		};

		const breakpointBase = 0;

		const breakpointXS = 480;

		const breakpointS = 760;

		const breakpointM = 1000;

		const breakpointL = 1300;

		const breakpointXL = 1760;

		const breakpointXXL = 1920;

		const breakpoint = {
		    base: breakpointBase,
		    xs: breakpointXS,
		    s: breakpointS,
		    m: breakpointM,
		    l: breakpointL,
		    xl: breakpointXL,
		    xxl: breakpointXXL,
		};

		function getMediaQueryMin(min) {
		    return `@media(min-width:${breakpoint[min]}px)`;
		}

		const motionDurationShort = '0.25s';

		const motionEasingBase = 'cubic-bezier(0.25,0.1,0.25,1)';

		const breakpoints = ['base', 'xs', 's', 'm', 'l', 'xl', 'xxl'];

		const motionDurationLong = '0.6s';

		const motionDurationModerate = '0.4s';

		const motionDurationVeryLong = '1.2s';

		const motionEasingIn = 'cubic-bezier(0,0,0.2,1)';

		const motionEasingOut = 'cubic-bezier(0.4,0,0.5,1)';

		const themeLightBackgroundShading = 'rgba(1, 2, 5, 0.67)';

		const themeDarkBackgroundShading = 'rgba(38, 38, 41, 0.67)';

		const mediaQueries = Object.values(breakpoint).map((v) => `(min-width:${v}px)`);
		let mediaQueryLists = hasWindow && window.matchMedia ? mediaQueries.map(window.matchMedia) : [];
		const breakpointChangeCallbackMap = new Map();
		const observeBreakpointChange = (node, callback) => {
		    // node might not be defined in connectedCallback
		    if (node) {
		        if (breakpointChangeCallbackMap.size === 0) {
		            mediaQueryLists.forEach((mediaQueryList) => {
		                // matchmedia-polyfill only implements addListener in jsdom-polyfill
		                mediaQueryList.addEventListener?.('change', handleBreakpointChange);
		            });
		        }
		        breakpointChangeCallbackMap.set(node, callback);
		    }
		};
		const unobserveBreakpointChange = (node) => {
		    breakpointChangeCallbackMap.delete(node);
		    if (breakpointChangeCallbackMap.size === 0) {
		        mediaQueryLists.forEach((mediaQueryList) => {
		            // matchmedia-polyfill only implements removeListener in jsdom-polyfill
		            mediaQueryList.removeEventListener?.('change', handleBreakpointChange);
		        });
		    }
		};
		const handleBreakpointChange = () => {
		    breakpointChangeCallbackMap.forEach((breakpointChangeCallback) => {
		        breakpointChangeCallback();
		    });
		};

		const flippedBreakpoint = Object.entries(breakpoint).reduce((result, [key, val]) => ({ ...result, [`${val}px`]: key }), {});
		const getCurrentBreakpointKey = () => {
		    const lastMatchingMediaQuery = mediaQueryLists
		        .filter((item) => item.matches)
		        .map((item) => item.media)
		        .pop();
		    return flippedBreakpoint[/\d+px/.exec(lastMatchingMediaQuery)[0]];
		};
		const getCurrentMatchingBreakpointValue = (data) => {
		    if (typeof data === 'object') {
		        const currentBreakpoint = getCurrentBreakpointKey();
		        const result = data[currentBreakpoint];
		        if (result) {
		            return result;
		        }
		        else {
		            const valuesArray = breakpoints.map((bp) => data[bp]);
		            // fill gaps with value from preceding breakpoint
		            valuesArray.forEach((val, i, arr) => {
		                if (val === undefined) {
		                    arr[i] = arr[i - 1];
		                }
		            });
		            return valuesArray[breakpoints.indexOf(currentBreakpoint)];
		        }
		    }
		    else {
		        return data;
		    }
		};

		/**
		 * Map of observed nodes and their corresponding callback functions.
		 */
		const observedNodesMap = new Map();
		/**
		 * Mutation observer for observing changes in the children of observed nodes.
		 */
		const childrenObserver = hasWindow &&
		    new MutationObserver((mutations) => {
		        // there may be race conditions in jsdom-polyfill tests  where the map is already empty when a mutation happens
		        if (observedNodesMap.size) {
		            const observedNodes = Array.from(observedNodesMap.keys());
		            mutations
		                // remove duplicates so we execute callback only once per node
		                .filter((mutation, idx, arr) => arr.findIndex((m) => m.target === mutation.target) === idx)
		                // find all observing parent nodes of mutated node and invoke their callbacks
		                .forEach((mutation) => {
		                observedNodes
		                    .filter((node) => node.contains(mutation.target))
		                    .forEach((node) => observedNodesMap.get(node)?.());
		            });
		        }
		    });
		/**
		 * Observes the children of a given node and invokes a callback when changes occur.
		 * @template T - The type of the node.
		 * @template K - The type of the node's attributes.
		 * @param {T} node - The node to observe.
		 * @param {() => void} callback - The callback function to invoke when changes occur.
		 * @param {(Lowercase<K extends string ? K : string> | keyof AriaAttributes)[]} [attributes] - Optional attribute names to be monitored.
		 * @returns {void}
		 */
		const observeChildren = (node, callback, attributes) => {
		    // node might not be defined in connectedCallback
		    if (node) {
		        observedNodesMap.set(node, callback);
		        childrenObserver.observe(node, {
		            childList: true,
		            subtree: true,
		            characterData: true,
		            attributeFilter: attributes,
		        });
		    }
		};
		/**
		 * Stops observing the children of a given node.
		 * @template T - The type of the node.
		 * @param {T} node - The node to unobserve.
		 * @returns {void}
		 */
		const unobserveChildren = (node) => {
		    observedNodesMap.delete(node);
		};

		/* eslint-disable no-undefined,no-param-reassign,no-shadow */

		/**
		 * Throttle execution of a function. Especially useful for rate limiting
		 * execution of handlers on events like resize and scroll.
		 *
		 * @param {number} delay -                  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher)
		 *                                            are most useful.
		 * @param {Function} callback -               A function to be executed after delay milliseconds. The `this` context and all arguments are passed through,
		 *                                            as-is, to `callback` when the throttled-function is executed.
		 * @param {object} [options] -              An object to configure options.
		 * @param {boolean} [options.noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds
		 *                                            while the throttled-function is being called. If noTrailing is false or unspecified, callback will be executed
		 *                                            one final time after the last throttled-function call. (After the throttled-function has not been called for
		 *                                            `delay` milliseconds, the internal counter is reset).
		 * @param {boolean} [options.noLeading] -   Optional, defaults to false. If noLeading is false, the first throttled-function call will execute callback
		 *                                            immediately. If noLeading is true, the first the callback execution will be skipped. It should be noted that
		 *                                            callback will never executed if both noLeading = true and noTrailing = true.
		 * @param {boolean} [options.debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is
		 *                                            false (at end), schedule `callback` to execute after `delay` ms.
		 *
		 * @returns {Function} A new, throttled, function.
		 */
		function throttle (delay, callback, options) {
		  var _ref = options || {},
		      _ref$noTrailing = _ref.noTrailing,
		      noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing,
		      _ref$noLeading = _ref.noLeading,
		      noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading,
		      _ref$debounceMode = _ref.debounceMode,
		      debounceMode = _ref$debounceMode === void 0 ? undefined : _ref$debounceMode;
		  /*
		   * After wrapper has stopped being called, this timeout ensures that
		   * `callback` is executed at the proper times in `throttle` and `end`
		   * debounce modes.
		   */


		  var timeoutID;
		  var cancelled = false; // Keep track of the last time `callback` was executed.

		  var lastExec = 0; // Function to clear existing timeout

		  function clearExistingTimeout() {
		    if (timeoutID) {
		      clearTimeout(timeoutID);
		    }
		  } // Function to cancel next exec


		  function cancel(options) {
		    var _ref2 = options || {},
		        _ref2$upcomingOnly = _ref2.upcomingOnly,
		        upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;

		    clearExistingTimeout();
		    cancelled = !upcomingOnly;
		  }
		  /*
		   * The `wrapper` function encapsulates all of the throttling / debouncing
		   * functionality and when executed will limit the rate at which `callback`
		   * is executed.
		   */


		  function wrapper() {
		    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
		      arguments_[_key] = arguments[_key];
		    }

		    var self = this;
		    var elapsed = Date.now() - lastExec;

		    if (cancelled) {
		      return;
		    } // Execute `callback` and update the `lastExec` timestamp.


		    function exec() {
		      lastExec = Date.now();
		      callback.apply(self, arguments_);
		    }
		    /*
		     * If `debounceMode` is true (at begin) this is used to clear the flag
		     * to allow future `callback` executions.
		     */


		    function clear() {
		      timeoutID = undefined;
		    }

		    if (!noLeading && debounceMode && !timeoutID) {
		      /*
		       * Since `wrapper` is being called for the first time and
		       * `debounceMode` is true (at begin), execute `callback`
		       * and noLeading != true.
		       */
		      exec();
		    }

		    clearExistingTimeout();

		    if (debounceMode === undefined && elapsed > delay) {
		      if (noLeading) {
		        /*
		         * In throttle mode with noLeading, if `delay` time has
		         * been exceeded, update `lastExec` and schedule `callback`
		         * to execute after `delay` ms.
		         */
		        lastExec = Date.now();

		        if (!noTrailing) {
		          timeoutID = setTimeout(debounceMode ? clear : exec, delay);
		        }
		      } else {
		        /*
		         * In throttle mode without noLeading, if `delay` time has been exceeded, execute
		         * `callback`.
		         */
		        exec();
		      }
		    } else if (noTrailing !== true) {
		      /*
		       * In trailing throttle mode, since `delay` time has not been
		       * exceeded, schedule `callback` to execute `delay` ms after most
		       * recent execution.
		       *
		       * If `debounceMode` is true (at begin), schedule `clear` to execute
		       * after `delay` ms.
		       *
		       * If `debounceMode` is false (at end), schedule `callback` to
		       * execute after `delay` ms.
		       */
		      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
		    }
		  }

		  wrapper.cancel = cancel; // Return the wrapper function.

		  return wrapper;
		}

		/* eslint-disable no-undefined */
		/**
		 * Debounce execution of a function. Debouncing, unlike throttling,
		 * guarantees that a function is only executed a single time, either at the
		 * very beginning of a series of calls, or at the very end.
		 *
		 * @param {number} delay -               A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
		 * @param {Function} callback -          A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
		 *                                        to `callback` when the debounced-function is executed.
		 * @param {object} [options] -           An object to configure options.
		 * @param {boolean} [options.atBegin] -  Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds
		 *                                        after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.
		 *                                        (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).
		 *
		 * @returns {Function} A new, debounced function.
		 */

		function debounce (delay, callback, options) {
		  var _ref = options || {},
		      _ref$atBegin = _ref.atBegin,
		      atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;

		  return throttle(delay, callback, {
		    debounceMode: atBegin !== false
		  });
		}

		const hasCounter = (el) => el.maxLength >= 0;
		// https://javascript.info/currying-partials
		const inputEventListenerCurry = (characterCountElement, counterElement, inputChangeCallback) => {
		    // returns actual listener function
		    return (e) => {
		        updateCounter(e.target, characterCountElement, counterElement, inputChangeCallback);
		    };
		};
		const updateCounter = (el, characterCountElement, counterElement, inputChangeCallback) => {
		    if (counterElement) {
		        setCounterInnerHtml(el, counterElement);
		    }
		    setAriaElementInnerHtml(el, characterCountElement);
		    inputChangeCallback?.();
		};
		const setCounterInnerHtml = (el, counterElement) => {
		    counterElement.innerText = `${el.value.length}/${el.maxLength}`;
		};
		const setAriaElementInnerHtml = debounce(800, (el, ariaElement) => {
		    ariaElement.innerText = `You have ${el.maxLength - el.value.length} out of ${el.maxLength} characters left`;
		});

		const hasPropValueChanged = (newVal, oldVal) => {
		    if (typeof newVal !== 'object' || typeof oldVal !== 'object') {
		        // primitive types
		        return newVal !== oldVal;
		    }
		    else if (Array.isArray(newVal) && Array.isArray(oldVal)) {
		        // type array
		        return !(newVal.length === oldVal.length && newVal.every((val, i) => val === oldVal[i]));
		    }
		    else {
		        // type object
		        // currently this does not take care of nested objects
		        return !(Object.keys(newVal).length === Object.keys(oldVal).length &&
		            Object.entries(newVal).every(([key1, val1]) => val1 === oldVal[key1]));
		    }
		};

		/* Auto Generated Start */
		const themeLight = {
		    primaryColor: '#010205',
		    primaryColorDarken: '#000000',
		    backgroundColor: '#FFF',
		    backgroundColorDarken: '#E0E0E0',
		    backgroundColorLighten: '#FFFFFF',
		    backgroundSurfaceColor: '#EEEFF2',
		    backgroundSurfaceColorDarken: '#CBCED7',
		    backgroundSurfaceColorLighten: '#FFFFFF',
		    contrastLowColor: '#D8D8DB',
		    contrastMediumColor: '#6B6D70',
		    contrastHighColor: '#535457',
		    contrastHighColorDarken: '#353638',
		    contrastHighColorLighten: '#717276',
		    hoverColor: 'rgba(148, 149, 152, .18)',
		    hoverColorDarken: '#75767A',
		    activeColor: 'rgba(148, 149, 152, 0.20)',
		    focusColor: '#1A44EA',
		    disabledColor: '#949598',
		    errorColor: '#CC1922',
		    errorColorDarken: '#951219',
		    errorSoftColor: '#FFE2E4',
		    errorSoftColorDarken: '#F4CED1',
		    errorSoftColorLighten: '#FFFFFF',
		    successColor: '#197E10',
		    successColorDarken: '#0E4809',
		    successSoftColor: '#E4FFEC',
		    successSoftColorDarken: '#D0F4DB',
		    successSoftColorLighten: '#FFFFFF',
		    warningColor: '#F3BE00',
		    warningSoftColor: '#FFF4D2',
		    warningSoftColorDarken: '#F1E5C1',
		    warningSoftColorLighten: '#FCFAF3',
		    infoColor: '#2762EC',
		    infoSoftColor: '#D3E1FF',
		    infoSoftColorDarken: '#C2D1F1',
		    infoSoftColorLighten: '#F4F7FD'
		};
		const themeDark = {
		    primaryColor: '#FBFCFF',
		    primaryColorDarken: '#BECEFF',
		    backgroundColor: '#0E0E12',
		    backgroundColorDarken: '#000000',
		    backgroundColorLighten: '#292934',
		    backgroundSurfaceColor: '#212225',
		    backgroundSurfaceColorDarken: '#040405',
		    backgroundSurfaceColorLighten: '#3E4045',
		    contrastLowColor: '#404044',
		    contrastMediumColor: '#88898C',
		    contrastHighColor: '#AFB0B3',
		    contrastHighColorDarken: '#909195',
		    contrastHighColorLighten: '#CECFD1',
		    hoverColor: 'rgba(148, 149, 152, .18)',
		    hoverColorDarken: '#75767A',
		    activeColor: 'rgba(126, 127, 130, 0.20)',
		    focusColor: '#1A44EA',
		    disabledColor: '#7E7F82',
		    errorColor: '#FC4040',
		    errorColorDarken: '#FB0404',
		    errorSoftColor: '#3A0F0F',
		    errorSoftColorDarken: '#1A1111',
		    errorSoftColorLighten: '#3F2828',
		    successColor: '#09D087',
		    successColorDarken: '#069561',
		    successSoftColor: '#003320',
		    successSoftColorDarken: '#04110C',
		    successSoftColorLighten: '#0F432F',
		    warningColor: '#F7CB47',
		    warningSoftColor: '#362B0A',
		    warningSoftColorDarken: '#16130B',
		    warningSoftColorLighten: '#3E3720',
		    infoColor: '#178BFF',
		    infoSoftColor: '#04294E',
		    infoSoftColorDarken: '#0C1A27',
		    infoSoftColorLighten: '#1A3856'
		};
		const themeAuto = {
		    ...themeLight,
		};
		const themes = {
		    'light': themeLight,
		    'dark': themeDark,
		    'auto': themeAuto
		};
		/* Auto Generated End */
		const schemeHighContrastMerged = {
		    disabledColor: 'GrayText',
		    focusColor: 'Highlight',
		};
		const schemeHighContrast = {
		    canvasColor: 'Canvas',
		    canvasTextColor: 'CanvasText',
		    highlightColor: 'Highlight',
		    linkColor: 'LinkText',
		};
		const getThemedColors = (theme) => {
		    return isHighContrastMode ? { ...themes[theme], ...schemeHighContrastMerged } : themes[theme];
		};
		const getHighContrastColors = () => {
		    return schemeHighContrast;
		};
		const getInvertedThemedColors = (theme) => {
		    return getThemedColors(isThemeDark(theme) ? 'light' : 'dark');
		};

		const motionDurationMap = {
		    short: motionDurationShort,
		    moderate: motionDurationModerate,
		    long: motionDurationLong,
		    veryLong: motionDurationVeryLong,
		};
		const motionEasingMap = {
		    base: motionEasingBase,
		    in: motionEasingIn,
		    out: motionEasingOut,
		    linear: 'linear',
		};
		const cssVariableTransitionDuration = '--p-transition-duration';
		const cssVariableAnimationDuration = '--p-animation-duration';
		const getTransition = (cssProperty, duration = 'short', easing = 'base', delay) => {
		    return `${cssProperty} var(${cssVariableTransitionDuration}, ${motionDurationMap[duration]}) ${motionEasingMap[easing]}${delay ? ` var(${cssVariableTransitionDuration}, ${motionDurationMap[delay]})` : ''}`;
		};
		const addImportantToRule = (value) => `${value} !important`;
		const addImportantToEachRule = (input) => {
		    return Object.entries(input).reduce((result, [key, value]) => value === null
		        ? result
		        : ((result[key] =
		            typeof value === 'object' ? addImportantToEachRule(value) : addImportantToRule(value)),
		            result), {});
		};
		// TODO: this is workaround, in order the colors to be bundled in the main bundle, we need to have at least one function here, which is used in project and which calls "getThemedColors"
		// TODO: This mechanism needs to be investigated as part of refactoring
		const doGetThemedColors = (theme = 'light') => {
		    return getThemedColors(theme);
		};
		const getFocusJssStyle = (theme, opts) => {
		    const { offset = '2px', slotted = '', pseudo = false } = opts || {};
		    const { focusColor } = getThemedColors(theme);
		    const { focusColor: focusColorDark } = getThemedColors('dark');
		    const slottedSelector = slotted && slotted !== true ? slotted : '';
		    return {
		        [`&${slotted ? '(' : ''}${slottedSelector}::-moz-focus-inner${slotted ? ')' : ''}`]: {
		            border: 0, // reset ua-style (for FF)
		        },
		        [`&${slotted ? '(' : ''}${slottedSelector}:focus${slotted ? ')' : ''}`]: {
		            outline: 0, // reset ua-style (for older browsers)
		        },
		        ...(pseudo && {
		            [`&${slotted ? '(' : ''}${slottedSelector}:focus-visible${slotted ? ')' : ''}`]: {
		                outline: 0, // reset ua-style (for modern browsers)
		            },
		        }),
		        [`&${slotted ? '(' : ''}${slottedSelector}:focus-visible${slotted ? ')' : ''}${pseudo ? '::before' : ''}`]: {
		            outline: `${borderWidthBase} solid ${focusColor}`,
		            outlineOffset: offset,
		            ...prefersColorSchemeDarkMediaQuery(theme, {
		                outlineColor: focusColorDark,
		            }),
		        },
		    };
		};
		// reset initial styles, e.g. in case link-pure is used with slotted anchor and nested within e.g. an accordion
		const getResetInitialStylesForSlottedAnchor = {
		    margin: 0,
		    padding: 0,
		    outline: 0, // reset native blue outline
		    borderRadius: 0,
		    background: 'transparent',
		};
		/**
		 * Returns a JSS style object that can be used to visually hide text in the browser, while still allowing it to be accessed by screen readers.
		 * @param {boolean} isHidden - A boolean value indicating whether the text should be hidden or not. Defaults to true.
		 * @param {JssStyle} isShownJssStyle - Additional styles applied when isHidden = false
		 * @returns {JssStyle} - A JSS style object containing styles depending on the value of isHidden and isShownJssStyle.
		 */
		const getHiddenTextJssStyle = (isHidden = true, isShownJssStyle) => {
		    return isHidden
		        ? {
		            position: 'absolute',
		            width: '1px',
		            height: '1px',
		            padding: 0,
		            margin: '-1px',
		            overflow: 'hidden',
		            clip: 'rect(0,0,0,0)',
		            whiteSpace: 'nowrap',
		        }
		        : {
		            position: 'static',
		            width: 'auto',
		            height: 'auto',
		            padding: 0,
		            margin: 0,
		            overflow: 'visible',
		            clip: 'auto',
		            whiteSpace: 'normal',
		            ...isShownJssStyle,
		        };
		};
		const BACKDROPS = ['blur', 'shading'];
		// TODO: there should be a shared style util for modal, flyout and flyout-navigation instead of having this code in the
		//  main bundle. Or don't share it at all, in case same transition concept isn't ideal to be shared from an UI point of view.
		/**
		 * Generates JSS styles for a frosted glass background.
		 * @param {boolean} isVisible - Determines if the frosted glass effect is visible.
		 * @param {number} zIndex - The z-index to be used.
		 * @param {Theme} theme - The theme to be used.
		 * @param {string} duration - The duration of the transition animation.
		 * @param {'blur' | 'shading'} backdrop - The backdrop variant.
		 * @returns {JssStyle} - The JSS styles for the frosted glass backdrop.
		 */
		const getBackdropJssStyle = (isVisible, zIndex, theme, duration = 'long', backdrop = 'blur') => {
		    return {
		        position: 'fixed',
		        inset: 0,
		        zIndex,
		        // TODO: background shading is missing in getThemedColors(theme).backgroundShading
		        background: isThemeDark(theme) ? themeDarkBackgroundShading : themeLightBackgroundShading,
		        ...prefersColorSchemeDarkMediaQuery(theme, {
		            background: themeDarkBackgroundShading,
		        }),
		        ...(isVisible
		            ? {
		                visibility: 'inherit',
		                pointerEvents: 'auto',
		                ...(backdrop === 'blur' && frostedGlassStyle),
		                opacity: 1,
		            }
		            : {
		                visibility: 'hidden', // element shall not be tabbable after fade out transition has finished
		                pointerEvents: 'none',
		                ...(backdrop === 'blur' && {
		                    // TODO: is `blur(0px)` necessary at all?
		                    WebkitBackdropFilter: 'blur(0px)',
		                    backdropFilter: 'blur(0px)',
		                }),
		                opacity: 0,
		            }),
		        transition: `${getTransition('opacity', duration)}, ${getTransition('backdrop-filter', duration)}, ${getTransition('-webkit-backdrop-filter', duration)}, visibility 0s linear var(${cssVariableTransitionDuration}, ${isVisible ? '0s' : motionDurationMap[duration]})`,
		    };
		};

		const prefersColorSchemeDarkMediaQuery = (theme, style) => {
		    return isThemeAuto(theme) && { '@media (prefers-color-scheme: dark)': style };
		};

		// NOTE: handpicked selection of plugins from jss-preset-default
		const jss = createJss({
		    plugins: [
		        jssGlobal(),
		        jssNested(),
		        camelCase(),
		        dist({ combineMediaQueries: true }),
		    ],
		});
		const getCss = (jssStyles) => jss
		    .createStyleSheet(jssStyles, {
		    generateId: (rule) => rule.key,
		})
		    .toString();
		const supportsConstructableStylesheets = () => {
		    try {
		        return typeof new CSSStyleSheet().replaceSync === 'function';
		    }
		    catch {
		        return false;
		    }
		};
		// determine it once
		const hasConstructableStylesheetSupport = supportsConstructableStylesheets();
		// getter for easy mocking
		const getHasConstructableStylesheetSupport = () => hasConstructableStylesheetSupport;
		const componentCssMap = new Map();
		const getCachedComponentCss = (host, getComponentCss, ...args) => {
		    const tagName = getTagNameWithoutPrefix(host);
		    if (!componentCssMap.has(tagName)) {
		        componentCssMap.set(tagName, new Map());
		    }
		    const id = args.map((arg) => (typeof arg === 'object' ? JSON.stringify(arg) : arg)).join('|');
		    const cache = componentCssMap.get(tagName);
		    if (!cache.has(id)) {
		        cache.set(id, getComponentCss(...args));
		    }
		    return cache.get(id);
		};
		const attachComponentCss = (host, getComponentCss, ...args) => {
		    const css = getCachedComponentCss(host, getComponentCss, ...args);
		    if (getHasConstructableStylesheetSupport()) {
		        const [sheet] = host.shadowRoot.adoptedStyleSheets;
		        if (sheet) {
		            sheet.replaceSync(css);
		        }
		        else {
		            const newSheet = new CSSStyleSheet();
		            newSheet.replaceSync(css);
		            host.shadowRoot.adoptedStyleSheets = [newSheet];
		        }
		    }
		    else {
		        // NOTE: fallback for Safari
		        // old style needs to be removed and added again in safari to be recognized
		        getShadowRootHTMLElement(host, 'style[jss]')?.remove();
		        const styleEl = document.createElement('style');
		        styleEl.setAttribute('jss', '');
		        styleEl.innerHTML = css;
		        host.shadowRoot.prepend(styleEl);
		    }
		};
		// TODO: this function does nothing but treats for unknowns reasons e.g. getThemedColors to be bundled into main chunk
		const doNothing = () => {
		    addImportantToEachRule({});
		    hasPropValueChanged(1, 1); // to force into main chunk
		};
		const buildResponsiveStyles = (rawValue, getJssStyle) => {
		    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
		    const value = parseJSON(rawValue);
		    return typeof value === 'object'
		        ? Object.keys(value)
		            // base styles are applied on root object, responsive styles are nested within
		            // hence it is used as the initial object within reduce function
		            .filter((key) => key !== 'base')
		            .reduce((result, breakpointValue) => ({
		            ...result,
		            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
		            [getMediaQueryMin(breakpointValue)]: getJssStyle(value[breakpointValue]),
		        }), getJssStyle(value.base))
		        : getJssStyle(value);
		};
		const isObject = (obj) => typeof obj === 'object' && !Array.isArray(obj);
		// NOTE: taken from https://stackoverflow.com/a/48218209
		const mergeDeep = (...objects) => {
		    return objects.reduce((prev, obj) => {
		        Object.keys(obj).forEach((key) => {
		            const pVal = prev[key];
		            const oVal = obj[key];
		            if (isObject(pVal) && isObject(oVal)) {
		                prev[key] = mergeDeep(pVal, oVal);
		            }
		            else {
		                prev[key] = oVal;
		            }
		        });
		        return prev;
		    }, {});
		};

		/**
		 * Checks if the current environment supports the native Popover API.
		 *
		 * @returns {boolean} `true` if the native Popover API is supported, `false` otherwise.
		 */
		const supportsNativePopover = () => {
		    if (!hasWindow) {
		        return false;
		    }
		    return HTMLElement.prototype.hasOwnProperty('popover');
		};
		// determine it once
		const hasNativePopoverSupport = supportsNativePopover();
		// getter for easy mocking
		const getHasNativePopoverSupport = () => hasNativePopoverSupport;

		const isThemeAuto = (theme) => {
		    return theme === 'auto';
		};

		const isThemeDark = (theme) => {
		    return theme === 'dark';
		};

		const formatObjectOutput = (value) => {
		    return JSON.stringify(value)
		        .replace(/"([a-zA-Z?]+)":/g, '$1:') // remove double quotes from keys
		        .replace(/([,:{])/g, '$1 ') // add space after following: ,:{
		        .replace(/(})/g, ' $1') // add space before following: }
		        .replace(/^"(.+)"$/, '$1'); // remove wrapping double quotes
		};
		const formatArrayOutput = (value) => {
		    return (JSON.stringify(value.map((x) => (x === undefined ? `${x}` : x))) // wrap undefined in quotes to not convert it to null
		        .replace(/'/g, '') // remove single quotes
		        // eslint-disable-next-line @typescript-eslint/quotes
		        .replace(/"/g, "'") // replace double quotes with single quotes
		        .replace(/'(undefined)'/, '$1') // remove quotes around undefined
		        .replace(/,/g, ', ') // add space after comma
		    );
		};
		const printErrorMessage = ({ propName, propValue, // TODO: might be nicer if this is always a string
		propType, componentName, }) => {
		    consoleError(`Invalid property '${propName}' with value '${formatObjectOutput(propValue)}' supplied to ${componentName}, expected one of: ${propType}`);
		};
		const isValueNotOfType = (propValue, propType) => {
		    return propValue !== undefined && typeof propValue !== propType;
		};
		const validateValueOfType = (propName, propValue, propType) => {
		    if (isValueNotOfType(propValue, propType)) {
		        return { propName, propValue, propType };
		    }
		};
		const breakpointCustomizableTemplate = 'value, ' +
		    formatObjectOutput(breakpoints.reduce((prev, key) => ({ ...prev, [key + (key !== 'base' ? '?' : '')]: 'value' }), {})).replace(/"/g, '');
		const getBreakpointCustomizableStructure = (allowedValues) => {
		    if (allowedValues !== 'boolean' && allowedValues !== 'number') {
		        allowedValues = formatArrayOutput(allowedValues)
		            .replace(/\[/g, '(') // starting inline type literal array
		            .replace(/]/g, ')[]') // ending inline type literal array
		            .replace(/,/g, ' |'); // replace commas with a pipe
		    }
		    return breakpointCustomizableTemplate.replace(/value/g, allowedValues);
		};
		const getAriaStructure = (allowedAriaAttributes) => {
		    return (formatObjectOutput(allowedAriaAttributes.reduce((prev, key) => ({
		        ...prev,
		        [key]: 'value',
		    }), {}))
		        .replace(/":/g, '"?:') // add optional modifier on keys before colon
		        // eslint-disable-next-line @typescript-eslint/quotes
		        .replace(/"/g, "'") // replace double quotes with single quotes
		    );
		};
		const getShapeStructure = (shapeStructure) => {
		    return formatObjectOutput(Object.keys(shapeStructure).reduce((prev, key) => ({ ...prev, [key]: shapeStructure[key].name }), {})).replace(/"/g, ''); // remove double quotes
		};
		const isBreakpointCustomizableValueInvalid = (value, allowedValues) => {
		    return allowedValues === 'boolean' || allowedValues === 'number'
		        ? isValueNotOfType(value, allowedValues)
		        : !allowedValues.includes(value);
		};
		// TODO: maybe dissolve object structure and have standalone utils
		const AllowedTypes = {
		    // eslint-disable-next-line id-blacklist
		    string: (...args) => validateValueOfType(...args, 'string'),
		    // eslint-disable-next-line id-blacklist
		    number: (...args) => validateValueOfType(...args, 'number'),
		    // eslint-disable-next-line id-blacklist
		    boolean: (...args) => validateValueOfType(...args, 'boolean'),
		    array: (allowedType) => 
		    // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
		    function array(propName, propValue) {
		        return isValidArray(propName, propValue, allowedType);
		    },
		    oneOf: (allowedValuesOrValidatorFunctions) => 
		    // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
		    function oneOf(propName, propValue) {
		        // use first item to determine if we've got primitive types or validator functions
		        if (typeof allowedValuesOrValidatorFunctions[0] !== 'function') {
		            if (!allowedValuesOrValidatorFunctions.includes(propValue)) {
		                return { propName, propValue, propType: formatArrayOutput(allowedValuesOrValidatorFunctions) };
		            }
		        }
		        else if (!allowedValuesOrValidatorFunctions.some((func) => func(propName, propValue) === undefined)) {
		            return {
		                propName,
		                propValue,
		                propType: allowedValuesOrValidatorFunctions.map((func) => func.name).join(', '),
		            };
		        }
		    },
		    breakpoint: (allowedValues) => 
		    // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
		    function breakpoint(propName, propValue) {
		        // TODO: do parseJSON once in the component, currently it is happening multiple times in a single lifecycle
		        const value = parseJSON(propValue);
		        let isInvalid = false;
		        if (typeof value === 'object') {
		            if (
		            // check structure keys: base, xs, s, m, l, xl
		            // TODO: check for base key
		            Object.keys(value).some((key) => !breakpoints.includes(key)) ||
		                // check actual values of keys, e.g. true, false, 'small' or 5
		                Object.values(value).some((val) => isBreakpointCustomizableValueInvalid(val, allowedValues))) {
		                isInvalid = true;
		            }
		        }
		        else if (isBreakpointCustomizableValueInvalid(value, allowedValues)) {
		            // single flat value like true, false, 'small' or 5, not breakpoint customizable object
		            isInvalid = true;
		        }
		        if (isInvalid) {
		            return {
		                propName,
		                propValue: formatObjectOutput(value),
		                propType: getBreakpointCustomizableStructure(allowedValues),
		            };
		        }
		    },
		    aria: (allowedAriaAttributes) => 
		    // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
		    function aria(propName, propValue) {
		        const ariaAttributes = parseJSONAttribute(propValue);
		        if (ariaAttributes &&
		            Object.keys(ariaAttributes).some((ariaKey) => !allowedAriaAttributes.includes(ariaKey))) {
		            return {
		                propName,
		                propValue: formatObjectOutput(ariaAttributes),
		                propType: getAriaStructure(allowedAriaAttributes),
		            };
		        }
		    },
		    shape: (shapeStructure) => 
		    // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
		    function shape(propName, propValue) {
		        if (propValue) {
		            // const propValueKeys = Object.keys(propValue);
		            if (
		            // check structure, but propValue could contain additional keys
		            // but how to handle optional keys like in table-head-cell's sort property?
		            // Object.keys(shapeStructure).some((key) => !propValueKeys.includes(key)) ||
		            // check values
		            Object.entries(shapeStructure).some(([structureKey, validatorFunc]) => validatorFunc(structureKey, propValue[structureKey]))) {
		                // TODO: more precise inner errors from value validation could be output
		                return {
		                    propName,
		                    propValue, // TODO: convert to string?
		                    propType: getShapeStructure(shapeStructure),
		                };
		            }
		        }
		    },
		};
		const validateProps = (instance, propTypes) => {
		    Object.entries(propTypes)
		        .map(([propKey, validatorFunc]) => validatorFunc(propKey, instance[propKey]))
		        .filter((x) => x)
		        .forEach((error) => printErrorMessage({ ...error, componentName: getTagNameWithoutPrefix(instance.host) }));
		};
		/**
		 * Validates an array using a provided validator function and returns the first encountered validation error.
		 *
		 * @param {string} propName - The name of the property being validated.
		 * @param {any} arr - The input to be validated.
		 * @param {ValidatorFunction} validator - The validator function that checks each array item.
		 * @returns {ValidationError | undefined} The first encountered validation error object, or undefined if the array is valid.
		 */
		const isValidArray = (propName, arr, validator) => {
		    const validationError = Array.isArray(arr)
		        ? validator(propName, arr.find((item) => validator(propName, item)))
		        : {
		            propName,
		            propValue: arr,
		            propType: validator(propName, null).propType, // Get propType by passing in null which will always result in error
		        };
		    if (validationError) {
		        return { ...validationError, propType: `${validationError.propType}[]` };
		    }
		};

		exports.AllowedTypes = AllowedTypes;
		exports.BACKDROPS = BACKDROPS;
		exports.Fragment = Fragment;
		exports.Host = Host;
		exports.addImportantToEachRule = addImportantToEachRule;
		exports.addImportantToRule = addImportantToRule;
		exports.attachComponentCss = attachComponentCss;
		exports.bootstrapLazy = bootstrapLazy;
		exports.borderWidthBase = borderWidthBase;
		exports.breakpoint = breakpoint;
		exports.breakpoints = breakpoints;
		exports.buildResponsiveStyles = buildResponsiveStyles;
		exports.consoleError = consoleError;
		exports.consoleWarn = consoleWarn;
		exports.createEvent = createEvent;
		exports.cssVariableAnimationDuration = cssVariableAnimationDuration;
		exports.cssVariableTransitionDuration = cssVariableTransitionDuration;
		exports.doGetThemedColors = doGetThemedColors;
		exports.doNothing = doNothing;
		exports.forceUpdate = forceUpdate;
		exports.frostedGlassStyle = frostedGlassStyle;
		exports.getBackdropJssStyle = getBackdropJssStyle;
		exports.getCss = getCss;
		exports.getCurrentMatchingBreakpointValue = getCurrentMatchingBreakpointValue;
		exports.getElement = getElement;
		exports.getFocusJssStyle = getFocusJssStyle;
		exports.getHTMLElement = getHTMLElement;
		exports.getHasNativePopoverSupport = getHasNativePopoverSupport;
		exports.getHiddenTextJssStyle = getHiddenTextJssStyle;
		exports.getHighContrastColors = getHighContrastColors;
		exports.getInvertedThemedColors = getInvertedThemedColors;
		exports.getMediaQueryMin = getMediaQueryMin;
		exports.getPrefixedTagNames = getPrefixedTagNames;
		exports.getResetInitialStylesForSlottedAnchor = getResetInitialStylesForSlottedAnchor;
		exports.getShadowRootHTMLElement = getShadowRootHTMLElement;
		exports.getTagName = getTagName;
		exports.getTagNameWithoutPrefix = getTagNameWithoutPrefix;
		exports.getThemedColors = getThemedColors;
		exports.getTransition = getTransition;
		exports.h = h;
		exports.hasCounter = hasCounter;
		exports.hasPropValueChanged = hasPropValueChanged;
		exports.hasWindow = hasWindow;
		exports.inputEventListenerCurry = inputEventListenerCurry;
		exports.isHighContrastMode = isHighContrastMode;
		exports.isThemeDark = isThemeDark;
		exports.mergeDeep = mergeDeep;
		exports.motionDurationLong = motionDurationLong;
		exports.motionDurationModerate = motionDurationModerate;
		exports.motionDurationShort = motionDurationShort;
		exports.motionDurationVeryLong = motionDurationVeryLong;
		exports.motionEasingBase = motionEasingBase;
		exports.motionEasingIn = motionEasingIn;
		exports.motionEasingOut = motionEasingOut;
		exports.observeAttributes = observeAttributes;
		exports.observeBreakpointChange = observeBreakpointChange;
		exports.observeChildren = observeChildren;
		exports.paramCaseToCamelCase = paramCaseToCamelCase;
		exports.parseAndGetAriaAttributes = parseAndGetAriaAttributes;
		exports.parseJSON = parseJSON;
		exports.parseJSONAttribute = parseJSONAttribute;
		exports.prefersColorSchemeDarkMediaQuery = prefersColorSchemeDarkMediaQuery;
		exports.promiseResolve = promiseResolve;
		exports.registerInstance = registerInstance;
		exports.removeAttribute = removeAttribute;
		exports.setAriaAttributes = setAriaAttributes;
		exports.setAttribute = setAttribute;
		exports.setNonce = setNonce;
		exports.throttle = throttle;
		exports.throwException = throwException;
		exports.unobserveAttributes = unobserveAttributes;
		exports.unobserveBreakpointChange = unobserveBreakpointChange;
		exports.unobserveChildren = unobserveChildren;
		exports.updateCounter = updateCounter;
		exports.validateProps = validateProps;

		
	} (validatePropsF6586828));
	return validatePropsF6586828;
}

var hasRequiredLoader_cjs;

function requireLoader_cjs () {
	if (hasRequiredLoader_cjs) return loader_cjs;
	hasRequiredLoader_cjs = 1;

	Object.defineProperty(loader_cjs, '__esModule', { value: true });

	const validateProps = requireValidatePropsF6586828();
	const appGlobals = requireAppGlobals999bcb42();
	requireGetCDNBaseURLE7722df3();

	const defineCustomElements = async (win, options) => {
	  if (typeof window === 'undefined') return undefined;
	  if(!window.PDS_SKIP_FETCH) { appGlobals.globalScripts(); }
	  return validateProps.bootstrapLazy(JSON.parse("[[\"p-table_7.cjs\",[[1,\"p-table\",{\"caption\":[1],\"theme\":[1]}],[1,\"p-table-body\"],[1,\"p-table-cell\",{\"multiline\":[4]}],[1,\"p-table-head\"],[1,\"p-table-head-cell\",{\"sort\":[16],\"hideLabel\":[4,\"hide-label\"],\"multiline\":[4]}],[1,\"p-table-head-row\"],[1,\"p-table-row\"]]],[\"p-flex_2.cjs\",[[1,\"p-flex\",{\"inline\":[8],\"wrap\":[1],\"direction\":[1],\"justifyContent\":[1,\"justify-content\"],\"alignItems\":[1,\"align-items\"],\"alignContent\":[1,\"align-content\"]}],[1,\"p-flex-item\",{\"width\":[1],\"offset\":[1],\"alignSelf\":[1,\"align-self\"],\"grow\":[8],\"shrink\":[8],\"flex\":[1]}]]],[\"p-flyout-navigation_2.cjs\",[[1,\"p-flyout-navigation\",{\"open\":[4],\"activeIdentifier\":[1,\"active-identifier\"],\"theme\":[1],\"aria\":[1],\"flyoutNavigationItemElements\":[32]},null,{\"open\":[\"openChangeHandler\"]}],[1,\"p-flyout-navigation-item\",{\"label\":[1],\"identifier\":[1]}]]],[\"p-grid_2.cjs\",[[1,\"p-grid\",{\"direction\":[1],\"wrap\":[1],\"gutter\":[8]}],[1,\"p-grid-item\",{\"size\":[8],\"offset\":[8]}]]],[\"p-multi-select_2.cjs\",[[1,\"p-multi-select\",{\"label\":[1],\"description\":[1],\"name\":[1],\"value\":[1040],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"disabled\":[4],\"required\":[4],\"dropdownDirection\":[1,\"dropdown-direction\"],\"theme\":[1],\"isOpen\":[32],\"srHighlightedOptionText\":[32],\"hasFilterResults\":[32]},[[0,\"internalOptionUpdate\",\"updateOptionHandler\"]],{\"value\":[\"onValueChange\"]}],[1,\"p-multi-select-option\",{\"value\":[1],\"disabled\":[4]}]]],[\"p-segmented-control_2.cjs\",[[1,\"p-segmented-control\",{\"backgroundColor\":[1,\"background-color\"],\"theme\":[1],\"value\":[8],\"columns\":[8]}],[17,\"p-segmented-control-item\",{\"value\":[8],\"disabled\":[4],\"label\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"]},[[2,\"click\",\"onClick\"]],{\"label\":[\"handleLabelChange\"],\"icon\":[\"handleLabelChange\"],\"iconSource\":[\"handleLabelChange\"]}]]],[\"p-select-wrapper_2.cjs\",[[1,\"p-select-wrapper\",{\"label\":[1],\"description\":[1],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"filter\":[4],\"theme\":[1],\"dropdownDirection\":[1,\"dropdown-direction\"],\"native\":[4]}],[1,\"p-select-wrapper-dropdown\",{\"selectRef\":[16],\"label\":[1],\"description\":[1],\"message\":[1],\"state\":[1],\"direction\":[1],\"theme\":[1],\"filter\":[4],\"required\":[4],\"disabled\":[4],\"onOpenChange\":[16],\"isOpenOverride\":[4,\"is-open-override\"],\"isOpen\":[32],\"optionMaps\":[32],\"searchString\":[32]}]]],[\"p-select_2.cjs\",[[1,\"p-select\",{\"label\":[1],\"description\":[1],\"name\":[1],\"value\":[1025],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"disabled\":[4],\"required\":[4],\"dropdownDirection\":[1,\"dropdown-direction\"],\"theme\":[1],\"isOpen\":[32],\"srHighlightedOptionText\":[32]},[[0,\"internalOptionUpdate\",\"updateOptionHandler\"]],{\"value\":[\"onValueChange\"]}],[1,\"p-select-option\",{\"value\":[1],\"disabled\":[4]}]]],[\"p-stepper-horizontal_2.cjs\",[[1,\"p-stepper-horizontal\",{\"size\":[1],\"theme\":[1]}],[17,\"p-stepper-horizontal-item\",{\"state\":[1],\"disabled\":[4]},[[2,\"click\",\"onClick\"]],{\"state\":[\"onStateChange\"]}]]],[\"p-tabs_2.cjs\",[[1,\"p-tabs\",{\"size\":[1],\"weight\":[1],\"theme\":[1],\"gradientColorScheme\":[1,\"gradient-color-scheme\"],\"gradientColor\":[1,\"gradient-color\"],\"activeTabIndex\":[1026,\"active-tab-index\"],\"tabsItemElements\":[32]},null,{\"activeTabIndex\":[\"activeTabHandler\"]}],[1,\"p-tabs-item\",{\"label\":[1]},null,{\"label\":[\"handleLabelChange\"]}]]],[\"p-text-list_2.cjs\",[[1,\"p-text-list\",{\"listType\":[1,\"list-type\"],\"orderType\":[1,\"order-type\"],\"type\":[1],\"theme\":[1]}],[1,\"p-text-list-item\"]]],[\"p-toast_2.cjs\",[[1,\"p-toast\",{\"theme\":[1],\"addMessage\":[64]}],[1,\"p-toast-item\",{\"text\":[1],\"state\":[1],\"theme\":[1]}]]],[\"p-accordion.cjs\",[[1,\"p-accordion\",{\"size\":[1],\"theme\":[1],\"heading\":[1],\"headingTag\":[1,\"heading-tag\"],\"tag\":[1],\"open\":[4],\"compact\":[4],\"sticky\":[4]}]]],[\"p-banner.cjs\",[[1,\"p-banner\",{\"open\":[4],\"heading\":[1],\"headingTag\":[1,\"heading-tag\"],\"description\":[1],\"state\":[1],\"dismissButton\":[4,\"dismiss-button\"],\"persistent\":[4],\"width\":[1],\"theme\":[1]},null,{\"open\":[\"openChangeHandler\"]}]]],[\"p-button.cjs\",[[17,\"p-button\",{\"type\":[1],\"name\":[1],\"value\":[1],\"disabled\":[4],\"loading\":[4],\"variant\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"hideLabel\":[8,\"hide-label\"],\"theme\":[1],\"aria\":[1]},[[2,\"click\",\"onClick\"]]]]],[\"p-button-group.cjs\",[[1,\"p-button-group\",{\"direction\":[1]}]]],[\"p-button-pure.cjs\",[[17,\"p-button-pure\",{\"type\":[1],\"name\":[1],\"value\":[1],\"disabled\":[4],\"loading\":[4],\"size\":[1],\"weight\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"underline\":[4],\"active\":[4],\"hideLabel\":[8,\"hide-label\"],\"alignLabel\":[1,\"align-label\"],\"stretch\":[8],\"theme\":[1],\"aria\":[1]},[[2,\"click\",\"onClick\"]]]]],[\"p-button-tile.cjs\",[[17,\"p-button-tile\",{\"size\":[1],\"weight\":[1],\"background\":[1],\"aspectRatio\":[1,\"aspect-ratio\"],\"label\":[1],\"description\":[1],\"align\":[1],\"gradient\":[4],\"compact\":[1032],\"type\":[1],\"disabled\":[4],\"loading\":[4],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"aria\":[1]},[[2,\"click\",\"onClick\"]]]]],[\"p-carousel.cjs\",[[1,\"p-carousel\",{\"heading\":[1],\"headingSize\":[1,\"heading-size\"],\"description\":[1],\"alignHeader\":[1,\"align-header\"],\"rewind\":[4],\"wrapContent\":[4,\"wrap-content\"],\"width\":[1],\"slidesPerPage\":[1032,\"slides-per-page\"],\"disablePagination\":[1032,\"disable-pagination\"],\"pagination\":[1032],\"aria\":[1],\"intl\":[1],\"theme\":[1],\"activeSlideIndex\":[2,\"active-slide-index\"],\"skipLinkTarget\":[1,\"skip-link-target\"],\"amountOfPages\":[32]},null,{\"activeSlideIndex\":[\"activeSlideHandler\"]}]]],[\"p-checkbox-wrapper.cjs\",[[1,\"p-checkbox-wrapper\",{\"label\":[1],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"loading\":[4],\"theme\":[1]},[[0,\"keydown\",\"onKeydown\"]]]]],[\"p-content-wrapper.cjs\",[[1,\"p-content-wrapper\",{\"width\":[1],\"backgroundColor\":[1,\"background-color\"],\"theme\":[1]}]]],[\"p-crest.cjs\",[[17,\"p-crest\",{\"href\":[1],\"target\":[1],\"aria\":[1]}]]],[\"p-display.cjs\",[[1,\"p-display\",{\"tag\":[1],\"size\":[1],\"align\":[1],\"color\":[1],\"ellipsis\":[4],\"theme\":[1]}]]],[\"p-divider.cjs\",[[1,\"p-divider\",{\"color\":[1],\"orientation\":[1],\"direction\":[1],\"theme\":[1]}]]],[\"p-fieldset.cjs\",[[1,\"p-fieldset\",{\"label\":[1],\"labelSize\":[1,\"label-size\"],\"required\":[4],\"state\":[1],\"message\":[1],\"theme\":[1]}]]],[\"p-fieldset-wrapper.cjs\",[[1,\"p-fieldset-wrapper\",{\"label\":[1],\"labelSize\":[1,\"label-size\"],\"required\":[4],\"state\":[1],\"message\":[1],\"theme\":[1]}]]],[\"p-flyout.cjs\",[[1,\"p-flyout\",{\"open\":[4],\"position\":[1],\"theme\":[1],\"aria\":[1]},null,{\"open\":[\"openChangeHandler\"]}]]],[\"p-heading.cjs\",[[1,\"p-heading\",{\"tag\":[1],\"size\":[1],\"align\":[1],\"color\":[1],\"ellipsis\":[4],\"theme\":[1]}]]],[\"p-headline.cjs\",[[1,\"p-headline\",{\"variant\":[1],\"tag\":[1],\"align\":[1],\"color\":[1],\"ellipsis\":[4],\"theme\":[1]}]]],[\"p-icon.cjs\",[[1,\"p-icon\",{\"name\":[1],\"source\":[1],\"color\":[1],\"size\":[1],\"lazy\":[4],\"theme\":[1],\"aria\":[1]}]]],[\"p-inline-notification.cjs\",[[1,\"p-inline-notification\",{\"heading\":[1],\"headingTag\":[1,\"heading-tag\"],\"description\":[1],\"state\":[1],\"dismissButton\":[4,\"dismiss-button\"],\"persistent\":[4],\"actionLabel\":[1,\"action-label\"],\"actionLoading\":[4,\"action-loading\"],\"actionIcon\":[1,\"action-icon\"],\"theme\":[1]}]]],[\"p-link.cjs\",[[17,\"p-link\",{\"variant\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"href\":[1],\"theme\":[1],\"target\":[1],\"download\":[1],\"rel\":[1],\"hideLabel\":[8,\"hide-label\"],\"aria\":[1]}]]],[\"p-link-pure.cjs\",[[17,\"p-link-pure\",{\"alignLabel\":[1,\"align-label\"],\"stretch\":[8],\"size\":[1],\"weight\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"underline\":[4],\"href\":[1],\"active\":[4],\"hideLabel\":[8,\"hide-label\"],\"theme\":[1],\"target\":[1],\"download\":[1],\"rel\":[1],\"aria\":[1]}]]],[\"p-link-social.cjs\",[[17,\"p-link-social\",{\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"href\":[1],\"theme\":[1],\"target\":[1],\"rel\":[1],\"hideLabel\":[8,\"hide-label\"]}]]],[\"p-link-tile.cjs\",[[17,\"p-link-tile\",{\"size\":[1],\"weight\":[1],\"background\":[1],\"aspectRatio\":[1,\"aspect-ratio\"],\"label\":[1],\"description\":[1],\"align\":[1],\"gradient\":[4],\"compact\":[1032],\"href\":[1],\"target\":[1],\"download\":[1],\"rel\":[1],\"aria\":[1]}]]],[\"p-link-tile-model-signature.cjs\",[[1,\"p-link-tile-model-signature\",{\"model\":[1],\"weight\":[1],\"aspectRatio\":[1,\"aspect-ratio\"],\"heading\":[1],\"description\":[1],\"linkDirection\":[1,\"link-direction\"],\"headingTag\":[1,\"heading-tag\"]}]]],[\"p-link-tile-product.cjs\",[[17,\"p-link-tile-product\",{\"heading\":[1],\"price\":[1],\"priceOriginal\":[1,\"price-original\"],\"description\":[1],\"likeButton\":[4,\"like-button\"],\"liked\":[4],\"href\":[1],\"aspectRatio\":[1,\"aspect-ratio\"],\"target\":[1],\"rel\":[1],\"theme\":[1]}]]],[\"p-marque.cjs\",[[17,\"p-marque\",{\"trademark\":[4],\"variant\":[1],\"size\":[1],\"href\":[1],\"target\":[1],\"aria\":[1]}]]],[\"p-modal.cjs\",[[1,\"p-modal\",{\"open\":[4],\"disableCloseButton\":[4,\"disable-close-button\"],\"dismissButton\":[4,\"dismiss-button\"],\"disableBackdropClick\":[4,\"disable-backdrop-click\"],\"heading\":[1],\"backdrop\":[1],\"fullscreen\":[8],\"aria\":[1],\"theme\":[1]},null,{\"open\":[\"openChangeHandler\"]}]]],[\"p-model-signature.cjs\",[[1,\"p-model-signature\",{\"model\":[1],\"safeZone\":[4,\"safe-zone\"],\"fetchPriority\":[1,\"fetch-priority\"],\"lazy\":[4],\"size\":[1],\"color\":[1],\"theme\":[1]}]]],[\"p-pagination.cjs\",[[17,\"p-pagination\",{\"totalItemsCount\":[2,\"total-items-count\"],\"itemsPerPage\":[2,\"items-per-page\"],\"activePage\":[1026,\"active-page\"],\"maxNumberOfPageLinks\":[8,\"max-number-of-page-links\"],\"showLastPage\":[4,\"show-last-page\"],\"allyLabel\":[1,\"ally-label\"],\"allyLabelPrev\":[1,\"ally-label-prev\"],\"allyLabelPage\":[1,\"ally-label-page\"],\"allyLabelNext\":[1,\"ally-label-next\"],\"intl\":[1],\"theme\":[1]}]]],[\"p-pin-code.cjs\",[[1,\"p-pin-code\",{\"label\":[1],\"description\":[1],\"name\":[1],\"length\":[2],\"hideLabel\":[8,\"hide-label\"],\"state\":[1],\"disabled\":[4],\"loading\":[4],\"required\":[4],\"message\":[1],\"type\":[1],\"value\":[1025],\"theme\":[1]}]]],[\"p-popover.cjs\",[[1,\"p-popover\",{\"direction\":[1],\"description\":[1],\"aria\":[1],\"theme\":[1],\"open\":[32]}]]],[\"p-radio-button-wrapper.cjs\",[[1,\"p-radio-button-wrapper\",{\"label\":[1],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"loading\":[4],\"theme\":[1]}]]],[\"p-scroller.cjs\",[[1,\"p-scroller\",{\"gradientColorScheme\":[1,\"gradient-color-scheme\"],\"gradientColor\":[1,\"gradient-color\"],\"scrollToPosition\":[1025,\"scroll-to-position\"],\"scrollIndicatorPosition\":[1,\"scroll-indicator-position\"],\"alignScrollIndicator\":[1,\"align-scroll-indicator\"],\"theme\":[1],\"scrollbar\":[4],\"aria\":[1],\"isPrevHidden\":[32],\"isNextHidden\":[32]},null,{\"scrollToPosition\":[\"scrollToPositionHandler\"]}]]],[\"p-spinner.cjs\",[[1,\"p-spinner\",{\"size\":[1],\"theme\":[1],\"aria\":[1]}]]],[\"p-switch.cjs\",[[17,\"p-switch\",{\"alignLabel\":[1,\"align-label\"],\"hideLabel\":[8,\"hide-label\"],\"stretch\":[8],\"checked\":[4],\"disabled\":[4],\"loading\":[4],\"theme\":[1]},[[2,\"click\",\"onClick\"]]]]],[\"p-tabs-bar.cjs\",[[1,\"p-tabs-bar\",{\"size\":[1],\"weight\":[1],\"theme\":[1],\"gradientColorScheme\":[1,\"gradient-color-scheme\"],\"gradientColor\":[1,\"gradient-color\"],\"activeTabIndex\":[2,\"active-tab-index\"],\"tabElements\":[32]},null,{\"activeTabIndex\":[\"activeTabIndexHandler\"]}]]],[\"p-tag.cjs\",[[1,\"p-tag\",{\"theme\":[1],\"color\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"]}]]],[\"p-tag-dismissible.cjs\",[[17,\"p-tag-dismissible\",{\"color\":[1],\"theme\":[1],\"label\":[1],\"aria\":[1]}]]],[\"p-text.cjs\",[[1,\"p-text\",{\"tag\":[1],\"size\":[1],\"weight\":[1],\"align\":[1],\"color\":[1],\"ellipsis\":[4],\"theme\":[1]}]]],[\"p-text-field-wrapper.cjs\",[[1,\"p-text-field-wrapper\",{\"label\":[1],\"unit\":[1],\"unitPosition\":[1,\"unit-position\"],\"description\":[1],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"showCharacterCount\":[4,\"show-character-count\"],\"showCounter\":[4,\"show-counter\"],\"actionIcon\":[1,\"action-icon\"],\"actionLoading\":[4,\"action-loading\"],\"submitButton\":[4,\"submit-button\"],\"showPasswordToggle\":[4,\"show-password-toggle\"],\"theme\":[1],\"showPassword\":[32],\"isClearable\":[32]},null,{\"showCounter\":[\"onShowCounterChange\"]}]]],[\"p-textarea-wrapper.cjs\",[[1,\"p-textarea-wrapper\",{\"label\":[1],\"description\":[1],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"showCharacterCount\":[4,\"show-character-count\"],\"showCounter\":[4,\"show-counter\"],\"theme\":[1]},null,{\"showCounter\":[\"onShowCounterChange\"]}]]],[\"p-wordmark.cjs\",[[17,\"p-wordmark\",{\"size\":[1],\"theme\":[1],\"href\":[1],\"target\":[1],\"aria\":[1]}]]]]"), options);
	};

	loader_cjs.setNonce = validateProps.setNonce;
	loader_cjs.defineCustomElements = defineCustomElements;

	
	return loader_cjs;
}

var hasRequiredSrc;

function requireSrc () {
	if (hasRequiredSrc) return src;
	hasRequiredSrc = 1;
	// polyfills for features used by our components but unsupported within jest (jsdom)
	requireAdoptedStyleSheets();
	requireIntersectionObserver();
	requireMatchMedia();
	requireMatchMedia_addListener();
	requireDist();

	if (!navigator.userAgent.includes('Node.js') && !navigator.userAgent.includes('jsdom')) {
	  throw new Error(
	    '[Porsche Design System] the jsdom-polyfill sub package should only be used in node and jsdom environments'
	  );
	}

	// skip initial stylesheet fetch
	window.PDS_SKIP_FETCH = true;

	// Since DSR conversion does not work in jsdom render client side markup instead
	process.browser = true;

	// jsdom polyfill build does not load anything from CDN and also does not use our web components manager
	// therefore, we have to setup the document.porscheDesignSystem ourselves here
	// '3.15.0-rc.5' is replaced during build
	document.porscheDesignSystem = {
	  cdn: {
	    url: 'https://cdn.ui.porsche.com', // needs to be set because we're not initializing via components-js load() method which would normally set this
	    prefixes: [],
	  },
	  ['3.15.0-rc.5']: {
	    readyResolve: () => {},
	    isReady: () => Promise.resolve(),
	  },
	};

	// workaround for WebComponentManager not working in jsdom because of missing <script type="module"> support
	// see: https://github.com/jsdom/jsdom/issues/2475
	requireLoader_cjs().defineCustomElements(); // this is executed synchronous since stencil v4

	window.PDS_SKIP_FETCH = false;
	return src;
}

var srcExports = requireSrc();
var index = /*@__PURE__*/getDefaultExportFromCjs(srcExports);

module.exports = index;
