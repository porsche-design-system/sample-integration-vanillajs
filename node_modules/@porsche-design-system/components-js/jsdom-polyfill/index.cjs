'use strict';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var src = {};

var adoptedStyleSheets = {};

var hasRequiredAdoptedStyleSheets;

function requireAdoptedStyleSheets () {
	if (hasRequiredAdoptedStyleSheets) return adoptedStyleSheets;
	hasRequiredAdoptedStyleSheets = 1;
	(function () {

	    if (typeof document === 'undefined' || 'adoptedStyleSheets' in document) { return; }

	    var hasShadyCss = 'ShadyCSS' in window && !ShadyCSS.nativeShadow;
	    var bootstrapper = document.implementation.createHTMLDocument('');
	    var closedShadowRootRegistry = new WeakMap();
	    var _DOMException = typeof DOMException === 'object' ? Error : DOMException;
	    var defineProperty = Object.defineProperty;
	    var forEach = Array.prototype.forEach;

	    var importPattern = /@import.+?;?$/gm;
	    function rejectImports(contents) {
	        var _contents = contents.replace(importPattern, '');
	        if (_contents !== contents) {
	            console.warn('@import rules are not allowed here. See https://github.com/WICG/construct-stylesheets/issues/119#issuecomment-588352418');
	        }
	        return _contents.trim();
	    }
	    function isElementConnected(element) {
	        return 'isConnected' in element
	            ? element.isConnected
	            : document.contains(element);
	    }
	    function unique(arr) {
	        return arr.filter(function (value, index) { return arr.indexOf(value) === index; });
	    }
	    function diff(arr1, arr2) {
	        return arr1.filter(function (value) { return arr2.indexOf(value) === -1; });
	    }
	    function removeNode(node) {
	        node.parentNode.removeChild(node);
	    }
	    function getShadowRoot(element) {
	        return element.shadowRoot || closedShadowRootRegistry.get(element);
	    }

	    var cssStyleSheetMethods = [
	        'addRule',
	        'deleteRule',
	        'insertRule',
	        'removeRule',
	    ];
	    var NonConstructedStyleSheet = CSSStyleSheet;
	    var nonConstructedProto = NonConstructedStyleSheet.prototype;
	    nonConstructedProto.replace = function () {
	        return Promise.reject(new _DOMException("Can't call replace on non-constructed CSSStyleSheets."));
	    };
	    nonConstructedProto.replaceSync = function () {
	        throw new _DOMException("Failed to execute 'replaceSync' on 'CSSStyleSheet': Can't call replaceSync on non-constructed CSSStyleSheets.");
	    };
	    function isCSSStyleSheetInstance(instance) {
	        return typeof instance === 'object'
	            ? proto$1.isPrototypeOf(instance) ||
	                nonConstructedProto.isPrototypeOf(instance)
	            : false;
	    }
	    function isNonConstructedStyleSheetInstance(instance) {
	        return typeof instance === 'object'
	            ? nonConstructedProto.isPrototypeOf(instance)
	            : false;
	    }
	    var $basicStyleElement = new WeakMap();
	    var $locations = new WeakMap();
	    var $adoptersByLocation = new WeakMap();
	    var $appliedMethods = new WeakMap();
	    function addAdopterLocation(sheet, location) {
	        var adopter = document.createElement('style');
	        $adoptersByLocation.get(sheet).set(location, adopter);
	        $locations.get(sheet).push(location);
	        return adopter;
	    }
	    function getAdopterByLocation(sheet, location) {
	        return $adoptersByLocation.get(sheet).get(location);
	    }
	    function removeAdopterLocation(sheet, location) {
	        $adoptersByLocation.get(sheet).delete(location);
	        $locations.set(sheet, $locations.get(sheet).filter(function (_location) { return _location !== location; }));
	    }
	    function restyleAdopter(sheet, adopter) {
	        requestAnimationFrame(function () {
	            adopter.textContent = $basicStyleElement.get(sheet).textContent;
	            $appliedMethods
	                .get(sheet)
	                .forEach(function (command) {
	                return adopter.sheet[command.method].apply(adopter.sheet, command.args);
	            });
	        });
	    }
	    function checkInvocationCorrectness(self) {
	        if (!$basicStyleElement.has(self)) {
	            throw new TypeError('Illegal invocation');
	        }
	    }
	    function ConstructedStyleSheet() {
	        var self = this;
	        var style = document.createElement('style');
	        bootstrapper.body.appendChild(style);
	        $basicStyleElement.set(self, style);
	        $locations.set(self, []);
	        $adoptersByLocation.set(self, new WeakMap());
	        $appliedMethods.set(self, []);
	    }
	    var proto$1 = ConstructedStyleSheet.prototype;
	    proto$1.replace = function replace(contents) {
	        try {
	            this.replaceSync(contents);
	            return Promise.resolve(this);
	        }
	        catch (e) {
	            return Promise.reject(e);
	        }
	    };
	    proto$1.replaceSync = function replaceSync(contents) {
	        checkInvocationCorrectness(this);
	        if (typeof contents === 'string') {
	            var self_1 = this;
	            $basicStyleElement.get(self_1).textContent = rejectImports(contents);
	            $appliedMethods.set(self_1, []);
	            $locations.get(self_1).forEach(function (location) {
	                if (location.isConnected()) {
	                    restyleAdopter(self_1, getAdopterByLocation(self_1, location));
	                }
	            });
	        }
	    };
	    defineProperty(proto$1, 'cssRules', {
	        configurable: true,
	        enumerable: true,
	        get: function cssRules() {
	            checkInvocationCorrectness(this);
	            return $basicStyleElement.get(this).sheet.cssRules;
	        },
	    });
	    defineProperty(proto$1, 'media', {
	        configurable: true,
	        enumerable: true,
	        get: function media() {
	            checkInvocationCorrectness(this);
	            return $basicStyleElement.get(this).sheet.media;
	        },
	    });
	    cssStyleSheetMethods.forEach(function (method) {
	        proto$1[method] = function () {
	            var self = this;
	            checkInvocationCorrectness(self);
	            var args = arguments;
	            $appliedMethods.get(self).push({ method: method, args: args });
	            $locations.get(self).forEach(function (location) {
	                if (location.isConnected()) {
	                    var sheet = getAdopterByLocation(self, location).sheet;
	                    sheet[method].apply(sheet, args);
	                }
	            });
	            var basicSheet = $basicStyleElement.get(self).sheet;
	            return basicSheet[method].apply(basicSheet, args);
	        };
	    });
	    defineProperty(ConstructedStyleSheet, Symbol.hasInstance, {
	        configurable: true,
	        value: isCSSStyleSheetInstance,
	    });

	    var defaultObserverOptions = {
	        childList: true,
	        subtree: true,
	    };
	    var locations = new WeakMap();
	    function getAssociatedLocation(element) {
	        var location = locations.get(element);
	        if (!location) {
	            location = new Location(element);
	            locations.set(element, location);
	        }
	        return location;
	    }
	    function attachAdoptedStyleSheetProperty(constructor) {
	        defineProperty(constructor.prototype, 'adoptedStyleSheets', {
	            configurable: true,
	            enumerable: true,
	            get: function () {
	                return getAssociatedLocation(this).sheets;
	            },
	            set: function (sheets) {
	                getAssociatedLocation(this).update(sheets);
	            },
	        });
	    }
	    function traverseWebComponents(node, callback) {
	        var iter = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT, function (foundNode) {
	            return getShadowRoot(foundNode)
	                ? NodeFilter.FILTER_ACCEPT
	                : NodeFilter.FILTER_REJECT;
	        },
	        null, false);
	        for (var next = void 0; (next = iter.nextNode());) {
	            callback(getShadowRoot(next));
	        }
	    }
	    var $element = new WeakMap();
	    var $uniqueSheets = new WeakMap();
	    var $observer = new WeakMap();
	    function isExistingAdopter(self, element) {
	        return (element instanceof HTMLStyleElement &&
	            $uniqueSheets.get(self).some(function (sheet) { return getAdopterByLocation(sheet, self); }));
	    }
	    function getAdopterContainer(self) {
	        var element = $element.get(self);
	        return element instanceof Document ? element.body : element;
	    }
	    function adopt(self) {
	        var styleList = document.createDocumentFragment();
	        var sheets = $uniqueSheets.get(self);
	        var observer = $observer.get(self);
	        var container = getAdopterContainer(self);
	        observer.disconnect();
	        sheets.forEach(function (sheet) {
	            styleList.appendChild(getAdopterByLocation(sheet, self) || addAdopterLocation(sheet, self));
	        });
	        container.insertBefore(styleList, null);
	        observer.observe(container, defaultObserverOptions);
	        sheets.forEach(function (sheet) {
	            restyleAdopter(sheet, getAdopterByLocation(sheet, self));
	        });
	    }
	    function Location(element) {
	        var self = this;
	        self.sheets = [];
	        $element.set(self, element);
	        $uniqueSheets.set(self, []);
	        $observer.set(self, new MutationObserver(function (mutations, observer) {
	            if (typeof document === 'undefined' || !document) {
	                observer.disconnect();
	                return;
	            }
	            mutations.forEach(function (mutation) {
	                if (!hasShadyCss) {
	                    forEach.call(mutation.addedNodes, function (node) {
	                        if (!(node instanceof Element)) {
	                            return;
	                        }
	                        traverseWebComponents(node, function (root) {
	                            getAssociatedLocation(root).connect();
	                        });
	                    });
	                }
	                forEach.call(mutation.removedNodes, function (node) {
	                    if (!(node instanceof Element)) {
	                        return;
	                    }
	                    if (isExistingAdopter(self, node)) {
	                        adopt(self);
	                    }
	                    if (!hasShadyCss) {
	                        traverseWebComponents(node, function (root) {
	                            getAssociatedLocation(root).disconnect();
	                        });
	                    }
	                });
	            });
	        }));
	    }
	    Location.prototype = {
	        isConnected: function () {
	            var element = $element.get(this);
	            return element instanceof Document
	                ? element.readyState !== 'loading'
	                : isElementConnected(element.host);
	        },
	        connect: function () {
	            var container = getAdopterContainer(this);
	            $observer.get(this).observe(container, defaultObserverOptions);
	            if ($uniqueSheets.get(this).length > 0) {
	                adopt(this);
	            }
	            traverseWebComponents(container, function (root) {
	                getAssociatedLocation(root).connect();
	            });
	        },
	        disconnect: function () {
	            $observer.get(this).disconnect();
	        },
	        update: function (sheets) {
	            var self = this;
	            var locationType = $element.get(self) === document ? 'Document' : 'ShadowRoot';
	            if (!Array.isArray(sheets)) {
	                throw new TypeError("Failed to set the 'adoptedStyleSheets' property on " + locationType + ": Iterator getter is not callable.");
	            }
	            if (!sheets.every(isCSSStyleSheetInstance)) {
	                throw new TypeError("Failed to set the 'adoptedStyleSheets' property on " + locationType + ": Failed to convert value to 'CSSStyleSheet'");
	            }
	            if (sheets.some(isNonConstructedStyleSheetInstance)) {
	                throw new TypeError("Failed to set the 'adoptedStyleSheets' property on " + locationType + ": Can't adopt non-constructed stylesheets");
	            }
	            self.sheets = sheets;
	            var oldUniqueSheets = $uniqueSheets.get(self);
	            var uniqueSheets = unique(sheets);
	            var removedSheets = diff(oldUniqueSheets, uniqueSheets);
	            removedSheets.forEach(function (sheet) {
	                removeNode(getAdopterByLocation(sheet, self));
	                removeAdopterLocation(sheet, self);
	            });
	            $uniqueSheets.set(self, uniqueSheets);
	            if (self.isConnected() && uniqueSheets.length > 0) {
	                adopt(self);
	            }
	        },
	    };

	    window.CSSStyleSheet = ConstructedStyleSheet;
	    attachAdoptedStyleSheetProperty(Document);
	    if ('ShadowRoot' in window) {
	        attachAdoptedStyleSheetProperty(ShadowRoot);
	        var proto = Element.prototype;
	        var attach_1 = proto.attachShadow;
	        proto.attachShadow = function attachShadow(init) {
	            var root = attach_1.call(this, init);
	            if (init.mode === 'closed') {
	                closedShadowRootRegistry.set(this, root);
	            }
	            return root;
	        };
	    }
	    var documentLocation = getAssociatedLocation(document);
	    if (documentLocation.isConnected()) {
	        documentLocation.connect();
	    }
	    else {
	        document.addEventListener('DOMContentLoaded', documentLocation.connect.bind(documentLocation));
	    }

	}());
	return adoptedStyleSheets;
}

var intersectionObserver = {};

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.
 *
 *  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 *
 */

var hasRequiredIntersectionObserver;

function requireIntersectionObserver () {
	if (hasRequiredIntersectionObserver) return intersectionObserver;
	hasRequiredIntersectionObserver = 1;
	(function() {

	// Exit early if we're not running in a browser.
	if (typeof window !== 'object') {
	  return;
	}

	// Exit early if all IntersectionObserver and IntersectionObserverEntry
	// features are natively supported.
	if ('IntersectionObserver' in window &&
	    'IntersectionObserverEntry' in window &&
	    'intersectionRatio' in window.IntersectionObserverEntry.prototype) {

	  // Minimal polyfill for Edge 15's lack of `isIntersecting`
	  // See: https://github.com/w3c/IntersectionObserver/issues/211
	  if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {
	    Object.defineProperty(window.IntersectionObserverEntry.prototype,
	      'isIntersecting', {
	      get: function () {
	        return this.intersectionRatio > 0;
	      }
	    });
	  }
	  return;
	}

	/**
	 * Returns the embedding frame element, if any.
	 * @param {!Document} doc
	 * @return {!Element}
	 */
	function getFrameElement(doc) {
	  try {
	    return doc.defaultView && doc.defaultView.frameElement || null;
	  } catch (e) {
	    // Ignore the error.
	    return null;
	  }
	}

	/**
	 * A local reference to the root document.
	 */
	var document = (function(startDoc) {
	  var doc = startDoc;
	  var frame = getFrameElement(doc);
	  while (frame) {
	    doc = frame.ownerDocument;
	    frame = getFrameElement(doc);
	  }
	  return doc;
	})(window.document);

	/**
	 * An IntersectionObserver registry. This registry exists to hold a strong
	 * reference to IntersectionObserver instances currently observing a target
	 * element. Without this registry, instances without another reference may be
	 * garbage collected.
	 */
	var registry = [];

	/**
	 * The signal updater for cross-origin intersection. When not null, it means
	 * that the polyfill is configured to work in a cross-origin mode.
	 * @type {function(DOMRect|ClientRect, DOMRect|ClientRect)}
	 */
	var crossOriginUpdater = null;

	/**
	 * The current cross-origin intersection. Only used in the cross-origin mode.
	 * @type {DOMRect|ClientRect}
	 */
	var crossOriginRect = null;


	/**
	 * Creates the global IntersectionObserverEntry constructor.
	 * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry
	 * @param {Object} entry A dictionary of instance properties.
	 * @constructor
	 */
	function IntersectionObserverEntry(entry) {
	  this.time = entry.time;
	  this.target = entry.target;
	  this.rootBounds = ensureDOMRect(entry.rootBounds);
	  this.boundingClientRect = ensureDOMRect(entry.boundingClientRect);
	  this.intersectionRect = ensureDOMRect(entry.intersectionRect || getEmptyRect());
	  this.isIntersecting = !!entry.intersectionRect;

	  // Calculates the intersection ratio.
	  var targetRect = this.boundingClientRect;
	  var targetArea = targetRect.width * targetRect.height;
	  var intersectionRect = this.intersectionRect;
	  var intersectionArea = intersectionRect.width * intersectionRect.height;

	  // Sets intersection ratio.
	  if (targetArea) {
	    // Round the intersection ratio to avoid floating point math issues:
	    // https://github.com/w3c/IntersectionObserver/issues/324
	    this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4));
	  } else {
	    // If area is zero and is intersecting, sets to 1, otherwise to 0
	    this.intersectionRatio = this.isIntersecting ? 1 : 0;
	  }
	}


	/**
	 * Creates the global IntersectionObserver constructor.
	 * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface
	 * @param {Function} callback The function to be invoked after intersection
	 *     changes have queued. The function is not invoked if the queue has
	 *     been emptied by calling the `takeRecords` method.
	 * @param {Object=} opt_options Optional configuration options.
	 * @constructor
	 */
	function IntersectionObserver(callback, opt_options) {

	  var options = opt_options || {};

	  if (typeof callback != 'function') {
	    throw new Error('callback must be a function');
	  }

	  if (
	    options.root &&
	    options.root.nodeType != 1 &&
	    options.root.nodeType != 9
	  ) {
	    throw new Error('root must be a Document or Element');
	  }

	  // Binds and throttles `this._checkForIntersections`.
	  this._checkForIntersections = throttle(
	      this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);

	  // Private properties.
	  this._callback = callback;
	  this._observationTargets = [];
	  this._queuedEntries = [];
	  this._rootMarginValues = this._parseRootMargin(options.rootMargin);

	  // Public properties.
	  this.thresholds = this._initThresholds(options.threshold);
	  this.root = options.root || null;
	  this.rootMargin = this._rootMarginValues.map(function(margin) {
	    return margin.value + margin.unit;
	  }).join(' ');

	  /** @private @const {!Array<!Document>} */
	  this._monitoringDocuments = [];
	  /** @private @const {!Array<function()>} */
	  this._monitoringUnsubscribes = [];
	}


	/**
	 * The minimum interval within which the document will be checked for
	 * intersection changes.
	 */
	IntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;


	/**
	 * The frequency in which the polyfill polls for intersection changes.
	 * this can be updated on a per instance basis and must be set prior to
	 * calling `observe` on the first target.
	 */
	IntersectionObserver.prototype.POLL_INTERVAL = null;

	/**
	 * Use a mutation observer on the root element
	 * to detect intersection changes.
	 */
	IntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;


	/**
	 * Sets up the polyfill in the cross-origin mode. The result is the
	 * updater function that accepts two arguments: `boundingClientRect` and
	 * `intersectionRect` - just as these fields would be available to the
	 * parent via `IntersectionObserverEntry`. This function should be called
	 * each time the iframe receives intersection information from the parent
	 * window, e.g. via messaging.
	 * @return {function(DOMRect|ClientRect, DOMRect|ClientRect)}
	 */
	IntersectionObserver._setupCrossOriginUpdater = function() {
	  if (!crossOriginUpdater) {
	    /**
	     * @param {DOMRect|ClientRect} boundingClientRect
	     * @param {DOMRect|ClientRect} intersectionRect
	     */
	    crossOriginUpdater = function(boundingClientRect, intersectionRect) {
	      if (!boundingClientRect || !intersectionRect) {
	        crossOriginRect = getEmptyRect();
	      } else {
	        crossOriginRect = convertFromParentRect(boundingClientRect, intersectionRect);
	      }
	      registry.forEach(function(observer) {
	        observer._checkForIntersections();
	      });
	    };
	  }
	  return crossOriginUpdater;
	};


	/**
	 * Resets the cross-origin mode.
	 */
	IntersectionObserver._resetCrossOriginUpdater = function() {
	  crossOriginUpdater = null;
	  crossOriginRect = null;
	};


	/**
	 * Starts observing a target element for intersection changes based on
	 * the thresholds values.
	 * @param {Element} target The DOM element to observe.
	 */
	IntersectionObserver.prototype.observe = function(target) {
	  var isTargetAlreadyObserved = this._observationTargets.some(function(item) {
	    return item.element == target;
	  });

	  if (isTargetAlreadyObserved) {
	    return;
	  }

	  if (!(target && target.nodeType == 1)) {
	    throw new Error('target must be an Element');
	  }

	  this._registerInstance();
	  this._observationTargets.push({element: target, entry: null});
	  this._monitorIntersections(target.ownerDocument);
	  this._checkForIntersections();
	};


	/**
	 * Stops observing a target element for intersection changes.
	 * @param {Element} target The DOM element to observe.
	 */
	IntersectionObserver.prototype.unobserve = function(target) {
	  this._observationTargets =
	      this._observationTargets.filter(function(item) {
	        return item.element != target;
	      });
	  this._unmonitorIntersections(target.ownerDocument);
	  if (this._observationTargets.length == 0) {
	    this._unregisterInstance();
	  }
	};


	/**
	 * Stops observing all target elements for intersection changes.
	 */
	IntersectionObserver.prototype.disconnect = function() {
	  this._observationTargets = [];
	  this._unmonitorAllIntersections();
	  this._unregisterInstance();
	};


	/**
	 * Returns any queue entries that have not yet been reported to the
	 * callback and clears the queue. This can be used in conjunction with the
	 * callback to obtain the absolute most up-to-date intersection information.
	 * @return {Array} The currently queued entries.
	 */
	IntersectionObserver.prototype.takeRecords = function() {
	  var records = this._queuedEntries.slice();
	  this._queuedEntries = [];
	  return records;
	};


	/**
	 * Accepts the threshold value from the user configuration object and
	 * returns a sorted array of unique threshold values. If a value is not
	 * between 0 and 1 and error is thrown.
	 * @private
	 * @param {Array|number=} opt_threshold An optional threshold value or
	 *     a list of threshold values, defaulting to [0].
	 * @return {Array} A sorted list of unique and valid threshold values.
	 */
	IntersectionObserver.prototype._initThresholds = function(opt_threshold) {
	  var threshold = opt_threshold || [0];
	  if (!Array.isArray(threshold)) threshold = [threshold];

	  return threshold.sort().filter(function(t, i, a) {
	    if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {
	      throw new Error('threshold must be a number between 0 and 1 inclusively');
	    }
	    return t !== a[i - 1];
	  });
	};


	/**
	 * Accepts the rootMargin value from the user configuration object
	 * and returns an array of the four margin values as an object containing
	 * the value and unit properties. If any of the values are not properly
	 * formatted or use a unit other than px or %, and error is thrown.
	 * @private
	 * @param {string=} opt_rootMargin An optional rootMargin value,
	 *     defaulting to '0px'.
	 * @return {Array<Object>} An array of margin objects with the keys
	 *     value and unit.
	 */
	IntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {
	  var marginString = opt_rootMargin || '0px';
	  var margins = marginString.split(/\s+/).map(function(margin) {
	    var parts = /^(-?\d*\.?\d+)(px|%)$/.exec(margin);
	    if (!parts) {
	      throw new Error('rootMargin must be specified in pixels or percent');
	    }
	    return {value: parseFloat(parts[1]), unit: parts[2]};
	  });

	  // Handles shorthand.
	  margins[1] = margins[1] || margins[0];
	  margins[2] = margins[2] || margins[0];
	  margins[3] = margins[3] || margins[1];

	  return margins;
	};


	/**
	 * Starts polling for intersection changes if the polling is not already
	 * happening, and if the page's visibility state is visible.
	 * @param {!Document} doc
	 * @private
	 */
	IntersectionObserver.prototype._monitorIntersections = function(doc) {
	  var win = doc.defaultView;
	  if (!win) {
	    // Already destroyed.
	    return;
	  }
	  if (this._monitoringDocuments.indexOf(doc) != -1) {
	    // Already monitoring.
	    return;
	  }

	  // Private state for monitoring.
	  var callback = this._checkForIntersections;
	  var monitoringInterval = null;
	  var domObserver = null;

	  // If a poll interval is set, use polling instead of listening to
	  // resize and scroll events or DOM mutations.
	  if (this.POLL_INTERVAL) {
	    monitoringInterval = win.setInterval(callback, this.POLL_INTERVAL);
	  } else {
	    addEvent(win, 'resize', callback, true);
	    addEvent(doc, 'scroll', callback, true);
	    if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in win) {
	      domObserver = new win.MutationObserver(callback);
	      domObserver.observe(doc, {
	        attributes: true,
	        childList: true,
	        characterData: true,
	        subtree: true
	      });
	    }
	  }

	  this._monitoringDocuments.push(doc);
	  this._monitoringUnsubscribes.push(function() {
	    // Get the window object again. When a friendly iframe is destroyed, it
	    // will be null.
	    var win = doc.defaultView;

	    if (win) {
	      if (monitoringInterval) {
	        win.clearInterval(monitoringInterval);
	      }
	      removeEvent(win, 'resize', callback, true);
	    }

	    removeEvent(doc, 'scroll', callback, true);
	    if (domObserver) {
	      domObserver.disconnect();
	    }
	  });

	  // Also monitor the parent.
	  var rootDoc =
	    (this.root && (this.root.ownerDocument || this.root)) || document;
	  if (doc != rootDoc) {
	    var frame = getFrameElement(doc);
	    if (frame) {
	      this._monitorIntersections(frame.ownerDocument);
	    }
	  }
	};


	/**
	 * Stops polling for intersection changes.
	 * @param {!Document} doc
	 * @private
	 */
	IntersectionObserver.prototype._unmonitorIntersections = function(doc) {
	  var index = this._monitoringDocuments.indexOf(doc);
	  if (index == -1) {
	    return;
	  }

	  var rootDoc =
	    (this.root && (this.root.ownerDocument || this.root)) || document;

	  // Check if any dependent targets are still remaining.
	  var hasDependentTargets =
	      this._observationTargets.some(function(item) {
	        var itemDoc = item.element.ownerDocument;
	        // Target is in this context.
	        if (itemDoc == doc) {
	          return true;
	        }
	        // Target is nested in this context.
	        while (itemDoc && itemDoc != rootDoc) {
	          var frame = getFrameElement(itemDoc);
	          itemDoc = frame && frame.ownerDocument;
	          if (itemDoc == doc) {
	            return true;
	          }
	        }
	        return false;
	      });
	  if (hasDependentTargets) {
	    return;
	  }

	  // Unsubscribe.
	  var unsubscribe = this._monitoringUnsubscribes[index];
	  this._monitoringDocuments.splice(index, 1);
	  this._monitoringUnsubscribes.splice(index, 1);
	  unsubscribe();

	  // Also unmonitor the parent.
	  if (doc != rootDoc) {
	    var frame = getFrameElement(doc);
	    if (frame) {
	      this._unmonitorIntersections(frame.ownerDocument);
	    }
	  }
	};


	/**
	 * Stops polling for intersection changes.
	 * @param {!Document} doc
	 * @private
	 */
	IntersectionObserver.prototype._unmonitorAllIntersections = function() {
	  var unsubscribes = this._monitoringUnsubscribes.slice(0);
	  this._monitoringDocuments.length = 0;
	  this._monitoringUnsubscribes.length = 0;
	  for (var i = 0; i < unsubscribes.length; i++) {
	    unsubscribes[i]();
	  }
	};


	/**
	 * Scans each observation target for intersection changes and adds them
	 * to the internal entries queue. If new entries are found, it
	 * schedules the callback to be invoked.
	 * @private
	 */
	IntersectionObserver.prototype._checkForIntersections = function() {
	  if (!this.root && crossOriginUpdater && !crossOriginRect) {
	    // Cross origin monitoring, but no initial data available yet.
	    return;
	  }

	  var rootIsInDom = this._rootIsInDom();
	  var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();

	  this._observationTargets.forEach(function(item) {
	    var target = item.element;
	    var targetRect = getBoundingClientRect(target);
	    var rootContainsTarget = this._rootContainsTarget(target);
	    var oldEntry = item.entry;
	    var intersectionRect = rootIsInDom && rootContainsTarget &&
	        this._computeTargetAndRootIntersection(target, targetRect, rootRect);

	    var rootBounds = null;
	    if (!this._rootContainsTarget(target)) {
	      rootBounds = getEmptyRect();
	    } else if (!crossOriginUpdater || this.root) {
	      rootBounds = rootRect;
	    }

	    var newEntry = item.entry = new IntersectionObserverEntry({
	      time: now(),
	      target: target,
	      boundingClientRect: targetRect,
	      rootBounds: rootBounds,
	      intersectionRect: intersectionRect
	    });

	    if (!oldEntry) {
	      this._queuedEntries.push(newEntry);
	    } else if (rootIsInDom && rootContainsTarget) {
	      // If the new entry intersection ratio has crossed any of the
	      // thresholds, add a new entry.
	      if (this._hasCrossedThreshold(oldEntry, newEntry)) {
	        this._queuedEntries.push(newEntry);
	      }
	    } else {
	      // If the root is not in the DOM or target is not contained within
	      // root but the previous entry for this target had an intersection,
	      // add a new record indicating removal.
	      if (oldEntry && oldEntry.isIntersecting) {
	        this._queuedEntries.push(newEntry);
	      }
	    }
	  }, this);

	  if (this._queuedEntries.length) {
	    this._callback(this.takeRecords(), this);
	  }
	};


	/**
	 * Accepts a target and root rect computes the intersection between then
	 * following the algorithm in the spec.
	 * TODO(philipwalton): at this time clip-path is not considered.
	 * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo
	 * @param {Element} target The target DOM element
	 * @param {Object} targetRect The bounding rect of the target.
	 * @param {Object} rootRect The bounding rect of the root after being
	 *     expanded by the rootMargin value.
	 * @return {?Object} The final intersection rect object or undefined if no
	 *     intersection is found.
	 * @private
	 */
	IntersectionObserver.prototype._computeTargetAndRootIntersection =
	    function(target, targetRect, rootRect) {
	  // If the element isn't displayed, an intersection can't happen.
	  if (window.getComputedStyle(target).display == 'none') return;

	  var intersectionRect = targetRect;
	  var parent = getParentNode(target);
	  var atRoot = false;

	  while (!atRoot && parent) {
	    var parentRect = null;
	    var parentComputedStyle = parent.nodeType == 1 ?
	        window.getComputedStyle(parent) : {};

	    // If the parent isn't displayed, an intersection can't happen.
	    if (parentComputedStyle.display == 'none') return null;

	    if (parent == this.root || parent.nodeType == /* DOCUMENT */ 9) {
	      atRoot = true;
	      if (parent == this.root || parent == document) {
	        if (crossOriginUpdater && !this.root) {
	          if (!crossOriginRect ||
	              crossOriginRect.width == 0 && crossOriginRect.height == 0) {
	            // A 0-size cross-origin intersection means no-intersection.
	            parent = null;
	            parentRect = null;
	            intersectionRect = null;
	          } else {
	            parentRect = crossOriginRect;
	          }
	        } else {
	          parentRect = rootRect;
	        }
	      } else {
	        // Check if there's a frame that can be navigated to.
	        var frame = getParentNode(parent);
	        var frameRect = frame && getBoundingClientRect(frame);
	        var frameIntersect =
	            frame &&
	            this._computeTargetAndRootIntersection(frame, frameRect, rootRect);
	        if (frameRect && frameIntersect) {
	          parent = frame;
	          parentRect = convertFromParentRect(frameRect, frameIntersect);
	        } else {
	          parent = null;
	          intersectionRect = null;
	        }
	      }
	    } else {
	      // If the element has a non-visible overflow, and it's not the <body>
	      // or <html> element, update the intersection rect.
	      // Note: <body> and <html> cannot be clipped to a rect that's not also
	      // the document rect, so no need to compute a new intersection.
	      var doc = parent.ownerDocument;
	      if (parent != doc.body &&
	          parent != doc.documentElement &&
	          parentComputedStyle.overflow != 'visible') {
	        parentRect = getBoundingClientRect(parent);
	      }
	    }

	    // If either of the above conditionals set a new parentRect,
	    // calculate new intersection data.
	    if (parentRect) {
	      intersectionRect = computeRectIntersection(parentRect, intersectionRect);
	    }
	    if (!intersectionRect) break;
	    parent = parent && getParentNode(parent);
	  }
	  return intersectionRect;
	};


	/**
	 * Returns the root rect after being expanded by the rootMargin value.
	 * @return {ClientRect} The expanded root rect.
	 * @private
	 */
	IntersectionObserver.prototype._getRootRect = function() {
	  var rootRect;
	  if (this.root && !isDoc(this.root)) {
	    rootRect = getBoundingClientRect(this.root);
	  } else {
	    // Use <html>/<body> instead of window since scroll bars affect size.
	    var doc = isDoc(this.root) ? this.root : document;
	    var html = doc.documentElement;
	    var body = doc.body;
	    rootRect = {
	      top: 0,
	      left: 0,
	      right: html.clientWidth || body.clientWidth,
	      width: html.clientWidth || body.clientWidth,
	      bottom: html.clientHeight || body.clientHeight,
	      height: html.clientHeight || body.clientHeight
	    };
	  }
	  return this._expandRectByRootMargin(rootRect);
	};


	/**
	 * Accepts a rect and expands it by the rootMargin value.
	 * @param {DOMRect|ClientRect} rect The rect object to expand.
	 * @return {ClientRect} The expanded rect.
	 * @private
	 */
	IntersectionObserver.prototype._expandRectByRootMargin = function(rect) {
	  var margins = this._rootMarginValues.map(function(margin, i) {
	    return margin.unit == 'px' ? margin.value :
	        margin.value * (i % 2 ? rect.width : rect.height) / 100;
	  });
	  var newRect = {
	    top: rect.top - margins[0],
	    right: rect.right + margins[1],
	    bottom: rect.bottom + margins[2],
	    left: rect.left - margins[3]
	  };
	  newRect.width = newRect.right - newRect.left;
	  newRect.height = newRect.bottom - newRect.top;

	  return newRect;
	};


	/**
	 * Accepts an old and new entry and returns true if at least one of the
	 * threshold values has been crossed.
	 * @param {?IntersectionObserverEntry} oldEntry The previous entry for a
	 *    particular target element or null if no previous entry exists.
	 * @param {IntersectionObserverEntry} newEntry The current entry for a
	 *    particular target element.
	 * @return {boolean} Returns true if a any threshold has been crossed.
	 * @private
	 */
	IntersectionObserver.prototype._hasCrossedThreshold =
	    function(oldEntry, newEntry) {

	  // To make comparing easier, an entry that has a ratio of 0
	  // but does not actually intersect is given a value of -1
	  var oldRatio = oldEntry && oldEntry.isIntersecting ?
	      oldEntry.intersectionRatio || 0 : -1;
	  var newRatio = newEntry.isIntersecting ?
	      newEntry.intersectionRatio || 0 : -1;

	  // Ignore unchanged ratios
	  if (oldRatio === newRatio) return;

	  for (var i = 0; i < this.thresholds.length; i++) {
	    var threshold = this.thresholds[i];

	    // Return true if an entry matches a threshold or if the new ratio
	    // and the old ratio are on the opposite sides of a threshold.
	    if (threshold == oldRatio || threshold == newRatio ||
	        threshold < oldRatio !== threshold < newRatio) {
	      return true;
	    }
	  }
	};


	/**
	 * Returns whether or not the root element is an element and is in the DOM.
	 * @return {boolean} True if the root element is an element and is in the DOM.
	 * @private
	 */
	IntersectionObserver.prototype._rootIsInDom = function() {
	  return !this.root || containsDeep(document, this.root);
	};


	/**
	 * Returns whether or not the target element is a child of root.
	 * @param {Element} target The target element to check.
	 * @return {boolean} True if the target element is a child of root.
	 * @private
	 */
	IntersectionObserver.prototype._rootContainsTarget = function(target) {
	  var rootDoc =
	    (this.root && (this.root.ownerDocument || this.root)) || document;
	  return (
	    containsDeep(rootDoc, target) &&
	    (!this.root || rootDoc == target.ownerDocument)
	  );
	};


	/**
	 * Adds the instance to the global IntersectionObserver registry if it isn't
	 * already present.
	 * @private
	 */
	IntersectionObserver.prototype._registerInstance = function() {
	  if (registry.indexOf(this) < 0) {
	    registry.push(this);
	  }
	};


	/**
	 * Removes the instance from the global IntersectionObserver registry.
	 * @private
	 */
	IntersectionObserver.prototype._unregisterInstance = function() {
	  var index = registry.indexOf(this);
	  if (index != -1) registry.splice(index, 1);
	};


	/**
	 * Returns the result of the performance.now() method or null in browsers
	 * that don't support the API.
	 * @return {number} The elapsed time since the page was requested.
	 */
	function now() {
	  if (typeof window !== 'undefined') {return window.performance && performance.now && performance.now();}
	}


	/**
	 * Throttles a function and delays its execution, so it's only called at most
	 * once within a given time period.
	 * @param {Function} fn The function to throttle.
	 * @param {number} timeout The amount of time that must pass before the
	 *     function can be called again.
	 * @return {Function} The throttled function.
	 */
	function throttle(fn, timeout) {
	  var timer = null;
	  return function () {
	    if (!timer) {
	      timer = setTimeout(function() {
	        fn();
	        timer = null;
	      }, timeout);
	    }
	  };
	}


	/**
	 * Adds an event handler to a DOM node ensuring cross-browser compatibility.
	 * @param {Node} node The DOM node to add the event handler to.
	 * @param {string} event The event name.
	 * @param {Function} fn The event handler to add.
	 * @param {boolean} opt_useCapture Optionally adds the even to the capture
	 *     phase. Note: this only works in modern browsers.
	 */
	function addEvent(node, event, fn, opt_useCapture) {
	  if (typeof node.addEventListener == 'function') {
	    node.addEventListener(event, fn, opt_useCapture);
	  }
	  else if (typeof node.attachEvent == 'function') {
	    node.attachEvent('on' + event, fn);
	  }
	}


	/**
	 * Removes a previously added event handler from a DOM node.
	 * @param {Node} node The DOM node to remove the event handler from.
	 * @param {string} event The event name.
	 * @param {Function} fn The event handler to remove.
	 * @param {boolean} opt_useCapture If the event handler was added with this
	 *     flag set to true, it should be set to true here in order to remove it.
	 */
	function removeEvent(node, event, fn, opt_useCapture) {
	  if (typeof node.removeEventListener == 'function') {
	    node.removeEventListener(event, fn, opt_useCapture);
	  }
	  else if (typeof node.detachEvent == 'function') {
	    node.detachEvent('on' + event, fn);
	  }
	}


	/**
	 * Returns the intersection between two rect objects.
	 * @param {Object} rect1 The first rect.
	 * @param {Object} rect2 The second rect.
	 * @return {?Object|?ClientRect} The intersection rect or undefined if no
	 *     intersection is found.
	 */
	function computeRectIntersection(rect1, rect2) {
	  var top = Math.max(rect1.top, rect2.top);
	  var bottom = Math.min(rect1.bottom, rect2.bottom);
	  var left = Math.max(rect1.left, rect2.left);
	  var right = Math.min(rect1.right, rect2.right);
	  var width = right - left;
	  var height = bottom - top;

	  return (width >= 0 && height >= 0) && {
	    top: top,
	    bottom: bottom,
	    left: left,
	    right: right,
	    width: width,
	    height: height
	  } || null;
	}


	/**
	 * Shims the native getBoundingClientRect for compatibility with older IE.
	 * @param {Element} el The element whose bounding rect to get.
	 * @return {DOMRect|ClientRect} The (possibly shimmed) rect of the element.
	 */
	function getBoundingClientRect(el) {
	  var rect;

	  try {
	    rect = el.getBoundingClientRect();
	  } catch (err) {
	    // Ignore Windows 7 IE11 "Unspecified error"
	    // https://github.com/w3c/IntersectionObserver/pull/205
	  }

	  if (!rect) return getEmptyRect();

	  // Older IE
	  if (!(rect.width && rect.height)) {
	    rect = {
	      top: rect.top,
	      right: rect.right,
	      bottom: rect.bottom,
	      left: rect.left,
	      width: rect.right - rect.left,
	      height: rect.bottom - rect.top
	    };
	  }
	  return rect;
	}


	/**
	 * Returns an empty rect object. An empty rect is returned when an element
	 * is not in the DOM.
	 * @return {ClientRect} The empty rect.
	 */
	function getEmptyRect() {
	  return {
	    top: 0,
	    bottom: 0,
	    left: 0,
	    right: 0,
	    width: 0,
	    height: 0
	  };
	}


	/**
	 * Ensure that the result has all of the necessary fields of the DOMRect.
	 * Specifically this ensures that `x` and `y` fields are set.
	 *
	 * @param {?DOMRect|?ClientRect} rect
	 * @return {?DOMRect}
	 */
	function ensureDOMRect(rect) {
	  // A `DOMRect` object has `x` and `y` fields.
	  if (!rect || 'x' in rect) {
	    return rect;
	  }
	  // A IE's `ClientRect` type does not have `x` and `y`. The same is the case
	  // for internally calculated Rect objects. For the purposes of
	  // `IntersectionObserver`, it's sufficient to simply mirror `left` and `top`
	  // for these fields.
	  return {
	    top: rect.top,
	    y: rect.top,
	    bottom: rect.bottom,
	    left: rect.left,
	    x: rect.left,
	    right: rect.right,
	    width: rect.width,
	    height: rect.height
	  };
	}


	/**
	 * Inverts the intersection and bounding rect from the parent (frame) BCR to
	 * the local BCR space.
	 * @param {DOMRect|ClientRect} parentBoundingRect The parent's bound client rect.
	 * @param {DOMRect|ClientRect} parentIntersectionRect The parent's own intersection rect.
	 * @return {ClientRect} The local root bounding rect for the parent's children.
	 */
	function convertFromParentRect(parentBoundingRect, parentIntersectionRect) {
	  var top = parentIntersectionRect.top - parentBoundingRect.top;
	  var left = parentIntersectionRect.left - parentBoundingRect.left;
	  return {
	    top: top,
	    left: left,
	    height: parentIntersectionRect.height,
	    width: parentIntersectionRect.width,
	    bottom: top + parentIntersectionRect.height,
	    right: left + parentIntersectionRect.width
	  };
	}


	/**
	 * Checks to see if a parent element contains a child element (including inside
	 * shadow DOM).
	 * @param {Node} parent The parent element.
	 * @param {Node} child The child element.
	 * @return {boolean} True if the parent node contains the child node.
	 */
	function containsDeep(parent, child) {
	  var node = child;
	  while (node) {
	    if (node == parent) return true;

	    node = getParentNode(node);
	  }
	  return false;
	}


	/**
	 * Gets the parent node of an element or its host element if the parent node
	 * is a shadow root.
	 * @param {Node} node The node whose parent to get.
	 * @return {Node|null} The parent node or null if no parent exists.
	 */
	function getParentNode(node) {
	  var parent = node.parentNode;

	  if (node.nodeType == /* DOCUMENT */ 9 && node != document) {
	    // If this node is a document node, look for the embedding frame.
	    return getFrameElement(node);
	  }

	  // If the parent has element that is assigned through shadow root slot
	  if (parent && parent.assignedSlot) {
	    parent = parent.assignedSlot.parentNode;
	  }

	  if (parent && parent.nodeType == 11 && parent.host) {
	    // If the parent is a shadow root, return the host element.
	    return parent.host;
	  }

	  return parent;
	}

	/**
	 * Returns true if `node` is a Document.
	 * @param {!Node} node
	 * @returns {boolean}
	 */
	function isDoc(node) {
	  return node && node.nodeType === 9;
	}


	// Exposes the constructors globally.
	window.IntersectionObserver = IntersectionObserver;
	window.IntersectionObserverEntry = IntersectionObserverEntry;

	}());
	return intersectionObserver;
}

var matchMedia$1 = {};

/*! matchMedia() polyfill - Test a CSS media type/query in JS. Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. MIT license */

var hasRequiredMatchMedia;

function requireMatchMedia () {
	if (hasRequiredMatchMedia) return matchMedia$1;
	hasRequiredMatchMedia = 1;
	window.matchMedia || (window.matchMedia = function() {

	    // For browsers that support matchMedium api such as IE 9 and webkit
	    var styleMedia = (window.styleMedia || window.media);

	    // For those that don't support matchMedium
	    if (!styleMedia) {
	        var style       = document.createElement('style'),
	            script      = document.getElementsByTagName('script')[0],
	            info        = null;

	        style.type  = 'text/css';
	        style.id    = 'matchmediajs-test';

	        if (!script) {
	          document.head.appendChild(style);
	        } else {
	          script.parentNode.insertBefore(style, script);
	        }

	        // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers
	        info = ('getComputedStyle' in window) && window.getComputedStyle(style, null) || style.currentStyle;

	        styleMedia = {
	            matchMedium: function(media) {
	                var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';

	                // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers
	                if (style.styleSheet) {
	                    style.styleSheet.cssText = text;
	                } else {
	                    style.textContent = text;
	                }

	                // Test if media query is true or false
	                return info.width === '1px';
	            }
	        };
	    }

	    return function(media) {
	        return {
	            matches: styleMedia.matchMedium(media || 'all'),
	            media: media || 'all'
	        };
	    };
	}());
	return matchMedia$1;
}

var matchMedia_addListener = {};

/*! matchMedia() polyfill addListener/removeListener extension. Author & copyright (c) 2012: Scott Jehl. MIT license */

var hasRequiredMatchMedia_addListener;

function requireMatchMedia_addListener () {
	if (hasRequiredMatchMedia_addListener) return matchMedia_addListener;
	hasRequiredMatchMedia_addListener = 1;
	(function(){
	    // Bail out for browsers that have addListener support
	    if (window.matchMedia && window.matchMedia('all').addListener) {
	        return false;
	    }

	    var localMatchMedia = window.matchMedia,
	        hasMediaQueries = localMatchMedia('only all').matches,
	        isListening     = false,
	        timeoutID       = 0,    // setTimeout for debouncing 'handleChange'
	        queries         = [],   // Contains each 'mql' and associated 'listeners' if 'addListener' is used
	        handleChange    = function(evt) {
	            // Debounce
	            clearTimeout(timeoutID);

	            timeoutID = setTimeout(function() {
	                for (var i = 0, il = queries.length; i < il; i++) {
	                    var mql         = queries[i].mql,
	                        listeners   = queries[i].listeners || [],
	                        matches     = localMatchMedia(mql.media).matches;

	                    // Update mql.matches value and call listeners
	                    // Fire listeners only if transitioning to or from matched state
	                    if (matches !== mql.matches) {
	                        mql.matches = matches;

	                        for (var j = 0, jl = listeners.length; j < jl; j++) {
	                            listeners[j].call(window, mql);
	                        }
	                    }
	                }
	            }, 30);
	        };

	    window.matchMedia = function(media) {
	        var mql         = localMatchMedia(media),
	            listeners   = [],
	            index       = 0;

	        mql.addListener = function(listener) {
	            // Changes would not occur to css media type so return now (Affects IE <= 8)
	            if (!hasMediaQueries) {
	                return;
	            }

	            // Set up 'resize' listener for browsers that support CSS3 media queries (Not for IE <= 8)
	            // There should only ever be 1 resize listener running for performance
	            if (!isListening) {
	                isListening = true;
	                window.addEventListener('resize', handleChange, true);
	            }

	            // Push object only if it has not been pushed already
	            if (index === 0) {
	                index = queries.push({
	                    mql         : mql,
	                    listeners   : listeners
	                });
	            }

	            listeners.push(listener);
	        };

	        mql.removeListener = function(listener) {
	            for (var i = 0, il = listeners.length; i < il; i++){
	                if (listeners[i] === listener){
	                    listeners.splice(i, 1);
	                }
	            }
	        };

	        return mql;
	    };
	}());
	return matchMedia_addListener;
}

var dist = {};

var hasRequiredDist;

function requireDist () {
	if (hasRequiredDist) return dist;
	hasRequiredDist = 1;
	(function () {

	    var UNSUPPORTED_ENVIRONMENT = typeof window === "undefined";

	    /**
	     * Is true if the browser natively supports the 'scroll-behavior' CSS-property.
	     * @type {boolean}
	     */
	    var SUPPORTS_SCROLL_BEHAVIOR = UNSUPPORTED_ENVIRONMENT ? false : "scrollBehavior" in document.documentElement.style;

	    

	    /*! *****************************************************************************
	    Copyright (c) Microsoft Corporation. All rights reserved.
	    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	    this file except in compliance with the License. You may obtain a copy of the
	    License at http://www.apache.org/licenses/LICENSE-2.0

	    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	    MERCHANTABLITY OR NON-INFRINGEMENT.

	    See the Apache Version 2.0 License for specific language governing permissions
	    and limitations under the License.
	    ***************************************************************************** */

	    var __assign = function() {
	        __assign = Object.assign || function __assign(t) {
	            for (var s, i = 1, n = arguments.length; i < n; i++) {
	                s = arguments[i];
	                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	            }
	            return t;
	        };
	        return __assign.apply(this, arguments);
	    };

	    function __read(o, n) {
	        var m = typeof Symbol === "function" && o[Symbol.iterator];
	        if (!m) return o;
	        var i = m.call(o), r, ar = [], e;
	        try {
	            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	        }
	        catch (error) { e = { error: error }; }
	        finally {
	            try {
	                if (r && !r.done && (m = i["return"])) m.call(i);
	            }
	            finally { if (e) throw e.error; }
	        }
	        return ar;
	    }

	    function getScrollingElement() {
	        if (document.scrollingElement != null) {
	            return document.scrollingElement;
	        }
	        else {
	            return document.documentElement;
	        }
	    }

	    var STYLE_ATTRIBUTE_PROPERTY_NAME = "scroll-behavior";
	    var STYLE_ATTRIBUTE_PROPERTY_REGEXP = new RegExp(STYLE_ATTRIBUTE_PROPERTY_NAME + ":\\s*([^;]*)");
	    /**
	     * Given an Element, this function appends the given ScrollBehavior CSS property value to the elements' 'style' attribute.
	     * If it doesnt already have one, it will add it.
	     * @param {Element} element
	     * @param {ScrollBehavior} behavior
	     */
	    function appendScrollBehaviorToStyleAttribute(element, behavior) {
	        var addition = STYLE_ATTRIBUTE_PROPERTY_NAME + ":" + behavior;
	        var attributeValue = element.getAttribute("style");
	        if (attributeValue == null || attributeValue === "") {
	            element.setAttribute("style", addition);
	            return;
	        }
	        // The style attribute may already include a 'scroll-behavior:<something>' in which case that should be replaced
	        var existingValueForProperty = parseScrollBehaviorFromStyleAttribute(element);
	        if (existingValueForProperty != null) {
	            var replacementProperty = STYLE_ATTRIBUTE_PROPERTY_NAME + ":" + existingValueForProperty;
	            // Replace the variant that ends with a semi-colon which it may
	            attributeValue = attributeValue.replace(replacementProperty + ";", "");
	            // Replace the variant that *doesn't* end with a semi-colon
	            attributeValue = attributeValue.replace(replacementProperty, "");
	        }
	        // Now, append the behavior to the string.
	        element.setAttribute("style", attributeValue.endsWith(";") ? "" + attributeValue + addition : ";" + attributeValue + addition);
	    }
	    /**
	     * Given an Element, this function attempts to parse its 'style' attribute (if it has one)' to extract
	     * a value for the 'scroll-behavior' CSS property (if it is given within that style attribute)
	     * @param {Element} element
	     * @returns {ScrollBehavior?}
	     */
	    function parseScrollBehaviorFromStyleAttribute(element) {
	        var styleAttributeValue = element.getAttribute("style");
	        if (styleAttributeValue != null && styleAttributeValue.includes(STYLE_ATTRIBUTE_PROPERTY_NAME)) {
	            var match = styleAttributeValue.match(STYLE_ATTRIBUTE_PROPERTY_REGEXP);
	            if (match != null) {
	                var _a = __read(match, 2), behavior = _a[1];
	                if (behavior != null && behavior !== "") {
	                    return behavior;
	                }
	            }
	        }
	        return undefined;
	    }

	    var styleDeclarationPropertyName = "scrollBehavior";
	    /**
	     * Determines the scroll behavior to use, depending on the given ScrollOptions and the position of the Element
	     * within the DOM
	     * @param {Element|HTMLElement|Window} inputTarget
	     * @param {ScrollOptions} [options]
	     * @returns {ScrollBehavior}
	     */
	    function getScrollBehavior(inputTarget, options) {
	        // If the given 'behavior' is 'smooth', apply smooth scrolling no matter what
	        if (options != null && options.behavior === "smooth")
	            return "smooth";
	        var target = "style" in inputTarget ? inputTarget : getScrollingElement();
	        var value;
	        if ("style" in target) {
	            // Check if scroll-behavior is set as a property on the CSSStyleDeclaration
	            var scrollBehaviorPropertyValue = target.style[styleDeclarationPropertyName];
	            // Return it if it is given and has a proper value
	            if (scrollBehaviorPropertyValue != null && scrollBehaviorPropertyValue !== "") {
	                value = scrollBehaviorPropertyValue;
	            }
	        }
	        if (value == null) {
	            var attributeValue = target.getAttribute("scroll-behavior");
	            if (attributeValue != null && attributeValue !== "") {
	                value = attributeValue;
	            }
	        }
	        if (value == null) {
	            // Otherwise, check if it is set as an inline style
	            value = parseScrollBehaviorFromStyleAttribute(target);
	        }
	        if (value == null) {
	            // Take the computed style for the element and see if it contains a specific 'scroll-behavior' value
	            var computedStyle = getComputedStyle(target);
	            var computedStyleValue = computedStyle.getPropertyValue("scrollBehavior");
	            if (computedStyleValue != null && computedStyleValue !== "") {
	                value = computedStyleValue;
	            }
	        }
	        // In all other cases, use the value from the CSSOM
	        return value;
	    }

	    

	    

	    var HALF = 0.5;
	    /**
	     * The easing function to use when applying the smooth scrolling
	     * @param {number} k
	     * @returns {number}
	     */
	    function ease(k) {
	        return HALF * (1 - Math.cos(Math.PI * k));
	    }

	    var NOOP = {
	        reset: function () { }
	    };
	    var map = typeof WeakMap === "undefined" ? undefined : new WeakMap();
	    function disableScrollSnap(scroller) {
	        // If scroll-behavior is natively supported, or if there is no native WeakMap support, there's no need for this fix
	        if (SUPPORTS_SCROLL_BEHAVIOR || map == null) {
	            return NOOP;
	        }
	        var scrollingElement = getScrollingElement();
	        var cachedScrollSnapValue;
	        var cachedScrollBehaviorStyleAttributeValue;
	        var secondaryScroller;
	        var secondaryScrollerCachedScrollSnapValue;
	        var secondaryScrollerCachedScrollBehaviorStyleAttributeValue;
	        var existingResult = map.get(scroller);
	        if (existingResult != null) {
	            cachedScrollSnapValue = existingResult.cachedScrollSnapValue;
	            cachedScrollBehaviorStyleAttributeValue = existingResult.cachedScrollBehaviorStyleAttributeValue;
	            secondaryScroller = existingResult.secondaryScroller;
	            secondaryScrollerCachedScrollSnapValue = existingResult.secondaryScrollerCachedScrollSnapValue;
	            secondaryScrollerCachedScrollBehaviorStyleAttributeValue = existingResult.secondaryScrollerCachedScrollBehaviorStyleAttributeValue;
	            existingResult.release();
	        }
	        else {
	            cachedScrollSnapValue = scroller.style.scrollSnapType === "" ? null : scroller.style.scrollSnapType;
	            cachedScrollBehaviorStyleAttributeValue = parseScrollBehaviorFromStyleAttribute(scroller);
	            secondaryScroller = scroller === scrollingElement && scrollingElement !== document.body ? document.body : undefined;
	            secondaryScrollerCachedScrollSnapValue =
	                secondaryScroller == null ? undefined : secondaryScroller.style.scrollSnapType === "" ? null : secondaryScroller.style.scrollSnapType;
	            secondaryScrollerCachedScrollBehaviorStyleAttributeValue =
	                secondaryScroller == null ? undefined : parseScrollBehaviorFromStyleAttribute(secondaryScroller);
	            var cachedComputedScrollSnapValue = getComputedStyle(scroller).getPropertyValue("scroll-snap-type");
	            var secondaryScrollerCachedComputedScrollSnapValue = secondaryScroller == null ? undefined : getComputedStyle(secondaryScroller).getPropertyValue("scroll-snap-type");
	            // If it just so happens that there actually isn't any scroll snapping going on, there's no point in performing any additional work here.
	            if (cachedComputedScrollSnapValue === "none" && secondaryScrollerCachedComputedScrollSnapValue === "none") {
	                return NOOP;
	            }
	        }
	        scroller.style.scrollSnapType = "none";
	        if (secondaryScroller !== undefined) {
	            secondaryScroller.style.scrollSnapType = "none";
	        }
	        if (cachedScrollBehaviorStyleAttributeValue !== undefined) {
	            appendScrollBehaviorToStyleAttribute(scroller, cachedScrollBehaviorStyleAttributeValue);
	        }
	        if (secondaryScroller !== undefined && secondaryScrollerCachedScrollBehaviorStyleAttributeValue !== undefined) {
	            appendScrollBehaviorToStyleAttribute(secondaryScroller, secondaryScrollerCachedScrollBehaviorStyleAttributeValue);
	        }
	        var hasReleased = false;
	        var eventTarget = scroller === scrollingElement ? window : scroller;
	        function release() {
	            eventTarget.removeEventListener("scroll", resetHandler);
	            if (map != null) {
	                map["delete"](scroller);
	            }
	            hasReleased = true;
	        }
	        function resetHandler() {
	            scroller.style.scrollSnapType = cachedScrollSnapValue;
	            if (secondaryScroller != null && secondaryScrollerCachedScrollSnapValue !== undefined) {
	                secondaryScroller.style.scrollSnapType = secondaryScrollerCachedScrollSnapValue;
	            }
	            if (cachedScrollBehaviorStyleAttributeValue !== undefined) {
	                appendScrollBehaviorToStyleAttribute(scroller, cachedScrollBehaviorStyleAttributeValue);
	            }
	            if (secondaryScroller !== undefined && secondaryScrollerCachedScrollBehaviorStyleAttributeValue !== undefined) {
	                appendScrollBehaviorToStyleAttribute(secondaryScroller, secondaryScrollerCachedScrollBehaviorStyleAttributeValue);
	            }
	            release();
	        }
	        function reset() {
	            setTimeout(function () {
	                if (hasReleased)
	                    return;
	                eventTarget.addEventListener("scroll", resetHandler);
	            });
	        }
	        map.set(scroller, {
	            release: release,
	            cachedScrollSnapValue: cachedScrollSnapValue,
	            cachedScrollBehaviorStyleAttributeValue: cachedScrollBehaviorStyleAttributeValue,
	            secondaryScroller: secondaryScroller,
	            secondaryScrollerCachedScrollSnapValue: secondaryScrollerCachedScrollSnapValue,
	            secondaryScrollerCachedScrollBehaviorStyleAttributeValue: secondaryScrollerCachedScrollBehaviorStyleAttributeValue
	        });
	        return {
	            reset: reset
	        };
	    }

	    /**
	     * The duration of a smooth scroll
	     * @type {number}
	     */
	    var SCROLL_TIME = 15000;
	    /**
	     * Performs a smooth repositioning of the scroll
	     * @param {ISmoothScrollOptions} options
	     */
	    function smoothScroll(options) {
	        var startTime = options.startTime, startX = options.startX, startY = options.startY, endX = options.endX, endY = options.endY, method = options.method, scroller = options.scroller;
	        var timeLapsed = 0;
	        var distanceX = endX - startX;
	        var distanceY = endY - startY;
	        var speed = Math.max(Math.abs((distanceX / 1000) * SCROLL_TIME), Math.abs((distanceY / 1000) * SCROLL_TIME));
	        // Temporarily disables any scroll snapping that may be active since it fights for control over the scroller with this polyfill
	        var scrollSnapFix = disableScrollSnap(scroller);
	        requestAnimationFrame(function animate(timestamp) {
	            timeLapsed += timestamp - startTime;
	            var percentage = Math.max(0, Math.min(1, speed === 0 ? 0 : timeLapsed / speed));
	            var positionX = Math.floor(startX + distanceX * ease(percentage));
	            var positionY = Math.floor(startY + distanceY * ease(percentage));
	            method(positionX, positionY);
	            if (positionX !== endX || positionY !== endY) {
	                requestAnimationFrame(animate);
	            }
	            else {
	                if (scrollSnapFix != null) {
	                    scrollSnapFix.reset();
	                    scrollSnapFix = undefined;
	                }
	            }
	        });
	    }

	    /**
	     * Returns a High Resolution timestamp if possible, otherwise fallbacks to Date.now()
	     * @returns {number}
	     */
	    function now() {
	        if ("performance" in window)
	            return performance.now();
	        return Date.now();
	    }

	    

	    var ELEMENT_ORIGINAL_SCROLL = UNSUPPORTED_ENVIRONMENT ? undefined : Element.prototype.scroll;

	    var WINDOW_ORIGINAL_SCROLL = UNSUPPORTED_ENVIRONMENT ? undefined : window.scroll;

	    var ELEMENT_ORIGINAL_SCROLL_BY = UNSUPPORTED_ENVIRONMENT ? undefined : Element.prototype.scrollBy;

	    var WINDOW_ORIGINAL_SCROLL_BY = UNSUPPORTED_ENVIRONMENT ? undefined : window.scrollBy;

	    var ELEMENT_ORIGINAL_SCROLL_TO = UNSUPPORTED_ENVIRONMENT ? undefined : Element.prototype.scrollTo;

	    var WINDOW_ORIGINAL_SCROLL_TO = UNSUPPORTED_ENVIRONMENT ? undefined : window.scrollTo;

	    /**
	     * A fallback if Element.prototype.scroll is not defined
	     * @param {number} x
	     * @param {number} y
	     */
	    function elementPrototypeScrollFallback(x, y) {
	        this.__adjustingScrollPosition = true;
	        this.scrollLeft = x;
	        this.scrollTop = y;
	        delete this.__adjustingScrollPosition;
	    }
	    /**
	     * A fallback if Element.prototype.scrollTo is not defined
	     * @param {number} x
	     * @param {number} y
	     */
	    function elementPrototypeScrollToFallback(x, y) {
	        return elementPrototypeScrollFallback.call(this, x, y);
	    }
	    /**
	     * A fallback if Element.prototype.scrollBy is not defined
	     * @param {number} x
	     * @param {number} y
	     */
	    function elementPrototypeScrollByFallback(x, y) {
	        this.__adjustingScrollPosition = true;
	        this.scrollLeft += x;
	        this.scrollTop += y;
	        delete this.__adjustingScrollPosition;
	    }
	    /**
	     * Gets the original non-patched prototype method for the given kind
	     * @param {ScrollMethodName} kind
	     * @param {Element|Window} element
	     * @return {Function}
	     */
	    function getOriginalScrollMethodForKind(kind, element) {
	        switch (kind) {
	            case "scroll":
	                if (element instanceof Element) {
	                    if (ELEMENT_ORIGINAL_SCROLL != null) {
	                        return ELEMENT_ORIGINAL_SCROLL;
	                    }
	                    else {
	                        return elementPrototypeScrollFallback;
	                    }
	                }
	                else {
	                    return WINDOW_ORIGINAL_SCROLL;
	                }
	            case "scrollBy":
	                if (element instanceof Element) {
	                    if (ELEMENT_ORIGINAL_SCROLL_BY != null) {
	                        return ELEMENT_ORIGINAL_SCROLL_BY;
	                    }
	                    else {
	                        return elementPrototypeScrollByFallback;
	                    }
	                }
	                else {
	                    return WINDOW_ORIGINAL_SCROLL_BY;
	                }
	            case "scrollTo":
	                if (element instanceof Element) {
	                    if (ELEMENT_ORIGINAL_SCROLL_TO != null) {
	                        return ELEMENT_ORIGINAL_SCROLL_TO;
	                    }
	                    else {
	                        return elementPrototypeScrollToFallback;
	                    }
	                }
	                else {
	                    return WINDOW_ORIGINAL_SCROLL_TO;
	                }
	        }
	    }

	    /**
	     * Gets the Smooth Scroll Options to use for the step function
	     * @param {Element|Window} element
	     * @param {number} x
	     * @param {number} y
	     * @param {ScrollMethodName} kind
	     * @returns {ISmoothScrollOptions}
	     */
	    function getSmoothScrollOptions(element, x, y, kind) {
	        var startTime = now();
	        if (!(element instanceof Element)) {
	            // Use window as the scroll container
	            var scrollX_1 = window.scrollX, pageXOffset_1 = window.pageXOffset, scrollY_1 = window.scrollY, pageYOffset_1 = window.pageYOffset;
	            var startX = scrollX_1 == null || scrollX_1 === 0 ? pageXOffset_1 : scrollX_1;
	            var startY = scrollY_1 == null || scrollY_1 === 0 ? pageYOffset_1 : scrollY_1;
	            return {
	                startTime: startTime,
	                startX: startX,
	                startY: startY,
	                endX: Math.floor(kind === "scrollBy" ? startX + x : x),
	                endY: Math.floor(kind === "scrollBy" ? startY + y : y),
	                method: getOriginalScrollMethodForKind("scrollTo", window).bind(window),
	                scroller: getScrollingElement()
	            };
	        }
	        else {
	            var scrollLeft = element.scrollLeft, scrollTop = element.scrollTop;
	            var startX = scrollLeft;
	            var startY = scrollTop;
	            return {
	                startTime: startTime,
	                startX: startX,
	                startY: startY,
	                endX: Math.floor(kind === "scrollBy" ? startX + x : x),
	                endY: Math.floor(kind === "scrollBy" ? startY + y : y),
	                method: getOriginalScrollMethodForKind("scrollTo", element).bind(element),
	                scroller: element
	            };
	        }
	    }

	    /**
	     * Ensures that the given value is numeric
	     * @param {number} value
	     * @return {number}
	     */
	    function ensureNumeric(value) {
	        if (value == null)
	            return 0;
	        else if (typeof value === "number") {
	            return value;
	        }
	        else if (typeof value === "string") {
	            return parseFloat(value);
	        }
	        else {
	            return 0;
	        }
	    }

	    /**
	     * Returns true if the given value is some ScrollToOptions
	     * @param {number | ScrollToOptions} value
	     * @return {value is ScrollToOptions}
	     */
	    function isScrollToOptions(value) {
	        return value != null && typeof value === "object";
	    }

	    /**
	     * Handles a scroll method
	     * @param {Element|Window} element
	     * @param {ScrollMethodName} kind
	     * @param {number | ScrollToOptions} optionsOrX
	     * @param {number} y
	     */
	    function handleScrollMethod(element, kind, optionsOrX, y) {
	        onScrollWithOptions(getScrollToOptionsWithValidation(optionsOrX, y), element, kind);
	    }
	    /**
	     * Invoked when a 'ScrollToOptions' dict is provided to 'scroll()' as the first argument
	     * @param {ScrollToOptions} options
	     * @param {Element|Window} element
	     * @param {ScrollMethodName} kind
	     */
	    function onScrollWithOptions(options, element, kind) {
	        var behavior = getScrollBehavior(element, options);
	        // If the behavior is 'auto' apply instantaneous scrolling
	        if (behavior == null || behavior === "auto") {
	            getOriginalScrollMethodForKind(kind, element).call(element, options.left, options.top);
	        }
	        else {
	            smoothScroll(getSmoothScrollOptions(element, options.left, options.top, kind));
	        }
	    }
	    /**
	     * Normalizes the given scroll coordinates
	     * @param {number?} x
	     * @param {number?} y
	     * @return {Required<Pick<ScrollToOptions, "top" | "left">>}
	     */
	    function normalizeScrollCoordinates(x, y) {
	        return {
	            left: ensureNumeric(x),
	            top: ensureNumeric(y)
	        };
	    }
	    /**
	     * Gets ScrollToOptions based on the given arguments. Will throw if validation fails
	     * @param {number | ScrollToOptions} optionsOrX
	     * @param {number} y
	     * @return {Required<ScrollToOptions>}
	     */
	    function getScrollToOptionsWithValidation(optionsOrX, y) {
	        // If only one argument is given, and it isn't an options object, throw a TypeError
	        if (y === undefined && !isScrollToOptions(optionsOrX)) {
	            throw new TypeError("Failed to execute 'scroll' on 'Element': parameter 1 ('options') is not an object.");
	        }
	        // Scroll based on the primitive values given as arguments
	        if (!isScrollToOptions(optionsOrX)) {
	            return __assign(__assign({}, normalizeScrollCoordinates(optionsOrX, y)), { behavior: "auto" });
	        }
	        // Scroll based on the received options object
	        else {
	            return __assign(__assign({}, normalizeScrollCoordinates(optionsOrX.left, optionsOrX.top)), { behavior: optionsOrX.behavior == null ? "auto" : optionsOrX.behavior });
	        }
	    }

	    /**
	     * Patches the 'scroll' method on the Element prototype
	     */
	    function patchElementScroll() {
	        Element.prototype.scroll = function (optionsOrX, y) {
	            handleScrollMethod(this, "scroll", optionsOrX, y);
	        };
	    }

	    /**
	     * Patches the 'scrollBy' method on the Element prototype
	     */
	    function patchElementScrollBy() {
	        Element.prototype.scrollBy = function (optionsOrX, y) {
	            handleScrollMethod(this, "scrollBy", optionsOrX, y);
	        };
	    }

	    /**
	     * Patches the 'scrollTo' method on the Element prototype
	     */
	    function patchElementScrollTo() {
	        Element.prototype.scrollTo = function (optionsOrX, y) {
	            handleScrollMethod(this, "scrollTo", optionsOrX, y);
	        };
	    }

	    /**
	     * Patches the 'scroll' method on the Window prototype
	     */
	    function patchWindowScroll() {
	        window.scroll = function (optionsOrX, y) {
	            handleScrollMethod(this, "scroll", optionsOrX, y);
	        };
	    }

	    /**
	     * Patches the 'scrollBy' method on the Window prototype
	     */
	    function patchWindowScrollBy() {
	        window.scrollBy = function (optionsOrX, y) {
	            handleScrollMethod(this, "scrollBy", optionsOrX, y);
	        };
	    }

	    /**
	     * Patches the 'scrollTo' method on the Window prototype
	     */
	    function patchWindowScrollTo() {
	        window.scrollTo = function (optionsOrX, y) {
	            handleScrollMethod(this, "scrollTo", optionsOrX, y);
	        };
	    }

	    // tslint:disable:no-any
	    /**
	     * Gets the parent of an element, taking into account DocumentFragments, ShadowRoots, as well as the root context (window)
	     * @param {EventTarget} currentElement
	     * @returns {EventTarget | null}
	     */
	    function getParent(currentElement) {
	        if ("nodeType" in currentElement && currentElement.nodeType === 1) {
	            return currentElement.parentNode;
	        }
	        if ("ShadowRoot" in window && currentElement instanceof window.ShadowRoot) {
	            return currentElement.host;
	        }
	        else if (currentElement === document) {
	            return window;
	        }
	        else if (currentElement instanceof Node)
	            return currentElement.parentNode;
	        return null;
	    }

	    /**
	     * Returns true if the given overflow property represents a scrollable overflow value
	     * @param {string | null} overflow
	     * @return {boolean}
	     */
	    function canOverflow(overflow) {
	        return overflow !== "visible" && overflow !== "clip";
	    }
	    /**
	     * Returns true if the given element is scrollable
	     * @param {Element} element
	     * @return {boolean}
	     */
	    function isScrollable(element) {
	        if (element.clientHeight < element.scrollHeight || element.clientWidth < element.scrollWidth) {
	            var style = getComputedStyle(element, null);
	            return canOverflow(style.overflowY) || canOverflow(style.overflowX);
	        }
	        return false;
	    }
	    /**
	     * Finds the nearest ancestor of an element that can scroll
	     * @param {Element} target
	     * @returns {Element|Window?}
	     */
	    function findNearestAncestorsWithScrollBehavior(target) {
	        var currentElement = target;
	        var scrollingElement = getScrollingElement();
	        while (currentElement != null) {
	            var behavior = getScrollBehavior(currentElement);
	            if (behavior != null && (currentElement === scrollingElement || isScrollable(currentElement))) {
	                return [currentElement, behavior];
	            }
	            var parent_1 = getParent(currentElement);
	            currentElement = parent_1;
	        }
	        // No such element could be found. Start over, but this time find the nearest ancestor that can simply scroll
	        currentElement = target;
	        while (currentElement != null) {
	            if (currentElement === scrollingElement || isScrollable(currentElement)) {
	                return [currentElement, "auto"];
	            }
	            var parent_2 = getParent(currentElement);
	            currentElement = parent_2;
	        }
	        // Default to the scrolling element
	        return [scrollingElement, "auto"];
	    }

	    // tslint:disable:no-any
	    /**
	     * Finds the nearest root from an element
	     * @param {Element} target
	     * @returns {Document|ShadowRoot}
	     */
	    function findNearestRoot(target) {
	        var currentElement = target;
	        while (currentElement != null) {
	            if ("ShadowRoot" in window && currentElement instanceof window.ShadowRoot) {
	                // Assume this is a ShadowRoot
	                return currentElement;
	            }
	            var parent_1 = getParent(currentElement);
	            if (parent_1 === currentElement) {
	                return document;
	            }
	            currentElement = parent_1;
	        }
	        return document;
	    }

	    /**
	     * Gets the origin of the given Location or HTMLAnchorElement if available in the runtime, and otherwise shims it. (it's a one-liner)
	     * @returns {string}
	     */
	    function getLocationOrigin(locationLike) {
	        if (locationLike === void 0) { locationLike = location; }
	        if ("origin" in locationLike && locationLike.origin != null) {
	            return locationLike.origin;
	        }
	        var port = locationLike.port != null && locationLike.port.length > 0 ? ":" + locationLike.port : "";
	        if (locationLike.protocol === "http:" && port === ":80") {
	            port = "";
	        }
	        else if (locationLike.protocol === "https:" && port === ":443") {
	            port = "";
	        }
	        return locationLike.protocol + "//" + locationLike.hostname + port;
	    }

	    /**
	     * A Regular expression that matches id's of the form "#[digit]"
	     * @type {RegExp}
	     */
	    var ID_WITH_LEADING_DIGIT_REGEXP = /^#\d/;
	    /**
	     * Catches anchor navigation to IDs within the same root and ensures that they can be smooth-scrolled
	     * if the scroll behavior is smooth in the first rooter within that context
	     */
	    function catchNavigation() {
	        // Listen for 'click' events globally
	        window.addEventListener("click", function (e) {
	            // Only work with trusted events on HTMLAnchorElements
	            if (!e.isTrusted || !(e.target instanceof HTMLAnchorElement))
	                return;
	            var _a = e.target, pathname = _a.pathname, search = _a.search, hash = _a.hash;
	            var pointsToCurrentPage = getLocationOrigin(e.target) === getLocationOrigin(location) && pathname === location.pathname && search === location.search;
	            // Only work with HTMLAnchorElements that navigates to a specific ID on the current page
	            if (!pointsToCurrentPage || hash == null || hash.length < 1) {
	                return;
	            }
	            // Find the nearest root, whether it be a ShadowRoot or the document itself
	            var root = findNearestRoot(e.target);
	            // Attempt to match the selector from that root. querySelector' doesn't support IDs that start with a digit, so work around that limitation
	            var elementMatch = hash.match(ID_WITH_LEADING_DIGIT_REGEXP) != null ? root.getElementById(hash.slice(1)) : root.querySelector(hash);
	            // If no selector could be found, don't proceed
	            if (elementMatch == null)
	                return;
	            // Find the nearest ancestor that can be scrolled
	            var _b = __read(findNearestAncestorsWithScrollBehavior(elementMatch), 2), behavior = _b[1];
	            // If the behavior isn't smooth, don't proceed
	            if (behavior !== "smooth")
	                return;
	            // Otherwise, first prevent the default action.
	            e.preventDefault();
	            // Now, scroll to the element with that ID
	            elementMatch.scrollIntoView({
	                behavior: behavior
	            });
	        });
	    }

	    var ELEMENT_ORIGINAL_SCROLL_INTO_VIEW = UNSUPPORTED_ENVIRONMENT ? undefined : Element.prototype.scrollIntoView;

	    /**
	     * The majority of this file is based on https://github.com/stipsan/compute-scroll-into-view (MIT license),
	     * but has been rewritten to accept a scroller as an argument.
	     */
	    /**
	     * Find out which edge to align against when logical scroll position is "nearest"
	     * Interesting fact: "nearest" works similarly to "if-needed", if the element is fully visible it will not scroll it
	     *
	     * Legends:
	     *      
	     *  target    frame
	     *      
	     */
	    function alignNearest(scrollingEdgeStart, scrollingEdgeEnd, scrollingSize, scrollingBorderStart, scrollingBorderEnd, elementEdgeStart, elementEdgeEnd, elementSize) {
	        /**
	         * If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B
	         *
	         *          
	         *        
	         *            
	         *                    do nothing
	         *            
	         *        
	         *          
	         *
	         *  If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D
	         *
	         *         
	         *   
	         *                    do nothing
	         *   
	         *         
	         */
	        if ((elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd) ||
	            (elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd)) {
	            return 0;
	        }
	        /**
	         * If element edge A is outside scrolling box edge A and element height is less than scrolling box height
	         *
	         *          
	         *                 
	         *                         
	         *  from             to    
	         *
	         *                     
	         *
	         * If element edge B is outside scrolling box edge B and element height is greater than scrolling box height
	         *
	         *                   
	         *                             
	         *  from         to      
	         *                           
	         *                 
	         *                         
	         *            
	         *          
	         *
	         * If element edge C is outside scrolling box edge C and element width is less than scrolling box width
	         *
	         *       from                 to
	         *                       
	         *                   
	         *                            
	         *                   
	         *                       
	         *
	         * If element edge D is outside scrolling box edge D and element width is greater than scrolling box width
	         *
	         *       from                 to
	         *                       
	         *           
	         *                              
	         *           
	         *                       
	         */
	        if ((elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize) ||
	            (elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize)) {
	            return elementEdgeStart - scrollingEdgeStart - scrollingBorderStart;
	        }
	        /**
	         * If element edge B is outside scrolling box edge B and element height is less than scrolling box height
	         *
	         *                     
	         *
	         *  from             to    
	         *                         
	         *                 
	         *          
	         *
	         * If element edge A is outside scrolling box edge A and element height is greater than scrolling box height
	         *
	         *          
	         *            
	         *                         
	         *                 
	         *                           
	         *  from         to      
	         *                             
	         *                   
	         *
	         * If element edge C is outside scrolling box edge C and element width is greater than scrolling box width
	         *
	         *           from                 to
	         *                           
	         *             
	         *                                
	         *             
	         *                           
	         *
	         * If element edge D is outside scrolling box edge D and element width is less than scrolling box width
	         *
	         *           from                 to
	         *                           
	         *                             
	         *                                
	         *                             
	         *                           
	         *
	         */
	        if ((elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize) || (elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize)) {
	            return elementEdgeEnd - scrollingEdgeEnd + scrollingBorderEnd;
	        }
	        return 0;
	    }
	    function computeScrollIntoView(target, scroller, options) {
	        var block = options.block, inline = options.inline;
	        // Used to handle the top most element that can be scrolled
	        var scrollingElement = getScrollingElement();
	        // Support pinch-zooming properly, making sure elements scroll into the visual viewport
	        // Browsers that don't support visualViewport will report the layout viewport dimensions on document.documentElement.clientWidth/Height
	        // and viewport dimensions on window.innerWidth/Height
	        // https://www.quirksmode.org/mobile/viewports2.html
	        // https://bokand.github.io/viewport/index.html
	        var viewportWidth = window.visualViewport != null ? visualViewport.width : innerWidth;
	        var viewportHeight = window.visualViewport != null ? visualViewport.height : innerHeight;
	        var viewportX = window.scrollX != null ? window.scrollX : window.pageXOffset;
	        var viewportY = window.scrollY != null ? window.scrollY : window.pageYOffset;
	        var _a = target.getBoundingClientRect(), targetHeight = _a.height, targetWidth = _a.width, targetTop = _a.top, targetRight = _a.right, targetBottom = _a.bottom, targetLeft = _a.left;
	        // These values mutate as we loop through and generate scroll coordinates
	        var targetBlock = block === "start" || block === "nearest" ? targetTop : block === "end" ? targetBottom : targetTop + targetHeight / 2; // block === 'center
	        var targetInline = inline === "center" ? targetLeft + targetWidth / 2 : inline === "end" ? targetRight : targetLeft; // inline === 'start || inline === 'nearest
	        var _b = scroller.getBoundingClientRect(), height = _b.height, width = _b.width, top = _b.top, right = _b.right, bottom = _b.bottom, left = _b.left;
	        var frameStyle = getComputedStyle(scroller);
	        var borderLeft = parseInt(frameStyle.borderLeftWidth, 10);
	        var borderTop = parseInt(frameStyle.borderTopWidth, 10);
	        var borderRight = parseInt(frameStyle.borderRightWidth, 10);
	        var borderBottom = parseInt(frameStyle.borderBottomWidth, 10);
	        var blockScroll = 0;
	        var inlineScroll = 0;
	        // The property existance checks for offset[Width|Height] is because only HTMLElement objects have them, but any Element might pass by here
	        // @TODO find out if the "as HTMLElement" overrides can be dropped
	        var scrollbarWidth = "offsetWidth" in scroller ? scroller.offsetWidth - scroller.clientWidth - borderLeft - borderRight : 0;
	        var scrollbarHeight = "offsetHeight" in scroller ? scroller.offsetHeight - scroller.clientHeight - borderTop - borderBottom : 0;
	        if (scrollingElement === scroller) {
	            // Handle viewport logic (document.documentElement or document.body)
	            if (block === "start") {
	                blockScroll = targetBlock;
	            }
	            else if (block === "end") {
	                blockScroll = targetBlock - viewportHeight;
	            }
	            else if (block === "nearest") {
	                blockScroll = alignNearest(viewportY, viewportY + viewportHeight, viewportHeight, borderTop, borderBottom, viewportY + targetBlock, viewportY + targetBlock + targetHeight, targetHeight);
	            }
	            else {
	                // block === 'center' is the default
	                blockScroll = targetBlock - viewportHeight / 2;
	            }
	            if (inline === "start") {
	                inlineScroll = targetInline;
	            }
	            else if (inline === "center") {
	                inlineScroll = targetInline - viewportWidth / 2;
	            }
	            else if (inline === "end") {
	                inlineScroll = targetInline - viewportWidth;
	            }
	            else {
	                // inline === 'nearest' is the default
	                inlineScroll = alignNearest(viewportX, viewportX + viewportWidth, viewportWidth, borderLeft, borderRight, viewportX + targetInline, viewportX + targetInline + targetWidth, targetWidth);
	            }
	            // Apply scroll position offsets and ensure they are within bounds
	            // @TODO add more test cases to cover this 100%
	            blockScroll = Math.max(0, blockScroll + viewportY);
	            inlineScroll = Math.max(0, inlineScroll + viewportX);
	        }
	        else {
	            // Handle each scrolling frame that might exist between the target and the viewport
	            if (block === "start") {
	                blockScroll = targetBlock - top - borderTop;
	            }
	            else if (block === "end") {
	                blockScroll = targetBlock - bottom + borderBottom + scrollbarHeight;
	            }
	            else if (block === "nearest") {
	                blockScroll = alignNearest(top, bottom, height, borderTop, borderBottom + scrollbarHeight, targetBlock, targetBlock + targetHeight, targetHeight);
	            }
	            else {
	                // block === 'center' is the default
	                blockScroll = targetBlock - (top + height / 2) + scrollbarHeight / 2;
	            }
	            if (inline === "start") {
	                inlineScroll = targetInline - left - borderLeft;
	            }
	            else if (inline === "center") {
	                inlineScroll = targetInline - (left + width / 2) + scrollbarWidth / 2;
	            }
	            else if (inline === "end") {
	                inlineScroll = targetInline - right + borderRight + scrollbarWidth;
	            }
	            else {
	                // inline === 'nearest' is the default
	                inlineScroll = alignNearest(left, right, width, borderLeft, borderRight + scrollbarWidth, targetInline, targetInline + targetWidth, targetWidth);
	            }
	            var scrollLeft = scroller.scrollLeft, scrollTop = scroller.scrollTop;
	            // Ensure scroll coordinates are not out of bounds while applying scroll offsets
	            blockScroll = Math.max(0, Math.min(scrollTop + blockScroll, scroller.scrollHeight - height + scrollbarHeight));
	            inlineScroll = Math.max(0, Math.min(scrollLeft + inlineScroll, scroller.scrollWidth - width + scrollbarWidth));
	        }
	        return {
	            top: blockScroll,
	            left: inlineScroll
	        };
	    }

	    /**
	     * Patches the 'scrollIntoView' method on the Element prototype
	     */
	    function patchElementScrollIntoView() {
	        Element.prototype.scrollIntoView = function (arg) {
	            var normalizedOptions = arg == null || arg === true
	                ? {
	                    block: "start",
	                    inline: "nearest"
	                }
	                : arg === false
	                    ? {
	                        block: "end",
	                        inline: "nearest"
	                    }
	                    : arg;
	            // Find the nearest ancestor that can be scrolled
	            var _a = __read(findNearestAncestorsWithScrollBehavior(this), 2), ancestorWithScroll = _a[0], ancestorWithScrollBehavior = _a[1];
	            var behavior = normalizedOptions.behavior != null ? normalizedOptions.behavior : ancestorWithScrollBehavior;
	            // If the behavior isn't smooth, simply invoke the original implementation and do no more
	            if (behavior !== "smooth") {
	                // Assert that 'scrollIntoView' is actually defined
	                if (ELEMENT_ORIGINAL_SCROLL_INTO_VIEW != null) {
	                    ELEMENT_ORIGINAL_SCROLL_INTO_VIEW.call(this, normalizedOptions);
	                }
	                // Otherwise, invoke 'scrollTo' instead and provide the scroll coordinates
	                else {
	                    var _b = computeScrollIntoView(this, ancestorWithScroll, normalizedOptions), top_1 = _b.top, left = _b.left;
	                    getOriginalScrollMethodForKind("scrollTo", this).call(this, left, top_1);
	                }
	                return;
	            }
	            ancestorWithScroll.scrollTo(__assign({ behavior: behavior }, computeScrollIntoView(this, ancestorWithScroll, normalizedOptions)));
	        };
	        // On IE11, HTMLElement has its own declaration of scrollIntoView and does not inherit this from the prototype chain, so we'll need to patch that one too.
	        if (HTMLElement.prototype.scrollIntoView != null && HTMLElement.prototype.scrollIntoView !== Element.prototype.scrollIntoView) {
	            HTMLElement.prototype.scrollIntoView = Element.prototype.scrollIntoView;
	        }
	    }

	    var ELEMENT_ORIGINAL_SCROLL_TOP_SET_DESCRIPTOR = UNSUPPORTED_ENVIRONMENT
	        ? undefined
	        : Object.getOwnPropertyDescriptor(Element.prototype, "scrollTop").set;

	    /**
	     * Patches the 'scrollTop' property descriptor on the Element prototype
	     */
	    function patchElementScrollTop() {
	        Object.defineProperty(Element.prototype, "scrollTop", {
	            set: function (scrollTop) {
	                if (this.__adjustingScrollPosition) {
	                    return ELEMENT_ORIGINAL_SCROLL_TOP_SET_DESCRIPTOR.call(this, scrollTop);
	                }
	                handleScrollMethod(this, "scrollTo", this.scrollLeft, scrollTop);
	                return scrollTop;
	            }
	        });
	    }

	    var ELEMENT_ORIGINAL_SCROLL_LEFT_SET_DESCRIPTOR = UNSUPPORTED_ENVIRONMENT
	        ? undefined
	        : Object.getOwnPropertyDescriptor(Element.prototype, "scrollLeft").set;

	    /**
	     * Patches the 'scrollLeft' property descriptor on the Element prototype
	     */
	    function patchElementScrollLeft() {
	        Object.defineProperty(Element.prototype, "scrollLeft", {
	            set: function (scrollLeft) {
	                if (this.__adjustingScrollPosition) {
	                    return ELEMENT_ORIGINAL_SCROLL_LEFT_SET_DESCRIPTOR.call(this, scrollLeft);
	                }
	                handleScrollMethod(this, "scrollTo", scrollLeft, this.scrollTop);
	                return scrollLeft;
	            }
	        });
	    }

	    /**
	     * Applies the polyfill
	     */
	    function patch() {
	        // Element.prototype methods
	        patchElementScroll();
	        patchElementScrollBy();
	        patchElementScrollTo();
	        patchElementScrollIntoView();
	        // Element.prototype descriptors
	        patchElementScrollLeft();
	        patchElementScrollTop();
	        // window methods
	        patchWindowScroll();
	        patchWindowScrollBy();
	        patchWindowScrollTo();
	        // Navigation
	        catchNavigation();
	    }

	    /**
	     * Is true if the browser natively supports the Element.prototype.[scroll|scrollTo|scrollBy|scrollIntoView] methods
	     * @type {boolean}
	     */
	    var SUPPORTS_ELEMENT_PROTOTYPE_SCROLL_METHODS = UNSUPPORTED_ENVIRONMENT
	        ? false
	        : "scroll" in Element.prototype && "scrollTo" in Element.prototype && "scrollBy" in Element.prototype && "scrollIntoView" in Element.prototype;

	    if (!UNSUPPORTED_ENVIRONMENT && (!SUPPORTS_SCROLL_BEHAVIOR || !SUPPORTS_ELEMENT_PROTOTYPE_SCROLL_METHODS)) {
	        patch();
	    }

	}());
	
	return dist;
}

var popover = {};

var hasRequiredPopover;

function requirePopover () {
	if (hasRequiredPopover) return popover;
	hasRequiredPopover = 1;
	// src/events.ts
	var ToggleEvent = class extends Event {
	  oldState;
	  newState;
	  constructor(type, { oldState = "", newState = "", ...init } = {}) {
	    super(type, init);
	    this.oldState = String(oldState || "");
	    this.newState = String(newState || "");
	  }
	};
	var popoverToggleTaskQueue = /* @__PURE__ */ new WeakMap();
	function queuePopoverToggleEventTask(element, oldState, newState) {
	  popoverToggleTaskQueue.set(
	    element,
	    setTimeout(() => {
	      if (!popoverToggleTaskQueue.has(element))
	        return;
	      element.dispatchEvent(
	        new ToggleEvent("toggle", {
	          cancelable: false,
	          oldState,
	          newState
	        })
	      );
	    }, 0)
	  );
	}

	// src/popover-helpers.ts
	var ShadowRoot = globalThis.ShadowRoot || function() {
	};
	var HTMLDialogElement = globalThis.HTMLDialogElement || function() {
	};
	var topLayerElements = /* @__PURE__ */ new WeakMap();
	var autoPopoverList = /* @__PURE__ */ new WeakMap();
	var visibilityState = /* @__PURE__ */ new WeakMap();
	function getPopoverVisibilityState(popover) {
	  return visibilityState.get(popover) || "hidden";
	}
	var popoverInvoker = /* @__PURE__ */ new WeakMap();
	function popoverTargetAttributeActivationBehavior(element) {
	  const popover = element.popoverTargetElement;
	  if (!(popover instanceof HTMLElement)) {
	    return;
	  }
	  const visibility = getPopoverVisibilityState(popover);
	  if (element.popoverTargetAction === "show" && visibility === "showing") {
	    return;
	  }
	  if (element.popoverTargetAction === "hide" && visibility === "hidden")
	    return;
	  if (visibility === "showing") {
	    hidePopover(popover, true, true);
	  } else if (checkPopoverValidity(popover, false)) {
	    popoverInvoker.set(popover, element);
	    showPopover(popover);
	  }
	}
	function checkPopoverValidity(element, expectedToBeShowing) {
	  if (element.popover !== "auto" && element.popover !== "manual") {
	    return false;
	  }
	  if (!element.isConnected)
	    return false;
	  if (expectedToBeShowing && getPopoverVisibilityState(element) !== "showing") {
	    return false;
	  }
	  if (!expectedToBeShowing && getPopoverVisibilityState(element) !== "hidden") {
	    return false;
	  }
	  if (element instanceof HTMLDialogElement && element.hasAttribute("open")) {
	    return false;
	  }
	  if (document.fullscreenElement === element)
	    return false;
	  return true;
	}
	function getStackPosition(popover) {
	  if (!popover)
	    return 0;
	  return Array.from(autoPopoverList.get(popover.ownerDocument) || []).indexOf(
	    popover
	  ) + 1;
	}
	function topMostClickedPopover(target) {
	  const clickedPopover = nearestInclusiveOpenPopover(target);
	  const invokerPopover = nearestInclusiveTargetPopoverForInvoker(target);
	  if (getStackPosition(clickedPopover) > getStackPosition(invokerPopover)) {
	    return clickedPopover;
	  }
	  return invokerPopover;
	}
	function topMostAutoPopover(document2) {
	  const documentPopovers = autoPopoverList.get(document2);
	  for (const popover of documentPopovers || []) {
	    if (!popover.isConnected) {
	      documentPopovers.delete(popover);
	    } else {
	      return popover;
	    }
	  }
	  return null;
	}
	function getRootNode(node) {
	  if (typeof node.getRootNode === "function") {
	    return node.getRootNode();
	  }
	  if (node.parentNode)
	    return getRootNode(node.parentNode);
	  return node;
	}
	function nearestInclusiveOpenPopover(node) {
	  while (node) {
	    if (node instanceof HTMLElement && node.popover === "auto" && visibilityState.get(node) === "showing") {
	      return node;
	    }
	    node = node.parentElement || getRootNode(node);
	    if (node instanceof ShadowRoot)
	      node = node.host;
	    if (node instanceof Document)
	      return;
	  }
	}
	function nearestInclusiveTargetPopoverForInvoker(node) {
	  while (node) {
	    const nodePopover = node.popoverTargetElement;
	    if (nodePopover instanceof HTMLElement)
	      return nodePopover;
	    node = node.parentElement || getRootNode(node);
	    if (node instanceof ShadowRoot)
	      node = node.host;
	    if (node instanceof Document)
	      return;
	  }
	}
	function topMostPopoverAncestor(newPopover) {
	  const popoverPositions = /* @__PURE__ */ new Map();
	  let i = 0;
	  for (const popover of autoPopoverList.get(newPopover.ownerDocument) || []) {
	    popoverPositions.set(popover, i);
	    i += 1;
	  }
	  popoverPositions.set(newPopover, i);
	  i += 1;
	  let topMostPopoverAncestor2 = null;
	  function checkAncestor(candidate) {
	    const candidateAncestor = nearestInclusiveOpenPopover(candidate);
	    if (candidateAncestor === null)
	      return null;
	    const candidatePosition = popoverPositions.get(candidateAncestor);
	    if (topMostPopoverAncestor2 === null || popoverPositions.get(topMostPopoverAncestor2) < candidatePosition) {
	      topMostPopoverAncestor2 = candidateAncestor;
	    }
	  }
	  checkAncestor(newPopover.parentElement || getRootNode(newPopover));
	  return topMostPopoverAncestor2;
	}
	function isFocusable(focusTarget) {
	  if (focusTarget.hidden || focusTarget instanceof ShadowRoot)
	    return false;
	  if (focusTarget instanceof HTMLButtonElement || focusTarget instanceof HTMLInputElement || focusTarget instanceof HTMLSelectElement || focusTarget instanceof HTMLTextAreaElement || focusTarget instanceof HTMLOptGroupElement || focusTarget instanceof HTMLOptionElement || focusTarget instanceof HTMLFieldSetElement) {
	    if (focusTarget.disabled)
	      return false;
	  }
	  if (focusTarget instanceof HTMLInputElement && focusTarget.type === "hidden") {
	    return false;
	  }
	  if (focusTarget instanceof HTMLAnchorElement && focusTarget.href === "") {
	    return false;
	  }
	  return typeof focusTarget.tabIndex === "number" && focusTarget.tabIndex !== -1;
	}
	function focusDelegate(focusTarget) {
	  if (focusTarget.shadowRoot && focusTarget.shadowRoot.delegatesFocus !== true) {
	    return null;
	  }
	  let whereToLook = focusTarget;
	  if (whereToLook.shadowRoot) {
	    whereToLook = whereToLook.shadowRoot;
	  }
	  let autoFocusDelegate = whereToLook.querySelector("[autofocus]");
	  if (autoFocusDelegate) {
	    return autoFocusDelegate;
	  } else {
	    const slots = whereToLook.querySelectorAll("slot");
	    for (const slot of slots) {
	      const assignedElements = slot.assignedElements({ flatten: true });
	      for (const el of assignedElements) {
	        if (el.hasAttribute("autofocus")) {
	          return el;
	        } else {
	          autoFocusDelegate = el.querySelector("[autofocus]");
	          if (autoFocusDelegate) {
	            return autoFocusDelegate;
	          }
	        }
	      }
	    }
	  }
	  const walker = focusTarget.ownerDocument.createTreeWalker(
	    whereToLook,
	    NodeFilter.SHOW_ELEMENT
	  );
	  let descendant = walker.currentNode;
	  while (descendant) {
	    if (isFocusable(descendant)) {
	      return descendant;
	    }
	    descendant = walker.nextNode();
	  }
	}
	function popoverFocusingSteps(subject) {
	  focusDelegate(subject)?.focus();
	}
	var previouslyFocusedElements = /* @__PURE__ */ new WeakMap();
	function showPopover(element) {
	  if (!checkPopoverValidity(element, false)) {
	    return;
	  }
	  const document2 = element.ownerDocument;
	  if (!element.dispatchEvent(
	    new ToggleEvent("beforetoggle", {
	      cancelable: true,
	      oldState: "closed",
	      newState: "open"
	    })
	  )) {
	    return;
	  }
	  if (!checkPopoverValidity(element, false)) {
	    return;
	  }
	  let shouldRestoreFocus = false;
	  if (element.popover === "auto") {
	    const originalType = element.getAttribute("popover");
	    const ancestor = topMostPopoverAncestor(element) || document2;
	    hideAllPopoversUntil(ancestor, false, true);
	    if (originalType !== element.getAttribute("popover") || !checkPopoverValidity(element, false)) {
	      return;
	    }
	  }
	  if (!topMostAutoPopover(document2)) {
	    shouldRestoreFocus = true;
	  }
	  previouslyFocusedElements.delete(element);
	  const originallyFocusedElement = document2.activeElement;
	  element.classList.add(":popover-open");
	  visibilityState.set(element, "showing");
	  if (!topLayerElements.has(document2)) {
	    topLayerElements.set(document2, /* @__PURE__ */ new Set());
	  }
	  topLayerElements.get(document2).add(element);
	  popoverFocusingSteps(element);
	  if (element.popover === "auto") {
	    if (!autoPopoverList.has(document2)) {
	      autoPopoverList.set(document2, /* @__PURE__ */ new Set());
	    }
	    autoPopoverList.get(document2).add(element);
	    setInvokerAriaExpanded(popoverInvoker.get(element), true);
	  }
	  if (shouldRestoreFocus && originallyFocusedElement && element.popover === "auto") {
	    previouslyFocusedElements.set(element, originallyFocusedElement);
	  }
	  queuePopoverToggleEventTask(element, "closed", "open");
	}
	function hidePopover(element, focusPreviousElement = false, fireEvents = false) {
	  if (!checkPopoverValidity(element, true)) {
	    return;
	  }
	  const document2 = element.ownerDocument;
	  if (element.popover === "auto") {
	    hideAllPopoversUntil(element, focusPreviousElement, fireEvents);
	    if (!checkPopoverValidity(element, true)) {
	      return;
	    }
	  }
	  setInvokerAriaExpanded(popoverInvoker.get(element), false);
	  popoverInvoker.delete(element);
	  if (fireEvents) {
	    element.dispatchEvent(
	      new ToggleEvent("beforetoggle", {
	        oldState: "open",
	        newState: "closed"
	      })
	    );
	    if (!checkPopoverValidity(element, true)) {
	      return;
	    }
	  }
	  topLayerElements.get(document2)?.delete(element);
	  autoPopoverList.get(document2)?.delete(element);
	  element.classList.remove(":popover-open");
	  visibilityState.set(element, "hidden");
	  if (fireEvents) {
	    queuePopoverToggleEventTask(element, "open", "closed");
	  }
	  const previouslyFocusedElement = previouslyFocusedElements.get(element);
	  if (previouslyFocusedElement) {
	    previouslyFocusedElements.delete(element);
	    if (focusPreviousElement) {
	      previouslyFocusedElement.focus();
	    }
	  }
	}
	function closeAllOpenPopovers(document2, focusPreviousElement = false, fireEvents = false) {
	  let popover = topMostAutoPopover(document2);
	  while (popover) {
	    hidePopover(popover, focusPreviousElement, fireEvents);
	    popover = topMostAutoPopover(document2);
	  }
	}
	function hideAllPopoversUntil(endpoint, focusPreviousElement, fireEvents) {
	  const document2 = endpoint.ownerDocument || endpoint;
	  if (endpoint instanceof Document) {
	    return closeAllOpenPopovers(document2, focusPreviousElement, fireEvents);
	  }
	  let lastToHide = null;
	  let foundEndpoint = false;
	  for (const popover of autoPopoverList.get(document2) || []) {
	    if (popover === endpoint) {
	      foundEndpoint = true;
	    } else if (foundEndpoint) {
	      lastToHide = popover;
	      break;
	    }
	  }
	  if (!foundEndpoint) {
	    return closeAllOpenPopovers(document2, focusPreviousElement, fireEvents);
	  }
	  while (lastToHide && getPopoverVisibilityState(lastToHide) === "showing" && autoPopoverList.get(document2)?.size) {
	    hidePopover(lastToHide, focusPreviousElement, fireEvents);
	  }
	}
	var popoverPointerDownTargets = /* @__PURE__ */ new WeakMap();
	function lightDismissOpenPopovers(event) {
	  if (!event.isTrusted)
	    return;
	  const target = event.composedPath()[0];
	  if (!target)
	    return;
	  const document2 = target.ownerDocument;
	  const topMostPopover = topMostAutoPopover(document2);
	  if (!topMostPopover)
	    return;
	  const ancestor = topMostClickedPopover(target);
	  if (ancestor && event.type === "pointerdown") {
	    popoverPointerDownTargets.set(document2, ancestor);
	  } else if (event.type === "pointerup") {
	    const sameTarget = popoverPointerDownTargets.get(document2) === ancestor;
	    popoverPointerDownTargets.delete(document2);
	    if (sameTarget) {
	      hideAllPopoversUntil(ancestor || document2, false, true);
	    }
	  }
	}
	var initialAriaExpandedValue = /* @__PURE__ */ new WeakMap();
	function setInvokerAriaExpanded(el, force = false) {
	  if (!el)
	    return;
	  if (!initialAriaExpandedValue.has(el)) {
	    initialAriaExpandedValue.set(el, el.getAttribute("aria-expanded"));
	  }
	  const popover = el.popoverTargetElement;
	  if (popover instanceof HTMLElement && popover.popover === "auto") {
	    el.setAttribute("aria-expanded", String(force));
	  } else {
	    const initialValue = initialAriaExpandedValue.get(el);
	    if (!initialValue) {
	      el.removeAttribute("aria-expanded");
	    } else {
	      el.setAttribute("aria-expanded", initialValue);
	    }
	  }
	}

	// src/popover.ts
	var ShadowRoot2 = globalThis.ShadowRoot || function() {
	};
	function isSupported() {
	  return typeof HTMLElement !== "undefined" && typeof HTMLElement.prototype === "object" && "popover" in HTMLElement.prototype;
	}
	function patchSelectorFn(object, name, mapper) {
	  const original = object[name];
	  Object.defineProperty(object, name, {
	    value(selector) {
	      return original.call(this, mapper(selector));
	    }
	  });
	}
	var nonEscapedPopoverSelector = /(^|[^\\]):popover-open\b/g;
	function hasLayerSupport() {
	  return typeof globalThis.CSSLayerBlockRule === "function";
	}
	function getStyles() {
	  const useLayer = hasLayerSupport();
	  return `
${useLayer ? "@layer popover-polyfill {" : ""}
  :where([popover]) {
    position: fixed;
    z-index: 2147483647;
    inset: 0;
    padding: 0.25em;
    width: fit-content;
    height: fit-content;
    border-width: initial;
    border-color: initial;
    border-image: initial;
    border-style: solid;
    background-color: canvas;
    color: canvastext;
    overflow: auto;
    margin: auto;
  }

  :where([popover]:not(.\\:popover-open)) {
    display: none;
  }

  :where(dialog[popover].\\:popover-open) {
    display: block;
  }

  :where(dialog[popover][open]) {
    display: revert;
  }

  :where([anchor].\\:popover-open) {
    inset: auto;
  }

  :where([anchor]:popover-open) {
    inset: auto;
  }

  @supports not (background-color: canvas) {
    :where([popover]) {
      background-color: white;
      color: black;
    }
  }

  @supports (width: -moz-fit-content) {
    :where([popover]) {
      width: -moz-fit-content;
      height: -moz-fit-content;
    }
  }

  @supports not (inset: 0) {
    :where([popover]) {
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }
  }
${useLayer ? "}" : ""}
`;
	}
	var popoverStyleSheet = null;
	function injectStyles(root) {
	  const styles = getStyles();
	  if (popoverStyleSheet === null) {
	    try {
	      popoverStyleSheet = new CSSStyleSheet();
	      popoverStyleSheet.replaceSync(styles);
	    } catch {
	      popoverStyleSheet = false;
	    }
	  }
	  if (popoverStyleSheet === false) {
	    const sheet = document.createElement("style");
	    sheet.textContent = styles;
	    if (root instanceof Document) {
	      root.head.prepend(sheet);
	    } else {
	      root.prepend(sheet);
	    }
	  } else {
	    root.adoptedStyleSheets = [popoverStyleSheet, ...root.adoptedStyleSheets];
	  }
	}
	function apply() {
	  if (typeof window === "undefined")
	    return;
	  window.ToggleEvent = window.ToggleEvent || ToggleEvent;
	  function rewriteSelector(selector) {
	    if (selector?.includes(":popover-open")) {
	      selector = selector.replace(
	        nonEscapedPopoverSelector,
	        "$1.\\:popover-open"
	      );
	    }
	    return selector;
	  }
	  patchSelectorFn(Document.prototype, "querySelector", rewriteSelector);
	  patchSelectorFn(Document.prototype, "querySelectorAll", rewriteSelector);
	  patchSelectorFn(Element.prototype, "querySelector", rewriteSelector);
	  patchSelectorFn(Element.prototype, "querySelectorAll", rewriteSelector);
	  patchSelectorFn(Element.prototype, "matches", rewriteSelector);
	  patchSelectorFn(Element.prototype, "closest", rewriteSelector);
	  patchSelectorFn(
	    DocumentFragment.prototype,
	    "querySelectorAll",
	    rewriteSelector
	  );
	  patchSelectorFn(
	    DocumentFragment.prototype,
	    "querySelectorAll",
	    rewriteSelector
	  );
	  Object.defineProperties(HTMLElement.prototype, {
	    popover: {
	      enumerable: true,
	      configurable: true,
	      get() {
	        if (!this.hasAttribute("popover"))
	          return null;
	        const value = (this.getAttribute("popover") || "").toLowerCase();
	        if (value === "" || value == "auto")
	          return "auto";
	        return "manual";
	      },
	      set(value) {
	        this.setAttribute("popover", value);
	      }
	    },
	    showPopover: {
	      enumerable: true,
	      configurable: true,
	      value() {
	        showPopover(this);
	      }
	    },
	    hidePopover: {
	      enumerable: true,
	      configurable: true,
	      value() {
	        hidePopover(this, true, true);
	      }
	    },
	    togglePopover: {
	      enumerable: true,
	      configurable: true,
	      value(force) {
	        if (visibilityState.get(this) === "showing" && force === void 0 || force === false) {
	          hidePopover(this, true, true);
	        } else if (force === void 0 || force === true) {
	          showPopover(this);
	        }
	      }
	    }
	  });
	  const originalAttachShadow = Element.prototype.attachShadow;
	  if (originalAttachShadow) {
	    Object.defineProperties(Element.prototype, {
	      attachShadow: {
	        enumerable: true,
	        configurable: true,
	        writable: true,
	        value(options) {
	          const shadowRoot = originalAttachShadow.call(this, options);
	          injectStyles(shadowRoot);
	          return shadowRoot;
	        }
	      }
	    });
	  }
	  const originalAttachInternals = HTMLElement.prototype.attachInternals;
	  if (originalAttachInternals) {
	    Object.defineProperties(HTMLElement.prototype, {
	      attachInternals: {
	        enumerable: true,
	        configurable: true,
	        writable: true,
	        value() {
	          const internals = originalAttachInternals.call(this);
	          if (internals.shadowRoot) {
	            injectStyles(internals.shadowRoot);
	          }
	          return internals;
	        }
	      }
	    });
	  }
	  const popoverTargetAssociatedElements = /* @__PURE__ */ new WeakMap();
	  function applyPopoverInvokerElementMixin(ElementClass) {
	    Object.defineProperties(ElementClass.prototype, {
	      popoverTargetElement: {
	        enumerable: true,
	        configurable: true,
	        set(targetElement) {
	          if (targetElement === null) {
	            this.removeAttribute("popovertarget");
	            popoverTargetAssociatedElements.delete(this);
	          } else if (!(targetElement instanceof Element)) {
	            throw new TypeError(
	              `popoverTargetElement must be an element or null`
	            );
	          } else {
	            this.setAttribute("popovertarget", "");
	            popoverTargetAssociatedElements.set(this, targetElement);
	          }
	        },
	        get() {
	          if (this.localName !== "button" && this.localName !== "input") {
	            return null;
	          }
	          if (this.localName === "input" && this.type !== "reset" && this.type !== "image" && this.type !== "button") {
	            return null;
	          }
	          if (this.disabled) {
	            return null;
	          }
	          if (this.form && this.type === "submit") {
	            return null;
	          }
	          const targetElement = popoverTargetAssociatedElements.get(this);
	          if (targetElement && targetElement.isConnected) {
	            return targetElement;
	          } else if (targetElement && !targetElement.isConnected) {
	            popoverTargetAssociatedElements.delete(this);
	            return null;
	          }
	          const root = getRootNode(this);
	          const idref = this.getAttribute("popovertarget");
	          if ((root instanceof Document || root instanceof ShadowRoot2) && idref) {
	            return root.getElementById(idref) || null;
	          }
	          return null;
	        }
	      },
	      popoverTargetAction: {
	        enumerable: true,
	        configurable: true,
	        get() {
	          const value = (this.getAttribute("popovertargetaction") || "").toLowerCase();
	          if (value === "show" || value === "hide")
	            return value;
	          return "toggle";
	        },
	        set(value) {
	          this.setAttribute("popovertargetaction", value);
	        }
	      }
	    });
	  }
	  applyPopoverInvokerElementMixin(HTMLButtonElement);
	  applyPopoverInvokerElementMixin(HTMLInputElement);
	  const handleInvokerActivation = (event) => {
	    const composedPath = event.composedPath();
	    const target = composedPath[0];
	    if (!(target instanceof Element) || target?.shadowRoot) {
	      return;
	    }
	    const root = getRootNode(target);
	    if (!(root instanceof ShadowRoot2 || root instanceof Document)) {
	      return;
	    }
	    const invoker = composedPath.find(
	      (el) => el.matches?.("[popovertargetaction],[popovertarget]")
	    );
	    if (invoker) {
	      popoverTargetAttributeActivationBehavior(invoker);
	      event.preventDefault();
	      return;
	    }
	  };
	  const onKeydown = (event) => {
	    const key = event.key;
	    const target = event.target;
	    if (!event.defaultPrevented && target && (key === "Escape" || key === "Esc")) {
	      hideAllPopoversUntil(target.ownerDocument, true, true);
	    }
	  };
	  const addEventListeners = (root) => {
	    root.addEventListener("click", handleInvokerActivation);
	    root.addEventListener("keydown", onKeydown);
	    root.addEventListener("pointerdown", lightDismissOpenPopovers);
	    root.addEventListener("pointerup", lightDismissOpenPopovers);
	  };
	  addEventListeners(document);
	  injectStyles(document);
	}

	// src/index.ts
	if (!isSupported())
	  apply();
	
	return popover;
}

/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */
/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = (function () {
    if (typeof Map !== 'undefined') {
        return Map;
    }
    /**
     * Returns index in provided array that matches the specified key.
     *
     * @param {Array<Array>} arr
     * @param {*} key
     * @returns {number}
     */
    function getIndex(arr, key) {
        var result = -1;
        arr.some(function (entry, index) {
            if (entry[0] === key) {
                result = index;
                return true;
            }
            return false;
        });
        return result;
    }
    return /** @class */ (function () {
        function class_1() {
            this.__entries__ = [];
        }
        Object.defineProperty(class_1.prototype, "size", {
            /**
             * @returns {boolean}
             */
            get: function () {
                return this.__entries__.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {*} key
         * @returns {*}
         */
        class_1.prototype.get = function (key) {
            var index = getIndex(this.__entries__, key);
            var entry = this.__entries__[index];
            return entry && entry[1];
        };
        /**
         * @param {*} key
         * @param {*} value
         * @returns {void}
         */
        class_1.prototype.set = function (key, value) {
            var index = getIndex(this.__entries__, key);
            if (~index) {
                this.__entries__[index][1] = value;
            }
            else {
                this.__entries__.push([key, value]);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.delete = function (key) {
            var entries = this.__entries__;
            var index = getIndex(entries, key);
            if (~index) {
                entries.splice(index, 1);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.has = function (key) {
            return !!~getIndex(this.__entries__, key);
        };
        /**
         * @returns {void}
         */
        class_1.prototype.clear = function () {
            this.__entries__.splice(0);
        };
        /**
         * @param {Function} callback
         * @param {*} [ctx=null]
         * @returns {void}
         */
        class_1.prototype.forEach = function (callback, ctx) {
            if (ctx === void 0) { ctx = null; }
            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                var entry = _a[_i];
                callback.call(ctx, entry[1], entry[0]);
            }
        };
        return class_1;
    }());
})();

/**
 * Detects whether window and document objects are available in current environment.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

// Returns global object of a current environment.
var global$1 = (function () {
    if (typeof global !== 'undefined' && global.Math === Math) {
        return global;
    }
    if (typeof self !== 'undefined' && self.Math === Math) {
        return self;
    }
    if (typeof window !== 'undefined' && window.Math === Math) {
        return window;
    }
    // eslint-disable-next-line no-new-func
    return Function('return this')();
})();

/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */
var requestAnimationFrame$1 = (function () {
    if (typeof requestAnimationFrame === 'function') {
        // It's required to use a bounded function because IE sometimes throws
        // an "Invalid calling object" error if rAF is invoked without the global
        // object on the left hand side.
        return requestAnimationFrame.bind(global$1);
    }
    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
})();

// Defines minimum timeout before adding a trailing call.
var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */
function throttle (callback, delay) {
    var leadingCall = false, trailingCall = false, lastCallTime = 0;
    /**
     * Invokes the original callback function and schedules new invocation if
     * the "proxy" was called during current request.
     *
     * @returns {void}
     */
    function resolvePending() {
        if (leadingCall) {
            leadingCall = false;
            callback();
        }
        if (trailingCall) {
            proxy();
        }
    }
    /**
     * Callback invoked after the specified delay. It will further postpone
     * invocation of the original function delegating it to the
     * requestAnimationFrame.
     *
     * @returns {void}
     */
    function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
    }
    /**
     * Schedules invocation of the original function.
     *
     * @returns {void}
     */
    function proxy() {
        var timeStamp = Date.now();
        if (leadingCall) {
            // Reject immediately following calls.
            if (timeStamp - lastCallTime < trailingTimeout) {
                return;
            }
            // Schedule new call to be in invoked when the pending one is resolved.
            // This is important for "transitions" which never actually start
            // immediately so there is a chance that we might miss one if change
            // happens amids the pending invocation.
            trailingCall = true;
        }
        else {
            leadingCall = true;
            trailingCall = false;
            setTimeout(timeoutCallback, delay);
        }
        lastCallTime = timeStamp;
    }
    return proxy;
}

// Minimum delay before invoking the update of observers.
var REFRESH_DELAY = 20;
// A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.
var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
// Check if MutationObserver is available.
var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */
var ResizeObserverController = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserverController.
     *
     * @private
     */
    function ResizeObserverController() {
        /**
         * Indicates whether DOM listeners have been added.
         *
         * @private {boolean}
         */
        this.connected_ = false;
        /**
         * Tells that controller has subscribed for Mutation Events.
         *
         * @private {boolean}
         */
        this.mutationEventsAdded_ = false;
        /**
         * Keeps reference to the instance of MutationObserver.
         *
         * @private {MutationObserver}
         */
        this.mutationsObserver_ = null;
        /**
         * A list of connected observers.
         *
         * @private {Array<ResizeObserverSPI>}
         */
        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    /**
     * Adds observer to observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be added.
     * @returns {void}
     */
    ResizeObserverController.prototype.addObserver = function (observer) {
        if (!~this.observers_.indexOf(observer)) {
            this.observers_.push(observer);
        }
        // Add listeners if they haven't been added yet.
        if (!this.connected_) {
            this.connect_();
        }
    };
    /**
     * Removes observer from observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be removed.
     * @returns {void}
     */
    ResizeObserverController.prototype.removeObserver = function (observer) {
        var observers = this.observers_;
        var index = observers.indexOf(observer);
        // Remove observer if it's present in registry.
        if (~index) {
            observers.splice(index, 1);
        }
        // Remove listeners if controller has no connected observers.
        if (!observers.length && this.connected_) {
            this.disconnect_();
        }
    };
    /**
     * Invokes the update of observers. It will continue running updates insofar
     * it detects changes.
     *
     * @returns {void}
     */
    ResizeObserverController.prototype.refresh = function () {
        var changesDetected = this.updateObservers_();
        // Continue running updates if changes have been detected as there might
        // be future ones caused by CSS transitions.
        if (changesDetected) {
            this.refresh();
        }
    };
    /**
     * Updates every observer from observers list and notifies them of queued
     * entries.
     *
     * @private
     * @returns {boolean} Returns "true" if any observer has detected changes in
     *      dimensions of it's elements.
     */
    ResizeObserverController.prototype.updateObservers_ = function () {
        // Collect observers that have active observations.
        var activeObservers = this.observers_.filter(function (observer) {
            return observer.gatherActive(), observer.hasActive();
        });
        // Deliver notifications in a separate cycle in order to avoid any
        // collisions between observers, e.g. when multiple instances of
        // ResizeObserver are tracking the same element and the callback of one
        // of them changes content dimensions of the observed target. Sometimes
        // this may result in notifications being blocked for the rest of observers.
        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
        return activeObservers.length > 0;
    };
    /**
     * Initializes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.connect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already added.
        if (!isBrowser || this.connected_) {
            return;
        }
        // Subscription to the "Transitionend" event is used as a workaround for
        // delayed transitions. This way it's possible to capture at least the
        // final state of an element.
        document.addEventListener('transitionend', this.onTransitionEnd_);
        window.addEventListener('resize', this.refresh);
        if (mutationObserverSupported) {
            this.mutationsObserver_ = new MutationObserver(this.refresh);
            this.mutationsObserver_.observe(document, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true
            });
        }
        else {
            document.addEventListener('DOMSubtreeModified', this.refresh);
            this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
    };
    /**
     * Removes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.disconnect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already removed.
        if (!isBrowser || !this.connected_) {
            return;
        }
        document.removeEventListener('transitionend', this.onTransitionEnd_);
        window.removeEventListener('resize', this.refresh);
        if (this.mutationsObserver_) {
            this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
            document.removeEventListener('DOMSubtreeModified', this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
    };
    /**
     * "Transitionend" event handler.
     *
     * @private
     * @param {TransitionEvent} event
     * @returns {void}
     */
    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
        // Detect whether transition may affect dimensions of an element.
        var isReflowProperty = transitionKeys.some(function (key) {
            return !!~propertyName.indexOf(key);
        });
        if (isReflowProperty) {
            this.refresh();
        }
    };
    /**
     * Returns instance of the ResizeObserverController.
     *
     * @returns {ResizeObserverController}
     */
    ResizeObserverController.getInstance = function () {
        if (!this.instance_) {
            this.instance_ = new ResizeObserverController();
        }
        return this.instance_;
    };
    /**
     * Holds reference to the controller's instance.
     *
     * @private {ResizeObserverController}
     */
    ResizeObserverController.instance_ = null;
    return ResizeObserverController;
}());

/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */
var defineConfigurable = (function (target, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var key = _a[_i];
        Object.defineProperty(target, key, {
            value: props[key],
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    return target;
});

/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */
var getWindowOf = (function (target) {
    // Assume that the element is an instance of Node, which means that it
    // has the "ownerDocument" property from which we can retrieve a
    // corresponding global object.
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
    // Return the local global object if it's not possible extract one from
    // provided element.
    return ownerGlobal || global$1;
});

// Placeholder of an empty content rectangle.
var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */
function toFloat(value) {
    return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */
function getBordersSize(styles) {
    var positions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function (size, position) {
        var value = styles['border-' + position + '-width'];
        return size + toFloat(value);
    }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */
function getPaddings(styles) {
    var positions = ['top', 'right', 'bottom', 'left'];
    var paddings = {};
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
        var position = positions_1[_i];
        var value = styles['padding-' + position];
        paddings[position] = toFloat(value);
    }
    return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */
function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */
function getHTMLElementContentRect(target) {
    // Client width & height properties can't be
    // used exclusively as they provide rounded values.
    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
    // By this condition we can catch all non-replaced inline, hidden and
    // detached elements. Though elements with width & height properties less
    // than 0.5 will be discarded as well.
    //
    // Without it we would need to implement separate methods for each of
    // those cases and it's not possible to perform a precise and performance
    // effective test for hidden elements. E.g. even jQuery's ':visible' filter
    // gives wrong results for elements with width & height less than 0.5.
    if (!clientWidth && !clientHeight) {
        return emptyRect;
    }
    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    // Computed styles of width & height are being used because they are the
    // only dimensions available to JS that contain non-rounded values. It could
    // be possible to utilize the getBoundingClientRect if only it's data wasn't
    // affected by CSS transformations let alone paddings, borders and scroll bars.
    var width = toFloat(styles.width), height = toFloat(styles.height);
    // Width & height include paddings and borders when the 'border-box' box
    // model is applied (except for IE).
    if (styles.boxSizing === 'border-box') {
        // Following conditions are required to handle Internet Explorer which
        // doesn't include paddings and borders to computed CSS dimensions.
        //
        // We can say that if CSS dimensions + paddings are equal to the "client"
        // properties then it's either IE, and thus we don't need to subtract
        // anything, or an element merely doesn't have paddings/borders styles.
        if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles, 'left', 'right') + horizPad;
        }
        if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
        }
    }
    // Following steps can't be applied to the document's root element as its
    // client[Width/Height] properties represent viewport area of the window.
    // Besides, it's as well not necessary as the <html> itself neither has
    // rendered scroll bars nor it can be clipped.
    if (!isDocumentElement(target)) {
        // In some browsers (only in Firefox, actually) CSS width & height
        // include scroll bars size which can be removed at this step as scroll
        // bars are the only difference between rounded dimensions + paddings
        // and "client" properties, though that is not always true in Chrome.
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight;
        // Chrome has a rather weird rounding of "client" properties.
        // E.g. for an element with content width of 314.2px it sometimes gives
        // the client width of 315px and for the width of 314.7px it may give
        // 314px. And it doesn't happen all the time. So just ignore this delta
        // as a non-relevant.
        if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
        }
        if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
        }
    }
    return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
var isSVGGraphicsElement = (function () {
    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
    // interface.
    if (typeof SVGGraphicsElement !== 'undefined') {
        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
    }
    // If it's so, then check that element is at least an instance of the
    // SVGElement and that it has the "getBBox" method.
    // eslint-disable-next-line no-extra-parens
    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
        typeof target.getBBox === 'function'); };
})();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */
function getContentRect(target) {
    if (!isBrowser) {
        return emptyRect;
    }
    if (isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
    }
    return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */
function createReadOnlyRect(_a) {
    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    // If DOMRectReadOnly is available use it as a prototype for the rectangle.
    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    // Rectangle's properties are not writable and non-enumerable.
    defineConfigurable(rect, {
        x: x, y: y, width: width, height: height,
        top: y,
        right: x + width,
        bottom: height + y,
        left: x
    });
    return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */
function createRectInit(x, y, width, height) {
    return { x: x, y: y, width: width, height: height };
}

/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */
var ResizeObservation = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObservation.
     *
     * @param {Element} target - Element to be observed.
     */
    function ResizeObservation(target) {
        /**
         * Broadcasted width of content rectangle.
         *
         * @type {number}
         */
        this.broadcastWidth = 0;
        /**
         * Broadcasted height of content rectangle.
         *
         * @type {number}
         */
        this.broadcastHeight = 0;
        /**
         * Reference to the last observed content rectangle.
         *
         * @private {DOMRectInit}
         */
        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
    }
    /**
     * Updates content rectangle and tells whether it's width or height properties
     * have changed since the last broadcast.
     *
     * @returns {boolean}
     */
    ResizeObservation.prototype.isActive = function () {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return (rect.width !== this.broadcastWidth ||
            rect.height !== this.broadcastHeight);
    };
    /**
     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
     * from the corresponding properties of the last observed content rectangle.
     *
     * @returns {DOMRectInit} Last observed content rectangle.
     */
    ResizeObservation.prototype.broadcastRect = function () {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
    };
    return ResizeObservation;
}());

var ResizeObserverEntry = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObserverEntry.
     *
     * @param {Element} target - Element that is being observed.
     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
     */
    function ResizeObserverEntry(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        // According to the specification following properties are not writable
        // and are also not enumerable in the native implementation.
        //
        // Property accessors are not being used as they'd require to define a
        // private WeakMap storage which may cause memory leaks in browsers that
        // don't support this type of collections.
        defineConfigurable(this, { target: target, contentRect: contentRect });
    }
    return ResizeObserverEntry;
}());

var ResizeObserverSPI = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback function that is invoked
     *      when one of the observed elements changes it's content dimensions.
     * @param {ResizeObserverController} controller - Controller instance which
     *      is responsible for the updates of observer.
     * @param {ResizeObserver} callbackCtx - Reference to the public
     *      ResizeObserver instance which will be passed to callback function.
     */
    function ResizeObserverSPI(callback, controller, callbackCtx) {
        /**
         * Collection of resize observations that have detected changes in dimensions
         * of elements.
         *
         * @private {Array<ResizeObservation>}
         */
        this.activeObservations_ = [];
        /**
         * Registry of the ResizeObservation instances.
         *
         * @private {Map<Element, ResizeObservation>}
         */
        this.observations_ = new MapShim();
        if (typeof callback !== 'function') {
            throw new TypeError('The callback provided as parameter 1 is not a function.');
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
    }
    /**
     * Starts observing provided element.
     *
     * @param {Element} target - Element to be observed.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.observe = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is already being observed.
        if (observations.has(target)) {
            return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        // Force the update of observations.
        this.controller_.refresh();
    };
    /**
     * Stops observing provided element.
     *
     * @param {Element} target - Element to stop observing.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.unobserve = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is not being observed.
        if (!observations.has(target)) {
            return;
        }
        observations.delete(target);
        if (!observations.size) {
            this.controller_.removeObserver(this);
        }
    };
    /**
     * Stops observing all elements.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.disconnect = function () {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
    };
    /**
     * Collects observation instances the associated element of which has changed
     * it's content rectangle.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.gatherActive = function () {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function (observation) {
            if (observation.isActive()) {
                _this.activeObservations_.push(observation);
            }
        });
    };
    /**
     * Invokes initial callback function with a list of ResizeObserverEntry
     * instances collected from active resize observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.broadcastActive = function () {
        // Do nothing if observer doesn't have active observations.
        if (!this.hasActive()) {
            return;
        }
        var ctx = this.callbackCtx_;
        // Create ResizeObserverEntry instance for every active observation.
        var entries = this.activeObservations_.map(function (observation) {
            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
    };
    /**
     * Clears the collection of active observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.clearActive = function () {
        this.activeObservations_.splice(0);
    };
    /**
     * Tells whether observer has active observations.
     *
     * @returns {boolean}
     */
    ResizeObserverSPI.prototype.hasActive = function () {
        return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI;
}());

// Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.
var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */
var ResizeObserver$1 = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback that is invoked when
     *      dimensions of the observed elements change.
     */
    function ResizeObserver(callback) {
        if (!(this instanceof ResizeObserver)) {
            throw new TypeError('Cannot call a class as a function.');
        }
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
    }
    return ResizeObserver;
}());
// Expose public methods of ResizeObserver.
[
    'observe',
    'unobserve',
    'disconnect'
].forEach(function (method) {
    ResizeObserver$1.prototype[method] = function () {
        var _a;
        return (_a = observers.get(this))[method].apply(_a, arguments);
    };
});

var index$1 = (function () {
    // Export existing implementation if available.
    if (typeof global$1.ResizeObserver !== 'undefined') {
        return global$1.ResizeObserver;
    }
    return ResizeObserver$1;
})();

var ResizeObserver_es = /*#__PURE__*/Object.freeze({
	__proto__: null,
	default: index$1
});

var require$$6 = /*@__PURE__*/getAugmentedNamespace(ResizeObserver_es);

var loader_cjs = {};

var alignLabel7a9d9074 = {};

var hasRequiredAlignLabel7a9d9074;

function requireAlignLabel7a9d9074 () {
	if (hasRequiredAlignLabel7a9d9074) return alignLabel7a9d9074;
	hasRequiredAlignLabel7a9d9074 = 1;

	// 'left' is deprecated and will be mapped to 'start'
	// 'right' is deprecated and will be mapped to 'end'
	/** @deprecated */
	const ALIGN_LABELS_DEPRECATED = ['left', 'right'];
	const ALIGN_LABELS = ['start', 'end', ...ALIGN_LABELS_DEPRECATED];

	alignLabel7a9d9074.ALIGN_LABELS = ALIGN_LABELS;

	
	return alignLabel7a9d9074;
}

var appGlobals2f0cb516 = {};

var getCDNBaseURLE7722df3 = {};

var hasRequiredGetCDNBaseURLE7722df3;

function requireGetCDNBaseURLE7722df3 () {
	if (hasRequiredGetCDNBaseURLE7722df3) return getCDNBaseURLE7722df3;
	hasRequiredGetCDNBaseURLE7722df3 = 1;

	const getCDNBaseURL = () => document.porscheDesignSystem.cdn.url + "/porsche-design-system";

	getCDNBaseURLE7722df3.getCDNBaseURL = getCDNBaseURL;

	
	return getCDNBaseURLE7722df3;
}

var hasRequiredAppGlobals2f0cb516;

function requireAppGlobals2f0cb516 () {
	if (hasRequiredAppGlobals2f0cb516) return appGlobals2f0cb516;
	hasRequiredAppGlobals2f0cb516 = 1;

	const getCDNBaseURL = requireGetCDNBaseURLE7722df3();
	const validateProps = requireValidateProps788e2bc5();

	// index.ts
	var FONT_FACE_CDN_FILE_COM = "font-face.7076ba0.css";
	var FONT_FACE_CDN_FILE_CN = "font-face.cn.c531632.css";

	const validatePartialUsage = () => {
	    // TODO: before reactivating we need to be able to distinguish between Light DOM and/or Shadow DOM usage.
	    // validateGetInitialStylesUsage();
	    validateGetFontFaceStylesUsage();
	    validateGetFontLinksUsage();
	    // TODO: integration test (real world test) first, before rollout
	    // validateGetLoaderScriptUsage();
	    // validateGetComponentChunkLinksUsage();
	};
	const validateGetFontFaceStylesUsage = () => {
	    const baseUrl = getCDNBaseURL.getCDNBaseURL();
	    const styleUrl = `${baseUrl}/styles/${baseUrl.match(/\.cn\//) ? FONT_FACE_CDN_FILE_CN : FONT_FACE_CDN_FILE_COM}`
	        ;
	    if (!document.head.querySelector(`link[href="${styleUrl}"],style[data-pds-font-face-styles=""]`)) {
	        logPartialValidationWarning('getFontFaceStyles');
	    }
	};
	const validateGetFontLinksUsage = () => {
	    if (!document.head.querySelector('link[rel=preload][as=font][href*=porsche-next]')) {
	        logPartialValidationWarning('getFontLinks');
	    }
	};
	const logPartialValidationWarning = (partialName, prefix) => {
	    validateProps.consoleWarn(getValidatePartialErrorPrimaryText(partialName), getValidatePartialErrorSecondaryText(partialName));
	};
	const getValidatePartialErrorPrimaryText = (partialName, prefix) => {
	    return `The Porsche Design System ${''}is used without using the ${partialName}() partial.`;
	};
	const getValidatePartialErrorSecondaryText = (partialName, required) => {
	    const partialUrl = partialName
	        .replace('get', '')
	        .replace(/([a-z])([A-Z])/g, '$1-$2') // camelCase to param-case
	        .toLowerCase();
	    return `The usage of the ${partialName}() partial is ${'recommended'} as described at https://designsystem.porsche.com/v3/partials/${partialUrl} to enhance loading behavior.`;
	};

	// TODO: should be removed, instead consumers should be forced via validation to use the partial for preloading
	const injectGlobalStyle = () => {
	    if (typeof document !== 'undefined' && "production" === 'production') {
	        const baseUrl = getCDNBaseURL.getCDNBaseURL();
	        const styleUrl = `${baseUrl}/styles/${baseUrl.match(/\.cn\//) ? FONT_FACE_CDN_FILE_CN : FONT_FACE_CDN_FILE_COM}`;
	        const { head } = document;
	        if (!head.querySelector(`link[href='${styleUrl}'],style[data-pds-font-face-styles=""]`)) {
	            const link = document.createElement('link');
	            link.href = styleUrl;
	            link.type = 'text/css';
	            link.rel = 'stylesheet';
	            head.appendChild(link);
	        }
	    }
	};

	// Timout after which the version validation will happen to increase changes of different versions being loaded and initialized
	const VERSION_VALIDATION_TIMEOUT = 3000;
	/**
	 * Validates the versions of the Porsche Design System and logs a warning if multiple different versions are detected.
	 *
	 * This is in particular problematic since multiple versions can initialize at different times.
	 * You cannot know when all versions are initialized and versions can be loaded only on particular pages. You have to consider having a mix of versions with the validation logic and without.
	 * You would need to detect changes to the document.porscheDesignSystem object and fire a validation on every change.
	 * This would be possible with a proxy which is only created once, but it would still only warn about the versions initialized at the time.
	 * Also, it makes it difficult to change the implementation in the future since it cannot be overwritten by another proxy.
	 * Another approach could be using the stencil 'appload' event (https://stenciljs.com/docs/api), which is already included in older versions of the design system.
	 * More information about other implementations can be found in the PR: https://github.com/porsche-design-system/porsche-design-system/pull/2867
	 */
	const validateVersions = () => {
	    // skip for yarn start
	    {
	        // Uses a timeout to increase the chances that all used versions are loaded and initialized
	        setTimeout(() => {
	            // eslint-disable-next-line @typescript-eslint/no-unused-vars
	            const { cdn, ...versions } = document.porscheDesignSystem;
	            if (Object.keys(versions).length > 1) {
	                validateProps.consoleWarn(
	                // eslint-disable-next-line @typescript-eslint/quotes
	                "Multiple different versions detected!\nWhile bootstrapping multiple versions is valid, it's highly recommended to upgrade all instances to the latest version in use for the best performance.\nRefer to the document.porscheDesignSystem object for detailed information on the current versions in use.\n", document.porscheDesignSystem);
	            }
	        }, VERSION_VALIDATION_TIMEOUT);
	    }
	};

	const appGlobalScript = () => {
	    {
	        // not available during `yarn start` of components package
	        document.porscheDesignSystem["3.27.1"].readyResolve(); // provided via load() of components-js package
	    }
	    injectGlobalStyle();
	    validatePartialUsage();
	    validateVersions();
	};

	const globalScripts = appGlobalScript;

	appGlobals2f0cb516.globalScripts = globalScripts;

	
	return appGlobals2f0cb516;
}

var applyCheckboxRadioButtonSafariRenderingFixE0db2b50 = {};

var isDisabledOrLoadingB1f56d7f = {};

var hasRequiredIsDisabledOrLoadingB1f56d7f;

function requireIsDisabledOrLoadingB1f56d7f () {
	if (hasRequiredIsDisabledOrLoadingB1f56d7f) return isDisabledOrLoadingB1f56d7f;
	hasRequiredIsDisabledOrLoadingB1f56d7f = 1;

	const isDisabledOrLoading = (disabled, loading) => {
	    return disabled || loading;
	};

	isDisabledOrLoadingB1f56d7f.isDisabledOrLoading = isDisabledOrLoading;

	
	return isDisabledOrLoadingB1f56d7f;
}

var supportsChromiumMediaQueryE79aefa2 = {};

var hasRequiredSupportsChromiumMediaQueryE79aefa2;

function requireSupportsChromiumMediaQueryE79aefa2 () {
	if (hasRequiredSupportsChromiumMediaQueryE79aefa2) return supportsChromiumMediaQueryE79aefa2;
	hasRequiredSupportsChromiumMediaQueryE79aefa2 = 1;

	/**
	 * Applies a style only on Chromium based browsers by using a media query which is only supported there.
	 * https://browserstack.com/guide/create-browser-specific-css
	 *
	 * @param {JssStyle} style - The style to be applied when the Chromium media query is supported.
	 * @returns {JssStyle} - The Chromium media query containing the style.
	 */
	const supportsChromiumMediaQuery = (style) => ({
	    '@media screen and (-webkit-min-device-pixel-ratio: 0) and (min-resolution: 0.001dpcm)': style,
	});

	supportsChromiumMediaQueryE79aefa2.supportsChromiumMediaQuery = supportsChromiumMediaQuery;

	
	return supportsChromiumMediaQueryE79aefa2;
}

var hoverMediaQuery5e6deda8 = {};

var hasRequiredHoverMediaQuery5e6deda8;

function requireHoverMediaQuery5e6deda8 () {
	if (hasRequiredHoverMediaQuery5e6deda8) return hoverMediaQuery5e6deda8;
	hasRequiredHoverMediaQuery5e6deda8 = 1;

	/**
	 * utility to wrap jss styles parameter in `@media (hover: hover)`
	 * which is used to not have hover styles on touch devices
	 */
	const hoverMediaQuery = (style) => ({ '@media(hover:hover)': style });

	hoverMediaQuery5e6deda8.hoverMediaQuery = hoverMediaQuery;

	
	return hoverMediaQuery5e6deda8;
}

var stateMessageStylesD1c4637f = {};

var hasNamedSlot273cd3ae = {};

var getNamedSlot223c478a = {};

var hasRequiredGetNamedSlot223c478a;

function requireGetNamedSlot223c478a () {
	if (hasRequiredGetNamedSlot223c478a) return getNamedSlot223c478a;
	hasRequiredGetNamedSlot223c478a = 1;

	const validateProps = requireValidateProps788e2bc5();

	const getNamedSlot = (el, slotName) => validateProps.getHTMLElement(el, `[slot="${slotName}"]`);

	getNamedSlot223c478a.getNamedSlot = getNamedSlot;

	
	return getNamedSlot223c478a;
}

var hasRequiredHasNamedSlot273cd3ae;

function requireHasNamedSlot273cd3ae () {
	if (hasRequiredHasNamedSlot273cd3ae) return hasNamedSlot273cd3ae;
	hasRequiredHasNamedSlot273cd3ae = 1;

	const getNamedSlot = requireGetNamedSlot223c478a();

	const hasNamedSlot = (el, slotName) => !!getNamedSlot.getNamedSlot(el, slotName);

	hasNamedSlot273cd3ae.hasNamedSlot = hasNamedSlot;

	
	return hasNamedSlot273cd3ae;
}

var spacingStaticXSmallB7d708b8 = {};

var hasRequiredSpacingStaticXSmallB7d708b8;

function requireSpacingStaticXSmallB7d708b8 () {
	if (hasRequiredSpacingStaticXSmallB7d708b8) return spacingStaticXSmallB7d708b8;
	hasRequiredSpacingStaticXSmallB7d708b8 = 1;

	const spacingStaticXSmall = '4px';

	spacingStaticXSmallB7d708b8.spacingStaticXSmall = spacingStaticXSmall;

	
	return spacingStaticXSmallB7d708b8;
}

var textSmallStyle00e1c6e2 = {};

var textShared5216bb19 = {};

var fontFamily23874d28 = {};

var hasRequiredFontFamily23874d28;

function requireFontFamily23874d28 () {
	if (hasRequiredFontFamily23874d28) return fontFamily23874d28;
	hasRequiredFontFamily23874d28 = 1;

	const fontFamily = "'Porsche Next','Arial Narrow',Arial,'Heiti SC',SimHei,sans-serif";

	fontFamily23874d28.fontFamily = fontFamily;

	
	return fontFamily23874d28;
}

var fontLineHeightD4b9e1a9 = {};

var hasRequiredFontLineHeightD4b9e1a9;

function requireFontLineHeightD4b9e1a9 () {
	if (hasRequiredFontLineHeightD4b9e1a9) return fontLineHeightD4b9e1a9;
	hasRequiredFontLineHeightD4b9e1a9 = 1;

	const fontLineHeight = 'calc(6px + 2.125ex)';

	fontLineHeightD4b9e1a9.fontLineHeight = fontLineHeight;

	
	return fontLineHeightD4b9e1a9;
}

var fontWeightRegularD0c768ac = {};

var hasRequiredFontWeightRegularD0c768ac;

function requireFontWeightRegularD0c768ac () {
	if (hasRequiredFontWeightRegularD0c768ac) return fontWeightRegularD0c768ac;
	hasRequiredFontWeightRegularD0c768ac = 1;

	const fontWeightRegular = 400;

	fontWeightRegularD0c768ac.fontWeightRegular = fontWeightRegular;

	
	return fontWeightRegularD0c768ac;
}

var fontVariant6ba3b7cb = {};

var hasRequiredFontVariant6ba3b7cb;

function requireFontVariant6ba3b7cb () {
	if (hasRequiredFontVariant6ba3b7cb) return fontVariant6ba3b7cb;
	hasRequiredFontVariant6ba3b7cb = 1;

	const fontStyleNormal = 'normal';

	const fontVariant = 'normal';

	fontVariant6ba3b7cb.fontStyleNormal = fontStyleNormal;
	fontVariant6ba3b7cb.fontVariant = fontVariant;

	
	return fontVariant6ba3b7cb;
}

var hasRequiredTextShared5216bb19;

function requireTextShared5216bb19 () {
	if (hasRequiredTextShared5216bb19) return textShared5216bb19;
	hasRequiredTextShared5216bb19 = 1;

	const fontFamily = requireFontFamily23874d28();
	const fontLineHeight = requireFontLineHeightD4b9e1a9();
	const fontWeightRegular = requireFontWeightRegularD0c768ac();
	const fontVariant = requireFontVariant6ba3b7cb();

	const fontHyphenationStyle = {
	    overflowWrap: 'break-word',
	    hyphens: 'auto',
	};

	const _textFontPartA = `${fontVariant.fontStyleNormal} ${fontVariant.fontVariant} ${fontWeightRegular.fontWeightRegular} `;
	const _textFontPartB = `/${fontLineHeight.fontLineHeight} ${fontFamily.fontFamily}`;

	textShared5216bb19._textFontPartA = _textFontPartA;
	textShared5216bb19._textFontPartB = _textFontPartB;
	textShared5216bb19.fontHyphenationStyle = fontHyphenationStyle;

	
	return textShared5216bb19;
}

var fontSizeTextSmall508930e5 = {};

var hasRequiredFontSizeTextSmall508930e5;

function requireFontSizeTextSmall508930e5 () {
	if (hasRequiredFontSizeTextSmall508930e5) return fontSizeTextSmall508930e5;
	hasRequiredFontSizeTextSmall508930e5 = 1;

	const fontSizeTextSmall = '1rem';

	fontSizeTextSmall508930e5.fontSizeTextSmall = fontSizeTextSmall;

	
	return fontSizeTextSmall508930e5;
}

var hasRequiredTextSmallStyle00e1c6e2;

function requireTextSmallStyle00e1c6e2 () {
	if (hasRequiredTextSmallStyle00e1c6e2) return textSmallStyle00e1c6e2;
	hasRequiredTextSmallStyle00e1c6e2 = 1;

	const textShared = requireTextShared5216bb19();
	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();

	const textSmallStyle = {
	    font: `${textShared._textFontPartA}${fontSizeTextSmall.fontSizeTextSmall}${textShared._textFontPartB}`,
	    ...textShared.fontHyphenationStyle,
	};

	textSmallStyle00e1c6e2.textSmallStyle = textSmallStyle;

	
	return textSmallStyle00e1c6e2;
}

var hasRequiredStateMessageStylesD1c4637f;

function requireStateMessageStylesD1c4637f () {
	if (hasRequiredStateMessageStylesD1c4637f) return stateMessageStylesD1c4637f;
	hasRequiredStateMessageStylesD1c4637f = 1;

	const validateProps = requireValidateProps788e2bc5();
	const hasNamedSlot = requireHasNamedSlot273cd3ae();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const textSmallStyle = requireTextSmallStyle00e1c6e2();

	const FORM_STATES = ['none', 'error', 'success'];

	const getRole = (state) => {
	    return state === 'error' ? 'alert' : state === 'success' ? 'status' : null;
	};

	const hasLabel = (element, label) => {
	    return !!label || hasNamedSlot.hasNamedSlot(element, 'label');
	};

	const hasMessage = (element, message, state) => {
	    return (message || hasNamedSlot.hasNamedSlot(element, 'message')) && ['success', 'error'].includes(state);
	};

	const Required = () => {
	    return (validateProps.h("span", { class: "required", "aria-hidden": "true" },
	        ' ',
	        "*"));
	};

	const messageId = 'message';
	const StateMessage = ({ state, message, theme, host }) => {
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(host);
	    const isErrorState = state === 'error';
	    return (hasMessage(host, message, state) && (validateProps.h("span", { id: messageId, class: "message", role: getRole(state) },
	        validateProps.h(PrefixedTagNames.pIcon, { name: isErrorState ? 'exclamation' : 'check', color: isErrorState ? 'notification-error' : 'notification-success', theme: theme, "aria-hidden": "true" }),
	        message || validateProps.h("slot", { name: "message" }))));
	};

	const getThemedFormStateColors = (theme, state) => {
	    const themedColors = validateProps.getThemedColors(theme);
	    return {
	        formStateColor: themedColors[`${state}Color`],
	        formStateHoverColor: themedColors[`${state}ColorDarken`],
	    };
	};

	const getFunctionalComponentRequiredStyles = () => {
	    return {
	        required: {
	            userSelect: 'none',
	        },
	    };
	};

	const getFunctionalComponentStateMessageStyles = (theme, state, additionalDefaultJssStyle) => {
	    return {
	        message: {
	            display: 'flex',
	            gap: spacingStaticXSmall.spacingStaticXSmall,
	            ...textSmallStyle.textSmallStyle,
	            color: getThemedFormStateColors(theme, state).formStateColor,
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                color: getThemedFormStateColors('dark', state).formStateColor,
	            }),
	            transition: validateProps.getTransition('color'),
	            ...additionalDefaultJssStyle,
	        },
	    };
	};

	stateMessageStylesD1c4637f.FORM_STATES = FORM_STATES;
	stateMessageStylesD1c4637f.Required = Required;
	stateMessageStylesD1c4637f.StateMessage = StateMessage;
	stateMessageStylesD1c4637f.getFunctionalComponentRequiredStyles = getFunctionalComponentRequiredStyles;
	stateMessageStylesD1c4637f.getFunctionalComponentStateMessageStyles = getFunctionalComponentStateMessageStyles;
	stateMessageStylesD1c4637f.getThemedFormStateColors = getThemedFormStateColors;
	stateMessageStylesD1c4637f.hasLabel = hasLabel;
	stateMessageStylesD1c4637f.hasMessage = hasMessage;
	stateMessageStylesD1c4637f.messageId = messageId;

	
	return stateMessageStylesD1c4637f;
}

var hasRequiredApplyCheckboxRadioButtonSafariRenderingFixE0db2b50;

function requireApplyCheckboxRadioButtonSafariRenderingFixE0db2b50 () {
	if (hasRequiredApplyCheckboxRadioButtonSafariRenderingFixE0db2b50) return applyCheckboxRadioButtonSafariRenderingFixE0db2b50;
	hasRequiredApplyCheckboxRadioButtonSafariRenderingFixE0db2b50 = 1;

	const validateProps = requireValidateProps788e2bc5();
	const isDisabledOrLoading = requireIsDisabledOrLoadingB1f56d7f();
	const supportsChromiumMediaQuery = requireSupportsChromiumMediaQueryE79aefa2();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const stateMessageStyles = requireStateMessageStylesD1c4637f();
	const fontLineHeight = requireFontLineHeightD4b9e1a9();
	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();
	const fontFamily = requireFontFamily23874d28();

	// TODO: move to form-styles.ts
	const getSlottedCheckboxRadioButtonStyles = (state, isDisabled, isLoading, theme) => {
	    const { primaryColor, contrastMediumColor, contrastHighColor, disabledColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, contrastMediumColor: contrastMediumColorDark, contrastHighColor: contrastHighColorDark, disabledColor: disabledColorDark, } = validateProps.getThemedColors('dark');
	    const { formStateColor, formStateHoverColor } = stateMessageStyles.getThemedFormStateColors(theme, state);
	    const { formStateColor: formStateColorDark, formStateHoverColor: formStateHoverColorDark } = stateMessageStyles.getThemedFormStateColors('dark', state);
	    const { canvasTextColor } = validateProps.getHighContrastColors();
	    const disabledOrLoading = isDisabledOrLoading.isDisabledOrLoading(isDisabled, isLoading);
	    // TODO: needs to be extracted into a color function
	    const uncheckedColor = disabledOrLoading ? disabledColor : formStateColor || contrastMediumColor;
	    const uncheckedColorDark = disabledOrLoading ? disabledColorDark : formStateColorDark || contrastMediumColorDark;
	    const uncheckedHoverColor = formStateHoverColor || primaryColor;
	    const uncheckedHoverColorDark = formStateHoverColorDark || primaryColorDark;
	    const checkedColor = validateProps.isHighContrastMode
	        ? canvasTextColor
	        : disabledOrLoading
	            ? disabledColor
	            : formStateColor || primaryColor;
	    const checkedColorDark = validateProps.isHighContrastMode
	        ? canvasTextColor
	        : disabledOrLoading
	            ? disabledColorDark
	            : formStateColorDark || primaryColorDark;
	    const checkedHoverColor = formStateHoverColor || contrastHighColor;
	    const checkedHoverColorDark = formStateHoverColorDark || contrastHighColorDark;
	    return {
	        '::slotted': {
	            '&(input)': {
	                width: fontLineHeight.fontLineHeight,
	                height: fontLineHeight.fontLineHeight,
	                font: `${fontSizeTextSmall.fontSizeTextSmall} ${fontFamily.fontFamily}`, // needed for correct width and height definition based on ex-unit
	                display: 'block',
	                margin: 0,
	                padding: 0,
	                WebkitAppearance: 'none', // iOS safari
	                appearance: 'none',
	                boxSizing: 'content-box',
	                background: `transparent 0% 0% / ${fontLineHeight.fontLineHeight}`,
	                transition: `${validateProps.getTransition('background-color')}, ${validateProps.getTransition('border-color')}`,
	                border: `${validateProps.borderWidthBase} solid ${uncheckedColor}`,
	                outline: 0, // TODO: only relevant for VRT testing with forced states - prevents :focus style (in case getFocusJssStyle() condition is not matching)
	                ...(disabledOrLoading
	                    ? {
	                        pointerEvents: 'none', // to prevent form element becomes clickable/toggleable
	                    }
	                    : {
	                        cursor: 'pointer',
	                    }),
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    borderColor: uncheckedColorDark,
	                }),
	            },
	            '&(input:checked)': {
	                // background-image is merged in later
	                borderColor: checkedColor,
	                backgroundColor: checkedColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    borderColor: checkedColorDark,
	                    backgroundColor: checkedColorDark,
	                }),
	            },
	            ...(!disabledOrLoading &&
	                !validateProps.isHighContrastMode &&
	                hoverMediaQuery.hoverMediaQuery({
	                    '&(input:hover),label:hover~.wrapper &(input)': {
	                        borderColor: uncheckedHoverColor,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            borderColor: uncheckedHoverColorDark,
	                        }),
	                    },
	                    '&(input:checked:hover),label:hover~.wrapper &(input:checked)': {
	                        borderColor: checkedHoverColor,
	                        backgroundColor: checkedHoverColor,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            borderColor: checkedHoverColorDark,
	                            backgroundColor: checkedHoverColorDark,
	                        }),
	                    },
	                    'label:hover~.wrapper &(input)': supportsChromiumMediaQuery.supportsChromiumMediaQuery({
	                        transition: 'unset', // Fixes chrome bug where transition properties are stuck on hover
	                    }),
	                })),
	            ...(!isDisabled && validateProps.getFocusJssStyle(theme, { slotted: 'input' })),
	        },
	    };
	};

	// TODO: we can get rid of this fix, as soon as p-checkbox-wrapper and p-radio-button-wrapper have been deprecated and
	//  replaced by encapsulated p-checkbox and p-radio-button component
	// Workaround for Safari >= 16.4 rendering issues (see #3012 for reference).
	// Checkbox/Radio-Button change is not rendered immediately if input or its label is still hovered.
	// The same bug appears on keyboard navigation.
	const getCheckboxRadioButtonSafariRenderingFix = (tagName) => ({
	    [`${tagName}`]: {
	        '& > input:checked': {
	            transform: 'rotateZ(0)',
	        },
	    },
	});

	applyCheckboxRadioButtonSafariRenderingFixE0db2b50.getCheckboxRadioButtonSafariRenderingFix = getCheckboxRadioButtonSafariRenderingFix;
	applyCheckboxRadioButtonSafariRenderingFixE0db2b50.getSlottedCheckboxRadioButtonStyles = getSlottedCheckboxRadioButtonStyles;

	
	return applyCheckboxRadioButtonSafariRenderingFixE0db2b50;
}

var bannerUtils2cc83734 = {};

var hasRequiredBannerUtils2cc83734;

function requireBannerUtils2cc83734 () {
	if (hasRequiredBannerUtils2cc83734) return bannerUtils2cc83734;
	hasRequiredBannerUtils2cc83734 = 1;

	/** @deprecated */
	const BANNER_STATES_DEPRECATED = ['neutral'];
	const BANNER_STATES = ['info', 'warning', 'error', ...BANNER_STATES_DEPRECATED];

	bannerUtils2cc83734.BANNER_STATES = BANNER_STATES;

	
	return bannerUtils2cc83734;
}

var borderRadiusLargeA0aa3a01 = {};

var hasRequiredBorderRadiusLargeA0aa3a01;

function requireBorderRadiusLargeA0aa3a01 () {
	if (hasRequiredBorderRadiusLargeA0aa3a01) return borderRadiusLargeA0aa3a01;
	hasRequiredBorderRadiusLargeA0aa3a01 = 1;

	const borderRadiusLarge = '12px';

	borderRadiusLargeA0aa3a01.borderRadiusLarge = borderRadiusLarge;

	
	return borderRadiusLargeA0aa3a01;
}

var borderRadiusMedium758b9411 = {};

var hasRequiredBorderRadiusMedium758b9411;

function requireBorderRadiusMedium758b9411 () {
	if (hasRequiredBorderRadiusMedium758b9411) return borderRadiusMedium758b9411;
	hasRequiredBorderRadiusMedium758b9411 = 1;

	const borderRadiusMedium = '8px';

	borderRadiusMedium758b9411.borderRadiusMedium = borderRadiusMedium;

	
	return borderRadiusMedium758b9411;
}

var borderRadiusSmall5f37fc45 = {};

var hasRequiredBorderRadiusSmall5f37fc45;

function requireBorderRadiusSmall5f37fc45 () {
	if (hasRequiredBorderRadiusSmall5f37fc45) return borderRadiusSmall5f37fc45;
	hasRequiredBorderRadiusSmall5f37fc45 = 1;

	const borderRadiusSmall = '4px';

	borderRadiusSmall5f37fc45.borderRadiusSmall = borderRadiusSmall;

	
	return borderRadiusSmall5f37fc45;
}

var buttonHandling39869edc = {};

var getClosestHTMLElement83d01a84 = {};

var hasRequiredGetClosestHTMLElement83d01a84;

function requireGetClosestHTMLElement83d01a84 () {
	if (hasRequiredGetClosestHTMLElement83d01a84) return getClosestHTMLElement83d01a84;
	hasRequiredGetClosestHTMLElement83d01a84 = 1;

	/* eslint-disable prefer-arrow/prefer-arrow-functions */
	function getClosestHTMLElement(element, selector) {
	    return element?.closest(selector);
	}

	getClosestHTMLElement83d01a84.getClosestHTMLElement = getClosestHTMLElement;

	
	return getClosestHTMLElement83d01a84;
}

var setAttributesF96a52a9 = {};

var hasRequiredSetAttributesF96a52a9;

function requireSetAttributesF96a52a9 () {
	if (hasRequiredSetAttributesF96a52a9) return setAttributesF96a52a9;
	hasRequiredSetAttributesF96a52a9 = 1;

	/**
	 * Sets attributes on an HTMLElement.
	 *
	 * @param {HTMLElement} host - The target HTMLElement to set attributes on.
	 * @param {{ [x: string]: string }} attributes - An object of attribute names and their corresponding values.
	 * @returns {void}
	 */
	const setAttributes = (host, attributes) => {
	    for (const args of Object.entries(attributes)) {
	        host.setAttribute(...args);
	    }
	};

	setAttributesF96a52a9.setAttributes = setAttributes;

	
	return setAttributesF96a52a9;
}

var hasRequiredButtonHandling39869edc;

function requireButtonHandling39869edc () {
	if (hasRequiredButtonHandling39869edc) return buttonHandling39869edc;
	hasRequiredButtonHandling39869edc = 1;

	requireValidateProps788e2bc5();
	const getClosestHTMLElement = requireGetClosestHTMLElement83d01a84();
	const setAttributes = requireSetAttributesF96a52a9();

	const improveButtonHandlingForCustomElement = (element, getType, getDisabled, getName, getValue) => {
	    element.addEventListener('click', (event) => handleButtonEvent(event, element, getType, getDisabled, getName, getValue));
	};
	const handleButtonEvent = (event, element, getType, getDisabled, getName, getValue) => {
	    // Why? That's why: https://hjorthhansen.dev/shadow-dom-and-forms/
	    const form = getClosestHTMLElement.getClosestHTMLElement(element, 'form');
	    if (form && !getDisabled()) {
	        /**
	         * we've to wait if someone calls preventDefault on the event
	         * then we shouldn't submit the form
	         */
	        window.setTimeout(() => {
	            if (!event.defaultPrevented) {
	                const name = getName?.();
	                const value = getValue?.();
	                const fakeButton = document.createElement('button');
	                setAttributes.setAttributes(fakeButton, {
	                    ...(name && { name }),
	                    ...(value && { value }),
	                    type: getType(),
	                });
	                fakeButton.style.display = 'none';
	                form.appendChild(fakeButton);
	                fakeButton.addEventListener('click', (fakeButtonEvent) => {
	                    fakeButtonEvent.stopPropagation();
	                });
	                fakeButton.click();
	                fakeButton.remove();
	            }
	        }, 1);
	    }
	};

	buttonHandling39869edc.handleButtonEvent = handleButtonEvent;
	buttonHandling39869edc.improveButtonHandlingForCustomElement = improveButtonHandlingForCustomElement;

	
	return buttonHandling39869edc;
}

var buttonLinkPureUtils42aabf78 = {};

var isParentOfKind4b323732 = {};

var hasRequiredIsParentOfKind4b323732;

function requireIsParentOfKind4b323732 () {
	if (hasRequiredIsParentOfKind4b323732) return isParentOfKind4b323732;
	hasRequiredIsParentOfKind4b323732 = 1;

	const validateProps = requireValidateProps788e2bc5();

	const isParentOfKind = (element, tagName) => {
	    const { parentElement } = element;
	    return parentElement && validateProps.getTagNameWithoutPrefix(parentElement) === tagName;
	};

	isParentOfKind4b323732.isParentOfKind = isParentOfKind;

	
	return isParentOfKind4b323732;
}

var hasRequiredButtonLinkPureUtils42aabf78;

function requireButtonLinkPureUtils42aabf78 () {
	if (hasRequiredButtonLinkPureUtils42aabf78) return buttonLinkPureUtils42aabf78;
	hasRequiredButtonLinkPureUtils42aabf78 = 1;

	const validateProps = requireValidateProps788e2bc5();
	const isParentOfKind = requireIsParentOfKind4b323732();

	const hasVisibleIcon = (iconName, iconSource) => {
	    return iconName !== 'none' || !!iconSource;
	};
	const warnIfParentIsPTextAndIconIsNone = (host, iconName, iconSource) => {
	    if (!hasVisibleIcon(iconName, iconSource) && isParentOfKind.isParentOfKind(host, 'p-text')) {
	        validateProps.consoleWarn(`${validateProps.getTagNameWithoutPrefix(host)} should not be used inside p-text. Please use a <button> or <a> tag.`, host);
	    }
	};

	buttonLinkPureUtils42aabf78.hasVisibleIcon = hasVisibleIcon;
	buttonLinkPureUtils42aabf78.warnIfParentIsPTextAndIconIsNone = warnIfParentIsPTextAndIconIsNone;

	
	return buttonLinkPureUtils42aabf78;
}

var buttonTypeAe0c09db = {};

var hasRequiredButtonTypeAe0c09db;

function requireButtonTypeAe0c09db () {
	if (hasRequiredButtonTypeAe0c09db) return buttonTypeAe0c09db;
	hasRequiredButtonTypeAe0c09db = 1;

	const BUTTON_ARIA_ATTRIBUTES = ['aria-label', 'aria-expanded', 'aria-pressed', 'aria-haspopup'];

	const BUTTON_TYPES = ['button', 'submit', 'reset'];

	buttonTypeAe0c09db.BUTTON_ARIA_ATTRIBUTES = BUTTON_ARIA_ATTRIBUTES;
	buttonTypeAe0c09db.BUTTON_TYPES = BUTTON_TYPES;

	
	return buttonTypeAe0c09db;
}

var changeColor50831612 = {};

var hasRequiredChangeColor50831612;

function requireChangeColor50831612 () {
	if (hasRequiredChangeColor50831612) return changeColor50831612;
	hasRequiredChangeColor50831612 = 1;

	const lighten = (hsl) => {
	    return changeColor(hsl, 15);
	};
	const darken = (hsl) => {
	    return changeColor(hsl, -15);
	};
	const changeColor = (hsl, lightness) => {
	    return hsl.replace(/\s(\d+)(%?)\//, (_, p1, p2) => {
	        return ` ${Math.min(Math.max(Number.parseInt(p1, 10) + lightness, 0), 100)}${p2}/`;
	    });
	};

	changeColor50831612.darken = darken;
	changeColor50831612.lighten = lighten;

	
	return changeColor50831612;
}

var colorSchemeStyles4bc3d59c = {};

var hasRequiredColorSchemeStyles4bc3d59c;

function requireColorSchemeStyles4bc3d59c () {
	if (hasRequiredColorSchemeStyles4bc3d59c) return colorSchemeStyles4bc3d59c;
	hasRequiredColorSchemeStyles4bc3d59c = 1;

	const hostHiddenStyles = {
	    '&([hidden])': {
	        display: 'none',
	    },
	};

	const colorSchemeStyles = {
	    colorScheme: 'light dark',
	};

	colorSchemeStyles4bc3d59c.colorSchemeStyles = colorSchemeStyles;
	colorSchemeStyles4bc3d59c.hostHiddenStyles = hostHiddenStyles;

	
	return colorSchemeStyles4bc3d59c;
}

var constants3998cc0f = {};

var dropShadowShared6e50faf3 = {};

var hasRequiredDropShadowShared6e50faf3;

function requireDropShadowShared6e50faf3 () {
	if (hasRequiredDropShadowShared6e50faf3) return dropShadowShared6e50faf3;
	hasRequiredDropShadowShared6e50faf3 = 1;

	const _dropShadowBackgroundColor = 'rgba(0, 0, 0, 0.16)';

	dropShadowShared6e50faf3._dropShadowBackgroundColor = _dropShadowBackgroundColor;

	
	return dropShadowShared6e50faf3;
}

var hasRequiredConstants3998cc0f;

function requireConstants3998cc0f () {
	if (hasRequiredConstants3998cc0f) return constants3998cc0f;
	hasRequiredConstants3998cc0f = 1;

	const dropShadowShared = requireDropShadowShared6e50faf3();

	const dropShadowHighStyle = {
	    boxShadow: `0px 8px 40px ${dropShadowShared._dropShadowBackgroundColor}`, // filter: drop-shadow() causes visual glitches in Firefox in combination with frostedGlassStyle
	};

	const TOAST_Z_INDEX = 999999;
	const BANNER_Z_INDEX = 99;

	constants3998cc0f.BANNER_Z_INDEX = BANNER_Z_INDEX;
	constants3998cc0f.TOAST_Z_INDEX = TOAST_Z_INDEX;
	constants3998cc0f.dropShadowHighStyle = dropShadowHighStyle;

	
	return constants3998cc0f;
}

var dialogStyles52804ea9 = {};

var spacingFluidLarge6087a0f7 = {};

var hasRequiredSpacingFluidLarge6087a0f7;

function requireSpacingFluidLarge6087a0f7 () {
	if (hasRequiredSpacingFluidLarge6087a0f7) return spacingFluidLarge6087a0f7;
	hasRequiredSpacingFluidLarge6087a0f7 = 1;

	const spacingFluidLarge = 'clamp(32px, 2.75vw + 23px, 76px)';

	spacingFluidLarge6087a0f7.spacingFluidLarge = spacingFluidLarge;

	
	return spacingFluidLarge6087a0f7;
}

var gridGapB5b73e4a = {};

var spacingFluidMedium88ab712b = {};

var hasRequiredSpacingFluidMedium88ab712b;

function requireSpacingFluidMedium88ab712b () {
	if (hasRequiredSpacingFluidMedium88ab712b) return spacingFluidMedium88ab712b;
	hasRequiredSpacingFluidMedium88ab712b = 1;

	const spacingFluidMedium = 'clamp(16px, 1.25vw + 12px, 36px)';

	spacingFluidMedium88ab712b.spacingFluidMedium = spacingFluidMedium;

	
	return spacingFluidMedium88ab712b;
}

var hasRequiredGridGapB5b73e4a;

function requireGridGapB5b73e4a () {
	if (hasRequiredGridGapB5b73e4a) return gridGapB5b73e4a;
	hasRequiredGridGapB5b73e4a = 1;

	const spacingFluidMedium = requireSpacingFluidMedium88ab712b();

	const gridGap = spacingFluidMedium.spacingFluidMedium;

	gridGapB5b73e4a.gridGap = gridGap;

	
	return gridGapB5b73e4a;
}

var spacingFluidSmall2c6caae7 = {};

var hasRequiredSpacingFluidSmall2c6caae7;

function requireSpacingFluidSmall2c6caae7 () {
	if (hasRequiredSpacingFluidSmall2c6caae7) return spacingFluidSmall2c6caae7;
	hasRequiredSpacingFluidSmall2c6caae7 = 1;

	const spacingFluidSmall = 'clamp(8px, 0.5vw + 6px, 16px)';

	spacingFluidSmall2c6caae7.spacingFluidSmall = spacingFluidSmall;

	
	return spacingFluidSmall2c6caae7;
}

var spacingStaticMedium94812711 = {};

var hasRequiredSpacingStaticMedium94812711;

function requireSpacingStaticMedium94812711 () {
	if (hasRequiredSpacingStaticMedium94812711) return spacingStaticMedium94812711;
	hasRequiredSpacingStaticMedium94812711 = 1;

	const spacingStaticMedium = '16px';

	spacingStaticMedium94812711.spacingStaticMedium = spacingStaticMedium;

	
	return spacingStaticMedium94812711;
}

var frostedGlassStyleBd067e45 = {};

var hasRequiredFrostedGlassStyleBd067e45;

function requireFrostedGlassStyleBd067e45 () {
	if (hasRequiredFrostedGlassStyleBd067e45) return frostedGlassStyleBd067e45;
	hasRequiredFrostedGlassStyleBd067e45 = 1;

	const backdropFilter = 'blur(32px)';
	const frostedGlassStyle = {
	    WebkitBackdropFilter: backdropFilter,
	    backdropFilter,
	};

	frostedGlassStyleBd067e45.frostedGlassStyle = frostedGlassStyle;

	
	return frostedGlassStyleBd067e45;
}

var hasRequiredDialogStyles52804ea9;

function requireDialogStyles52804ea9 () {
	if (hasRequiredDialogStyles52804ea9) return dialogStyles52804ea9;
	hasRequiredDialogStyles52804ea9 = 1;

	const validateProps = requireValidateProps788e2bc5();
	const spacingFluidLarge = requireSpacingFluidLarge6087a0f7();
	const gridGap = requireGridGapB5b73e4a();
	const spacingFluidSmall = requireSpacingFluidSmall2c6caae7();
	const spacingFluidMedium = requireSpacingFluidMedium88ab712b();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();
	const frostedGlassStyle = requireFrostedGlassStyleBd067e45();

	const setDialogVisibility = (isOpen, dialog, scrollArea) => {
	    // `.showModal()` / `.close()` shall only be called when state changes and after render cycle has finished
	    // (e.g. in `componentDidRender()`) to prepare visibility states of dialog in order to focus the dismiss button correctly
	    if (isOpen === true && !dialog.open) {
	        scrollArea.scrollTo(0, 0); // reset scroll position each time dialog gets opened again
	        dialog.inert = true; // This will prevent the autofocus of focusable elements inside the dialog (e.g. close button) element which is conflicting with our transition
	        dialog.showModal(); // shows modal on `#top-layer`
	        dialog.inert = false; // Re-enable focus on dialog element
	        dialog.focus(); // set focus programmatically to dialog element to prevent transition bug in Safari
	    }
	    else if (isOpen === false && dialog.open) {
	        dialog.close();
	    }
	};
	const onCancelDialog = (e, cb, disable = false) => {
	    e.preventDefault(); // prevent closing the dialog uncontrolled by ESC
	    if (!disable) {
	        cb();
	    }
	};
	const onClickDialog = (e, cb, disable) => {
	    if (!disable &&
	        (e.target.className === 'scroller' ||
	            e.target.tagName === 'DIALOG')) {
	        cb(); // dismiss dialog when clicked on backdrop
	    }
	};
	const onTransitionEnd = (nativeEvent, isOpen, motionVisibleEndEvent, motionHiddenEndEvent) => {
	    // Use property which has the longest duration and prevent multiple ontransitionend events for each property
	    if (nativeEvent.propertyName === 'background-color') {
	        // eslint-disable-next-line no-unused-expressions
	        isOpen ? motionVisibleEndEvent.emit(nativeEvent) : motionHiddenEndEvent.emit(nativeEvent);
	    }
	};

	const BACKDROPS = ['blur', 'shading'];
	const headingTags = 'h1,h2,h3,h4,h5,h6';
	const dialogHostJssStyle = {
	    '--pds-internal-grid-outer-column': `calc(${spacingFluidLarge.spacingFluidLarge} - ${gridGap.gridGap})`,
	    '--pds-internal-grid-margin': `calc(${spacingFluidLarge.spacingFluidLarge} * -1)`,
	    '--pds-internal-grid-width-min': 'auto',
	    '--pds-internal-grid-width-max': 'none',
	};
	const getDialogJssStyle = (isVisible, theme, backdrop = 'blur') => {
	    return {
	        ...dialogBackdropResetJssStyle,
	        ...getDialogBackdropTransitionJssStyle(isVisible, theme, backdrop),
	    };
	};
	const dialogBackdropResetJssStyle = {
	    position: 'fixed', // ua-style
	    inset: 0, // ua-style
	    margin: 0, // ua-style
	    padding: 0, // ua-style
	    border: 0, // ua-style
	    width: '100dvw', // ua-style
	    height: '100dvh', // ua-style
	    maxWidth: '100dvw', // ua-style
	    maxHeight: '100dvh', // ua-style
	    overflow: 'hidden', // ua-style
	    display: 'block', // ua-style
	    outline: 0, // ua-style (we always expect a focusable element to be within the dialog)
	    '&::backdrop': {
	        display: 'none', // ua-style (we can't use it atm because it's not animatable in all browsers)
	    },
	};
	const getDialogBackdropTransitionJssStyle = (isVisible, theme, backdrop = 'blur') => {
	    const isBackdropBlur = backdrop === 'blur';
	    const { backgroundShadingColor } = validateProps.getThemedColors(theme);
	    const { backgroundShadingColor: backgroundShadingColorDark } = validateProps.getThemedColors('dark');
	    const duration = isVisible ? 'long' : 'moderate';
	    const easing = isVisible ? 'in' : 'out';
	    // as soon as all browsers are supporting `allow-discrete`, visibility transition shouldn't be necessary anymore
	    const transition = `visibility 0s linear var(${validateProps.cssVariableTransitionDuration}, ${isVisible ? '0s' : validateProps.motionDurationMap[duration]}), ${validateProps.getTransition('background-color', duration, easing)}, ${validateProps.getTransition('-webkit-backdrop-filter', duration, easing)}, ${validateProps.getTransition('backdrop-filter', duration, easing)}`;
	    return {
	        zIndex: 9999999, // fallback for fade out stacking until `overlay` + `allow-discrete` is supported in all browsers. It tries to mimic #top-layer positioning hierarchy.
	        ...(isVisible
	            ? {
	                visibility: 'inherit',
	                pointerEvents: 'auto',
	                background: backgroundShadingColor,
	                ...(isBackdropBlur && frostedGlassStyle.frostedGlassStyle),
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    background: backgroundShadingColorDark,
	                }),
	            }
	            : {
	                visibility: 'hidden', // element shall not be tabbable with keyboard after fade out transition has finished
	                pointerEvents: 'none', // element can't be interacted with mouse
	                background: 'transparent',
	            }),
	        transition,
	        // `allow-discrete` transition for ua-style `overlay` (supported browsers only) ensures dialog is rendered on
	        // #top-layer as long as fade-in or fade-out transition/animation is running
	        '@supports (transition-behavior: allow-discrete)': {
	            transition: `${transition}, ${validateProps.getTransition('overlay', duration, easing)} allow-discrete`,
	        },
	    };
	};
	const getScrollerJssStyle = (position, theme) => {
	    // ensures scrollbar color is set correctly (e.g. when scrollbar is shown on backdrop, on flyout/modal surface or with Auto Dark Mode)
	    const backgroundLight = 'rgba(255,255,255,.01)';
	    const backgroundDark = 'rgba(0,0,0,.01)';
	    const background = {
	        light: backgroundLight,
	        dark: backgroundDark,
	        auto: backgroundLight,
	    };
	    return {
	        position: 'absolute',
	        isolation: 'isolate', // creates new stacking context to show scrollbars on top of header/footer areas (on iOS/iPadOS)
	        display: 'grid',
	        ...(position === 'fullscreen'
	            ? {
	                inset: 0,
	            }
	            : {
	                insetBlock: 0,
	                [position === 'start' ? 'insetInlineStart' : 'insetInlineEnd']: 0,
	            }),
	        overflow: 'hidden auto',
	        overscrollBehaviorY: 'none',
	        // TODO: check if smooth scrolling on iOS is given?
	        background: background[theme],
	        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	            background: background.dark,
	        }),
	    };
	};
	const dialogPaddingBlock = `calc(${spacingFluidSmall.spacingFluidSmall} + ${spacingFluidMedium.spacingFluidMedium})`;
	const dialogGridJssStyle = {
	    display: 'grid',
	    gridTemplate: `auto/${spacingFluidSmall.spacingFluidSmall} auto ${spacingFluidSmall.spacingFluidSmall}`,
	    paddingBlock: dialogPaddingBlock,
	    rowGap: spacingFluidMedium.spacingFluidMedium,
	    columnGap: `calc(${spacingFluidLarge.spacingFluidLarge} - ${spacingFluidSmall.spacingFluidSmall})`,
	    alignContent: 'flex-start',
	};
	const getDialogColorJssStyle = (theme) => {
	    const { primaryColor, backgroundColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, backgroundColor: backgroundColorDark } = validateProps.getThemedColors('dark');
	    return {
	        color: primaryColor, // enables color inheritance for slots
	        background: backgroundColor,
	        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	            color: primaryColorDark,
	            background: backgroundColorDark,
	        }),
	    };
	};
	const getDialogTransitionJssStyle = (isVisible, slideIn) => {
	    const duration = isVisible ? 'moderate' : 'short';
	    const easing = isVisible ? 'in' : 'out';
	    return {
	        // transition offset relies vertically on viewport (vh) because the dialog height can be infinite, while horizontally
	        // it relies on the dialog width (%) which has a max-width
	        ...(isVisible
	            ? {
	                opacity: 1,
	                transform: 'initial',
	            }
	            : {
	                opacity: 0,
	                transform: slideIn === '^' ? 'translateY(25vh)' : `translateX(${slideIn === '>' ? '-' : ''}100%)`,
	                '&:dir(rtl)': {
	                    transform: slideIn === '^' ? 'translateY(25vh)' : `translateX(${slideIn === '>' ? '' : '-'}100%)`,
	                },
	            }),
	        transition: `${validateProps.getTransition('opacity', duration, easing)}, ${validateProps.getTransition('transform', duration, easing)}`,
	    };
	};
	const getDialogStickyAreaJssStyle = (area, theme) => {
	    const { backgroundColor } = validateProps.getThemedColors(theme);
	    const { backgroundColor: backgroundColorDark } = validateProps.getThemedColors('dark');
	    const scrollShadowColor = 'rgba(204, 204, 204, 0.35)';
	    const scrollShadowColorDark = 'rgba(0, 0, 0, 0.6)';
	    const isAreaHeader = area === 'header';
	    const boxShadowDimension = `0 ${isAreaHeader ? 5 : -5}px 10px`;
	    return {
	        position: 'sticky',
	        [isAreaHeader ? 'top' : 'bottom']: '-.1px', // necessary for `IntersectionObserver` to detect if sticky element is stuck or not. Float value is used, so that sticky area isn't moved out visually by e.g. 1px when container gets scrolled.
	        transform: 'translateZ(0)', // prevents slightly squeezed elements within sticky area for some browsers (e.g. Firefox) caused by float value of sticky top position
	        padding: `${spacingStaticMedium.spacingStaticMedium} ${spacingFluidLarge.spacingFluidLarge}`,
	        marginBlock: `${isAreaHeader ? `calc((${spacingFluidSmall.spacingFluidSmall} + ${spacingFluidMedium.spacingFluidMedium}) * -1)` : `-${spacingStaticMedium.spacingStaticMedium}`} -${spacingStaticMedium.spacingStaticMedium}`,
	        background: backgroundColor,
	        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	            background: backgroundColorDark,
	        }),
	        clipPath: `inset(${isAreaHeader ? '0 0 -20px 0' : '-20px 0 0 0'})`, // crop leaking box-shadow on left and right side
	        transition: `${validateProps.getTransition('box-shadow')}`,
	        '&[data-stuck]': {
	            boxShadow: `${validateProps.isThemeDark(theme) ? scrollShadowColorDark : scrollShadowColor} ${boxShadowDimension}`,
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                boxShadow: `${scrollShadowColorDark} ${boxShadowDimension}`,
	            }),
	        },
	    };
	};

	dialogStyles52804ea9.BACKDROPS = BACKDROPS;
	dialogStyles52804ea9.dialogGridJssStyle = dialogGridJssStyle;
	dialogStyles52804ea9.dialogHostJssStyle = dialogHostJssStyle;
	dialogStyles52804ea9.dialogPaddingBlock = dialogPaddingBlock;
	dialogStyles52804ea9.getDialogColorJssStyle = getDialogColorJssStyle;
	dialogStyles52804ea9.getDialogJssStyle = getDialogJssStyle;
	dialogStyles52804ea9.getDialogStickyAreaJssStyle = getDialogStickyAreaJssStyle;
	dialogStyles52804ea9.getDialogTransitionJssStyle = getDialogTransitionJssStyle;
	dialogStyles52804ea9.getScrollerJssStyle = getScrollerJssStyle;
	dialogStyles52804ea9.headingTags = headingTags;
	dialogStyles52804ea9.onCancelDialog = onCancelDialog;
	dialogStyles52804ea9.onClickDialog = onClickDialog;
	dialogStyles52804ea9.onTransitionEnd = onTransitionEnd;
	dialogStyles52804ea9.setDialogVisibility = setDialogVisibility;

	
	return dialogStyles52804ea9;
}

var displaySharedAdef5fa6 = {};

var hasRequiredDisplaySharedAdef5fa6;

function requireDisplaySharedAdef5fa6 () {
	if (hasRequiredDisplaySharedAdef5fa6) return displaySharedAdef5fa6;
	hasRequiredDisplaySharedAdef5fa6 = 1;

	const fontFamily = requireFontFamily23874d28();
	const fontLineHeight = requireFontLineHeightD4b9e1a9();
	const fontWeightRegular = requireFontWeightRegularD0c768ac();
	const fontVariant = requireFontVariant6ba3b7cb();

	const fontSizeDisplayMedium = 'clamp(2.03rem, 3.58vw + 1.31rem, 5.61rem)';

	const _displayFontPartA = `${fontVariant.fontStyleNormal} ${fontVariant.fontVariant} ${fontWeightRegular.fontWeightRegular} `;
	const _displayFontPartB = `/${fontLineHeight.fontLineHeight} ${fontFamily.fontFamily}`;

	displaySharedAdef5fa6._displayFontPartA = _displayFontPartA;
	displaySharedAdef5fa6._displayFontPartB = _displayFontPartB;
	displaySharedAdef5fa6.fontSizeDisplayMedium = fontSizeDisplayMedium;

	
	return displaySharedAdef5fa6;
}

var fieldsetUtils7753153f = {};

var headingShared888aa084 = {};

var fontWeightSemiBold4482c830 = {};

var hasRequiredFontWeightSemiBold4482c830;

function requireFontWeightSemiBold4482c830 () {
	if (hasRequiredFontWeightSemiBold4482c830) return fontWeightSemiBold4482c830;
	hasRequiredFontWeightSemiBold4482c830 = 1;

	const fontWeightSemiBold = 600;

	fontWeightSemiBold4482c830.fontWeightSemiBold = fontWeightSemiBold;

	
	return fontWeightSemiBold4482c830;
}

var hasRequiredHeadingShared888aa084;

function requireHeadingShared888aa084 () {
	if (hasRequiredHeadingShared888aa084) return headingShared888aa084;
	hasRequiredHeadingShared888aa084 = 1;

	const fontFamily = requireFontFamily23874d28();
	const fontLineHeight = requireFontLineHeightD4b9e1a9();
	const fontWeightSemiBold = requireFontWeightSemiBold4482c830();
	const fontVariant = requireFontVariant6ba3b7cb();

	const _headingFontPartA = `${fontVariant.fontStyleNormal} ${fontVariant.fontVariant} ${fontWeightSemiBold.fontWeightSemiBold} `;
	const _headingFontPartB = `/${fontLineHeight.fontLineHeight} ${fontFamily.fontFamily}`;

	headingShared888aa084._headingFontPartA = _headingFontPartA;
	headingShared888aa084._headingFontPartB = _headingFontPartB;

	
	return headingShared888aa084;
}

var fontSizeHeadingMediumC49ab5a2 = {};

var fontSizeTextMedium88887ad8 = {};

var hasRequiredFontSizeTextMedium88887ad8;

function requireFontSizeTextMedium88887ad8 () {
	if (hasRequiredFontSizeTextMedium88887ad8) return fontSizeTextMedium88887ad8;
	hasRequiredFontSizeTextMedium88887ad8 = 1;

	const fontSizeTextMedium = 'clamp(1.13rem, 0.21vw + 1.08rem, 1.33rem)';

	fontSizeTextMedium88887ad8.fontSizeTextMedium = fontSizeTextMedium;

	
	return fontSizeTextMedium88887ad8;
}

var hasRequiredFontSizeHeadingMediumC49ab5a2;

function requireFontSizeHeadingMediumC49ab5a2 () {
	if (hasRequiredFontSizeHeadingMediumC49ab5a2) return fontSizeHeadingMediumC49ab5a2;
	hasRequiredFontSizeHeadingMediumC49ab5a2 = 1;

	const fontSizeTextMedium = requireFontSizeTextMedium88887ad8();

	const fontSizeHeadingMedium = fontSizeTextMedium.fontSizeTextMedium;

	fontSizeHeadingMediumC49ab5a2.fontSizeHeadingMedium = fontSizeHeadingMedium;

	
	return fontSizeHeadingMediumC49ab5a2;
}

var hasRequiredFieldsetUtils7753153f;

function requireFieldsetUtils7753153f () {
	if (hasRequiredFieldsetUtils7753153f) return fieldsetUtils7753153f;
	hasRequiredFieldsetUtils7753153f = 1;

	const headingShared = requireHeadingShared888aa084();
	const fontSizeHeadingMedium = requireFontSizeHeadingMediumC49ab5a2();

	const headingMediumStyle = {
	    font: `${headingShared._headingFontPartA}${fontSizeHeadingMedium.fontSizeHeadingMedium}${headingShared._headingFontPartB}`,
	};

	const FIELDSET_LABEL_SIZES = ['small', 'medium'];

	fieldsetUtils7753153f.FIELDSET_LABEL_SIZES = FIELDSET_LABEL_SIZES;
	fieldsetUtils7753153f.headingMediumStyle = headingMediumStyle;

	
	return fieldsetUtils7753153f;
}

var fontSizeTextStyles4439a071 = {};

var fontSizeTextXXSmallA02f9c40 = {};

var hasRequiredFontSizeTextXXSmallA02f9c40;

function requireFontSizeTextXXSmallA02f9c40 () {
	if (hasRequiredFontSizeTextXXSmallA02f9c40) return fontSizeTextXXSmallA02f9c40;
	hasRequiredFontSizeTextXXSmallA02f9c40 = 1;

	const fontSizeTextXXSmall = '.75rem';

	fontSizeTextXXSmallA02f9c40.fontSizeTextXXSmall = fontSizeTextXXSmall;

	
	return fontSizeTextXXSmallA02f9c40;
}

var fontSizeTextXSmallE59d35d7 = {};

var hasRequiredFontSizeTextXSmallE59d35d7;

function requireFontSizeTextXSmallE59d35d7 () {
	if (hasRequiredFontSizeTextXSmallE59d35d7) return fontSizeTextXSmallE59d35d7;
	hasRequiredFontSizeTextXSmallE59d35d7 = 1;

	const fontSizeTextXSmall = 'clamp(0.81rem, 0.23vw + 0.77rem, 0.88rem)';

	fontSizeTextXSmallE59d35d7.fontSizeTextXSmall = fontSizeTextXSmall;

	
	return fontSizeTextXSmallE59d35d7;
}

var fontSizeTextLarge05a4bc90 = {};

var hasRequiredFontSizeTextLarge05a4bc90;

function requireFontSizeTextLarge05a4bc90 () {
	if (hasRequiredFontSizeTextLarge05a4bc90) return fontSizeTextLarge05a4bc90;
	hasRequiredFontSizeTextLarge05a4bc90 = 1;

	const fontSizeTextLarge = 'clamp(1.27rem, 0.51vw + 1.16rem, 1.78rem)';

	fontSizeTextLarge05a4bc90.fontSizeTextLarge = fontSizeTextLarge;

	
	return fontSizeTextLarge05a4bc90;
}

var fontSizeTextXLarge0ecf9ef3 = {};

var hasRequiredFontSizeTextXLarge0ecf9ef3;

function requireFontSizeTextXLarge0ecf9ef3 () {
	if (hasRequiredFontSizeTextXLarge0ecf9ef3) return fontSizeTextXLarge0ecf9ef3;
	hasRequiredFontSizeTextXLarge0ecf9ef3 = 1;

	const fontSizeTextXLarge = 'clamp(1.42rem, 0.94vw + 1.23rem, 2.37rem)';

	fontSizeTextXLarge0ecf9ef3.fontSizeTextXLarge = fontSizeTextXLarge;

	
	return fontSizeTextXLarge0ecf9ef3;
}

var hasRequiredFontSizeTextStyles4439a071;

function requireFontSizeTextStyles4439a071 () {
	if (hasRequiredFontSizeTextStyles4439a071) return fontSizeTextStyles4439a071;
	hasRequiredFontSizeTextStyles4439a071 = 1;

	const fontSizeTextXXSmall = requireFontSizeTextXXSmallA02f9c40();
	const fontSizeTextXSmall = requireFontSizeTextXSmallE59d35d7();
	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();
	const fontSizeTextMedium = requireFontSizeTextMedium88887ad8();
	const fontSizeTextLarge = requireFontSizeTextLarge05a4bc90();
	const fontSizeTextXLarge = requireFontSizeTextXLarge0ecf9ef3();

	const fontSizeTextMap = {
	    'xx-small': fontSizeTextXXSmall.fontSizeTextXXSmall,
	    'x-small': fontSizeTextXSmall.fontSizeTextXSmall,
	    small: fontSizeTextSmall.fontSizeTextSmall,
	    medium: fontSizeTextMedium.fontSizeTextMedium,
	    large: fontSizeTextLarge.fontSizeTextLarge,
	    'x-large': fontSizeTextXLarge.fontSizeTextXLarge,
	    inherit: 'inherit',
	};
	const getFontSizeText = (size) => {
	    return fontSizeTextMap[size];
	};

	fontSizeTextStyles4439a071.getFontSizeText = getFontSizeText;

	
	return fontSizeTextStyles4439a071;
}

var fontWeightStylesB74e8683 = {};

var hasRequiredFontWeightStylesB74e8683;

function requireFontWeightStylesB74e8683 () {
	if (hasRequiredFontWeightStylesB74e8683) return fontWeightStylesB74e8683;
	hasRequiredFontWeightStylesB74e8683 = 1;

	const fontWeightRegular = requireFontWeightRegularD0c768ac();
	const fontWeightSemiBold = requireFontWeightSemiBold4482c830();

	const fontWeightBold = 700;

	const fontWeightMap = {
	    regular: fontWeightRegular.fontWeightRegular,
	    'semi-bold': fontWeightSemiBold.fontWeightSemiBold,
	    bold: fontWeightBold,
	};
	const getFontWeight = (weight) => {
	    return fontWeightMap[weight];
	};

	fontWeightStylesB74e8683.getFontWeight = getFontWeight;

	
	return fontWeightStylesB74e8683;
}

var fontSizeHeadingLargeC355151d = {};

var hasRequiredFontSizeHeadingLargeC355151d;

function requireFontSizeHeadingLargeC355151d () {
	if (hasRequiredFontSizeHeadingLargeC355151d) return fontSizeHeadingLargeC355151d;
	hasRequiredFontSizeHeadingLargeC355151d = 1;

	const fontSizeTextLarge = requireFontSizeTextLarge05a4bc90();

	const fontSizeHeadingLarge = fontSizeTextLarge.fontSizeTextLarge;

	fontSizeHeadingLargeC355151d.fontSizeHeadingLarge = fontSizeHeadingLarge;

	
	return fontSizeHeadingLargeC355151d;
}

var fontSizeHeadingSmallA15141a5 = {};

var hasRequiredFontSizeHeadingSmallA15141a5;

function requireFontSizeHeadingSmallA15141a5 () {
	if (hasRequiredFontSizeHeadingSmallA15141a5) return fontSizeHeadingSmallA15141a5;
	hasRequiredFontSizeHeadingSmallA15141a5 = 1;

	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();

	const fontSizeHeadingSmall = fontSizeTextSmall.fontSizeTextSmall;

	fontSizeHeadingSmallA15141a5.fontSizeHeadingSmall = fontSizeHeadingSmall;

	
	return fontSizeHeadingSmallA15141a5;
}

var fontSizeText728b6387 = {};

var hasRequiredFontSizeText728b6387;

function requireFontSizeText728b6387 () {
	if (hasRequiredFontSizeText728b6387) return fontSizeText728b6387;
	hasRequiredFontSizeText728b6387 = 1;

	const fontSizeTextXXSmall = requireFontSizeTextXXSmallA02f9c40();
	const fontSizeTextXSmall = requireFontSizeTextXSmallE59d35d7();
	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();
	const fontSizeTextMedium = requireFontSizeTextMedium88887ad8();
	const fontSizeTextLarge = requireFontSizeTextLarge05a4bc90();
	const fontSizeTextXLarge = requireFontSizeTextXLarge0ecf9ef3();

	const fontSizeText = {
	    xxSmall: fontSizeTextXXSmall.fontSizeTextXXSmall,
	    xSmall: fontSizeTextXSmall.fontSizeTextXSmall,
	    small: fontSizeTextSmall.fontSizeTextSmall,
	    medium: fontSizeTextMedium.fontSizeTextMedium,
	    large: fontSizeTextLarge.fontSizeTextLarge,
	    xLarge: fontSizeTextXLarge.fontSizeTextXLarge,
	};

	fontSizeText728b6387.fontSizeText = fontSizeText;

	
	return fontSizeText728b6387;
}

var forcedColorsMediaQuery69d5b1ca = {};

var hasRequiredForcedColorsMediaQuery69d5b1ca;

function requireForcedColorsMediaQuery69d5b1ca () {
	if (hasRequiredForcedColorsMediaQuery69d5b1ca) return forcedColorsMediaQuery69d5b1ca;
	hasRequiredForcedColorsMediaQuery69d5b1ca = 1;

	const forcedColorsMediaQuery = (style) => {
	    return { '@media (forced-colors: active)': style };
	};

	forcedColorsMediaQuery69d5b1ca.forcedColorsMediaQuery = forcedColorsMediaQuery;

	
	return forcedColorsMediaQuery69d5b1ca;
}

var formStylesDeecb9a1 = {};

var spacingStaticSmall2130ed04 = {};

var hasRequiredSpacingStaticSmall2130ed04;

function requireSpacingStaticSmall2130ed04 () {
	if (hasRequiredSpacingStaticSmall2130ed04) return spacingStaticSmall2130ed04;
	hasRequiredSpacingStaticSmall2130ed04 = 1;

	const spacingStaticSmall = '8px';

	spacingStaticSmall2130ed04.spacingStaticSmall = spacingStaticSmall;

	
	return spacingStaticSmall2130ed04;
}

var hasRequiredFormStylesDeecb9a1;

function requireFormStylesDeecb9a1 () {
	if (hasRequiredFormStylesDeecb9a1) return formStylesDeecb9a1;
	hasRequiredFormStylesDeecb9a1 = 1;

	const validateProps = requireValidateProps788e2bc5();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const stateMessageStyles = requireStateMessageStylesD1c4637f();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();
	const fontLineHeight = requireFontLineHeightD4b9e1a9();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const textSmallStyle = requireTextSmallStyle00e1c6e2();

	const getSlottedTextFieldTextareaSelectStyles = (child, state, isLoading, theme, additionalDefaultJssStyle) => {
	    const { primaryColor, contrastLowColor, contrastMediumColor, disabledColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, contrastLowColor: contrastLowColorDark, contrastMediumColor: contrastMediumColorDark, disabledColor: disabledColorDark, } = validateProps.getThemedColors('dark');
	    const { formStateColor, formStateHoverColor } = stateMessageStyles.getThemedFormStateColors(theme, state);
	    const { formStateColor: formStateColorDark, formStateHoverColor: formStateHoverColorDark } = stateMessageStyles.getThemedFormStateColors('dark', state);
	    return {
	        [`::slotted(${child})`]: {
	            display: 'block',
	            width: '100%',
	            height: child !== 'textarea'
	                ? `calc(${fontLineHeight.fontLineHeight} + 10px + ${validateProps.borderWidthBase} * 2 + ${spacingStaticSmall.spacingStaticSmall} * 2)` // we need 10px additionally so input height becomes 54px
	                : 'auto',
	            margin: 0,
	            outline: 0,
	            WebkitAppearance: 'none', // iOS safari
	            appearance: 'none',
	            boxSizing: 'border-box',
	            border: `${validateProps.borderWidthBase} solid ${formStateColor || contrastMediumColor}`,
	            borderRadius: borderRadiusSmall.borderRadiusSmall,
	            background: 'transparent',
	            font: textSmallStyle.textSmallStyle.font.replace('ex', 'ex + 6px'), // a minimum line-height is needed for input, otherwise value is scrollable in Chrome, +6px is aligned with how Safari visualize date/time input highlighting
	            textIndent: 0,
	            color: primaryColor,
	            transition: `${validateProps.getTransition('background-color')}, ${validateProps.getTransition('border-color')}, ${validateProps.getTransition('color')}`, // for smooth transitions between e.g. disabled states
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                borderColor: formStateColorDark || contrastMediumColorDark,
	                color: primaryColorDark,
	            }),
	            ...additionalDefaultJssStyle,
	        },
	        '::slotted(:not(input[type="password"]))': {
	            textOverflow: 'ellipsis',
	        },
	        ...(!isLoading &&
	            hoverMediaQuery.hoverMediaQuery({
	                // with the media query the selector has higher priority and overrides disabled styles
	                [`::slotted(${child}:not(:disabled):not(:focus):not([readonly]):hover),label:hover~.wrapper ::slotted(${child}:not(:disabled):not(:focus):not([readonly]))${child === 'select' ? ',label:hover~.wrapper ::part(select-wrapper-dropdown)' : ''}`]: {
	                    borderColor: formStateHoverColor || primaryColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        borderColor: formStateHoverColorDark || primaryColorDark,
	                    }),
	                },
	            })),
	        // TODO: getFocusJssStyle() can't be re-used because focus style differs for form elements
	        [`::slotted(${child}:focus)`]: {
	            borderColor: primaryColor,
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                borderColor: primaryColorDark,
	            }),
	        },
	        [`::slotted(${child}:disabled)`]: {
	            cursor: 'not-allowed',
	            color: disabledColor,
	            borderColor: disabledColor,
	            WebkitTextFillColor: disabledColor,
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                color: disabledColorDark,
	                borderColor: disabledColorDark,
	                WebkitTextFillColor: disabledColorDark,
	            }),
	        },
	        ...(child !== 'select' && {
	            [`::slotted(${child}[readonly])`]: {
	                borderColor: contrastLowColor,
	                background: contrastLowColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    borderColor: contrastLowColorDark,
	                    background: contrastLowColorDark,
	                }),
	            },
	        }),
	    };
	};
	const formElementLayeredGap = '9px'; // to have same distance vertically and horizontally for e.g. button/icon within form element
	const formElementLayeredSafeZone = `calc(${formElementLayeredGap} + ${validateProps.borderWidthBase})`;
	// TODO: basic button/icon padding can already be set within style function instead of on component style level
	const formButtonOrIconPadding = spacingStaticXSmall.spacingStaticXSmall;
	// TODO: if we'd use 12px instead, it wouldn't be necessary for textarea to have a custom vertical padding,
	//  unfortunately line-height alignment breaks for a select element for some reasons then
	// TODO: basic form element padding can already be set within style function instead of on component style level
	const formElementPaddingVertical = spacingStaticSmall.spacingStaticSmall;
	// TODO: basic form element padding can already be set within style function instead of on component style level
	const formElementPaddingHorizontal = spacingStaticMedium.spacingStaticMedium;
	const getCalculatedFormElementPaddingHorizontal = (buttonOrIconAmount) => {
	    // when applied, font-family and font-size needs to be set too for correct calculation of ex-unit ($fontLineHeight)
	    return `calc(${formElementLayeredGap} + ${formElementPaddingHorizontal} / 2 + (${fontLineHeight.fontLineHeight} + ${formButtonOrIconPadding} * 2) * ${buttonOrIconAmount})`;
	};
	// TODO: re-use in textarea-wrapper not only in text-field-wrapper
	const getUnitCounterJssStyle = (isDisabled, isReadonly, theme) => {
	    const { disabledColor, contrastMediumColor, contrastHighColor } = validateProps.getThemedColors(theme);
	    const { disabledColor: disabledColorDark, contrastMediumColor: contrastMediumColorDark } = validateProps.getThemedColors('dark');
	    return {
	        pointerEvents: 'none',
	        maxWidth: '100%',
	        boxSizing: 'border-box',
	        whiteSpace: 'nowrap',
	        overflow: 'hidden',
	        textOverflow: 'ellipsis',
	        font: textSmallStyle.textSmallStyle.font,
	        color: contrastMediumColor,
	        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	            color: contrastMediumColorDark,
	        }),
	        ...(isDisabled && {
	            color: disabledColor,
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                color: disabledColorDark,
	            }),
	        }),
	        ...(isReadonly && {
	            color: contrastHighColor,
	        })
	    };
	};

	formStylesDeecb9a1.formButtonOrIconPadding = formButtonOrIconPadding;
	formStylesDeecb9a1.formElementLayeredGap = formElementLayeredGap;
	formStylesDeecb9a1.formElementLayeredSafeZone = formElementLayeredSafeZone;
	formStylesDeecb9a1.formElementPaddingHorizontal = formElementPaddingHorizontal;
	formStylesDeecb9a1.formElementPaddingVertical = formElementPaddingVertical;
	formStylesDeecb9a1.getCalculatedFormElementPaddingHorizontal = getCalculatedFormElementPaddingHorizontal;
	formStylesDeecb9a1.getSlottedTextFieldTextareaSelectStyles = getSlottedTextFieldTextareaSelectStyles;
	formStylesDeecb9a1.getUnitCounterJssStyle = getUnitCounterJssStyle;

	
	return formStylesDeecb9a1;
}

var formUtils876806ab = {};

var hasRequiredFormUtils876806ab;

function requireFormUtils876806ab () {
	if (hasRequiredFormUtils876806ab) return formUtils876806ab;
	hasRequiredFormUtils876806ab = 1;

	const hasCounter = (el) => el && el.maxLength >= 0;
	// https://javascript.info/currying-partials
	const inputEventListenerCurry = (characterCountElement, counterElement, inputChangeCallback) => {
	    // returns actual listener function
	    return (e) => {
	        updateCounter(e.target, characterCountElement, counterElement, inputChangeCallback);
	    };
	};
	const updateCounter = (el, characterCountElement, counterElement, inputChangeCallback) => {
	    if (counterElement) {
	        setCounterInnerHtml(el, counterElement);
	    }
	    setAriaElementInnerHtml(el, characterCountElement);
	    inputChangeCallback?.();
	};
	const setCounterInnerHtml = (el, counterElement) => {
	    counterElement.innerText = `${el.value.length}/${el.maxLength}`;
	};
	// eslint-disable-next-line prefer-arrow/prefer-arrow-functions
	function debounce(fn, ms = 800) {
	    let timeoutId;
	    return function (...args) {
	        if (timeoutId) {
	            clearTimeout(timeoutId);
	        }
	        timeoutId = setTimeout(() => fn.apply(this, args), ms);
	    };
	}
	const setAriaElementInnerHtml = debounce((el, ariaElement) => {
	    ariaElement.innerText = `You have ${el.maxLength - el.value.length} out of ${el.maxLength} characters left`;
	});

	formUtils876806ab.debounce = debounce;
	formUtils876806ab.hasCounter = hasCounter;
	formUtils876806ab.inputEventListenerCurry = inputEventListenerCurry;
	formUtils876806ab.updateCounter = updateCounter;

	
	return formUtils876806ab;
}

var getButtonBaseAriaAttributes84dbc1f1 = {};

var hasRequiredGetButtonBaseAriaAttributes84dbc1f1;

function requireGetButtonBaseAriaAttributes84dbc1f1 () {
	if (hasRequiredGetButtonBaseAriaAttributes84dbc1f1) return getButtonBaseAriaAttributes84dbc1f1;
	hasRequiredGetButtonBaseAriaAttributes84dbc1f1 = 1;

	requireValidateProps788e2bc5();
	const isDisabledOrLoading = requireIsDisabledOrLoadingB1f56d7f();

	const getButtonBaseAriaAttributes = (isDisabled, isLoading) => {
	    return {
	        'aria-disabled': isDisabledOrLoading.isDisabledOrLoading(isDisabled, isLoading) ? 'true' : null,
	    };
	};

	getButtonBaseAriaAttributes84dbc1f1.getButtonBaseAriaAttributes = getButtonBaseAriaAttributes;

	
	return getButtonBaseAriaAttributes84dbc1f1;
}

var getAttribute9c66ed26 = {};

var hasRequiredGetAttribute9c66ed26;

function requireGetAttribute9c66ed26 () {
	if (hasRequiredGetAttribute9c66ed26) return getAttribute9c66ed26;
	hasRequiredGetAttribute9c66ed26 = 1;

	const getAttribute = (el, attributeName) => {
	    return el.getAttribute(attributeName);
	};

	getAttribute9c66ed26.getAttribute = getAttribute;

	
	return getAttribute9c66ed26;
}

var getDirectChildHTMLElement18d9487f = {};

var transformSelectorToDirectChildSelectorEcc1a9c4 = {};

var hasRequiredTransformSelectorToDirectChildSelectorEcc1a9c4;

function requireTransformSelectorToDirectChildSelectorEcc1a9c4 () {
	if (hasRequiredTransformSelectorToDirectChildSelectorEcc1a9c4) return transformSelectorToDirectChildSelectorEcc1a9c4;
	hasRequiredTransformSelectorToDirectChildSelectorEcc1a9c4 = 1;

	const transformSelectorToDirectChildSelector = (selector) => selector
	    .split(',')
	    .map((part) => `:scope>${part}`)
	    .join();

	transformSelectorToDirectChildSelectorEcc1a9c4.transformSelectorToDirectChildSelector = transformSelectorToDirectChildSelector;

	
	return transformSelectorToDirectChildSelectorEcc1a9c4;
}

var hasRequiredGetDirectChildHTMLElement18d9487f;

function requireGetDirectChildHTMLElement18d9487f () {
	if (hasRequiredGetDirectChildHTMLElement18d9487f) return getDirectChildHTMLElement18d9487f;
	hasRequiredGetDirectChildHTMLElement18d9487f = 1;

	const validateProps = requireValidateProps788e2bc5();
	const transformSelectorToDirectChildSelector = requireTransformSelectorToDirectChildSelectorEcc1a9c4();

	/* eslint-disable prefer-arrow/prefer-arrow-functions */
	function getDirectChildHTMLElement(element, selector) {
	    // querySelector(All) doesn't work with :scope pseudo class and comma separator in jsdom, yet
	    // https://github.com/jsdom/jsdom/issues/3141
	    // therefore we got a workaround so it works nicely when consumed from jsdom-polyfill package
	    return (transformSelectorToDirectChildSelector.transformSelectorToDirectChildSelector(selector)
	        .split(',')
	        .map((sel) => validateProps.getHTMLElement(element, sel))
	        .filter((x) => x)[0] || null // comma separated selector might return null, so we have to filter
	    );
	}

	getDirectChildHTMLElement18d9487f.getDirectChildHTMLElement = getDirectChildHTMLElement;

	
	return getDirectChildHTMLElement18d9487f;
}

var getDirectChildHTMLElements2594e5bd = {};

var getHTMLElements3f1c700f = {};

var hasRequiredGetHTMLElements3f1c700f;

function requireGetHTMLElements3f1c700f () {
	if (hasRequiredGetHTMLElements3f1c700f) return getHTMLElements3f1c700f;
	hasRequiredGetHTMLElements3f1c700f = 1;

	function getHTMLElements(element, selector) {
	    return element ? Array.from(element.querySelectorAll(selector)) : [];
	}

	getHTMLElements3f1c700f.getHTMLElements = getHTMLElements;

	
	return getHTMLElements3f1c700f;
}

var hasRequiredGetDirectChildHTMLElements2594e5bd;

function requireGetDirectChildHTMLElements2594e5bd () {
	if (hasRequiredGetDirectChildHTMLElements2594e5bd) return getDirectChildHTMLElements2594e5bd;
	hasRequiredGetDirectChildHTMLElements2594e5bd = 1;

	const getHTMLElements = requireGetHTMLElements3f1c700f();
	const transformSelectorToDirectChildSelector = requireTransformSelectorToDirectChildSelectorEcc1a9c4();

	/* eslint-disable prefer-arrow/prefer-arrow-functions */
	function getDirectChildHTMLElements(element, selector) {
	    // querySelector(All) doesn't work with :scope pseudo class and comma separator in jsdom, yet
	    // https://github.com/jsdom/jsdom/issues/3141
	    // therefore we got a workaround, so it works nicely when consumed from jsdom-polyfill package
	    return transformSelectorToDirectChildSelector.transformSelectorToDirectChildSelector(selector)
	        .split(',')
	        .flatMap((sel) => getHTMLElements.getHTMLElements(element, sel)); // might contain duplicates
	}

	getDirectChildHTMLElements2594e5bd.getDirectChildHTMLElements = getDirectChildHTMLElements;

	
	return getDirectChildHTMLElements2594e5bd;
}

var getInlineSVGBackgroundImageB65404d9 = {};

var hasRequiredGetInlineSVGBackgroundImageB65404d9;

function requireGetInlineSVGBackgroundImageB65404d9 () {
	if (hasRequiredGetInlineSVGBackgroundImageB65404d9) return getInlineSVGBackgroundImageB65404d9;
	hasRequiredGetInlineSVGBackgroundImageB65404d9 = 1;

	const escapeHashCharacter = (colorString) => {
	    return colorString.replace('#', '%23');
	};

	const getInlineSVGBackgroundImage = (path) => {
	    return `url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">${path}</svg>')`;
	};

	getInlineSVGBackgroundImageB65404d9.escapeHashCharacter = escapeHashCharacter;
	getInlineSVGBackgroundImageB65404d9.getInlineSVGBackgroundImage = getInlineSVGBackgroundImage;

	
	return getInlineSVGBackgroundImageB65404d9;
}

var getMediaQueryMax5b73ea17 = {};

var hasRequiredGetMediaQueryMax5b73ea17;

function requireGetMediaQueryMax5b73ea17 () {
	if (hasRequiredGetMediaQueryMax5b73ea17) return getMediaQueryMax5b73ea17;
	hasRequiredGetMediaQueryMax5b73ea17 = 1;

	const validateProps = requireValidateProps788e2bc5();

	function getMediaQueryMax(max) {
	    return `@media(max-width:${validateProps.breakpoint[max] - 1}px)`;
	}

	getMediaQueryMax5b73ea17.getMediaQueryMax = getMediaQueryMax;

	
	return getMediaQueryMax5b73ea17;
}

var getOnlyChildOfKindHTMLElementOrThrowCdb95e52 = {};

var hasRequiredGetOnlyChildOfKindHTMLElementOrThrowCdb95e52;

function requireGetOnlyChildOfKindHTMLElementOrThrowCdb95e52 () {
	if (hasRequiredGetOnlyChildOfKindHTMLElementOrThrowCdb95e52) return getOnlyChildOfKindHTMLElementOrThrowCdb95e52;
	hasRequiredGetOnlyChildOfKindHTMLElementOrThrowCdb95e52 = 1;

	const validateProps = requireValidateProps788e2bc5();
	const getDirectChildHTMLElements = requireGetDirectChildHTMLElements2594e5bd();

	/* eslint-disable prefer-arrow/prefer-arrow-functions */
	function getOnlyChildOfKindHTMLElementOrThrow(element, selector) {
	    // we need to support named slots for label/description or message, hence we can't verify element.children.length
	    const directChildren = getDirectChildHTMLElements.getDirectChildHTMLElements(element, selector);
	    if (directChildren.length !== 1) {
	        validateProps.throwException(`${validateProps.getTagNameWithoutPrefix(element)} has to contain a single direct child of: ${selector}`);
	    }
	    return directChildren[0];
	}

	getOnlyChildOfKindHTMLElementOrThrowCdb95e52.getOnlyChildOfKindHTMLElementOrThrow = getOnlyChildOfKindHTMLElementOrThrow;

	
	return getOnlyChildOfKindHTMLElementOrThrowCdb95e52;
}

var getSlotTextContent3ec731e2 = {};

var hasRequiredGetSlotTextContent3ec731e2;

function requireGetSlotTextContent3ec731e2 () {
	if (hasRequiredGetSlotTextContent3ec731e2) return getSlotTextContent3ec731e2;
	hasRequiredGetSlotTextContent3ec731e2 = 1;

	const validateProps = requireValidateProps788e2bc5();

	const getSlotTextContent = (el, slotName) => validateProps.getHTMLElement(el, `[slot="${slotName}"]`)?.textContent;

	getSlotTextContent3ec731e2.getSlotTextContent = getSlotTextContent;

	
	return getSlotTextContent3ec731e2;
}

var gridBasicOffset92343778 = {};

var gridExtendedOffsetBaseFb9830f6 = {};

var hasRequiredGridExtendedOffsetBaseFb9830f6;

function requireGridExtendedOffsetBaseFb9830f6 () {
	if (hasRequiredGridExtendedOffsetBaseFb9830f6) return gridExtendedOffsetBaseFb9830f6;
	hasRequiredGridExtendedOffsetBaseFb9830f6 = 1;

	const _gridWidthMax = '2560px';
	// fluid sizing calculated by https://fluidtypography.com/#app-get-started
	const _gridSafeZoneBase = 'max(22px, 10.625vw - 12px)'; // viewport-width range = 320 - 760px / size range = 22 - 68.75px
	const _gridSafeZoneS = 'calc(5vw - 16px)'; // viewport-width range = 760 - 1920px / size range = 22(22.75) - 80(79.71)px
	const _gridSafeZoneXXL = 'min(50vw - 880px, 400px)'; // viewport-width range = 1920 - 2560px / size range = 80(79.71)px - 400(399.71)px

	const gridExtendedOffsetBase = _gridSafeZoneBase;

	gridExtendedOffsetBaseFb9830f6._gridSafeZoneBase = _gridSafeZoneBase;
	gridExtendedOffsetBaseFb9830f6._gridSafeZoneS = _gridSafeZoneS;
	gridExtendedOffsetBaseFb9830f6._gridSafeZoneXXL = _gridSafeZoneXXL;
	gridExtendedOffsetBaseFb9830f6._gridWidthMax = _gridWidthMax;
	gridExtendedOffsetBaseFb9830f6.gridExtendedOffsetBase = gridExtendedOffsetBase;

	
	return gridExtendedOffsetBaseFb9830f6;
}

var gridExtendedOffsetXXLC7a41e50 = {};

var hasRequiredGridExtendedOffsetXXLC7a41e50;

function requireGridExtendedOffsetXXLC7a41e50 () {
	if (hasRequiredGridExtendedOffsetXXLC7a41e50) return gridExtendedOffsetXXLC7a41e50;
	hasRequiredGridExtendedOffsetXXLC7a41e50 = 1;

	const gridExtendedOffsetBase = requireGridExtendedOffsetBaseFb9830f6();
	const gridGap = requireGridGapB5b73e4a();

	const columnMap = {
	    narrow: 4,
	    basic: 2,
	    extended: 1,
	};
	const gridColumnWidthS = `calc((100vw - ${gridExtendedOffsetBase._gridSafeZoneS} * 2 - ${gridGap.gridGap} * 15) / 16)`;
	const gridColumnWidthXXL = `calc((min(100vw, ${gridExtendedOffsetBase._gridWidthMax}) - ${gridExtendedOffsetBase._gridSafeZoneXXL} * 2 - ${gridGap.gridGap} * 15) / 16)`;
	const _gridPadding = `max(0px, 50vw - ${gridExtendedOffsetBase._gridWidthMax} / 2)`;
	const _getGridOffsetS = (width) => `calc(${gridExtendedOffsetBase._gridSafeZoneS} + (${gridGap.gridGap} + ${gridColumnWidthS}) * ${columnMap[width]})`;
	const _getGridOffsetXXL = (width) => `calc(${_gridPadding} + ${gridExtendedOffsetBase._gridSafeZoneXXL} + (${gridGap.gridGap} + ${gridColumnWidthXXL}) * ${columnMap[width]})`;

	const gridExtendedOffsetS = _getGridOffsetS('extended');

	const gridExtendedOffsetXXL = _getGridOffsetXXL('extended');

	gridExtendedOffsetXXLC7a41e50._getGridOffsetS = _getGridOffsetS;
	gridExtendedOffsetXXLC7a41e50._getGridOffsetXXL = _getGridOffsetXXL;
	gridExtendedOffsetXXLC7a41e50._gridPadding = _gridPadding;
	gridExtendedOffsetXXLC7a41e50.gridExtendedOffsetS = gridExtendedOffsetS;
	gridExtendedOffsetXXLC7a41e50.gridExtendedOffsetXXL = gridExtendedOffsetXXL;

	
	return gridExtendedOffsetXXLC7a41e50;
}

var hasRequiredGridBasicOffset92343778;

function requireGridBasicOffset92343778 () {
	if (hasRequiredGridBasicOffset92343778) return gridBasicOffset92343778;
	hasRequiredGridBasicOffset92343778 = 1;

	const gridExtendedOffsetBase = requireGridExtendedOffsetBaseFb9830f6();
	const gridExtendedOffsetXXL = requireGridExtendedOffsetXXLC7a41e50();

	const gridExtendedOffset = {
	    base: gridExtendedOffsetBase.gridExtendedOffsetBase,
	    s: gridExtendedOffsetXXL.gridExtendedOffsetS,
	    xxl: gridExtendedOffsetXXL.gridExtendedOffsetXXL,
	};

	const gridBasicOffsetBase = gridExtendedOffsetBase._gridSafeZoneBase;

	const gridBasicOffsetS = gridExtendedOffsetXXL._getGridOffsetS('basic');

	const gridBasicOffsetXXL = gridExtendedOffsetXXL._getGridOffsetXXL('basic');

	const gridBasicOffset = {
	    base: gridBasicOffsetBase,
	    s: gridBasicOffsetS,
	    xxl: gridBasicOffsetXXL,
	};

	gridBasicOffset92343778.gridBasicOffset = gridBasicOffset;
	gridBasicOffset92343778.gridExtendedOffset = gridExtendedOffset;

	
	return gridBasicOffset92343778;
}

var groupDirectionStylesC4bd8b11 = {};

var hasRequiredGroupDirectionStylesC4bd8b11;

function requireGroupDirectionStylesC4bd8b11 () {
	if (hasRequiredGroupDirectionStylesC4bd8b11) return groupDirectionStylesC4bd8b11;
	hasRequiredGroupDirectionStylesC4bd8b11 = 1;

	const GROUP_DIRECTIONS = ['row', 'column'];
	const groupDirectionJssStyles = {
	    column: {
	        flexFlow: 'column nowrap',
	        alignItems: 'stretch',
	    },
	    row: {
	        flexFlow: 'row wrap',
	        alignItems: 'center',
	    },
	};
	const getGroupDirectionJssStyles = (direction) => {
	    return groupDirectionJssStyles[direction];
	};

	groupDirectionStylesC4bd8b11.GROUP_DIRECTIONS = GROUP_DIRECTIONS;
	groupDirectionStylesC4bd8b11.getGroupDirectionJssStyles = getGroupDirectionJssStyles;

	
	return groupDirectionStylesC4bd8b11;
}

var hasDocument079654e6 = {};

var hasRequiredHasDocument079654e6;

function requireHasDocument079654e6 () {
	if (hasRequiredHasDocument079654e6) return hasDocument079654e6;
	hasRequiredHasDocument079654e6 = 1;

	const hasDocument = typeof document !== 'undefined';

	hasDocument079654e6.hasDocument = hasDocument;

	
	return hasDocument079654e6;
}

var hasAttributeBf22c03a = {};

var hasRequiredHasAttributeBf22c03a;

function requireHasAttributeBf22c03a () {
	if (hasRequiredHasAttributeBf22c03a) return hasAttributeBf22c03a;
	hasRequiredHasAttributeBf22c03a = 1;

	const hasAttribute = (el, attributeName) => {
	    return el.hasAttribute(attributeName);
	};

	hasAttributeBf22c03a.hasAttribute = hasAttribute;

	
	return hasAttributeBf22c03a;
}

var hasDescription050833e0 = {};

var hasRequiredHasDescription050833e0;

function requireHasDescription050833e0 () {
	if (hasRequiredHasDescription050833e0) return hasDescription050833e0;
	hasRequiredHasDescription050833e0 = 1;

	requireValidateProps788e2bc5();
	const hasNamedSlot = requireHasNamedSlot273cd3ae();

	const hasDescription = (element, description) => {
	    return !!description || hasNamedSlot.hasNamedSlot(element, 'description');
	};

	hasDescription050833e0.hasDescription = hasDescription;

	
	return hasDescription050833e0;
}

var hasHeading5ac42b7f = {};

var hasRequiredHasHeading5ac42b7f;

function requireHasHeading5ac42b7f () {
	if (hasRequiredHasHeading5ac42b7f) return hasHeading5ac42b7f;
	hasRequiredHasHeading5ac42b7f = 1;

	requireValidateProps788e2bc5();
	const hasNamedSlot = requireHasNamedSlot273cd3ae();

	const hasHeading = (element, heading) => {
	    return !!heading || hasNamedSlot.hasNamedSlot(element, 'heading');
	};

	hasHeading5ac42b7f.hasHeading = hasHeading;

	
	return hasHeading5ac42b7f;
}

var headingTag6cfe20fe = {};

var hasRequiredHeadingTag6cfe20fe;

function requireHeadingTag6cfe20fe () {
	if (hasRequiredHeadingTag6cfe20fe) return headingTag6cfe20fe;
	hasRequiredHeadingTag6cfe20fe = 1;

	const HEADING_TAGS = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];

	headingTag6cfe20fe.HEADING_TAGS = HEADING_TAGS;

	
	return headingTag6cfe20fe;
}

var headingSmallStyle43f95761 = {};

var hasRequiredHeadingSmallStyle43f95761;

function requireHeadingSmallStyle43f95761 () {
	if (hasRequiredHeadingSmallStyle43f95761) return headingSmallStyle43f95761;
	hasRequiredHeadingSmallStyle43f95761 = 1;

	const headingShared = requireHeadingShared888aa084();
	const fontSizeHeadingSmall = requireFontSizeHeadingSmallA15141a5();

	const headingSmallStyle = {
	    font: `${headingShared._headingFontPartA}${fontSizeHeadingSmall.fontSizeHeadingSmall}${headingShared._headingFontPartB}`,
	};

	headingSmallStyle43f95761.headingSmallStyle = headingSmallStyle;

	
	return headingSmallStyle43f95761;
}

var headingXXLargeStyle0857cde1 = {};

var hasRequiredHeadingXXLargeStyle0857cde1;

function requireHeadingXXLargeStyle0857cde1 () {
	if (hasRequiredHeadingXXLargeStyle0857cde1) return headingXXLargeStyle0857cde1;
	hasRequiredHeadingXXLargeStyle0857cde1 = 1;

	const fontSizeTextXLarge = requireFontSizeTextXLarge0ecf9ef3();
	const headingShared = requireHeadingShared888aa084();

	const fontSizeHeadingXLarge = fontSizeTextXLarge.fontSizeTextXLarge;

	const fontSizeHeadingXXLarge = 'clamp(1.6rem, 1.56vw + 1.29rem, 3.16rem)';

	const headingXXLargeStyle = {
	    font: `${headingShared._headingFontPartA}${fontSizeHeadingXXLarge}${headingShared._headingFontPartB}`,
	};

	headingXXLargeStyle0857cde1.fontSizeHeadingXLarge = fontSizeHeadingXLarge;
	headingXXLargeStyle0857cde1.fontSizeHeadingXXLarge = fontSizeHeadingXXLarge;
	headingXXLargeStyle0857cde1.headingXXLargeStyle = headingXXLargeStyle;

	
	return headingXXLargeStyle0857cde1;
}

var helper22e15c0e = {};

var hasRequiredHelper22e15c0e;

function requireHelper22e15c0e () {
	if (hasRequiredHelper22e15c0e) return helper22e15c0e;
	hasRequiredHelper22e15c0e = 1;

	const validateProps = requireValidateProps788e2bc5();

	const getDeprecatedPropOrSlotWarningMessage = (host, propOrSlot) => `${propOrSlot} is deprecated for component ${validateProps.getTagNameWithoutPrefix(host)} and will be removed with next major release.`;

	helper22e15c0e.getDeprecatedPropOrSlotWarningMessage = getDeprecatedPropOrSlotWarningMessage;

	
	return helper22e15c0e;
}

var index_cjs = {};

var hasRequiredIndex_cjs;

function requireIndex_cjs () {
	if (hasRequiredIndex_cjs) return index_cjs;
	hasRequiredIndex_cjs = 1;


	
	return index_cjs;
}

var inlineNotificationUtilsFb9eaa4e = {};

var hasRequiredInlineNotificationUtilsFb9eaa4e;

function requireInlineNotificationUtilsFb9eaa4e () {
	if (hasRequiredInlineNotificationUtilsFb9eaa4e) return inlineNotificationUtilsFb9eaa4e;
	hasRequiredInlineNotificationUtilsFb9eaa4e = 1;

	const validateProps = requireValidateProps788e2bc5();
	const getMediaQueryMax = requireGetMediaQueryMax5b73ea17();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const bannerUtils = requireBannerUtils2cc83734();

	const mediaQueryMinS = validateProps.getMediaQueryMin('s');
	const mediaQueryMaxS = getMediaQueryMax.getMediaQueryMax('s');
	const getBackgroundColor = (state, theme) => {
	    const { infoSoftColor, successSoftColor, errorSoftColor, warningSoftColor } = validateProps.getThemedColors(theme);
	    const colorMap = {
	        neutral: infoSoftColor, // deprecated
	        info: infoSoftColor,
	        warning: warningSoftColor,
	        success: successSoftColor,
	        error: errorSoftColor,
	    };
	    return colorMap[state];
	};
	const getNotificationRootJssStyle = (state, hasAction, hasClose, theme) => {
	    return {
	        // display: 'grid', // NOTE: display property is moved into component styled to not apply !important keyword
	        // 2 columns for content and optional close button
	        gridTemplateColumns: `minmax(auto, 1fr)${hasClose ? ' auto' : ''}`,
	        gap: spacingStaticMedium.spacingStaticMedium,
	        placeItems: 'start',
	        padding: spacingStaticMedium.spacingStaticMedium,
	        background: getBackgroundColor(state, theme),
	        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	            background: getBackgroundColor(state, 'dark'),
	        }),
	        borderRadius: borderRadiusSmall.borderRadiusSmall,
	        ...(validateProps.isHighContrastMode && {
	            outline: '1px solid transparent',
	        }),
	        [mediaQueryMinS]: {
	            // 4 columns are for icon, content, optional action button and optional close button
	            gridTemplateColumns: `auto minmax(auto, 1fr)${hasAction ? ' auto' : ''}${hasClose ? ' auto' : ''}`,
	        },
	    };
	};
	const getNotificationIconJssStyle = () => ({
	    marginTop: '2px', // To be center aligned with close button
	    [mediaQueryMaxS]: {
	        display: 'none',
	    },
	});
	const getNotificationContentJssStyle = () => ({
	    display: 'grid',
	    gap: spacingStaticXSmall.spacingStaticXSmall,
	    maxWidth: '50rem',
	    marginTop: '2px', // To be center aligned with close button
	    [mediaQueryMinS]: {
	        marginLeft: `-${spacingStaticSmall.spacingStaticSmall}`,
	    },
	});

	const INLINE_NOTIFICATION_STATES = ['success', ...bannerUtils.BANNER_STATES];
	const getInlineNotificationIconName = (state) => {
	    const stateToIconMap = {
	        neutral: 'information-filled', // deprecated
	        info: 'information-filled',
	        warning: 'warning-filled',
	        success: 'success-filled',
	        error: 'error-filled',
	    };
	    return stateToIconMap[state];
	};
	const getContentAriaAttributes = (state, labelId, descriptionId) => {
	    const isAlert = state === 'warning' || state === 'error';
	    return {
	        role: isAlert ? 'alert' : 'status',
	        'aria-live': isAlert ? 'assertive' : 'polite',
	        'aria-labelledby': labelId,
	        'aria-describedby': descriptionId,
	    };
	};

	inlineNotificationUtilsFb9eaa4e.INLINE_NOTIFICATION_STATES = INLINE_NOTIFICATION_STATES;
	inlineNotificationUtilsFb9eaa4e.getContentAriaAttributes = getContentAriaAttributes;
	inlineNotificationUtilsFb9eaa4e.getInlineNotificationIconName = getInlineNotificationIconName;
	inlineNotificationUtilsFb9eaa4e.getNotificationContentJssStyle = getNotificationContentJssStyle;
	inlineNotificationUtilsFb9eaa4e.getNotificationIconJssStyle = getNotificationIconJssStyle;
	inlineNotificationUtilsFb9eaa4e.getNotificationRootJssStyle = getNotificationRootJssStyle;

	
	return inlineNotificationUtilsFb9eaa4e;
}

var isClickOutside050dc86b = {};

var hasRequiredIsClickOutside050dc86b;

function requireIsClickOutside050dc86b () {
	if (hasRequiredIsClickOutside050dc86b) return isClickOutside050dc86b;
	hasRequiredIsClickOutside050dc86b = 1;
	const min = Math.min;
	const max = Math.max;
	const round = Math.round;
	const floor = Math.floor;
	const createCoords = v => ({
	  x: v,
	  y: v
	});
	const oppositeSideMap = {
	  left: 'right',
	  right: 'left',
	  bottom: 'top',
	  top: 'bottom'
	};
	const oppositeAlignmentMap = {
	  start: 'end',
	  end: 'start'
	};
	function clamp(start, value, end) {
	  return max(start, min(value, end));
	}
	function evaluate(value, param) {
	  return typeof value === 'function' ? value(param) : value;
	}
	function getSide(placement) {
	  return placement.split('-')[0];
	}
	function getAlignment(placement) {
	  return placement.split('-')[1];
	}
	function getOppositeAxis(axis) {
	  return axis === 'x' ? 'y' : 'x';
	}
	function getAxisLength(axis) {
	  return axis === 'y' ? 'height' : 'width';
	}
	function getSideAxis(placement) {
	  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';
	}
	function getAlignmentAxis(placement) {
	  return getOppositeAxis(getSideAxis(placement));
	}
	function getAlignmentSides(placement, rects, rtl) {
	  if (rtl === void 0) {
	    rtl = false;
	  }
	  const alignment = getAlignment(placement);
	  const alignmentAxis = getAlignmentAxis(placement);
	  const length = getAxisLength(alignmentAxis);
	  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';
	  if (rects.reference[length] > rects.floating[length]) {
	    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
	  }
	  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
	}
	function getExpandedPlacements(placement) {
	  const oppositePlacement = getOppositePlacement(placement);
	  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
	}
	function getOppositeAlignmentPlacement(placement) {
	  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);
	}
	function getSideList(side, isStart, rtl) {
	  const lr = ['left', 'right'];
	  const rl = ['right', 'left'];
	  const tb = ['top', 'bottom'];
	  const bt = ['bottom', 'top'];
	  switch (side) {
	    case 'top':
	    case 'bottom':
	      if (rtl) return isStart ? rl : lr;
	      return isStart ? lr : rl;
	    case 'left':
	    case 'right':
	      return isStart ? tb : bt;
	    default:
	      return [];
	  }
	}
	function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
	  const alignment = getAlignment(placement);
	  let list = getSideList(getSide(placement), direction === 'start', rtl);
	  if (alignment) {
	    list = list.map(side => side + "-" + alignment);
	    if (flipAlignment) {
	      list = list.concat(list.map(getOppositeAlignmentPlacement));
	    }
	  }
	  return list;
	}
	function getOppositePlacement(placement) {
	  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);
	}
	function expandPaddingObject(padding) {
	  return {
	    top: 0,
	    right: 0,
	    bottom: 0,
	    left: 0,
	    ...padding
	  };
	}
	function getPaddingObject(padding) {
	  return typeof padding !== 'number' ? expandPaddingObject(padding) : {
	    top: padding,
	    right: padding,
	    bottom: padding,
	    left: padding
	  };
	}
	function rectToClientRect(rect) {
	  const {
	    x,
	    y,
	    width,
	    height
	  } = rect;
	  return {
	    width,
	    height,
	    top: y,
	    left: x,
	    right: x + width,
	    bottom: y + height,
	    x,
	    y
	  };
	}

	function computeCoordsFromPlacement(_ref, placement, rtl) {
	  let {
	    reference,
	    floating
	  } = _ref;
	  const sideAxis = getSideAxis(placement);
	  const alignmentAxis = getAlignmentAxis(placement);
	  const alignLength = getAxisLength(alignmentAxis);
	  const side = getSide(placement);
	  const isVertical = sideAxis === 'y';
	  const commonX = reference.x + reference.width / 2 - floating.width / 2;
	  const commonY = reference.y + reference.height / 2 - floating.height / 2;
	  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
	  let coords;
	  switch (side) {
	    case 'top':
	      coords = {
	        x: commonX,
	        y: reference.y - floating.height
	      };
	      break;
	    case 'bottom':
	      coords = {
	        x: commonX,
	        y: reference.y + reference.height
	      };
	      break;
	    case 'right':
	      coords = {
	        x: reference.x + reference.width,
	        y: commonY
	      };
	      break;
	    case 'left':
	      coords = {
	        x: reference.x - floating.width,
	        y: commonY
	      };
	      break;
	    default:
	      coords = {
	        x: reference.x,
	        y: reference.y
	      };
	  }
	  switch (getAlignment(placement)) {
	    case 'start':
	      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
	      break;
	    case 'end':
	      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
	      break;
	  }
	  return coords;
	}

	/**
	 * Computes the `x` and `y` coordinates that will place the floating element
	 * next to a given reference element.
	 *
	 * This export does not have any `platform` interface logic. You will need to
	 * write one for the platform you are using Floating UI with.
	 */
	const computePosition$1 = async (reference, floating, config) => {
	  const {
	    placement = 'bottom',
	    strategy = 'absolute',
	    middleware = [],
	    platform
	  } = config;
	  const validMiddleware = middleware.filter(Boolean);
	  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));
	  let rects = await platform.getElementRects({
	    reference,
	    floating,
	    strategy
	  });
	  let {
	    x,
	    y
	  } = computeCoordsFromPlacement(rects, placement, rtl);
	  let statefulPlacement = placement;
	  let middlewareData = {};
	  let resetCount = 0;
	  for (let i = 0; i < validMiddleware.length; i++) {
	    const {
	      name,
	      fn
	    } = validMiddleware[i];
	    const {
	      x: nextX,
	      y: nextY,
	      data,
	      reset
	    } = await fn({
	      x,
	      y,
	      initialPlacement: placement,
	      placement: statefulPlacement,
	      strategy,
	      middlewareData,
	      rects,
	      platform,
	      elements: {
	        reference,
	        floating
	      }
	    });
	    x = nextX != null ? nextX : x;
	    y = nextY != null ? nextY : y;
	    middlewareData = {
	      ...middlewareData,
	      [name]: {
	        ...middlewareData[name],
	        ...data
	      }
	    };
	    if (reset && resetCount <= 50) {
	      resetCount++;
	      if (typeof reset === 'object') {
	        if (reset.placement) {
	          statefulPlacement = reset.placement;
	        }
	        if (reset.rects) {
	          rects = reset.rects === true ? await platform.getElementRects({
	            reference,
	            floating,
	            strategy
	          }) : reset.rects;
	        }
	        ({
	          x,
	          y
	        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
	      }
	      i = -1;
	    }
	  }
	  return {
	    x,
	    y,
	    placement: statefulPlacement,
	    strategy,
	    middlewareData
	  };
	};

	/**
	 * Resolves with an object of overflow side offsets that determine how much the
	 * element is overflowing a given clipping boundary on each side.
	 * - positive = overflowing the boundary by that number of pixels
	 * - negative = how many pixels left before it will overflow
	 * - 0 = lies flush with the boundary
	 * @see https://floating-ui.com/docs/detectOverflow
	 */
	async function detectOverflow(state, options) {
	  var _await$platform$isEle;
	  if (options === void 0) {
	    options = {};
	  }
	  const {
	    x,
	    y,
	    platform,
	    rects,
	    elements,
	    strategy
	  } = state;
	  const {
	    boundary = 'clippingAncestors',
	    rootBoundary = 'viewport',
	    elementContext = 'floating',
	    altBoundary = false,
	    padding = 0
	  } = evaluate(options, state);
	  const paddingObject = getPaddingObject(padding);
	  const altContext = elementContext === 'floating' ? 'reference' : 'floating';
	  const element = elements[altBoundary ? altContext : elementContext];
	  const clippingClientRect = rectToClientRect(await platform.getClippingRect({
	    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),
	    boundary,
	    rootBoundary,
	    strategy
	  }));
	  const rect = elementContext === 'floating' ? {
	    x,
	    y,
	    width: rects.floating.width,
	    height: rects.floating.height
	  } : rects.reference;
	  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));
	  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {
	    x: 1,
	    y: 1
	  } : {
	    x: 1,
	    y: 1
	  };
	  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
	    elements,
	    rect,
	    offsetParent,
	    strategy
	  }) : rect);
	  return {
	    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
	    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
	    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
	    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
	  };
	}

	/**
	 * Provides data to position an inner element of the floating element so that it
	 * appears centered to the reference element.
	 * @see https://floating-ui.com/docs/arrow
	 */
	const arrow$1 = options => ({
	  name: 'arrow',
	  options,
	  async fn(state) {
	    const {
	      x,
	      y,
	      placement,
	      rects,
	      platform,
	      elements,
	      middlewareData
	    } = state;
	    // Since `element` is required, we don't Partial<> the type.
	    const {
	      element,
	      padding = 0
	    } = evaluate(options, state) || {};
	    if (element == null) {
	      return {};
	    }
	    const paddingObject = getPaddingObject(padding);
	    const coords = {
	      x,
	      y
	    };
	    const axis = getAlignmentAxis(placement);
	    const length = getAxisLength(axis);
	    const arrowDimensions = await platform.getDimensions(element);
	    const isYAxis = axis === 'y';
	    const minProp = isYAxis ? 'top' : 'left';
	    const maxProp = isYAxis ? 'bottom' : 'right';
	    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';
	    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
	    const startDiff = coords[axis] - rects.reference[axis];
	    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));
	    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;

	    // DOM platform can return `window` as the `offsetParent`.
	    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {
	      clientSize = elements.floating[clientProp] || rects.floating[length];
	    }
	    const centerToReference = endDiff / 2 - startDiff / 2;

	    // If the padding is large enough that it causes the arrow to no longer be
	    // centered, modify the padding so that it is centered.
	    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
	    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
	    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);

	    // Make sure the arrow doesn't overflow the floating element if the center
	    // point is outside the floating element's bounds.
	    const min$1 = minPadding;
	    const max = clientSize - arrowDimensions[length] - maxPadding;
	    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
	    const offset = clamp(min$1, center, max);

	    // If the reference is small enough that the arrow's padding causes it to
	    // to point to nothing for an aligned placement, adjust the offset of the
	    // floating element itself. To ensure `shift()` continues to take action,
	    // a single reset is performed when this is true.
	    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
	    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;
	    return {
	      [axis]: coords[axis] + alignmentOffset,
	      data: {
	        [axis]: offset,
	        centerOffset: center - offset - alignmentOffset,
	        ...(shouldAddOffset && {
	          alignmentOffset
	        })
	      },
	      reset: shouldAddOffset
	    };
	  }
	});

	/**
	 * Optimizes the visibility of the floating element by flipping the `placement`
	 * in order to keep it in view when the preferred placement(s) will overflow the
	 * clipping boundary. Alternative to `autoPlacement`.
	 * @see https://floating-ui.com/docs/flip
	 */
	const flip$1 = function (options) {
	  if (options === void 0) {
	    options = {};
	  }
	  return {
	    name: 'flip',
	    options,
	    async fn(state) {
	      var _middlewareData$arrow, _middlewareData$flip;
	      const {
	        placement,
	        middlewareData,
	        rects,
	        initialPlacement,
	        platform,
	        elements
	      } = state;
	      const {
	        mainAxis: checkMainAxis = true,
	        crossAxis: checkCrossAxis = true,
	        fallbackPlacements: specifiedFallbackPlacements,
	        fallbackStrategy = 'bestFit',
	        fallbackAxisSideDirection = 'none',
	        flipAlignment = true,
	        ...detectOverflowOptions
	      } = evaluate(options, state);

	      // If a reset by the arrow was caused due to an alignment offset being
	      // added, we should skip any logic now since `flip()` has already done its
	      // work.
	      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643
	      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
	        return {};
	      }
	      const side = getSide(placement);
	      const initialSideAxis = getSideAxis(initialPlacement);
	      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
	      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
	      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
	      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';
	      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
	        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
	      }
	      const placements = [initialPlacement, ...fallbackPlacements];
	      const overflow = await detectOverflow(state, detectOverflowOptions);
	      const overflows = [];
	      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
	      if (checkMainAxis) {
	        overflows.push(overflow[side]);
	      }
	      if (checkCrossAxis) {
	        const sides = getAlignmentSides(placement, rects, rtl);
	        overflows.push(overflow[sides[0]], overflow[sides[1]]);
	      }
	      overflowsData = [...overflowsData, {
	        placement,
	        overflows
	      }];

	      // One or more sides is overflowing.
	      if (!overflows.every(side => side <= 0)) {
	        var _middlewareData$flip2, _overflowsData$filter;
	        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
	        const nextPlacement = placements[nextIndex];
	        if (nextPlacement) {
	          // Try next placement and re-run the lifecycle.
	          return {
	            data: {
	              index: nextIndex,
	              overflows: overflowsData
	            },
	            reset: {
	              placement: nextPlacement
	            }
	          };
	        }

	        // First, find the candidates that fit on the mainAxis side of overflow,
	        // then find the placement that fits the best on the main crossAxis side.
	        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;

	        // Otherwise fallback.
	        if (!resetPlacement) {
	          switch (fallbackStrategy) {
	            case 'bestFit':
	              {
	                var _overflowsData$filter2;
	                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {
	                  if (hasFallbackAxisSideDirection) {
	                    const currentSideAxis = getSideAxis(d.placement);
	                    return currentSideAxis === initialSideAxis ||
	                    // Create a bias to the `y` side axis due to horizontal
	                    // reading directions favoring greater width.
	                    currentSideAxis === 'y';
	                  }
	                  return true;
	                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
	                if (placement) {
	                  resetPlacement = placement;
	                }
	                break;
	              }
	            case 'initialPlacement':
	              resetPlacement = initialPlacement;
	              break;
	          }
	        }
	        if (placement !== resetPlacement) {
	          return {
	            reset: {
	              placement: resetPlacement
	            }
	          };
	        }
	      }
	      return {};
	    }
	  };
	};

	// For type backwards-compatibility, the `OffsetOptions` type was also
	// Derivable.

	async function convertValueToCoords(state, options) {
	  const {
	    placement,
	    platform,
	    elements
	  } = state;
	  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
	  const side = getSide(placement);
	  const alignment = getAlignment(placement);
	  const isVertical = getSideAxis(placement) === 'y';
	  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;
	  const crossAxisMulti = rtl && isVertical ? -1 : 1;
	  const rawValue = evaluate(options, state);

	  // eslint-disable-next-line prefer-const
	  let {
	    mainAxis,
	    crossAxis,
	    alignmentAxis
	  } = typeof rawValue === 'number' ? {
	    mainAxis: rawValue,
	    crossAxis: 0,
	    alignmentAxis: null
	  } : {
	    mainAxis: rawValue.mainAxis || 0,
	    crossAxis: rawValue.crossAxis || 0,
	    alignmentAxis: rawValue.alignmentAxis
	  };
	  if (alignment && typeof alignmentAxis === 'number') {
	    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;
	  }
	  return isVertical ? {
	    x: crossAxis * crossAxisMulti,
	    y: mainAxis * mainAxisMulti
	  } : {
	    x: mainAxis * mainAxisMulti,
	    y: crossAxis * crossAxisMulti
	  };
	}

	/**
	 * Modifies the placement by translating the floating element along the
	 * specified axes.
	 * A number (shorthand for `mainAxis` or distance), or an axes configuration
	 * object may be passed.
	 * @see https://floating-ui.com/docs/offset
	 */
	const offset$1 = function (options) {
	  if (options === void 0) {
	    options = 0;
	  }
	  return {
	    name: 'offset',
	    options,
	    async fn(state) {
	      var _middlewareData$offse, _middlewareData$arrow;
	      const {
	        x,
	        y,
	        placement,
	        middlewareData
	      } = state;
	      const diffCoords = await convertValueToCoords(state, options);

	      // If the placement is the same and the arrow caused an alignment offset
	      // then we don't need to change the positioning coordinates.
	      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
	        return {};
	      }
	      return {
	        x: x + diffCoords.x,
	        y: y + diffCoords.y,
	        data: {
	          ...diffCoords,
	          placement
	        }
	      };
	    }
	  };
	};

	/**
	 * Optimizes the visibility of the floating element by shifting it in order to
	 * keep it in view when it will overflow the clipping boundary.
	 * @see https://floating-ui.com/docs/shift
	 */
	const shift$1 = function (options) {
	  if (options === void 0) {
	    options = {};
	  }
	  return {
	    name: 'shift',
	    options,
	    async fn(state) {
	      const {
	        x,
	        y,
	        placement
	      } = state;
	      const {
	        mainAxis: checkMainAxis = true,
	        crossAxis: checkCrossAxis = false,
	        limiter = {
	          fn: _ref => {
	            let {
	              x,
	              y
	            } = _ref;
	            return {
	              x,
	              y
	            };
	          }
	        },
	        ...detectOverflowOptions
	      } = evaluate(options, state);
	      const coords = {
	        x,
	        y
	      };
	      const overflow = await detectOverflow(state, detectOverflowOptions);
	      const crossAxis = getSideAxis(getSide(placement));
	      const mainAxis = getOppositeAxis(crossAxis);
	      let mainAxisCoord = coords[mainAxis];
	      let crossAxisCoord = coords[crossAxis];
	      if (checkMainAxis) {
	        const minSide = mainAxis === 'y' ? 'top' : 'left';
	        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';
	        const min = mainAxisCoord + overflow[minSide];
	        const max = mainAxisCoord - overflow[maxSide];
	        mainAxisCoord = clamp(min, mainAxisCoord, max);
	      }
	      if (checkCrossAxis) {
	        const minSide = crossAxis === 'y' ? 'top' : 'left';
	        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';
	        const min = crossAxisCoord + overflow[minSide];
	        const max = crossAxisCoord - overflow[maxSide];
	        crossAxisCoord = clamp(min, crossAxisCoord, max);
	      }
	      const limitedCoords = limiter.fn({
	        ...state,
	        [mainAxis]: mainAxisCoord,
	        [crossAxis]: crossAxisCoord
	      });
	      return {
	        ...limitedCoords,
	        data: {
	          x: limitedCoords.x - x,
	          y: limitedCoords.y - y,
	          enabled: {
	            [mainAxis]: checkMainAxis,
	            [crossAxis]: checkCrossAxis
	          }
	        }
	      };
	    }
	  };
	};
	/**
	 * Built-in `limiter` that will stop `shift()` at a certain point.
	 */
	const limitShift$1 = function (options) {
	  if (options === void 0) {
	    options = {};
	  }
	  return {
	    options,
	    fn(state) {
	      const {
	        x,
	        y,
	        placement,
	        rects,
	        middlewareData
	      } = state;
	      const {
	        offset = 0,
	        mainAxis: checkMainAxis = true,
	        crossAxis: checkCrossAxis = true
	      } = evaluate(options, state);
	      const coords = {
	        x,
	        y
	      };
	      const crossAxis = getSideAxis(placement);
	      const mainAxis = getOppositeAxis(crossAxis);
	      let mainAxisCoord = coords[mainAxis];
	      let crossAxisCoord = coords[crossAxis];
	      const rawOffset = evaluate(offset, state);
	      const computedOffset = typeof rawOffset === 'number' ? {
	        mainAxis: rawOffset,
	        crossAxis: 0
	      } : {
	        mainAxis: 0,
	        crossAxis: 0,
	        ...rawOffset
	      };
	      if (checkMainAxis) {
	        const len = mainAxis === 'y' ? 'height' : 'width';
	        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
	        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
	        if (mainAxisCoord < limitMin) {
	          mainAxisCoord = limitMin;
	        } else if (mainAxisCoord > limitMax) {
	          mainAxisCoord = limitMax;
	        }
	      }
	      if (checkCrossAxis) {
	        var _middlewareData$offse, _middlewareData$offse2;
	        const len = mainAxis === 'y' ? 'width' : 'height';
	        const isOriginSide = ['top', 'left'].includes(getSide(placement));
	        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
	        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
	        if (crossAxisCoord < limitMin) {
	          crossAxisCoord = limitMin;
	        } else if (crossAxisCoord > limitMax) {
	          crossAxisCoord = limitMax;
	        }
	      }
	      return {
	        [mainAxis]: mainAxisCoord,
	        [crossAxis]: crossAxisCoord
	      };
	    }
	  };
	};

	/**
	 * Provides data that allows you to change the size of the floating element 
	 * for instance, prevent it from overflowing the clipping boundary or match the
	 * width of the reference element.
	 * @see https://floating-ui.com/docs/size
	 */
	const size$1 = function (options) {
	  if (options === void 0) {
	    options = {};
	  }
	  return {
	    name: 'size',
	    options,
	    async fn(state) {
	      var _state$middlewareData, _state$middlewareData2;
	      const {
	        placement,
	        rects,
	        platform,
	        elements
	      } = state;
	      const {
	        apply = () => {},
	        ...detectOverflowOptions
	      } = evaluate(options, state);
	      const overflow = await detectOverflow(state, detectOverflowOptions);
	      const side = getSide(placement);
	      const alignment = getAlignment(placement);
	      const isYAxis = getSideAxis(placement) === 'y';
	      const {
	        width,
	        height
	      } = rects.floating;
	      let heightSide;
	      let widthSide;
	      if (side === 'top' || side === 'bottom') {
	        heightSide = side;
	        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';
	      } else {
	        widthSide = side;
	        heightSide = alignment === 'end' ? 'top' : 'bottom';
	      }
	      const maximumClippingHeight = height - overflow.top - overflow.bottom;
	      const maximumClippingWidth = width - overflow.left - overflow.right;
	      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
	      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
	      const noShift = !state.middlewareData.shift;
	      let availableHeight = overflowAvailableHeight;
	      let availableWidth = overflowAvailableWidth;
	      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
	        availableWidth = maximumClippingWidth;
	      }
	      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
	        availableHeight = maximumClippingHeight;
	      }
	      if (noShift && !alignment) {
	        const xMin = max(overflow.left, 0);
	        const xMax = max(overflow.right, 0);
	        const yMin = max(overflow.top, 0);
	        const yMax = max(overflow.bottom, 0);
	        if (isYAxis) {
	          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
	        } else {
	          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
	        }
	      }
	      await apply({
	        ...state,
	        availableWidth,
	        availableHeight
	      });
	      const nextDimensions = await platform.getDimensions(elements.floating);
	      if (width !== nextDimensions.width || height !== nextDimensions.height) {
	        return {
	          reset: {
	            rects: true
	          }
	        };
	      }
	      return {};
	    }
	  };
	};

	function hasWindow() {
	  return typeof window !== 'undefined';
	}
	function getNodeName(node) {
	  if (isNode(node)) {
	    return (node.nodeName || '').toLowerCase();
	  }
	  // Mocked nodes in testing environments may not be instances of Node. By
	  // returning `#document` an infinite loop won't occur.
	  // https://github.com/floating-ui/floating-ui/issues/2317
	  return '#document';
	}
	function getWindow(node) {
	  var _node$ownerDocument;
	  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
	}
	function getDocumentElement(node) {
	  var _ref;
	  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
	}
	function isNode(value) {
	  if (!hasWindow()) {
	    return false;
	  }
	  return value instanceof Node || value instanceof getWindow(value).Node;
	}
	function isElement(value) {
	  if (!hasWindow()) {
	    return false;
	  }
	  return value instanceof Element || value instanceof getWindow(value).Element;
	}
	function isHTMLElement(value) {
	  if (!hasWindow()) {
	    return false;
	  }
	  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
	}
	function isShadowRoot(value) {
	  if (!hasWindow() || typeof ShadowRoot === 'undefined') {
	    return false;
	  }
	  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
	}
	function isOverflowElement(element) {
	  const {
	    overflow,
	    overflowX,
	    overflowY,
	    display
	  } = getComputedStyle(element);
	  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);
	}
	function isTableElement(element) {
	  return ['table', 'td', 'th'].includes(getNodeName(element));
	}
	function isTopLayer(element) {
	  return [':popover-open', ':modal'].some(selector => {
	    try {
	      return element.matches(selector);
	    } catch (e) {
	      return false;
	    }
	  });
	}
	function isContainingBlock(elementOrCss) {
	  const webkit = isWebKit();
	  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;

	  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
	  // https://drafts.csswg.org/css-transforms-2/#individual-transforms
	  return ['transform', 'translate', 'scale', 'rotate', 'perspective'].some(value => css[value] ? css[value] !== 'none' : false) || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));
	}
	function getContainingBlock(element) {
	  let currentNode = getParentNode(element);
	  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
	    if (isContainingBlock(currentNode)) {
	      return currentNode;
	    } else if (isTopLayer(currentNode)) {
	      return null;
	    }
	    currentNode = getParentNode(currentNode);
	  }
	  return null;
	}
	function isWebKit() {
	  if (typeof CSS === 'undefined' || !CSS.supports) return false;
	  return CSS.supports('-webkit-backdrop-filter', 'none');
	}
	function isLastTraversableNode(node) {
	  return ['html', 'body', '#document'].includes(getNodeName(node));
	}
	function getComputedStyle(element) {
	  return getWindow(element).getComputedStyle(element);
	}
	function getNodeScroll(element) {
	  if (isElement(element)) {
	    return {
	      scrollLeft: element.scrollLeft,
	      scrollTop: element.scrollTop
	    };
	  }
	  return {
	    scrollLeft: element.scrollX,
	    scrollTop: element.scrollY
	  };
	}
	function getParentNode(node) {
	  if (getNodeName(node) === 'html') {
	    return node;
	  }
	  const result =
	  // Step into the shadow DOM of the parent of a slotted node.
	  node.assignedSlot ||
	  // DOM Element detected.
	  node.parentNode ||
	  // ShadowRoot detected.
	  isShadowRoot(node) && node.host ||
	  // Fallback.
	  getDocumentElement(node);
	  return isShadowRoot(result) ? result.host : result;
	}
	function getNearestOverflowAncestor(node) {
	  const parentNode = getParentNode(node);
	  if (isLastTraversableNode(parentNode)) {
	    return node.ownerDocument ? node.ownerDocument.body : node.body;
	  }
	  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
	    return parentNode;
	  }
	  return getNearestOverflowAncestor(parentNode);
	}
	function getOverflowAncestors(node, list, traverseIframes) {
	  var _node$ownerDocument2;
	  if (list === void 0) {
	    list = [];
	  }
	  if (traverseIframes === void 0) {
	    traverseIframes = true;
	  }
	  const scrollableAncestor = getNearestOverflowAncestor(node);
	  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
	  const win = getWindow(scrollableAncestor);
	  if (isBody) {
	    const frameElement = getFrameElement(win);
	    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
	  }
	  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
	}
	function getFrameElement(win) {
	  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
	}

	function getCssDimensions(element) {
	  const css = getComputedStyle(element);
	  // In testing environments, the `width` and `height` properties are empty
	  // strings for SVG elements, returning NaN. Fallback to `0` in this case.
	  let width = parseFloat(css.width) || 0;
	  let height = parseFloat(css.height) || 0;
	  const hasOffset = isHTMLElement(element);
	  const offsetWidth = hasOffset ? element.offsetWidth : width;
	  const offsetHeight = hasOffset ? element.offsetHeight : height;
	  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
	  if (shouldFallback) {
	    width = offsetWidth;
	    height = offsetHeight;
	  }
	  return {
	    width,
	    height,
	    $: shouldFallback
	  };
	}

	function unwrapElement(element) {
	  return !isElement(element) ? element.contextElement : element;
	}

	function getScale(element) {
	  const domElement = unwrapElement(element);
	  if (!isHTMLElement(domElement)) {
	    return createCoords(1);
	  }
	  const rect = domElement.getBoundingClientRect();
	  const {
	    width,
	    height,
	    $
	  } = getCssDimensions(domElement);
	  let x = ($ ? round(rect.width) : rect.width) / width;
	  let y = ($ ? round(rect.height) : rect.height) / height;

	  // 0, NaN, or Infinity should always fallback to 1.

	  if (!x || !Number.isFinite(x)) {
	    x = 1;
	  }
	  if (!y || !Number.isFinite(y)) {
	    y = 1;
	  }
	  return {
	    x,
	    y
	  };
	}

	const noOffsets = /*#__PURE__*/createCoords(0);
	function getVisualOffsets(element) {
	  const win = getWindow(element);
	  if (!isWebKit() || !win.visualViewport) {
	    return noOffsets;
	  }
	  return {
	    x: win.visualViewport.offsetLeft,
	    y: win.visualViewport.offsetTop
	  };
	}
	function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
	  if (isFixed === void 0) {
	    isFixed = false;
	  }
	  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
	    return false;
	  }
	  return isFixed;
	}

	function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
	  if (includeScale === void 0) {
	    includeScale = false;
	  }
	  if (isFixedStrategy === void 0) {
	    isFixedStrategy = false;
	  }
	  const clientRect = element.getBoundingClientRect();
	  const domElement = unwrapElement(element);
	  let scale = createCoords(1);
	  if (includeScale) {
	    if (offsetParent) {
	      if (isElement(offsetParent)) {
	        scale = getScale(offsetParent);
	      }
	    } else {
	      scale = getScale(element);
	    }
	  }
	  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
	  let x = (clientRect.left + visualOffsets.x) / scale.x;
	  let y = (clientRect.top + visualOffsets.y) / scale.y;
	  let width = clientRect.width / scale.x;
	  let height = clientRect.height / scale.y;
	  if (domElement) {
	    const win = getWindow(domElement);
	    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
	    let currentWin = win;
	    let currentIFrame = getFrameElement(currentWin);
	    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
	      const iframeScale = getScale(currentIFrame);
	      const iframeRect = currentIFrame.getBoundingClientRect();
	      const css = getComputedStyle(currentIFrame);
	      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
	      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
	      x *= iframeScale.x;
	      y *= iframeScale.y;
	      width *= iframeScale.x;
	      height *= iframeScale.y;
	      x += left;
	      y += top;
	      currentWin = getWindow(currentIFrame);
	      currentIFrame = getFrameElement(currentWin);
	    }
	  }
	  return rectToClientRect({
	    width,
	    height,
	    x,
	    y
	  });
	}

	// If <html> has a CSS width greater than the viewport, then this will be
	// incorrect for RTL.
	function getWindowScrollBarX(element, rect) {
	  const leftScroll = getNodeScroll(element).scrollLeft;
	  if (!rect) {
	    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
	  }
	  return rect.left + leftScroll;
	}

	function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
	  if (ignoreScrollbarX === void 0) {
	    ignoreScrollbarX = false;
	  }
	  const htmlRect = documentElement.getBoundingClientRect();
	  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 :
	  // RTL <body> scrollbar.
	  getWindowScrollBarX(documentElement, htmlRect));
	  const y = htmlRect.top + scroll.scrollTop;
	  return {
	    x,
	    y
	  };
	}

	function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
	  let {
	    elements,
	    rect,
	    offsetParent,
	    strategy
	  } = _ref;
	  const isFixed = strategy === 'fixed';
	  const documentElement = getDocumentElement(offsetParent);
	  const topLayer = elements ? isTopLayer(elements.floating) : false;
	  if (offsetParent === documentElement || topLayer && isFixed) {
	    return rect;
	  }
	  let scroll = {
	    scrollLeft: 0,
	    scrollTop: 0
	  };
	  let scale = createCoords(1);
	  const offsets = createCoords(0);
	  const isOffsetParentAnElement = isHTMLElement(offsetParent);
	  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
	    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
	      scroll = getNodeScroll(offsetParent);
	    }
	    if (isHTMLElement(offsetParent)) {
	      const offsetRect = getBoundingClientRect(offsetParent);
	      scale = getScale(offsetParent);
	      offsets.x = offsetRect.x + offsetParent.clientLeft;
	      offsets.y = offsetRect.y + offsetParent.clientTop;
	    }
	  }
	  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
	  return {
	    width: rect.width * scale.x,
	    height: rect.height * scale.y,
	    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
	    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
	  };
	}

	function getClientRects(element) {
	  return Array.from(element.getClientRects());
	}

	// Gets the entire size of the scrollable document area, even extending outside
	// of the `<html>` and `<body>` rect bounds if horizontally scrollable.
	function getDocumentRect(element) {
	  const html = getDocumentElement(element);
	  const scroll = getNodeScroll(element);
	  const body = element.ownerDocument.body;
	  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
	  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
	  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
	  const y = -scroll.scrollTop;
	  if (getComputedStyle(body).direction === 'rtl') {
	    x += max(html.clientWidth, body.clientWidth) - width;
	  }
	  return {
	    width,
	    height,
	    x,
	    y
	  };
	}

	function getViewportRect(element, strategy) {
	  const win = getWindow(element);
	  const html = getDocumentElement(element);
	  const visualViewport = win.visualViewport;
	  let width = html.clientWidth;
	  let height = html.clientHeight;
	  let x = 0;
	  let y = 0;
	  if (visualViewport) {
	    width = visualViewport.width;
	    height = visualViewport.height;
	    const visualViewportBased = isWebKit();
	    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {
	      x = visualViewport.offsetLeft;
	      y = visualViewport.offsetTop;
	    }
	  }
	  return {
	    width,
	    height,
	    x,
	    y
	  };
	}

	// Returns the inner client rect, subtracting scrollbars if present.
	function getInnerBoundingClientRect(element, strategy) {
	  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');
	  const top = clientRect.top + element.clientTop;
	  const left = clientRect.left + element.clientLeft;
	  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
	  const width = element.clientWidth * scale.x;
	  const height = element.clientHeight * scale.y;
	  const x = left * scale.x;
	  const y = top * scale.y;
	  return {
	    width,
	    height,
	    x,
	    y
	  };
	}
	function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
	  let rect;
	  if (clippingAncestor === 'viewport') {
	    rect = getViewportRect(element, strategy);
	  } else if (clippingAncestor === 'document') {
	    rect = getDocumentRect(getDocumentElement(element));
	  } else if (isElement(clippingAncestor)) {
	    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
	  } else {
	    const visualOffsets = getVisualOffsets(element);
	    rect = {
	      x: clippingAncestor.x - visualOffsets.x,
	      y: clippingAncestor.y - visualOffsets.y,
	      width: clippingAncestor.width,
	      height: clippingAncestor.height
	    };
	  }
	  return rectToClientRect(rect);
	}
	function hasFixedPositionAncestor(element, stopNode) {
	  const parentNode = getParentNode(element);
	  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
	    return false;
	  }
	  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);
	}

	// A "clipping ancestor" is an `overflow` element with the characteristic of
	// clipping (or hiding) child elements. This returns all clipping ancestors
	// of the given element up the tree.
	function getClippingElementAncestors(element, cache) {
	  const cachedResult = cache.get(element);
	  if (cachedResult) {
	    return cachedResult;
	  }
	  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');
	  let currentContainingBlockComputedStyle = null;
	  const elementIsFixed = getComputedStyle(element).position === 'fixed';
	  let currentNode = elementIsFixed ? getParentNode(element) : element;

	  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
	  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
	    const computedStyle = getComputedStyle(currentNode);
	    const currentNodeIsContaining = isContainingBlock(currentNode);
	    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {
	      currentContainingBlockComputedStyle = null;
	    }
	    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
	    if (shouldDropCurrentNode) {
	      // Drop non-containing blocks.
	      result = result.filter(ancestor => ancestor !== currentNode);
	    } else {
	      // Record last containing block for next iteration.
	      currentContainingBlockComputedStyle = computedStyle;
	    }
	    currentNode = getParentNode(currentNode);
	  }
	  cache.set(element, result);
	  return result;
	}

	// Gets the maximum area that the element is visible in due to any number of
	// clipping ancestors.
	function getClippingRect(_ref) {
	  let {
	    element,
	    boundary,
	    rootBoundary,
	    strategy
	  } = _ref;
	  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
	  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
	  const firstClippingAncestor = clippingAncestors[0];
	  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
	    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
	    accRect.top = max(rect.top, accRect.top);
	    accRect.right = min(rect.right, accRect.right);
	    accRect.bottom = min(rect.bottom, accRect.bottom);
	    accRect.left = max(rect.left, accRect.left);
	    return accRect;
	  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
	  return {
	    width: clippingRect.right - clippingRect.left,
	    height: clippingRect.bottom - clippingRect.top,
	    x: clippingRect.left,
	    y: clippingRect.top
	  };
	}

	function getDimensions(element) {
	  const {
	    width,
	    height
	  } = getCssDimensions(element);
	  return {
	    width,
	    height
	  };
	}

	function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
	  const isOffsetParentAnElement = isHTMLElement(offsetParent);
	  const documentElement = getDocumentElement(offsetParent);
	  const isFixed = strategy === 'fixed';
	  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
	  let scroll = {
	    scrollLeft: 0,
	    scrollTop: 0
	  };
	  const offsets = createCoords(0);
	  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
	    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
	      scroll = getNodeScroll(offsetParent);
	    }
	    if (isOffsetParentAnElement) {
	      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
	      offsets.x = offsetRect.x + offsetParent.clientLeft;
	      offsets.y = offsetRect.y + offsetParent.clientTop;
	    } else if (documentElement) {
	      // If the <body> scrollbar appears on the left (e.g. RTL systems). Use
	      // Firefox with layout.scrollbar.side = 3 in about:config to test this.
	      offsets.x = getWindowScrollBarX(documentElement);
	    }
	  }
	  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
	  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
	  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
	  return {
	    x,
	    y,
	    width: rect.width,
	    height: rect.height
	  };
	}

	function isStaticPositioned(element) {
	  return getComputedStyle(element).position === 'static';
	}

	function getTrueOffsetParent(element, polyfill) {
	  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {
	    return null;
	  }
	  if (polyfill) {
	    return polyfill(element);
	  }
	  let rawOffsetParent = element.offsetParent;

	  // Firefox returns the <html> element as the offsetParent if it's non-static,
	  // while Chrome and Safari return the <body> element. The <body> element must
	  // be used to perform the correct calculations even if the <html> element is
	  // non-static.
	  if (getDocumentElement(element) === rawOffsetParent) {
	    rawOffsetParent = rawOffsetParent.ownerDocument.body;
	  }
	  return rawOffsetParent;
	}

	// Gets the closest ancestor positioned element. Handles some edge cases,
	// such as table ancestors and cross browser bugs.
	function getOffsetParent(element, polyfill) {
	  const win = getWindow(element);
	  if (isTopLayer(element)) {
	    return win;
	  }
	  if (!isHTMLElement(element)) {
	    let svgOffsetParent = getParentNode(element);
	    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
	      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
	        return svgOffsetParent;
	      }
	      svgOffsetParent = getParentNode(svgOffsetParent);
	    }
	    return win;
	  }
	  let offsetParent = getTrueOffsetParent(element, polyfill);
	  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
	    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
	  }
	  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
	    return win;
	  }
	  return offsetParent || getContainingBlock(element) || win;
	}

	const getElementRects = async function (data) {
	  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
	  const getDimensionsFn = this.getDimensions;
	  const floatingDimensions = await getDimensionsFn(data.floating);
	  return {
	    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
	    floating: {
	      x: 0,
	      y: 0,
	      width: floatingDimensions.width,
	      height: floatingDimensions.height
	    }
	  };
	};

	function isRTL(element) {
	  return getComputedStyle(element).direction === 'rtl';
	}

	const platform = {
	  convertOffsetParentRelativeRectToViewportRelativeRect,
	  getDocumentElement,
	  getClippingRect,
	  getOffsetParent,
	  getElementRects,
	  getClientRects,
	  getDimensions,
	  getScale,
	  isElement,
	  isRTL
	};

	function rectsAreEqual(a, b) {
	  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
	}

	// https://samthor.au/2021/observing-dom/
	function observeMove(element, onMove) {
	  let io = null;
	  let timeoutId;
	  const root = getDocumentElement(element);
	  function cleanup() {
	    var _io;
	    clearTimeout(timeoutId);
	    (_io = io) == null || _io.disconnect();
	    io = null;
	  }
	  function refresh(skip, threshold) {
	    if (skip === void 0) {
	      skip = false;
	    }
	    if (threshold === void 0) {
	      threshold = 1;
	    }
	    cleanup();
	    const elementRectForRootMargin = element.getBoundingClientRect();
	    const {
	      left,
	      top,
	      width,
	      height
	    } = elementRectForRootMargin;
	    if (!skip) {
	      onMove();
	    }
	    if (!width || !height) {
	      return;
	    }
	    const insetTop = floor(top);
	    const insetRight = floor(root.clientWidth - (left + width));
	    const insetBottom = floor(root.clientHeight - (top + height));
	    const insetLeft = floor(left);
	    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
	    const options = {
	      rootMargin,
	      threshold: max(0, min(1, threshold)) || 1
	    };
	    let isFirstUpdate = true;
	    function handleObserve(entries) {
	      const ratio = entries[0].intersectionRatio;
	      if (ratio !== threshold) {
	        if (!isFirstUpdate) {
	          return refresh();
	        }
	        if (!ratio) {
	          // If the reference is clipped, the ratio is 0. Throttle the refresh
	          // to prevent an infinite loop of updates.
	          timeoutId = setTimeout(() => {
	            refresh(false, 1e-7);
	          }, 1000);
	        } else {
	          refresh(false, ratio);
	        }
	      }
	      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
	        // It's possible that even though the ratio is reported as 1, the
	        // element is not actually fully within the IntersectionObserver's root
	        // area anymore. This can happen under performance constraints. This may
	        // be a bug in the browser's IntersectionObserver implementation. To
	        // work around this, we compare the element's bounding rect now with
	        // what it was at the time we created the IntersectionObserver. If they
	        // are not equal then the element moved, so we refresh.
	        refresh();
	      }
	      isFirstUpdate = false;
	    }

	    // Older browsers don't support a `document` as the root and will throw an
	    // error.
	    try {
	      io = new IntersectionObserver(handleObserve, {
	        ...options,
	        // Handle <iframe>s
	        root: root.ownerDocument
	      });
	    } catch (e) {
	      io = new IntersectionObserver(handleObserve, options);
	    }
	    io.observe(element);
	  }
	  refresh(true);
	  return cleanup;
	}

	/**
	 * Automatically updates the position of the floating element when necessary.
	 * Should only be called when the floating element is mounted on the DOM or
	 * visible on the screen.
	 * @returns cleanup function that should be invoked when the floating element is
	 * removed from the DOM or hidden from the screen.
	 * @see https://floating-ui.com/docs/autoUpdate
	 */
	function autoUpdate(reference, floating, update, options) {
	  if (options === void 0) {
	    options = {};
	  }
	  const {
	    ancestorScroll = true,
	    ancestorResize = true,
	    elementResize = typeof ResizeObserver === 'function',
	    layoutShift = typeof IntersectionObserver === 'function',
	    animationFrame = false
	  } = options;
	  const referenceEl = unwrapElement(reference);
	  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];
	  ancestors.forEach(ancestor => {
	    ancestorScroll && ancestor.addEventListener('scroll', update, {
	      passive: true
	    });
	    ancestorResize && ancestor.addEventListener('resize', update);
	  });
	  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
	  let reobserveFrame = -1;
	  let resizeObserver = null;
	  if (elementResize) {
	    resizeObserver = new ResizeObserver(_ref => {
	      let [firstEntry] = _ref;
	      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
	        // Prevent update loops when using the `size` middleware.
	        // https://github.com/floating-ui/floating-ui/issues/1740
	        resizeObserver.unobserve(floating);
	        cancelAnimationFrame(reobserveFrame);
	        reobserveFrame = requestAnimationFrame(() => {
	          var _resizeObserver;
	          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
	        });
	      }
	      update();
	    });
	    if (referenceEl && !animationFrame) {
	      resizeObserver.observe(referenceEl);
	    }
	    resizeObserver.observe(floating);
	  }
	  let frameId;
	  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
	  if (animationFrame) {
	    frameLoop();
	  }
	  function frameLoop() {
	    const nextRefRect = getBoundingClientRect(reference);
	    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
	      update();
	    }
	    prevRefRect = nextRefRect;
	    frameId = requestAnimationFrame(frameLoop);
	  }
	  update();
	  return () => {
	    var _resizeObserver2;
	    ancestors.forEach(ancestor => {
	      ancestorScroll && ancestor.removeEventListener('scroll', update);
	      ancestorResize && ancestor.removeEventListener('resize', update);
	    });
	    cleanupIo == null || cleanupIo();
	    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
	    resizeObserver = null;
	    if (animationFrame) {
	      cancelAnimationFrame(frameId);
	    }
	  };
	}

	/**
	 * Modifies the placement by translating the floating element along the
	 * specified axes.
	 * A number (shorthand for `mainAxis` or distance), or an axes configuration
	 * object may be passed.
	 * @see https://floating-ui.com/docs/offset
	 */
	const offset = offset$1;

	/**
	 * Optimizes the visibility of the floating element by shifting it in order to
	 * keep it in view when it will overflow the clipping boundary.
	 * @see https://floating-ui.com/docs/shift
	 */
	const shift = shift$1;

	/**
	 * Optimizes the visibility of the floating element by flipping the `placement`
	 * in order to keep it in view when the preferred placement(s) will overflow the
	 * clipping boundary. Alternative to `autoPlacement`.
	 * @see https://floating-ui.com/docs/flip
	 */
	const flip = flip$1;

	/**
	 * Provides data that allows you to change the size of the floating element 
	 * for instance, prevent it from overflowing the clipping boundary or match the
	 * width of the reference element.
	 * @see https://floating-ui.com/docs/size
	 */
	const size = size$1;

	/**
	 * Provides data to position an inner element of the floating element so that it
	 * appears centered to the reference element.
	 * @see https://floating-ui.com/docs/arrow
	 */
	const arrow = arrow$1;

	/**
	 * Built-in `limiter` that will stop `shift()` at a certain point.
	 */
	const limitShift = limitShift$1;

	/**
	 * Computes the `x` and `y` coordinates that will place the floating element
	 * next to a given reference element.
	 */
	const computePosition = (reference, floating, options) => {
	  // This caches the expensive `getClippingElementAncestors` function so that
	  // multiple lifecycle resets re-use the same result. It only lives for a
	  // single call. If other functions become expensive, we can add them as well.
	  const cache = new Map();
	  const mergedOptions = {
	    platform,
	    ...options
	  };
	  const platformWithCache = {
	    ...mergedOptions.platform,
	    _c: cache
	  };
	  return computePosition$1(reference, floating, {
	    ...mergedOptions,
	    platform: platformWithCache
	  });
	};

	/**
	 * Checks if a click event occurred outside the specified element.
	 *
	 * @param {Event} e - The click event object.
	 * @param {HTMLElement} host - The host element to compare against.
	 * @returns {boolean} - Returns true if the click event occurred outside the host element, otherwise false.
	 */
	const isClickOutside = (e, host) => !e.composedPath().includes(host);

	isClickOutside050dc86b.arrow = arrow;
	isClickOutside050dc86b.autoUpdate = autoUpdate;
	isClickOutside050dc86b.computePosition = computePosition;
	isClickOutside050dc86b.flip = flip;
	isClickOutside050dc86b.isClickOutside = isClickOutside;
	isClickOutside050dc86b.limitShift = limitShift;
	isClickOutside050dc86b.offset = offset;
	isClickOutside050dc86b.shift = shift;
	isClickOutside050dc86b.size = size;

	
	return isClickOutside050dc86b;
}

var isSsrHydration78eae0b3 = {};

var hasRequiredIsSsrHydration78eae0b3;

function requireIsSsrHydration78eae0b3 () {
	if (hasRequiredIsSsrHydration78eae0b3) return isSsrHydration78eae0b3;
	hasRequiredIsSsrHydration78eae0b3 = 1;

	const isSsrHydration = (host) => host.hasAttribute('data-ssr');

	isSsrHydration78eae0b3.isSsrHydration = isSsrHydration;

	
	return isSsrHydration78eae0b3;
}

var isElementOfKindF7da6ac6 = {};

var hasRequiredIsElementOfKindF7da6ac6;

function requireIsElementOfKindF7da6ac6 () {
	if (hasRequiredIsElementOfKindF7da6ac6) return isElementOfKindF7da6ac6;
	hasRequiredIsElementOfKindF7da6ac6 = 1;

	const validateProps = requireValidateProps788e2bc5();

	const isElementOfKind = (element, tagName) => validateProps.getTagNameWithoutPrefix(element) === tagName;

	isElementOfKindF7da6ac6.isElementOfKind = isElementOfKind;

	
	return isElementOfKindF7da6ac6;
}

var labelStylesD5916d0e = {};

var hasRequiredLabelStylesD5916d0e;

function requireLabelStylesD5916d0e () {
	if (hasRequiredLabelStylesD5916d0e) return labelStylesD5916d0e;
	hasRequiredLabelStylesD5916d0e = 1;

	const validateProps = requireValidateProps788e2bc5();
	const getClosestHTMLElement = requireGetClosestHTMLElement83d01a84();
	const hasDescription = requireHasDescription050833e0();
	const stateMessageStyles = requireStateMessageStylesD1c4637f();
	const isParentOfKind = requireIsParentOfKind4b323732();
	const textSmallStyle = requireTextSmallStyle00e1c6e2();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const fontSizeTextXSmall = requireFontSizeTextXSmallE59d35d7();

	const isRequired = (el) => !!el?.required;

	const isParentFieldsetRequired = (element) => {
	    return ((isParentOfKind.isParentOfKind(element, 'p-fieldset') || isParentOfKind.isParentOfKind(element, 'p-fieldset-wrapper')) &&
	        isRequired(element.parentElement));
	};

	const isRequiredAndParentNotRequired = (element, child) => {
	    return isRequired(child) && !isParentFieldsetRequired(element);
	};

	const labelId = 'label';
	const descriptionId = 'description';
	const Label = ({ host, label, description, htmlFor, isRequired, isLoading, isDisabled, formElement, }) => {
	    return (validateProps.h(validateProps.Fragment, null,
	        validateProps.h("label", { class: "label", id: labelId, "aria-disabled": isLoading || isDisabled ? 'true' : null, ...(htmlFor
	                ? { htmlFor }
	                : {
	                    onClick: (event) => onLabelClick(event, formElement, isLoading, isDisabled, host),
	                }) }, stateMessageStyles.hasLabel(host, label) && (validateProps.h(validateProps.Fragment, null,
	            label || validateProps.h("slot", { name: "label" }),
	            ((isRequired && !isParentFieldsetRequired(host)) ||
	                (formElement && isRequiredAndParentNotRequired(host, formElement))) && validateProps.h(stateMessageStyles.Required, null)))),
	        hasDescription.hasDescription(host, description) && (validateProps.h("span", { class: "label", id: descriptionId, "aria-disabled": isLoading || isDisabled ? 'true' : null }, description || validateProps.h("slot", { name: "description" })))));
	};
	const onLabelClick = (event, formElement, isLoading, isDisabled, host) => {
	    // we don't want to click/focus the form element, if a link is clicked or when host/form-field is in loading or disabled state
	    if (isLoading || isDisabled || getClosestHTMLElement.getClosestHTMLElement(event.target, 'a') !== null) {
	        return;
	    }
	    if (formElement.tagName === 'INPUT' && (formElement.type === 'checkbox' || formElement.type === 'radio')) {
	        // checkbox-wrapper, radio-button-wrapper
	        formElement.click();
	        // TODO: maybe we should call `formElement.focus();` too, to be in sync with the behaviour of other form fields.
	        //  On the other hand, it would show a focus outline, maybe this then needs to be handled with :focus-visible and :focus fallback instead.
	    }
	    else if (formElement.tagName === 'SELECT') {
	        // select-wrapper
	        // TODO: should be refactored in select-wrapper, so that "for" attribute becomes possible to use
	        const el = host.shadowRoot.children[0].querySelector('.dropdown')?.shadowRoot.children[0]; // input or button of p-select-wrapper-dropdown
	        if (el) {
	            el.click();
	            el.focus();
	        }
	        else {
	            formElement.focus(); // it's not possible to open the native option list of a select by JS
	        }
	    }
	    else if (formElement.tagName === 'INPUT' || formElement.tagName === 'TEXTAREA') {
	        // text-field-wrapper, textarea-wrapper
	        formElement.focus();
	    }
	};

	const getFunctionalComponentLabelStyles = (isDisabledOrLoading, hideLabel, theme, additionalDefaultJssStyle, additionalIsShownJssStyle) => {
	    const { primaryColor, disabledColor, contrastHighColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, disabledColor: disabledColorDark, contrastHighColor: contrastHighColorDark, } = validateProps.getThemedColors('dark');
	    return {
	        label: {
	            ...textSmallStyle.textSmallStyle,
	            cursor: isDisabledOrLoading ? 'not-allowed' : 'pointer',
	            justifySelf: 'flex-start', // ensures label is not getting stretched by flex or grid context of its parent
	            color: isDisabledOrLoading ? disabledColor : primaryColor,
	            transition: validateProps.getTransition('color'), // for smooth transitions between e.g. disabled state
	            ...validateProps.buildResponsiveStyles(hideLabel, (isHidden) => validateProps.getHiddenTextJssStyle(isHidden, additionalIsShownJssStyle)),
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                color: isDisabledOrLoading ? disabledColorDark : primaryColorDark,
	            }),
	            '&:empty': {
	                display: 'none', // prevents outer spacing caused by parents grid gap, in case no label value is defined (although it has to be set to be a11y compliant)
	            },
	            '&+&': {
	                cursor: 'unset',
	                marginTop: `-${spacingStaticXSmall.spacingStaticXSmall}`,
	                fontSize: fontSizeTextXSmall.fontSizeTextXSmall,
	                ...(!isDisabledOrLoading && {
	                    color: contrastHighColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        color: contrastHighColorDark,
	                    }),
	                }),
	            },
	            ...additionalDefaultJssStyle,
	        },
	        // .required
	        ...stateMessageStyles.getFunctionalComponentRequiredStyles(),
	    };
	};

	labelStylesD5916d0e.Label = Label;
	labelStylesD5916d0e.descriptionId = descriptionId;
	labelStylesD5916d0e.getFunctionalComponentLabelStyles = getFunctionalComponentLabelStyles;
	labelStylesD5916d0e.isRequiredAndParentNotRequired = isRequiredAndParentNotRequired;
	labelStylesD5916d0e.labelId = labelId;

	
	return labelStylesD5916d0e;
}

var linkAriaAttribute6f29e1a0 = {};

var hasRequiredLinkAriaAttribute6f29e1a0;

function requireLinkAriaAttribute6f29e1a0 () {
	if (hasRequiredLinkAriaAttribute6f29e1a0) return linkAriaAttribute6f29e1a0;
	hasRequiredLinkAriaAttribute6f29e1a0 = 1;

	const LINK_ARIA_ATTRIBUTES = ['aria-label', 'aria-current', 'aria-haspopup'];

	linkAriaAttribute6f29e1a0.LINK_ARIA_ATTRIBUTES = LINK_ARIA_ATTRIBUTES;

	
	return linkAriaAttribute6f29e1a0;
}

var linkButtonPureStyles102ff74a = {};

var preventFoucOfNestedElementsStylesE5a706ce = {};

var hasRequiredPreventFoucOfNestedElementsStylesE5a706ce;

function requirePreventFoucOfNestedElementsStylesE5a706ce () {
	if (hasRequiredPreventFoucOfNestedElementsStylesE5a706ce) return preventFoucOfNestedElementsStylesE5a706ce;
	hasRequiredPreventFoucOfNestedElementsStylesE5a706ce = 1;

	const preventFoucOfNestedElementsStyles = {
	    ':not(:defined,[data-ssr])': {},
	};

	preventFoucOfNestedElementsStylesE5a706ce.preventFoucOfNestedElementsStyles = preventFoucOfNestedElementsStyles;

	
	return preventFoucOfNestedElementsStylesE5a706ce;
}

var hasRequiredLinkButtonPureStyles102ff74a;

function requireLinkButtonPureStyles102ff74a () {
	if (hasRequiredLinkButtonPureStyles102ff74a) return linkButtonPureStyles102ff74a;
	hasRequiredLinkButtonPureStyles102ff74a = 1;

	const validateProps = requireValidateProps788e2bc5();
	const buttonLinkPureUtils = requireButtonLinkPureUtils42aabf78();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const fontSizeTextStyles = requireFontSizeTextStyles4439a071();
	const textSmallStyle = requireTextSmallStyle00e1c6e2();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const frostedGlassStyle = requireFrostedGlassStyleBd067e45();
	const fontLineHeight = requireFontLineHeightD4b9e1a9();

	// Needed for slotted anchor and hidden label, which then enlarges the hidden label to equal host size and indents the text to be visually hidden.
	const getVisibilityJssStyle = (hideLabel) => {
	    return hideLabel
	        ? {
	            whiteSpace: 'nowrap',
	            textIndent: '-999999px', // Needed because standard sr-only classes don't work here due that we need a bounding box for the focus style
	            overflow: 'hidden',
	        }
	        : {
	            whiteSpace: 'inherit',
	            textIndent: 0,
	            overflow: 'visible',
	        };
	};
	const offsetVertical = '-2px';
	const offsetHorizontal = '-4px';
	const getLinkButtonPureStyles = (icon, iconSource, active, isDisabledOrLoading, stretch, size, hideLabel, alignLabel, underline, hasSlottedAnchor, theme) => {
	    const { primaryColor, disabledColor, hoverColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, disabledColor: disabledColorDark, hoverColor: hoverColorDark, } = validateProps.getThemedColors('dark');
	    const hasIcon = buttonLinkPureUtils.hasVisibleIcon(icon, iconSource);
	    return {
	        '@global': {
	            ':host': {
	                ...validateProps.addImportantToEachRule({
	                    transform: 'translate3d(0,0,0)', // creates new stacking context
	                    outline: 0, // custom element is able to delegate the focus
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	                ...validateProps.buildResponsiveStyles(stretch, (responsiveStretch) => ({
	                    display: responsiveStretch ? 'block' : 'inline-block',
	                    width: responsiveStretch ? '100%' : 'auto', // prevents adjusting its size when used as flex or grid child
	                    ...(!responsiveStretch && { verticalAlign: 'top' }),
	                })),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	        },
	        root: {
	            display: 'flex',
	            width: '100%',
	            padding: 0,
	            margin: 0, // Removes default button margin on safari 15
	            color: isDisabledOrLoading ? disabledColor : primaryColor,
	            textDecoration: underline ? 'underline' : 'none',
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                color: isDisabledOrLoading ? disabledColorDark : primaryColorDark,
	            }),
	            ...textSmallStyle.textSmallStyle,
	            ...validateProps.mergeDeep(validateProps.buildResponsiveStyles(hideLabel, (hidelabelValue) => ({
	                gap: hidelabelValue ? 0 : spacingStaticXSmall.spacingStaticXSmall,
	            })), validateProps.buildResponsiveStyles(stretch, (stretchValue) => ({
	                justifyContent: stretchValue ? 'space-between' : 'flex-start',
	                alignItems: stretchValue ? 'center' : 'flex-start',
	            })), validateProps.buildResponsiveStyles(size, (sizeValue) => ({
	                fontSize: fontSizeTextStyles.getFontSizeText(sizeValue),
	            }))),
	            '&::before': {
	                content: '""',
	                position: 'absolute', // mobile Safari -> prevent lagging active state
	                top: offsetVertical,
	                bottom: offsetVertical,
	                ...validateProps.buildResponsiveStyles(hideLabel, (hideLabelValue) => ({
	                    right: hideLabelValue ? offsetVertical : offsetHorizontal,
	                    left: hideLabelValue ? offsetVertical : offsetHorizontal,
	                })),
	                borderRadius: borderRadiusSmall.borderRadiusSmall,
	                transition: validateProps.getTransition('background-color'),
	                ...(active && {
	                    ...frostedGlassStyle.frostedGlassStyle,
	                    backgroundColor: hoverColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        backgroundColor: hoverColorDark,
	                    }),
	                }),
	            },
	            ...(!isDisabledOrLoading &&
	                hoverMediaQuery.hoverMediaQuery({
	                    '&:hover::before': {
	                        ...frostedGlassStyle.frostedGlassStyle,
	                        backgroundColor: hoverColor,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            backgroundColor: hoverColorDark,
	                        }),
	                    },
	                })),
	            ...(!hasSlottedAnchor && validateProps.getFocusJssStyle(theme, { pseudo: true, offset: '-2px' })),
	        },
	        ...(hasIcon
	            ? {
	                icon: {
	                    position: 'relative',
	                    flexShrink: '0',
	                    width: fontLineHeight.fontLineHeight,
	                    height: fontLineHeight.fontLineHeight,
	                    // workaround for Safari to optimize vertical alignment of icons
	                    // TODO: check if this is still needed after optimized icons are included
	                    '@supports (width: round(down, 1px, 1px))': {
	                        width: `round(down, ${fontLineHeight.fontLineHeight}, 1px)`,
	                        height: `round(down, ${fontLineHeight.fontLineHeight}, 1px)`,
	                    },
	                },
	                label: validateProps.mergeDeep({ zIndex: '1' }, // fix Firefox bug on :hover (#2583) & pure-link with nested anchor & hidden label (#3349)
	                validateProps.buildResponsiveStyles(hideLabel, getVisibilityJssStyle), validateProps.buildResponsiveStyles(alignLabel, (alignLabelValue) => ({
	                    // TODO: we should remove 'left' here and map the value in the component class already to 'start' but might be difficult due to breakpoint customizable prop value
	                    order: alignLabelValue === 'left' || alignLabelValue === 'start' ? -1 : 0,
	                }))),
	            }
	            : {
	                label: {
	                    position: 'relative', // needed for hover state when icon="none" is set
	                },
	            }),
	    };
	};

	linkButtonPureStyles102ff74a.getLinkButtonPureStyles = getLinkButtonPureStyles;
	linkButtonPureStyles102ff74a.offsetHorizontal = offsetHorizontal;
	linkButtonPureStyles102ff74a.offsetVertical = offsetVertical;

	
	return linkButtonPureStyles102ff74a;
}

var linkButtonStyles7215407d = {};

var hasRequiredLinkButtonStyles7215407d;

function requireLinkButtonStyles7215407d () {
	if (hasRequiredLinkButtonStyles7215407d) return linkButtonStyles7215407d;
	hasRequiredLinkButtonStyles7215407d = 1;

	const validateProps = requireValidateProps788e2bc5();
	const changeColor = requireChangeColor50831612();
	const buttonLinkPureUtils = requireButtonLinkPureUtils42aabf78();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const textSmallStyle = requireTextSmallStyle00e1c6e2();
	const frostedGlassStyle = requireFrostedGlassStyleBd067e45();
	const fontLineHeight = requireFontLineHeightD4b9e1a9();

	const { primaryColor: darkThemePrimaryColor } = validateProps.getThemedColors('dark');
	const { primaryColor: lightThemePrimaryColor } = validateProps.getThemedColors('light');
	const getVariantColors = (variant, theme) => {
	    const { primaryColor, contrastHighColor, contrastMediumColor, hoverColor, backgroundFrostedColor } = validateProps.getThemedColors(theme);
	    const { canvasColor } = validateProps.getHighContrastColors();
	    const colors = {
	        primary: {
	            textColor: theme === 'dark' ? lightThemePrimaryColor : darkThemePrimaryColor,
	            borderColor: primaryColor,
	            borderColorHover: contrastHighColor,
	            backgroundColor: primaryColor,
	            backgroundColorHover: contrastHighColor,
	        },
	        secondary: {
	            textColor: primaryColor,
	            borderColor: primaryColor,
	            borderColorHover: contrastMediumColor,
	            backgroundColor: validateProps.isHighContrastMode ? canvasColor : 'transparent',
	            backgroundColorHover: hoverColor,
	        },
	        ghost: {
	            textColor: primaryColor,
	            borderColor: backgroundFrostedColor,
	            borderColorHover: theme === 'dark' ? changeColor.lighten(backgroundFrostedColor) : changeColor.darken(backgroundFrostedColor),
	            backgroundColor: backgroundFrostedColor,
	            backgroundColorHover: theme === 'dark' ? changeColor.lighten(backgroundFrostedColor) : changeColor.darken(backgroundFrostedColor),
	        },
	    };
	    return colors[variant === 'tertiary' ? 'secondary' : variant];
	};
	const getLinkButtonStyles = (icon, iconSource, variant, hideLabel, isDisabledOrLoading, hasSlottedAnchor, compact, cssVariableInternalScaling, theme) => {
	    const isPrimary = variant === 'primary';
	    const { textColor, borderColor, borderColorHover, backgroundColor, backgroundColorHover } = getVariantColors(variant, theme);
	    const { textColor: textColorDark, borderColor: borderColorDark, borderColorHover: borderColorHoverDark, backgroundColor: backgroundColorDark, backgroundColorHover: backgroundColorHoverDark, } = getVariantColors(variant, 'dark');
	    const { focusColor } = validateProps.getThemedColors(theme);
	    const hasIcon = buttonLinkPureUtils.hasVisibleIcon(icon, iconSource) || hideLabel;
	    const scalingVar = `var(${cssVariableInternalScaling}, var(--p-internal-scaling-factor))`;
	    const borderCompensation = variant === 'ghost' ? `+ ${validateProps.borderWidthBase}` : ''; // Compensate for missing border in ghost variant (Fixes border backdrop-filter blur rendering issue in safari)
	    const paddingBlock = `calc(${scalingVar} * 0.8125 * ${validateProps.SCALING_BASE_VALUE} ${borderCompensation})`; // 0.8125 * SCALING_BASE_VALUE corresponds to 13px
	    const paddingInline = `max(calc(${scalingVar} * 1.625 * ${validateProps.SCALING_BASE_VALUE} ${borderCompensation}), ${variant === 'ghost' ? '6px' : '4px'})`; // 1.625 * SCALING_BASE_VALUE corresponds to 26px
	    const gap = `clamp(2px, calc(${scalingVar} * 0.5 * ${validateProps.SCALING_BASE_VALUE}), 16px)`; // 0.5 * SCALING_BASE_VALUE corresponds to 8px
	    const iconMarginInlineStart = `clamp(-16px, calc(${scalingVar} * -0.5 * ${validateProps.SCALING_BASE_VALUE}), -2px)`; // -0.5 * SCALING_BASE_VALUE corresponds to -8px
	    return {
	        '@global': {
	            ':host': {
	                display: 'inline-block',
	                ...validateProps.addImportantToEachRule({
	                    verticalAlign: 'top',
	                    outline: 0, // custom element is able to delegate the focus
	                    borderRadius: borderRadiusSmall.borderRadiusSmall,
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	        },
	        root: {
	            display: 'flex',
	            alignItems: 'flex-start',
	            justifyContent: 'center',
	            width: '100%', // Allows for setting a width on the host
	            minWidth: 'min-content', // Do not shrink beyond icon size + padding + border + label
	            boxSizing: 'border-box',
	            textAlign: 'start',
	            WebkitAppearance: 'none', // iOS safari
	            appearance: 'none',
	            textDecoration: 'none',
	            ...textSmallStyle.textSmallStyle,
	            ...(variant === 'ghost'
	                ? { ...frostedGlassStyle.frostedGlassStyle, border: 'none' } // We can't use a border in the ghost variant due to rendering issues with backdrop-filter in safari
	                : { border: `${validateProps.borderWidthBase} solid ${borderColor}` }),
	            borderRadius: borderRadiusSmall.borderRadiusSmall,
	            transform: 'translate3d(0,0,0)', // creates new stacking context (for slotted anchor + focus)
	            backgroundColor,
	            color: textColor,
	            ...validateProps.buildResponsiveStyles(compact, (compactValue) => ({
	                '--p-internal-scaling-factor': compactValue ? 'calc(4 / 13)' : 1, // Compact mode needs to have 4px paddingBlock thus this scaling factor
	            })),
	            transition: `${validateProps.getTransition('background-color')}, ${validateProps.getTransition('border-color')}, ${validateProps.getTransition('color')}`,
	            ...validateProps.buildResponsiveStyles(hideLabel, (hideLabelValue) => ({
	                padding: hideLabelValue ? paddingBlock : `${paddingBlock} ${paddingInline}`,
	                gap: hideLabelValue ? 0 : gap,
	            })),
	            ...(!hasSlottedAnchor && validateProps.getFocusJssStyle(theme)),
	            ...(!isDisabledOrLoading &&
	                hoverMediaQuery.hoverMediaQuery({
	                    '&:hover': {
	                        backgroundColor: backgroundColorHover,
	                        borderColor: validateProps.isHighContrastMode ? focusColor : borderColorHover,
	                        ...(!isPrimary && frostedGlassStyle.frostedGlassStyle),
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            backgroundColor: backgroundColorHoverDark,
	                            borderColor: borderColorHoverDark,
	                        }),
	                    },
	                })),
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                borderColor: borderColorDark,
	                backgroundColor: backgroundColorDark,
	                color: textColorDark,
	            }),
	        },
	        label: validateProps.buildResponsiveStyles(hideLabel, validateProps.getHiddenTextJssStyle),
	        ...(hasIcon && {
	            icon: {
	                width: fontLineHeight.fontLineHeight, // ensure space is already reserved until icon component is loaded (ssr)
	                height: fontLineHeight.fontLineHeight, // ensure space is already reserved until icon component is loaded (ssr)
	                ...validateProps.buildResponsiveStyles(hideLabel, (hideLabelValue) => ({
	                    marginInlineStart: hideLabelValue ? 0 : iconMarginInlineStart, // compensate white space of svg icon and optimize visual alignment
	                })),
	            },
	        }),
	    };
	};

	linkButtonStyles7215407d.getLinkButtonStyles = getLinkButtonStyles;

	
	return linkButtonStyles7215407d;
}

var linkButtonVariantB99795db = {};

var hasRequiredLinkButtonVariantB99795db;

function requireLinkButtonVariantB99795db () {
	if (hasRequiredLinkButtonVariantB99795db) return linkButtonVariantB99795db;
	hasRequiredLinkButtonVariantB99795db = 1;

	/** @deprecated */
	const LINK_BUTTON_VARIANTS_DEPRECATED = ['tertiary'];
	const LINK_BUTTON_VARIANTS = ['primary', 'secondary', 'ghost', ...LINK_BUTTON_VARIANTS_DEPRECATED];

	linkButtonVariantB99795db.LINK_BUTTON_VARIANTS = LINK_BUTTON_VARIANTS;

	
	return linkButtonVariantB99795db;
}

var linkStyles76fc91e3 = {};

var hasRequiredLinkStyles76fc91e3;

function requireLinkStyles76fc91e3 () {
	if (hasRequiredLinkStyles76fc91e3) return linkStyles76fc91e3;
	hasRequiredLinkStyles76fc91e3 = 1;

	const validateProps = requireValidateProps788e2bc5();
	const linkButtonStyles = requireLinkButtonStyles7215407d();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();

	const cssVariableInternalLinkScaling = '--p-internal-link-scaling';
	const getComponentCss = (icon, iconSource, variant, hideLabel, hasSlottedAnchor, compact, theme) => {
	    const { linkColor } = validateProps.getHighContrastColors();
	    const isPrimary = variant === 'primary';
	    return validateProps.getCss(validateProps.mergeDeep(linkButtonStyles.getLinkButtonStyles(icon, iconSource, variant, hideLabel, false, hasSlottedAnchor, compact, cssVariableInternalLinkScaling, theme), {
	        label: {
	            clip: validateProps.addImportantToRule('unset'), // to overrule breakpoint customizable hide-label style
	        },
	        icon: {
	            ...(isPrimary &&
	                !validateProps.isHighContrastMode && {
	                filter: 'invert(1)',
	            }),
	        },
	    }, hasSlottedAnchor && {
	        ...(validateProps.isHighContrastMode && {
	            root: {
	                borderColor: linkColor,
	            },
	        }),
	        '@global': validateProps.addImportantToEachRule({
	            '::slotted': {
	                '&(a)': {
	                    ...validateProps.getResetInitialStylesForSlottedAnchor,
	                    textDecoration: 'none',
	                    font: 'inherit',
	                    color: 'inherit',
	                },
	                // The clickable area for Safari < ~15 (<= release date: 2021-10-28) is reduced to the slotted anchor itself,
	                // since Safari prior to this major release does not support pseudo-elements in the slotted context
	                // (https://bugs.webkit.org/show_bug.cgi?id=178237)
	                '&(a)::before': {
	                    content: '""',
	                    position: 'fixed',
	                    inset: variant === 'ghost' ? '0px' : '-2px', // Variant ghost has no border to compensate
	                    borderRadius: borderRadiusSmall.borderRadiusSmall,
	                },
	                ...validateProps.getFocusJssStyle(theme, { slotted: 'a', pseudo: true }),
	            },
	        }),
	    }));
	};

	linkStyles76fc91e3.getComponentCss = getComponentCss;

	
	return linkStyles76fc91e3;
}

var linkTileUtilsFce9594a = {};

var tileUtils82ea5cf8 = {};

var hasRequiredTileUtils82ea5cf8;

function requireTileUtils82ea5cf8 () {
	if (hasRequiredTileUtils82ea5cf8) return tileUtils82ea5cf8;
	hasRequiredTileUtils82ea5cf8 = 1;

	requireValidateProps788e2bc5();
	const getDirectChildHTMLElement = requireGetDirectChildHTMLElement18d9487f();

	const _gradient = 'rgba(31,31,31,0.9) 0%,' +
	    'rgba(31,31,31,0.9) 20%,' +
	    'rgba(31,31,31,0.852589) 26.67%,' +
	    'rgba(32,32,32,0.768225) 33.33%,' +
	    'rgba(33,33,33,0.668116) 40%,' +
	    'rgba(34,34,34,0.557309) 46.67%,' +
	    'rgba(35,35,35,0.442691) 53.33%,' +
	    'rgba(36,36,36,0.331884) 60%,' +
	    'rgba(37,37,37,0.231775) 66.67%,' +
	    'rgba(38,38,38,0.147411) 73.33%,' +
	    'rgba(39,39,39,0.0816599) 80%,' +
	    'rgba(39,39,39,0.03551) 86.67%,' +
	    'rgba(39,39,39,0.0086472) 93.33%,' +
	    'rgba(39,39,39,0)';

	const gradientToTopStyle = {
	    background: `linear-gradient(to top, ${_gradient} 100%);`,
	};

	const preventAutoPlayOfSlottedVideoOnPrefersReducedMotion = (host) => {
	    const video = getDirectChildHTMLElement.getDirectChildHTMLElement(host, 'video');
	    if (video?.hasAttribute('autoplay') && matchMedia('(prefers-reduced-motion)').matches) {
	        video.pause();
	    }
	};

	/** @deprecated */
	const TILE_ASPECT_RATIOS_DEPRECATED = ['1:1', '4:3', '3:4', '16:9', '9:16'];
	const TILE_ASPECT_RATIOS = ['1/1', '4/3', '3/4', '16/9', '9/16', ...TILE_ASPECT_RATIOS_DEPRECATED];
	/** @deprecated */
	const TILE_SIZES_DEPRECATED = ['default'];
	const TILE_SIZES = ['medium', 'large', 'inherit', ...TILE_SIZES_DEPRECATED];
	const TILE_WEIGHTS = ['regular', 'semi-bold'];
	const TILE_ALIGNS = ['top', 'bottom'];

	tileUtils82ea5cf8.TILE_ALIGNS = TILE_ALIGNS;
	tileUtils82ea5cf8.TILE_ASPECT_RATIOS = TILE_ASPECT_RATIOS;
	tileUtils82ea5cf8.TILE_SIZES = TILE_SIZES;
	tileUtils82ea5cf8.TILE_WEIGHTS = TILE_WEIGHTS;
	tileUtils82ea5cf8._gradient = _gradient;
	tileUtils82ea5cf8.gradientToTopStyle = gradientToTopStyle;
	tileUtils82ea5cf8.preventAutoPlayOfSlottedVideoOnPrefersReducedMotion = preventAutoPlayOfSlottedVideoOnPrefersReducedMotion;

	
	return tileUtils82ea5cf8;
}

var themeBfc10573 = {};

var hasRequiredThemeBfc10573;

function requireThemeBfc10573 () {
	if (hasRequiredThemeBfc10573) return themeBfc10573;
	hasRequiredThemeBfc10573 = 1;

	const THEMES = ['light', 'dark', 'auto'];

	themeBfc10573.THEMES = THEMES;

	
	return themeBfc10573;
}

var hasRequiredLinkTileUtilsFce9594a;

function requireLinkTileUtilsFce9594a () {
	if (hasRequiredLinkTileUtilsFce9594a) return linkTileUtilsFce9594a;
	hasRequiredLinkTileUtilsFce9594a = 1;

	const tileUtils = requireTileUtils82ea5cf8();
	const validateProps = requireValidateProps788e2bc5();
	const theme = requireThemeBfc10573();

	const gradientToBottomStyle = {
	    background: `linear-gradient(to bottom, ${tileUtils._gradient} 100%);`,
	};

	/** @deprecated */
	const LINK_TILE_WEIGHTS_DEPRECATED = ['semibold'];
	const LINK_TILE_WEIGHTS = [...tileUtils.TILE_WEIGHTS, ...LINK_TILE_WEIGHTS_DEPRECATED];
	const sharedTilePropTypes = {
	    size: validateProps.AllowedTypes.breakpoint(tileUtils.TILE_SIZES),
	    background: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    aspectRatio: validateProps.AllowedTypes.breakpoint(tileUtils.TILE_ASPECT_RATIOS),
	    label: validateProps.AllowedTypes.string,
	    description: validateProps.AllowedTypes.string,
	    align: validateProps.AllowedTypes.oneOf(tileUtils.TILE_ALIGNS),
	    gradient: validateProps.AllowedTypes.boolean,
	    compact: validateProps.AllowedTypes.breakpoint('boolean'),
	};

	linkTileUtilsFce9594a.LINK_TILE_WEIGHTS = LINK_TILE_WEIGHTS;
	linkTileUtilsFce9594a.gradientToBottomStyle = gradientToBottomStyle;
	linkTileUtilsFce9594a.sharedTilePropTypes = sharedTilePropTypes;

	
	return linkTileUtilsFce9594a;
}

var loadingMessageStyles100c7f01 = {};

var hasRequiredLoadingMessageStyles100c7f01;

function requireLoadingMessageStyles100c7f01 () {
	if (hasRequiredLoadingMessageStyles100c7f01) return loadingMessageStyles100c7f01;
	hasRequiredLoadingMessageStyles100c7f01 = 1;

	const validateProps = requireValidateProps788e2bc5();

	const loadingId = 'loading';
	const LoadingMessage = ({ loading, initialLoading }) => {
	    return (validateProps.h("span", { id: loadingId, class: "loading", role: "status" }, loading ? 'Loading' : initialLoading ? 'Loading finished' : ''));
	};

	const getFunctionalComponentLoadingMessageStyles = () => {
	    return {
	        loading: validateProps.getHiddenTextJssStyle(),
	    };
	};

	loadingMessageStyles100c7f01.LoadingMessage = LoadingMessage;
	loadingMessageStyles100c7f01.getFunctionalComponentLoadingMessageStyles = getFunctionalComponentLoadingMessageStyles;
	loadingMessageStyles100c7f01.loadingId = loadingId;

	
	return loadingMessageStyles100c7f01;
}

var observer98c271bc = {};

var hasRequiredObserver98c271bc;

function requireObserver98c271bc () {
	if (hasRequiredObserver98c271bc) return observer98c271bc;
	hasRequiredObserver98c271bc = 1;

	/**
	 * Map of scrollArea elements which are used as root in the corresponding IntersectionObserver instance.
	 * Used in order to create only one Intersection Observer instance per scrollArea element.
	 */
	const scrollAreaObserverMap = new Map();
	/**
	 * Map of observed nodes and their corresponding IntersectionObserver instances.
	 */
	const observedStickyNodesMap = new Map();
	/**
	 * Creates an IntersectionObserver for observing sticky elements within a scroll area.
	 * @param {HTMLElement} scrollArea - The scroll area containing the sticky elements.
	 * @returns {IntersectionObserver} - The created IntersectionObserver instance.
	 */
	const getIntersectionObserverStickyArea = (scrollArea) => {
	    return new IntersectionObserver((entries) => {
	        for (const { target, isIntersecting } of entries) {
	            target.toggleAttribute('data-stuck', !isIntersecting);
	        }
	    }, {
	        root: scrollArea,
	        threshold: 1,
	    });
	};
	/**
	 * Observes a sticky area with IntersectionObserver and ensures it's only added once.
	 * @param {HTMLElement} scrollArea - The scroll area containing the sticky element.
	 * @param {HTMLElement} stickyNode - The sticky element to observe.
	 */
	const observeStickyArea = (scrollArea, stickyNode) => {
	    let observer = scrollAreaObserverMap.get(scrollArea);
	    if (!observer) {
	        observer = getIntersectionObserverStickyArea(scrollArea);
	        scrollAreaObserverMap.set(scrollArea, observer);
	    }
	    if (!observedStickyNodesMap.has(stickyNode)) {
	        observer.observe(stickyNode);
	        observedStickyNodesMap.set(stickyNode, observer);
	    }
	};

	observer98c271bc.observeStickyArea = observeStickyArea;

	
	return observer98c271bc;
}

var pAccordion_cjs_entry = {};

var warnIfDeprecatedPropIsUsed76f87eda = {};

var hasRequiredWarnIfDeprecatedPropIsUsed76f87eda;

function requireWarnIfDeprecatedPropIsUsed76f87eda () {
	if (hasRequiredWarnIfDeprecatedPropIsUsed76f87eda) return warnIfDeprecatedPropIsUsed76f87eda;
	hasRequiredWarnIfDeprecatedPropIsUsed76f87eda = 1;

	const helper = requireHelper22e15c0e();
	const validateProps = requireValidateProps788e2bc5();

	const warnIfDeprecatedPropIsUsed = (instance, prop, additionalText) => {
	    const propValue = instance[prop];
	    if (propValue !== undefined && propValue !== null) {
	        validateProps.consoleWarn(helper.getDeprecatedPropOrSlotWarningMessage(instance.host, prop), additionalText || '', instance.host);
	    }
	};

	warnIfDeprecatedPropIsUsed76f87eda.warnIfDeprecatedPropIsUsed = warnIfDeprecatedPropIsUsed;

	
	return warnIfDeprecatedPropIsUsed76f87eda;
}

var slottedAnchorStylesFe1a10c2 = {};

var hasRequiredSlottedAnchorStylesFe1a10c2;

function requireSlottedAnchorStylesFe1a10c2 () {
	if (hasRequiredSlottedAnchorStylesFe1a10c2) return slottedAnchorStylesFe1a10c2;
	hasRequiredSlottedAnchorStylesFe1a10c2 = 1;

	const validateProps = requireValidateProps788e2bc5();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const borderRadiusMedium = requireBorderRadiusMedium758b9411();

	const themeLightStateHover = 'rgba(148, 149, 152, .18)';

	const offsetHorizontal = '2px';
	const getHoverStyles = (borderRadius = 'small') => {
	    const borderRadiusValue = borderRadius === 'small'
	        ? borderRadiusSmall.borderRadiusSmall
	        : borderRadius === 'medium'
	            ? borderRadiusMedium.borderRadiusMedium
	            : borderRadius || borderRadiusSmall.borderRadiusSmall;
	    return {
	        borderRadius: borderRadiusValue, // it's visually being reflected on both (when placed here), element and hover
	        marginLeft: `-${offsetHorizontal}`,
	        marginRight: `-${offsetHorizontal}`,
	        paddingLeft: offsetHorizontal,
	        paddingRight: offsetHorizontal,
	        transition: `background var(--p-transition-duration, ${validateProps.motionDurationShort}) ${validateProps.motionEasingBase}`,
	    };
	};
	const getHoverNestedStyles = () => {
	    return {
	        background: themeLightStateHover, // hover color is equal for light and dark theme
	    };
	};
	const getHoverStyle = (opts) => {
	    const { borderRadius } = {};
	    return {
	        ...getHoverStyles(borderRadius),
	        // TODO: how can we test this later in vrt?
	        '@media(hover:hover)': {
	            '&:hover': {
	                ...getHoverNestedStyles(),
	            },
	        },
	    };
	};

	const getSlottedAnchorStyles = (tagName) => ({
	    '@global': {
	        // it's important to reset following styles again for components supporting ::slotted(a) like Link, Link-Pure, Tag and Tabs-Bar,
	        [`${tagName} a`]: validateProps.addImportantToEachRule({
	            textDecoration: 'underline',
	            color: 'currentcolor',
	            ...getHoverStyle(),
	            // light and dark theme are using the same color atm.
	            ...validateProps.getFocusJssStyle('light', { offset: 0 }),
	        }),
	    },
	});

	slottedAnchorStylesFe1a10c2.getSlottedAnchorStyles = getSlottedAnchorStyles;

	
	return slottedAnchorStylesFe1a10c2;
}

var hasRequiredPAccordion_cjs_entry;

function requirePAccordion_cjs_entry () {
	if (hasRequiredPAccordion_cjs_entry) return pAccordion_cjs_entry;
	hasRequiredPAccordion_cjs_entry = 1;

	Object.defineProperty(pAccordion_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed76f87eda();
	const theme = requireThemeBfc10573();
	const headingTag = requireHeadingTag6cfe20fe();
	const slottedAnchorStyles = requireSlottedAnchorStylesFe1a10c2();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const textSmallStyle = requireTextSmallStyle00e1c6e2();
	const fontWeightSemiBold = requireFontWeightSemiBold4482c830();
	const fontSizeTextMedium = requireFontSizeTextMedium88887ad8();
	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const fontLineHeight = requireFontLineHeightD4b9e1a9();
	const fontSizeTextXXSmall = requireFontSizeTextXXSmallA02f9c40();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	requireHelper22e15c0e();
	requireBorderRadiusMedium758b9411();
	requireTextShared5216bb19();
	requireFontFamily23874d28();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();

	const getComponentCss = (size, compact, open, theme, sticky) => {
	    const { primaryColor, hoverColor, contrastLowColor, backgroundColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, hoverColor: hoverColorDark, contrastLowColor: contrastLowColorDark, backgroundColor: backgroundColorDark, } = validateProps.getThemedColors('dark');
	    const cssVariablePositionStickyTop = '--p-accordion-position-sticky-top';
	    const positionStickyTopFallback = '0';
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...(compact
	                        ? { transform: 'translate3d(0,0,0)' } // relevant for custom click-area in compact variant
	                        : {
	                            borderBottom: `1px solid ${contrastLowColor}`,
	                            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                                borderColor: contrastLowColorDark,
	                            }),
	                        }),
	                    '&(:only-of-type)': { borderBottom: 0 },
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            button: {
	                display: 'flex',
	                position: 'relative',
	                justifyContent: 'space-between',
	                alignItems: 'center',
	                width: '100%',
	                textDecoration: 'none',
	                border: 0,
	                margin: 0, // Removes default button margin on safari 15
	                gap: '24px',
	                background: 'transparent',
	                cursor: 'pointer',
	                textAlign: 'start',
	                color: primaryColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: primaryColorDark,
	                }),
	                ...textSmallStyle.textSmallStyle,
	                fontWeight: fontWeightSemiBold.fontWeightSemiBold,
	                ...validateProps.buildResponsiveStyles(size, (s) => ({
	                    fontSize: s === 'medium' ? fontSizeTextMedium.fontSizeTextMedium : fontSizeTextSmall.fontSizeTextSmall,
	                    padding: `${compact ? '4px' : s === 'medium' ? '20px' : '15px'} 0`,
	                })),
	                // mergeDeep needed because of hoverMediaQuery in certain modes not wrapping keys and therefore overriding "&::before" key
	                ...validateProps.mergeDeep({
	                    '&::before': {
	                        content: '""',
	                        position: 'absolute',
	                        borderRadius: borderRadiusSmall.borderRadiusSmall,
	                        left: '-4px',
	                        right: '-4px',
	                        ...(compact
	                            ? {
	                                top: '2px',
	                                bottom: '2px',
	                            }
	                            : {
	                                top: '6px',
	                                bottom: '6px',
	                            }),
	                    },
	                }, hoverMediaQuery.hoverMediaQuery({
	                    '&::before': {
	                        transition: validateProps.getTransition('background-color'),
	                    },
	                    '&:hover::before': {
	                        background: hoverColor,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            background: hoverColorDark,
	                        }),
	                    },
	                })),
	                ...validateProps.getFocusJssStyle(theme, { pseudo: true, offset: '-2px' }),
	            },
	        },
	        heading: {
	            margin: 0,
	            ...(sticky && {
	                position: 'sticky',
	                top: `var(${cssVariablePositionStickyTop}, ${positionStickyTopFallback})`,
	                zIndex: 1, // to be on top of the collapsible
	                backgroundColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    backgroundColor: backgroundColorDark,
	                }),
	            }),
	        },
	        'icon-container': {
	            height: fontLineHeight.fontLineHeight,
	            width: fontLineHeight.fontLineHeight,
	            display: 'flex',
	            alignItems: 'center',
	            justifyContent: 'center',
	        },
	        icon: {
	            width: fontLineHeight.fontLineHeight,
	            height: fontLineHeight.fontLineHeight,
	            fontSize: fontSizeTextXXSmall.fontSizeTextXXSmall,
	            transform: open ? 'rotate3d(0)' : 'rotate3d(0,0,1,90deg)',
	            transition: validateProps.getTransition('transform'),
	        },
	        collapsible: {
	            color: primaryColor, // enables color inheritance for slotted content
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                color: primaryColorDark,
	            }),
	            display: 'grid',
	            ...(sticky && {
	                position: 'relative',
	                zIndex: 0, // to be below the heading
	            }),
	            ...(open
	                ? {
	                    gridTemplateRows: '1fr',
	                    visibility: 'inherit',
	                    transition: validateProps.getTransition('grid-template-rows'),
	                    paddingBottom: compact ? spacingStaticSmall.spacingStaticSmall : '24px',
	                }
	                : {
	                    gridTemplateRows: '0fr',
	                    visibility: 'hidden',
	                    transition: `${validateProps.getTransition('grid-template-rows')}, visibility 0s linear var(${validateProps.cssVariableTransitionDuration}, ${validateProps.motionDurationShort})`,
	                }),
	            '& div': {
	                overflow: open ? 'visible' : 'hidden',
	                // Fix overflow issues for overlapping content (e.g. select dropdown)
	                animation: open ? `$overflow var(${validateProps.cssVariableTransitionDuration},${validateProps.motionDurationShort})` : 'none',
	                // Necessary to make focus outlines fully visible
	                padding: '4px',
	                margin: '-4px',
	                // Fix scrollbar issues when slotted content includes .sr-only styles (see issue #3042)
	                transform: 'translate3d(0,0,0)',
	                zIndex: 1,
	            },
	        },
	        '@keyframes overflow': {
	            from: { overflow: 'hidden' },
	            to: { overflow: 'hidden' },
	        },
	    });
	};

	const ACCORDION_SIZES = ['small', 'medium'];

	const propTypes = {
	    size: validateProps.AllowedTypes.breakpoint(ACCORDION_SIZES),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    heading: validateProps.AllowedTypes.string,
	    headingTag: validateProps.AllowedTypes.oneOf(headingTag.HEADING_TAGS),
	    tag: validateProps.AllowedTypes.oneOf([undefined, ...headingTag.HEADING_TAGS]),
	    open: validateProps.AllowedTypes.boolean,
	    compact: validateProps.AllowedTypes.boolean,
	    sticky: validateProps.AllowedTypes.boolean,
	};
	const Accordion = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.accordionChange = validateProps.createEvent(this, "accordionChange", 3);
	        this.update = validateProps.createEvent(this, "update", 3);
	        this.onButtonClick = () => {
	            this.update.emit({ open: !this.open });
	            this.accordionChange.emit({ open: !this.open });
	        };
	        this.size = 'small';
	        this.theme = 'light';
	        this.heading = undefined;
	        this.headingTag = 'h2';
	        this.tag = undefined;
	        this.open = undefined;
	        this.compact = undefined;
	        this.sticky = undefined;
	    }
	    connectedCallback() {
	        validateProps.applyConstructableStylesheetStyles(this.host, slottedAnchorStyles.getSlottedAnchorStyles);
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'tag', 'Please use heading-tag prop instead.');
	        validateProps.attachComponentCss(this.host, getComponentCss, this.size, this.compact, this.open, this.theme, this.sticky);
	        const buttonId = 'accordion-control';
	        const contentId = 'accordion-panel';
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        const Heading = this.tag || this.headingTag;
	        return (validateProps.h(validateProps.Host, { key: 'f468a2a96523ed86c9574fadcc4dd944b64e489c' }, validateProps.h(Heading, { key: 'fd7bfca27cdc732c851d0bab265167aed0c5aea6', class: "heading" }, validateProps.h("button", { key: '3aa60c6c49499418b703220f5f890907320cd0c0', id: buttonId, type: "button", "aria-expanded": this.open ? 'true' : 'false', "aria-controls": contentId, onClick: this.onButtonClick }, this.heading || validateProps.h("slot", { key: '9a6f71b107120572d7b6b81cbb4b7e78b765d977', name: "heading" }), validateProps.h("span", { key: '4dd8e60f8104fc7fabc3b5a4b71cc8fc30303a5b', class: "icon-container" }, validateProps.h(PrefixedTagNames.pIcon, { key: 'aee88d8dcbc584349456b80469574e21b554fa97', class: "icon", name: this.open ? 'minus' : 'plus', theme: this.theme, size: "xx-small", "aria-hidden": "true" })))), validateProps.h("div", { key: '30d647715f18919c3557559d16ab2eb84376e332', id: contentId, class: "collapsible", role: "region", "aria-labelledby": buttonId }, validateProps.h("div", { key: '9f6b89d4f870c32b9b81bef463f77c0a03fab964' }, validateProps.h("slot", { key: '771bb1697bfc5d6e77743bbf27f8b8a2b8f46fe4' })))));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pAccordion_cjs_entry.p_accordion = Accordion;

	
	return pAccordion_cjs_entry;
}

var pBanner_cjs_entry = {};

var warnIfDeprecatedPropValueIsUsed91ceea3c = {};

var hasRequiredWarnIfDeprecatedPropValueIsUsed91ceea3c;

function requireWarnIfDeprecatedPropValueIsUsed91ceea3c () {
	if (hasRequiredWarnIfDeprecatedPropValueIsUsed91ceea3c) return warnIfDeprecatedPropValueIsUsed91ceea3c;
	hasRequiredWarnIfDeprecatedPropValueIsUsed91ceea3c = 1;

	const helper = requireHelper22e15c0e();
	const validateProps = requireValidateProps788e2bc5();

	const warnIfDeprecatedPropValueIsUsed = (instance, prop, deprecationMap) => {
	    const value = instance[prop];
	    if (deprecationMap[value]) {
	        const deprecatedPropWarningMessage = helper.getDeprecatedPropOrSlotWarningMessage(instance.host, `${prop}='${value}'`);
	        validateProps.consoleWarn(deprecatedPropWarningMessage, `Please use ${prop}='${deprecationMap[value]}' instead.`, instance.host);
	    }
	};

	warnIfDeprecatedPropValueIsUsed91ceea3c.warnIfDeprecatedPropValueIsUsed = warnIfDeprecatedPropValueIsUsed;

	
	return warnIfDeprecatedPropValueIsUsed91ceea3c;
}

var hasRequiredPBanner_cjs_entry;

function requirePBanner_cjs_entry () {
	if (hasRequiredPBanner_cjs_entry) return pBanner_cjs_entry;
	hasRequiredPBanner_cjs_entry = 1;

	Object.defineProperty(pBanner_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const bannerUtils = requireBannerUtils2cc83734();
	const hasNamedSlot = requireHasNamedSlot273cd3ae();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed91ceea3c();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed76f87eda();
	const theme = requireThemeBfc10573();
	const headingTag = requireHeadingTag6cfe20fe();
	const constants = requireConstants3998cc0f();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const gridExtendedOffsetBase = requireGridExtendedOffsetBaseFb9830f6();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const gridExtendedOffsetXXL = requireGridExtendedOffsetXXLC7a41e50();
	const helper = requireHelper22e15c0e();
	const slottedAnchorStyles = requireSlottedAnchorStylesFe1a10c2();
	requireGetNamedSlot223c478a();
	requireDropShadowShared6e50faf3();
	requireGridGapB5b73e4a();
	requireSpacingFluidMedium88ab712b();
	requireBorderRadiusMedium758b9411();

	const getBannerPopoverResetStyles = () => {
	    return {
	        position: 'fixed',
	        margin: 0,
	        padding: 0,
	        inset: 'auto', // ua popover reset
	        width: 'auto', // ua popover reset
	        height: 'auto', // ua popover reset
	        maxWidth: '100%', // If component is wrapped in container with maxWidth
	        border: '0', // ua popover reset
	        outline: '0', // ua popover reset
	        overflow: 'visible', // ua popover reset
	    };
	};

	const cssVariableTop = '--p-banner-position-top';
	const cssVariableBottom = '--p-banner-position-bottom';
	const cssVariableZIndex = '--p-internal-banner-z-index';
	const topBottomFallback = '56px';
	const getComponentCss = (isOpen) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...getBannerPopoverResetStyles(),
	                    bottom: `var(${cssVariableBottom},${topBottomFallback})`,
	                    left: gridExtendedOffsetBase.gridExtendedOffsetBase,
	                    right: gridExtendedOffsetBase.gridExtendedOffsetBase,
	                    zIndex: `var(${cssVariableZIndex},${constants.BANNER_Z_INDEX})`,
	                    ...constants.dropShadowHighStyle,
	                    borderRadius: borderRadiusSmall.borderRadiusSmall, // needed for rounded box-shadow
	                    '&::backdrop': {
	                        display: 'none',
	                    },
	                    ...(isOpen
	                        ? {
	                            opacity: 1,
	                            visibility: 'inherit',
	                            pointerEvents: 'inherit',
	                            transform: 'translate3d(0,0,0)',
	                            transition: `${validateProps.getTransition('transform', 'moderate', 'in')}, ${validateProps.getTransition('opacity', 'moderate', 'in')}`,
	                        }
	                        : {
	                            opacity: 0,
	                            visibility: 'hidden',
	                            pointerEvents: 'none',
	                            transform: `translate3d(0,calc(var(${cssVariableBottom},${topBottomFallback}) + 100%),0)`,
	                            '&(.hydrated),&(.ssr)': {
	                                transition: `visibility 0s linear var(${validateProps.cssVariableTransitionDuration}, ${validateProps.motionDurationLong}), ${validateProps.getTransition('transform', 'moderate', 'out')}, ${validateProps.getTransition('opacity', 'moderate', 'out')}`,
	                                // during transition the element will be removed from top-layer immediately, resulting in other elements laying over (as of Mai 2024 only Chrome is fixed by this)
	                                '@supports (transition-behavior: allow-discrete)': {
	                                    transition: `visibility 0s linear var(${validateProps.cssVariableTransitionDuration}, ${validateProps.motionDurationLong}), ${validateProps.getTransition('transform', 'moderate', 'out')}, ${validateProps.getTransition('opacity', 'moderate', 'out')}, overlay var(${validateProps.cssVariableTransitionDuration}, ${validateProps.motionDurationModerate}) ${validateProps.motionEasingOut} allow-discrete`,
	                                },
	                            },
	                        }),
	                    [validateProps.getMediaQueryMin('s')]: {
	                        top: `var(${cssVariableTop},${topBottomFallback})`,
	                        bottom: 'auto',
	                        left: gridExtendedOffsetXXL.gridExtendedOffsetS,
	                        right: gridExtendedOffsetXXL.gridExtendedOffsetS,
	                        // space before and after "-" is crucial)
	                        ...(!isOpen && { transform: `translate3d(0,calc(-100% - var(${cssVariableTop},${topBottomFallback})),0)` }),
	                    },
	                    [validateProps.getMediaQueryMin('xxl')]: {
	                        left: gridExtendedOffsetXXL.gridExtendedOffsetXXL,
	                        right: gridExtendedOffsetXXL.gridExtendedOffsetXXL,
	                    },
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	        },
	    });
	};

	const propTypes = {
	    open: validateProps.AllowedTypes.boolean,
	    heading: validateProps.AllowedTypes.string,
	    headingTag: validateProps.AllowedTypes.oneOf(headingTag.HEADING_TAGS),
	    description: validateProps.AllowedTypes.string,
	    state: validateProps.AllowedTypes.oneOf(bannerUtils.BANNER_STATES),
	    dismissButton: validateProps.AllowedTypes.boolean,
	    persistent: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Banner = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.dismiss = validateProps.createEvent(this, "dismiss", 3);
	        this.onKeyboardEvent = (event) => {
	            if (event.key === 'Escape') {
	                this.dismissBanner();
	            }
	        };
	        this.onDismiss = (event) => {
	            if (this.hasDismissButton) {
	                event?.stopPropagation(); // prevent double event emission because of identical name
	                this.dismiss.emit();
	            }
	        };
	        this.dismissBanner = () => {
	            this.dismiss.emit();
	        };
	        this.open = false;
	        this.heading = '';
	        this.headingTag = 'h5';
	        this.description = '';
	        this.state = 'info';
	        this.dismissButton = true;
	        this.persistent = undefined;
	        this.width = undefined;
	        this.theme = 'light';
	    }
	    get hasDismissButton() {
	        return this.persistent ? false : this.dismissButton;
	    }
	    openChangeHandler(isOpen) {
	        if (this.hasDismissButton) {
	            if (isOpen) {
	                document.addEventListener('keydown', this.onKeyboardEvent);
	            }
	            else {
	                document.removeEventListener('keydown', this.onKeyboardEvent);
	            }
	        }
	    }
	    connectedCallback() {
	        validateProps.applyConstructableStylesheetStyles(this.host, slottedAnchorStyles.getSlottedAnchorStyles);
	        if (this.open && this.hasDismissButton) {
	            document.addEventListener('keydown', this.onKeyboardEvent);
	        }
	    }
	    componentDidRender() {
	        // showPopover needs to be called after render cycle to prepare visibility states of popover in order to focus the dismiss button correctly
	        this.setBannerVisibility(this.open);
	        if (this.hasDismissButton) {
	            this.closeBtn = validateProps.getShadowRootHTMLElement(this.inlineNotificationElement, '.close');
	            this.closeBtn?.focus();
	        }
	    }
	    disconnectedCallback() {
	        if (this.open && this.hasDismissButton) {
	            document.removeEventListener('keydown', this.onKeyboardEvent);
	        }
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'state', {
	            neutral: 'info',
	        });
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'persistent', 'Please use dismissButton prop instead.');
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'width', 'The component is aligned with Porsche Grid "extended" by default.');
	        const hasTitleSlot = hasNamedSlot.hasNamedSlot(this.host, 'title');
	        if (hasTitleSlot) {
	            validateProps.consoleWarn(helper.getDeprecatedPropOrSlotWarningMessage(this.host, 'slot="title"'), 'Please use the heading prop or slot="heading" instead.');
	        }
	        validateProps.attachComponentCss(this.host, getComponentCss, this.open);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(validateProps.Host, { key: 'd7d36df795b7bfa8e5563ee2fca7b1005b82c107', popover: "manual" }, validateProps.h(PrefixedTagNames.pInlineNotification, { key: '1a29c0d19d3eda87a864caf6ecfd7c73279f938d', ref: (el) => (this.inlineNotificationElement = el), heading: this.heading, headingTag: this.headingTag, description: this.description, state: this.state, dismissButton: this.hasDismissButton, theme: this.theme, onDismiss: this.onDismiss, "aria-hidden": this.open ? 'false' : 'true' }, hasNamedSlot.hasNamedSlot(this.host, 'heading') ? (validateProps.h("slot", { name: "heading", slot: "heading" })) : (hasTitleSlot && validateProps.h("slot", { name: "title", slot: "heading" })), hasNamedSlot.hasNamedSlot(this.host, 'description') && validateProps.h("slot", { key: 'bae2092fe74208dc40eb52d8e2840575167258ea', name: "description" }))));
	    }
	    setBannerVisibility(isOpen) {
	        if (isOpen) {
	            this.host.showPopover();
	        }
	        else {
	            this.host.hidePopover();
	        }
	    }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "open": ["openChangeHandler"]
	    }; }
	};

	pBanner_cjs_entry.p_banner = Banner;

	
	return pBanner_cjs_entry;
}

var pButtonGroup_cjs_entry = {};

var hasRequiredPButtonGroup_cjs_entry;

function requirePButtonGroup_cjs_entry () {
	if (hasRequiredPButtonGroup_cjs_entry) return pButtonGroup_cjs_entry;
	hasRequiredPButtonGroup_cjs_entry = 1;

	Object.defineProperty(pButtonGroup_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const groupDirectionStyles = requireGroupDirectionStylesC4bd8b11();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const spacingFluidSmall = requireSpacingFluidSmall2c6caae7();

	const getComponentCss = (direction) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            div: {
	                display: 'flex',
	                gap: spacingFluidSmall.spacingFluidSmall,
	                ...validateProps.buildResponsiveStyles(direction, groupDirectionStyles.getGroupDirectionJssStyles),
	            },
	        },
	    });
	};

	const propTypes = {
	    direction: validateProps.AllowedTypes.breakpoint(groupDirectionStyles.GROUP_DIRECTIONS),
	};
	const ButtonGroup = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.direction = { base: 'column', xs: 'row' };
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.direction);
	        return (validateProps.h("div", { key: 'c2ee02d803cde60dc60f84f75be2581bffe2ca19', role: "group" }, validateProps.h("slot", { key: '50387bcf81a3e2932a5dd2aa32b3dd62c4bce4c3' })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pButtonGroup_cjs_entry.p_button_group = ButtonGroup;

	
	return pButtonGroup_cjs_entry;
}

var pButtonPure_cjs_entry = {};

var textSizeBe3fca13 = {};

var hasRequiredTextSizeBe3fca13;

function requireTextSizeBe3fca13 () {
	if (hasRequiredTextSizeBe3fca13) return textSizeBe3fca13;
	hasRequiredTextSizeBe3fca13 = 1;

	const TEXT_SIZES = ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'inherit'];

	textSizeBe3fca13.TEXT_SIZES = TEXT_SIZES;

	
	return textSizeBe3fca13;
}

var typographyTextWeight02ea3596 = {};

var hasRequiredTypographyTextWeight02ea3596;

function requireTypographyTextWeight02ea3596 () {
	if (hasRequiredTypographyTextWeight02ea3596) return typographyTextWeight02ea3596;
	hasRequiredTypographyTextWeight02ea3596 = 1;

	// 'thin' is deprecated and will be mapped to 'regular'
	// 'semibold' is deprecated and will be mapped to 'semi-bold'
	/** @deprecated */
	const TYPOGRAPHY_TEXT_WEIGHTS_DEPRECATED = ['thin', 'semibold'];
	const TYPOGRAPHY_TEXT_WEIGHTS = ['regular', 'semi-bold', 'bold', ...TYPOGRAPHY_TEXT_WEIGHTS_DEPRECATED];

	typographyTextWeight02ea3596.TYPOGRAPHY_TEXT_WEIGHTS = TYPOGRAPHY_TEXT_WEIGHTS;

	
	return typographyTextWeight02ea3596;
}

var hasRequiredPButtonPure_cjs_entry;

function requirePButtonPure_cjs_entry () {
	if (hasRequiredPButtonPure_cjs_entry) return pButtonPure_cjs_entry;
	hasRequiredPButtonPure_cjs_entry = 1;

	Object.defineProperty(pButtonPure_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const buttonType = requireButtonTypeAe0c09db();
	const isDisabledOrLoading = requireIsDisabledOrLoadingB1f56d7f();
	const buttonHandling = requireButtonHandling39869edc();
	const buttonLinkPureUtils = requireButtonLinkPureUtils42aabf78();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed91ceea3c();
	const theme = requireThemeBfc10573();
	const textSize = requireTextSizeBe3fca13();
	const typographyTextWeight = requireTypographyTextWeight02ea3596();
	const alignLabel = requireAlignLabel7a9d9074();
	const loadingMessageStyles = requireLoadingMessageStyles100c7f01();
	const linkButtonPureStyles = requireLinkButtonPureStyles102ff74a();
	const fontLineHeight = requireFontLineHeightD4b9e1a9();
	const getButtonBaseAriaAttributes = requireGetButtonBaseAriaAttributes84dbc1f1();
	requireGetClosestHTMLElement83d01a84();
	requireSetAttributesF96a52a9();
	requireIsParentOfKind4b323732();
	requireHelper22e15c0e();
	requireColorSchemeStyles4bc3d59c();
	requireHoverMediaQuery5e6deda8();
	requirePreventFoucOfNestedElementsStylesE5a706ce();
	requireFontSizeTextStyles4439a071();
	requireFontSizeTextXXSmallA02f9c40();
	requireFontSizeTextXSmallE59d35d7();
	requireFontSizeTextSmall508930e5();
	requireFontSizeTextMedium88887ad8();
	requireFontSizeTextLarge05a4bc90();
	requireFontSizeTextXLarge0ecf9ef3();
	requireTextSmallStyle00e1c6e2();
	requireTextShared5216bb19();
	requireFontFamily23874d28();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireSpacingStaticXSmallB7d708b8();
	requireBorderRadiusSmall5f37fc45();
	requireFrostedGlassStyleBd067e45();

	const getComponentCss = (icon, iconSource, active, isLoading, isDisabledOrLoading, stretch, size, hideLabel, alignLabel, underline, theme) => {
	    const hasIcon = buttonLinkPureUtils.hasVisibleIcon(icon, iconSource);
	    return validateProps.getCss(validateProps.mergeDeep(linkButtonPureStyles.getLinkButtonPureStyles(icon, iconSource, active, isDisabledOrLoading, stretch, size, hideLabel, alignLabel, underline, false, theme), {
	        root: {
	            WebkitAppearance: 'none', // iOS safari
	            appearance: 'none',
	            background: 'transparent',
	            textAlign: 'start',
	            border: 0,
	            cursor: isDisabledOrLoading ? 'not-allowed' : 'pointer',
	        },
	        ...(!hasIcon &&
	            isLoading && {
	            label: {
	                opacity: 0, // use opacity for smooth transition between states and to keep accessible name available
	            },
	            icon: {
	                position: 'absolute',
	                top: 0,
	                left: `calc(50% - ${fontLineHeight.fontLineHeight} / 2)`,
	                width: fontLineHeight.fontLineHeight,
	                height: fontLineHeight.fontLineHeight,
	            },
	        }),
	        // .loading
	        ...loadingMessageStyles.getFunctionalComponentLoadingMessageStyles(),
	    }));
	};

	const warnIfIsLoadingAndIconIsNone = (host, loading, iconName, iconSource) => {
	    if (loading && !buttonLinkPureUtils.hasVisibleIcon(iconName, iconSource)) {
	        validateProps.consoleWarn(`combination of properties icon='${iconName}' and loading='${loading}' for component ${validateProps.getTagNameWithoutPrefix(host)} is not supported.`, host);
	    }
	};
	const getButtonPureAriaAttributes = (isDisabled, isLoading, aria) => {
	    return {
	        ...validateProps.parseAndGetAriaAttributes(aria),
	        ...getButtonBaseAriaAttributes.getButtonBaseAriaAttributes(isDisabled, isLoading),
	    };
	};

	const propTypes = {
	    type: validateProps.AllowedTypes.oneOf(buttonType.BUTTON_TYPES),
	    name: validateProps.AllowedTypes.string,
	    value: validateProps.AllowedTypes.string,
	    disabled: validateProps.AllowedTypes.boolean,
	    loading: validateProps.AllowedTypes.boolean,
	    size: validateProps.AllowedTypes.breakpoint(textSize.TEXT_SIZES),
	    weight: validateProps.AllowedTypes.oneOf(typographyTextWeight.TYPOGRAPHY_TEXT_WEIGHTS),
	    icon: validateProps.AllowedTypes.string,
	    iconSource: validateProps.AllowedTypes.string,
	    underline: validateProps.AllowedTypes.boolean,
	    active: validateProps.AllowedTypes.boolean,
	    hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	    alignLabel: validateProps.AllowedTypes.breakpoint(alignLabel.ALIGN_LABELS),
	    stretch: validateProps.AllowedTypes.breakpoint('boolean'),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    aria: validateProps.AllowedTypes.aria(buttonType.BUTTON_ARIA_ATTRIBUTES),
	    form: validateProps.AllowedTypes.string,
	};
	const ButtonPure = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        if (hostRef.$hostElement$["s-ei"]) {
	            this.internals = hostRef.$hostElement$["s-ei"];
	        }
	        else {
	            this.internals = hostRef.$hostElement$.attachInternals?.();
	            hostRef.$hostElement$["s-ei"] = this.internals;
	        }
	        this.initialLoading = false;
	        this.type = 'submit';
	        this.name = undefined;
	        this.value = undefined;
	        this.disabled = false;
	        this.loading = false;
	        this.size = 'small';
	        this.weight = 'regular';
	        this.icon = 'arrow-right';
	        this.iconSource = undefined;
	        this.underline = false;
	        this.active = false;
	        this.hideLabel = false;
	        this.alignLabel = 'end';
	        this.stretch = false;
	        this.theme = 'light';
	        this.aria = undefined;
	        this.form = undefined;
	    }
	    get isDisabledOrLoading() {
	        return isDisabledOrLoading.isDisabledOrLoading(this.disabled, this.loading);
	    }
	    // this stops click events when button is disabled
	    onClick(e) {
	        if (this.isDisabledOrLoading) {
	            e.stopPropagation();
	            return;
	        }
	        if (this.form && this.internals?.form) {
	            e.preventDefault();
	            if (this.type === 'submit') {
	                // Submitter is null because the button can't be passed from the shadow DOM https://github.com/WICG/webcomponents/issues/814
	                this.internals?.form.requestSubmit();
	            }
	            else if (this.type === 'reset') {
	                this.internals?.form.reset();
	            }
	        }
	    }
	    onValueChange(newValue) {
	        if (this.form) {
	            this.internals?.setFormValue(newValue);
	        }
	    }
	    connectedCallback() {
	        this.initialLoading = this.loading;
	    }
	    componentWillLoad() {
	        if (this.form) {
	            this.internals?.setFormValue(this.value);
	        }
	        this.initialLoading = this.loading;
	    }
	    componentWillUpdate() {
	        if (this.loading) {
	            this.initialLoading = true;
	        }
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    componentDidLoad() {
	        if (!this.form) {
	            buttonHandling.improveButtonHandlingForCustomElement(this.host, () => this.type, () => this.isDisabledOrLoading, () => this.name, () => this.value);
	        }
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfIsLoadingAndIconIsNone(this.host, this.loading, this.icon, this.iconSource);
	        buttonLinkPureUtils.warnIfParentIsPTextAndIconIsNone(this.host, this.icon, this.iconSource);
	        const alignLabelDeprecationMap = {
	            left: 'start',
	            right: 'end',
	        };
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'alignLabel', alignLabelDeprecationMap);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.icon, this.iconSource, this.active, this.loading, this.isDisabledOrLoading, this.stretch, this.size, this.hideLabel, this.alignLabel, this.underline, this.theme);
	        const hasIcon = buttonLinkPureUtils.hasVisibleIcon(this.icon, this.iconSource);
	        const iconProps = {
	            class: 'icon',
	            size: 'inherit',
	            theme: this.theme,
	        };
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(validateProps.Host, { key: 'accf6c8edda9fae414cbaec4c40750c0729146dc' }, validateProps.h("button", { key: '4283d670739381b770b948dc0263918ae0f6555f', ...getButtonPureAriaAttributes(this.disabled, this.loading, this.aria), class: "root", type: this.type, name: this.name, value: this.value, "aria-describedby": this.loading ? loadingMessageStyles.loadingId : undefined }, this.loading ? (validateProps.h(PrefixedTagNames.pSpinner, { ...iconProps, "aria-hidden": "true" })) : (hasIcon && (validateProps.h(PrefixedTagNames.pIcon, { ...iconProps, name: this.icon, source: this.iconSource, color: this.isDisabledOrLoading ? 'state-disabled' : 'primary', theme: this.theme, "aria-hidden": "true" }))), validateProps.h("span", { key: '5f894e1c568c682a4cb91290661eb7618dcfa44a', class: "label" }, validateProps.h("slot", { key: '00b89254623c264dc953deba6f09d624f3a26501' }))), validateProps.h(loadingMessageStyles.LoadingMessage, { key: 'f406a0df1e5cd6730e62d75fb113a4af8ded8f8f', loading: this.loading, initialLoading: this.initialLoading })));
	    }
	    static get delegatesFocus() { return true; }
	    static get formAssociated() { return true; }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "value": ["onValueChange"]
	    }; }
	};

	pButtonPure_cjs_entry.p_button_pure = ButtonPure;

	
	return pButtonPure_cjs_entry;
}

var pButtonTile_cjs_entry = {};

var slottedPictureImageStyles3121dac8 = {};

var hasRequiredSlottedPictureImageStyles3121dac8;

function requireSlottedPictureImageStyles3121dac8 () {
	if (hasRequiredSlottedPictureImageStyles3121dac8) return slottedPictureImageStyles3121dac8;
	hasRequiredSlottedPictureImageStyles3121dac8 = 1;

	const validateProps = requireValidateProps788e2bc5();

	const getSlottedPictureImageStyles = (tagName) => ({
	    '@global': {
	        [`${tagName} picture img`]: validateProps.addImportantToEachRule({
	            height: '100%',
	            width: '100%',
	            objectFit: 'cover',
	        }),
	    },
	});

	slottedPictureImageStyles3121dac8.getSlottedPictureImageStyles = getSlottedPictureImageStyles;

	
	return slottedPictureImageStyles3121dac8;
}

var textMediumStyle59c59854 = {};

var hasRequiredTextMediumStyle59c59854;

function requireTextMediumStyle59c59854 () {
	if (hasRequiredTextMediumStyle59c59854) return textMediumStyle59c59854;
	hasRequiredTextMediumStyle59c59854 = 1;

	const textShared = requireTextShared5216bb19();
	const fontSizeTextMedium = requireFontSizeTextMedium88887ad8();

	const textMediumStyle = {
	    font: `${textShared._textFontPartA}${fontSizeTextMedium.fontSizeTextMedium}${textShared._textFontPartB}`,
	    ...textShared.fontHyphenationStyle,
	};

	textMediumStyle59c59854.textMediumStyle = textMediumStyle;

	
	return textMediumStyle59c59854;
}

var hasRequiredPButtonTile_cjs_entry;

function requirePButtonTile_cjs_entry () {
	if (hasRequiredPButtonTile_cjs_entry) return pButtonTile_cjs_entry;
	hasRequiredPButtonTile_cjs_entry = 1;

	Object.defineProperty(pButtonTile_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const buttonType = requireButtonTypeAe0c09db();
	const isDisabledOrLoading = requireIsDisabledOrLoadingB1f56d7f();
	const tileUtils = requireTileUtils82ea5cf8();
	const slottedPictureImageStyles = requireSlottedPictureImageStyles3121dac8();
	const linkTileUtils = requireLinkTileUtilsFce9594a();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const forcedColorsMediaQuery = requireForcedColorsMediaQuery69d5b1ca();
	const fontWeightStyles = requireFontWeightStylesB74e8683();
	const fontSizeTextStyles = requireFontSizeTextStyles4439a071();
	const textMediumStyle = requireTextMediumStyle59c59854();
	const spacingFluidMedium = requireSpacingFluidMedium88ab712b();
	const spacingFluidLarge = requireSpacingFluidLarge6087a0f7();
	const borderRadiusLarge = requireBorderRadiusLargeA0aa3a01();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();
	requireGetDirectChildHTMLElement18d9487f();
	requireTransformSelectorToDirectChildSelectorEcc1a9c4();
	requireThemeBfc10573();
	requireFontWeightRegularD0c768ac();
	requireFontWeightSemiBold4482c830();
	requireFontSizeTextXXSmallA02f9c40();
	requireFontSizeTextXSmallE59d35d7();
	requireFontSizeTextSmall508930e5();
	requireFontSizeTextMedium88887ad8();
	requireFontSizeTextLarge05a4bc90();
	requireFontSizeTextXLarge0ecf9ef3();
	requireTextShared5216bb19();
	requireFontFamily23874d28();
	requireFontLineHeightD4b9e1a9();
	requireFontVariant6ba3b7cb();

	const getComponentCss = (isDisabledOrLoading, aspectRatio, size, weight, background, align, compact, hasGradient, isDisabled) => {
	    const isTopAligned = align === 'top';
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block', // `display: flex` would be more ideal, but doesn't work in Safari in all cases
	                hyphens: 'auto', // TODO: shouldn't we expose a CSS variable instead?
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            slot: {
	                display: 'block',
	                '&:not([name])': {
	                    width: '100%',
	                    height: '100%',
	                    transition: validateProps.getTransition('transform', 'moderate'),
	                },
	                '&[name="header"]': {
	                    gridArea: `${isTopAligned ? 4 : 2}/2`,
	                    zIndex: 3,
	                },
	            },
	            '::slotted(:is(img,picture,video))': validateProps.addImportantToEachRule({
	                display: 'block',
	                width: '100%',
	                height: '100%',
	            }),
	            '::slotted(:is(img,video))': validateProps.addImportantToEachRule({
	                objectFit: 'cover',
	            }),
	            a: {
	                gridArea: '1/1/-1 /-1',
	                zIndex: 4,
	                outline: 0, // reset focus style since this element is used to improve mouse interaction only
	            },
	            p: {
	                ...textMediumStyle.textMediumStyle,
	                zIndex: 3,
	                margin: 0, // reset ua-style
	                maxWidth: '34.375rem',
	                hyphens: 'inherit',
	                ...validateProps.mergeDeep(validateProps.buildResponsiveStyles(size, (sizeValue) => ({
	                    fontSize: fontSizeTextStyles.getFontSizeText(sizeValue === 'default' ? 'medium' : sizeValue), // mapping of the deprecated size 'default'
	                })), validateProps.buildResponsiveStyles(weight, (weightValue) => ({
	                    fontWeight: fontWeightStyles.getFontWeight(weightValue),
	                })), validateProps.buildResponsiveStyles(background, (backgroundValue) => ({
	                    color: validateProps.getThemedColors(backgroundValue).primaryColor,
	                }))),
	            },
	        },
	        root: {
	            ...validateProps.buildResponsiveStyles(aspectRatio, (aspectRatioValue) => ({
	                aspectRatio: aspectRatioValue.replace(':', '/'), // mapping of the deprecated aspect-ratio with ':'
	            })),
	            cursor: isDisabledOrLoading ? 'not-allowed' : 'pointer',
	            width: '100%', // necessary in case tile content overflows in grid or flex context
	            height: '100%', // necessary in case tile content overflows in grid or flex context
	            display: 'grid',
	            gridTemplate: `${spacingFluidMedium.spacingFluidMedium} auto minmax(0px, 1fr) auto ${spacingFluidMedium.spacingFluidMedium}/${spacingFluidMedium.spacingFluidMedium} minmax(0px, 1fr) ${spacingFluidMedium.spacingFluidMedium}`,
	            ...(hasGradient &&
	                validateProps.isThemeDark(background) && {
	                '&::after': {
	                    content: '""',
	                    zIndex: 2,
	                    ...(isTopAligned
	                        ? {
	                            gridArea: '1/1/3/-1',
	                            ...linkTileUtils.gradientToBottomStyle,
	                            marginBottom: `calc(${spacingFluidLarge.spacingFluidLarge} * -1)`, // to increase the gradient area without reserving additional layout space
	                            borderStartStartRadius: borderRadiusLarge.borderRadiusLarge,
	                            borderStartEndRadius: borderRadiusLarge.borderRadiusLarge,
	                        }
	                        : {
	                            gridArea: '4/1/6/-1',
	                            ...tileUtils.gradientToTopStyle,
	                            marginTop: `calc(${spacingFluidLarge.spacingFluidLarge} * -1)`, // to increase the gradient area without reserving additional layout space
	                            borderEndStartRadius: borderRadiusLarge.borderRadiusLarge,
	                            borderEndEndRadius: borderRadiusLarge.borderRadiusLarge,
	                        }),
	                    ...forcedColorsMediaQuery.forcedColorsMediaQuery({
	                        background: 'rgba(0,0,0,0.7)',
	                    }),
	                },
	            }),
	            ...(!isDisabled &&
	                hoverMediaQuery.hoverMediaQuery({
	                    '&:hover slot:not([name])': {
	                        transform: 'scale3d(1.05,1.05,1.05)',
	                    },
	                })),
	        },
	        media: {
	            position: 'relative', // necessary if custom `position: absolute` style is added to media elements
	            gridArea: '1/1/-1 /-1',
	            zIndex: 1,
	            overflow: 'hidden', // relevant for scaling of nested image
	            borderRadius: borderRadiusLarge.borderRadiusLarge,
	        },
	        footer: {
	            gridArea: `${isTopAligned ? 2 : 4}/2`,
	            display: 'flex',
	            gap: spacingStaticMedium.spacingStaticMedium,
	            justifyContent: 'space-between',
	            ...validateProps.buildResponsiveStyles(compact, (compactValue) => compactValue
	                ? {
	                    alignItems: 'center',
	                    flexDirection: 'row',
	                }
	                : {
	                    alignItems: 'flex-start',
	                    flexDirection: 'column',
	                }),
	        },
	        'link-or-button-pure': {
	            zIndex: 5,
	            ...validateProps.buildResponsiveStyles(compact, (compactValue) => ({
	                display: compactValue ? 'inline-block' : 'none',
	            })),
	        },
	        'link-or-button': {
	            minHeight: '54px', // prevent content shift
	            zIndex: 5,
	            ...validateProps.buildResponsiveStyles(compact, (compactValue) => ({
	                display: compactValue ? 'none' : 'inline-block',
	            })),
	        },
	    });
	};

	const propTypes = {
	    ...linkTileUtils.sharedTilePropTypes,
	    weight: validateProps.AllowedTypes.breakpoint(tileUtils.TILE_WEIGHTS),
	    type: validateProps.AllowedTypes.oneOf(buttonType.BUTTON_TYPES),
	    disabled: validateProps.AllowedTypes.boolean,
	    loading: validateProps.AllowedTypes.boolean,
	    icon: validateProps.AllowedTypes.string,
	    iconSource: validateProps.AllowedTypes.string,
	    aria: validateProps.AllowedTypes.aria(buttonType.BUTTON_ARIA_ATTRIBUTES),
	};
	const ButtonTile = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.size = 'medium';
	        this.weight = 'semi-bold';
	        this.background = 'dark';
	        this.aspectRatio = '4/3';
	        this.label = undefined;
	        this.description = undefined;
	        this.align = 'bottom';
	        this.gradient = true;
	        this.compact = false;
	        this.type = 'submit';
	        this.disabled = false;
	        this.loading = false;
	        this.icon = 'none';
	        this.iconSource = undefined;
	        this.aria = undefined;
	    }
	    onClick(e) {
	        if (isDisabledOrLoading.isDisabledOrLoading(this.disabled, this.loading)) {
	            e.stopPropagation();
	        }
	    }
	    connectedCallback() {
	        validateProps.applyConstructableStylesheetStyles(this.host, slottedPictureImageStyles.getSlottedPictureImageStyles);
	    }
	    componentWillLoad() {
	        tileUtils.preventAutoPlayOfSlottedVideoOnPrefersReducedMotion(this.host);
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, getComponentCss, isDisabledOrLoading.isDisabledOrLoading(this.disabled, this.loading), this.aspectRatio, this.size, this.weight, this.background, this.align, this.compact, this.gradient, this.disabled);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        const buttonProps = {
	            theme: this.background,
	            variant: 'secondary',
	            iconSource: this.iconSource,
	            type: this.type,
	            disabled: this.disabled,
	            loading: this.loading,
	            aria: this.aria,
	        };
	        const button = (validateProps.h(PrefixedTagNames.pButton, { ...buttonProps, icon: this.icon, key: "link-or-button", class: "link-or-button" }, this.label));
	        const buttonPure = (validateProps.h(PrefixedTagNames.pButtonPure, { ...buttonProps, key: "link-or-button-pure", class: "link-or-button-pure", hideLabel: true, icon: this.icon === 'none' ? 'arrow-right' : this.icon }, this.label));
	        return (validateProps.h("div", { key: '94136f41abcd9b6fc8bf3ec6602844cace806c7a', class: "root" }, validateProps.h("slot", { key: 'c8b069da51d744b6b970e6fa5d4bfa791fb90b53', name: "header" }), validateProps.h("div", { key: '208a3c27917dbc6cf553d1416137740f13e64de0', class: "media" }, validateProps.h("slot", { key: 'bf0279522d9a0a44da840cac55c06e43d0ed57a1', onSlotchange: () => tileUtils.preventAutoPlayOfSlottedVideoOnPrefersReducedMotion(this.host) })), validateProps.h("div", { key: 'b7178e6d2170decff6f8a21703c2c9d08784fc11', class: "footer" }, validateProps.h("p", { key: '3541749d91f038d103fc128c7086aaa94fef003d' }, this.description), typeof this.compact === 'boolean' ? (this.compact ? buttonPure : button) : [buttonPure, button])));
	    }
	    static get delegatesFocus() { return true; }
	    get host() { return validateProps.getElement(this); }
	};

	pButtonTile_cjs_entry.p_button_tile = ButtonTile;

	
	return pButtonTile_cjs_entry;
}

var pButton_cjs_entry = {};

var hasRequiredPButton_cjs_entry;

function requirePButton_cjs_entry () {
	if (hasRequiredPButton_cjs_entry) return pButton_cjs_entry;
	hasRequiredPButton_cjs_entry = 1;

	Object.defineProperty(pButton_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const buttonType = requireButtonTypeAe0c09db();
	const isDisabledOrLoading = requireIsDisabledOrLoadingB1f56d7f();
	const buttonHandling = requireButtonHandling39869edc();
	const buttonLinkPureUtils = requireButtonLinkPureUtils42aabf78();
	const theme = requireThemeBfc10573();
	const linkButtonVariant = requireLinkButtonVariantB99795db();
	const loadingMessageStyles = requireLoadingMessageStyles100c7f01();
	const linkButtonStyles = requireLinkButtonStyles7215407d();
	const frostedGlassStyle = requireFrostedGlassStyleBd067e45();
	const fontLineHeight = requireFontLineHeightD4b9e1a9();
	const getButtonBaseAriaAttributes = requireGetButtonBaseAriaAttributes84dbc1f1();
	requireGetClosestHTMLElement83d01a84();
	requireSetAttributesF96a52a9();
	requireIsParentOfKind4b323732();
	requireChangeColor50831612();
	requireColorSchemeStyles4bc3d59c();
	requireHoverMediaQuery5e6deda8();
	requirePreventFoucOfNestedElementsStylesE5a706ce();
	requireBorderRadiusSmall5f37fc45();
	requireTextSmallStyle00e1c6e2();
	requireTextShared5216bb19();
	requireFontFamily23874d28();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();

	const cssVariableInternalButtonScaling = '--p-internal-button-scaling';
	const getDisabledColors = (variant, loading, theme) => {
	    const { contrastMediumColor, contrastHighColor, disabledColor, hoverColor, backgroundFrostedColor } = validateProps.getThemedColors(theme);
	    const { canvasColor } = validateProps.getHighContrastColors();
	    const colors = {
	        primary: {
	            textColor: validateProps.isHighContrastMode ? disabledColor : contrastHighColor,
	            borderColor: validateProps.isHighContrastMode ? disabledColor : loading ? contrastHighColor : disabledColor,
	            backgroundColor: validateProps.isHighContrastMode ? canvasColor : loading ? contrastHighColor : disabledColor,
	        },
	        secondary: {
	            textColor: disabledColor,
	            borderColor: validateProps.isHighContrastMode ? disabledColor : loading ? contrastMediumColor : disabledColor,
	            backgroundColor: validateProps.isHighContrastMode ? canvasColor : loading ? hoverColor : 'transparent',
	        },
	        ghost: {
	            textColor: disabledColor,
	            borderColor: validateProps.isHighContrastMode ? disabledColor : loading ? backgroundFrostedColor : backgroundFrostedColor,
	            backgroundColor: validateProps.isHighContrastMode ? canvasColor : loading ? backgroundFrostedColor : backgroundFrostedColor,
	        },
	    };
	    return colors[variant === 'tertiary' ? 'secondary' : variant];
	};
	const getComponentCss = (icon, iconSource, variant, hideLabel, disabled, loading, compact, theme) => {
	    const disabledOrLoading = isDisabledOrLoading.isDisabledOrLoading(disabled, loading);
	    const { textColor, borderColor, backgroundColor } = getDisabledColors(variant, loading, theme);
	    const { textColor: textColorDark, borderColor: borderColorDark, backgroundColor: backgroundColorDark, } = getDisabledColors(variant, loading, 'dark');
	    const isPrimary = variant === 'primary';
	    return validateProps.getCss(validateProps.mergeDeep(linkButtonStyles.getLinkButtonStyles(icon, iconSource, variant, hideLabel, disabledOrLoading, false, compact, cssVariableInternalButtonScaling, theme), {
	        root: {
	            cursor: disabledOrLoading ? 'not-allowed' : 'pointer',
	            ...(disabledOrLoading && {
	                backgroundColor,
	                borderColor,
	                color: textColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    backgroundColor: backgroundColorDark,
	                    borderColor: borderColorDark,
	                    color: textColorDark,
	                }),
	            }),
	            ...(loading && !isPrimary && frostedGlassStyle.frostedGlassStyle),
	            margin: 0, // Removes default button margin on safari 15
	        },
	        ...(loading && {
	            spinner: {
	                width: fontLineHeight.fontLineHeight,
	                height: fontLineHeight.fontLineHeight,
	                pointerEvents: 'none',
	                position: 'absolute',
	                top: '50%',
	                left: '50%',
	                transform: 'translate(-50%, -50%)',
	                ...(isPrimary && !validateProps.isHighContrastMode && { filter: 'invert(1)' }),
	            },
	        }),
	        label: {
	            transition: validateProps.getTransition('opacity'),
	            ...(loading && {
	                opacity: 0, // use opacity for smooth transition between states
	            }),
	        },
	        icon: {
	            transition: validateProps.getTransition('opacity'),
	            ...(!disabled &&
	                isPrimary &&
	                !validateProps.isHighContrastMode && {
	                filter: 'invert(1)',
	            }),
	            ...(loading && {
	                opacity: 0, // use opacity for smooth transition between states
	            }),
	        },
	        // .loading
	        ...loadingMessageStyles.getFunctionalComponentLoadingMessageStyles(),
	    }));
	};

	const getButtonAriaAttributes = (isDisabled, isLoading, aria) => {
	    return {
	        ...validateProps.parseAndGetAriaAttributes(aria),
	        ...getButtonBaseAriaAttributes.getButtonBaseAriaAttributes(isDisabled, isLoading),
	    };
	};

	const propTypes = {
	    type: validateProps.AllowedTypes.oneOf(buttonType.BUTTON_TYPES),
	    name: validateProps.AllowedTypes.string,
	    value: validateProps.AllowedTypes.string,
	    variant: validateProps.AllowedTypes.oneOf(linkButtonVariant.LINK_BUTTON_VARIANTS),
	    disabled: validateProps.AllowedTypes.boolean,
	    loading: validateProps.AllowedTypes.boolean,
	    icon: validateProps.AllowedTypes.string,
	    iconSource: validateProps.AllowedTypes.string,
	    hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	    compact: validateProps.AllowedTypes.breakpoint('boolean'),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    aria: validateProps.AllowedTypes.aria(buttonType.BUTTON_ARIA_ATTRIBUTES),
	    form: validateProps.AllowedTypes.string,
	};
	const Button = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        if (hostRef.$hostElement$["s-ei"]) {
	            this.internals = hostRef.$hostElement$["s-ei"];
	        }
	        else {
	            this.internals = hostRef.$hostElement$.attachInternals?.();
	            hostRef.$hostElement$["s-ei"] = this.internals;
	        }
	        this.initialLoading = false;
	        this.type = 'submit';
	        this.name = undefined;
	        this.value = undefined;
	        this.disabled = false;
	        this.loading = false;
	        this.variant = 'primary';
	        this.icon = 'none';
	        this.iconSource = undefined;
	        this.hideLabel = false;
	        this.compact = false;
	        this.theme = 'light';
	        this.aria = undefined;
	        this.form = undefined;
	    }
	    onClick(e) {
	        if (isDisabledOrLoading.isDisabledOrLoading(this.disabled, this.loading)) {
	            e.stopPropagation();
	            return;
	        }
	        if (this.form && this.internals?.form) {
	            e.preventDefault();
	            if (this.type === 'submit') {
	                // Submitter is null because the button can't be passed from the shadow DOM https://github.com/WICG/webcomponents/issues/814
	                this.internals?.form.requestSubmit();
	            }
	            else if (this.type === 'reset') {
	                this.internals?.form.reset();
	            }
	        }
	    }
	    onValueChange(newValue) {
	        if (this.form) {
	            this.internals?.setFormValue(newValue);
	        }
	    }
	    connectedCallback() {
	        this.initialLoading = this.loading;
	    }
	    componentWillLoad() {
	        if (this.form) {
	            this.internals?.setFormValue(this.value);
	        }
	        this.initialLoading = this.loading;
	    }
	    componentWillUpdate() {
	        if (this.loading) {
	            this.initialLoading = true;
	        }
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    componentDidLoad() {
	        if (!this.form) {
	            buttonHandling.improveButtonHandlingForCustomElement(this.host, () => this.type, () => isDisabledOrLoading.isDisabledOrLoading(this.disabled, this.loading), () => this.name, () => this.value);
	        }
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.icon, this.iconSource, this.variant, this.hideLabel, this.disabled, this.loading, this.compact, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(validateProps.Host, { key: 'e488198832261615157f8e991b877ad11106defb' }, validateProps.h("button", { key: '0a67e5521da46776fe83311e04f7ad43635e6ebd', ...getButtonAriaAttributes(this.disabled, this.loading, this.aria), class: "root", type: this.type, name: this.name, value: this.value, "aria-describedby": this.loading ? loadingMessageStyles.loadingId : undefined }, this.loading && (validateProps.h(PrefixedTagNames.pSpinner, { key: 'ddaed8e3e57c382d1dd6277cba6a122956763a2c', class: "spinner", size: "inherit", theme: this.theme, "aria-hidden": "true" })), buttonLinkPureUtils.hasVisibleIcon(this.icon, this.iconSource) && (validateProps.h(PrefixedTagNames.pIcon, { key: 'dabe2b52dc5a0c14e562cb82e819e4d142b68b82', class: "icon", size: "inherit", name: this.iconSource ? undefined : this.icon, source: this.iconSource, color: this.disabled ? (this.variant === 'primary' ? 'contrast-high' : 'state-disabled') : 'primary', theme: this.theme, "aria-hidden": "true" })), validateProps.h("span", { key: '2dafcd6423fcd88f8fbbd99de3614a1b65b8f605', class: "label" }, validateProps.h("slot", { key: 'a8433b2d660d975a8e5082e4248f14b004b11173' }))), validateProps.h(loadingMessageStyles.LoadingMessage, { key: '29830bd1c55061f96cbb5a2118b89d82a3d1198d', loading: this.loading, initialLoading: this.initialLoading })));
	    }
	    static get delegatesFocus() { return true; }
	    static get formAssociated() { return true; }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "value": ["onValueChange"]
	    }; }
	};

	pButton_cjs_entry.p_button = Button;

	
	return pButton_cjs_entry;
}

var pCanvas_cjs_entry = {};

var textXSmallStyle30d03035 = {};

var hasRequiredTextXSmallStyle30d03035;

function requireTextXSmallStyle30d03035 () {
	if (hasRequiredTextXSmallStyle30d03035) return textXSmallStyle30d03035;
	hasRequiredTextXSmallStyle30d03035 = 1;

	const textShared = requireTextShared5216bb19();
	const fontSizeTextXSmall = requireFontSizeTextXSmallE59d35d7();

	const textXSmallStyle = {
	    font: `${textShared._textFontPartA}${fontSizeTextXSmall.fontSizeTextXSmall}${textShared._textFontPartB}`,
	    ...textShared.fontHyphenationStyle,
	};

	textXSmallStyle30d03035.textXSmallStyle = textXSmallStyle;

	
	return textXSmallStyle30d03035;
}

var hasRequiredPCanvas_cjs_entry;

function requirePCanvas_cjs_entry () {
	if (hasRequiredPCanvas_cjs_entry) return pCanvas_cjs_entry;
	hasRequiredPCanvas_cjs_entry = 1;

	Object.defineProperty(pCanvas_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const hasNamedSlot = requireHasNamedSlot273cd3ae();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const gridGap = requireGridGapB5b73e4a();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const textXSmallStyle = requireTextXSmallStyle30d03035();
	const textSmallStyle = requireTextSmallStyle00e1c6e2();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const spacingFluidSmall = requireSpacingFluidSmall2c6caae7();
	requireGetNamedSlot223c478a();
	requireSpacingFluidMedium88ab712b();
	requireTextShared5216bb19();
	requireFontFamily23874d28();
	requireFontLineHeightD4b9e1a9();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextXSmallE59d35d7();
	requireFontSizeTextSmall508930e5();

	// public css classes
	const cssClassGrid = '-p-canvas-grid';
	// public css variables
	const cssVarSidebarStartWidth = '--p-canvas-sidebar-start-width';
	const cssVarSidebarEndWidth = '--p-canvas-sidebar-end-width';
	// default values for public css variables
	const sidebarStartWidth = `var(${cssVarSidebarStartWidth},320px)`;
	const sidebarEndWidth = `var(${cssVarSidebarEndWidth},320px)`;
	// private css variables
	const cssVarColorPrimary = '--_a';
	const cssVarColorBackgroundBase = '--_b';
	const cssVarColorBackgroundSurface = '--_c';
	const cssVarColorContrastLow = '--_d';
	const cssVarColorFooterGradient = '--_e';
	const cssVarTemplateSidebarStartWidth = '--_f';
	const cssVarTemplateSidebarEndWidth = '--_g';
	// media queries
	const mediaQueryS = validateProps.getMediaQueryMin('s');
	const mediaQueryM = validateProps.getMediaQueryMin('m');
	// others
	const spacingBase = gridGap.gridGap.replace('36px', '24px');
	const getComponentCss = (theme, isSidebarStartOpen, isSidebarEndOpen) => {
	    const { primaryColor, backgroundColor, backgroundSurfaceColor, contrastLowColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, backgroundColor: backgroundColorDark, backgroundSurfaceColor: backgroundSurfaceColorDark, contrastLowColor: contrastLowColorDark, } = validateProps.getThemedColors('dark');
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            slot: {
	                '&:not([name]),&[name="footer"]': {
	                    [`&::slotted(.${cssClassGrid})`]: {
	                        display: 'grid',
	                        gridTemplateColumns: 'repeat(12,minmax(0,1fr))',
	                        columnGap: spacingBase,
	                        marginInline: 'auto',
	                        containerType: 'inline-size',
	                    },
	                },
	                '&[name="title"]::slotted': {
	                    '&(a)': {
	                        textDecoration: 'none',
	                        color: 'inherit',
	                        borderRadius: borderRadiusSmall.borderRadiusSmall,
	                    },
	                    ...validateProps.getFocusJssStyle(theme, { slotted: 'a' }),
	                },
	                '&[name="sidebar-end-header"]': {
	                    display: 'block', // ensures header section of sidebar-end area is aligned correctly
	                },
	                '&[name="background"]': {
	                    zIndex: 3,
	                    display: 'block',
	                    gridArea: '1/1/-1/-1',
	                    position: 'sticky',
	                    top: 0,
	                    height: '100dvh',
	                    pointerEvents: 'none',
	                    overflow: 'hidden',
	                    transform: 'translate3d(0,0,0)', // needed for Safari to force GPU acceleration
	                    [mediaQueryS]: {
	                        gridColumn: '2/3',
	                    },
	                    '&::slotted(video),&::slotted(img)': {
	                        width: '100%',
	                        height: '100%',
	                        objectFit: 'cover',
	                        transition: validateProps.getTransition('opacity', 'veryLong'),
	                        pointerEvents: 'none',
	                    },
	                },
	            },
	            h2: {
	                font: textXSmallStyle.textXSmallStyle.font,
	                textOverflow: 'ellipsis',
	                overflow: 'hidden',
	                whiteSpace: 'nowrap',
	                margin: 0,
	                padding: '4px', // preserve enough spacing for focus state
	                textTransform: 'uppercase',
	                letterSpacing: '2px',
	            },
	        },
	        root: {
	            [cssVarColorPrimary]: primaryColor,
	            [cssVarColorBackgroundBase]: backgroundColor,
	            [cssVarColorBackgroundSurface]: backgroundSurfaceColor,
	            [cssVarColorContrastLow]: contrastLowColor,
	            [cssVarColorFooterGradient]: `0,0%,${validateProps.isThemeDark(theme) ? '0%' : '100%'}`,
	            [cssVarTemplateSidebarStartWidth]: isSidebarStartOpen ? sidebarStartWidth : '0px',
	            [cssVarTemplateSidebarEndWidth]: isSidebarEndOpen ? sidebarEndWidth : '0px',
	            display: 'grid',
	            gridTemplateRows: 'auto minmax(0,1fr) auto',
	            gridTemplateAreas: '"header" "main" "footer"',
	            minWidth: '320px',
	            minHeight: '100dvh',
	            font: textSmallStyle.textSmallStyle.font,
	            color: `var(${cssVarColorPrimary})`,
	            background: `var(${cssVarColorBackgroundBase})`,
	            transition: validateProps.getTransition('grid-template-columns'),
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                [cssVarColorPrimary]: primaryColorDark,
	                [cssVarColorBackgroundBase]: backgroundColorDark,
	                [cssVarColorBackgroundSurface]: backgroundSurfaceColorDark,
	                [cssVarColorContrastLow]: contrastLowColorDark,
	                [cssVarColorFooterGradient]: '0,0%,0%',
	            }),
	            [mediaQueryS]: {
	                gridTemplateColumns: `var(${cssVarTemplateSidebarStartWidth}) minmax(0,1fr)`,
	                gridTemplateAreas: '"sidebar-start header" "sidebar-start main" "sidebar-start footer"',
	            },
	            [mediaQueryM]: {
	                gridTemplateColumns: `var(${cssVarTemplateSidebarStartWidth}) minmax(0,1fr) var(${cssVarTemplateSidebarEndWidth})`,
	                gridTemplateAreas: '"sidebar-start header sidebar-end" "sidebar-start main sidebar-end" "sidebar-start footer sidebar-end"',
	            },
	            '&::after': {
	                [mediaQueryM]: {
	                    content: '""',
	                    zIndex: 2,
	                    gridArea: '1/2/-1/3',
	                    boxShadow: `1px 0 0 0 var(${cssVarColorContrastLow})`,
	                    background: `var(${cssVarColorBackgroundBase})`,
	                    pointerEvents: 'none',
	                },
	            },
	        },
	        header: {
	            zIndex: 6,
	            gridArea: 'header',
	            containerType: 'inline-size',
	            position: 'sticky',
	            top: 0,
	            minHeight: '56px',
	            boxSizing: 'border-box',
	            display: 'grid',
	            gridTemplateColumns: 'minmax(0,1fr) auto minmax(0,1fr)',
	            gap: spacingBase,
	            alignItems: 'center',
	            paddingBlock: spacingStaticSmall.spacingStaticSmall,
	            paddingInline: spacingBase,
	            '&__area': {
	                display: 'flex',
	                gap: spacingStaticSmall.spacingStaticSmall,
	                alignItems: 'center',
	                '&--start': {
	                    justifyContent: 'flex-start',
	                },
	                '&--end': {
	                    justifyContent: 'flex-end',
	                },
	            },
	            '&__crest': {
	                [`@container(min-width:${validateProps.breakpointS}px)`]: {
	                    display: 'none',
	                },
	            },
	            '&__wordmark': {
	                height: '10px',
	                [`@container(max-width:${validateProps.breakpointS - 1}px)`]: {
	                    display: 'none',
	                },
	            },
	            '&:focus': {
	                outline: 'none',
	            },
	        },
	        blur: {
	            zIndex: -1,
	            position: 'absolute',
	            inset: 0,
	            pointerEvents: 'none',
	            '& > div': {
	                position: 'absolute',
	                inset: 0,
	            },
	            '& > div:nth-of-type(1)': {
	                zIndex: 1,
	                WebkitBackdropFilter: 'blur(64px)',
	                backdropFilter: 'blur(64px)',
	                WebkitMaskImage: 'linear-gradient(to bottom,rgba(0,0,0,100%) 0%,rgba(0,0,0,1) 12.5%,rgba(0,0,0,1) 25%,rgba(0,0,0,0) 37.5%)',
	                maskImage: 'linear-gradient(to bottom,rgba(0,0,0,100%) 0%,rgba(0,0,0,1) 12.5%,rgba(0,0,0,1) 25%,rgba(0,0,0,0) 37.5%)',
	            },
	            '& > div:nth-of-type(2)': {
	                zIndex: 2,
	                WebkitBackdropFilter: 'blur(32px)',
	                backdropFilter: 'blur(32px)',
	                WebkitMaskImage: 'linear-gradient(to bottom,rgba(0,0,0,0) 12.5%,rgba(0,0,0,1) 25%,rgba(0,0,0,1) 37.5%,rgba(0,0,0,0) 50%)',
	                maskImage: 'linear-gradient(to bottom,rgba(0,0,0,0) 12.5%,rgba(0,0,0,1) 25%,rgba(0,0,0,1) 37.5%,rgba(0,0,0,0) 50%)',
	            },
	            '& > div:nth-of-type(3)': {
	                zIndex: 3,
	                WebkitBackdropFilter: 'blur(16px)',
	                backdropFilter: 'blur(16px)',
	                WebkitMaskImage: 'linear-gradient(to bottom,rgba(0,0,0,0) 25%,rgba(0,0,0,1) 37.5%,rgba(0,0,0,1) 50%,rgba(0,0,0,0) 62.5%)',
	                maskImage: 'linear-gradient(to bottom,rgba(0,0,0,0) 25%,rgba(0,0,0,1) 37.5%,rgba(0,0,0,1) 50%,rgba(0,0,0,0) 62.5%)',
	            },
	            '& > div:nth-of-type(4)': {
	                zIndex: 4,
	                WebkitBackdropFilter: 'blur(8px)',
	                backdropFilter: 'blur(8px)',
	                WebkitMaskImage: 'linear-gradient(to bottom,rgba(0,0,0,0) 37.5%,rgba(0,0,0,1) 50%,rgba(0,0,0,1) 62.5%,rgba(0,0,0,0) 75%)',
	                maskImage: 'linear-gradient(to bottom,rgba(0,0,0,0) 37.5%,rgba(0,0,0,1) 50%,rgba(0,0,0,1) 62.5%,rgba(0,0,0,0) 75%)',
	            },
	            '& > div:nth-of-type(5)': {
	                zIndex: 5,
	                WebkitBackdropFilter: 'blur(4px)',
	                backdropFilter: 'blur(4px)',
	                WebkitMaskImage: 'linear-gradient(to bottom,rgba(0,0,0,0) 50%,rgba(0,0,0,1) 62.5%,rgba(0,0,0,1) 75%,rgba(0,0,0,0) 87.5%)',
	                maskImage: 'linear-gradient(to bottom,rgba(0,0,0,0) 50%,rgba(0,0,0,1) 62.5%,rgba(0,0,0,1) 75%,rgba(0,0,0,0) 87.5%)',
	            },
	            '& > div:nth-of-type(6)': {
	                zIndex: 6,
	                WebkitBackdropFilter: 'blur(2px)',
	                backdropFilter: 'blur(2px)',
	                WebkitMaskImage: 'linear-gradient(to bottom,rgba(0,0,0,0) 62.5%,rgba(0,0,0,1) 75%,rgba(0,0,0,1) 87.5%,rgba(0,0,0,0) 100%)',
	                maskImage: 'linear-gradient(to bottom,rgba(0,0,0,0) 62.5%,rgba(0,0,0,1) 75%,rgba(0,0,0,1) 87.5%,rgba(0,0,0,0) 100%)',
	            },
	            '& > div:nth-of-type(7)': {
	                zIndex: 7,
	                WebkitBackdropFilter: 'blur(1px)',
	                backdropFilter: 'blur(1px)',
	                WebkitMaskImage: 'linear-gradient(to bottom,rgba(0,0,0,0) 75%,rgba(0,0,0,1) 87.5%,rgba(0,0,0,1) 100%)',
	                maskImage: 'linear-gradient(to bottom,rgba(0,0,0,0) 75%,rgba(0,0,0,1) 87.5%,rgba(0,0,0,1) 100%)',
	            },
	            '& > div:nth-of-type(8)': {
	                zIndex: 8,
	                WebkitBackdropFilter: 'blur(.5px)',
	                backdropFilter: 'blur(.5px)',
	                WebkitMaskImage: 'linear-gradient(to bottom,rgba(0,0,0,0) 87.5%,rgba(0,0,0,1) 100%)',
	                maskImage: 'linear-gradient(to bottom,rgba(0,0,0,0) 87.5%,rgba(0,0,0,1) 100%)',
	            },
	        },
	        main: {
	            zIndex: 4,
	            gridArea: 'main',
	            padding: spacingBase,
	        },
	        footer: {
	            zIndex: 5,
	            gridArea: 'footer',
	            padding: `${spacingBase} ${spacingBase} ${spacingFluidSmall.spacingFluidSmall}`,
	            position: 'sticky',
	            bottom: 0,
	            '&::before': {
	                content: '""',
	                zIndex: -1,
	                position: 'absolute',
	                inset: '-140px 0 0',
	                pointerEvents: 'none',
	                background: `linear-gradient(to bottom,hsla(var(${cssVarColorFooterGradient}),0) 0%,hsla(var(${cssVarColorFooterGradient}),0.013) 8.1%,hsla(var(${cssVarColorFooterGradient}),0.049) 15.5%,hsla(var(${cssVarColorFooterGradient}),0.104) 22.5%,hsla(var(${cssVarColorFooterGradient}),0.175) 29%,hsla(var(${cssVarColorFooterGradient}),0.259) 35.3%,hsla(var(${cssVarColorFooterGradient}),0.352) 41.2%,hsla(var(${cssVarColorFooterGradient}),0.45) 47.1%,hsla(var(${cssVarColorFooterGradient}),0.55) 52.9%,hsla(var(${cssVarColorFooterGradient}),0.648) 58.8%,hsla(var(${cssVarColorFooterGradient}),0.741) 64.7%,hsla(var(${cssVarColorFooterGradient}),0.825) 71%,hsla(var(${cssVarColorFooterGradient}),0.896) 77.5%,hsla(var(${cssVarColorFooterGradient}),0.951) 84.5%,hsla(var(${cssVarColorFooterGradient}),0.987) 91.9%,hsl(var(${cssVarColorFooterGradient})) 100%)`,
	            },
	        },
	        sidebar: {
	            position: 'sticky',
	            top: 0,
	            height: '100dvh',
	            '&--start': {
	                zIndex: 7,
	                gridArea: 'sidebar-start',
	                justifySelf: 'flex-end',
	                width: sidebarStartWidth,
	                backgroundColor: `var(${cssVarColorBackgroundSurface})`,
	                '&::before': {
	                    content: '""',
	                    zIndex: -1,
	                    position: 'absolute',
	                    backgroundColor: 'transparent',
	                    right: '-16px',
	                    height: '32px',
	                    width: '16px',
	                    pointerEvents: 'none',
	                    top: 0,
	                    borderTopLeftRadius: '16px',
	                    boxShadow: `0 -16px 0 0 var(${cssVarColorBackgroundSurface})`,
	                },
	            },
	            '&--end': {
	                zIndex: 1,
	                gridArea: 'sidebar-end',
	                justifySelf: 'flex-end',
	                width: sidebarEndWidth,
	                backgroundColor: `var(${cssVarColorBackgroundBase})`,
	            },
	            '&__scroller': {
	                position: 'absolute',
	                inset: 0,
	                overflow: 'hidden auto',
	                overscrollBehaviorY: 'contain',
	                background: 'inherit', // ensures correct scrollbar coloring in light / dark mode
	            },
	            '&__header': {
	                zIndex: 1,
	                display: 'flex',
	                gap: spacingStaticSmall.spacingStaticSmall,
	                alignItems: 'center',
	                position: 'sticky',
	                top: 0,
	                padding: `${spacingStaticSmall.spacingStaticSmall} ${spacingBase}`,
	                minHeight: '56px',
	                boxSizing: 'border-box',
	                '&--start': {
	                    justifyContent: 'flex-start',
	                    '&::before': {
	                        background: `linear-gradient(180deg,var(${cssVarColorBackgroundSurface}) 0%,var(${cssVarColorBackgroundSurface}) 65%,transparent 100%)`,
	                    },
	                },
	                '&--end': {
	                    justifyContent: 'space-between',
	                    '&::before': {
	                        background: `linear-gradient(180deg,var(${cssVarColorBackgroundBase}) 0%,var(${cssVarColorBackgroundBase}) 65%,transparent 100%)`,
	                    },
	                },
	                '&::before': {
	                    content: '""',
	                    zIndex: -1,
	                    position: 'absolute',
	                    inset: '0 0 -8px',
	                    pointerEvents: 'none',
	                },
	            },
	            '&__content': {
	                position: 'relative', // needed for z-index to work
	                zIndex: 0, // ensures slotted dom nodes can't be on top of sidebar header
	                display: 'block',
	                padding: spacingBase,
	            },
	            '&:focus': {
	                outline: 'none',
	            },
	        },
	        'flyout-start': {
	            '--p-flyout-width': '100dvw',
	            '--p-flyout-max-width': sidebarStartWidth,
	        },
	        'flyout-end': {
	            '--p-flyout-width': '100dvw',
	            '--p-flyout-max-width': sidebarEndWidth,
	        },
	    });
	};

	const propTypes = {
	    sidebarStartOpen: validateProps.AllowedTypes.boolean,
	    sidebarEndOpen: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Canvas = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.sidebarStartUpdate = validateProps.createEvent(this, "sidebarStartUpdate", 3);
	        this.sidebarEndDismiss = validateProps.createEvent(this, "sidebarEndDismiss", 3);
	        this.matchMediaQueryS = window.matchMedia(`(min-width: ${validateProps.breakpointS}px)`);
	        this.matchMediaQueryM = window.matchMedia(`(min-width: ${validateProps.breakpointM}px)`);
	        this.handleMediaQueryS = (e) => {
	            this.isMediaQueryS = !!e.matches;
	        };
	        this.handleMediaQueryM = (e) => {
	            this.isMediaQueryM = !!e.matches;
	        };
	        this.toggleSidebarStart = () => {
	            this.sidebarStartUpdate.emit({
	                open: !this.sidebarStartOpen,
	            });
	        };
	        this.onDismissSidebarStart = () => {
	            this.sidebarStartUpdate.emit({
	                open: false,
	            });
	        };
	        this.onDismissSidebarEnd = () => {
	            this.sidebarEndDismiss.emit();
	        };
	        this.sidebarStartOpen = false;
	        this.sidebarEndOpen = false;
	        this.theme = 'light';
	        this.isMediaQueryS = false;
	        this.isMediaQueryM = false;
	    }
	    openChangeHandlerSidebarStart(isOpen) {
	        if (this.isMediaQueryS) {
	            this.root.ontransitionend = () => {
	                this[isOpen ? 'sidebarStart' : 'header'].focus({ preventScroll: true });
	            };
	        }
	    }
	    openChangeHandlerSidebarEnd(isOpen) {
	        if (this.isMediaQueryM) {
	            this.root.ontransitionend = () => {
	                this[isOpen ? 'sidebarEnd' : 'header'].focus({ preventScroll: true });
	            };
	        }
	    }
	    connectedCallback() {
	        this.handleMediaQueryS(this.matchMediaQueryS);
	        this.handleMediaQueryM(this.matchMediaQueryM);
	        this.matchMediaQueryS.addEventListener('change', this.handleMediaQueryS);
	        this.matchMediaQueryM.addEventListener('change', this.handleMediaQueryM);
	    }
	    disconnectedCallback() {
	        this.matchMediaQueryS.removeEventListener('change', this.handleMediaQueryS);
	        this.matchMediaQueryM.removeEventListener('change', this.handleMediaQueryM);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        this.hasTitle = hasNamedSlot.hasNamedSlot(this.host, 'title');
	        this.hasSidebarEnd = hasNamedSlot.hasNamedSlot(this.host, 'sidebar-end');
	        this.hasSidebarEndHeader = hasNamedSlot.hasNamedSlot(this.host, 'sidebar-end-header');
	        this.hasFooter = hasNamedSlot.hasNamedSlot(this.host, 'footer');
	        this.hasBackground = hasNamedSlot.hasNamedSlot(this.host, 'background');
	        validateProps.attachComponentCss(this.host, getComponentCss, this.theme, this.sidebarStartOpen, this.sidebarEndOpen);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(validateProps.Host, { key: 'd00919113b9945178721d084de535791e6b592f9' }, validateProps.h("div", { key: '3b6650aef350044739b0f4e958dacc0e308616af', class: "root", ref: (el) => (this.root = el) }, validateProps.h("header", { key: 'd8f18ec8473a53af3b848fde8d53579c8a16b236', class: "header", tabIndex: -1, ref: (el) => (this.header = el) }, validateProps.h("div", { key: 'a6a5b368c27b492ab5e9a243ac435d0672cdde3d', class: "blur" }, validateProps.h("div", { key: 'caf1047ecdea01ae5a8565d4a5565c0f16914961' }), validateProps.h("div", { key: '261e9bed20fc052f549163b9d20ffaf40aa457a5' }), validateProps.h("div", { key: '7feb5e17625d07cd5a12ad6d8daadfaadaf96fa6' }), validateProps.h("div", { key: '14b7a958068d7ce8f4e82b61d80cbe5936405822' }), validateProps.h("div", { key: '91fb7fed0ee26dd07fee178b621f67e827d89ac8' }), validateProps.h("div", { key: 'c7837ba1bb4f1058d57a2b5b24b28b765e56fb08' }), validateProps.h("div", { key: '34c082f285e41233ccd8d3079dec4da6402ffadb' }), validateProps.h("div", { key: '6c7b765e76e462cd481a4912f4e1fe2a70c4056b' })), validateProps.h("div", { key: '7a08fdfe9bff675b400823fa7c61697f9b38bcf6', class: "header__area header__area--start" }, !this.sidebarStartOpen && (validateProps.h(PrefixedTagNames.pButton, { key: '664f4856f4f968f15a3283eb27c6d01bed0e4f56', theme: this.theme, icon: "sidebar", variant: "ghost", compact: true, "hide-label": "true", aria: { 'aria-expanded': this.sidebarStartOpen }, onClick: this.toggleSidebarStart }, this.sidebarStartOpen ? 'Close' : 'Open', " navigation sidebar")), validateProps.h("slot", { key: 'a4ea1d732d441fdc037520fafb1f12165b43862a', name: "header-start" })), validateProps.h(PrefixedTagNames.pCrest, { key: 'e7a96c780a3d56edc202d2a5e056f43ee8b86ee6', class: "header__crest" }), validateProps.h(PrefixedTagNames.pWordmark, { key: 'f1a8d067bc4f3d968909a35235c47ecf646d9a09', class: "header__wordmark", size: "inherit", theme: this.theme }), validateProps.h("div", { key: 'aff1b5f7a582451aaae87810f6e882e8e6663afb', class: "header__area header__area--end" }, validateProps.h("slot", { key: 'e1d185f28f6ebad59cbc1c3bb14c177a66e1f32a', name: "header-end" }))), this.isMediaQueryS && (validateProps.h("aside", { key: '6d49403cac500429745356eadf56083ca3d79dcb', class: "sidebar sidebar--start", inert: !this.sidebarStartOpen, "aria-label": `Navigation sidebar ${this.sidebarStartOpen ? 'open' : 'closed'}`, tabIndex: -1, ref: (el) => (this.sidebarStart = el) }, validateProps.h("div", { key: '26c1dc84d1d8c853347321ccbe134f74d28ee634', class: "sidebar__scroller" }, validateProps.h("div", { key: '57e82a0116489d29bc2ef28df5ea4798699f38ad', class: "sidebar__header sidebar__header--start" }, validateProps.h(PrefixedTagNames.pButton, { key: '991b876538680ccefac21cb1abb9dd577a6ff555', theme: this.theme, icon: "sidebar", variant: "ghost", compact: true, "hide-label": "true", aria: { 'aria-expanded': this.sidebarStartOpen }, onClick: this.toggleSidebarStart }, this.sidebarStartOpen ? 'Close' : 'Open', " navigation sidebar"), this.hasTitle && (validateProps.h("h2", { key: '3f73f8dada94c61761efb75e8a514824e0005a38' }, validateProps.h("slot", { key: 'ae01c3563aa8391649fbc10626d6fab52465909c', name: "title" })))), validateProps.h("div", { key: '5e2853866d780724c6b96d72ec769eec7f3bf20c', class: "sidebar__content" }, validateProps.h("slot", { key: 'ac75c80dec9b1d97d66941666077618d05e494de', name: "sidebar-start" }))))), validateProps.h("main", { key: '33a4aa20b291e94995c7c9c444edb3efc1cb339d', class: "main" }, validateProps.h("slot", { key: '85e9b344d5ccb0e1eb179edbfb3c7093a57b94d7' })), this.hasSidebarEnd && this.isMediaQueryM && (validateProps.h("aside", { key: '69264a2cb69944b3a761721c17474c1760e115a0', class: "sidebar sidebar--end", inert: !this.sidebarEndOpen, "aria-label": `Settings sidebar ${this.sidebarEndOpen ? 'open' : 'closed'}`, tabIndex: -1, ref: (el) => (this.sidebarEnd = el) }, validateProps.h("div", { key: 'f183c9ef8956cd95dac2c533cb30f04c6f0ce4b6', class: "sidebar__scroller" }, validateProps.h("div", { key: '9fc5780aa49c301dac162c8d0f9645ac4831abee', class: "sidebar__header sidebar__header--end" }, validateProps.h("slot", { key: 'b7d19888aac5149519d0ca45a9f5822ced93b2d6', name: "sidebar-end-header" }), validateProps.h(PrefixedTagNames.pButton, { key: 'dd2f469bbc538eedd2a84c4e58fae8b6e39080e1', theme: this.theme, icon: "close", variant: "ghost", compact: true, "hide-label": "true", aria: { 'aria-expanded': this.sidebarEndOpen }, onClick: this.onDismissSidebarEnd }, this.sidebarEndOpen ? 'Close' : 'Open', " settings sidebar")), validateProps.h("div", { key: '0ca7c53d5d82f142fa9ec8ac2da8641a59b8f85a', class: "sidebar__content" }, validateProps.h("slot", { key: '17719b759febcc825b9143c960578c6f0f2de207', name: "sidebar-end" }))))), this.hasFooter && (validateProps.h("footer", { key: '4683066a78d202ee17c6f13db4319d7d4fedf23f', class: "footer" }, validateProps.h("slot", { key: 'ed265efcb03fbbbb9ee42c4f035a84027086fdb8', name: "footer" }))), this.hasBackground && validateProps.h("slot", { key: '9e9bbf8a2c0f4262212d121a8a5d98ffb6e6a282', name: "background" })), !this.isMediaQueryS && (validateProps.h(PrefixedTagNames.pFlyout, { key: '5e732d8ce60dea310203e8b6526264c697e4b448', class: "flyout-start", theme: this.theme, open: this.sidebarStartOpen, position: "start", onDismiss: this.onDismissSidebarStart }, this.hasTitle && (validateProps.h("h2", { key: 'e16d7849aceb07ca0e4e3d278c64248659b3d967', slot: "header" }, validateProps.h("slot", { key: '3112e1f78749891276072ca9e4aff8e3d2f7ed33', name: "title" }))), validateProps.h("slot", { key: '05b3860120ad903dbb00ad520c637589c7c9f98a', name: "sidebar-start" }))), this.hasSidebarEnd && !this.isMediaQueryM && (validateProps.h(PrefixedTagNames.pFlyout, { key: '765760e09d5ccc17c21308ede72d1723bbb58447', class: "flyout-end", theme: this.theme, open: this.sidebarEndOpen, position: "end", onDismiss: this.onDismissSidebarEnd }, this.hasSidebarEndHeader && validateProps.h("slot", { key: '1e52c06ce8f609f4611285194aa3a68e00d01971', slot: "header", name: "sidebar-end-header" }), validateProps.h("slot", { key: '78f489b00d00a08428beacc50ad2cf49c06dd04b', name: "sidebar-end" })))));
	    }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "sidebarStartOpen": ["openChangeHandlerSidebarStart"],
	        "sidebarEndOpen": ["openChangeHandlerSidebarEnd"]
	    }; }
	};

	pCanvas_cjs_entry.p_canvas = Canvas;

	
	return pCanvas_cjs_entry;
}

var pCarousel_cjs_entry = {};

var hasRequiredPCarousel_cjs_entry;

function requirePCarousel_cjs_entry () {
	if (hasRequiredPCarousel_cjs_entry) return pCarousel_cjs_entry;
	hasRequiredPCarousel_cjs_entry = 1;

	Object.defineProperty(pCarousel_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const hasNamedSlot = requireHasNamedSlot273cd3ae();
	const hasDescription = requireHasDescription050833e0();
	const hasHeading = requireHasHeading5ac42b7f();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed91ceea3c();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed76f87eda();
	const theme = requireThemeBfc10573();
	const slottedAnchorStyles = requireSlottedAnchorStylesFe1a10c2();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const gridBasicOffset = requireGridBasicOffset92343778();
	const spacingFluidMedium = requireSpacingFluidMedium88ab712b();
	const borderRadiusLarge = requireBorderRadiusLargeA0aa3a01();
	const headingXXLargeStyle = requireHeadingXXLargeStyle0857cde1();
	const headingShared = requireHeadingShared888aa084();
	const spacingFluidSmall = requireSpacingFluidSmall2c6caae7();
	const textSmallStyle = requireTextSmallStyle00e1c6e2();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const gridGap = requireGridGapB5b73e4a();
	requireGetNamedSlot223c478a();
	requireHelper22e15c0e();
	requireBorderRadiusMedium758b9411();
	requireGridExtendedOffsetBaseFb9830f6();
	requireGridExtendedOffsetXXLC7a41e50();
	requireFontSizeTextXLarge0ecf9ef3();
	requireFontFamily23874d28();
	requireFontLineHeightD4b9e1a9();
	requireFontWeightSemiBold4482c830();
	requireFontVariant6ba3b7cb();
	requireTextShared5216bb19();
	requireFontWeightRegularD0c768ac();
	requireFontSizeTextSmall508930e5();

	const headingXLargeStyle = {
	    font: `${headingShared._headingFontPartA}${headingXXLargeStyle.fontSizeHeadingXLarge}${headingShared._headingFontPartB}`,
	};

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { _defineProperties(Constructor.prototype, protoProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

	/*!
	 * Splide.js
	 * Version  : 4.1.4
	 * License  : MIT
	 * Copyright: 2022 Naotoshi Fujita
	 */
	var MEDIA_PREFERS_REDUCED_MOTION = "(prefers-reduced-motion: reduce)";
	var CREATED = 1;
	var MOUNTED = 2;
	var IDLE = 3;
	var MOVING = 4;
	var SCROLLING = 5;
	var DRAGGING = 6;
	var DESTROYED = 7;
	var STATES = {
	  CREATED: CREATED,
	  MOUNTED: MOUNTED,
	  IDLE: IDLE,
	  MOVING: MOVING,
	  SCROLLING: SCROLLING,
	  DRAGGING: DRAGGING,
	  DESTROYED: DESTROYED
	};

	function empty(array) {
	  array.length = 0;
	}

	function slice(arrayLike, start, end) {
	  return Array.prototype.slice.call(arrayLike, start, end);
	}

	function apply(func) {
	  return func.bind.apply(func, [null].concat(slice(arguments, 1)));
	}

	var nextTick = setTimeout;

	var noop = function noop() {};

	function raf(func) {
	  return requestAnimationFrame(func);
	}

	function typeOf(type, subject) {
	  return typeof subject === type;
	}

	function isObject(subject) {
	  return !isNull(subject) && typeOf("object", subject);
	}

	var isArray = Array.isArray;
	var isFunction = apply(typeOf, "function");
	var isString = apply(typeOf, "string");
	var isUndefined = apply(typeOf, "undefined");

	function isNull(subject) {
	  return subject === null;
	}

	function isHTMLElement(subject) {
	  try {
	    return subject instanceof (subject.ownerDocument.defaultView || window).HTMLElement;
	  } catch (e) {
	    return false;
	  }
	}

	function toArray(value) {
	  return isArray(value) ? value : [value];
	}

	function forEach(values, iteratee) {
	  toArray(values).forEach(iteratee);
	}

	function includes(array, value) {
	  return array.indexOf(value) > -1;
	}

	function push(array, items) {
	  array.push.apply(array, toArray(items));
	  return array;
	}

	function toggleClass(elm, classes, add) {
	  if (elm) {
	    forEach(classes, function (name) {
	      if (name) {
	        elm.classList[add ? "add" : "remove"](name);
	      }
	    });
	  }
	}

	function addClass(elm, classes) {
	  toggleClass(elm, isString(classes) ? classes.split(" ") : classes, true);
	}

	function append(parent, children) {
	  forEach(children, parent.appendChild.bind(parent));
	}

	function before(nodes, ref) {
	  forEach(nodes, function (node) {
	    var parent = (ref || node).parentNode;

	    if (parent) {
	      parent.insertBefore(node, ref);
	    }
	  });
	}

	function matches(elm, selector) {
	  return isHTMLElement(elm) && (elm["msMatchesSelector"] || elm.matches).call(elm, selector);
	}

	function children(parent, selector) {
	  var children2 = parent ? slice(parent.children) : [];
	  return selector ? children2.filter(function (child) {
	    return matches(child, selector);
	  }) : children2;
	}

	function child(parent, selector) {
	  return selector ? children(parent, selector)[0] : parent.firstElementChild;
	}

	var ownKeys = Object.keys;

	function forOwn(object, iteratee, right) {
	  if (object) {
	    (right ? ownKeys(object).reverse() : ownKeys(object)).forEach(function (key) {
	      key !== "__proto__" && iteratee(object[key], key);
	    });
	  }

	  return object;
	}

	function assign(object) {
	  slice(arguments, 1).forEach(function (source) {
	    forOwn(source, function (value, key) {
	      object[key] = source[key];
	    });
	  });
	  return object;
	}

	function merge(object) {
	  slice(arguments, 1).forEach(function (source) {
	    forOwn(source, function (value, key) {
	      if (isArray(value)) {
	        object[key] = value.slice();
	      } else if (isObject(value)) {
	        object[key] = merge({}, isObject(object[key]) ? object[key] : {}, value);
	      } else {
	        object[key] = value;
	      }
	    });
	  });
	  return object;
	}

	function omit(object, keys) {
	  forEach(keys || ownKeys(object), function (key) {
	    delete object[key];
	  });
	}

	function removeAttribute(elms, attrs) {
	  forEach(elms, function (elm) {
	    forEach(attrs, function (attr) {
	      elm && elm.removeAttribute(attr);
	    });
	  });
	}

	function setAttribute(elms, attrs, value) {
	  if (isObject(attrs)) {
	    forOwn(attrs, function (value2, name) {
	      setAttribute(elms, name, value2);
	    });
	  } else {
	    forEach(elms, function (elm) {
	      isNull(value) || value === "" ? removeAttribute(elm, attrs) : elm.setAttribute(attrs, String(value));
	    });
	  }
	}

	function create(tag, attrs, parent) {
	  var elm = document.createElement(tag);

	  if (attrs) {
	    isString(attrs) ? addClass(elm, attrs) : setAttribute(elm, attrs);
	  }

	  parent && append(parent, elm);
	  return elm;
	}

	function style(elm, prop, value) {
	  if (isUndefined(value)) {
	    return getComputedStyle(elm)[prop];
	  }

	  if (!isNull(value)) {
	    elm.style[prop] = "" + value;
	  }
	}

	function display(elm, display2) {
	  style(elm, "display", display2);
	}

	function focus(elm) {
	  elm["setActive"] && elm["setActive"]() || elm.focus({
	    preventScroll: true
	  });
	}

	function getAttribute(elm, attr) {
	  return elm.getAttribute(attr);
	}

	function hasClass(elm, className) {
	  return elm && elm.classList.contains(className);
	}

	function rect(target) {
	  return target.getBoundingClientRect();
	}

	function remove(nodes) {
	  forEach(nodes, function (node) {
	    if (node && node.parentNode) {
	      node.parentNode.removeChild(node);
	    }
	  });
	}

	function parseHtml(html) {
	  return child(new DOMParser().parseFromString(html, "text/html").body);
	}

	function prevent(e, stopPropagation) {
	  e.preventDefault();

	  if (stopPropagation) {
	    e.stopPropagation();
	    e.stopImmediatePropagation();
	  }
	}

	function query(parent, selector) {
	  return parent && parent.querySelector(selector);
	}

	function queryAll(parent, selector) {
	  return selector ? slice(parent.querySelectorAll(selector)) : [];
	}

	function removeClass(elm, classes) {
	  toggleClass(elm, classes, false);
	}

	function timeOf(e) {
	  return e.timeStamp;
	}

	function unit(value) {
	  return isString(value) ? value : value ? value + "px" : "";
	}

	var PROJECT_CODE = "splide";
	var DATA_ATTRIBUTE = "data-" + PROJECT_CODE;

	function assert(condition, message) {
	  if (!condition) {
	    throw new Error("[" + PROJECT_CODE + "] " + (message || ""));
	  }
	}

	var min = Math.min,
	    max = Math.max,
	    floor = Math.floor,
	    ceil = Math.ceil,
	    abs = Math.abs;

	function approximatelyEqual(x, y, epsilon) {
	  return abs(x - y) < epsilon;
	}

	function between(number, x, y, exclusive) {
	  var minimum = min(x, y);
	  var maximum = max(x, y);
	  return exclusive ? minimum < number && number < maximum : minimum <= number && number <= maximum;
	}

	function clamp(number, x, y) {
	  var minimum = min(x, y);
	  var maximum = max(x, y);
	  return min(max(minimum, number), maximum);
	}

	function sign(x) {
	  return +(x > 0) - +(x < 0);
	}

	function format(string, replacements) {
	  forEach(replacements, function (replacement) {
	    string = string.replace("%s", "" + replacement);
	  });
	  return string;
	}

	function pad(number) {
	  return number < 10 ? "0" + number : "" + number;
	}

	var ids = {};

	function uniqueId(prefix) {
	  return "" + prefix + pad(ids[prefix] = (ids[prefix] || 0) + 1);
	}

	function EventBinder() {
	  var listeners = [];

	  function bind(targets, events, callback, options) {
	    forEachEvent(targets, events, function (target, event, namespace) {
	      var isEventTarget = ("addEventListener" in target);
	      var remover = isEventTarget ? target.removeEventListener.bind(target, event, callback, options) : target["removeListener"].bind(target, callback);
	      isEventTarget ? target.addEventListener(event, callback, options) : target["addListener"](callback);
	      listeners.push([target, event, namespace, callback, remover]);
	    });
	  }

	  function unbind(targets, events, callback) {
	    forEachEvent(targets, events, function (target, event, namespace) {
	      listeners = listeners.filter(function (listener) {
	        if (listener[0] === target && listener[1] === event && listener[2] === namespace && (!callback || listener[3] === callback)) {
	          listener[4]();
	          return false;
	        }

	        return true;
	      });
	    });
	  }

	  function dispatch(target, type, detail) {
	    var e;
	    var bubbles = true;

	    if (typeof CustomEvent === "function") {
	      e = new CustomEvent(type, {
	        bubbles: bubbles,
	        detail: detail
	      });
	    } else {
	      e = document.createEvent("CustomEvent");
	      e.initCustomEvent(type, bubbles, false, detail);
	    }

	    target.dispatchEvent(e);
	    return e;
	  }

	  function forEachEvent(targets, events, iteratee) {
	    forEach(targets, function (target) {
	      target && forEach(events, function (events2) {
	        events2.split(" ").forEach(function (eventNS) {
	          var fragment = eventNS.split(".");
	          iteratee(target, fragment[0], fragment[1]);
	        });
	      });
	    });
	  }

	  function destroy() {
	    listeners.forEach(function (data) {
	      data[4]();
	    });
	    empty(listeners);
	  }

	  return {
	    bind: bind,
	    unbind: unbind,
	    dispatch: dispatch,
	    destroy: destroy
	  };
	}

	var EVENT_MOUNTED = "mounted";
	var EVENT_READY = "ready";
	var EVENT_MOVE = "move";
	var EVENT_MOVED = "moved";
	var EVENT_CLICK = "click";
	var EVENT_ACTIVE = "active";
	var EVENT_INACTIVE = "inactive";
	var EVENT_VISIBLE = "visible";
	var EVENT_HIDDEN = "hidden";
	var EVENT_REFRESH = "refresh";
	var EVENT_UPDATED = "updated";
	var EVENT_RESIZE = "resize";
	var EVENT_RESIZED = "resized";
	var EVENT_DRAG = "drag";
	var EVENT_DRAGGING = "dragging";
	var EVENT_DRAGGED = "dragged";
	var EVENT_SCROLL = "scroll";
	var EVENT_SCROLLED = "scrolled";
	var EVENT_OVERFLOW = "overflow";
	var EVENT_DESTROY = "destroy";
	var EVENT_ARROWS_MOUNTED = "arrows:mounted";
	var EVENT_ARROWS_UPDATED = "arrows:updated";
	var EVENT_PAGINATION_MOUNTED = "pagination:mounted";
	var EVENT_PAGINATION_UPDATED = "pagination:updated";
	var EVENT_NAVIGATION_MOUNTED = "navigation:mounted";
	var EVENT_AUTOPLAY_PLAY = "autoplay:play";
	var EVENT_AUTOPLAY_PLAYING = "autoplay:playing";
	var EVENT_AUTOPLAY_PAUSE = "autoplay:pause";
	var EVENT_LAZYLOAD_LOADED = "lazyload:loaded";
	var EVENT_SLIDE_KEYDOWN = "sk";
	var EVENT_SHIFTED = "sh";
	var EVENT_END_INDEX_CHANGED = "ei";

	function EventInterface(Splide2) {
	  var bus = Splide2 ? Splide2.event.bus : document.createDocumentFragment();
	  var binder = EventBinder();

	  function on(events, callback) {
	    binder.bind(bus, toArray(events).join(" "), function (e) {
	      callback.apply(callback, isArray(e.detail) ? e.detail : []);
	    });
	  }

	  function emit(event) {
	    binder.dispatch(bus, event, slice(arguments, 1));
	  }

	  if (Splide2) {
	    Splide2.event.on(EVENT_DESTROY, binder.destroy);
	  }

	  return assign(binder, {
	    bus: bus,
	    on: on,
	    off: apply(binder.unbind, bus),
	    emit: emit
	  });
	}

	function RequestInterval(interval, onInterval, onUpdate, limit) {
	  var now = Date.now;
	  var startTime;
	  var rate = 0;
	  var id;
	  var paused = true;
	  var count = 0;

	  function update() {
	    if (!paused) {
	      rate = interval ? min((now() - startTime) / interval, 1) : 1;
	      onUpdate && onUpdate(rate);

	      if (rate >= 1) {
	        onInterval();
	        startTime = now();

	        if (limit && ++count >= limit) {
	          return pause();
	        }
	      }

	      id = raf(update);
	    }
	  }

	  function start(resume) {
	    resume || cancel();
	    startTime = now() - (resume ? rate * interval : 0);
	    paused = false;
	    id = raf(update);
	  }

	  function pause() {
	    paused = true;
	  }

	  function rewind() {
	    startTime = now();
	    rate = 0;

	    if (onUpdate) {
	      onUpdate(rate);
	    }
	  }

	  function cancel() {
	    id && cancelAnimationFrame(id);
	    rate = 0;
	    id = 0;
	    paused = true;
	  }

	  function set(time) {
	    interval = time;
	  }

	  function isPaused() {
	    return paused;
	  }

	  return {
	    start: start,
	    rewind: rewind,
	    pause: pause,
	    cancel: cancel,
	    set: set,
	    isPaused: isPaused
	  };
	}

	function State(initialState) {
	  var state = initialState;

	  function set(value) {
	    state = value;
	  }

	  function is(states) {
	    return includes(toArray(states), state);
	  }

	  return {
	    set: set,
	    is: is
	  };
	}

	function Throttle(func, duration) {
	  var interval = RequestInterval(0, func, null, 1);
	  return function () {
	    interval.isPaused() && interval.start();
	  };
	}

	function Media(Splide2, Components2, options) {
	  var state = Splide2.state;
	  var breakpoints = options.breakpoints || {};
	  var reducedMotion = options.reducedMotion || {};
	  var binder = EventBinder();
	  var queries = [];

	  function setup() {
	    var isMin = options.mediaQuery === "min";
	    ownKeys(breakpoints).sort(function (n, m) {
	      return isMin ? +n - +m : +m - +n;
	    }).forEach(function (key) {
	      register(breakpoints[key], "(" + (isMin ? "min" : "max") + "-width:" + key + "px)");
	    });
	    register(reducedMotion, MEDIA_PREFERS_REDUCED_MOTION);
	    update();
	  }

	  function destroy(completely) {
	    if (completely) {
	      binder.destroy();
	    }
	  }

	  function register(options2, query) {
	    var queryList = matchMedia(query);
	    binder.bind(queryList, "change", update);
	    queries.push([options2, queryList]);
	  }

	  function update() {
	    var destroyed = state.is(DESTROYED);
	    var direction = options.direction;
	    var merged = queries.reduce(function (merged2, entry) {
	      return merge(merged2, entry[1].matches ? entry[0] : {});
	    }, {});
	    omit(options);
	    set(merged);

	    if (options.destroy) {
	      Splide2.destroy(options.destroy === "completely");
	    } else if (destroyed) {
	      destroy(true);
	      Splide2.mount();
	    } else {
	      direction !== options.direction && Splide2.refresh();
	    }
	  }

	  function reduce(enable) {
	    if (matchMedia(MEDIA_PREFERS_REDUCED_MOTION).matches) {
	      enable ? merge(options, reducedMotion) : omit(options, ownKeys(reducedMotion));
	    }
	  }

	  function set(opts, base, notify) {
	    merge(options, opts);
	    base && merge(Object.getPrototypeOf(options), opts);

	    if (notify || !state.is(CREATED)) {
	      Splide2.emit(EVENT_UPDATED, options);
	    }
	  }

	  return {
	    setup: setup,
	    destroy: destroy,
	    reduce: reduce,
	    set: set
	  };
	}

	var ARROW = "Arrow";
	var ARROW_LEFT = ARROW + "Left";
	var ARROW_RIGHT = ARROW + "Right";
	var ARROW_UP = ARROW + "Up";
	var ARROW_DOWN = ARROW + "Down";
	var RTL = "rtl";
	var TTB = "ttb";
	var ORIENTATION_MAP = {
	  width: ["height"],
	  left: ["top", "right"],
	  right: ["bottom", "left"],
	  x: ["y"],
	  X: ["Y"],
	  Y: ["X"],
	  ArrowLeft: [ARROW_UP, ARROW_RIGHT],
	  ArrowRight: [ARROW_DOWN, ARROW_LEFT]
	};

	function Direction(Splide2, Components2, options) {
	  function resolve(prop, axisOnly, direction) {
	    direction = direction || options.direction;
	    var index = direction === RTL && !axisOnly ? 1 : direction === TTB ? 0 : -1;
	    return ORIENTATION_MAP[prop] && ORIENTATION_MAP[prop][index] || prop.replace(/width|left|right/i, function (match, offset) {
	      var replacement = ORIENTATION_MAP[match.toLowerCase()][index] || match;
	      return offset > 0 ? replacement.charAt(0).toUpperCase() + replacement.slice(1) : replacement;
	    });
	  }

	  function orient(value) {
	    return value * (options.direction === RTL ? 1 : -1);
	  }

	  return {
	    resolve: resolve,
	    orient: orient
	  };
	}

	var ROLE = "role";
	var TAB_INDEX = "tabindex";
	var DISABLED = "disabled";
	var ARIA_PREFIX = "aria-";
	var ARIA_CONTROLS = ARIA_PREFIX + "controls";
	var ARIA_CURRENT = ARIA_PREFIX + "current";
	var ARIA_SELECTED = ARIA_PREFIX + "selected";
	var ARIA_LABEL = ARIA_PREFIX + "label";
	var ARIA_LABELLEDBY = ARIA_PREFIX + "labelledby";
	var ARIA_HIDDEN = ARIA_PREFIX + "hidden";
	var ARIA_ORIENTATION = ARIA_PREFIX + "orientation";
	var ARIA_ROLEDESCRIPTION = ARIA_PREFIX + "roledescription";
	var ARIA_LIVE = ARIA_PREFIX + "live";
	var ARIA_BUSY = ARIA_PREFIX + "busy";
	var ARIA_ATOMIC = ARIA_PREFIX + "atomic";
	var ALL_ATTRIBUTES = [ROLE, TAB_INDEX, DISABLED, ARIA_CONTROLS, ARIA_CURRENT, ARIA_LABEL, ARIA_LABELLEDBY, ARIA_HIDDEN, ARIA_ORIENTATION, ARIA_ROLEDESCRIPTION];
	var CLASS_PREFIX = PROJECT_CODE + "__";
	var STATUS_CLASS_PREFIX = "is-";
	var CLASS_ROOT = PROJECT_CODE;
	var CLASS_TRACK = CLASS_PREFIX + "track";
	var CLASS_LIST = CLASS_PREFIX + "list";
	var CLASS_SLIDE = CLASS_PREFIX + "slide";
	var CLASS_CLONE = CLASS_SLIDE + "--clone";
	var CLASS_CONTAINER = CLASS_SLIDE + "__container";
	var CLASS_ARROWS = CLASS_PREFIX + "arrows";
	var CLASS_ARROW = CLASS_PREFIX + "arrow";
	var CLASS_ARROW_PREV = CLASS_ARROW + "--prev";
	var CLASS_ARROW_NEXT = CLASS_ARROW + "--next";
	var CLASS_PAGINATION = CLASS_PREFIX + "pagination";
	var CLASS_PAGINATION_PAGE = CLASS_PAGINATION + "__page";
	var CLASS_PROGRESS = CLASS_PREFIX + "progress";
	var CLASS_PROGRESS_BAR = CLASS_PROGRESS + "__bar";
	var CLASS_TOGGLE = CLASS_PREFIX + "toggle";
	var CLASS_SPINNER = CLASS_PREFIX + "spinner";
	var CLASS_SR = CLASS_PREFIX + "sr";
	var CLASS_INITIALIZED = STATUS_CLASS_PREFIX + "initialized";
	var CLASS_ACTIVE = STATUS_CLASS_PREFIX + "active";
	var CLASS_PREV = STATUS_CLASS_PREFIX + "prev";
	var CLASS_NEXT = STATUS_CLASS_PREFIX + "next";
	var CLASS_VISIBLE = STATUS_CLASS_PREFIX + "visible";
	var CLASS_LOADING = STATUS_CLASS_PREFIX + "loading";
	var CLASS_FOCUS_IN = STATUS_CLASS_PREFIX + "focus-in";
	var CLASS_OVERFLOW = STATUS_CLASS_PREFIX + "overflow";
	var STATUS_CLASSES = [CLASS_ACTIVE, CLASS_VISIBLE, CLASS_PREV, CLASS_NEXT, CLASS_LOADING, CLASS_FOCUS_IN, CLASS_OVERFLOW];
	var CLASSES = {
	  slide: CLASS_SLIDE,
	  clone: CLASS_CLONE,
	  arrows: CLASS_ARROWS,
	  arrow: CLASS_ARROW,
	  prev: CLASS_ARROW_PREV,
	  next: CLASS_ARROW_NEXT,
	  pagination: CLASS_PAGINATION,
	  page: CLASS_PAGINATION_PAGE,
	  spinner: CLASS_SPINNER
	};

	function closest(from, selector) {
	  if (isFunction(from.closest)) {
	    return from.closest(selector);
	  }

	  var elm = from;

	  while (elm && elm.nodeType === 1) {
	    if (matches(elm, selector)) {
	      break;
	    }

	    elm = elm.parentElement;
	  }

	  return elm;
	}

	var FRICTION = 5;
	var LOG_INTERVAL = 200;
	var POINTER_DOWN_EVENTS = "touchstart mousedown";
	var POINTER_MOVE_EVENTS = "touchmove mousemove";
	var POINTER_UP_EVENTS = "touchend touchcancel mouseup click";

	function Elements(Splide2, Components2, options) {
	  var _EventInterface = EventInterface(Splide2),
	      on = _EventInterface.on,
	      bind = _EventInterface.bind;

	  var root = Splide2.root;
	  var i18n = options.i18n;
	  var elements = {};
	  var slides = [];
	  var rootClasses = [];
	  var trackClasses = [];
	  var track;
	  var list;
	  var isUsingKey;

	  function setup() {
	    collect();
	    init();
	    update();
	  }

	  function mount() {
	    on(EVENT_REFRESH, destroy);
	    on(EVENT_REFRESH, setup);
	    on(EVENT_UPDATED, update);
	    bind(document, POINTER_DOWN_EVENTS + " keydown", function (e) {
	      isUsingKey = e.type === "keydown";
	    }, {
	      capture: true
	    });
	    bind(root, "focusin", function () {
	      toggleClass(root, CLASS_FOCUS_IN, !!isUsingKey);
	    });
	  }

	  function destroy(completely) {
	    var attrs = ALL_ATTRIBUTES.concat("style");
	    empty(slides);
	    removeClass(root, rootClasses);
	    removeClass(track, trackClasses);
	    removeAttribute([track, list], attrs);
	    removeAttribute(root, completely ? attrs : ["style", ARIA_ROLEDESCRIPTION]);
	  }

	  function update() {
	    removeClass(root, rootClasses);
	    removeClass(track, trackClasses);
	    rootClasses = getClasses(CLASS_ROOT);
	    trackClasses = getClasses(CLASS_TRACK);
	    addClass(root, rootClasses);
	    addClass(track, trackClasses);
	    setAttribute(root, ARIA_LABEL, options.label);
	    setAttribute(root, ARIA_LABELLEDBY, options.labelledby);
	  }

	  function collect() {
	    track = find("." + CLASS_TRACK);
	    list = child(track, "." + CLASS_LIST);
	    assert(track && list, "A track/list element is missing.");
	    push(slides, children(list, "." + CLASS_SLIDE + ":not(." + CLASS_CLONE + ")"));
	    forOwn({
	      arrows: CLASS_ARROWS,
	      pagination: CLASS_PAGINATION,
	      prev: CLASS_ARROW_PREV,
	      next: CLASS_ARROW_NEXT,
	      bar: CLASS_PROGRESS_BAR,
	      toggle: CLASS_TOGGLE
	    }, function (className, key) {
	      elements[key] = find("." + className);
	    });
	    assign(elements, {
	      root: root,
	      track: track,
	      list: list,
	      slides: slides
	    });
	  }

	  function init() {
	    var id = root.id || uniqueId(PROJECT_CODE);
	    var role = options.role;
	    root.id = id;
	    track.id = track.id || id + "-track";
	    list.id = list.id || id + "-list";

	    if (!getAttribute(root, ROLE) && root.tagName !== "SECTION" && role) {
	      setAttribute(root, ROLE, role);
	    }

	    setAttribute(root, ARIA_ROLEDESCRIPTION, i18n.carousel);
	    setAttribute(list, ROLE, "presentation");
	  }

	  function find(selector) {
	    var elm = query(root, selector);
	    return elm && closest(elm, "." + CLASS_ROOT) === root ? elm : void 0;
	  }

	  function getClasses(base) {
	    return [base + "--" + options.type, base + "--" + options.direction, options.drag && base + "--draggable", options.isNavigation && base + "--nav", base === CLASS_ROOT && CLASS_ACTIVE];
	  }

	  return assign(elements, {
	    setup: setup,
	    mount: mount,
	    destroy: destroy
	  });
	}

	var SLIDE = "slide";
	var LOOP = "loop";
	var FADE = "fade";

	function Slide$1(Splide2, index, slideIndex, slide) {
	  var event = EventInterface(Splide2);
	  var on = event.on,
	      emit = event.emit,
	      bind = event.bind;
	  var Components = Splide2.Components,
	      root = Splide2.root,
	      options = Splide2.options;
	  var isNavigation = options.isNavigation,
	      updateOnMove = options.updateOnMove,
	      i18n = options.i18n,
	      pagination = options.pagination,
	      slideFocus = options.slideFocus;
	  var resolve = Components.Direction.resolve;
	  var styles = getAttribute(slide, "style");
	  var label = getAttribute(slide, ARIA_LABEL);
	  var isClone = slideIndex > -1;
	  var container = child(slide, "." + CLASS_CONTAINER);
	  var destroyed;

	  function mount() {
	    if (!isClone) {
	      slide.id = root.id + "-slide" + pad(index + 1);
	      setAttribute(slide, ROLE, pagination ? "tabpanel" : "group");
	      setAttribute(slide, ARIA_ROLEDESCRIPTION, i18n.slide);
	      setAttribute(slide, ARIA_LABEL, label || format(i18n.slideLabel, [index + 1, Splide2.length]));
	    }

	    listen();
	  }

	  function listen() {
	    bind(slide, "click", apply(emit, EVENT_CLICK, self));
	    bind(slide, "keydown", apply(emit, EVENT_SLIDE_KEYDOWN, self));
	    on([EVENT_MOVED, EVENT_SHIFTED, EVENT_SCROLLED], update);
	    on(EVENT_NAVIGATION_MOUNTED, initNavigation);

	    if (updateOnMove) {
	      on(EVENT_MOVE, onMove);
	    }
	  }

	  function destroy() {
	    destroyed = true;
	    event.destroy();
	    removeClass(slide, STATUS_CLASSES);
	    removeAttribute(slide, ALL_ATTRIBUTES);
	    setAttribute(slide, "style", styles);
	    setAttribute(slide, ARIA_LABEL, label || "");
	  }

	  function initNavigation() {
	    var controls = Splide2.splides.map(function (target) {
	      var Slide2 = target.splide.Components.Slides.getAt(index);
	      return Slide2 ? Slide2.slide.id : "";
	    }).join(" ");
	    setAttribute(slide, ARIA_LABEL, format(i18n.slideX, (isClone ? slideIndex : index) + 1));
	    setAttribute(slide, ARIA_CONTROLS, controls);
	    setAttribute(slide, ROLE, slideFocus ? "button" : "");
	    slideFocus && removeAttribute(slide, ARIA_ROLEDESCRIPTION);
	  }

	  function onMove() {
	    if (!destroyed) {
	      update();
	    }
	  }

	  function update() {
	    if (!destroyed) {
	      var curr = Splide2.index;
	      updateActivity();
	      updateVisibility();
	      toggleClass(slide, CLASS_PREV, index === curr - 1);
	      toggleClass(slide, CLASS_NEXT, index === curr + 1);
	    }
	  }

	  function updateActivity() {
	    var active = isActive();

	    if (active !== hasClass(slide, CLASS_ACTIVE)) {
	      toggleClass(slide, CLASS_ACTIVE, active);
	      setAttribute(slide, ARIA_CURRENT, isNavigation && active || "");
	      emit(active ? EVENT_ACTIVE : EVENT_INACTIVE, self);
	    }
	  }

	  function updateVisibility() {
	    var visible = isVisible();
	    var hidden = !visible && (!isActive() || isClone);

	    if (!Splide2.state.is([MOVING, SCROLLING])) {
	      setAttribute(slide, ARIA_HIDDEN, hidden || "");
	    }

	    setAttribute(queryAll(slide, options.focusableNodes || ""), TAB_INDEX, hidden ? -1 : "");

	    if (slideFocus) {
	      setAttribute(slide, TAB_INDEX, hidden ? -1 : 0);
	    }

	    if (visible !== hasClass(slide, CLASS_VISIBLE)) {
	      toggleClass(slide, CLASS_VISIBLE, visible);
	      emit(visible ? EVENT_VISIBLE : EVENT_HIDDEN, self);
	    }

	    if (!visible && document.activeElement === slide) {
	      var Slide2 = Components.Slides.getAt(Splide2.index);
	      Slide2 && focus(Slide2.slide);
	    }
	  }

	  function style$1(prop, value, useContainer) {
	    style(useContainer && container || slide, prop, value);
	  }

	  function isActive() {
	    var curr = Splide2.index;
	    return curr === index || options.cloneStatus && curr === slideIndex;
	  }

	  function isVisible() {
	    if (Splide2.is(FADE)) {
	      return isActive();
	    }

	    var trackRect = rect(Components.Elements.track);
	    var slideRect = rect(slide);
	    var left = resolve("left", true);
	    var right = resolve("right", true);
	    return floor(trackRect[left]) <= ceil(slideRect[left]) && floor(slideRect[right]) <= ceil(trackRect[right]);
	  }

	  function isWithin(from, distance) {
	    var diff = abs(from - index);

	    if (!isClone && (options.rewind || Splide2.is(LOOP))) {
	      diff = min(diff, Splide2.length - diff);
	    }

	    return diff <= distance;
	  }

	  var self = {
	    index: index,
	    slideIndex: slideIndex,
	    slide: slide,
	    container: container,
	    isClone: isClone,
	    mount: mount,
	    destroy: destroy,
	    update: update,
	    style: style$1,
	    isWithin: isWithin
	  };
	  return self;
	}

	function Slides(Splide2, Components2, options) {
	  var _EventInterface2 = EventInterface(Splide2),
	      on = _EventInterface2.on,
	      emit = _EventInterface2.emit,
	      bind = _EventInterface2.bind;

	  var _Components2$Elements = Components2.Elements,
	      slides = _Components2$Elements.slides,
	      list = _Components2$Elements.list;
	  var Slides2 = [];

	  function mount() {
	    init();
	    on(EVENT_REFRESH, destroy);
	    on(EVENT_REFRESH, init);
	  }

	  function init() {
	    slides.forEach(function (slide, index) {
	      register(slide, index, -1);
	    });
	  }

	  function destroy() {
	    forEach$1(function (Slide2) {
	      Slide2.destroy();
	    });
	    empty(Slides2);
	  }

	  function update() {
	    forEach$1(function (Slide2) {
	      Slide2.update();
	    });
	  }

	  function register(slide, index, slideIndex) {
	    var object = Slide$1(Splide2, index, slideIndex, slide);
	    object.mount();
	    Slides2.push(object);
	    Slides2.sort(function (Slide1, Slide2) {
	      return Slide1.index - Slide2.index;
	    });
	  }

	  function get(excludeClones) {
	    return excludeClones ? filter(function (Slide2) {
	      return !Slide2.isClone;
	    }) : Slides2;
	  }

	  function getIn(page) {
	    var Controller = Components2.Controller;
	    var index = Controller.toIndex(page);
	    var max = Controller.hasFocus() ? 1 : options.perPage;
	    return filter(function (Slide2) {
	      return between(Slide2.index, index, index + max - 1);
	    });
	  }

	  function getAt(index) {
	    return filter(index)[0];
	  }

	  function add(items, index) {
	    forEach(items, function (slide) {
	      if (isString(slide)) {
	        slide = parseHtml(slide);
	      }

	      if (isHTMLElement(slide)) {
	        var ref = slides[index];
	        ref ? before(slide, ref) : append(list, slide);
	        addClass(slide, options.classes.slide);
	        observeImages(slide, apply(emit, EVENT_RESIZE));
	      }
	    });
	    emit(EVENT_REFRESH);
	  }

	  function remove$1(matcher) {
	    remove(filter(matcher).map(function (Slide2) {
	      return Slide2.slide;
	    }));
	    emit(EVENT_REFRESH);
	  }

	  function forEach$1(iteratee, excludeClones) {
	    get(excludeClones).forEach(iteratee);
	  }

	  function filter(matcher) {
	    return Slides2.filter(isFunction(matcher) ? matcher : function (Slide2) {
	      return isString(matcher) ? matches(Slide2.slide, matcher) : includes(toArray(matcher), Slide2.index);
	    });
	  }

	  function style(prop, value, useContainer) {
	    forEach$1(function (Slide2) {
	      Slide2.style(prop, value, useContainer);
	    });
	  }

	  function observeImages(elm, callback) {
	    var images = queryAll(elm, "img");
	    var length = images.length;

	    if (length) {
	      images.forEach(function (img) {
	        bind(img, "load error", function () {
	          if (! --length) {
	            callback();
	          }
	        });
	      });
	    } else {
	      callback();
	    }
	  }

	  function getLength(excludeClones) {
	    return excludeClones ? slides.length : Slides2.length;
	  }

	  function isEnough() {
	    return Slides2.length > options.perPage;
	  }

	  return {
	    mount: mount,
	    destroy: destroy,
	    update: update,
	    register: register,
	    get: get,
	    getIn: getIn,
	    getAt: getAt,
	    add: add,
	    remove: remove$1,
	    forEach: forEach$1,
	    filter: filter,
	    style: style,
	    getLength: getLength,
	    isEnough: isEnough
	  };
	}

	function Layout(Splide2, Components2, options) {
	  var _EventInterface3 = EventInterface(Splide2),
	      on = _EventInterface3.on,
	      bind = _EventInterface3.bind,
	      emit = _EventInterface3.emit;

	  var Slides = Components2.Slides;
	  var resolve = Components2.Direction.resolve;
	  var _Components2$Elements2 = Components2.Elements,
	      root = _Components2$Elements2.root,
	      track = _Components2$Elements2.track,
	      list = _Components2$Elements2.list;
	  var getAt = Slides.getAt,
	      styleSlides = Slides.style;
	  var vertical;
	  var rootRect;
	  var overflow;

	  function mount() {
	    init();
	    bind(window, "resize load", Throttle(apply(emit, EVENT_RESIZE)));
	    on([EVENT_UPDATED, EVENT_REFRESH], init);
	    on(EVENT_RESIZE, resize);
	  }

	  function init() {
	    vertical = options.direction === TTB;
	    style(root, "maxWidth", unit(options.width));
	    style(track, resolve("paddingLeft"), cssPadding(false));
	    style(track, resolve("paddingRight"), cssPadding(true));
	    resize(true);
	  }

	  function resize(force) {
	    var newRect = rect(root);

	    if (force || rootRect.width !== newRect.width || rootRect.height !== newRect.height) {
	      style(track, "height", cssTrackHeight());
	      styleSlides(resolve("marginRight"), unit(options.gap));
	      styleSlides("width", cssSlideWidth());
	      styleSlides("height", cssSlideHeight(), true);
	      rootRect = newRect;
	      emit(EVENT_RESIZED);

	      if (overflow !== (overflow = isOverflow())) {
	        toggleClass(root, CLASS_OVERFLOW, overflow);
	        emit(EVENT_OVERFLOW, overflow);
	      }
	    }
	  }

	  function cssPadding(right) {
	    var padding = options.padding;
	    var prop = resolve(right ? "right" : "left");
	    return padding && unit(padding[prop] || (isObject(padding) ? 0 : padding)) || "0px";
	  }

	  function cssTrackHeight() {
	    var height = "";

	    if (vertical) {
	      height = cssHeight();
	      assert(height, "height or heightRatio is missing.");
	      height = "calc(" + height + " - " + cssPadding(false) + " - " + cssPadding(true) + ")";
	    }

	    return height;
	  }

	  function cssHeight() {
	    return unit(options.height || rect(list).width * options.heightRatio);
	  }

	  function cssSlideWidth() {
	    return options.autoWidth ? null : unit(options.fixedWidth) || (vertical ? "" : cssSlideSize());
	  }

	  function cssSlideHeight() {
	    return unit(options.fixedHeight) || (vertical ? options.autoHeight ? null : cssSlideSize() : cssHeight());
	  }

	  function cssSlideSize() {
	    var gap = unit(options.gap);
	    return "calc((100%" + (gap && " + " + gap) + ")/" + (options.perPage || 1) + (gap && " - " + gap) + ")";
	  }

	  function listSize() {
	    return rect(list)[resolve("width")];
	  }

	  function slideSize(index, withoutGap) {
	    var Slide = getAt(index || 0);
	    return Slide ? rect(Slide.slide)[resolve("width")] + (withoutGap ? 0 : getGap()) : 0;
	  }

	  function totalSize(index, withoutGap) {
	    var Slide = getAt(index);

	    if (Slide) {
	      var right = rect(Slide.slide)[resolve("right")];
	      var left = rect(list)[resolve("left")];
	      return abs(right - left) + (withoutGap ? 0 : getGap());
	    }

	    return 0;
	  }

	  function sliderSize(withoutGap) {
	    return totalSize(Splide2.length - 1) - totalSize(0) + slideSize(0, withoutGap);
	  }

	  function getGap() {
	    var Slide = getAt(0);
	    return Slide && parseFloat(style(Slide.slide, resolve("marginRight"))) || 0;
	  }

	  function getPadding(right) {
	    return parseFloat(style(track, resolve("padding" + (right ? "Right" : "Left")))) || 0;
	  }

	  function isOverflow() {
	    return Splide2.is(FADE) || sliderSize(true) > listSize();
	  }

	  return {
	    mount: mount,
	    resize: resize,
	    listSize: listSize,
	    slideSize: slideSize,
	    sliderSize: sliderSize,
	    totalSize: totalSize,
	    getPadding: getPadding,
	    isOverflow: isOverflow
	  };
	}

	var MULTIPLIER = 2;

	function Clones(Splide2, Components2, options) {
	  var event = EventInterface(Splide2);
	  var on = event.on;
	  var Elements = Components2.Elements,
	      Slides = Components2.Slides;
	  var resolve = Components2.Direction.resolve;
	  var clones = [];
	  var cloneCount;

	  function mount() {
	    on(EVENT_REFRESH, remount);
	    on([EVENT_UPDATED, EVENT_RESIZE], observe);

	    if (cloneCount = computeCloneCount()) {
	      generate(cloneCount);
	      Components2.Layout.resize(true);
	    }
	  }

	  function remount() {
	    destroy();
	    mount();
	  }

	  function destroy() {
	    remove(clones);
	    empty(clones);
	    event.destroy();
	  }

	  function observe() {
	    var count = computeCloneCount();

	    if (cloneCount !== count) {
	      if (cloneCount < count || !count) {
	        event.emit(EVENT_REFRESH);
	      }
	    }
	  }

	  function generate(count) {
	    var slides = Slides.get().slice();
	    var length = slides.length;

	    if (length) {
	      while (slides.length < count) {
	        push(slides, slides);
	      }

	      push(slides.slice(-count), slides.slice(0, count)).forEach(function (Slide, index) {
	        var isHead = index < count;
	        var clone = cloneDeep(Slide.slide, index);
	        isHead ? before(clone, slides[0].slide) : append(Elements.list, clone);
	        push(clones, clone);
	        Slides.register(clone, index - count + (isHead ? 0 : length), Slide.index);
	      });
	    }
	  }

	  function cloneDeep(elm, index) {
	    var clone = elm.cloneNode(true);
	    addClass(clone, options.classes.clone);
	    clone.id = Splide2.root.id + "-clone" + pad(index + 1);
	    return clone;
	  }

	  function computeCloneCount() {
	    var clones2 = options.clones;

	    if (!Splide2.is(LOOP)) {
	      clones2 = 0;
	    } else if (isUndefined(clones2)) {
	      var fixedSize = options[resolve("fixedWidth")] && Components2.Layout.slideSize(0);
	      var fixedCount = fixedSize && ceil(rect(Elements.track)[resolve("width")] / fixedSize);
	      clones2 = fixedCount || options[resolve("autoWidth")] && Splide2.length || options.perPage * MULTIPLIER;
	    }

	    return clones2;
	  }

	  return {
	    mount: mount,
	    destroy: destroy
	  };
	}

	function Move(Splide2, Components2, options) {
	  var _EventInterface4 = EventInterface(Splide2),
	      on = _EventInterface4.on,
	      emit = _EventInterface4.emit;

	  var set = Splide2.state.set;
	  var _Components2$Layout = Components2.Layout,
	      slideSize = _Components2$Layout.slideSize,
	      getPadding = _Components2$Layout.getPadding,
	      totalSize = _Components2$Layout.totalSize,
	      listSize = _Components2$Layout.listSize,
	      sliderSize = _Components2$Layout.sliderSize;
	  var _Components2$Directio = Components2.Direction,
	      resolve = _Components2$Directio.resolve,
	      orient = _Components2$Directio.orient;
	  var _Components2$Elements3 = Components2.Elements,
	      list = _Components2$Elements3.list,
	      track = _Components2$Elements3.track;
	  var Transition;

	  function mount() {
	    Transition = Components2.Transition;
	    on([EVENT_MOUNTED, EVENT_RESIZED, EVENT_UPDATED, EVENT_REFRESH], reposition);
	  }

	  function reposition() {
	    if (!Components2.Controller.isBusy()) {
	      Components2.Scroll.cancel();
	      jump(Splide2.index);
	      Components2.Slides.update();
	    }
	  }

	  function move(dest, index, prev, callback) {
	    if (dest !== index && canShift(dest > prev)) {
	      cancel();
	      translate(shift(getPosition(), dest > prev), true);
	    }

	    set(MOVING);
	    emit(EVENT_MOVE, index, prev, dest);
	    Transition.start(index, function () {
	      set(IDLE);
	      emit(EVENT_MOVED, index, prev, dest);
	      callback && callback();
	    });
	  }

	  function jump(index) {
	    translate(toPosition(index, true));
	  }

	  function translate(position, preventLoop) {
	    if (!Splide2.is(FADE)) {
	      var destination = preventLoop ? position : loop(position);
	      style(list, "transform", "translate" + resolve("X") + "(" + destination + "px)");
	      position !== destination && emit(EVENT_SHIFTED);
	    }
	  }

	  function loop(position) {
	    if (Splide2.is(LOOP)) {
	      var index = toIndex(position);
	      var exceededMax = index > Components2.Controller.getEnd();
	      var exceededMin = index < 0;

	      if (exceededMin || exceededMax) {
	        position = shift(position, exceededMax);
	      }
	    }

	    return position;
	  }

	  function shift(position, backwards) {
	    var excess = position - getLimit(backwards);
	    var size = sliderSize();
	    position -= orient(size * (ceil(abs(excess) / size) || 1)) * (backwards ? 1 : -1);
	    return position;
	  }

	  function cancel() {
	    translate(getPosition(), true);
	    Transition.cancel();
	  }

	  function toIndex(position) {
	    var Slides = Components2.Slides.get();
	    var index = 0;
	    var minDistance = Infinity;

	    for (var i = 0; i < Slides.length; i++) {
	      var slideIndex = Slides[i].index;
	      var distance = abs(toPosition(slideIndex, true) - position);

	      if (distance <= minDistance) {
	        minDistance = distance;
	        index = slideIndex;
	      } else {
	        break;
	      }
	    }

	    return index;
	  }

	  function toPosition(index, trimming) {
	    var position = orient(totalSize(index - 1) - offset(index));
	    return trimming ? trim(position) : position;
	  }

	  function getPosition() {
	    var left = resolve("left");
	    return rect(list)[left] - rect(track)[left] + orient(getPadding(false));
	  }

	  function trim(position) {
	    if (options.trimSpace && Splide2.is(SLIDE)) {
	      position = clamp(position, 0, orient(sliderSize(true) - listSize()));
	    }

	    return position;
	  }

	  function offset(index) {
	    var focus = options.focus;
	    return focus === "center" ? (listSize() - slideSize(index, true)) / 2 : +focus * slideSize(index) || 0;
	  }

	  function getLimit(max) {
	    return toPosition(max ? Components2.Controller.getEnd() : 0, !!options.trimSpace);
	  }

	  function canShift(backwards) {
	    var shifted = orient(shift(getPosition(), backwards));
	    return backwards ? shifted >= 0 : shifted <= list[resolve("scrollWidth")] - rect(track)[resolve("width")];
	  }

	  function exceededLimit(max, position) {
	    position = isUndefined(position) ? getPosition() : position;
	    var exceededMin = max !== true && orient(position) < orient(getLimit(false));
	    var exceededMax = max !== false && orient(position) > orient(getLimit(true));
	    return exceededMin || exceededMax;
	  }

	  return {
	    mount: mount,
	    move: move,
	    jump: jump,
	    translate: translate,
	    shift: shift,
	    cancel: cancel,
	    toIndex: toIndex,
	    toPosition: toPosition,
	    getPosition: getPosition,
	    getLimit: getLimit,
	    exceededLimit: exceededLimit,
	    reposition: reposition
	  };
	}

	function Controller(Splide2, Components2, options) {
	  var _EventInterface5 = EventInterface(Splide2),
	      on = _EventInterface5.on,
	      emit = _EventInterface5.emit;

	  var Move = Components2.Move;
	  var getPosition = Move.getPosition,
	      getLimit = Move.getLimit,
	      toPosition = Move.toPosition;
	  var _Components2$Slides = Components2.Slides,
	      isEnough = _Components2$Slides.isEnough,
	      getLength = _Components2$Slides.getLength;
	  var omitEnd = options.omitEnd;
	  var isLoop = Splide2.is(LOOP);
	  var isSlide = Splide2.is(SLIDE);
	  var getNext = apply(getAdjacent, false);
	  var getPrev = apply(getAdjacent, true);
	  var currIndex = options.start || 0;
	  var endIndex;
	  var prevIndex = currIndex;
	  var slideCount;
	  var perMove;
	  var perPage;

	  function mount() {
	    init();
	    on([EVENT_UPDATED, EVENT_REFRESH, EVENT_END_INDEX_CHANGED], init);
	    on(EVENT_RESIZED, onResized);
	  }

	  function init() {
	    slideCount = getLength(true);
	    perMove = options.perMove;
	    perPage = options.perPage;
	    endIndex = getEnd();
	    var index = clamp(currIndex, 0, omitEnd ? endIndex : slideCount - 1);

	    if (index !== currIndex) {
	      currIndex = index;
	      Move.reposition();
	    }
	  }

	  function onResized() {
	    if (endIndex !== getEnd()) {
	      emit(EVENT_END_INDEX_CHANGED);
	    }
	  }

	  function go(control, allowSameIndex, callback) {
	    if (!isBusy()) {
	      var dest = parse(control);
	      var index = loop(dest);

	      if (index > -1 && (allowSameIndex || index !== currIndex)) {
	        setIndex(index);
	        Move.move(dest, index, prevIndex, callback);
	      }
	    }
	  }

	  function scroll(destination, duration, snap, callback) {
	    Components2.Scroll.scroll(destination, duration, snap, function () {
	      var index = loop(Move.toIndex(getPosition()));
	      setIndex(omitEnd ? min(index, endIndex) : index);
	      callback && callback();
	    });
	  }

	  function parse(control) {
	    var index = currIndex;

	    if (isString(control)) {
	      var _ref = control.match(/([+\-<>])(\d+)?/) || [],
	          indicator = _ref[1],
	          number = _ref[2];

	      if (indicator === "+" || indicator === "-") {
	        index = computeDestIndex(currIndex + +("" + indicator + (+number || 1)), currIndex);
	      } else if (indicator === ">") {
	        index = number ? toIndex(+number) : getNext(true);
	      } else if (indicator === "<") {
	        index = getPrev(true);
	      }
	    } else {
	      index = isLoop ? control : clamp(control, 0, endIndex);
	    }

	    return index;
	  }

	  function getAdjacent(prev, destination) {
	    var number = perMove || (hasFocus() ? 1 : perPage);
	    var dest = computeDestIndex(currIndex + number * (prev ? -1 : 1), currIndex, !(perMove || hasFocus()));

	    if (dest === -1 && isSlide) {
	      if (!approximatelyEqual(getPosition(), getLimit(!prev), 1)) {
	        return prev ? 0 : endIndex;
	      }
	    }

	    return destination ? dest : loop(dest);
	  }

	  function computeDestIndex(dest, from, snapPage) {
	    if (isEnough() || hasFocus()) {
	      var index = computeMovableDestIndex(dest);

	      if (index !== dest) {
	        from = dest;
	        dest = index;
	        snapPage = false;
	      }

	      if (dest < 0 || dest > endIndex) {
	        if (!perMove && (between(0, dest, from, true) || between(endIndex, from, dest, true))) {
	          dest = toIndex(toPage(dest));
	        } else {
	          if (isLoop) {
	            dest = snapPage ? dest < 0 ? -(slideCount % perPage || perPage) : slideCount : dest;
	          } else if (options.rewind) {
	            dest = dest < 0 ? endIndex : 0;
	          } else {
	            dest = -1;
	          }
	        }
	      } else {
	        if (snapPage && dest !== from) {
	          dest = toIndex(toPage(from) + (dest < from ? -1 : 1));
	        }
	      }
	    } else {
	      dest = -1;
	    }

	    return dest;
	  }

	  function computeMovableDestIndex(dest) {
	    if (isSlide && options.trimSpace === "move" && dest !== currIndex) {
	      var position = getPosition();

	      while (position === toPosition(dest, true) && between(dest, 0, Splide2.length - 1, !options.rewind)) {
	        dest < currIndex ? --dest : ++dest;
	      }
	    }

	    return dest;
	  }

	  function loop(index) {
	    return isLoop ? (index + slideCount) % slideCount || 0 : index;
	  }

	  function getEnd() {
	    var end = slideCount - (hasFocus() || isLoop && perMove ? 1 : perPage);

	    while (omitEnd && end-- > 0) {
	      if (toPosition(slideCount - 1, true) !== toPosition(end, true)) {
	        end++;
	        break;
	      }
	    }

	    return clamp(end, 0, slideCount - 1);
	  }

	  function toIndex(page) {
	    return clamp(hasFocus() ? page : perPage * page, 0, endIndex);
	  }

	  function toPage(index) {
	    return hasFocus() ? min(index, endIndex) : floor((index >= endIndex ? slideCount - 1 : index) / perPage);
	  }

	  function toDest(destination) {
	    var closest = Move.toIndex(destination);
	    return isSlide ? clamp(closest, 0, endIndex) : closest;
	  }

	  function setIndex(index) {
	    if (index !== currIndex) {
	      prevIndex = currIndex;
	      currIndex = index;
	    }
	  }

	  function getIndex(prev) {
	    return prev ? prevIndex : currIndex;
	  }

	  function hasFocus() {
	    return !isUndefined(options.focus) || options.isNavigation;
	  }

	  function isBusy() {
	    return Splide2.state.is([MOVING, SCROLLING]) && !!options.waitForTransition;
	  }

	  return {
	    mount: mount,
	    go: go,
	    scroll: scroll,
	    getNext: getNext,
	    getPrev: getPrev,
	    getAdjacent: getAdjacent,
	    getEnd: getEnd,
	    setIndex: setIndex,
	    getIndex: getIndex,
	    toIndex: toIndex,
	    toPage: toPage,
	    toDest: toDest,
	    hasFocus: hasFocus,
	    isBusy: isBusy
	  };
	}

	var XML_NAME_SPACE = "http://www.w3.org/2000/svg";
	var PATH = "m15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z";
	var SIZE = 40;

	function Arrows(Splide2, Components2, options) {
	  var event = EventInterface(Splide2);
	  var on = event.on,
	      bind = event.bind,
	      emit = event.emit;
	  var classes = options.classes,
	      i18n = options.i18n;
	  var Elements = Components2.Elements,
	      Controller = Components2.Controller;
	  var placeholder = Elements.arrows,
	      track = Elements.track;
	  var wrapper = placeholder;
	  var prev = Elements.prev;
	  var next = Elements.next;
	  var created;
	  var wrapperClasses;
	  var arrows = {};

	  function mount() {
	    init();
	    on(EVENT_UPDATED, remount);
	  }

	  function remount() {
	    destroy();
	    mount();
	  }

	  function init() {
	    var enabled = options.arrows;

	    if (enabled && !(prev && next)) {
	      createArrows();
	    }

	    if (prev && next) {
	      assign(arrows, {
	        prev: prev,
	        next: next
	      });
	      display(wrapper, enabled ? "" : "none");
	      addClass(wrapper, wrapperClasses = CLASS_ARROWS + "--" + options.direction);

	      if (enabled) {
	        listen();
	        update();
	        setAttribute([prev, next], ARIA_CONTROLS, track.id);
	        emit(EVENT_ARROWS_MOUNTED, prev, next);
	      }
	    }
	  }

	  function destroy() {
	    event.destroy();
	    removeClass(wrapper, wrapperClasses);

	    if (created) {
	      remove(placeholder ? [prev, next] : wrapper);
	      prev = next = null;
	    } else {
	      removeAttribute([prev, next], ALL_ATTRIBUTES);
	    }
	  }

	  function listen() {
	    on([EVENT_MOUNTED, EVENT_MOVED, EVENT_REFRESH, EVENT_SCROLLED, EVENT_END_INDEX_CHANGED], update);
	    bind(next, "click", apply(go, ">"));
	    bind(prev, "click", apply(go, "<"));
	  }

	  function go(control) {
	    Controller.go(control, true);
	  }

	  function createArrows() {
	    wrapper = placeholder || create("div", classes.arrows);
	    prev = createArrow(true);
	    next = createArrow(false);
	    created = true;
	    append(wrapper, [prev, next]);
	    !placeholder && before(wrapper, track);
	  }

	  function createArrow(prev2) {
	    var arrow = "<button class=\"" + classes.arrow + " " + (prev2 ? classes.prev : classes.next) + "\" type=\"button\"><svg xmlns=\"" + XML_NAME_SPACE + "\" viewBox=\"0 0 " + SIZE + " " + SIZE + "\" width=\"" + SIZE + "\" height=\"" + SIZE + "\" focusable=\"false\"><path d=\"" + (options.arrowPath || PATH) + "\" />";
	    return parseHtml(arrow);
	  }

	  function update() {
	    if (prev && next) {
	      var index = Splide2.index;
	      var prevIndex = Controller.getPrev();
	      var nextIndex = Controller.getNext();
	      var prevLabel = prevIndex > -1 && index < prevIndex ? i18n.last : i18n.prev;
	      var nextLabel = nextIndex > -1 && index > nextIndex ? i18n.first : i18n.next;
	      prev.disabled = prevIndex < 0;
	      next.disabled = nextIndex < 0;
	      setAttribute(prev, ARIA_LABEL, prevLabel);
	      setAttribute(next, ARIA_LABEL, nextLabel);
	      emit(EVENT_ARROWS_UPDATED, prev, next, prevIndex, nextIndex);
	    }
	  }

	  return {
	    arrows: arrows,
	    mount: mount,
	    destroy: destroy,
	    update: update
	  };
	}

	var INTERVAL_DATA_ATTRIBUTE = DATA_ATTRIBUTE + "-interval";

	function Autoplay(Splide2, Components2, options) {
	  var _EventInterface6 = EventInterface(Splide2),
	      on = _EventInterface6.on,
	      bind = _EventInterface6.bind,
	      emit = _EventInterface6.emit;

	  var interval = RequestInterval(options.interval, Splide2.go.bind(Splide2, ">"), onAnimationFrame);
	  var isPaused = interval.isPaused;
	  var Elements = Components2.Elements,
	      _Components2$Elements4 = Components2.Elements,
	      root = _Components2$Elements4.root,
	      toggle = _Components2$Elements4.toggle;
	  var autoplay = options.autoplay;
	  var hovered;
	  var focused;
	  var stopped = autoplay === "pause";

	  function mount() {
	    if (autoplay) {
	      listen();
	      toggle && setAttribute(toggle, ARIA_CONTROLS, Elements.track.id);
	      stopped || play();
	      update();
	    }
	  }

	  function listen() {
	    if (options.pauseOnHover) {
	      bind(root, "mouseenter mouseleave", function (e) {
	        hovered = e.type === "mouseenter";
	        autoToggle();
	      });
	    }

	    if (options.pauseOnFocus) {
	      bind(root, "focusin focusout", function (e) {
	        focused = e.type === "focusin";
	        autoToggle();
	      });
	    }

	    if (toggle) {
	      bind(toggle, "click", function () {
	        stopped ? play() : pause(true);
	      });
	    }

	    on([EVENT_MOVE, EVENT_SCROLL, EVENT_REFRESH], interval.rewind);
	    on(EVENT_MOVE, onMove);
	  }

	  function play() {
	    if (isPaused() && Components2.Slides.isEnough()) {
	      interval.start(!options.resetProgress);
	      focused = hovered = stopped = false;
	      update();
	      emit(EVENT_AUTOPLAY_PLAY);
	    }
	  }

	  function pause(stop) {
	    if (stop === void 0) {
	      stop = true;
	    }

	    stopped = !!stop;
	    update();

	    if (!isPaused()) {
	      interval.pause();
	      emit(EVENT_AUTOPLAY_PAUSE);
	    }
	  }

	  function autoToggle() {
	    if (!stopped) {
	      hovered || focused ? pause(false) : play();
	    }
	  }

	  function update() {
	    if (toggle) {
	      toggleClass(toggle, CLASS_ACTIVE, !stopped);
	      setAttribute(toggle, ARIA_LABEL, options.i18n[stopped ? "play" : "pause"]);
	    }
	  }

	  function onAnimationFrame(rate) {
	    var bar = Elements.bar;
	    bar && style(bar, "width", rate * 100 + "%");
	    emit(EVENT_AUTOPLAY_PLAYING, rate);
	  }

	  function onMove(index) {
	    var Slide = Components2.Slides.getAt(index);
	    interval.set(Slide && +getAttribute(Slide.slide, INTERVAL_DATA_ATTRIBUTE) || options.interval);
	  }

	  return {
	    mount: mount,
	    destroy: interval.cancel,
	    play: play,
	    pause: pause,
	    isPaused: isPaused
	  };
	}

	function Cover(Splide2, Components2, options) {
	  var _EventInterface7 = EventInterface(Splide2),
	      on = _EventInterface7.on;

	  function mount() {
	    if (options.cover) {
	      on(EVENT_LAZYLOAD_LOADED, apply(toggle, true));
	      on([EVENT_MOUNTED, EVENT_UPDATED, EVENT_REFRESH], apply(cover, true));
	    }
	  }

	  function cover(cover2) {
	    Components2.Slides.forEach(function (Slide) {
	      var img = child(Slide.container || Slide.slide, "img");

	      if (img && img.src) {
	        toggle(cover2, img, Slide);
	      }
	    });
	  }

	  function toggle(cover2, img, Slide) {
	    Slide.style("background", cover2 ? "center/cover no-repeat url(\"" + img.src + "\")" : "", true);
	    display(img, cover2 ? "none" : "");
	  }

	  return {
	    mount: mount,
	    destroy: apply(cover, false)
	  };
	}

	var BOUNCE_DIFF_THRESHOLD = 10;
	var BOUNCE_DURATION = 600;
	var FRICTION_FACTOR = 0.6;
	var BASE_VELOCITY = 1.5;
	var MIN_DURATION = 800;

	function Scroll(Splide2, Components2, options) {
	  var _EventInterface8 = EventInterface(Splide2),
	      on = _EventInterface8.on,
	      emit = _EventInterface8.emit;

	  var set = Splide2.state.set;
	  var Move = Components2.Move;
	  var getPosition = Move.getPosition,
	      getLimit = Move.getLimit,
	      exceededLimit = Move.exceededLimit,
	      translate = Move.translate;
	  var isSlide = Splide2.is(SLIDE);
	  var interval;
	  var callback;
	  var friction = 1;

	  function mount() {
	    on(EVENT_MOVE, clear);
	    on([EVENT_UPDATED, EVENT_REFRESH], cancel);
	  }

	  function scroll(destination, duration, snap, onScrolled, noConstrain) {
	    var from = getPosition();
	    clear();

	    if (snap && (!isSlide || !exceededLimit())) {
	      var size = Components2.Layout.sliderSize();
	      var offset = sign(destination) * size * floor(abs(destination) / size) || 0;
	      destination = Move.toPosition(Components2.Controller.toDest(destination % size)) + offset;
	    }

	    var noDistance = approximatelyEqual(from, destination, 1);
	    friction = 1;
	    duration = noDistance ? 0 : duration || max(abs(destination - from) / BASE_VELOCITY, MIN_DURATION);
	    callback = onScrolled;
	    interval = RequestInterval(duration, onEnd, apply(update, from, destination, noConstrain), 1);
	    set(SCROLLING);
	    emit(EVENT_SCROLL);
	    interval.start();
	  }

	  function onEnd() {
	    set(IDLE);
	    callback && callback();
	    emit(EVENT_SCROLLED);
	  }

	  function update(from, to, noConstrain, rate) {
	    var position = getPosition();
	    var target = from + (to - from) * easing(rate);
	    var diff = (target - position) * friction;
	    translate(position + diff);

	    if (isSlide && !noConstrain && exceededLimit()) {
	      friction *= FRICTION_FACTOR;

	      if (abs(diff) < BOUNCE_DIFF_THRESHOLD) {
	        scroll(getLimit(exceededLimit(true)), BOUNCE_DURATION, false, callback, true);
	      }
	    }
	  }

	  function clear() {
	    if (interval) {
	      interval.cancel();
	    }
	  }

	  function cancel() {
	    if (interval && !interval.isPaused()) {
	      clear();
	      onEnd();
	    }
	  }

	  function easing(t) {
	    var easingFunc = options.easingFunc;
	    return easingFunc ? easingFunc(t) : 1 - Math.pow(1 - t, 4);
	  }

	  return {
	    mount: mount,
	    destroy: clear,
	    scroll: scroll,
	    cancel: cancel
	  };
	}

	var SCROLL_LISTENER_OPTIONS = {
	  passive: false,
	  capture: true
	};

	function Drag(Splide2, Components2, options) {
	  var _EventInterface9 = EventInterface(Splide2),
	      on = _EventInterface9.on,
	      emit = _EventInterface9.emit,
	      bind = _EventInterface9.bind,
	      unbind = _EventInterface9.unbind;

	  var state = Splide2.state;
	  var Move = Components2.Move,
	      Scroll = Components2.Scroll,
	      Controller = Components2.Controller,
	      track = Components2.Elements.track,
	      reduce = Components2.Media.reduce;
	  var _Components2$Directio2 = Components2.Direction,
	      resolve = _Components2$Directio2.resolve,
	      orient = _Components2$Directio2.orient;
	  var getPosition = Move.getPosition,
	      exceededLimit = Move.exceededLimit;
	  var basePosition;
	  var baseEvent;
	  var prevBaseEvent;
	  var isFree;
	  var dragging;
	  var exceeded = false;
	  var clickPrevented;
	  var disabled;
	  var target;

	  function mount() {
	    bind(track, POINTER_MOVE_EVENTS, noop, SCROLL_LISTENER_OPTIONS);
	    bind(track, POINTER_UP_EVENTS, noop, SCROLL_LISTENER_OPTIONS);
	    bind(track, POINTER_DOWN_EVENTS, onPointerDown, SCROLL_LISTENER_OPTIONS);
	    bind(track, "click", onClick, {
	      capture: true
	    });
	    bind(track, "dragstart", prevent);
	    on([EVENT_MOUNTED, EVENT_UPDATED], init);
	  }

	  function init() {
	    var drag = options.drag;
	    disable(!drag);
	    isFree = drag === "free";
	  }

	  function onPointerDown(e) {
	    clickPrevented = false;

	    if (!disabled) {
	      var isTouch = isTouchEvent(e);

	      if (isDraggable(e.target) && (isTouch || !e.button)) {
	        if (!Controller.isBusy()) {
	          target = isTouch ? track : window;
	          dragging = state.is([MOVING, SCROLLING]);
	          prevBaseEvent = null;
	          bind(target, POINTER_MOVE_EVENTS, onPointerMove, SCROLL_LISTENER_OPTIONS);
	          bind(target, POINTER_UP_EVENTS, onPointerUp, SCROLL_LISTENER_OPTIONS);
	          Move.cancel();
	          Scroll.cancel();
	          save(e);
	        } else {
	          prevent(e, true);
	        }
	      }
	    }
	  }

	  function onPointerMove(e) {
	    if (!state.is(DRAGGING)) {
	      state.set(DRAGGING);
	      emit(EVENT_DRAG);
	    }

	    if (e.cancelable) {
	      if (dragging) {
	        Move.translate(basePosition + constrain(diffCoord(e)));
	        var expired = diffTime(e) > LOG_INTERVAL;
	        var hasExceeded = exceeded !== (exceeded = exceededLimit());

	        if (expired || hasExceeded) {
	          save(e);
	        }

	        clickPrevented = true;
	        emit(EVENT_DRAGGING);
	        prevent(e);
	      } else if (isSliderDirection(e)) {
	        dragging = shouldStart(e);
	        prevent(e);
	      }
	    }
	  }

	  function onPointerUp(e) {
	    if (state.is(DRAGGING)) {
	      state.set(IDLE);
	      emit(EVENT_DRAGGED);
	    }

	    if (dragging) {
	      move(e);
	      prevent(e);
	    }

	    unbind(target, POINTER_MOVE_EVENTS, onPointerMove);
	    unbind(target, POINTER_UP_EVENTS, onPointerUp);
	    dragging = false;
	  }

	  function onClick(e) {
	    if (!disabled && clickPrevented) {
	      prevent(e, true);
	    }
	  }

	  function save(e) {
	    prevBaseEvent = baseEvent;
	    baseEvent = e;
	    basePosition = getPosition();
	  }

	  function move(e) {
	    var velocity = computeVelocity(e);
	    var destination = computeDestination(velocity);
	    var rewind = options.rewind && options.rewindByDrag;
	    reduce(false);

	    if (isFree) {
	      Controller.scroll(destination, 0, options.snap);
	    } else if (Splide2.is(FADE)) {
	      Controller.go(orient(sign(velocity)) < 0 ? rewind ? "<" : "-" : rewind ? ">" : "+");
	    } else if (Splide2.is(SLIDE) && exceeded && rewind) {
	      Controller.go(exceededLimit(true) ? ">" : "<");
	    } else {
	      Controller.go(Controller.toDest(destination), true);
	    }

	    reduce(true);
	  }

	  function shouldStart(e) {
	    var thresholds = options.dragMinThreshold;
	    var isObj = isObject(thresholds);
	    var mouse = isObj && thresholds.mouse || 0;
	    var touch = (isObj ? thresholds.touch : +thresholds) || 10;
	    return abs(diffCoord(e)) > (isTouchEvent(e) ? touch : mouse);
	  }

	  function isSliderDirection(e) {
	    return abs(diffCoord(e)) > abs(diffCoord(e, true));
	  }

	  function computeVelocity(e) {
	    if (Splide2.is(LOOP) || !exceeded) {
	      var time = diffTime(e);

	      if (time && time < LOG_INTERVAL) {
	        return diffCoord(e) / time;
	      }
	    }

	    return 0;
	  }

	  function computeDestination(velocity) {
	    return getPosition() + sign(velocity) * min(abs(velocity) * (options.flickPower || 600), isFree ? Infinity : Components2.Layout.listSize() * (options.flickMaxPages || 1));
	  }

	  function diffCoord(e, orthogonal) {
	    return coordOf(e, orthogonal) - coordOf(getBaseEvent(e), orthogonal);
	  }

	  function diffTime(e) {
	    return timeOf(e) - timeOf(getBaseEvent(e));
	  }

	  function getBaseEvent(e) {
	    return baseEvent === e && prevBaseEvent || baseEvent;
	  }

	  function coordOf(e, orthogonal) {
	    return (isTouchEvent(e) ? e.changedTouches[0] : e)["page" + resolve(orthogonal ? "Y" : "X")];
	  }

	  function constrain(diff) {
	    return diff / (exceeded && Splide2.is(SLIDE) ? FRICTION : 1);
	  }

	  function isDraggable(target2) {
	    var noDrag = options.noDrag;
	    return !matches(target2, "." + CLASS_PAGINATION_PAGE + ", ." + CLASS_ARROW) && (!noDrag || !matches(target2, noDrag));
	  }

	  function isTouchEvent(e) {
	    return typeof TouchEvent !== "undefined" && e instanceof TouchEvent;
	  }

	  function isDragging() {
	    return dragging;
	  }

	  function disable(value) {
	    disabled = value;
	  }

	  return {
	    mount: mount,
	    disable: disable,
	    isDragging: isDragging
	  };
	}

	var NORMALIZATION_MAP = {
	  Spacebar: " ",
	  Right: ARROW_RIGHT,
	  Left: ARROW_LEFT,
	  Up: ARROW_UP,
	  Down: ARROW_DOWN
	};

	function normalizeKey(key) {
	  key = isString(key) ? key : key.key;
	  return NORMALIZATION_MAP[key] || key;
	}

	var KEYBOARD_EVENT = "keydown";

	function Keyboard(Splide2, Components2, options) {
	  var _EventInterface10 = EventInterface(Splide2),
	      on = _EventInterface10.on,
	      bind = _EventInterface10.bind,
	      unbind = _EventInterface10.unbind;

	  var root = Splide2.root;
	  var resolve = Components2.Direction.resolve;
	  var target;
	  var disabled;

	  function mount() {
	    init();
	    on(EVENT_UPDATED, destroy);
	    on(EVENT_UPDATED, init);
	    on(EVENT_MOVE, onMove);
	  }

	  function init() {
	    var keyboard = options.keyboard;

	    if (keyboard) {
	      target = keyboard === "global" ? window : root;
	      bind(target, KEYBOARD_EVENT, onKeydown);
	    }
	  }

	  function destroy() {
	    unbind(target, KEYBOARD_EVENT);
	  }

	  function disable(value) {
	    disabled = value;
	  }

	  function onMove() {
	    var _disabled = disabled;
	    disabled = true;
	    nextTick(function () {
	      disabled = _disabled;
	    });
	  }

	  function onKeydown(e) {
	    if (!disabled) {
	      var key = normalizeKey(e);

	      if (key === resolve(ARROW_LEFT)) {
	        Splide2.go("<");
	      } else if (key === resolve(ARROW_RIGHT)) {
	        Splide2.go(">");
	      }
	    }
	  }

	  return {
	    mount: mount,
	    destroy: destroy,
	    disable: disable
	  };
	}

	var SRC_DATA_ATTRIBUTE = DATA_ATTRIBUTE + "-lazy";
	var SRCSET_DATA_ATTRIBUTE = SRC_DATA_ATTRIBUTE + "-srcset";
	var IMAGE_SELECTOR = "[" + SRC_DATA_ATTRIBUTE + "], [" + SRCSET_DATA_ATTRIBUTE + "]";

	function LazyLoad(Splide2, Components2, options) {
	  var _EventInterface11 = EventInterface(Splide2),
	      on = _EventInterface11.on,
	      off = _EventInterface11.off,
	      bind = _EventInterface11.bind,
	      emit = _EventInterface11.emit;

	  var isSequential = options.lazyLoad === "sequential";
	  var events = [EVENT_MOVED, EVENT_SCROLLED];
	  var entries = [];

	  function mount() {
	    if (options.lazyLoad) {
	      init();
	      on(EVENT_REFRESH, init);
	    }
	  }

	  function init() {
	    empty(entries);
	    register();

	    if (isSequential) {
	      loadNext();
	    } else {
	      off(events);
	      on(events, check);
	      check();
	    }
	  }

	  function register() {
	    Components2.Slides.forEach(function (Slide) {
	      queryAll(Slide.slide, IMAGE_SELECTOR).forEach(function (img) {
	        var src = getAttribute(img, SRC_DATA_ATTRIBUTE);
	        var srcset = getAttribute(img, SRCSET_DATA_ATTRIBUTE);

	        if (src !== img.src || srcset !== img.srcset) {
	          var className = options.classes.spinner;
	          var parent = img.parentElement;
	          var spinner = child(parent, "." + className) || create("span", className, parent);
	          entries.push([img, Slide, spinner]);
	          img.src || display(img, "none");
	        }
	      });
	    });
	  }

	  function check() {
	    entries = entries.filter(function (data) {
	      var distance = options.perPage * ((options.preloadPages || 1) + 1) - 1;
	      return data[1].isWithin(Splide2.index, distance) ? load(data) : true;
	    });
	    entries.length || off(events);
	  }

	  function load(data) {
	    var img = data[0];
	    addClass(data[1].slide, CLASS_LOADING);
	    bind(img, "load error", apply(onLoad, data));
	    setAttribute(img, "src", getAttribute(img, SRC_DATA_ATTRIBUTE));
	    setAttribute(img, "srcset", getAttribute(img, SRCSET_DATA_ATTRIBUTE));
	    removeAttribute(img, SRC_DATA_ATTRIBUTE);
	    removeAttribute(img, SRCSET_DATA_ATTRIBUTE);
	  }

	  function onLoad(data, e) {
	    var img = data[0],
	        Slide = data[1];
	    removeClass(Slide.slide, CLASS_LOADING);

	    if (e.type !== "error") {
	      remove(data[2]);
	      display(img, "");
	      emit(EVENT_LAZYLOAD_LOADED, img, Slide);
	      emit(EVENT_RESIZE);
	    }

	    isSequential && loadNext();
	  }

	  function loadNext() {
	    entries.length && load(entries.shift());
	  }

	  return {
	    mount: mount,
	    destroy: apply(empty, entries),
	    check: check
	  };
	}

	function Pagination(Splide2, Components2, options) {
	  var event = EventInterface(Splide2);
	  var on = event.on,
	      emit = event.emit,
	      bind = event.bind;
	  var Slides = Components2.Slides,
	      Elements = Components2.Elements,
	      Controller = Components2.Controller;
	  var hasFocus = Controller.hasFocus,
	      getIndex = Controller.getIndex,
	      go = Controller.go;
	  var resolve = Components2.Direction.resolve;
	  var placeholder = Elements.pagination;
	  var items = [];
	  var list;
	  var paginationClasses;

	  function mount() {
	    destroy();
	    on([EVENT_UPDATED, EVENT_REFRESH, EVENT_END_INDEX_CHANGED], mount);
	    var enabled = options.pagination;
	    placeholder && display(placeholder, enabled ? "" : "none");

	    if (enabled) {
	      on([EVENT_MOVE, EVENT_SCROLL, EVENT_SCROLLED], update);
	      createPagination();
	      update();
	      emit(EVENT_PAGINATION_MOUNTED, {
	        list: list,
	        items: items
	      }, getAt(Splide2.index));
	    }
	  }

	  function destroy() {
	    if (list) {
	      remove(placeholder ? slice(list.children) : list);
	      removeClass(list, paginationClasses);
	      empty(items);
	      list = null;
	    }

	    event.destroy();
	  }

	  function createPagination() {
	    var length = Splide2.length;
	    var classes = options.classes,
	        i18n = options.i18n,
	        perPage = options.perPage;
	    var max = hasFocus() ? Controller.getEnd() + 1 : ceil(length / perPage);
	    list = placeholder || create("ul", classes.pagination, Elements.track.parentElement);
	    addClass(list, paginationClasses = CLASS_PAGINATION + "--" + getDirection());
	    setAttribute(list, ROLE, "tablist");
	    setAttribute(list, ARIA_LABEL, i18n.select);
	    setAttribute(list, ARIA_ORIENTATION, getDirection() === TTB ? "vertical" : "");

	    for (var i = 0; i < max; i++) {
	      var li = create("li", null, list);
	      var button = create("button", {
	        class: classes.page,
	        type: "button"
	      }, li);
	      var controls = Slides.getIn(i).map(function (Slide) {
	        return Slide.slide.id;
	      });
	      var text = !hasFocus() && perPage > 1 ? i18n.pageX : i18n.slideX;
	      bind(button, "click", apply(onClick, i));

	      if (options.paginationKeyboard) {
	        bind(button, "keydown", apply(onKeydown, i));
	      }

	      setAttribute(li, ROLE, "presentation");
	      setAttribute(button, ROLE, "tab");
	      setAttribute(button, ARIA_CONTROLS, controls.join(" "));
	      setAttribute(button, ARIA_LABEL, format(text, i + 1));
	      setAttribute(button, TAB_INDEX, -1);
	      items.push({
	        li: li,
	        button: button,
	        page: i
	      });
	    }
	  }

	  function onClick(page) {
	    go(">" + page, true);
	  }

	  function onKeydown(page, e) {
	    var length = items.length;
	    var key = normalizeKey(e);
	    var dir = getDirection();
	    var nextPage = -1;

	    if (key === resolve(ARROW_RIGHT, false, dir)) {
	      nextPage = ++page % length;
	    } else if (key === resolve(ARROW_LEFT, false, dir)) {
	      nextPage = (--page + length) % length;
	    } else if (key === "Home") {
	      nextPage = 0;
	    } else if (key === "End") {
	      nextPage = length - 1;
	    }

	    var item = items[nextPage];

	    if (item) {
	      focus(item.button);
	      go(">" + nextPage);
	      prevent(e, true);
	    }
	  }

	  function getDirection() {
	    return options.paginationDirection || options.direction;
	  }

	  function getAt(index) {
	    return items[Controller.toPage(index)];
	  }

	  function update() {
	    var prev = getAt(getIndex(true));
	    var curr = getAt(getIndex());

	    if (prev) {
	      var button = prev.button;
	      removeClass(button, CLASS_ACTIVE);
	      removeAttribute(button, ARIA_SELECTED);
	      setAttribute(button, TAB_INDEX, -1);
	    }

	    if (curr) {
	      var _button = curr.button;
	      addClass(_button, CLASS_ACTIVE);
	      setAttribute(_button, ARIA_SELECTED, true);
	      setAttribute(_button, TAB_INDEX, "");
	    }

	    emit(EVENT_PAGINATION_UPDATED, {
	      list: list,
	      items: items
	    }, prev, curr);
	  }

	  return {
	    items: items,
	    mount: mount,
	    destroy: destroy,
	    getAt: getAt,
	    update: update
	  };
	}

	var TRIGGER_KEYS = [" ", "Enter"];

	function Sync(Splide2, Components2, options) {
	  var isNavigation = options.isNavigation,
	      slideFocus = options.slideFocus;
	  var events = [];

	  function mount() {
	    Splide2.splides.forEach(function (target) {
	      if (!target.isParent) {
	        sync(Splide2, target.splide);
	        sync(target.splide, Splide2);
	      }
	    });

	    if (isNavigation) {
	      navigate();
	    }
	  }

	  function destroy() {
	    events.forEach(function (event) {
	      event.destroy();
	    });
	    empty(events);
	  }

	  function remount() {
	    destroy();
	    mount();
	  }

	  function sync(splide, target) {
	    var event = EventInterface(splide);
	    event.on(EVENT_MOVE, function (index, prev, dest) {
	      target.go(target.is(LOOP) ? dest : index);
	    });
	    events.push(event);
	  }

	  function navigate() {
	    var event = EventInterface(Splide2);
	    var on = event.on;
	    on(EVENT_CLICK, onClick);
	    on(EVENT_SLIDE_KEYDOWN, onKeydown);
	    on([EVENT_MOUNTED, EVENT_UPDATED], update);
	    events.push(event);
	    event.emit(EVENT_NAVIGATION_MOUNTED, Splide2.splides);
	  }

	  function update() {
	    setAttribute(Components2.Elements.list, ARIA_ORIENTATION, options.direction === TTB ? "vertical" : "");
	  }

	  function onClick(Slide) {
	    Splide2.go(Slide.index);
	  }

	  function onKeydown(Slide, e) {
	    if (includes(TRIGGER_KEYS, normalizeKey(e))) {
	      onClick(Slide);
	      prevent(e);
	    }
	  }

	  return {
	    setup: apply(Components2.Media.set, {
	      slideFocus: isUndefined(slideFocus) ? isNavigation : slideFocus
	    }, true),
	    mount: mount,
	    destroy: destroy,
	    remount: remount
	  };
	}

	function Wheel(Splide2, Components2, options) {
	  var _EventInterface12 = EventInterface(Splide2),
	      bind = _EventInterface12.bind;

	  var lastTime = 0;

	  function mount() {
	    if (options.wheel) {
	      bind(Components2.Elements.track, "wheel", onWheel, SCROLL_LISTENER_OPTIONS);
	    }
	  }

	  function onWheel(e) {
	    if (e.cancelable) {
	      var deltaY = e.deltaY;
	      var backwards = deltaY < 0;
	      var timeStamp = timeOf(e);

	      var _min = options.wheelMinThreshold || 0;

	      var sleep = options.wheelSleep || 0;

	      if (abs(deltaY) > _min && timeStamp - lastTime > sleep) {
	        Splide2.go(backwards ? "<" : ">");
	        lastTime = timeStamp;
	      }

	      shouldPrevent(backwards) && prevent(e);
	    }
	  }

	  function shouldPrevent(backwards) {
	    return !options.releaseWheel || Splide2.state.is(MOVING) || Components2.Controller.getAdjacent(backwards) !== -1;
	  }

	  return {
	    mount: mount
	  };
	}

	var SR_REMOVAL_DELAY = 90;

	function Live(Splide2, Components2, options) {
	  var _EventInterface13 = EventInterface(Splide2),
	      on = _EventInterface13.on;

	  var track = Components2.Elements.track;
	  var enabled = options.live && !options.isNavigation;
	  var sr = create("span", CLASS_SR);
	  var interval = RequestInterval(SR_REMOVAL_DELAY, apply(toggle, false));

	  function mount() {
	    if (enabled) {
	      disable(!Components2.Autoplay.isPaused());
	      setAttribute(track, ARIA_ATOMIC, true);
	      sr.textContent = "\u2026";
	      on(EVENT_AUTOPLAY_PLAY, apply(disable, true));
	      on(EVENT_AUTOPLAY_PAUSE, apply(disable, false));
	      on([EVENT_MOVED, EVENT_SCROLLED], apply(toggle, true));
	    }
	  }

	  function toggle(active) {
	    setAttribute(track, ARIA_BUSY, active);

	    if (active) {
	      append(track, sr);
	      interval.start();
	    } else {
	      remove(sr);
	      interval.cancel();
	    }
	  }

	  function destroy() {
	    removeAttribute(track, [ARIA_LIVE, ARIA_ATOMIC, ARIA_BUSY]);
	    remove(sr);
	  }

	  function disable(disabled) {
	    if (enabled) {
	      setAttribute(track, ARIA_LIVE, disabled ? "off" : "polite");
	    }
	  }

	  return {
	    mount: mount,
	    disable: disable,
	    destroy: destroy
	  };
	}

	var ComponentConstructors = /*#__PURE__*/Object.freeze({
	  __proto__: null,
	  Media: Media,
	  Direction: Direction,
	  Elements: Elements,
	  Slides: Slides,
	  Layout: Layout,
	  Clones: Clones,
	  Move: Move,
	  Controller: Controller,
	  Arrows: Arrows,
	  Autoplay: Autoplay,
	  Cover: Cover,
	  Scroll: Scroll,
	  Drag: Drag,
	  Keyboard: Keyboard,
	  LazyLoad: LazyLoad,
	  Pagination: Pagination,
	  Sync: Sync,
	  Wheel: Wheel,
	  Live: Live
	});
	var I18N = {
	  prev: "Previous slide",
	  next: "Next slide",
	  first: "Go to first slide",
	  last: "Go to last slide",
	  slideX: "Go to slide %s",
	  pageX: "Go to page %s",
	  play: "Start autoplay",
	  pause: "Pause autoplay",
	  carousel: "carousel",
	  slide: "slide",
	  select: "Select a slide to show",
	  slideLabel: "%s of %s"
	};
	var DEFAULTS = {
	  type: "slide",
	  role: "region",
	  speed: 400,
	  perPage: 1,
	  cloneStatus: true,
	  arrows: true,
	  pagination: true,
	  paginationKeyboard: true,
	  interval: 5e3,
	  pauseOnHover: true,
	  pauseOnFocus: true,
	  resetProgress: true,
	  easing: "cubic-bezier(0.25, 1, 0.5, 1)",
	  drag: true,
	  direction: "ltr",
	  trimSpace: true,
	  focusableNodes: "a, button, textarea, input, select, iframe",
	  live: true,
	  classes: CLASSES,
	  i18n: I18N,
	  reducedMotion: {
	    speed: 0,
	    rewindSpeed: 0,
	    autoplay: "pause"
	  }
	};

	function Fade(Splide2, Components2, options) {
	  var Slides = Components2.Slides;

	  function mount() {
	    EventInterface(Splide2).on([EVENT_MOUNTED, EVENT_REFRESH], init);
	  }

	  function init() {
	    Slides.forEach(function (Slide) {
	      Slide.style("transform", "translateX(-" + 100 * Slide.index + "%)");
	    });
	  }

	  function start(index, done) {
	    Slides.style("transition", "opacity " + options.speed + "ms " + options.easing);
	    nextTick(done);
	  }

	  return {
	    mount: mount,
	    start: start,
	    cancel: noop
	  };
	}

	function Slide(Splide2, Components2, options) {
	  var Move = Components2.Move,
	      Controller = Components2.Controller,
	      Scroll = Components2.Scroll;
	  var list = Components2.Elements.list;
	  var transition = apply(style, list, "transition");
	  var endCallback;

	  function mount() {
	    EventInterface(Splide2).bind(list, "transitionend", function (e) {
	      if (e.target === list && endCallback) {
	        cancel();
	        endCallback();
	      }
	    });
	  }

	  function start(index, done) {
	    var destination = Move.toPosition(index, true);
	    var position = Move.getPosition();
	    var speed = getSpeed(index);

	    if (abs(destination - position) >= 1 && speed >= 1) {
	      if (options.useScroll) {
	        Scroll.scroll(destination, speed, false, done);
	      } else {
	        transition("transform " + speed + "ms " + options.easing);
	        Move.translate(destination, true);
	        endCallback = done;
	      }
	    } else {
	      Move.jump(index);
	      done();
	    }
	  }

	  function cancel() {
	    transition("");
	    Scroll.cancel();
	  }

	  function getSpeed(index) {
	    var rewindSpeed = options.rewindSpeed;

	    if (Splide2.is(SLIDE) && rewindSpeed) {
	      var prev = Controller.getIndex(true);
	      var end = Controller.getEnd();

	      if (prev === 0 && index >= end || prev >= end && index === 0) {
	        return rewindSpeed;
	      }
	    }

	    return options.speed;
	  }

	  return {
	    mount: mount,
	    start: start,
	    cancel: cancel
	  };
	}

	var _Splide = /*#__PURE__*/function () {
	  function _Splide(target, options) {
	    this.event = EventInterface();
	    this.Components = {};
	    this.state = State(CREATED);
	    this.splides = [];
	    this._o = {};
	    this._E = {};
	    var root = isString(target) ? query(document, target) : target;
	    assert(root, root + " is invalid.");
	    this.root = root;
	    options = merge({
	      label: getAttribute(root, ARIA_LABEL) || "",
	      labelledby: getAttribute(root, ARIA_LABELLEDBY) || ""
	    }, DEFAULTS, _Splide.defaults, options || {});

	    try {
	      merge(options, JSON.parse(getAttribute(root, DATA_ATTRIBUTE)));
	    } catch (e) {
	      assert(false, "Invalid JSON");
	    }

	    this._o = Object.create(merge({}, options));
	  }

	  var _proto = _Splide.prototype;

	  _proto.mount = function mount(Extensions, Transition) {
	    var _this = this;

	    var state = this.state,
	        Components2 = this.Components;
	    assert(state.is([CREATED, DESTROYED]), "Already mounted!");
	    state.set(CREATED);
	    this._C = Components2;
	    this._T = Transition || this._T || (this.is(FADE) ? Fade : Slide);
	    this._E = Extensions || this._E;
	    var Constructors = assign({}, ComponentConstructors, this._E, {
	      Transition: this._T
	    });
	    forOwn(Constructors, function (Component, key) {
	      var component = Component(_this, Components2, _this._o);
	      Components2[key] = component;
	      component.setup && component.setup();
	    });
	    forOwn(Components2, function (component) {
	      component.mount && component.mount();
	    });
	    this.emit(EVENT_MOUNTED);
	    addClass(this.root, CLASS_INITIALIZED);
	    state.set(IDLE);
	    this.emit(EVENT_READY);
	    return this;
	  };

	  _proto.sync = function sync(splide) {
	    this.splides.push({
	      splide: splide
	    });
	    splide.splides.push({
	      splide: this,
	      isParent: true
	    });

	    if (this.state.is(IDLE)) {
	      this._C.Sync.remount();

	      splide.Components.Sync.remount();
	    }

	    return this;
	  };

	  _proto.go = function go(control) {
	    this._C.Controller.go(control);

	    return this;
	  };

	  _proto.on = function on(events, callback) {
	    this.event.on(events, callback);
	    return this;
	  };

	  _proto.off = function off(events) {
	    this.event.off(events);
	    return this;
	  };

	  _proto.emit = function emit(event) {
	    var _this$event;

	    (_this$event = this.event).emit.apply(_this$event, [event].concat(slice(arguments, 1)));

	    return this;
	  };

	  _proto.add = function add(slides, index) {
	    this._C.Slides.add(slides, index);

	    return this;
	  };

	  _proto.remove = function remove(matcher) {
	    this._C.Slides.remove(matcher);

	    return this;
	  };

	  _proto.is = function is(type) {
	    return this._o.type === type;
	  };

	  _proto.refresh = function refresh() {
	    this.emit(EVENT_REFRESH);
	    return this;
	  };

	  _proto.destroy = function destroy(completely) {
	    if (completely === void 0) {
	      completely = true;
	    }

	    var event = this.event,
	        state = this.state;

	    if (state.is(CREATED)) {
	      EventInterface(this).on(EVENT_READY, this.destroy.bind(this, completely));
	    } else {
	      forOwn(this._C, function (component) {
	        component.destroy && component.destroy(completely);
	      }, true);
	      event.emit(EVENT_DESTROY);
	      event.destroy();
	      completely && empty(this.splides);
	      state.set(DESTROYED);
	    }

	    return this;
	  };

	  _createClass(_Splide, [{
	    key: "options",
	    get: function get() {
	      return this._o;
	    },
	    set: function set(options) {
	      this._C.Media.set(options, true, true);
	    }
	  }, {
	    key: "length",
	    get: function get() {
	      return this._C.Slides.getLength(true);
	    }
	  }, {
	    key: "index",
	    get: function get() {
	      return this._C.Controller.getIndex();
	    }
	  }]);

	  return _Splide;
	}();

	var Splide = _Splide;
	Splide.defaults = {};
	Splide.STATES = STATES;

	const cssVariablePrevNextFilter = '--p-carousel-prev-next-filter';
	const cssVariableGradientColorWidth = '--p-gradient-color-width';
	const carouselTransitionDuration = validateProps.motionDurationModerate;
	const paginationInfiniteStartCaseClass = 'pagination--infinite';
	const bulletClass = 'bullet';
	const bulletActiveClass = 'bullet--active';
	const bulletInfiniteClass = 'bullet--infinite';
	const paginationVisibleBulletCount = 5;
	const paginationBulletSize = '8px';
	const paginationInfiniteBulletSize = '4px';
	const paginationActiveBulletSize = '20px';
	const paginationGap = '8px';
	const paginationWidth = `calc(${paginationActiveBulletSize} + ${paginationBulletSize} * ${paginationVisibleBulletCount - 1} + ${paginationGap} * ${paginationVisibleBulletCount - 1})`; // Width for one active bullet + width of inactive bullets + spacing
	const paginationInset = '8px'; // Used to increase clickable area on touch devices
	const paginationGapLarge = '16px';
	const paginationWidthLarge = `calc(${paginationActiveBulletSize} + ${paginationBulletSize} * ${paginationVisibleBulletCount - 1} + ${paginationGapLarge} * ${paginationVisibleBulletCount - 1} + 2 * ${paginationInset})`; // Width for one active bullet + width of inactive bullets + spacing
	const selectorHeading = '.heading';
	const selectorDescription = 'p,::slotted([slot="description"])';
	const mediaQueryS = validateProps.getMediaQueryMin('s');
	const mediaQueryXXL = validateProps.getMediaQueryMin('xxl');
	const mediaQueryPointerCoarse = '@media (pointer: coarse)';
	const spacingMap = {
	    basic: gridBasicOffset.gridBasicOffset,
	    extended: gridBasicOffset.gridExtendedOffset,
	};
	const backfaceVisibilityJssStyle = {
	    backfaceVisibility: 'hidden',
	    WebkitBackfaceVisibility: 'hidden',
	};
	const gradientColorLight = {
	    'background-base': '255,255,255',
	    'background-surface': '238,239,242',
	    none: '',
	};
	const gradientColorDark = {
	    'background-base': '14,14,18',
	    'background-surface': '33,34,37',
	    none: '',
	};
	const gradientColorMap = {
	    auto: gradientColorLight,
	    light: gradientColorLight,
	    dark: gradientColorDark,
	};
	const getGradient = (theme, gradientColorTheme) => {
	    const gradientColor = gradientColorMap[theme][gradientColorTheme];
	    return (`rgba(${gradientColor},1) 20%,` +
	        `rgba(${gradientColor},0.6) 48%,` +
	        `rgba(${gradientColor},0.3) 68%,` +
	        `rgba(${gradientColor},0)`);
	};
	const getComponentCss = (gradientColor, hasHeading, hasDescription, hasControlsSlot, headingSize, width, hasPagination, isInfinitePagination, alignHeader, theme, hasNavigation, alignControls) => {
	    const { primaryColor, contrastMediumColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, contrastMediumColor: contrastMediumColorDark } = validateProps.getThemedColors('dark');
	    const { canvasTextColor } = validateProps.getHighContrastColors();
	    const isHeaderAlignCenter = alignHeader === 'center';
	    const getGradientStyles = (direction) => gradientColor
	        ? {
	            [direction === 'left' ? 'right' : 'left']: 0,
	            background: `linear-gradient(to ${direction}, ${getGradient(theme, gradientColor)} 100%)`,
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                background: `linear-gradient(to ${direction}, ${getGradient('dark', gradientColor)} 100%)`,
	            }),
	        }
	        : {};
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'flex',
	                ...validateProps.addImportantToEachRule({
	                    gap: spacingFluidMedium.spacingFluidMedium, // TODO: maybe it's better to style by margin on .splide, then styles would be part of shadow dom
	                    flexDirection: 'column',
	                    boxSizing: 'content-box', // ensures padding is added to host instead of subtracted
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            ...(hasControlsSlot && {
	                'slot[name="controls"]': {
	                    display: 'block',
	                    gridColumn: '1/-1',
	                    gridRowStart: 3,
	                    alignSelf: 'center', // ensures vertical alignment to prev/next buttons
	                    justifySelf: alignControls !== 'auto' ? alignControls : isHeaderAlignCenter ? 'center' : 'start',
	                    [mediaQueryS]: {
	                        gridColumn: alignControls !== 'center' && hasNavigation ? '1/2' : '1/-1',
	                        justifySelf: alignControls !== 'auto' ? alignControls : isHeaderAlignCenter && !hasNavigation ? 'center' : 'start',
	                    },
	                },
	            }),
	            ...validateProps.addImportantToEachRule({
	                '::slotted': {
	                    '&(*)': {
	                        borderRadius: `var(--p-carousel-border-radius, ${borderRadiusLarge.borderRadiusLarge})`,
	                    },
	                },
	                // TODO: maybe it's better to style with slot[name="heading"] and slot[name="description"] instead, then styles would be part of shadow dom
	                // .heading,p,::slotted([slot=description])
	                ...((hasHeading || hasDescription) && {
	                    [`${selectorHeading},${selectorDescription}`]: {
	                        gridColumn: '1/-1',
	                        color: primaryColor,
	                        ...(isHeaderAlignCenter && {
	                            textAlign: 'center', // relevant in case heading or description becomes multiline
	                            justifySelf: 'center', // relevant for horizontal alignment of heading and description in case max-width applies
	                        }),
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            color: primaryColorDark,
	                        }),
	                    },
	                }),
	                ...(hasHeading && {
	                    [selectorHeading]: {
	                        maxWidth: '56.25rem',
	                        margin: `0 0 ${hasDescription ? 0 : spacingFluidMedium.spacingFluidMedium}`,
	                        ...(headingSize === 'xx-large' ? headingXXLargeStyle.headingXXLargeStyle : headingXLargeStyle),
	                    },
	                    '::slotted([slot=heading])': {
	                        margin: 0, // reset ua-style
	                        ...(headingSize === 'xx-large' ? headingXXLargeStyle.headingXXLargeStyle : headingXLargeStyle),
	                    },
	                }),
	                // p,::slotted([slot=description])
	                ...(hasDescription && {
	                    [selectorDescription]: {
	                        maxWidth: '34.375rem',
	                        margin: `${spacingFluidSmall.spacingFluidSmall} 0 ${spacingFluidMedium.spacingFluidMedium}`,
	                        ...textSmallStyle.textSmallStyle,
	                    },
	                }),
	            }),
	        },
	        header: {
	            display: 'grid',
	            padding: `0 ${spacingMap[width].base}`,
	            [mediaQueryS]: {
	                gridTemplateColumns: 'minmax(0px, 1fr) auto',
	                padding: `0 ${spacingMap[width].s}`,
	                ...(hasNavigation && { columnGap: spacingStaticMedium.spacingStaticMedium }),
	            },
	            [mediaQueryXXL]: {
	                padding: `0 ${spacingMap[width].xxl}`,
	            },
	        },
	        nav: {
	            display: 'none',
	            [mediaQueryS]: {
	                gridRowStart: '3',
	                gridColumnEnd: '-1',
	                display: 'flex',
	                gap: spacingStaticXSmall.spacingStaticXSmall,
	                alignSelf: 'flex-start', // relevant in case slot="header" becomes higher than nav group
	            },
	            filter: `var(${cssVariablePrevNextFilter}, none)`,
	        },
	        btn: {
	            padding: spacingStaticSmall.spacingStaticSmall,
	        },
	        'skip-link': {
	            // :focus must be used in this case, because :focus-visible is just matched on the focusable element itself, not on the host element.
	            '&:not(:focus)': {
	                opacity: 0,
	                pointerEvents: 'none',
	            },
	        },
	        splide: {
	            overflow: 'hidden',
	            padding: '4px 0', // for slide focus outline
	            margin: '-4px 0', // for slide focus outline
	            '&__track': {
	                position: 'relative',
	                // !important is necessary to override inline styles set by splide library
	                ...validateProps.addImportantToEachRule({
	                    padding: `0 ${spacingMap[width].base}`,
	                    [mediaQueryS]: {
	                        padding: `0 ${spacingMap[width].s}`,
	                    },
	                    [mediaQueryXXL]: {
	                        padding: `0 ${spacingMap[width].xxl}`,
	                    },
	                }),
	                '&--draggable': {
	                    cursor: 'grab',
	                    userSelect: 'none',
	                    WebkitUserSelect: 'none',
	                    WebkitTouchCallout: 'none',
	                },
	                ...(gradientColor &&
	                    gradientColor !== 'none' && {
	                    '&::before, &::after': {
	                        content: '""',
	                        position: 'absolute',
	                        zIndex: 1,
	                        top: 0,
	                        height: '100%',
	                        width: `var(${cssVariableGradientColorWidth}, 33%)`,
	                    },
	                    '&::before': getGradientStyles('right'),
	                    '&::after': getGradientStyles('left'),
	                }),
	            },
	            '&__list': {
	                ...backfaceVisibilityJssStyle,
	                display: 'flex',
	            },
	            '&__slide': {
	                ...backfaceVisibilityJssStyle,
	                flexShrink: 0,
	                transform: 'translateZ(0)', // fixes mobile safari flickering, https://github.com/nolimits4web/swiper/issues/3527#issuecomment-609088939
	                borderRadius: `var(--p-carousel-border-radius, ${borderRadiusLarge.borderRadiusLarge})`,
	                ...validateProps.getFocusJssStyle(theme),
	            },
	            '&__sr': validateProps.getHiddenTextJssStyle(), // appears in the DOM when sliding
	            ...(isHeaderAlignCenter && {
	                '&:not(.is-overflow) .splide__list': {
	                    justifyContent: 'center',
	                },
	                '&:not(.is-overflow) .splide__slide:last-child': {
	                    marginInlineEnd: validateProps.addImportantToRule('0'),
	                },
	            }),
	        },
	        ...(hasPagination && {
	            'pagination-container': {
	                ...validateProps.buildResponsiveStyles(hasPagination, (hasPaginationValue) => ({
	                    display: hasPaginationValue ? 'flex' : 'none',
	                })),
	                position: 'relative',
	                justifyContent: isInfinitePagination ? 'flex-start' : 'center',
	                width: paginationWidth,
	                left: `calc(50% - (${paginationWidth}) / 2)`,
	                [mediaQueryPointerCoarse]: {
	                    width: paginationWidthLarge,
	                    left: `calc(50% - ${paginationWidthLarge} / 2)`,
	                },
	                overflowX: 'hidden',
	            },
	            pagination: {
	                display: 'flex',
	                alignItems: 'center',
	                width: 'fit-content',
	                height: paginationBulletSize, // Needed to avoid jumping when rewinding dynamically added slides
	                gap: paginationGap,
	                [mediaQueryPointerCoarse]: {
	                    height: `calc(${paginationBulletSize} + 2 * ${paginationInset})`,
	                    gap: paginationGapLarge,
	                },
	                transition: `transform ${carouselTransitionDuration}`,
	            },
	            [bulletClass]: {
	                // Increase clickable area on touch devices
	                [mediaQueryPointerCoarse]: {
	                    '&::before': {
	                        content: '""',
	                        position: 'absolute',
	                        inset: `-${paginationInset}`,
	                    },
	                    position: 'relative',
	                },
	                borderRadius: borderRadiusSmall.borderRadiusSmall,
	                ...(validateProps.isHighContrastMode
	                    ? {
	                        background: canvasTextColor,
	                    }
	                    : {
	                        background: contrastMediumColor,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            background: contrastMediumColorDark,
	                        }),
	                    }),
	                ...(isInfinitePagination
	                    ? {
	                        width: '0px',
	                        height: '0px',
	                        transition: `background-color ${carouselTransitionDuration}, width ${carouselTransitionDuration}, height ${carouselTransitionDuration}`,
	                    }
	                    : {
	                        width: paginationBulletSize,
	                        height: paginationBulletSize,
	                        transition: `background-color ${carouselTransitionDuration}, width ${carouselTransitionDuration}`,
	                    }),
	                ...hoverMediaQuery.hoverMediaQuery({
	                    cursor: 'pointer',
	                }),
	            },
	            ...(isInfinitePagination && {
	                [paginationInfiniteStartCaseClass]: {
	                    [`& > .${bulletClass}:nth-child(-n+4)`]: {
	                        width: paginationBulletSize,
	                        height: paginationBulletSize,
	                    },
	                },
	                [bulletInfiniteClass]: {
	                    // Necessary to override the bulletActiveClass sibling selector
	                    ...validateProps.addImportantToEachRule({
	                        width: paginationInfiniteBulletSize,
	                        height: paginationInfiniteBulletSize,
	                    }),
	                    [`& ~ .${bulletClass}`]: {
	                        width: paginationBulletSize,
	                        height: paginationBulletSize,
	                    },
	                    [`& ~ .${bulletInfiniteClass} ~ .${bulletClass}`]: {
	                        width: '0px',
	                        height: '0px',
	                    },
	                },
	            }),
	            [bulletActiveClass]: {
	                ...(validateProps.isHighContrastMode
	                    ? {
	                        background: canvasTextColor,
	                    }
	                    : {
	                        background: primaryColor,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            background: primaryColorDark,
	                        }),
	                    }),
	                height: paginationBulletSize,
	                width: validateProps.addImportantToRule(paginationActiveBulletSize),
	                ...(isInfinitePagination && {
	                    [`& ~ .${bulletClass}`]: {
	                        width: paginationBulletSize,
	                        height: paginationBulletSize,
	                    },
	                    [`& ~ .${bulletInfiniteClass} ~ .${bulletClass}`]: {
	                        width: '0px',
	                        height: '0px',
	                    },
	                }),
	            },
	        }),
	    });
	};

	const CAROUSEL_WIDTHS = ['basic', 'extended'];
	const CAROUSEL_SLIDES_PER_PAGE = ['auto', ...Array.from(new Array(10), (_, i) => i + 1)];
	const CAROUSEL_GRADIENT_COLORS = ['background-base', 'background-surface', 'none'];
	// 'left' is deprecated and will be mapped to 'start'
	/** @deprecated */
	const CAROUSEL_ALIGN_HEADERS_DEPRECATED = ['left'];
	const CAROUSEL_ALIGN_HEADERS = ['start', 'center', ...CAROUSEL_ALIGN_HEADERS_DEPRECATED];
	const CAROUSEL_ARIA_ATTRIBUTES = ['aria-label'];
	// The offset value used for calculating the number of infinite bullets
	const INFINITE_BULLET_OFFSET = 2;
	// The total number of infinite bullets including the center bullet
	const INFINITE_BULLET_AMOUNT = INFINITE_BULLET_OFFSET * 2 + 1;
	// Infinite bullets will be shown if the total number of bullets is greater than this value
	const INFINITE_BULLET_THRESHOLD = 5;
	const CAROUSEL_ALIGN_CONTROLS = ['start', 'center', 'auto'];
	const getSplideBreakpoints = (perPage) => {
	    return typeof perPage === 'object'
	        ? Object.entries(perPage).reduce((result, [key, val]) => ({
	            ...result,
	            [validateProps.breakpoint[key]]: {
	                // round to sanitize floating numbers
	                perPage: val === 'auto' ? 1 : Math.round(val),
	                autoWidth: val === 'auto',
	            },
	        }), {})
	        : {
	            0: {
	                // round to sanitize floating numbers
	                perPage: perPage === 'auto' ? 1 : Math.round(perPage),
	                autoWidth: perPage === 'auto',
	            },
	        };
	};
	const getSlidesAndAddAttributes = (host) => {
	    const slides = Array.from(host.children).filter(({ slot }) => slot !== 'heading' && slot !== 'description' && slot !== 'controls');
	    slides.forEach((el, i) => {
	        el.setAttribute('slot', `slide-${i}`);
	    });
	    return slides;
	};
	const getAmountOfPages = (amountOfSlides, slidesPerPage) => {
	    return amountOfSlides === 0 ? 0 : amountOfSlides < slidesPerPage ? 1 : amountOfSlides - slidesPerPage + 1;
	};
	const isFirstPage = (splide) => splide.index === 0;
	const isLastPage = (splide, amountOfPages) => splide.index >= amountOfPages - 1; // catch removal of slide
	const slidePrev = (splide, amountOfPages, focusOnCenterSlide) => {
	    if (focusOnCenterSlide) {
	        splide.go('<');
	    }
	    else {
	        // sanitize in case of removal of slide since splide.index seems to be from before splide.refresh()
	        const prevSlide = splide.index === amountOfPages ? splide.index - 2 : '<';
	        splide.go(isFirstPage(splide) ? amountOfPages - 1 : prevSlide);
	    }
	};
	const slideNext = (splide, amountOfPages, focusOnCenterSlide) => {
	    if (focusOnCenterSlide) {
	        splide.go('>');
	    }
	    else {
	        splide.go(isLastPage(splide, amountOfPages) ? 0 : '>');
	    }
	};
	const updatePrevNextButtons = (btnPrev, btnNext, splide) => {
	    const { i18n, rewind } = splide.options;
	    const isFirst = isFirstPage(splide);
	    btnPrev.disabled = isFirst && !rewind;
	    btnPrev.aria = { 'aria-label': i18n[isFirst ? 'last' : 'prev'] };
	    const isLast = isLastPage(splide, getAmountOfPages(splide.length, splide.options.perPage));
	    btnNext.disabled = isLast && !rewind;
	    btnNext.aria = {
	        'aria-label': i18n[isLast ? 'first' : 'next'],
	    };
	};
	const isInfinitePagination = (amountOfPages) => {
	    return amountOfPages > INFINITE_BULLET_THRESHOLD;
	};
	const renderPagination = (paginationEl, amountOfPages, activeIndex, splide) => {
	    if (paginationEl) {
	        // sanitize in case of removal of slide since activeIndex is from before splide.refresh()
	        const sanitizedActiveIndex = activeIndex > amountOfPages - 1 ? amountOfPages - 1 : activeIndex;
	        paginationEl.innerHTML = Array.from(new Array(amountOfPages), (_, i) => `<span class="bullet${i === sanitizedActiveIndex ? ` ${bulletActiveClass}` : ''}"></span>`).join('');
	        paginationEl.addEventListener('click', (e) => {
	            const target = e.composedPath()[0];
	            if (target.classList.contains(bulletClass)) {
	                splide.go(Array.from(paginationEl.children).indexOf(target));
	            }
	        });
	        if (isInfinitePagination(amountOfPages)) {
	            updateBulletState(paginationEl, amountOfPages, sanitizedActiveIndex);
	        }
	    }
	};
	const updateBulletState = (paginationEl, amountOfPages, newIndex) => {
	    const isStartCase = newIndex < INFINITE_BULLET_OFFSET;
	    const isEndCase = newIndex > amountOfPages - 1 - INFINITE_BULLET_OFFSET;
	    const infiniteBulletRightIndex = newIndex + INFINITE_BULLET_OFFSET;
	    const infiniteBulletLeftIndex = newIndex - INFINITE_BULLET_OFFSET;
	    const endCaseInfiniteBulletIndex = amountOfPages - INFINITE_BULLET_AMOUNT;
	    const startCaseInfiniteBulletIndex = INFINITE_BULLET_AMOUNT - 1;
	    const isInfiniteBulletLeft = (bulletIndex) => isEndCase ? bulletIndex === endCaseInfiniteBulletIndex : bulletIndex === infiniteBulletLeftIndex;
	    const isInfiniteBulletRight = (bulletIndex) => isStartCase ? bulletIndex === startCaseInfiniteBulletIndex : bulletIndex === infiniteBulletRightIndex;
	    const paginationGap = getComputedStyle(paginationEl).columnGap; // Touch devices use a larger gap
	    const getTranslateX = () => {
	        if (isStartCase) {
	            return '0';
	        }
	        if (isEndCase) {
	            return `calc(-${amountOfPages - INFINITE_BULLET_AMOUNT} * ${paginationGap})`;
	        }
	        return `calc(-${newIndex - INFINITE_BULLET_OFFSET} * ${paginationGap})`;
	    };
	    paginationEl.style.transform = `translateX(${getTranslateX()})`;
	    // Only update bullets around newIndex
	    for (let i = newIndex - INFINITE_BULLET_AMOUNT - 1; i < newIndex + INFINITE_BULLET_AMOUNT + 1; i++) {
	        const index = (i + amountOfPages) % amountOfPages;
	        paginationEl.children[index].classList.toggle(bulletInfiniteClass, isInfiniteBulletLeft(index) || isInfiniteBulletRight(index));
	    }
	    // Add/Remove class to pagination in order to style the first bullets when the index is in isStartCase
	    paginationEl.classList.toggle(paginationInfiniteStartCaseClass, isStartCase);
	};
	const updatePagination = (paginationEl, amountOfPages, newIndex) => {
	    if (paginationEl) {
	        paginationEl.querySelector(`.${bulletActiveClass}`).classList.remove(bulletActiveClass);
	        paginationEl.children[newIndex].classList.add(bulletActiveClass);
	        if (isInfinitePagination(amountOfPages)) {
	            updateBulletState(paginationEl, amountOfPages, newIndex);
	        }
	    }
	};
	const getLangDirection = (el) => {
	    const dirAttribute = el.closest('[dir]')?.getAttribute('dir');
	    if (dirAttribute) {
	        return dirAttribute;
	    }
	    const lang = document.documentElement.lang;
	    if (lang && lang !== 'unknown') {
	        // @ts-expect-error "textInfo" is not supported in Firefox and not part of the types.
	        return new Intl.Locale(lang).textInfo?.direction || 'ltr';
	    }
	    return 'ltr';
	};

	const propTypes = {
	    heading: validateProps.AllowedTypes.string,
	    headingSize: validateProps.AllowedTypes.oneOf(['x-large', 'xx-large']),
	    description: validateProps.AllowedTypes.string,
	    alignHeader: validateProps.AllowedTypes.oneOf(CAROUSEL_ALIGN_HEADERS),
	    rewind: validateProps.AllowedTypes.boolean,
	    wrapContent: validateProps.AllowedTypes.boolean,
	    width: validateProps.AllowedTypes.oneOf(CAROUSEL_WIDTHS),
	    slidesPerPage: validateProps.AllowedTypes.oneOf([
	        validateProps.AllowedTypes.breakpoint(CAROUSEL_SLIDES_PER_PAGE),
	    ]),
	    gradientColor: validateProps.AllowedTypes.oneOf(CAROUSEL_GRADIENT_COLORS),
	    focusOnCenterSlide: validateProps.AllowedTypes.boolean,
	    trimSpace: validateProps.AllowedTypes.boolean,
	    disablePagination: validateProps.AllowedTypes.breakpoint('boolean'),
	    pagination: validateProps.AllowedTypes.breakpoint('boolean'),
	    aria: validateProps.AllowedTypes.aria(CAROUSEL_ARIA_ATTRIBUTES),
	    intl: validateProps.AllowedTypes.shape({
	        prev: validateProps.AllowedTypes.string,
	        next: validateProps.AllowedTypes.string,
	        first: validateProps.AllowedTypes.string,
	        last: validateProps.AllowedTypes.string,
	        slideLabel: validateProps.AllowedTypes.string,
	        slide: validateProps.AllowedTypes.string,
	    }),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    activeSlideIndex: validateProps.AllowedTypes.number,
	    skipLinkTarget: validateProps.AllowedTypes.string,
	    alignControls: validateProps.AllowedTypes.oneOf(CAROUSEL_ALIGN_CONTROLS),
	};
	const Carousel = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.carouselChange = validateProps.createEvent(this, "carouselChange", 3);
	        this.update = validateProps.createEvent(this, "update", 3);
	        this.slides = [];
	        this.updateSlidesAndPagination = () => {
	            this.slides = getSlidesAndAddAttributes(this.host);
	            this.updateAmountOfPages();
	        };
	        this.updateAmountOfPages = () => {
	            this.amountOfPages = getAmountOfPages(this.slides.length, 
	            // round to sanitize floating numbers
	            validateProps.getCurrentMatchingBreakpointValue(this.parsedSlidesPerPage) === 'auto'
	                ? 1
	                : Math.round(validateProps.getCurrentMatchingBreakpointValue(this.parsedSlidesPerPage)));
	            renderPagination(this.paginationEl, this.getPageCount(), this.splide?.index || 0, this.splide);
	            // splideJS needs to be refreshed to apply new 'autoWidth' option which is not supported by splideJS breakpoint feature
	            if (this.splide) {
	                validateProps.getCurrentMatchingBreakpointValue(this.parsedSlidesPerPage) === 'auto'
	                    ? (this.splide.options = { autoWidth: true })
	                    : false;
	                this.splide.refresh();
	            }
	        };
	        this.onNextKeyDown = (e) => {
	            if (e.key === 'Tab' && !e.shiftKey) {
	                const activeSlide = this.splideSlides.at(this.splide.index);
	                activeSlide.focus();
	                e.preventDefault();
	            }
	        };
	        this.getPageCount = () => (this.focusOnCenterSlide ? this.slides.length : this.amountOfPages);
	        this.onSplideFocusIn = (e) => {
	            const { target } = e;
	            const { index: splideIndex } = this.splide;
	            const slideIndexOfFocusedElement = this.splideSlides.findIndex((slide) => slide.querySelector('slot').assignedElements()[0].contains(target) || slide.contains(target)); // focussed element is slot or within slide, e.g. link or button
	            const slideIsVisible = this.splideSlides[slideIndexOfFocusedElement].classList.contains('is-visible');
	            if (splideIndex !== slideIndexOfFocusedElement) {
	                if (slideIndexOfFocusedElement > splideIndex && (!slideIsVisible || this.focusOnCenterSlide)) {
	                    slideNext(this.splide, this.amountOfPages, this.focusOnCenterSlide);
	                }
	                else if (slideIndexOfFocusedElement < splideIndex) {
	                    slidePrev(this.splide, this.amountOfPages, this.focusOnCenterSlide);
	                }
	            }
	        };
	        this.heading = undefined;
	        this.headingSize = 'x-large';
	        this.description = undefined;
	        this.alignHeader = 'start';
	        this.alignControls = 'auto';
	        this.rewind = true;
	        this.wrapContent = undefined;
	        this.width = 'basic';
	        this.slidesPerPage = 1;
	        this.disablePagination = undefined;
	        this.pagination = true;
	        this.aria = undefined;
	        this.intl = undefined;
	        this.theme = 'light';
	        this.activeSlideIndex = 0;
	        this.skipLinkTarget = undefined;
	        this.focusOnCenterSlide = false;
	        this.gradientColor = 'none';
	        this.trimSpace = true;
	        this.amountOfPages = undefined;
	    }
	    get parsedSlidesPerPage() {
	        return validateProps.parseJSON(this.slidesPerPage);
	    }
	    get parsedDisablePagination() {
	        return validateProps.parseJSON(this.disablePagination);
	    }
	    get parsedPagination() {
	        return validateProps.parseJSON(this.pagination);
	    }
	    get splideSlides() {
	        return this.splide.Components.Elements.slides;
	    }
	    get hasNavigation() {
	        return this.parsedSlidesPerPage === 'auto' || this.amountOfPages > 1;
	    }
	    activeSlideHandler(newValue) {
	        this.splide.go(newValue); // change event is emitted via splide.on('move')
	    }
	    connectedCallback() {
	        validateProps.applyConstructableStylesheetStyles(this.host, slottedAnchorStyles.getSlottedAnchorStyles);
	        validateProps.observeChildren(this.host, this.updateSlidesAndPagination);
	        this.observeBreakpointChange();
	        if (this.splide) {
	            this.observeSlides(); // on reconnect, adjust aria attributes on slides
	            // on reconnect we can reuse the splide instance
	            this.updateSlidesAndPagination();
	            this.registerSplideHandlers(this.splide);
	        }
	    }
	    componentWillLoad() {
	        this.updateSlidesAndPagination();
	        this.observeBreakpointChange();
	    }
	    componentShouldUpdate(newVal, oldVal, propName) {
	        return propName !== 'activeSlideIndex' && validateProps.hasPropValueChanged(newVal, oldVal); // we need to prevent splide reinitialization via splide.refresh() when activeSlideIndex is changed from outside
	    }
	    componentDidLoad() {
	        this.observeSlides(); // initial, adjust aria attributes on slides
	        this.splide = new Splide(this.container, {
	            start: this.activeSlideIndex,
	            arrows: false,
	            easing: validateProps.motionEasingBase,
	            focus: this.focusOnCenterSlide ? 'center' : undefined,
	            trimSpace: this.trimSpace,
	            pagination: false,
	            rewind: this.rewind,
	            rewindByDrag: true, // only works when rewind: true
	            drag: this.hasNavigation,
	            perMove: 1,
	            mediaQuery: 'min',
	            speed: Number.parseFloat(carouselTransitionDuration) * 1000,
	            gap: gridGap.gridGap,
	            // TODO: this uses matchMedia internally, since we also use it, there is some redundancy
	            breakpoints: getSplideBreakpoints(this.parsedSlidesPerPage), // eslint-disable-line @typescript-eslint/no-redundant-type-constituents
	            // https://splidejs.com/guides/i18n/#default-texts
	            i18n: validateProps.parseJSONAttribute(this.intl || {}), // can only be applied initially atm
	            direction: getLangDirection(this.host),
	        });
	        this.registerSplideHandlers(this.splide);
	    }
	    componentDidUpdate() {
	        this.splide.options = { drag: this.hasNavigation };
	        this.splide.refresh(); // needs to happen after render to detect new and removed slides
	        if (this.hasNavigation) {
	            renderPagination(this.paginationEl, this.getPageCount(), this.splide?.index || 0, this.splide); // update pagination in case the carousel was not draggable before
	            updatePrevNextButtons(this.btnPrev, this.btnNext, this.splide); // go to last/first slide aria might be wrong
	        }
	    }
	    disconnectedCallback() {
	        validateProps.unobserveChildren(this.host);
	        validateProps.unobserveChildren(this.container); // adjust aria attributes on slides
	        validateProps.unobserveBreakpointChange(this.host);
	        this.splide.destroy();
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        const alignHeaderDeprecationMap = {
	            left: 'start',
	        };
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'alignHeader', alignHeaderDeprecationMap);
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'wrapContent');
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'disablePagination', 'Please use pagination prop instead.');
	        const hasHeadingPropOrSlot = hasHeading.hasHeading(this.host, this.heading);
	        const hasDescriptionPropOrSlot = hasDescription.hasDescription(this.host, this.description);
	        const hasControlsSlot = hasNamedSlot.hasNamedSlot(this.host, 'controls');
	        validateProps.attachComponentCss(this.host, getComponentCss, this.gradientColor, hasHeadingPropOrSlot, hasDescriptionPropOrSlot, hasControlsSlot, this.headingSize, this.width, 
	        // flip boolean values of disablePagination since it is the inverse of pagination
	        this.parsedDisablePagination
	            ? typeof this.parsedDisablePagination === 'object'
	                ? Object.fromEntries(Object.entries(this.parsedDisablePagination).map(([key, value]) => [key, !value]))
	                : !this.parsedDisablePagination
	            : this.parsedPagination, isInfinitePagination(this.focusOnCenterSlide ? this.slides.length : this.amountOfPages), (alignHeaderDeprecationMap[this.alignHeader] ||
	            this.alignHeader), this.theme, this.hasNavigation, this.alignControls);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        const btnProps = {
	            class: 'btn',
	            type: 'button',
	            hideLabel: true,
	            theme: this.theme,
	            // 'aria-controls': 'splide-track', // TODO: cross shadow dom? use native button tag instead of p-button-pure?
	        };
	        const headingId = 'heading';
	        return (validateProps.h(validateProps.Host, { key: '70b0ea802dbe12fe312d7a476851b88f05f42460' }, validateProps.h("div", { key: '3336216de14640a06c348167bfcfb3fcde4df491', class: "header" }, hasHeadingPropOrSlot &&
	            (this.heading ? (validateProps.h("h2", { class: "heading", id: headingId }, this.heading)) : (validateProps.h("div", { class: "heading", id: headingId }, validateProps.h("slot", { name: "heading" })))), hasDescriptionPropOrSlot && (this.description ? validateProps.h("p", null, this.description) : validateProps.h("slot", { name: "description" })), hasControlsSlot && validateProps.h("slot", { key: '71c55b3b931c63877efd3684a17dab10d5c81076', name: "controls" }), validateProps.h("div", { key: '06008af7aa0cea5de3c27ea9b795e732e2916be8', class: "nav" }, this.skipLinkTarget && (validateProps.h(PrefixedTagNames.pLinkPure, { key: 'f067621828af8c817a557f6ccc78916b5d4bb370', href: this.skipLinkTarget, theme: this.theme, icon: "arrow-last", class: "btn skip-link", alignLabel: "start", hideLabel: true }, "Skip carousel entries")), this.hasNavigation && (validateProps.h(PrefixedTagNames.pButtonPure, { key: '52c0259105c52685b63f85bde7461649d6c4d2ec', ...btnProps, icon: "arrow-left", ref: (ref) => (this.btnPrev = ref), onClick: () => slidePrev(this.splide, this.amountOfPages, this.focusOnCenterSlide) })), this.hasNavigation && (validateProps.h(PrefixedTagNames.pButtonPure, { key: '5f880c934f02082bcd27817ea69562172c33b7e0', ...btnProps, icon: "arrow-right", ref: (ref) => (this.btnNext = ref), onClick: () => slideNext(this.splide, this.amountOfPages, this.focusOnCenterSlide), onKeyDown: this.onNextKeyDown })))), validateProps.h("div", { key: 'c58d75c92673f39caeb01bea15843fee9d67bed4', id: "splide", class: "splide", ...validateProps.parseAndGetAriaAttributes({
	                'aria-labelledby': hasHeadingPropOrSlot && !this.aria ? headingId : undefined,
	                ...validateProps.parseAndGetAriaAttributes(this.aria),
	            }), ref: (ref) => (this.container = ref), onMouseDown: (e) => e.preventDefault(), onFocusin: this.onSplideFocusIn }, validateProps.h("div", { key: '9edf1173a95709ce50836420b310780d6b956d6b', class: "splide__track" }, validateProps.h("div", { key: '69231accb997d4755d65d77874f4de1515cfdb17', class: "splide__list" }, this.slides.map((_, i) => (validateProps.h("div", { key: i, class: "splide__slide", tabIndex: 0 }, validateProps.h("slot", { name: `slide-${i}` }))))))), (this.parsedDisablePagination ? this.parsedDisablePagination !== true : this.parsedPagination) &&
	            this.hasNavigation && (validateProps.h("div", { key: 'c72762bf9d7dab0678e42fb2f7f0036572749297', class: "pagination-container", "aria-hidden": "true" }, validateProps.h("div", { key: '05f1c6886d643f38f6d6c4ca09328ad56f78bd41', class: "pagination", ref: (ref) => (this.paginationEl = ref) })))));
	    }
	    registerSplideHandlers(splide) {
	        splide.on('mounted', () => {
	            if (this.splide.options.drag) {
	                updatePrevNextButtons(this.btnPrev, this.btnNext, splide);
	                renderPagination(this.paginationEl, this.getPageCount(), this.activeSlideIndex, this.splide); // initial pagination
	            }
	        });
	        splide.on('move', (activeIndex, previousIndex) => {
	            updatePrevNextButtons(this.btnPrev, this.btnNext, splide);
	            updatePagination(this.paginationEl, this.getPageCount(), activeIndex);
	            this.update.emit({ activeIndex, previousIndex });
	            this.carouselChange.emit({ activeIndex, previousIndex });
	        });
	        splide.mount();
	    }
	    observeBreakpointChange() {
	        if (typeof this.parsedSlidesPerPage === 'object') {
	            validateProps.observeBreakpointChange(this.host, this.updateAmountOfPages);
	        }
	    }
	    observeSlides() {
	        // splide sets attributes everytime it slides or slides are added, which we need to adjust after wards
	        validateProps.observeChildren(this.container, () => {
	            for (const el of this.splideSlides) {
	                el.removeAttribute('aria-hidden');
	                el.setAttribute('tabindex', '0');
	            }
	        }, ['aria-hidden']);
	    }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "activeSlideIndex": ["activeSlideHandler"]
	    }; }
	};

	pCarousel_cjs_entry.p_carousel = Carousel;

	
	return pCarousel_cjs_entry;
}

var pCheckboxWrapper_cjs_entry = {};

var schemedHighContrastMediaQuery462417a0 = {};

var hasRequiredSchemedHighContrastMediaQuery462417a0;

function requireSchemedHighContrastMediaQuery462417a0 () {
	if (hasRequiredSchemedHighContrastMediaQuery462417a0) return schemedHighContrastMediaQuery462417a0;
	hasRequiredSchemedHighContrastMediaQuery462417a0 = 1;

	const getSchemedHighContrastMediaQuery = (light, dark) => {
	    return {
	        '@media (forced-colors: active) and (prefers-color-scheme: light)': light,
	        '@media (forced-colors: active) and (prefers-color-scheme: dark)': dark,
	    };
	};

	schemedHighContrastMediaQuery462417a0.getSchemedHighContrastMediaQuery = getSchemedHighContrastMediaQuery;

	
	return schemedHighContrastMediaQuery462417a0;
}

var hasRequiredPCheckboxWrapper_cjs_entry;

function requirePCheckboxWrapper_cjs_entry () {
	if (hasRequiredPCheckboxWrapper_cjs_entry) return pCheckboxWrapper_cjs_entry;
	hasRequiredPCheckboxWrapper_cjs_entry = 1;

	Object.defineProperty(pCheckboxWrapper_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const isDisabledOrLoading = requireIsDisabledOrLoadingB1f56d7f();
	const stateMessageStyles = requireStateMessageStylesD1c4637f();
	const theme = requireThemeBfc10573();
	const getOnlyChildOfKindHTMLElementOrThrow = requireGetOnlyChildOfKindHTMLElementOrThrowCdb95e52();
	const applyCheckboxRadioButtonSafariRenderingFix = requireApplyCheckboxRadioButtonSafariRenderingFixE0db2b50();
	const getInlineSVGBackgroundImage = requireGetInlineSVGBackgroundImageB65404d9();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const schemedHighContrastMediaQuery = requireSchemedHighContrastMediaQuery462417a0();
	const labelStyles = requireLabelStylesD5916d0e();
	const loadingMessageStyles = requireLoadingMessageStyles100c7f01();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const fontLineHeight = requireFontLineHeightD4b9e1a9();
	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();
	const fontFamily = requireFontFamily23874d28();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const slottedAnchorStyles = requireSlottedAnchorStylesFe1a10c2();
	requireHasNamedSlot273cd3ae();
	requireGetNamedSlot223c478a();
	requireTextSmallStyle00e1c6e2();
	requireTextShared5216bb19();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireGetDirectChildHTMLElements2594e5bd();
	requireGetHTMLElements3f1c700f();
	requireTransformSelectorToDirectChildSelectorEcc1a9c4();
	requireSupportsChromiumMediaQueryE79aefa2();
	requireHoverMediaQuery5e6deda8();
	requireGetClosestHTMLElement83d01a84();
	requireHasDescription050833e0();
	requireIsParentOfKind4b323732();
	requireFontSizeTextXSmallE59d35d7();
	requireBorderRadiusMedium758b9411();

	const getCheckedSVGBackgroundImage = (fill) => {
	    return getInlineSVGBackgroundImage.getInlineSVGBackgroundImage(`<path fill="${fill}" d="m20.22,7.47l-1.47-1.42-9.26,9.02-4.24-4.15-1.47,1.42,5.71,5.6,10.73-10.47Z"/>`);
	};
	const getIndeterminateSVGBackgroundImage = (fill) => {
	    return getInlineSVGBackgroundImage.getInlineSVGBackgroundImage(`<path fill="${fill}" d="m20,11v2H4v-2h16Z"/>`);
	};
	const getComponentCss = (hideLabel, state, isDisabled, isLoading, theme) => {
	    const checkedIconColor = getInlineSVGBackgroundImage.escapeHashCharacter(validateProps.getInvertedThemedColors(theme).primaryColor);
	    const checkedIconColorDark = getInlineSVGBackgroundImage.escapeHashCharacter(validateProps.getInvertedThemedColors('dark').primaryColor);
	    const indeterminateIconColor = getInlineSVGBackgroundImage.escapeHashCharacter(validateProps.getThemedColors(theme).primaryColor);
	    const indeterminateIconColorDark = getInlineSVGBackgroundImage.escapeHashCharacter(validateProps.getThemedColors('dark').primaryColor);
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            // ::slotted(input)
	            ...validateProps.addImportantToEachRule(validateProps.mergeDeep(applyCheckboxRadioButtonSafariRenderingFix.getSlottedCheckboxRadioButtonStyles(state, isDisabled, isLoading, theme), {
	                '::slotted': {
	                    '&(input)': {
	                        gridArea: '1/1',
	                        borderRadius: borderRadiusSmall.borderRadiusSmall,
	                    },
	                    // TODO: is it somehow useful possible to make following styles configurable by parameter?
	                    ...(!isLoading && {
	                        '&(input:checked)': {
	                            backgroundImage: getCheckedSVGBackgroundImage(checkedIconColor),
	                            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                                backgroundImage: getCheckedSVGBackgroundImage(checkedIconColorDark),
	                            }),
	                            // This is a workaround for Blink based browsers, which do not reflect the high contrast system colors (e.g.: "Canvas" and "CanvasText") when added to background SVG's.
	                            ...(validateProps.isHighContrastMode &&
	                                schemedHighContrastMediaQuery.getSchemedHighContrastMediaQuery({
	                                    backgroundImage: getCheckedSVGBackgroundImage('white'),
	                                }, {
	                                    backgroundImage: getCheckedSVGBackgroundImage('black'),
	                                })),
	                        },
	                        '&(input:indeterminate)': {
	                            backgroundImage: getIndeterminateSVGBackgroundImage(indeterminateIconColor),
	                            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                                backgroundImage: getIndeterminateSVGBackgroundImage(indeterminateIconColorDark),
	                            }),
	                            // This is a workaround for Blink based browsers, which do not reflect the high contrast system colors (e.g.: "Canvas" and "CanvasText") when added to background SVG's.
	                            ...(validateProps.isHighContrastMode &&
	                                schemedHighContrastMediaQuery.getSchemedHighContrastMediaQuery({
	                                    backgroundImage: getIndeterminateSVGBackgroundImage('black'),
	                                }, {
	                                    backgroundImage: getIndeterminateSVGBackgroundImage('white'),
	                                })),
	                        },
	                    }),
	                },
	            })),
	        },
	        root: {
	            display: 'grid',
	            gridTemplateColumns: 'auto minmax(0, 1fr)',
	            rowGap: spacingStaticXSmall.spacingStaticXSmall,
	        },
	        wrapper: {
	            display: 'grid',
	            gridArea: '1/1',
	            alignSelf: 'flex-start', // in case label becomes multiline
	            ...(isDisabledOrLoading.isDisabledOrLoading(isDisabled, isLoading) && {
	                // TODO: maybe .wrapper should handle it for all form components while pointer-events: none is set to input
	                cursor: 'not-allowed',
	            }),
	        },
	        ...(isLoading && {
	            // TODO: extract for checkbox-wrapper and radio-button-wrapper (not gridArea and placeSelf)
	            spinner: {
	                position: 'relative', // ensure correct stacking, can be removed as soon as focus for input is handled with outline
	                gridArea: '1/1',
	                placeSelf: 'center',
	                width: fontLineHeight.fontLineHeight,
	                height: fontLineHeight.fontLineHeight,
	                font: `${fontSizeTextSmall.fontSizeTextSmall} ${fontFamily.fontFamily}`, // needed for correct width and height definition based on ex-unit
	                pointerEvents: 'none',
	            },
	        }),
	        // .label / .required
	        ...labelStyles.getFunctionalComponentLabelStyles(isDisabled || isLoading, hideLabel, theme, {
	            gridArea: '1/2',
	        }, {
	            paddingTop: '2px', // compensate vertical alignment
	            paddingInlineStart: spacingStaticSmall.spacingStaticSmall, // asymmetric padding used instead of gap to prevent not clickable area between label and input
	        }),
	        // .message
	        ...stateMessageStyles.getFunctionalComponentStateMessageStyles(theme, state, {
	            gridColumn: '1/3',
	        }),
	        // .loading
	        ...loadingMessageStyles.getFunctionalComponentLoadingMessageStyles(),
	    });
	};

	const propTypes = {
	    label: validateProps.AllowedTypes.string,
	    state: validateProps.AllowedTypes.oneOf(stateMessageStyles.FORM_STATES),
	    message: validateProps.AllowedTypes.string,
	    hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	    loading: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const CheckboxWrapper = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.initialLoading = false;
	        this.observeAttributes = () => {
	            validateProps.observeAttributes(this.input, ['disabled', 'required'], () => validateProps.forceUpdate(this.host));
	        };
	        this.label = '';
	        this.state = 'none';
	        this.message = '';
	        this.hideLabel = false;
	        this.loading = false;
	        this.theme = 'light';
	    }
	    onKeydown(e) {
	        const { key } = e;
	        if ((key === ' ' || key === 'Spacebar') && isDisabledOrLoading.isDisabledOrLoading(this.input.disabled, this.loading)) {
	            e.preventDefault();
	        }
	    }
	    connectedCallback() {
	        this.initialLoading = this.loading;
	        validateProps.applyConstructableStylesheetStyles(this.host, slottedAnchorStyles.getSlottedAnchorStyles, applyCheckboxRadioButtonSafariRenderingFix.getCheckboxRadioButtonSafariRenderingFix);
	        this.observeAttributes(); // on every reconnect
	    }
	    componentWillLoad() {
	        this.initialLoading = this.loading;
	        this.input = getOnlyChildOfKindHTMLElementOrThrow.getOnlyChildOfKindHTMLElementOrThrow(this.host, 'input[type=checkbox]');
	        this.observeAttributes(); // once initially
	    }
	    componentWillUpdate() {
	        if (this.loading) {
	            this.initialLoading = true;
	        }
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    componentDidRender() {
	        /*
	         * This is a workaround to improve accessibility because the input and the label/description/message text are placed in different DOM.
	         * Referencing ID's from outside the component is impossible because the web components DOM is separate.
	         * We have to wait for full support of the Accessibility Object Model (AOM) to provide the relationship between shadow DOM and slots
	         */
	        validateProps.setAriaAttributes(this.input, {
	            label: this.label,
	            message: this.message,
	            state: this.state,
	        });
	    }
	    disconnectedCallback() {
	        validateProps.unobserveAttributes(this.input);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        const { disabled } = this.input;
	        validateProps.attachComponentCss(this.host, getComponentCss, this.hideLabel, this.state, disabled, this.loading, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h("div", { key: '61fbcc42dd8afd31d65c1120573a9e052822e800', class: "root" }, validateProps.h(labelStyles.Label, { key: '7581e6dbdd5fb38ec0e53a93c79a22bbd1933d21', host: this.host, label: this.label, isLoading: this.loading, isDisabled: disabled, formElement: this.input }), validateProps.h("div", { key: 'b95dfe4a675a7a216c8a28a7aa17689c50571d1d', class: "wrapper" }, validateProps.h("slot", { key: '758461c3d85f1dc2e4f20d262a7c1c5574bc4bb8' }), this.loading && (validateProps.h(PrefixedTagNames.pSpinner, { key: 'ceee98688323b7aaee9bc3954d6e289c60c7aead', class: "spinner", size: "inherit", theme: this.theme, "aria-hidden": "true" }))), validateProps.h(stateMessageStyles.StateMessage, { key: '02ef74678445b21ae79519acbbf93ad2322bed05', state: this.state, message: this.message, theme: this.theme, host: this.host }), validateProps.h(loadingMessageStyles.LoadingMessage, { key: '00f8a5131f503f891e0a145bc77f300418ed5075', loading: this.loading, initialLoading: this.initialLoading })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pCheckboxWrapper_cjs_entry.p_checkbox_wrapper = CheckboxWrapper;

	
	return pCheckboxWrapper_cjs_entry;
}

var pCheckbox_cjs_entry = {};

var hasRequiredPCheckbox_cjs_entry;

function requirePCheckbox_cjs_entry () {
	if (hasRequiredPCheckbox_cjs_entry) return pCheckbox_cjs_entry;
	hasRequiredPCheckbox_cjs_entry = 1;

	Object.defineProperty(pCheckbox_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const isDisabledOrLoading = requireIsDisabledOrLoadingB1f56d7f();
	const stateMessageStyles = requireStateMessageStylesD1c4637f();
	const theme = requireThemeBfc10573();
	const slottedAnchorStyles = requireSlottedAnchorStylesFe1a10c2();
	const labelStyles = requireLabelStylesD5916d0e();
	const loadingMessageStyles = requireLoadingMessageStyles100c7f01();
	const supportsChromiumMediaQuery = requireSupportsChromiumMediaQueryE79aefa2();
	const getInlineSVGBackgroundImage = requireGetInlineSVGBackgroundImageB65404d9();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const schemedHighContrastMediaQuery = requireSchemedHighContrastMediaQuery462417a0();
	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();
	const fontFamily = requireFontFamily23874d28();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const textSmallStyle = requireTextSmallStyle00e1c6e2();
	const fontLineHeight = requireFontLineHeightD4b9e1a9();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	requireHasNamedSlot273cd3ae();
	requireGetNamedSlot223c478a();
	requireBorderRadiusMedium758b9411();
	requireGetClosestHTMLElement83d01a84();
	requireHasDescription050833e0();
	requireIsParentOfKind4b323732();
	requireFontSizeTextXSmallE59d35d7();
	requireTextShared5216bb19();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();

	const getCheckedSVGBackgroundImage = (fill) => {
	    return getInlineSVGBackgroundImage.getInlineSVGBackgroundImage(`<path fill="${fill}" d="m20.22,7.47l-1.47-1.42-9.26,9.02-4.24-4.15-1.47,1.42,5.71,5.6,10.73-10.47Z"/>`);
	};
	const getIndeterminateSVGBackgroundImage = (fill) => {
	    return getInlineSVGBackgroundImage.getInlineSVGBackgroundImage(`<path fill="${fill}" d="m20,11v2H4v-2h16Z"/>`);
	};
	const cssVarInternalCheckboxScaling = '--p-internal-checkbox-scaling';
	const getComponentCss = (hideLabel, state, isDisabled, isLoading, compact, theme) => {
	    const { primaryColor, contrastMediumColor, contrastHighColor, disabledColor, focusColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, contrastMediumColor: contrastMediumColorDark, contrastHighColor: contrastHighColorDark, disabledColor: disabledColorDark, focusColor: focusColorDark, } = validateProps.getThemedColors('dark');
	    const { formStateColor, formStateHoverColor } = stateMessageStyles.getThemedFormStateColors(theme, state);
	    const { formStateColor: formStateColorDark, formStateHoverColor: formStateHoverColorDark } = stateMessageStyles.getThemedFormStateColors('dark', state);
	    const { canvasTextColor } = validateProps.getHighContrastColors();
	    const disabledOrLoading = isDisabledOrLoading.isDisabledOrLoading(isDisabled, isLoading);
	    // TODO: needs to be extracted into a color function
	    const uncheckedColor = disabledOrLoading ? disabledColor : formStateColor || contrastMediumColor;
	    const uncheckedColorDark = disabledOrLoading ? disabledColorDark : formStateColorDark || contrastMediumColorDark;
	    const uncheckedHoverColor = formStateHoverColor || primaryColor;
	    const uncheckedHoverColorDark = formStateHoverColorDark || primaryColorDark;
	    const checkedColor = validateProps.isHighContrastMode
	        ? canvasTextColor
	        : disabledOrLoading
	            ? disabledColor
	            : formStateColor || primaryColor;
	    const checkedColorDark = validateProps.isHighContrastMode
	        ? canvasTextColor
	        : disabledOrLoading
	            ? disabledColorDark
	            : formStateColorDark || primaryColorDark;
	    const checkedHoverColor = formStateHoverColor || contrastHighColor;
	    const checkedHoverColorDark = formStateHoverColorDark || contrastHighColorDark;
	    const checkedIconColor = getInlineSVGBackgroundImage.escapeHashCharacter(validateProps.getInvertedThemedColors(theme).primaryColor);
	    const checkedIconColorDark = getInlineSVGBackgroundImage.escapeHashCharacter(validateProps.getInvertedThemedColors('dark').primaryColor);
	    const indeterminateIconColor = getInlineSVGBackgroundImage.escapeHashCharacter(disabledOrLoading ? disabledColorDark : formStateColor || primaryColor);
	    const indeterminateIconColorDark = getInlineSVGBackgroundImage.escapeHashCharacter(formStateColorDark || primaryColorDark);
	    const indeterminateIconHoverColor = getInlineSVGBackgroundImage.escapeHashCharacter(formStateHoverColor || primaryColor);
	    const indeterminateIconHoverColorDark = getInlineSVGBackgroundImage.escapeHashCharacter(formStateHoverColorDark || primaryColorDark);
	    const background = `transparent 0% 0% / ${fontLineHeight.fontLineHeight}`;
	    const minimumTouchTargetSize = '24px'; // Minimum touch target size to comply with accessibility guidelines.
	    const scalingVar = `var(${cssVarInternalCheckboxScaling}, ${compact ? 0.6668 : 1})`;
	    // Determines the scaling factor for the checkbox size. In "compact" mode, it uses 0.6668 to achieve a 20px checkbox (compact size).
	    // Defaults to 1 for the standard size and can be overridden by the CSS variable `cssVarInternalCheckboxScaling`.
	    const dimension = `calc(max(${validateProps.SCALING_BASE_VALUE} * 0.75, ${scalingVar} * ${fontLineHeight.fontLineHeight}))`;
	    // Calculates the checkbox size and ensures a minimum size of 12px (0.75 * SCALING_BASE_VALUE).
	    // Scales proportionally with the line height and the scaling factor.
	    const dimensionFull = `calc(${dimension} + ${validateProps.borderWidthBase} * 2)`; // Calculates the total size of the checkbox including its borders.
	    const touchTargetSizeDiff = `calc(${minimumTouchTargetSize} - ${dimensionFull})`; // Difference between the minimum touch target size and the checkbox full size.
	    const paddingInlineStart = `calc(${spacingStaticSmall.spacingStaticSmall} - (max(0px, ${touchTargetSizeDiff})))`;
	    // Adjusts padding to maintain consistent spacing when the checkbox is smaller than the minimum touch target size.
	    // Uses asymmetric padding instead of `gap` to ensure there is no non-clickable area between the label and the input.
	    const paddingTop = `calc((${dimensionFull} - ${fontLineHeight.fontLineHeight}) / 2)`; // Vertically centers the checkbox label relative to the checkbox size.
	    const inset = `calc(-${validateProps.borderWidthBase} - max(0px, ${touchTargetSizeDiff} / 2))`; // Positions the checkbox ::before pseudo-element with a negative offset to align it with the touch target.
	    const height = `calc(max(${fontLineHeight.fontLineHeight}, ${dimensionFull}))`; // Ensures the wrapper height matches either the font's line height or the full size of the checkbox, whichever is larger.
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            input: {
	                position: 'relative',
	                '&::before': {
	                    // Ensures the touch target is at least 24px, even if the checkbox is smaller than the minimum touch target size.
	                    // This pseudo-element expands the clickable area without affecting the visual size of the checkbox itself.
	                    content: '""',
	                    position: 'absolute',
	                    inset,
	                },
	                width: dimension,
	                height: dimension,
	                font: `${fontSizeTextSmall.fontSizeTextSmall} ${fontFamily.fontFamily}`, // needed for correct width and height definition based on ex-unit
	                display: 'block',
	                margin: 0,
	                padding: 0,
	                WebkitAppearance: 'none', // iOS safari
	                appearance: 'none',
	                boxSizing: 'content-box',
	                background,
	                transition: `${validateProps.getTransition('background-color')}, ${validateProps.getTransition('border-color')}`,
	                border: `${validateProps.borderWidthBase} solid ${uncheckedColor}`,
	                outline: 0, // TODO: only relevant for VRT testing with forced states - prevents :focus style (in case getFocusJssStyle() condition is not matching)
	                ...(disabledOrLoading
	                    ? {
	                        pointerEvents: 'none', // to prevent form element becomes clickable/toggleable
	                    }
	                    : {
	                        cursor: 'pointer',
	                    }),
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    borderColor: uncheckedColorDark,
	                }),
	                gridArea: '1/1',
	                borderRadius: borderRadiusSmall.borderRadiusSmall,
	                ...validateProps.addImportantToEachRule({
	                    backgroundSize: 'cover',
	                }),
	            },
	            ...(isLoading
	                ? {
	                    'input:checked': {
	                        // background-image is merged in later
	                        borderColor: checkedColor,
	                        backgroundColor: checkedColor,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            borderColor: checkedColorDark,
	                            backgroundColor: checkedColorDark,
	                        }),
	                    },
	                }
	                : {
	                    'input:checked': {
	                        borderColor: checkedColor,
	                        backgroundColor: checkedColor,
	                        backgroundImage: getCheckedSVGBackgroundImage(checkedIconColor),
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            backgroundImage: getCheckedSVGBackgroundImage(checkedIconColorDark),
	                            borderColor: checkedColorDark,
	                            backgroundColor: checkedColorDark,
	                        }),
	                        // This is a workaround for Blink based browsers, which do not reflect the high contrast system colors (e.g.: "Canvas" and "CanvasText") when added to background SVG's.
	                        ...(validateProps.isHighContrastMode &&
	                            schemedHighContrastMediaQuery.getSchemedHighContrastMediaQuery({
	                                backgroundImage: getCheckedSVGBackgroundImage('white'),
	                            }, {
	                                backgroundImage: getCheckedSVGBackgroundImage('black'),
	                            })),
	                    },
	                    'input:indeterminate': {
	                        background, // Safari fix: ensures proper rendering of 'indeterminate' mode with 'checked' state.
	                        borderColor: uncheckedColor, // Safari fix: ensures proper rendering of 'indeterminate' mode with 'checked' state.
	                        backgroundImage: getIndeterminateSVGBackgroundImage(indeterminateIconColor),
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            backgroundImage: getIndeterminateSVGBackgroundImage(disabledOrLoading ? indeterminateIconColor : indeterminateIconColorDark),
	                            borderColor: uncheckedColorDark, // Safari fix: ensures proper rendering of 'indeterminate' mode with 'checked' state.
	                            backgroundColor: 'transparent', // Safari fix: ensures proper rendering of 'indeterminate' mode with 'checked' state.
	                        }),
	                        // This is a workaround for Blink based browsers, which do not reflect the high contrast system colors (e.g.: "Canvas" and "CanvasText") when added to background SVG's.
	                        ...(validateProps.isHighContrastMode &&
	                            schemedHighContrastMediaQuery.getSchemedHighContrastMediaQuery({
	                                backgroundImage: getIndeterminateSVGBackgroundImage('black'),
	                            }, {
	                                backgroundImage: getIndeterminateSVGBackgroundImage('white'),
	                            })),
	                    },
	                }),
	            ...(!disabledOrLoading &&
	                !validateProps.isHighContrastMode &&
	                hoverMediaQuery.hoverMediaQuery({
	                    'input:hover,label:hover~.wrapper input': {
	                        borderColor: uncheckedHoverColor,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            borderColor: uncheckedHoverColorDark,
	                        }),
	                    },
	                    'input:checked:hover,label:hover~.wrapper input:checked': {
	                        borderColor: checkedHoverColor,
	                        backgroundColor: checkedHoverColor,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            borderColor: checkedHoverColorDark,
	                            backgroundColor: checkedHoverColorDark,
	                        }),
	                    },
	                    'input:indeterminate:hover,label:hover~.wrapper input:indeterminate': {
	                        background, // Safari fix: ensures proper rendering of 'indeterminate' mode with 'checked' state.
	                        borderColor: uncheckedHoverColor, // Safari fix: ensures proper rendering of 'indeterminate' mode with 'checked' state.
	                        backgroundImage: getIndeterminateSVGBackgroundImage(getInlineSVGBackgroundImage.escapeHashCharacter(indeterminateIconHoverColor)),
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            backgroundImage: getIndeterminateSVGBackgroundImage(getInlineSVGBackgroundImage.escapeHashCharacter(indeterminateIconHoverColorDark)),
	                            borderColor: uncheckedHoverColorDark, // Safari fix: ensures proper rendering of 'indeterminate' mode
	                            backgroundColor: 'transparent',
	                        }),
	                    },
	                    'label:hover~.wrapper input': supportsChromiumMediaQuery.supportsChromiumMediaQuery({
	                        transition: 'unset', // Fixes chrome bug where transition properties are stuck on hover
	                    }),
	                })),
	            ...(!isDisabled && {
	                'input::-moz-focus-inner': {
	                    border: 0, // reset ua-style (for FF)
	                },
	                'input:focus': {
	                    outline: 0, // reset ua-style (for older browsers)
	                },
	                'input:focus-visible': {
	                    outline: `${validateProps.borderWidthBase} solid ${focusColor}`,
	                    outlineOffset: '2px',
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        outlineColor: focusColorDark,
	                    }),
	                },
	            }),
	        },
	        root: {
	            display: 'grid',
	            gridTemplateColumns: 'auto minmax(0, 1fr)',
	            rowGap: spacingStaticXSmall.spacingStaticXSmall,
	            ...(disabledOrLoading && {
	                cursor: 'not-allowed',
	            }),
	        },
	        wrapper: {
	            ...textSmallStyle.textSmallStyle,
	            minWidth: minimumTouchTargetSize,
	            minHeight: minimumTouchTargetSize,
	            justifyContent: 'center',
	            alignItems: 'center',
	            display: 'grid',
	            gridArea: '1/1',
	            alignSelf: 'flex-start', // in case label becomes multiline
	            height,
	        },
	        ...(isLoading && {
	            spinner: {
	                position: 'relative', // ensure correct stacking, can be removed as soon as focus for input is handled with outline
	                gridArea: '1/1',
	                placeSelf: 'center',
	                width: dimension,
	                height: dimension,
	                font: `${fontSizeTextSmall.fontSizeTextSmall} ${fontFamily.fontFamily}`, // needed for correct width and height definition based on ex-unit
	                pointerEvents: 'none',
	            },
	        }),
	        // .label / .required
	        ...labelStyles.getFunctionalComponentLabelStyles(isDisabled || isLoading, hideLabel, theme, {
	            gridArea: '1/2',
	            ...(isLoading && { pointerEvents: 'none' }), // prevent default htmlFor behavior. TODO: Remove as soon as label component for custom form components exists.
	        }, {
	            paddingTop,
	            paddingInlineStart,
	        }),
	        // .message
	        ...stateMessageStyles.getFunctionalComponentStateMessageStyles(theme, state, {
	            gridColumn: '1/3',
	        }),
	        // .loading
	        ...loadingMessageStyles.getFunctionalComponentLoadingMessageStyles(),
	    });
	};

	const propTypes = {
	    label: validateProps.AllowedTypes.string,
	    name: validateProps.AllowedTypes.string,
	    value: validateProps.AllowedTypes.string,
	    required: validateProps.AllowedTypes.boolean,
	    disabled: validateProps.AllowedTypes.boolean,
	    indeterminate: validateProps.AllowedTypes.boolean,
	    checked: validateProps.AllowedTypes.boolean,
	    form: validateProps.AllowedTypes.string,
	    state: validateProps.AllowedTypes.oneOf(stateMessageStyles.FORM_STATES),
	    message: validateProps.AllowedTypes.string,
	    hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	    loading: validateProps.AllowedTypes.boolean,
	    compact: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Checkbox = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.update = validateProps.createEvent(this, "update", 3);
	        this.blur = validateProps.createEvent(this, "blur", 3);
	        if (hostRef.$hostElement$["s-ei"]) {
	            this.internals = hostRef.$hostElement$["s-ei"];
	        }
	        else {
	            this.internals = hostRef.$hostElement$.attachInternals?.();
	            hostRef.$hostElement$["s-ei"] = this.internals;
	        }
	        this.initialLoading = false;
	        this.onBlur = (e) => {
	            e.stopPropagation();
	            e.stopImmediatePropagation();
	            this.blur.emit(e);
	        };
	        this.onChange = (e) => {
	            const checked = e.target.checked;
	            this.checked = checked;
	            this.internals?.setFormValue(checked ? this.value : undefined);
	            this.update.emit({
	                value: this.value,
	                name: this.name,
	                checked,
	            });
	        };
	        this.name = '';
	        this.required = false;
	        this.disabled = false;
	        this.indeterminate = false;
	        this.checked = false;
	        this.form = undefined;
	        this.value = 'on';
	        this.label = '';
	        this.state = 'none';
	        this.message = '';
	        this.hideLabel = false;
	        this.loading = false;
	        this.compact = false;
	        this.theme = 'light';
	    }
	    onKeydown(e) {
	        const { key } = e;
	        if ((key === ' ' || key === 'Spacebar') && isDisabledOrLoading.isDisabledOrLoading(this.disabled, this.loading)) {
	            e.preventDefault();
	        }
	    }
	    onValueChange(newValue) {
	        this.internals?.setFormValue(this.checkboxInputElement?.checked ? newValue : undefined);
	    }
	    onIndeterminateChange(newValue) {
	        if (this.checkboxInputElement) {
	            this.checkboxInputElement.indeterminate = newValue;
	        }
	    }
	    onCheckedChange(newValue) {
	        this.internals?.setFormValue(newValue ? this.value : undefined);
	    }
	    connectedCallback() {
	        this.initialLoading = this.loading;
	        validateProps.applyConstructableStylesheetStyles(this.host, slottedAnchorStyles.getSlottedAnchorStyles);
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    componentWillLoad() {
	        this.initialLoading = this.loading;
	        this.defaultChecked = this.checked;
	    }
	    componentDidLoad() {
	        this.checkboxInputElement.indeterminate = this.indeterminate;
	        if (this.checkboxInputElement.checked) {
	            this.internals?.setFormValue(this.value);
	        }
	    }
	    componentWillUpdate() {
	        if (this.loading) {
	            this.initialLoading = true;
	        }
	    }
	    formResetCallback() {
	        this.internals?.setFormValue(this.defaultChecked ? this.value : undefined);
	        this.checked = this.defaultChecked;
	    }
	    formDisabledCallback(disabled) {
	        this.disabled = disabled;
	    }
	    formStateRestoreCallback(state) {
	        this.checked = !!state;
	    }
	    componentDidRender() {
	        // Skip validation if the checkbox is disabled; it's ignored in form validation
	        // and always has an empty validationMessage, even if some ValidityState flags are true.
	        if (!this.disabled) {
	            this.internals?.setValidity(this.checkboxInputElement.validity, this.checkboxInputElement.validationMessage, this.checkboxInputElement);
	        }
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.hideLabel, this.state, this.disabled, this.loading, this.compact, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        const id = 'checkbox';
	        return (validateProps.h("div", { key: '4246bd0e50d8d0d46eaf009a8f8b1ed5c84b083e', class: "root" }, validateProps.h(labelStyles.Label, { key: '8c01da52538d92bd0006173a9a7a6b20ca59d143', host: this.host, htmlFor: id, label: this.label, isLoading: this.loading, isDisabled: this.disabled, isRequired: this.required }), validateProps.h("div", { key: '799a14ba76cfd97aee855455241f38b17c187df8', class: "wrapper" }, validateProps.h("input", { key: 'a5811d4018e8c665c018253b55f50d7056c0da52', type: "checkbox", id: id, "aria-describedby": `${labelStyles.descriptionId} ${stateMessageStyles.messageId}`, "aria-invalid": this.state === 'error' ? 'true' : null, "aria-disabled": this.loading || this.disabled ? 'true' : null, checked: this.checked, form: this.form, value: this.value, name: this.name, onChange: this.onChange, onBlur: this.onBlur, required: this.required, disabled: this.disabled, ref: (el) => (this.checkboxInputElement = el) }), this.loading && (validateProps.h(PrefixedTagNames.pSpinner, { key: '5ac3f2d039e7eca9fdf735eefabb4ebff3103655', class: "spinner", size: "inherit", theme: this.theme, "aria-hidden": "true" }))), validateProps.h(stateMessageStyles.StateMessage, { key: 'd47b7da1ec23b0b6929becbf15e9a2af599eedb5', state: this.state, message: this.message, theme: this.theme, host: this.host }), validateProps.h(loadingMessageStyles.LoadingMessage, { key: '2016dd865ffa5784cb3a5927cfe68be1a297586b', loading: this.loading, initialLoading: this.initialLoading })));
	    }
	    static get delegatesFocus() { return true; }
	    static get formAssociated() { return true; }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "value": ["onValueChange"],
	        "indeterminate": ["onIndeterminateChange"],
	        "checked": ["onCheckedChange"]
	    }; }
	};

	pCheckbox_cjs_entry.p_checkbox = Checkbox;

	
	return pCheckbox_cjs_entry;
}

var pContentWrapper_cjs_entry = {};

var warnIfDeprecatedComponentIsUsedB14eebd2 = {};

var hasRequiredWarnIfDeprecatedComponentIsUsedB14eebd2;

function requireWarnIfDeprecatedComponentIsUsedB14eebd2 () {
	if (hasRequiredWarnIfDeprecatedComponentIsUsedB14eebd2) return warnIfDeprecatedComponentIsUsedB14eebd2;
	hasRequiredWarnIfDeprecatedComponentIsUsedB14eebd2 = 1;

	const validateProps = requireValidateProps788e2bc5();

	const warnIfDeprecatedComponentIsUsed = (host, message) => {
	    validateProps.consoleWarn(`component ${validateProps.getTagNameWithoutPrefix(host)} is deprecated and will be removed with next major release.`, message, host);
	};

	warnIfDeprecatedComponentIsUsedB14eebd2.warnIfDeprecatedComponentIsUsed = warnIfDeprecatedComponentIsUsed;

	
	return warnIfDeprecatedComponentIsUsedB14eebd2;
}

var hasRequiredPContentWrapper_cjs_entry;

function requirePContentWrapper_cjs_entry () {
	if (hasRequiredPContentWrapper_cjs_entry) return pContentWrapper_cjs_entry;
	hasRequiredPContentWrapper_cjs_entry = 1;

	Object.defineProperty(pContentWrapper_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const warnIfDeprecatedComponentIsUsed = requireWarnIfDeprecatedComponentIsUsedB14eebd2();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const gridExtendedOffsetBase = requireGridExtendedOffsetBaseFb9830f6();
	const gridExtendedOffsetXXL = requireGridExtendedOffsetXXLC7a41e50();
	const gridBasicOffset = requireGridBasicOffset92343778();
	requireGridGapB5b73e4a();
	requireSpacingFluidMedium88ab712b();

	const gridFullOffset = gridExtendedOffsetXXL._gridPadding;

	const gridNarrowOffsetBase = gridExtendedOffsetBase._gridSafeZoneBase;

	const gridNarrowOffsetS = gridExtendedOffsetXXL._getGridOffsetS('narrow');

	const gridNarrowOffsetXXL = gridExtendedOffsetXXL._getGridOffsetXXL('narrow');

	const gridNarrowOffset = {
	    base: gridNarrowOffsetBase,
	    s: gridNarrowOffsetS,
	    xxl: gridNarrowOffsetXXL,
	};

	const CONTENT_WRAPPER_BACKGROUND_COLORS = ['transparent', 'default'];
	// fluid is deprecated and will be mapped to full
	const CONTENT_WRAPPER_WIDTHS = ['narrow', 'basic', 'extended', 'fluid', 'full'];
	const deprecatedContentWrapperComponentMessage = 'Please use native CSS Grid (https://css-tricks.com/snippets/css/complete-guide-grid) instead in combination with the Porsche Grid utility based on CSS Grid.';

	const widthMap = {
	    narrow: gridNarrowOffset,
	    basic: gridBasicOffset.gridBasicOffset,
	    extended: gridBasicOffset.gridExtendedOffset,
	};
	const getComponentCss = (width) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	        },
	        root: {
	            minWidth: 0, // needed for some flex context
	            ...(['full', 'fluid'].includes(width)
	                ? {
	                    padding: `0 ${gridFullOffset}`,
	                }
	                : {
	                    padding: `0 ${widthMap[width].base}`,
	                    [validateProps.getMediaQueryMin('s')]: {
	                        padding: `0 ${widthMap[width].s}`,
	                    },
	                    [validateProps.getMediaQueryMin('xxl')]: {
	                        padding: `0 ${widthMap[width].xxl}`,
	                    },
	                }),
	        },
	    });
	};

	const propTypes = {
	    width: validateProps.AllowedTypes.oneOf(CONTENT_WRAPPER_WIDTHS),
	    backgroundColor: validateProps.AllowedTypes.oneOf(CONTENT_WRAPPER_BACKGROUND_COLORS),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const ContentWrapper = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.width = 'extended';
	        this.backgroundColor = 'transparent';
	        this.theme = 'light';
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedComponentIsUsed.warnIfDeprecatedComponentIsUsed(this.host, deprecatedContentWrapperComponentMessage);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.width);
	        return (validateProps.h("div", { key: '1af948954323e0a1cacdf1824f62865fad5674ab', class: "root" }, validateProps.h("slot", { key: 'cf799bc234824436f9fee5087343dd4712b622c3' })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pContentWrapper_cjs_entry.p_content_wrapper = ContentWrapper;

	
	return pContentWrapper_cjs_entry;
}

var pCrest_cjs_entry = {};

var hasRequiredPCrest_cjs_entry;

function requirePCrest_cjs_entry () {
	if (hasRequiredPCrest_cjs_entry) return pCrest_cjs_entry;
	hasRequiredPCrest_cjs_entry = 1;

	Object.defineProperty(pCrest_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const getCDNBaseURL = requireGetCDNBaseURLE7722df3();
	const linkAriaAttribute = requireLinkAriaAttribute6f29e1a0();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();

	// index.ts
	var CRESTS_MANIFEST = { "porscheCrest": { "1x": { "png": "porsche-crest.d76137c@1x.png", "webp": "porsche-crest.0d0cc89@1x.webp" }, "2x": { "png": "porsche-crest.8a292fb@2x.png", "webp": "porsche-crest.2245c45@2x.webp" }, "3x": { "png": "porsche-crest.18d6f02@3x.png", "webp": "porsche-crest.19b4292@3x.webp" } } };

	const buildCrestSrcSet = (format) => {
	    return Object.entries(CRESTS_MANIFEST.porscheCrest)
	        .map(([resolution, fileName]) => `${getCDNBaseURL.getCDNBaseURL()}/crest/${fileName[format]} ${resolution}`)
	        .join();
	};
	const buildCrestImgSrc = () => {
	    return `${getCDNBaseURL.getCDNBaseURL()}/crest/${CRESTS_MANIFEST.porscheCrest['2x'].png}`;
	};
	const crestSize = {
	    width: 30,
	    height: 40,
	};

	const { width: width$1, height: height$1 } = crestSize;
	const getDimensionStyle = {
	    maxWidth: `${width$1}px`,
	    maxHeight: `${height$1}px`,
	    width: 'inherit',
	    height: 'inherit',
	};
	const getComponentCss = () => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                position: 'relative',
	                display: 'inline-block',
	                verticalAlign: 'top',
	                ...validateProps.addImportantToEachRule({
	                    outline: 0, // TODO: is it still necessary?
	                    boxSizing: 'content-box', // needed for correct height calculation when padding is set on host (e.g. custom click area)
	                    ...getDimensionStyle,
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            a: {
	                display: 'block',
	                textDecoration: 'none',
	                ...getDimensionStyle,
	                '&::before': {
	                    // needs to be defined always to have correct custom click area
	                    content: '""',
	                    position: 'absolute',
	                    inset: 0,
	                    borderRadius: '1px',
	                },
	                ...validateProps.getFocusJssStyle('light', { pseudo: true }), // TODO: we need to support theme
	            },
	            picture: {
	                display: 'block',
	                width: `min(${width$1}px, 100%)`,
	                height: `min(${height$1}px, 100%)`,
	            },
	            img: {
	                display: 'block',
	                maxWidth: '100%',
	                maxHeight: '100%',
	                width: 'auto',
	                height: 'auto',
	            },
	        },
	    });
	};

	const propTypes = {
	    href: validateProps.AllowedTypes.string,
	    target: validateProps.AllowedTypes.string,
	    aria: validateProps.AllowedTypes.aria(linkAriaAttribute.LINK_ARIA_ATTRIBUTES),
	};
	const { width, height } = crestSize;
	const Crest = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.href = undefined;
	        this.target = '_self';
	        this.aria = undefined;
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, getComponentCss);
	        const picture = window.PDS_SKIP_FETCH ? undefined :  (validateProps.h("picture", { key: '975aa1e5c2d0acdf9028d264c96233162751a820' }, validateProps.h("source", { key: "webp", srcSet: buildCrestSrcSet('webp'), type: "image/webp" }), validateProps.h("source", { key: "png", srcSet: buildCrestSrcSet('png'), type: "image/png" }), validateProps.h("img", { key: '820743149c5f98de61e872944a0a657f36bc6c07', src: buildCrestImgSrc(), width: width, height: height, alt: "Porsche" })));
	        return (validateProps.h(validateProps.Host, { key: '33f00a2c1eb00353ee3f2d818b7383131347c24e' }, this.href === undefined ? (picture) : (validateProps.h("a", { href: this.href, target: this.target, ...validateProps.parseAndGetAriaAttributes(this.aria) }, picture))));
	    }
	    static get delegatesFocus() { return true; }
	    get host() { return validateProps.getElement(this); }
	};

	pCrest_cjs_entry.p_crest = Crest;

	
	return pCrest_cjs_entry;
}

var pDisplay_cjs_entry = {};

var typographyAlign844cd863 = {};

var hasRequiredTypographyAlign844cd863;

function requireTypographyAlign844cd863 () {
	if (hasRequiredTypographyAlign844cd863) return typographyAlign844cd863;
	hasRequiredTypographyAlign844cd863 = 1;

	const getDirectChildHTMLElement = requireGetDirectChildHTMLElement18d9487f();

	const hasSpecificDirectChildTag = (host, tag) => {
	    const el = getDirectChildHTMLElement.getDirectChildHTMLElement(host, ':only-child');
	    return !!el?.matches(tag);
	};

	// 'left' is deprecated and will be mapped to 'start'
	// 'right' is deprecated and will be mapped to 'end'
	/** @deprecated */
	const TYPOGRAPHY_ALIGNS_DEPRECATED = ['left', 'right'];
	const TYPOGRAPHY_ALIGNS = ['start', 'center', 'end', 'inherit', ...TYPOGRAPHY_ALIGNS_DEPRECATED];

	typographyAlign844cd863.TYPOGRAPHY_ALIGNS = TYPOGRAPHY_ALIGNS;
	typographyAlign844cd863.hasSpecificDirectChildTag = hasSpecificDirectChildTag;

	
	return typographyAlign844cd863;
}

var typographyStyles226e4585 = {};

var hasRequiredTypographyStyles226e4585;

function requireTypographyStyles226e4585 () {
	if (hasRequiredTypographyStyles226e4585) return typographyStyles226e4585;
	hasRequiredTypographyStyles226e4585 = 1;

	const validateProps = requireValidateProps788e2bc5();

	const getThemedTypographyColor = (theme, textColor // eslint-disable-line @typescript-eslint/no-duplicate-type-constituents
	) => {
	    const themedColors = validateProps.getThemedColors(theme);
	    const colorMap = {
	        primary: themedColors.primaryColor,
	        default: themedColors.primaryColor, // deprecated but part of HeadlineColor
	        'contrast-low': themedColors.contrastLowColor,
	        'contrast-medium': themedColors.contrastMediumColor,
	        'contrast-high': themedColors.contrastHighColor,
	        'notification-success': themedColors.successColor,
	        'notification-warning': themedColors.warningColor,
	        'notification-error': themedColors.errorColor,
	        'notification-info': themedColors.infoColor,
	        inherit: 'currentColor',
	    };
	    return colorMap[textColor];
	};

	const getTypographyRootJssStyle = (baseTextStyle, responsiveStyle, align, // eslint-disable-line @typescript-eslint/no-duplicate-type-constituents
	color, // eslint-disable-line @typescript-eslint/no-duplicate-type-constituents
	ellipsis, theme) => {
	    return {
	        margin: 0,
	        padding: 0,
	        ...baseTextStyle,
	        color: getThemedTypographyColor(theme, color),
	        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	            color: getThemedTypographyColor('dark', color),
	        }),
	        textAlign: align,
	        letterSpacing: 'normal',
	        listStyleType: 'none',
	        whiteSpace: 'inherit',
	        ...(ellipsis && {
	            maxWidth: '100%',
	            overflow: 'hidden',
	            textOverflow: 'ellipsis',
	            whiteSpace: 'nowrap',
	        }),
	        ...responsiveStyle,
	    };
	};
	const getTypographySlottedJssStyle = () => {
	    return {
	        all: 'unset',
	    };
	};

	typographyStyles226e4585.getTypographyRootJssStyle = getTypographyRootJssStyle;
	typographyStyles226e4585.getTypographySlottedJssStyle = getTypographySlottedJssStyle;

	
	return typographyStyles226e4585;
}

var hasRequiredPDisplay_cjs_entry;

function requirePDisplay_cjs_entry () {
	if (hasRequiredPDisplay_cjs_entry) return pDisplay_cjs_entry;
	hasRequiredPDisplay_cjs_entry = 1;

	Object.defineProperty(pDisplay_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const typographyAlign = requireTypographyAlign844cd863();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed91ceea3c();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const typographyStyles = requireTypographyStyles226e4585();
	const displayShared = requireDisplaySharedAdef5fa6();
	const slottedAnchorStyles = requireSlottedAnchorStylesFe1a10c2();
	requireGetDirectChildHTMLElement18d9487f();
	requireTransformSelectorToDirectChildSelectorEcc1a9c4();
	requireHelper22e15c0e();
	requireFontFamily23874d28();
	requireFontLineHeightD4b9e1a9();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireBorderRadiusSmall5f37fc45();
	requireBorderRadiusMedium758b9411();

	const fontSizeDisplaySmall = 'clamp(1.8rem, 2.41vw + 1.32rem, 4.21rem)';

	const fontSizeDisplayLarge = 'clamp(2.28rem, 5.2vw + 1.24rem, 7.48rem)';

	const displayLargeStyle = {
	    font: `${displayShared._displayFontPartA}${fontSizeDisplayLarge}${displayShared._displayFontPartB}`,
	};

	const DISPLAY_TAGS = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
	const DISPLAY_SIZES = ['small', 'medium', 'large', 'inherit'];
	const DISPLAY_COLORS = ['primary', 'inherit'];
	const displaySizeToTagMap = {
	    small: 'h3',
	    medium: 'h2',
	    large: 'h1',
	    inherit: 'h1',
	};
	const getDisplayTagType = (host, size, tag) => {
	    if (typographyAlign.hasSpecificDirectChildTag(host, DISPLAY_TAGS.join())) {
	        return 'div';
	    }
	    if (tag) {
	        return tag;
	    }
	    return displaySizeToTagMap[size] || 'h1';
	};

	const sizeMap = {
	    small: fontSizeDisplaySmall,
	    medium: displayShared.fontSizeDisplayMedium,
	    large: fontSizeDisplayLarge,
	};
	const getComponentCss = (size, align, color, ellipsis, theme) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            [`::slotted(:is(${DISPLAY_TAGS.join()}))`]: validateProps.addImportantToEachRule(typographyStyles.getTypographySlottedJssStyle()),
	        },
	        root: typographyStyles.getTypographyRootJssStyle(displayLargeStyle, validateProps.buildResponsiveStyles(size, (sizeValue) => ({
	            fontSize: sizeValue === 'inherit' ? sizeValue : sizeMap[sizeValue],
	        })), align, color, ellipsis, theme),
	    });
	};

	const propTypes = {
	    tag: validateProps.AllowedTypes.oneOf([undefined, ...DISPLAY_TAGS]),
	    size: validateProps.AllowedTypes.breakpoint(DISPLAY_SIZES),
	    align: validateProps.AllowedTypes.oneOf(typographyAlign.TYPOGRAPHY_ALIGNS),
	    color: validateProps.AllowedTypes.oneOf(DISPLAY_COLORS),
	    ellipsis: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Display = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.tag = undefined;
	        this.size = 'large';
	        this.align = 'start';
	        this.color = 'primary';
	        this.ellipsis = false;
	        this.theme = 'light';
	    }
	    connectedCallback() {
	        validateProps.applyConstructableStylesheetStyles(this.host, slottedAnchorStyles.getSlottedAnchorStyles);
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        const alignDeprecationMap = {
	            left: 'start',
	            right: 'end',
	        };
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'align', alignDeprecationMap);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.size, (alignDeprecationMap[this.align] || this.align), this.color, this.ellipsis, this.theme);
	        const TagType = getDisplayTagType(this.host, this.size, this.tag);
	        return (validateProps.h(TagType, { key: '8ca8f48a96c3950d4e0a437e40ccc79a1f969e5f', class: "root" }, validateProps.h("slot", { key: '28f3034e57f7b4706f92e107b4ef0aa4160c6db4' })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pDisplay_cjs_entry.p_display = Display;

	
	return pDisplay_cjs_entry;
}

var pDivider_cjs_entry = {};

var hasRequiredPDivider_cjs_entry;

function requirePDivider_cjs_entry () {
	if (hasRequiredPDivider_cjs_entry) return pDivider_cjs_entry;
	hasRequiredPDivider_cjs_entry = 1;

	Object.defineProperty(pDivider_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed91ceea3c();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed76f87eda();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	requireHelper22e15c0e();

	/** @deprecated */
	const DIVIDER_COLORS_DEPRECATED = [
	    'neutral-contrast-high',
	    'neutral-contrast-medium',
	    'neutral-contrast-low',
	];
	const DIVIDER_COLORS = [
	    'contrast-low',
	    'contrast-medium',
	    'contrast-high',
	    ...DIVIDER_COLORS_DEPRECATED,
	];
	const DIVIDER_DIRECTIONS = ['vertical', 'horizontal'];

	const getComponentCss = (color, orientation, theme) => {
	    const { contrastLowColor, contrastMediumColor, contrastHighColor } = validateProps.getThemedColors(theme);
	    const { contrastLowColor: contrastLowColorDark, contrastMediumColor: contrastMediumColorDark, contrastHighColor: contrastHighColorDark, } = validateProps.getThemedColors('dark');
	    const colorMap = {
	        'contrast-low': contrastLowColor,
	        'contrast-medium': contrastMediumColor,
	        'contrast-high': contrastHighColor,
	    };
	    const colorMapDark = {
	        'contrast-low': contrastLowColorDark,
	        'contrast-medium': contrastMediumColorDark,
	        'contrast-high': contrastHighColorDark,
	    };
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            hr: {
	                margin: 0,
	                padding: 0,
	                border: 'none',
	                textAlign: 'start',
	                ...(validateProps.isHighContrastMode
	                    ? {
	                        background: validateProps.getHighContrastColors().canvasTextColor,
	                    }
	                    : {
	                        background: colorMap[color],
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            background: colorMapDark[color],
	                        }),
	                    }),
	                ...validateProps.buildResponsiveStyles(orientation, (o) => o === 'horizontal' ? { height: '1px', width: '100%' } : { height: '100%', width: '1px' }),
	            },
	        },
	    });
	};

	const propTypes = {
	    color: validateProps.AllowedTypes.oneOf(DIVIDER_COLORS),
	    orientation: validateProps.AllowedTypes.breakpoint([undefined, ...DIVIDER_DIRECTIONS]),
	    direction: validateProps.AllowedTypes.breakpoint(DIVIDER_DIRECTIONS),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Divider = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.color = 'contrast-low';
	        this.orientation = undefined;
	        this.direction = 'horizontal';
	        this.theme = 'light';
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        const deprecationMap = {
	            'neutral-contrast-low': 'contrast-low',
	            'neutral-contrast-medium': 'contrast-medium',
	            'neutral-contrast-high': 'contrast-high',
	        };
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'color', deprecationMap);
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'orientation', 'Please use direction prop instead.');
	        validateProps.attachComponentCss(this.host, getComponentCss, (deprecationMap[this.color] || this.color), this.orientation || this.direction, this.theme);
	        return validateProps.h("hr", { key: 'edf839fc2c669bd09ef6c35ad50be5c89f4ee726' });
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pDivider_cjs_entry.p_divider = Divider;

	
	return pDivider_cjs_entry;
}

var pFieldsetWrapper_cjs_entry = {};

var hasRequiredPFieldsetWrapper_cjs_entry;

function requirePFieldsetWrapper_cjs_entry () {
	if (hasRequiredPFieldsetWrapper_cjs_entry) return pFieldsetWrapper_cjs_entry;
	hasRequiredPFieldsetWrapper_cjs_entry = 1;

	Object.defineProperty(pFieldsetWrapper_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const stateMessageStyles = requireStateMessageStylesD1c4637f();
	const warnIfDeprecatedComponentIsUsed = requireWarnIfDeprecatedComponentIsUsedB14eebd2();
	const theme = requireThemeBfc10573();
	const fieldsetUtils = requireFieldsetUtils7753153f();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();
	const headingSmallStyle = requireHeadingSmallStyle43f95761();
	requireHasNamedSlot273cd3ae();
	requireGetNamedSlot223c478a();
	requireSpacingStaticXSmallB7d708b8();
	requireTextSmallStyle00e1c6e2();
	requireTextShared5216bb19();
	requireFontFamily23874d28();
	requireFontLineHeightD4b9e1a9();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireHeadingShared888aa084();
	requireFontWeightSemiBold4482c830();
	requireFontSizeHeadingMediumC49ab5a2();
	requireFontSizeTextMedium88887ad8();
	requireFontSizeHeadingSmallA15141a5();

	const getComponentCss = (state, labelSize, hasLabel, theme) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            fieldset: {
	                margin: 0,
	                padding: 0,
	                border: 'none',
	            },
	            ...(hasLabel && {
	                legend: {
	                    margin: `0 0 ${spacingStaticMedium.spacingStaticMedium}`,
	                    padding: 0,
	                    color: validateProps.getThemedColors(theme).primaryColor,
	                    ...(labelSize === 'small' ? headingSmallStyle.headingSmallStyle : fieldsetUtils.headingMediumStyle),
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        color: validateProps.getThemedColors('dark').primaryColor,
	                    }),
	                },
	            }),
	        },
	        ...stateMessageStyles.getFunctionalComponentRequiredStyles(),
	        ...validateProps.mergeDeep(stateMessageStyles.getFunctionalComponentStateMessageStyles(theme, state), {
	            message: {
	                marginTop: spacingStaticMedium.spacingStaticMedium,
	            },
	        }),
	    });
	};

	const propTypes = {
	    label: validateProps.AllowedTypes.string,
	    labelSize: validateProps.AllowedTypes.oneOf(fieldsetUtils.FIELDSET_LABEL_SIZES),
	    required: validateProps.AllowedTypes.boolean,
	    state: validateProps.AllowedTypes.oneOf(stateMessageStyles.FORM_STATES),
	    message: validateProps.AllowedTypes.string,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const FieldsetWrapper = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.label = '';
	        this.labelSize = 'medium';
	        this.required = false;
	        this.state = 'none';
	        this.message = '';
	        this.theme = 'light';
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedComponentIsUsed.warnIfDeprecatedComponentIsUsed(this.host, 'Please use new p-fieldset component instead.');
	        validateProps.attachComponentCss(this.host, getComponentCss, this.state, this.labelSize, stateMessageStyles.hasLabel(this.host, this.label), this.theme);
	        const hasMessageValue = stateMessageStyles.hasMessage(this.host, this.message, this.state);
	        return (validateProps.h("fieldset", { key: '9376e235455e0f7b94223f0160ce0d1649f879d2', "aria-describedby": hasMessageValue ? stateMessageStyles.messageId : null }, stateMessageStyles.hasLabel(this.host, this.label) && (validateProps.h("legend", { key: '3727a6b8b75bc0877c31bcb4d83cab7f7862130f' }, this.label || validateProps.h("slot", { key: '48f61902118bd8ff1c2551af07dbc1a8d583efed', name: "label" }), this.required && validateProps.h(stateMessageStyles.Required, { key: '09612a06af32746cec0d639ce3fcf566a96b5caf' }))), validateProps.h("slot", { key: '8b99b771261a098b1ffc8ee37c6ac8fe90b1d752' }), validateProps.h(stateMessageStyles.StateMessage, { key: 'db28e903f3d82cc58ef0ed0c4748ff25594e482d', state: this.state, message: this.message, theme: this.theme, host: this.host })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pFieldsetWrapper_cjs_entry.p_fieldset_wrapper = FieldsetWrapper;

	
	return pFieldsetWrapper_cjs_entry;
}

var pFieldset_cjs_entry = {};

var hasRequiredPFieldset_cjs_entry;

function requirePFieldset_cjs_entry () {
	if (hasRequiredPFieldset_cjs_entry) return pFieldset_cjs_entry;
	hasRequiredPFieldset_cjs_entry = 1;

	Object.defineProperty(pFieldset_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const stateMessageStyles = requireStateMessageStylesD1c4637f();
	const theme = requireThemeBfc10573();
	const fieldsetUtils = requireFieldsetUtils7753153f();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();
	const headingSmallStyle = requireHeadingSmallStyle43f95761();
	requireHasNamedSlot273cd3ae();
	requireGetNamedSlot223c478a();
	requireSpacingStaticXSmallB7d708b8();
	requireTextSmallStyle00e1c6e2();
	requireTextShared5216bb19();
	requireFontFamily23874d28();
	requireFontLineHeightD4b9e1a9();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireHeadingShared888aa084();
	requireFontWeightSemiBold4482c830();
	requireFontSizeHeadingMediumC49ab5a2();
	requireFontSizeTextMedium88887ad8();
	requireFontSizeHeadingSmallA15141a5();

	const getComponentCss = (state, labelSize, hasLabel, theme) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            fieldset: {
	                margin: 0,
	                padding: 0,
	                border: 'none',
	            },
	            ...(hasLabel && {
	                legend: {
	                    margin: `0 0 ${spacingStaticMedium.spacingStaticMedium}`,
	                    padding: 0,
	                    color: validateProps.getThemedColors(theme).primaryColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        color: validateProps.getThemedColors('dark').primaryColor,
	                    }),
	                    ...(labelSize === 'small' ? headingSmallStyle.headingSmallStyle : fieldsetUtils.headingMediumStyle),
	                },
	            }),
	        },
	        ...stateMessageStyles.getFunctionalComponentRequiredStyles(),
	        ...validateProps.mergeDeep(stateMessageStyles.getFunctionalComponentStateMessageStyles(theme, state), {
	            message: {
	                marginTop: spacingStaticMedium.spacingStaticMedium,
	            },
	        }),
	    });
	};

	const propTypes = {
	    label: validateProps.AllowedTypes.string,
	    labelSize: validateProps.AllowedTypes.oneOf(fieldsetUtils.FIELDSET_LABEL_SIZES),
	    required: validateProps.AllowedTypes.boolean,
	    state: validateProps.AllowedTypes.oneOf(stateMessageStyles.FORM_STATES),
	    message: validateProps.AllowedTypes.string,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Fieldset = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.label = '';
	        this.labelSize = 'medium';
	        this.required = false;
	        this.state = 'none';
	        this.message = '';
	        this.theme = 'light';
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.state, this.labelSize, stateMessageStyles.hasLabel(this.host, this.label), this.theme);
	        const hasMessageValue = stateMessageStyles.hasMessage(this.host, this.message, this.state);
	        return (validateProps.h("fieldset", { key: '3e5d3faeb56f14364b2b05ca9160bcf9be3a034e', "aria-describedby": hasMessageValue ? stateMessageStyles.messageId : null }, stateMessageStyles.hasLabel(this.host, this.label) && (validateProps.h("legend", { key: '240f14e82719c9484df00f42b3970202ea0992b0' }, this.label || validateProps.h("slot", { key: '77300ba14251bfd27dfabe82923b3bb9ed7b299a', name: "label" }), this.required && validateProps.h(stateMessageStyles.Required, { key: '2d815208ca5ae6dfcda0d5727b1678845e745983' }))), validateProps.h("slot", { key: '72de6fcfa568676b18ed294509c8b9e8412584fe' }), validateProps.h(stateMessageStyles.StateMessage, { key: 'c438ab5e9ea0c9e2e6145fd6613447896962d074', state: this.state, message: this.message, theme: this.theme, host: this.host })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pFieldset_cjs_entry.p_fieldset = Fieldset;

	
	return pFieldset_cjs_entry;
}

var pFlex_2_cjs_entry = {};

var throwIfParentIsNotOfKindE0807bbc = {};

var hasRequiredThrowIfParentIsNotOfKindE0807bbc;

function requireThrowIfParentIsNotOfKindE0807bbc () {
	if (hasRequiredThrowIfParentIsNotOfKindE0807bbc) return throwIfParentIsNotOfKindE0807bbc;
	hasRequiredThrowIfParentIsNotOfKindE0807bbc = 1;

	const validateProps = requireValidateProps788e2bc5();
	const isParentOfKind = requireIsParentOfKind4b323732();

	const throwIfParentIsNotOfKind = (element, tagNameOrNames) => {
	    if (element.parentElement) {
	        const tagNamesArray = Array.isArray(tagNameOrNames) ? tagNameOrNames : [tagNameOrNames];
	        const matches = tagNamesArray.some((tagName) => isParentOfKind.isParentOfKind(element, tagName));
	        if (!matches) {
	            const allowedTagNames = tagNamesArray
	                .map((tagName) => validateProps.getPrefixedTagNames(element)[validateProps.paramCaseToCamelCase(tagName)])
	                .join(' | ');
	            const actualTagName = validateProps.getTagName(element.parentElement);
	            validateProps.throwException(`parent HTMLElement of ${validateProps.getTagName(element)} should be of kind ${allowedTagNames} but got ${actualTagName}.`);
	        }
	    }
	};

	throwIfParentIsNotOfKindE0807bbc.throwIfParentIsNotOfKind = throwIfParentIsNotOfKind;

	
	return throwIfParentIsNotOfKindE0807bbc;
}

var hasRequiredPFlex_2_cjs_entry;

function requirePFlex_2_cjs_entry () {
	if (hasRequiredPFlex_2_cjs_entry) return pFlex_2_cjs_entry;
	hasRequiredPFlex_2_cjs_entry = 1;

	Object.defineProperty(pFlex_2_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const warnIfDeprecatedComponentIsUsed = requireWarnIfDeprecatedComponentIsUsedB14eebd2();
	const throwIfParentIsNotOfKind = requireThrowIfParentIsNotOfKindE0807bbc();
	requireIsParentOfKind4b323732();

	const FLEX_WRAPS = ['nowrap', 'wrap', 'wrap-reverse'];
	const FLEX_DIRECTIONS = ['row', 'row-reverse', 'column', 'column-reverse'];
	const FLEX_JUSTIFY_CONTENTS = [
	    'flex-start',
	    'flex-end',
	    'center',
	    'space-between',
	    'space-around',
	    'space-evenly',
	];
	const FLEX_ALIGN_ITEMS = ['stretch', 'flex-start', 'flex-end', 'center', 'baseline'];
	const FLEX_ALIGN_CONTENTS = [
	    'stretch',
	    'flex-start',
	    'flex-end',
	    'center',
	    'space-between',
	    'space-around',
	    'space-evenly',
	];
	const deprecatedFlexComponentMessage = 'Please use native CSS Flex (https://css-tricks.com/snippets/css/a-guide-to-flexbox) instead for better performance and more standardized layout technique.';

	const getComponentCss$1 = (inline, wrap, direction, justifyContent, alignItems, alignContent) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                ...validateProps.buildResponsiveStyles(inline, (inlineResponsive) => ({
	                    display: inlineResponsive ? 'inline-flex' : 'flex',
	                })),
	                ...validateProps.addImportantToEachRule(validateProps.mergeDeep(colorSchemeStyles.colorSchemeStyles, colorSchemeStyles.hostHiddenStyles, validateProps.buildResponsiveStyles(wrap, (flexWrapResponsive) => ({ flexWrap: flexWrapResponsive })), validateProps.buildResponsiveStyles(direction, (flexDirectionResponsive) => ({
	                    flexDirection: flexDirectionResponsive,
	                })), validateProps.buildResponsiveStyles(justifyContent, (justifyContentResponsive) => ({
	                    justifyContent: justifyContentResponsive,
	                })), validateProps.buildResponsiveStyles(alignItems, (alignItemsResponsive) => ({
	                    alignItems: alignItemsResponsive,
	                })), validateProps.buildResponsiveStyles(alignContent, (alignContentResponsive) => ({
	                    alignContent: alignContentResponsive,
	                })))),
	            },
	        },
	    });
	};

	const propTypes$1 = {
	    inline: validateProps.AllowedTypes.breakpoint('boolean'),
	    wrap: validateProps.AllowedTypes.breakpoint(FLEX_WRAPS),
	    direction: validateProps.AllowedTypes.breakpoint(FLEX_DIRECTIONS),
	    justifyContent: validateProps.AllowedTypes.breakpoint(FLEX_JUSTIFY_CONTENTS),
	    alignItems: validateProps.AllowedTypes.breakpoint(FLEX_ALIGN_ITEMS),
	    alignContent: validateProps.AllowedTypes.breakpoint(FLEX_ALIGN_CONTENTS),
	};
	const Flex = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.inline = false;
	        this.wrap = 'nowrap';
	        this.direction = 'row';
	        this.justifyContent = 'flex-start';
	        this.alignItems = 'stretch';
	        this.alignContent = 'stretch';
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes$1);
	        warnIfDeprecatedComponentIsUsed.warnIfDeprecatedComponentIsUsed(this.host, deprecatedFlexComponentMessage);
	        validateProps.attachComponentCss(this.host, getComponentCss$1, this.inline, this.wrap, this.direction, this.justifyContent, this.alignItems, this.alignContent);
	        return validateProps.h("slot", { key: 'e8a429d95c2e59e4a67de2c6a9d3d9d4e6d9654d' });
	    }
	    get host() { return validateProps.getElement(this); }
	};

	const FLEX_ITEM_WIDTHS = [
	    'auto',
	    'one-quarter',
	    'one-third',
	    'half',
	    'two-thirds',
	    'three-quarters',
	    'full',
	];
	const FLEX_ITEM_OFFSETS = ['none', 'one-quarter', 'one-third', 'half', 'two-thirds', 'three-quarters'];
	const FLEX_ITEM_ALIGN_SELFS = ['auto', 'flex-start', 'flex-end', 'center', 'baseline', 'stretch'];
	const FLEX_ITEM_GROWS = [0, 1];
	const FLEX_ITEM_SHRINKS = [0, 1];
	const FLEX_ITEM_FLEXS = ['initial', 'auto', 'none', 'equal'];

	const flexItemWidths = {
	    none: 0,
	    'one-quarter': 25,
	    'one-third': 33.333333,
	    half: 50,
	    'two-thirds': 66.666667,
	    'three-quarters': 75,
	    full: 100,
	    auto: 'auto',
	};
	const getComponentCss = (width, offset, alignSelf, grow, shrink, flex) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': validateProps.addImportantToEachRule({
	                boxSizing: 'border-box',
	                ...colorSchemeStyles.hostHiddenStyles,
	                ...validateProps.mergeDeep(validateProps.buildResponsiveStyles(width, (widthResponsive) => ({
	                    width: `${flexItemWidths[widthResponsive]}%`,
	                })), validateProps.buildResponsiveStyles(offset, (offsetResponsive) => ({
	                    marginLeft: `${flexItemWidths[offsetResponsive]}%`,
	                })), validateProps.buildResponsiveStyles(alignSelf, (alignSelfResponsive) => ({
	                    alignSelf: alignSelfResponsive,
	                })), flex !== 'initial' // flex shorthand conflicts with grow and shrink, which means even default grow or shrink props would override flex
	                    ? validateProps.buildResponsiveStyles(flex, (flexResponsive) => ({
	                        flex: flexResponsive === 'equal' ? '1 1 0' : flexResponsive,
	                    }))
	                    : validateProps.mergeDeep(validateProps.buildResponsiveStyles(grow, (flexGrow) => ({ flexGrow })), validateProps.buildResponsiveStyles(shrink, (flexShrink) => ({ flexShrink })))),
	            }),
	        },
	    });
	};

	const propTypes = {
	    width: validateProps.AllowedTypes.breakpoint(FLEX_ITEM_WIDTHS),
	    offset: validateProps.AllowedTypes.breakpoint(FLEX_ITEM_OFFSETS),
	    alignSelf: validateProps.AllowedTypes.breakpoint(FLEX_ITEM_ALIGN_SELFS),
	    grow: validateProps.AllowedTypes.breakpoint(FLEX_ITEM_GROWS),
	    shrink: validateProps.AllowedTypes.breakpoint(FLEX_ITEM_SHRINKS),
	    flex: validateProps.AllowedTypes.breakpoint(FLEX_ITEM_FLEXS),
	};
	const FlexItem = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.width = 'auto';
	        this.offset = 'none';
	        this.alignSelf = 'auto';
	        this.grow = 0;
	        this.shrink = 1;
	        this.flex = 'initial';
	    }
	    connectedCallback() {
	        throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-flex');
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedComponentIsUsed.warnIfDeprecatedComponentIsUsed(this.host, deprecatedFlexComponentMessage);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.width, this.offset, this.alignSelf, this.grow, this.shrink, this.flex);
	        return validateProps.h("slot", { key: '559c9b03f0ddebedb4b2bdf27c568cebc3127041' });
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pFlex_2_cjs_entry.p_flex = Flex;
	pFlex_2_cjs_entry.p_flex_item = FlexItem;

	
	return pFlex_2_cjs_entry;
}

var pFlyoutMultilevel_2_cjs_entry = {};

var setScrollLock68edfbd1 = {};

var hasRequiredSetScrollLock68edfbd1;

function requireSetScrollLock68edfbd1 () {
	if (hasRequiredSetScrollLock68edfbd1) return setScrollLock68edfbd1;
	hasRequiredSetScrollLock68edfbd1 = 1;

	const setScrollLock = (isOpen) => {
	    // This doesn't work reliably in iOS Safari with collapsed address bar where body is still scrollable
	    // there are libraries like `body-scroll-lock` and `body-scroll-lock-upgrade` which advertise to handle it, but they
	    // rely on event manipulation and also don't work reliable
	    // https://github.com/willmcpo/body-scroll-lock/blob/master/src/bodyScrollLock.js
	    // https://github.com/rick-liruixin/body-scroll-lock-upgrade/blob/develop/src/body-scroll-lock.ts
	    // Since solutions where the html and body nodes are manipulated can cause all kinds of other problems, we keep this simple solution for now
	    document.body.style.overflow = isOpen ? 'hidden' : '';
	};

	setScrollLock68edfbd1.setScrollLock = setScrollLock;

	
	return setScrollLock68edfbd1;
}

var spacingFluidXSmall0dd753ae = {};

var hasRequiredSpacingFluidXSmall0dd753ae;

function requireSpacingFluidXSmall0dd753ae () {
	if (hasRequiredSpacingFluidXSmall0dd753ae) return spacingFluidXSmall0dd753ae;
	hasRequiredSpacingFluidXSmall0dd753ae = 1;

	const spacingFluidXSmall = 'clamp(4px, 0.25vw + 3px, 8px)';

	spacingFluidXSmall0dd753ae.spacingFluidXSmall = spacingFluidXSmall;

	
	return spacingFluidXSmall0dd753ae;
}

var hasRequiredPFlyoutMultilevel_2_cjs_entry;

function requirePFlyoutMultilevel_2_cjs_entry () {
	if (hasRequiredPFlyoutMultilevel_2_cjs_entry) return pFlyoutMultilevel_2_cjs_entry;
	hasRequiredPFlyoutMultilevel_2_cjs_entry = 1;

	Object.defineProperty(pFlyoutMultilevel_2_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const setScrollLock = requireSetScrollLock68edfbd1();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const getMediaQueryMax = requireGetMediaQueryMax5b73ea17();
	const spacingFluidMedium = requireSpacingFluidMedium88ab712b();
	const frostedGlassStyle = requireFrostedGlassStyleBd067e45();
	const spacingFluidXSmall = requireSpacingFluidXSmall0dd753ae();
	const spacingFluidLarge = requireSpacingFluidLarge6087a0f7();
	const spacingFluidSmall = requireSpacingFluidSmall2c6caae7();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const isElementOfKind = requireIsElementOfKindF7da6ac6();
	const throwIfParentIsNotOfKind = requireThrowIfParentIsNotOfKindE0807bbc();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const headingSmallStyle = requireHeadingSmallStyle43f95761();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();
	const textMediumStyle = requireTextMediumStyle59c59854();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	requireIsParentOfKind4b323732();
	requireHeadingShared888aa084();
	requireFontFamily23874d28();
	requireFontLineHeightD4b9e1a9();
	requireFontWeightSemiBold4482c830();
	requireFontVariant6ba3b7cb();
	requireFontSizeHeadingSmallA15141a5();
	requireFontSizeTextSmall508930e5();
	requireTextShared5216bb19();
	requireFontWeightRegularD0c768ac();
	requireFontSizeTextMedium88887ad8();

	const getHTMLElementOfKind = (element, tagName) => {
	    const children = Array.from(element.querySelectorAll(tagName));
	    const prefixedElementTagName = validateProps.getPrefixedTagNames(element)[validateProps.paramCaseToCamelCase(tagName)];
	    return Array.from(children).filter((el) => validateProps.getTagName(el) === prefixedElementTagName);
	};

	const scrollerWidthDesktop = 'clamp(338px, 210px + 18vw, 640px)';
	const mediaQueryMobile = getMediaQueryMax.getMediaQueryMax('s');
	const mediaQueryDesktop = validateProps.getMediaQueryMin('s');
	const dialogDurationOpen = 'moderate';
	const backdropDurationOpen = 'long';
	const easingOpen = 'in';
	const dialogDurationClose = 'short';
	const backdropDurationClose = 'moderate';
	const easingClose = 'out';
	// ensures that the scrollbar color is mostly set correctly
	const scrollerBackground = {
	    light: 'rgba(255,255,255,.01)',
	    dark: 'rgba(0,0,0,.01)',
	    auto: 'rgba(255,255,255,.01)',
	};
	const getComponentCss$1 = (isOpen, isPrimary, isSecondaryScrollerVisible, theme) => {
	    const { backgroundColor, backgroundSurfaceColor, backgroundShadingColor } = validateProps.getThemedColors(theme);
	    const { backgroundColor: backgroundColorDark, backgroundSurfaceColor: backgroundSurfaceColorDark, backgroundShadingColor: backgroundShadingColorDark, } = validateProps.getThemedColors('dark');
	    return validateProps.getCss({
	        '@global': {
	            '@keyframes slide-up-mobile': {
	                from: { transform: `translate3d(0,${spacingFluidMedium.spacingFluidMedium},0)` },
	                to: { transform: 'translate3d(0,0,0)' },
	            },
	            // unfortunately, it's not possible to use transform animation like in mobile view
	            // because then a new stacking context within scroll container would be initialized
	            // causing the slotted scroll container to become invisible
	            '@keyframes slide-up-desktop': {
	                from: { marginBlockStart: spacingFluidMedium.spacingFluidMedium },
	                to: { marginBlockStart: '0px' },
	            },
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            dialog: {
	                all: 'unset',
	                position: 'fixed',
	                inset: 0,
	                zIndex: 999999999, // fallback when dialog isn't rendered on #top-layer, e.g. relevant in ssr context or fade-out transition in Safari or Firefox
	                outline: 0, // prevents outline in case dialog becomes focusable
	                ...(isOpen
	                    ? {
	                        visibility: 'inherit',
	                        ...frostedGlassStyle.frostedGlassStyle,
	                        background: backgroundShadingColor,
	                        transition: `${validateProps.getTransition('background', backdropDurationOpen, easingOpen)}, ${validateProps.getTransition('backdrop-filter', backdropDurationOpen, easingOpen)}, ${validateProps.getTransition('-webkit-backdrop-filter', backdropDurationOpen, easingOpen)}`,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            background: backgroundShadingColorDark,
	                        }),
	                    }
	                    : {
	                        visibility: 'hidden',
	                        transition: `visibility 0s linear var(${validateProps.cssVariableTransitionDuration}, ${validateProps.motionDurationMap[backdropDurationClose]}), ${validateProps.getTransition('overlay', backdropDurationClose, easingClose)} allow-discrete, ${validateProps.getTransition('background', backdropDurationClose, easingClose)}, ${validateProps.getTransition('backdrop-filter', backdropDurationClose, easingClose)}, ${validateProps.getTransition('-webkit-backdrop-filter', backdropDurationClose, easingClose)}`,
	                    }),
	                '&::backdrop': {
	                    display: 'none',
	                },
	            },
	            slot: {
	                [mediaQueryMobile]: {
	                    display: 'contents',
	                    ...(!isSecondaryScrollerVisible && {
	                        zIndex: 0,
	                        display: 'flex',
	                        flexDirection: 'column',
	                        gap: spacingFluidXSmall.spacingFluidXSmall,
	                        gridArea: '4/2/auto/-2',
	                        height: 'fit-content', // ensures padding bottom is added instead of subtracted because of grid context
	                        paddingBlockEnd: spacingFluidLarge.spacingFluidLarge,
	                        ...(isPrimary && {
	                            animation: validateProps.getAnimation('slide-up-mobile', 'moderate', 'base'),
	                        }),
	                    }),
	                },
	                [mediaQueryDesktop]: {
	                    display: 'flex',
	                    flexDirection: 'column',
	                    gap: isPrimary ? spacingFluidXSmall.spacingFluidXSmall : spacingFluidMedium.spacingFluidMedium,
	                    gridArea: '2/2/auto/-2',
	                    height: 'fit-content', // ensures padding bottom is added instead of subtracted because of grid context
	                    paddingBlockEnd: spacingFluidLarge.spacingFluidLarge,
	                    ...(isPrimary && {
	                        animation: validateProps.getAnimation('slide-up-desktop', 'moderate', 'base'),
	                    }),
	                },
	            },
	            ...(isSecondaryScrollerVisible && {
	                '::slotted(*:not([primary],[secondary],[cascade]))': {
	                    [mediaQueryMobile]: {
	                        display: 'none',
	                    },
	                },
	                '::slotted(*:not([primary],[cascade]))': {
	                    [mediaQueryDesktop]: {
	                        ...(!isPrimary && {
	                            display: 'none',
	                        }),
	                    },
	                },
	            }),
	        },
	        drawer: {
	            position: 'absolute',
	            inset: 0,
	            display: 'grid',
	            ...(isOpen
	                ? {
	                    opacity: 1,
	                    transform: 'translate3d(0,0,0)',
	                    transition: `${validateProps.getTransition('opacity', dialogDurationOpen, easingOpen)}, ${validateProps.getTransition('transform', dialogDurationOpen, easingOpen)}`,
	                }
	                : {
	                    opacity: 0,
	                    transform: 'translate3d(-100%,0,0)',
	                    transition: `${validateProps.getTransition('opacity', dialogDurationClose, easingClose)}, ${validateProps.getTransition('transform', dialogDurationClose, easingClose)}`,
	                    '&:dir(rtl)': {
	                        transform: 'translate3d(100%,0,0)',
	                    },
	                }),
	            [mediaQueryMobile]: {
	                gridTemplate: `${spacingFluidMedium.spacingFluidMedium} auto ${spacingFluidLarge.spacingFluidLarge} minmax(0, 1fr)/${spacingFluidLarge.spacingFluidLarge} auto minmax(0, 1fr) auto ${spacingFluidLarge.spacingFluidLarge}`,
	                background: backgroundColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    background: backgroundColorDark,
	                }),
	            },
	            [mediaQueryDesktop]: {
	                width: isSecondaryScrollerVisible ? `calc(${scrollerWidthDesktop} * 2)` : scrollerWidthDesktop,
	                gridTemplate: `${spacingFluidMedium.spacingFluidMedium} minmax(0, 1fr)/repeat(${isSecondaryScrollerVisible ? 2 : 1}, ${spacingFluidLarge.spacingFluidLarge} minmax(0, 1fr) ${spacingFluidLarge.spacingFluidLarge})`,
	                background: backgroundColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    background: backgroundColorDark,
	                }),
	                ...(isSecondaryScrollerVisible && {
	                    background: `linear-gradient(90deg,${backgroundColor} 0%,${backgroundColor} 50%,${backgroundSurfaceColor} 50%,${backgroundSurfaceColor} 100%)`,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        background: `linear-gradient(90deg,${backgroundColorDark} 0%,${backgroundColorDark} 50%,${backgroundSurfaceColorDark} 50%,${backgroundSurfaceColorDark} 100%)`,
	                    }),
	                    '&:dir(rtl)': {
	                        background: `linear-gradient(90deg,${backgroundSurfaceColor} 0%,${backgroundSurfaceColor} 50%,${backgroundColor} 50%,${backgroundColor} 100%)`,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            background: `linear-gradient(90deg,${backgroundSurfaceColorDark} 0%,${backgroundSurfaceColorDark} 50%,${backgroundColorDark} 50%,${backgroundColorDark} 100%)`,
	                        }),
	                    },
	                }),
	            },
	            '&::before, &::after': {
	                content: '""',
	                position: 'relative',
	                zIndex: 2,
	                pointerEvents: 'none',
	                opacity: 0,
	            },
	            '&::before': {
	                [mediaQueryMobile]: {
	                    gridArea: '1/1/-1/-1',
	                    background: backgroundColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        background: backgroundColorDark,
	                    }),
	                },
	                [mediaQueryDesktop]: {
	                    gridArea: '1/1/-1/4',
	                    background: backgroundColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        background: backgroundColorDark,
	                    }),
	                },
	            },
	            '&::after': {
	                [mediaQueryMobile]: {
	                    gridArea: '1/1/-1/-1',
	                    background: backgroundColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        background: backgroundColorDark,
	                    }),
	                },
	                [mediaQueryDesktop]: {
	                    gridArea: '1/4/-1/-1',
	                    background: backgroundSurfaceColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        background: backgroundSurfaceColorDark,
	                    }),
	                },
	            },
	        },
	        scroller: {
	            display: 'contents',
	            overflow: 'hidden auto',
	            // scrollBehavior: 'smooth', // when defined, `.scrollTo()` isn't applied immediately
	            // overscrollBehaviorY: 'none', // when defined, rubber band scroll effect is getting lost on iOS Safari
	            // WebkitOverflowScrolling: 'touch', // when defined, secondary scroller might not be show in iOS Safari on iPhone only
	            background: scrollerBackground[theme],
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                background: scrollerBackground.dark,
	            }),
	            [mediaQueryMobile]: {
	                ...(!isSecondaryScrollerVisible && {
	                    gridArea: '1/1/-1/-1',
	                    display: 'grid',
	                    gridTemplateRows: 'subgrid',
	                    gridTemplateColumns: 'subgrid',
	                    '&::before': {
	                        content: '""',
	                        position: 'sticky',
	                        top: 0,
	                        gridArea: '1/1/4/-1',
	                        zIndex: 1,
	                        background: `linear-gradient(180deg,${backgroundColor} 0%,${backgroundColor} 65%,transparent 100%)`,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            background: `linear-gradient(180deg,${backgroundColorDark} 0%,${backgroundColorDark} 65%,transparent 100%)`,
	                        }),
	                    },
	                }),
	            },
	            [mediaQueryDesktop]: {
	                gridArea: '1/1/-1/4',
	                display: 'grid',
	                gridTemplateRows: 'subgrid',
	                gridTemplateColumns: 'subgrid',
	            },
	        },
	        'dismiss-mobile': {
	            [mediaQueryMobile]: {
	                ...validateProps.dismissButtonJssStyle,
	                width: 'fit-content',
	                height: 'fit-content',
	                placeSelf: 'center flex-end',
	                gridArea: '2/4',
	                zIndex: 3, // ensures dismiss button is on top of opacity animation handled by ::before/::after
	                marginInlineEnd: '-1px', // improve visual alignment and compensate white space of close icon
	            },
	            [mediaQueryDesktop]: {
	                display: 'none',
	            },
	        },
	        'dismiss-desktop': {
	            [mediaQueryMobile]: {
	                display: 'none',
	            },
	            [mediaQueryDesktop]: {
	                '--p-internal-icon-filter': 'invert(1)',
	                position: 'absolute',
	                insetInlineStart: `calc(100% + ${spacingFluidSmall.spacingFluidSmall})`,
	                insetBlockStart: spacingFluidSmall.spacingFluidSmall,
	                padding: spacingStaticSmall.spacingStaticSmall,
	            },
	        },
	        back: {
	            display: 'none',
	            ...(isSecondaryScrollerVisible && {
	                [mediaQueryMobile]: {
	                    display: 'block',
	                    gridArea: '2/2',
	                    width: 'fit-content',
	                    height: 'fit-content',
	                    placeSelf: 'center flex-start',
	                    zIndex: 2,
	                },
	            }),
	        },
	    });
	};

	const FLYOUT_MULTILEVEL_ARIA_ATTRIBUTES = ['aria-label'];
	const INTERNAL_UPDATE_EVENT_NAME = 'internalUpdate';
	/**
	 * Updates the state of the flyout multilevel and its children based on the provided activeItem and value.
	 *
	 * @param {string | undefined} activeItem - The flyout-multilevel-item element which is currently active (which has the activeIdentifier as identifier). If undefined, updates the root element.
	 * @param {boolean} value - The new state value to apply.
	 * @returns {void}
	 */
	const updateFlyoutMultiLevelItemState = (activeItem, value) => {
	    activeItem.secondary = value;
	    traverseTreeAndUpdateState(activeItem.parentElement, 'primary', value);
	};
	/**
	 * Recursively updates the state of a flyout item's parent elements by traversing up the DOM tree.
	 *
	 * @param {HTMLPFlyoutMultilevelItemElement} activeItem - The current flyout item being updated.
	 * @param {'primary' | 'secondary' | 'cascade'} prop - The property of the flyout item to update.
	 * @param {boolean} value - The new state value to apply.
	 */
	const traverseTreeAndUpdateState = (activeItem, prop, value) => {
	    if (isElementOfKind.isElementOfKind(activeItem, 'p-flyout-multilevel-item')) {
	        activeItem[prop] = value;
	        traverseTreeAndUpdateState(activeItem.parentElement, 'cascade', value);
	    }
	};
	/**
	 * Synchronizes the provided theme to all items in the given array by updating each item's theme property.
	 * Ensures that updates are reflected by forcing a component update.
	 *
	 * @param {Theme} theme - The theme to apply to all items.
	 * @param {Item[]} items - The array of items whose theme will be updated.
	 */
	const syncThemeToItems = (theme, items) => {
	    for (const item of items) {
	        item.theme = theme;
	        validateProps.forceUpdate(item);
	    }
	};
	const validateActiveIdentifier = (instance, items, activeIdentifier) => {
	    if (activeIdentifier !== undefined) {
	        const matchingItems = items.filter((item) => item.identifier === activeIdentifier);
	        if (matchingItems.length === 0) {
	            logInvalidIdentifierError(instance, activeIdentifier);
	        }
	        else if (matchingItems.length > 1) {
	            logMultipleIdentifierError(instance, activeIdentifier, matchingItems);
	        }
	    }
	};
	const logInvalidIdentifierError = (instance, activeIdentifier) => validateProps.consoleError(`Invalid value '${activeIdentifier}' supplied to ${validateProps.getTagNameWithoutPrefix(instance.host)} for property 'activeIdentifier' because reference is not present.`);
	const logMultipleIdentifierError = (instance, activeIdentifier, matchingItems) => validateProps.consoleError(`Found multiple matching items for value '${activeIdentifier}' supplied to ${validateProps.getTagNameWithoutPrefix(instance.host)}:`, ...matchingItems);

	const propTypes$1 = {
	    activeIdentifier: validateProps.AllowedTypes.string,
	    open: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    aria: validateProps.AllowedTypes.aria(FLYOUT_MULTILEVEL_ARIA_ATTRIBUTES),
	};
	const FlyoutMultilevel = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.dismiss = validateProps.createEvent(this, "dismiss", 3);
	        this.update = validateProps.createEvent(this, "update", 3);
	        this.isDesktop = false;
	        this.matchMediaQueryS = window.matchMedia(`(min-width: ${validateProps.breakpointS}px)`);
	        this.defineFlyoutMultilevelItemElements = () => {
	            this.flyoutMultilevelItemElements = getHTMLElementOfKind(this.host, 'p-flyout-multilevel-item');
	        };
	        this.onClickDialog = (e) => {
	            if (e.target.tagName === 'DIALOG') {
	                // dismiss dialog when clicked on backdrop
	                this.dismissDialog();
	            }
	        };
	        this.onCancelDialog = (e) => {
	            // prevent closing the dialog uncontrolled by ESC (only relevant for browsers supporting <dialog/>)
	            e.preventDefault();
	            this.dismissDialog();
	        };
	        this.dismissDialog = () => {
	            this.dismiss.emit();
	        };
	        this.handleMediaQueryS = (e) => {
	            this.isDesktop = !!e.matches;
	        };
	        this.open = false;
	        this.activeIdentifier = undefined;
	        this.aria = undefined;
	        this.theme = 'light';
	        this.flyoutMultilevelItemElements = [];
	        this.primary = true;
	        this.isSecondaryDrawerVisible = !!this.activeIdentifier;
	    }
	    openChangeHandler(isOpen) {
	        setScrollLock.setScrollLock(isOpen);
	    }
	    async activeIdentifierChangeHandler(newVal, oldVal) {
	        await this.updateFlyoutMultiLevelState(oldVal, newVal);
	    }
	    themeChangeHandler(theme) {
	        syncThemeToItems(theme, this.flyoutMultilevelItemElements);
	    }
	    onInternalUpdate(e) {
	        e.stopPropagation(); // prevents internal event from bubbling further
	        const activeIdentifier = e.detail.activeIdentifier;
	        this.update.emit({ activeIdentifier });
	    }
	    connectedCallback() {
	        this.handleMediaQueryS(this.matchMediaQueryS);
	        this.matchMediaQueryS.addEventListener('change', this.handleMediaQueryS);
	    }
	    async componentWillLoad() {
	        this.defineFlyoutMultilevelItemElements();
	        syncThemeToItems(this.theme, this.flyoutMultilevelItemElements);
	        const activeItem = this.flyoutMultilevelItemElements.find((item) => item.identifier === this.activeIdentifier);
	        activeItem && updateFlyoutMultiLevelItemState(activeItem, true); // Set item state
	        this.primary = !activeItem || activeItem.parentElement === this.host;
	    }
	    componentDidLoad() {
	        if (this.open) {
	            setScrollLock.setScrollLock(true);
	            this.setDialogVisibility(true);
	        }
	        validateProps.getShadowRootHTMLElement(this.host, 'slot').addEventListener('slotchange', this.defineFlyoutMultilevelItemElements);
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    componentDidRender() {
	        // showModal needs to be called after render cycle to prepare visibility states of dialog in order to focus the dismiss button correctly
	        this.setDialogVisibility(this.open);
	    }
	    disconnectedCallback() {
	        setScrollLock.setScrollLock(false);
	        this.matchMediaQueryS.removeEventListener('change', this.handleMediaQueryS);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes$1);
	        validateActiveIdentifier(this, this.flyoutMultilevelItemElements, this.activeIdentifier);
	        validateProps.attachComponentCss(this.host, getComponentCss$1, this.open, this.primary, this.isSecondaryDrawerVisible, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h("dialog", { key: '96a9002bc13af6b42d573773ad5b907bd993ed65', inert: !this.open, ref: (ref) => (this.dialog = ref), ...validateProps.parseAndGetAriaAttributes(this.aria), onCancel: this.onCancelDialog, onClick: this.onClickDialog }, validateProps.h("div", { key: '9987356722efa05effaf2a764709296c17f375d9', class: "drawer", ref: (ref) => (this.drawer = ref) }, validateProps.h(PrefixedTagNames.pButtonPure, { key: '90a2deb2387fa4fe6188dd5afad4914da4480d77', class: "back", type: "button", size: "small", alignLabel: "end", stretch: true, icon: "arrow-left", theme: this.theme, hideLabel: true, onClick: () => this.emitCloseSecondaryUpdate() }, "Back"), validateProps.h(PrefixedTagNames.pButton, { key: '5710ee7d00c8dffbe0312c230f85d9ebb02ea2c5', class: "dismiss-mobile", type: "button", variant: "ghost", hideLabel: true, icon: "close", theme: this.theme, onClick: this.dismissDialog }, "Dismiss flyout"), validateProps.h(PrefixedTagNames.pButtonPure, { key: '03a0f691b9b7917dd398da27957d16f9651acd85', class: "dismiss-desktop", type: "button", size: "medium", icon: "close", hideLabel: true, theme: this.theme, onClick: this.dismissDialog }, "Dismiss flyout"), validateProps.h("div", { key: '079c26ed9820c3cd8a3692ce3aa7577db5a2814b', class: "scroller" }, validateProps.h("slot", { key: 'e1376e4242afe28ac008e876eb42bad1dd5333ab' })))));
	    }
	    setDialogVisibility(isOpen) {
	        // Only call showModal/close on dialog when state changes
	        if (isOpen === true && !this.dialog.open) {
	            this.dialog.showModal();
	        }
	        else if (isOpen === false && this.dialog.open) {
	            this.dialog.close();
	        }
	    }
	    async updateFlyoutMultiLevelState(oldVal, newVal) {
	        const oldItem = oldVal && this.flyoutMultilevelItemElements.find((item) => item.identifier === oldVal);
	        const newItem = newVal && this.flyoutMultilevelItemElements.find((item) => item.identifier === newVal);
	        // Secondary Drawer is closed => only update state
	        if (!newItem) {
	            if (this.isDesktop) {
	                this.updateStates(oldItem, newItem);
	            }
	            else {
	                const animation = this.animateDrawerFade('::after', 'out');
	                await animation.finished;
	                this.updateStates(oldItem, newItem);
	                this.animateDrawerFade('::after', 'in');
	            }
	        }
	        // Secondary Drawer is opened => update state + fade in
	        if (!oldItem) {
	            if (this.isDesktop) {
	                this.updateStates(oldItem, newItem);
	                this.animateDrawerFade('::after', 'in');
	            }
	            else {
	                const animation = this.animateDrawerFade('::after', 'out');
	                await animation.finished;
	                this.updateStates(oldItem, newItem);
	                this.animateDrawerFade('::after', 'in');
	            }
	        }
	        // Active item is changed => fade out + update state + fade in
	        if (newItem && oldItem) {
	            const isHierarchyChanged = oldItem.parentElement !== newItem.parentElement;
	            const animations = [
	                this.animateDrawerFade('::after', 'out'),
	                isHierarchyChanged && this.animateDrawerFade('::before', 'out'),
	            ].filter(Boolean);
	            await Promise.all(animations.map((a) => a.finished));
	            this.updateStates(oldItem, newItem);
	            isHierarchyChanged && this.animateDrawerFade('::before', 'in');
	            this.animateDrawerFade('::after', 'in');
	        }
	    }
	    emitCloseSecondaryUpdate() {
	        this.update.emit({ activeIdentifier: undefined });
	    }
	    updateStates(oldItem, newItem) {
	        this.primary = !oldItem || !newItem || newItem.parentElement === this.host;
	        this.isSecondaryDrawerVisible = !!this.activeIdentifier;
	        oldItem && updateFlyoutMultiLevelItemState(oldItem, false); // Reset old item state
	        newItem && updateFlyoutMultiLevelItemState(newItem, true); // Set new item state
	    }
	    animateDrawerFade(pseudoElement, direction) {
	        const keyframes = direction === 'in' ? [{ opacity: 1 }, { opacity: 0 }] : [{ opacity: 0 }, { opacity: 1 }];
	        const duration = direction === 'in' ? 400 : 150;
	        return this.drawer?.animate(keyframes, { duration, pseudoElement });
	    }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "open": ["openChangeHandler"],
	        "activeIdentifier": ["activeIdentifierChangeHandler"],
	        "theme": ["themeChangeHandler"]
	    }; }
	};

	const getComponentCss = (isPrimary, isSecondary, isCascade, theme) => {
	    const { primaryColor, backgroundColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, backgroundColor: backgroundColorDark } = validateProps.getThemedColors('dark');
	    return validateProps.getCss({
	        '@global': {
	            '@keyframes slide-up-mobile': {
	                from: { transform: `translate3d(0,${spacingFluidMedium.spacingFluidMedium},0)` },
	                to: { transform: 'translate3d(0,0,0)' },
	            },
	            '@keyframes slide-up-desktop-primary': {
	                from: { marginBlockStart: spacingFluidMedium.spacingFluidMedium },
	                to: { marginBlockStart: '0px' },
	            },
	            '@keyframes slide-up-desktop-secondary': {
	                from: { marginBlockStart: spacingFluidMedium.spacingFluidMedium },
	                to: { marginBlockStart: '0px' },
	            },
	            ':host': {
	                display: 'contents',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            slot: {
	                display: 'none',
	                [mediaQueryMobile]: {
	                    ...(isSecondary && {
	                        zIndex: 0,
	                        display: 'flex',
	                        flexDirection: 'column',
	                        gap: spacingFluidXSmall.spacingFluidXSmall,
	                        gridArea: '4/2/auto/-2',
	                        height: 'fit-content', // ensures padding bottom is added instead of subtracted because of grid context
	                        paddingBlockEnd: spacingFluidLarge.spacingFluidLarge,
	                        animation: validateProps.getAnimation('slide-up-mobile', 'moderate', 'base'),
	                    }),
	                    ...((isPrimary || isCascade) && {
	                        display: 'contents',
	                    }),
	                },
	                [mediaQueryDesktop]: {
	                    ...((isPrimary || isSecondary) && {
	                        display: 'flex',
	                        flexDirection: 'column',
	                        gap: spacingFluidXSmall.spacingFluidXSmall,
	                        height: 'fit-content', // ensures padding bottom is added instead of subtracted because of grid context
	                        animation: validateProps.getAnimation(`slide-up-desktop-${isPrimary ? 'primary' : 'secondary'}`, 'moderate', 'base'),
	                    }),
	                    ...(isSecondary && {
	                        gridArea: '2/2/auto/-2',
	                        paddingBlockEnd: spacingFluidLarge.spacingFluidLarge,
	                    }),
	                    ...(isCascade && {
	                        display: 'contents',
	                    }),
	                },
	            },
	            h2: {
	                display: 'none',
	                [mediaQueryMobile]: {
	                    ...(isSecondary && {
	                        ...headingSmallStyle.headingSmallStyle,
	                        display: 'block',
	                        gridArea: '2/3',
	                        placeSelf: 'center',
	                        zIndex: 2,
	                        margin: 0,
	                        paddingInline: spacingStaticMedium.spacingStaticMedium,
	                        maxWidth: '100%',
	                        boxSizing: 'border-box',
	                        whiteSpace: 'nowrap',
	                        overflow: 'hidden',
	                        textOverflow: 'ellipsis',
	                        color: primaryColor, // enables color inheritance for slotted content
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            color: primaryColorDark,
	                        }),
	                    }),
	                },
	            },
	            // If cascade we need to hide all children which are not primary or another cascade (e.g. all siblings of the primary or cascade item)
	            ...(isCascade && {
	                '::slotted(*:not([primary],[cascade]))': {
	                    display: 'none',
	                },
	            }),
	            ...(isPrimary && {
	                '::slotted(*:not([secondary]))': {
	                    [mediaQueryMobile]: {
	                        display: 'none',
	                    },
	                },
	            }),
	            '::slotted': {
	                '&(a)': {
	                    all: 'unset',
	                    alignSelf: 'flex-start',
	                    font: textMediumStyle.textMediumStyle.font,
	                    cursor: 'pointer',
	                    borderRadius: borderRadiusSmall.borderRadiusSmall,
	                    padding: validateProps.addImportantToRule(spacingFluidSmall.spacingFluidSmall),
	                    marginInline: validateProps.addImportantToRule(`calc(${spacingFluidSmall.spacingFluidSmall} * -1)`),
	                    color: primaryColor,
	                    textDecoration: 'underline',
	                    textDecorationColor: 'transparent',
	                    transition: `${validateProps.getTransition('text-decoration-color')}`,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        color: primaryColorDark,
	                    }),
	                },
	                '&(a[aria-current])': {
	                    textDecoration: 'underline',
	                },
	                ...hoverMediaQuery.hoverMediaQuery({
	                    '&(a:hover)': {
	                        textDecorationColor: 'inherit',
	                    },
	                }),
	                ...validateProps.getFocusJssStyle(theme, { slotted: 'a', offset: '-2px' }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	        },
	        // drawer subgrid in combination with scroller grid ensures no content squeezing during slide up animation, potentially caused by scrollbar
	        drawer: {
	            [mediaQueryMobile]: {
	                display: 'none',
	                ...((isPrimary || isSecondary || isCascade) && {
	                    display: 'contents',
	                }),
	            },
	            [mediaQueryDesktop]: {
	                display: 'none',
	                ...(isSecondary && {
	                    position: 'absolute', // enables to break out of scroll area
	                    inset: 0,
	                    insetInlineStart: scrollerWidthDesktop,
	                    display: 'grid',
	                    gridTemplate: `${spacingFluidMedium.spacingFluidMedium} minmax(0, 1fr)/${spacingFluidLarge.spacingFluidLarge} minmax(0, 1fr) ${spacingFluidLarge.spacingFluidLarge}`,
	                }),
	                ...((isPrimary || isCascade) && {
	                    display: 'contents',
	                }),
	            },
	        },
	        scroller: {
	            display: 'none',
	            overflow: 'hidden auto',
	            // scrollBehavior: 'smooth', // when defined, `.scrollTo()` isn't applied immediately
	            // overscrollBehaviorY: 'none', // when defined, rubber band scroll effect is getting lost on iOS Safari
	            // WebkitOverflowScrolling: 'touch', // when defined, secondary scroller might not be show in iOS Safari on iPhone only
	            background: scrollerBackground[theme],
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                background: scrollerBackground.dark,
	            }),
	            [mediaQueryMobile]: {
	                ...(isSecondary && {
	                    display: 'grid',
	                    gridTemplateRows: 'subgrid',
	                    gridTemplateColumns: 'subgrid',
	                    gridArea: '1/1/-1/-1',
	                    '&::before': {
	                        zIndex: 1,
	                        content: '""',
	                        position: 'sticky',
	                        top: 0,
	                        gridArea: '1/1/4/-1',
	                        background: `linear-gradient(180deg,${backgroundColor} 0%,${backgroundColor} 65%,transparent 100%)`,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            background: `linear-gradient(180deg,${backgroundColorDark} 0%,${backgroundColorDark} 65%,transparent 100%)`,
	                        }),
	                    },
	                }),
	                ...((isPrimary || isCascade) && {
	                    display: 'contents',
	                }),
	            },
	            [mediaQueryDesktop]: {
	                ...(isSecondary && {
	                    gridArea: '1/1/-1/-1',
	                    display: 'grid',
	                    gridTemplateRows: 'subgrid',
	                    gridTemplateColumns: 'subgrid',
	                }),
	                ...((isPrimary || isCascade) && {
	                    display: 'contents',
	                }),
	            },
	        },
	        button: {
	            ...((isPrimary || isCascade) && {
	                display: 'none',
	            }),
	            [mediaQueryMobile]: {
	                ...(isSecondary && {
	                    display: 'none',
	                }),
	            },
	            ...(!isPrimary &&
	                !isCascade && {
	                padding: spacingFluidSmall.spacingFluidSmall,
	                margin: `0 calc(${spacingFluidSmall.spacingFluidSmall} * -1)`,
	            }),
	        },
	        back: {
	            ...(!isPrimary && {
	                display: 'none',
	            }),
	            ...(isPrimary && {
	                [mediaQueryMobile]: {
	                    gridArea: '2/2',
	                    width: 'fit-content',
	                    height: 'fit-content',
	                    placeSelf: 'center flex-start',
	                    zIndex: 2,
	                },
	                [mediaQueryDesktop]: {
	                    width: 'fit-content',
	                    height: 'fit-content',
	                    marginInlineStart: '-4px', // improve visual alignment and compensate white space of arrow-left icon
	                },
	            }),
	        },
	    });
	};

	const propTypes = {
	    identifier: validateProps.AllowedTypes.string,
	    label: validateProps.AllowedTypes.string,
	    cascade: validateProps.AllowedTypes.boolean,
	    secondary: validateProps.AllowedTypes.boolean,
	    primary: validateProps.AllowedTypes.boolean,
	};
	const FlyoutMultilevelItem = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.onClickButton = () => {
	            if (isElementOfKind.isElementOfKind(this.host.parentElement, 'p-flyout-multilevel')) {
	                this.secondary ? this.emitInternalUpdateEvent(undefined) : this.emitInternalUpdateEvent(this.identifier);
	            }
	            else if (!this.secondary) {
	                this.emitInternalUpdateEvent(this.identifier);
	            }
	        };
	        this.label = undefined;
	        this.identifier = undefined;
	        this.primary = false;
	        this.secondary = false;
	        this.cascade = false;
	    }
	    get theme() {
	        return this.host.theme || 'light'; // default as fallback (internal private prop is controlled by flyout-multilevel)
	    }
	    connectedCallback() {
	        throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, ['p-flyout-multilevel', 'p-flyout-multilevel-item']);
	    }
	    componentDidRender() {
	        this.scroller.scrollTo(0, 0); // Reset scroll position when navigated
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.primary, this.secondary, this.cascade, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(validateProps.Host, { key: '02fe6e74eefd47c6e8adbc9541f0d6ee7ed5a19c' }, validateProps.h(PrefixedTagNames.pButtonPure, { key: 'd2663ee686bb1a76c3d18d58c67c56e6546da658', inert: this.primary || this.cascade, class: "button", type: "button", size: "medium", alignLabel: "start", stretch: true, icon: "arrow-head-right", active: this.secondary, aria: { 'aria-expanded': this.secondary }, theme: this.theme, onClick: () => this.onClickButton() }, this.label), validateProps.h(PrefixedTagNames.pButtonPure, { key: '6211fcaa92e0c5745355f887ec2f556bcec5021a', class: "back", type: "button", size: "small", alignLabel: "end", stretch: true, icon: "arrow-left", theme: this.theme, hideLabel: { base: true, s: false }, onClick: () => this.emitInternalUpdateEvent(this.identifier) }, this.label), validateProps.h("h2", { key: '89a312210373a8f5622cfd02718c1cd5c09d6cd6' }, this.label), validateProps.h("div", { key: '596d4479976f540aa12bcc5b2e1e0e070d347f7c', class: "drawer" }, validateProps.h("div", { key: '75f9bd0528782ee3edc55e4a8f6684f16fd18125', class: "scroller", ref: (ref) => (this.scroller = ref) }, validateProps.h("slot", { key: '5381649421e3970842014818d47af53d42100dac' })))));
	    }
	    emitInternalUpdateEvent(activeIdentifier) {
	        this.host.dispatchEvent(new CustomEvent(INTERNAL_UPDATE_EVENT_NAME, {
	            bubbles: true,
	            detail: { activeIdentifier },
	        }));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pFlyoutMultilevel_2_cjs_entry.p_flyout_multilevel = FlyoutMultilevel;
	pFlyoutMultilevel_2_cjs_entry.p_flyout_multilevel_item = FlyoutMultilevelItem;

	
	return pFlyoutMultilevel_2_cjs_entry;
}

var pFlyout_cjs_entry = {};

var hasRequiredPFlyout_cjs_entry;

function requirePFlyout_cjs_entry () {
	if (hasRequiredPFlyout_cjs_entry) return pFlyout_cjs_entry;
	hasRequiredPFlyout_cjs_entry = 1;

	Object.defineProperty(pFlyout_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const getSlotTextContent = requireGetSlotTextContent3ec731e2();
	const hasNamedSlot = requireHasNamedSlot273cd3ae();
	const dialogStyles = requireDialogStyles52804ea9();
	const observer = requireObserver98c271bc();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed91ceea3c();
	const setScrollLock = requireSetScrollLock68edfbd1();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const spacingFluidSmall = requireSpacingFluidSmall2c6caae7();
	const spacingFluidMedium = requireSpacingFluidMedium88ab712b();
	requireGetNamedSlot223c478a();
	requireSpacingFluidLarge6087a0f7();
	requireGridGapB5b73e4a();
	requireSpacingStaticMedium94812711();
	requireFrostedGlassStyleBd067e45();
	requireHelper22e15c0e();

	const cssVariableWidth = '--p-flyout-width';
	// TODO: we shouldn't expose --p-flyout-max-width
	const cssVariableMaxWidth = '--p-flyout-max-width';
	const getComponentCss = (isOpen, position, hasHeader, hasFooter, hasSubFooter, footerBehavior, theme) => {
	    const isPositionStart = position === 'start' || position === 'left';
	    const isFooterFixed = footerBehavior === 'fixed';
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...dialogStyles.dialogHostJssStyle,
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            slot: {
	                display: 'block',
	                '&:first-of-type': {
	                    gridRowStart: 1,
	                },
	                '&:not([name])': {
	                    gridColumn: '2/3',
	                    zIndex: 0, // controls layering + creates new stacking context (prevents content within to be above other dialog areas)
	                    ...(isFooterFixed &&
	                        hasHeader && {
	                        gridRow: 2,
	                    }),
	                },
	                ...(hasHeader && {
	                    '&[name=header]': {
	                        ...dialogStyles.getDialogStickyAreaJssStyle('header', theme),
	                        gridColumn: '1/-1',
	                        zIndex: 3, // controls layering + creates new stacking context (prevents content within to be above other dialog areas)
	                        ...(isFooterFixed && {
	                            gridRow: 1,
	                        }),
	                        marginBlockStart: 0,
	                    },
	                }),
	                ...(hasFooter && {
	                    '&[name=footer]': {
	                        ...dialogStyles.getDialogStickyAreaJssStyle('footer', theme),
	                        gridColumn: '1/-1',
	                        zIndex: 2, // controls layering + creates new stacking context (prevents content within to be above other dialog areas)
	                        ...(isFooterFixed && {
	                            gridRow: hasHeader ? 3 : 2,
	                            ...(!hasSubFooter && {
	                                marginBlockEnd: '.3px', // lets the footer shadow disappear when flyout is scrolled to the bottom
	                            }),
	                        }),
	                    },
	                }),
	                ...(hasSubFooter && {
	                    '&[name=sub-footer]': {
	                        gridColumn: '2/3',
	                        zIndex: 1, // controls layering + creates new stacking context (prevents content within to be above other dialog areas)
	                    },
	                }),
	            },
	            dialog: dialogStyles.getDialogJssStyle(isOpen, theme),
	        },
	        scroller: {
	            ...dialogStyles.getScrollerJssStyle(isPositionStart ? 'start' : 'end', theme),
	            // compared to Modal, the transition is handled on the scroller to have correct stucked behaviour (visibility of drop shadow)
	            // for sticky header area while transitioned
	            ...dialogStyles.getDialogTransitionJssStyle(isOpen, isPositionStart ? '>' : '<'),
	            // Though this might be an accessibility issue, we don't want an outline to be rendered until we have a proper design solution
	            '&:focus-visible': {
	                outline: 'none',
	            },
	        },
	        flyout: {
	            ...dialogStyles.dialogGridJssStyle,
	            ...dialogStyles.getDialogColorJssStyle(theme),
	            width: `var(${cssVariableWidth},auto)`,
	            minWidth: '320px',
	            maxWidth: `var(${cssVariableMaxWidth},1180px)`,
	            ...(hasHeader && {
	                paddingBlockStart: 0,
	            }),
	            ...(isFooterFixed &&
	                !hasSubFooter && {
	                paddingBlockEnd: 0,
	            }),
	            ...(isFooterFixed && {
	                gridTemplateRows: hasHeader ? 'auto 1fr auto' : '1fr',
	                '&::before': {
	                    content: '""',
	                    minHeight: hasHeader ? '100dvh' : `calc(100dvh - ${dialogStyles.dialogPaddingBlock})`,
	                    gridArea: `1/1/${hasHeader ? '4' : '3'}/-1`,
	                    pointerEvents: 'none',
	                },
	            }),
	        },
	        dismiss: {
	            ...validateProps.dismissButtonJssStyle,
	            gridArea: '1/3',
	            zIndex: 4, // ensures dismiss button is above everything
	            position: 'sticky',
	            insetBlockStart: spacingFluidSmall.spacingFluidSmall,
	            insetInlineEnd: spacingFluidSmall.spacingFluidSmall,
	            marginBlockStart: `calc(${spacingFluidMedium.spacingFluidMedium} * -1)`,
	            placeSelf: 'flex-start flex-end',
	        },
	    });
	};

	// 'left' is deprecated and will be mapped to 'start'
	/** @deprecated */
	const FLYOUT_POSITIONS_DEPRECATED = ['left', 'right'];
	const FLYOUT_POSITIONS = ['start', 'end', ...FLYOUT_POSITIONS_DEPRECATED];
	const FLYOUT_FOOTER_BEHAVIOR = ['sticky', 'fixed'];
	const FLYOUT_ARIA_ATTRIBUTES = ['aria-label'];
	/**
	 * Map of flyout instances and their corresponding resize observers to update the experimental css property --p-flyout-sticky-top.
	 */
	const stickyTopCssVarResizeObserverMap = new Map();
	/**
	 * Map of flyout instances and their corresponding css stylesheets including the experimental css property --p-flyout-sticky-top.
	 */
	const stickyTopCssVarStyleSheetMap = new Map();
	// Called once in didLoad for setup
	const addStickyTopCssVarStyleSheet = (host) => {
	    if (validateProps.getHasConstructableStylesheetSupport()) {
	        stickyTopCssVarStyleSheetMap.set(host, new CSSStyleSheet());
	        // It's very important to create and push the stylesheet after `attachComponentCss()` has been called, otherwise styles might replace each other.
	        // TODO: for some reason unit test in Docker environment throws TS2339: Property 'push' does not exist on type 'readonly CSSStyleSheet[]'
	        /* eslint-disable @typescript-eslint/prefer-ts-expect-error, @typescript-eslint/ban-ts-comment */
	        // @ts-ignore
	        host.shadowRoot.adoptedStyleSheets.push(stickyTopCssVarStyleSheetMap.get(host));
	        updateStickyTopCssVarStyleSheet(host, 0);
	    }
	};
	// Called whenever component updates
	const handleUpdateStickyTopCssVar = (host, hasHeader, header) => {
	    if (validateProps.getHasConstructableStylesheetSupport()) {
	        // Create resize observer if none exists but is needed (State changes from !hasHeader -> hasHeader or initially)
	        if (hasHeader && !stickyTopCssVarResizeObserverMap.has(host)) {
	            stickyTopCssVarResizeObserverMap.set(host, getStickyTopResizeObserver(host));
	            stickyTopCssVarResizeObserverMap.get(host).observe(header);
	        }
	        // Remove resize observer if one exists but isn't needed anymore (State changes from hasHeader -> !hasHeader)
	        else if (!hasHeader && stickyTopCssVarResizeObserverMap.has(host)) {
	            updateStickyTopCssVarStyleSheet(host, 0);
	            stickyTopCssVarResizeObserverMap.get(host).disconnect();
	            stickyTopCssVarResizeObserverMap.delete(host);
	        }
	    }
	};
	const updateStickyTopCssVarStyleSheet = (host, value) => {
	    // EXPERIMENTAL CSS variable
	    stickyTopCssVarStyleSheetMap.get(host).replaceSync(`:host{--p-flyout-sticky-top:${value}px}`);
	};
	const getStickyTopResizeObserver = (host) => {
	    return new ResizeObserver((entries) => {
	        for (const entry of entries) {
	            updateStickyTopCssVarStyleSheet(host, Math.floor(entry.target.getBoundingClientRect().height));
	        }
	    });
	};

	const propTypes = {
	    open: validateProps.AllowedTypes.boolean,
	    position: validateProps.AllowedTypes.oneOf(FLYOUT_POSITIONS),
	    disableBackdropClick: validateProps.AllowedTypes.boolean,
	    footerBehavior: validateProps.AllowedTypes.oneOf(FLYOUT_FOOTER_BEHAVIOR),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    aria: validateProps.AllowedTypes.aria(FLYOUT_ARIA_ATTRIBUTES),
	};
	const Flyout = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.dismiss = validateProps.createEvent(this, "dismiss", 3);
	        this.motionVisibleEnd = validateProps.createEvent(this, "motionVisibleEnd", 3);
	        this.motionHiddenEnd = validateProps.createEvent(this, "motionHiddenEnd", 3);
	        this.dismissDialog = () => {
	            this.dismiss.emit();
	        };
	        this.updateSlotObserver = () => {
	            if (this.hasHeader) {
	                // When slots change dynamically the intersection observer for the scroll shadows has to be added
	                observer.observeStickyArea(this.scroller, this.header);
	            }
	            if (this.hasFooter) {
	                // When slots change dynamically the intersection observer for the scroll shadows has to be added
	                observer.observeStickyArea(this.scroller, this.footer);
	            }
	            // When header slot changes dynamically the resize observer and adopted stylesheet for the CSS custom property --p-flyout-sticky-top has to be updated
	            handleUpdateStickyTopCssVar(this.host, this.hasHeader, this.header);
	        };
	        this.open = false;
	        this.position = 'end';
	        this.disableBackdropClick = false;
	        this.footerBehavior = 'sticky';
	        this.theme = 'light';
	        this.aria = undefined;
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    connectedCallback() {
	        // Observe dynamic slot changes
	        validateProps.observeChildren(this.host, () => {
	            validateProps.forceUpdate(this.host);
	        }, undefined, { subtree: false, childList: true, attributes: false });
	    }
	    componentWillRender() {
	        setScrollLock.setScrollLock(this.open);
	    }
	    componentDidRender() {
	        dialogStyles.setDialogVisibility(this.open, this.dialog, this.scroller);
	    }
	    componentDidLoad() {
	        addStickyTopCssVarStyleSheet(this.host);
	        // Has to be called here instead of render to assure that the slot references are available
	        this.updateSlotObserver();
	    }
	    componentDidUpdate() {
	        // Has to be called here instead of render to assure that the slot references are available
	        this.updateSlotObserver();
	    }
	    disconnectedCallback() {
	        setScrollLock.setScrollLock(false);
	        validateProps.unobserveChildren(this.host);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        const positionDeprecationMap = {
	            left: 'start',
	            right: 'end',
	        };
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'position', positionDeprecationMap);
	        this.hasHeader = hasNamedSlot.hasNamedSlot(this.host, 'header');
	        this.hasFooter = hasNamedSlot.hasNamedSlot(this.host, 'footer');
	        this.hasSubFooter = hasNamedSlot.hasNamedSlot(this.host, 'sub-footer');
	        validateProps.attachComponentCss(this.host, getComponentCss, this.open, (positionDeprecationMap[this.position] || this.position), this.hasHeader, this.hasFooter, this.hasSubFooter, this.footerBehavior, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h("dialog", { key: 'bd275433a9a4388130945f896c2035d8a9c40cdf', tabIndex: -1, ref: (el) => (this.dialog = el), onCancel: (e) => dialogStyles.onCancelDialog(e, this.dismissDialog),
	            // Previously done with onMouseDown to change the click behavior (not closing when pressing mousedown on flyout and mouseup on backdrop) but changed back to native behavior
	            onClick: (e) => dialogStyles.onClickDialog(e, this.dismissDialog, this.disableBackdropClick), onTransitionEnd: (e) => dialogStyles.onTransitionEnd(e, this.open, this.motionVisibleEnd, this.motionHiddenEnd), ...validateProps.parseAndGetAriaAttributes({
	                'aria-modal': true,
	                ...{ 'aria-label': this.hasHeader ? getSlotTextContent.getSlotTextContent(this.host, 'header') : 'Flyout' },
	                ...validateProps.parseAndGetAriaAttributes(this.aria),
	            }) }, validateProps.h("div", { key: 'd8ba0ba4866a19769dd7dffd468002323c0a27be', class: "scroller", ref: (el) => (this.scroller = el) }, validateProps.h("div", { key: '2753db59a0038e446399f4a4416e53a0791c14ef', class: "flyout" }, validateProps.h(PrefixedTagNames.pButton, { key: '13e2c26bbc78ed0d3955c5cd0580c0b77b2542d7', variant: "ghost", class: "dismiss", type: "button", hideLabel: true, icon: "close", theme: this.theme, onClick: this.dismissDialog }, "Dismiss flyout"), this.hasHeader && validateProps.h("slot", { key: 'e9c203be468f2fa94f1bc84ee9cfbd9da5c7b42c', name: "header", ref: (el) => (this.header = el) }), validateProps.h("slot", { key: '45b1bdf3471ab70af0587ea0b66bfe00334c1c4b' }), this.hasFooter && validateProps.h("slot", { key: '398156b4612e32eab2df3962a48c770dc9ada2e9', name: "footer", ref: (el) => (this.footer = el) }), this.hasSubFooter && validateProps.h("slot", { key: 'b5bb9cf3ca06d227806514408699df3ad1f69659', name: "sub-footer" })))));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pFlyout_cjs_entry.p_flyout = Flyout;

	
	return pFlyout_cjs_entry;
}

var pGrid_2_cjs_entry = {};

var hasRequiredPGrid_2_cjs_entry;

function requirePGrid_2_cjs_entry () {
	if (hasRequiredPGrid_2_cjs_entry) return pGrid_2_cjs_entry;
	hasRequiredPGrid_2_cjs_entry = 1;

	Object.defineProperty(pGrid_2_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const gridGap = requireGridGapB5b73e4a();
	const warnIfDeprecatedComponentIsUsed = requireWarnIfDeprecatedComponentIsUsedB14eebd2();
	const throwIfParentIsNotOfKind = requireThrowIfParentIsNotOfKindE0807bbc();
	requireSpacingFluidMedium88ab712b();
	requireIsParentOfKind4b323732();

	const GRID_DIRECTIONS = ['row', 'row-reverse', 'column', 'column-reverse'];
	const GRID_WRAPS = ['nowrap', 'wrap'];
	const GRID_GUTTERS = [16, 24, 36];
	const deprecatedGridComponentMessage = 'Please use native CSS Grid (https://css-tricks.com/snippets/css/complete-guide-grid) instead in combination with the Porsche Grid utility based on CSS Grid.';

	const gutter$1 = `calc(${gridGap.gridGap} / -2)`;
	const getComponentCss$1 = (direction, wrap) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'flex',
	                ...validateProps.addImportantToEachRule({
	                    flex: 'auto',
	                    width: 'auto',
	                    marginLeft: gutter$1,
	                    marginRight: gutter$1,
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                    ...validateProps.mergeDeep(validateProps.buildResponsiveStyles(direction, (flexDirection) => ({ flexDirection })), validateProps.buildResponsiveStyles(wrap, (flexWrap) => ({ flexWrap }))),
	                }),
	            },
	        },
	    });
	};

	const propTypes$1 = {
	    direction: validateProps.AllowedTypes.breakpoint(GRID_DIRECTIONS),
	    wrap: validateProps.AllowedTypes.breakpoint(GRID_WRAPS),
	    gutter: validateProps.AllowedTypes.breakpoint(GRID_GUTTERS),
	};
	const Grid = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.direction = 'row';
	        this.wrap = 'wrap';
	        this.gutter = { base: 16, s: 24, m: 36 };
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes$1);
	        warnIfDeprecatedComponentIsUsed.warnIfDeprecatedComponentIsUsed(this.host, deprecatedGridComponentMessage);
	        validateProps.attachComponentCss(this.host, getComponentCss$1, this.direction, this.wrap);
	        return validateProps.h("slot", { key: 'f2da424b47c7628e16579667aec42cfaa7ee4c29' });
	    }
	    get host() { return validateProps.getElement(this); }
	};

	const GRID_ITEM_SIZES = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
	const GRID_ITEM_OFFSETS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];

	const gutter = `calc(${gridGap.gridGap} / 2)`;
	const gridItemWidths = [
	    0, 8.333333, 16.666667, 25, 33.333333, 41.666667, 50, 58.333333, 66.666667, 75, 83.333333, 91.666667, 100,
	];
	const getComponentCss = (size, offset) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': validateProps.addImportantToEachRule({
	                paddingLeft: gutter,
	                paddingRight: gutter,
	                boxSizing: 'border-box',
	                ...colorSchemeStyles.hostHiddenStyles,
	                ...validateProps.mergeDeep(validateProps.buildResponsiveStyles(size, (sizeResponsive) => ({
	                    width: `${gridItemWidths[sizeResponsive]}%`,
	                    minWidth: `${gridItemWidths[sizeResponsive]}%`,
	                })), validateProps.buildResponsiveStyles(offset, (offsetResponsive) => ({
	                    marginLeft: `${gridItemWidths[offsetResponsive]}%`,
	                }))),
	            }),
	        },
	    });
	};

	const propTypes = {
	    size: validateProps.AllowedTypes.breakpoint(GRID_ITEM_SIZES),
	    offset: validateProps.AllowedTypes.breakpoint(GRID_ITEM_OFFSETS),
	};
	const GridItem = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.size = 1;
	        this.offset = 0;
	    }
	    connectedCallback() {
	        throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-grid');
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedComponentIsUsed.warnIfDeprecatedComponentIsUsed(this.host, deprecatedGridComponentMessage);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.size, this.offset);
	        return validateProps.h("slot", { key: '0cf7faf8085d3cab2fb0fb3ede3a61eaaec6c054' });
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pGrid_2_cjs_entry.p_grid = Grid;
	pGrid_2_cjs_entry.p_grid_item = GridItem;

	
	return pGrid_2_cjs_entry;
}

var pHeading_cjs_entry = {};

var hasRequiredPHeading_cjs_entry;

function requirePHeading_cjs_entry () {
	if (hasRequiredPHeading_cjs_entry) return pHeading_cjs_entry;
	hasRequiredPHeading_cjs_entry = 1;

	Object.defineProperty(pHeading_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const typographyAlign = requireTypographyAlign844cd863();
	const headingTag = requireHeadingTag6cfe20fe();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed91ceea3c();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const typographyStyles = requireTypographyStyles226e4585();
	const fontSizeHeadingSmall = requireFontSizeHeadingSmallA15141a5();
	const fontSizeHeadingMedium = requireFontSizeHeadingMediumC49ab5a2();
	const fontSizeHeadingLarge = requireFontSizeHeadingLargeC355151d();
	const headingXXLargeStyle = requireHeadingXXLargeStyle0857cde1();
	const slottedAnchorStyles = requireSlottedAnchorStylesFe1a10c2();
	requireGetDirectChildHTMLElement18d9487f();
	requireTransformSelectorToDirectChildSelectorEcc1a9c4();
	requireHelper22e15c0e();
	requireFontSizeTextSmall508930e5();
	requireFontSizeTextMedium88887ad8();
	requireFontSizeTextLarge05a4bc90();
	requireFontSizeTextXLarge0ecf9ef3();
	requireHeadingShared888aa084();
	requireFontFamily23874d28();
	requireFontLineHeightD4b9e1a9();
	requireFontWeightSemiBold4482c830();
	requireFontVariant6ba3b7cb();
	requireBorderRadiusSmall5f37fc45();
	requireBorderRadiusMedium758b9411();

	const HEADING_SIZES = ['small', 'medium', 'large', 'x-large', 'xx-large', 'inherit'];

	const HEADING_COLORS = ['primary', 'inherit'];
	const headingSizeToTagMap = {
	    small: 'h6',
	    medium: 'h5',
	    large: 'h4',
	    'x-large': 'h3',
	    'xx-large': 'h2',
	    inherit: 'h2',
	};
	const getHeadingTagType = (host, size, tag) => {
	    if (typographyAlign.hasSpecificDirectChildTag(host, headingTag.HEADING_TAGS.join())) {
	        return 'div';
	    }
	    if (tag) {
	        return tag;
	    }
	    return headingSizeToTagMap[size] || 'h2';
	};

	const sizeMap = {
	    small: fontSizeHeadingSmall.fontSizeHeadingSmall,
	    medium: fontSizeHeadingMedium.fontSizeHeadingMedium,
	    large: fontSizeHeadingLarge.fontSizeHeadingLarge,
	    'x-large': headingXXLargeStyle.fontSizeHeadingXLarge,
	    'xx-large': headingXXLargeStyle.fontSizeHeadingXXLarge,
	};
	const getComponentCss = (size, align, color, ellipsis, theme) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            [`::slotted(:is(${headingTag.HEADING_TAGS.join()}))`]: validateProps.addImportantToEachRule(typographyStyles.getTypographySlottedJssStyle()),
	        },
	        root: typographyStyles.getTypographyRootJssStyle(headingXXLargeStyle.headingXXLargeStyle, validateProps.buildResponsiveStyles(size, (sizeValue) => ({
	            fontSize: sizeValue === 'inherit' ? sizeValue : sizeMap[sizeValue],
	        })), align, color, ellipsis, theme),
	    });
	};

	const propTypes = {
	    tag: validateProps.AllowedTypes.oneOf([undefined, ...headingTag.HEADING_TAGS]),
	    size: validateProps.AllowedTypes.breakpoint(HEADING_SIZES),
	    align: validateProps.AllowedTypes.oneOf(typographyAlign.TYPOGRAPHY_ALIGNS),
	    color: validateProps.AllowedTypes.oneOf(HEADING_COLORS),
	    ellipsis: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Heading = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.tag = undefined;
	        this.size = 'xx-large';
	        this.align = 'start';
	        this.color = 'primary';
	        this.ellipsis = false;
	        this.theme = 'light';
	    }
	    connectedCallback() {
	        validateProps.applyConstructableStylesheetStyles(this.host, slottedAnchorStyles.getSlottedAnchorStyles);
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        const alignDeprecationMap = {
	            left: 'start',
	            right: 'end',
	        };
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'align', alignDeprecationMap);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.size, (alignDeprecationMap[this.align] || this.align), this.color, this.ellipsis, this.theme);
	        const TagType = getHeadingTagType(this.host, this.size, this.tag);
	        return (validateProps.h(TagType, { key: '5001bdf00bf4cd792e37d1c5eed67a633ea330a5', class: "root" }, validateProps.h("slot", { key: '90d07a3aa74aee279e556dd134644ba38a2454af' })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pHeading_cjs_entry.p_heading = Heading;

	
	return pHeading_cjs_entry;
}

var pHeadline_cjs_entry = {};

var hasRequiredPHeadline_cjs_entry;

function requirePHeadline_cjs_entry () {
	if (hasRequiredPHeadline_cjs_entry) return pHeadline_cjs_entry;
	hasRequiredPHeadline_cjs_entry = 1;

	Object.defineProperty(pHeadline_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const typographyAlign = requireTypographyAlign844cd863();
	const warnIfDeprecatedComponentIsUsed = requireWarnIfDeprecatedComponentIsUsedB14eebd2();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const typographyStyles = requireTypographyStyles226e4585();
	const headingXXLargeStyle = requireHeadingXXLargeStyle0857cde1();
	const fontSizeHeadingLarge = requireFontSizeHeadingLargeC355151d();
	const fontSizeHeadingMedium = requireFontSizeHeadingMediumC49ab5a2();
	const fontSizeHeadingSmall = requireFontSizeHeadingSmallA15141a5();
	const fontSizeTextXXSmall = requireFontSizeTextXXSmallA02f9c40();
	const fontSizeTextXSmall = requireFontSizeTextXSmallE59d35d7();
	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();
	const fontSizeTextMedium = requireFontSizeTextMedium88887ad8();
	const fontSizeTextLarge = requireFontSizeTextLarge05a4bc90();
	const fontSizeTextXLarge = requireFontSizeTextXLarge0ecf9ef3();
	const displayShared = requireDisplaySharedAdef5fa6();
	const slottedAnchorStyles = requireSlottedAnchorStylesFe1a10c2();
	requireGetDirectChildHTMLElement18d9487f();
	requireTransformSelectorToDirectChildSelectorEcc1a9c4();
	requireHeadingShared888aa084();
	requireFontFamily23874d28();
	requireFontLineHeightD4b9e1a9();
	requireFontWeightSemiBold4482c830();
	requireFontVariant6ba3b7cb();
	requireFontWeightRegularD0c768ac();
	requireBorderRadiusSmall5f37fc45();
	requireBorderRadiusMedium758b9411();

	const displayMediumStyle = {
	    font: `${displayShared._displayFontPartA}${displayShared.fontSizeDisplayMedium}${displayShared._displayFontPartB}`,
	};

	const HEADLINE_VARIANTS = [
	    'large-title',
	    'headline-1',
	    'headline-2',
	    'headline-3',
	    'headline-4',
	    'headline-5',
	];
	const HEADLINE_TAGS = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
	const HEADLINE_COLORS = ['primary', 'default', 'inherit'];
	const isValidVariantType = (variant) => {
	    return HEADLINE_VARIANTS.includes(variant);
	};
	const variantToTagMap = {
	    'large-title': 'h1',
	    'headline-1': 'h1',
	    'headline-2': 'h2',
	    'headline-3': 'h3',
	    'headline-4': 'h4',
	    'headline-5': 'h5',
	};
	const getHeadlineTagType = (host, variant, tag) => {
	    if (typographyAlign.hasSpecificDirectChildTag(host, HEADLINE_TAGS.join())) {
	        return 'div';
	    }
	    if (tag) {
	        return tag;
	    }
	    return variantToTagMap[variant] || 'h1';
	};

	const headlineSizeMap = {
	    'headline-1': headingXXLargeStyle.fontSizeHeadingXXLarge,
	    'headline-2': headingXXLargeStyle.fontSizeHeadingXLarge,
	    'headline-3': fontSizeHeadingLarge.fontSizeHeadingLarge,
	    'headline-4': fontSizeHeadingMedium.fontSizeHeadingMedium,
	    'headline-5': fontSizeHeadingSmall.fontSizeHeadingSmall,
	};
	const getHeadlineVariantJssStyle = (variant) => {
	    return {
	        ...(variant === 'large-title'
	            ? displayMediumStyle
	            : {
	                fontSize: headlineSizeMap[variant],
	            }),
	    };
	};
	const textSizeMap = {
	    'xx-small': fontSizeTextXXSmall.fontSizeTextXXSmall,
	    'x-small': fontSizeTextXSmall.fontSizeTextXSmall,
	    small: fontSizeTextSmall.fontSizeTextSmall,
	    medium: fontSizeTextMedium.fontSizeTextMedium,
	    large: fontSizeTextLarge.fontSizeTextLarge,
	    'x-large': fontSizeTextXLarge.fontSizeTextXLarge,
	};
	const getTextSizeJssStyle = (textSize) => {
	    return {
	        fontSize: textSize === 'inherit' ? textSize : textSizeMap[textSize],
	    };
	};
	const getComponentCss = (variant, align, color, ellipsis, theme) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            '::slotted': {
	                [HEADLINE_TAGS.map((i) => `&(${i})`).join()]: validateProps.addImportantToEachRule(typographyStyles.getTypographySlottedJssStyle()),
	            },
	        },
	        root: typographyStyles.getTypographyRootJssStyle(headingXXLargeStyle.headingXXLargeStyle, isValidVariantType(variant)
	            ? getHeadlineVariantJssStyle(variant)
	            : validateProps.buildResponsiveStyles(variant, getTextSizeJssStyle), align, color, ellipsis, theme),
	    });
	};

	const propTypes = {
	    // variant: AllowedTypes.string, // TODO: with all the different values this can't easily be validated
	    tag: validateProps.AllowedTypes.oneOf([undefined, ...HEADLINE_TAGS]),
	    align: validateProps.AllowedTypes.oneOf(typographyAlign.TYPOGRAPHY_ALIGNS),
	    color: validateProps.AllowedTypes.oneOf(HEADLINE_COLORS),
	    ellipsis: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Headline = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.variant = 'headline-1';
	        this.tag = undefined;
	        this.align = 'start';
	        this.color = 'primary';
	        this.ellipsis = false;
	        this.theme = 'light';
	    }
	    connectedCallback() {
	        validateProps.applyConstructableStylesheetStyles(this.host, slottedAnchorStyles.getSlottedAnchorStyles);
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedComponentIsUsed.warnIfDeprecatedComponentIsUsed(this.host, 'Please use new p-heading component instead.');
	        const alignDeprecationMap = {
	            left: 'start',
	            right: 'end',
	        };
	        validateProps.attachComponentCss(this.host, getComponentCss, this.variant, (alignDeprecationMap[this.align] || this.align), this.color, this.ellipsis, this.theme);
	        const TagType = getHeadlineTagType(this.host, this.variant, this.tag);
	        return (validateProps.h(TagType, { key: 'ac5eb80e34099ec0be0d15d1101b8f16129e6f2c', class: "root" }, validateProps.h("slot", { key: '8335110218ae5f8b1e8788fa1cccefd3be8630b4' })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pHeadline_cjs_entry.p_headline = Headline;

	
	return pHeadline_cjs_entry;
}

var pIcon_cjs_entry = {};

var typographyTextColor524bae09 = {};

var hasRequiredTypographyTextColor524bae09;

function requireTypographyTextColor524bae09 () {
	if (hasRequiredTypographyTextColor524bae09) return typographyTextColor524bae09;
	hasRequiredTypographyTextColor524bae09 = 1;

	/** @deprecated */
	const TYPOGRAPHY_TEXT_COLORS_DEPRECATED = [
	    'brand', // deprecated
	    'default', // deprecated
	    'neutral-contrast-low', // deprecated
	    'neutral-contrast-medium', // deprecated
	    'neutral-contrast-high', // deprecated
	    'notification-neutral', // deprecated
	];
	const TYPOGRAPHY_TEXT_COLORS = [
	    'primary',
	    'contrast-low',
	    'contrast-medium',
	    'contrast-high',
	    'notification-success',
	    'notification-warning',
	    'notification-error',
	    'notification-info',
	    'inherit',
	    ...TYPOGRAPHY_TEXT_COLORS_DEPRECATED,
	];

	typographyTextColor524bae09.TYPOGRAPHY_TEXT_COLORS = TYPOGRAPHY_TEXT_COLORS;

	
	return typographyTextColor524bae09;
}

var hasRequiredPIcon_cjs_entry;

function requirePIcon_cjs_entry () {
	if (hasRequiredPIcon_cjs_entry) return pIcon_cjs_entry;
	hasRequiredPIcon_cjs_entry = 1;

	Object.defineProperty(pIcon_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed91ceea3c();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed76f87eda();
	const theme = requireThemeBfc10573();
	const textSize = requireTextSizeBe3fca13();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const schemedHighContrastMediaQuery = requireSchemedHighContrastMediaQuery462417a0();
	const fontSizeTextXXSmall = requireFontSizeTextXXSmallA02f9c40();
	const fontSizeTextXSmall = requireFontSizeTextXSmallE59d35d7();
	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();
	const fontSizeTextMedium = requireFontSizeTextMedium88887ad8();
	const fontSizeTextLarge = requireFontSizeTextLarge05a4bc90();
	const fontSizeTextXLarge = requireFontSizeTextXLarge0ecf9ef3();
	const fontLineHeight = requireFontLineHeightD4b9e1a9();
	const fontFamily = requireFontFamily23874d28();
	const typographyTextColor = requireTypographyTextColor524bae09();
	const getCDNBaseURL = requireGetCDNBaseURLE7722df3();
	requireHelper22e15c0e();

	// index.ts
	var ICONS_MANIFEST = { "360": "360.0600731.svg", "4-wheel-drive": "4-wheel-drive.9c218bf.svg", "accessibility": "accessibility.087d747.svg", "active-cabin-ventilation": "active-cabin-ventilation.b081399.svg", "add": "add.fac861a.svg", "adjust": "adjust.ca46bd4.svg", "aggregation": "aggregation.96f06e5.svg", "arrow-compact-down": "arrow-compact-down.9b37afe.svg", "arrow-compact-left": "arrow-compact-left.7169de6.svg", "arrow-compact-right": "arrow-compact-right.cc2d1d2.svg", "arrow-compact-up": "arrow-compact-up.36724bb.svg", "arrow-double-down": "arrow-double-down.61ae4d7.svg", "arrow-double-left": "arrow-double-left.1b576eb.svg", "arrow-double-right": "arrow-double-right.dcfabff.svg", "arrow-double-up": "arrow-double-up.fb73db5.svg", "arrow-down": "arrow-down.49c6983.svg", "arrow-first": "arrow-first.beb7d9f.svg", "arrow-head-down": "arrow-head-down.1e3cbb8.svg", "arrow-head-left": "arrow-head-left.cf1395d.svg", "arrow-head-right": "arrow-head-right.304b330.svg", "arrow-head-up": "arrow-head-up.6d3fd23.svg", "arrow-last": "arrow-last.cc24903.svg", "arrow-left": "arrow-left.e03c25b.svg", "arrow-right": "arrow-right.872716b.svg", "arrow-up": "arrow-up.9d294d1.svg", "arrows": "arrows.de040f9.svg", "attachment": "attachment.8f3dd0a.svg", "augmented-reality": "augmented-reality.8b6ce95.svg", "battery-empty": "battery-empty.38b4b15.svg", "battery-empty-co2": "battery-empty-co2.c4cabef.svg", "battery-empty-fuel": "battery-empty-fuel.e833e13.svg", "battery-full": "battery-full.03de75d.svg", "battery-half": "battery-half.11f1ef8.svg", "battery-one-quarter": "battery-one-quarter.91235a0.svg", "battery-three-quarters": "battery-three-quarters.dcf768f.svg", "bell": "bell.1eab3a2.svg", "bookmark": "bookmark.9d6982f.svg", "bookmark-filled": "bookmark-filled.327ac78.svg", "brain": "brain.838387a.svg", "broadcast": "broadcast.0ad5a15.svg", "cabriolet": "cabriolet.ab33aab.svg", "calculator": "calculator.a323a2d.svg", "calendar": "calendar.70a6a12.svg", "camera": "camera.e5e95b9.svg", "car": "car.35229c9.svg", "car-battery": "car-battery.895510f.svg", "card": "card.f284448.svg", "charging-active": "charging-active.c3aa214.svg", "charging-network": "charging-network.a40072f.svg", "charging-state": "charging-state.f56d8df.svg", "charging-station": "charging-station.5ff1ed4.svg", "chart": "chart.c8c32d2.svg", "chat": "chat.7945544.svg", "check": "check.8ba06be.svg", "city": "city.5ae672c.svg", "climate": "climate.a9d5818.svg", "climate-control": "climate-control.ce31939.svg", "clock": "clock.c88a1ef.svg", "close": "close.eec3c5d.svg", "closed-caption": "closed-caption.ceaf6cb.svg", "cloud": "cloud.2c3959e.svg", "co2-class": "co2-class.fc49211.svg", "co2-emission": "co2-emission.c42e7f8.svg", "color-picker": "color-picker.598f402.svg", "compare": "compare.6578829.svg", "compass": "compass.f90f319.svg", "configurate": "configurate.5311c8d.svg", "copy": "copy.0fcd086.svg", "country-road": "country-road.d2bbc5a.svg", "coupe": "coupe.7549e3e.svg", "cubic-capacity": "cubic-capacity.7b0b8c8.svg", "cut": "cut.851e5c2.svg", "delete": "delete.5a8c8ca.svg", "disable": "disable.5918c32.svg", "dislike": "dislike.51614b0.svg", "dislike-filled": "dislike-filled.e1a8c4d.svg", "document": "document.df36b6c.svg", "door": "door.61c32d6.svg", "download": "download.c06f455.svg", "drag": "drag.9e893fd.svg", "duration": "duration.94e5252.svg", "ear": "ear.27a802f.svg", "edit": "edit.330f321.svg", "email": "email.f2530de.svg", "error": "error.b8ae9ad.svg", "error-filled": "error-filled.a4d06ed.svg", "exclamation": "exclamation.46cd17b.svg", "exclamation-filled": "exclamation-filled.9d09ed1.svg", "external": "external.fb677b9.svg", "fast-backward": "fast-backward.a71faae.svg", "fast-forward": "fast-forward.1e6fa9f.svg", "file-csv": "file-csv.4140e24.svg", "file-excel": "file-excel.56d577d.svg", "filter": "filter.610f808.svg", "fingerprint": "fingerprint.6a85170.svg", "flag": "flag.7af5baf.svg", "flash": "flash.88a2ada.svg", "fuel-station": "fuel-station.f7bdf51.svg", "garage": "garage.5014e8d.svg", "genuine-parts": "genuine-parts.6bfddde.svg", "geo-localization": "geo-localization.516d603.svg", "gift": "gift.7beb1eb.svg", "globe": "globe.56cc8fc.svg", "grid": "grid.06bc31a.svg", "grip": "grip.5ec4289.svg", "group": "group.051436a.svg", "hand": "hand.4e85714.svg", "heart": "heart.9a5962e.svg", "heart-filled": "heart-filled.dd7decf.svg", "highway": "highway.bf0eb24.svg", "highway-filled": "highway-filled.38e93fb.svg", "history": "history.f09645c.svg", "home": "home.7b1d1da.svg", "horn": "horn.bf47b1a.svg", "image": "image.b2614f0.svg", "increase": "increase.700012f.svg", "information": "information.da41162.svg", "information-filled": "information-filled.8f08911.svg", "key": "key.ee5d89b.svg", "laptop": "laptop.c422480.svg", "leaf": "leaf.92ca6a6.svg", "leather": "leather.1d2769a.svg", "light": "light.f0eb8e4.svg", "like": "like.a7468cd.svg", "like-filled": "like-filled.a0126c1.svg", "limousine": "limousine.87799d5.svg", "linked": "linked.8f30cb5.svg", "list": "list.411dd00.svg", "locate": "locate.6554f9e.svg", "lock": "lock.243281a.svg", "lock-open": "lock-open.95803d2.svg", "logo-apple-carplay": "logo-apple-carplay.c872af9.svg", "logo-apple-music": "logo-apple-music.1395f37.svg", "logo-apple-podcast": "logo-apple-podcast.09be038.svg", "logo-baidu": "logo-baidu.9e89c7d.svg", "logo-delicious": "logo-delicious.e83f574.svg", "logo-digg": "logo-digg.f096670.svg", "logo-facebook": "logo-facebook.74abe88.svg", "logo-foursquare": "logo-foursquare.d638fd8.svg", "logo-gmail": "logo-gmail.5f96ee2.svg", "logo-google": "logo-google.1dee423.svg", "logo-hatena": "logo-hatena.da509f0.svg", "logo-instagram": "logo-instagram.b916daa.svg", "logo-kaixin": "logo-kaixin.b1211a2.svg", "logo-kakaotalk": "logo-kakaotalk.38f5396.svg", "logo-kununu": "logo-kununu.79344ff.svg", "logo-linkedin": "logo-linkedin.b72559f.svg", "logo-naver": "logo-naver.75588fe.svg", "logo-pinterest": "logo-pinterest.e8f6963.svg", "logo-qq": "logo-qq.6d9b6d9.svg", "logo-qq-share": "logo-qq-share.ee864d9.svg", "logo-reddit": "logo-reddit.da13e44.svg", "logo-skyrock": "logo-skyrock.eb2f28d.svg", "logo-snapchat": "logo-snapchat.ef706a2.svg", "logo-sohu": "logo-sohu.a30c66b.svg", "logo-spotify": "logo-spotify.2ec4b2d.svg", "logo-tecent": "logo-tecent.d119e85.svg", "logo-telegram": "logo-telegram.d151481.svg", "logo-tiktok": "logo-tiktok.2f3a465.svg", "logo-tumblr": "logo-tumblr.c689f44.svg", "logo-twitter": "logo-twitter.5f2490a.svg", "logo-viber": "logo-viber.198bd43.svg", "logo-vk": "logo-vk.37b94e0.svg", "logo-wechat": "logo-wechat.83b2b98.svg", "logo-weibo": "logo-weibo.c8dacee.svg", "logo-whatsapp": "logo-whatsapp.add9a6d.svg", "logo-x": "logo-x.5f2490a.svg", "logo-xing": "logo-xing.3a8df0f.svg", "logo-yahoo": "logo-yahoo.8cbd0ba.svg", "logo-youku": "logo-youku.fe988d0.svg", "logo-youtube": "logo-youtube.da3798f.svg", "logout": "logout.7ec7451.svg", "map": "map.c16f618.svg", "menu-dots-horizontal": "menu-dots-horizontal.788f7fa.svg", "menu-dots-vertical": "menu-dots-vertical.4970a65.svg", "menu-lines": "menu-lines.e332216.svg", "microphone": "microphone.8ecdce6.svg", "minus": "minus.f6d964c.svg", "mobile": "mobile.7f35446.svg", "moon": "moon.5b73246.svg", "new-chat": "new-chat.95ffd2e.svg", "news": "news.5b604b0.svg", "north-arrow": "north-arrow.2da1dbe.svg", "oil-can": "oil-can.cb58fc7.svg", "online-search": "online-search.90e9ab1.svg", "parking-brake": "parking-brake.45704bd.svg", "parking-light": "parking-light.c49a231.svg", "paste": "paste.dd60261.svg", "pause": "pause.e41b935.svg", "phone": "phone.f4f774b.svg", "pin": "pin.3417cec.svg", "pin-filled": "pin-filled.7b8e9ba.svg", "pivot": "pivot.3ae18b8.svg", "play": "play.24226d4.svg", "plug": "plug.c159935.svg", "plus": "plus.319993e.svg", "preheating": "preheating.e2a796f.svg", "price-tag": "price-tag.f0d3917.svg", "printer": "printer.f59b0ee.svg", "purchase": "purchase.9cd6d65.svg", "push-pin": "push-pin.89e4ead.svg", "push-pin-off": "push-pin-off.ba99213.svg", "qr": "qr.87a49a3.svg", "qr-off": "qr-off.64e21b9.svg", "question": "question.3402a63.svg", "question-filled": "question-filled.cf25dd5.svg", "racing-flag": "racing-flag.b7ddcc8.svg", "radar": "radar.de5a6c1.svg", "radio": "radio.2b48e53.svg", "refresh": "refresh.41fd868.svg", "replay": "replay.55a99f2.svg", "reset": "reset.e53d52f.svg", "return": "return.46d30de.svg", "road": "road.bd3d4bc.svg", "roof-closed": "roof-closed.018d021.svg", "roof-open": "roof-open.51c8ee6.svg", "route": "route.f4fbbb4.svg", "rss": "rss.0e77baf.svg", "save": "save.6171ff5.svg", "screen": "screen.420be15.svg", "search": "search.3f0f1ce.svg", "seat": "seat.a3ebc40.svg", "send": "send.b32099c.svg", "service-technician": "service-technician.8749028.svg", "share": "share.a0b30da.svg", "shopping-bag": "shopping-bag.3f91a9b.svg", "shopping-bag-filled": "shopping-bag-filled.abf6c98.svg", "shopping-cart": "shopping-cart.370e224.svg", "shopping-cart-filled": "shopping-cart-filled.e0c3a65.svg", "sidebar": "sidebar.8e43896.svg", "sidelights": "sidelights.65c9dd9.svg", "skip-backward": "skip-backward.cd25ac5.svg", "skip-forward": "skip-forward.001e97f.svg", "snowflake": "snowflake.83907b3.svg", "sort": "sort.92b50bd.svg", "stack": "stack.804af93.svg", "star": "star.4c5bb15.svg", "star-filled": "star-filled.84ef2f6.svg", "steering-wheel": "steering-wheel.4dea19e.svg", "stop": "stop.173b6ac.svg", "stopwatch": "stopwatch.0e048a4.svg", "subtract": "subtract.57eed1d.svg", "success": "success.b16d4c1.svg", "success-filled": "success-filled.1832d98.svg", "sun": "sun.4301cbd.svg", "suv": "suv.33ac4aa.svg", "switch": "switch.66f74c4.svg", "tablet": "tablet.07341ac.svg", "tachometer": "tachometer.3a2fc3c.svg", "theme": "theme.08f6508.svg", "tire": "tire.e5c9372.svg", "trigger-finger": "trigger-finger.65aa6e2.svg", "truck": "truck.2c26c04.svg", "turismo": "turismo.a066b9f.svg", "unlinked": "unlinked.e9afe39.svg", "upload": "upload.d1f5a2a.svg", "user": "user.c18dabe.svg", "user-filled": "user-filled.2ea646d.svg", "user-group": "user-group.79cdf86.svg", "user-manual": "user-manual.470e243.svg", "video": "video.7590689.svg", "view": "view.5b4d7f6.svg", "view-off": "view-off.a4ede54.svg", "volume-off": "volume-off.bcd49e7.svg", "volume-up": "volume-up.2084f60.svg", "warning": "warning.59927e6.svg", "warning-filled": "warning-filled.1f6fe21.svg", "weather": "weather.9c96bd7.svg", "weight": "weight.b57a60d.svg", "wifi": "wifi.e2a8d9c.svg", "work": "work.9dd71a4.svg", "wrench": "wrench.09a2a67.svg", "wrenches": "wrenches.d2ed45d.svg", "zoom-in": "zoom-in.ff299b8.svg", "zoom-out": "zoom-out.ebb6246.svg" };

	const toFilter = (values) => `invert(${values[0]}%) sepia(${values[1]}%) saturate(${values[2]}%) hue-rotate(${values[3]}deg) brightness(${values[4]}%) contrast(${values[5]}%)`;

	const filterLightContrastLow = toFilter([93, 11, 36, 201, 89, 102]);
	const filterLightContrastMedium = toFilter([45, 6, 235, 177, 91, 85]);
	const filterLightContrastHigh = toFilter([40, 2, 686, 187, 80, 94]);
	const filterDarkContrastLow = toFilter([20, 7, 421, 202, 97, 82]);
	const filterDarkContrastMedium = toFilter([66, 3, 333, 187, 82, 86]);
	const filterDarkContrastHigh = toFilter([68, 6, 108, 187, 104, 88]);

	const filterLightDisabled = toFilter([63, 8, 108, 188, 94, 86]);
	const filterDarkDisabled = toFilter([52, 6, 135, 187, 94, 89]);

	const filterLightNotificationSuccess = toFilter([28, 89, 572, 71, 111, 98]);
	const filterLightNotificationWarning = toFilter([58, 53, 820, 12, 112, 103]);
	const filterLightNotificationError = toFilter([14, 75, 4140, 347, 100, 97]);
	const filterLightNotificationInfo = toFilter([44, 100, 492, 195, 86, 221]);
	const filterDarkNotificationSuccess = toFilter([60, 71, 512, 106, 91, 97]);
	const filterDarkNotificationWarning = toFilter([75, 39, 759, 350, 109, 94]);
	const filterDarkNotificationError = toFilter([64, 91, 5857, 336, 98, 102]);
	const filterDarkNotificationInfo = toFilter([56, 77, 4175, 198, 104, 98]);

	const filterLightPrimary = toFilter([3, 7, 2930, 188, 91, 103]);
	const filterDarkPrimary = toFilter([100, 91, 38, 254, 110, 110]);

	const sizeMap = {
	    'xx-small': fontSizeTextXXSmall.fontSizeTextXXSmall,
	    'x-small': fontSizeTextXSmall.fontSizeTextXSmall,
	    small: fontSizeTextSmall.fontSizeTextSmall,
	    medium: fontSizeTextMedium.fontSizeTextMedium,
	    large: fontSizeTextLarge.fontSizeTextLarge,
	    'x-large': fontSizeTextXLarge.fontSizeTextXLarge,
	};
	const filterLight = {
	    primary: filterLightPrimary,
	    'state-disabled': filterLightDisabled,
	    'contrast-low': filterLightContrastLow,
	    'contrast-medium': filterLightContrastMedium,
	    'contrast-high': filterLightContrastHigh,
	    'notification-success': filterLightNotificationSuccess,
	    'notification-warning': filterLightNotificationWarning,
	    'notification-error': filterLightNotificationError,
	    'notification-info': filterLightNotificationInfo,
	};
	const filterDark = {
	    primary: filterDarkPrimary,
	    'state-disabled': filterDarkDisabled,
	    'contrast-low': filterDarkContrastLow,
	    'contrast-medium': filterDarkContrastMedium,
	    'contrast-high': filterDarkContrastHigh,
	    'notification-success': filterDarkNotificationSuccess,
	    'notification-warning': filterDarkNotificationWarning,
	    'notification-error': filterDarkNotificationError,
	    'notification-info': filterDarkNotificationInfo,
	};
	const filterMap = {
	    auto: filterLight,
	    light: filterLight,
	    dark: filterDark,
	};
	const forceRerenderAnimationStyle = {
	    '0%': {
	        transform: 'rotateZ(0)',
	    },
	    '100%': {
	        transform: 'rotateZ(0)',
	    },
	};
	const keyFramesLight = 'rerender-light';
	const keyFramesDark = 'rerender-dark';
	const cssVariableFilter = '--p-internal-icon-filter';
	const isFlippableIcon = (name, source) => {
	    return (!source &&
	        (name === 'arrow-compact-left' ||
	            name === 'arrow-compact-right' ||
	            name === 'arrow-double-left' ||
	            name === 'arrow-double-right' ||
	            name === 'arrow-first' ||
	            name === 'arrow-head-left' ||
	            name === 'arrow-head-right' ||
	            name === 'arrow-last' ||
	            name === 'arrow-left' ||
	            name === 'arrow-right' ||
	            name === 'chart' ||
	            name === 'chat' ||
	            name === 'external' ||
	            name === 'increase' ||
	            name === 'list' ||
	            name === 'logout' ||
	            name === 'return' ||
	            name === 'send'));
	};
	const getComponentCss = (name, source, color, size, theme) => {
	    const isColorInherit = color === 'inherit';
	    const isSizeInherit = size === 'inherit';
	    const isDark = validateProps.isThemeDark(theme);
	    const animationName = `${isDark ? keyFramesDark : keyFramesLight}-${color}`;
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'inline-block',
	                verticalAlign: 'top',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            img: {
	                display: 'block', // without display, img tag gets some extra spacing
	                margin: 0,
	                padding: 0,
	                pointerEvents: 'none', // disable dragging/ghosting of images
	                ...(!isColorInherit && {
	                    filter: `var(${cssVariableFilter},${filterMap[theme][color]})`,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        filter: `var(${cssVariableFilter},${filterMap.dark[color]})`,
	                    }),
	                    ...(validateProps.isHighContrastMode &&
	                        schemedHighContrastMediaQuery.getSchemedHighContrastMediaQuery({
	                            filter: filterMap.light[color],
	                        }, {
	                            filter: filterMap.dark[color],
	                        })),
	                    WebkitAnimation: `${animationName} 1ms`, // needed to enforce repaint in Safari if theme is switched programmatically
	                }),
	                ...(isSizeInherit
	                    ? {
	                        width: size,
	                        height: size,
	                    }
	                    : {
	                        width: fontLineHeight.fontLineHeight,
	                        height: fontLineHeight.fontLineHeight,
	                        font: `${sizeMap[size]} ${fontFamily.fontFamily}`,
	                    }),
	                ...(isFlippableIcon(name, source) && {
	                    '&:dir(rtl)': {
	                        transform: 'scaleX(-1)',
	                    },
	                }),
	            },
	            ...(!isColorInherit && {
	                [`@keyframes ${animationName}`]: forceRerenderAnimationStyle,
	            }),
	        },
	    });
	};

	const ICON_ARIA_ATTRIBUTES = ['aria-label'];
	const ICON_COLORS = [...typographyTextColor.TYPOGRAPHY_TEXT_COLORS, 'state-disabled'];
	const isUrl = (str) => str?.length > 0 && /(\/)/.test(str);
	const DEFAULT_ICON_NAME = 'arrow-right';
	// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
	const buildIconUrl = (iconNameOrSource = DEFAULT_ICON_NAME) => {
	    if (iconNameOrSource === null) {
	        return buildIconUrl(DEFAULT_ICON_NAME);
	    }
	    if (isUrl(iconNameOrSource)) {
	        return iconNameOrSource;
	    }
	    if (ICONS_MANIFEST[iconNameOrSource]) {
	        return `${getCDNBaseURL.getCDNBaseURL()}/icons/${ICONS_MANIFEST[iconNameOrSource]}`;
	    }
	    return buildIconUrl(DEFAULT_ICON_NAME);
	};

	const propTypes = {
	    name: validateProps.AllowedTypes.oneOf(Object.keys(ICONS_MANIFEST)),
	    source: validateProps.AllowedTypes.string,
	    color: validateProps.AllowedTypes.oneOf(ICON_COLORS),
	    size: validateProps.AllowedTypes.oneOf(textSize.TEXT_SIZES),
	    lazy: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    aria: validateProps.AllowedTypes.aria(ICON_ARIA_ATTRIBUTES),
	};
	const Icon = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.name = 'arrow-right';
	        this.source = undefined;
	        this.color = 'primary';
	        this.size = 'small';
	        this.lazy = undefined;
	        this.theme = 'light';
	        this.aria = undefined;
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'lazy');
	        const deprecationMap = {
	            brand: 'primary',
	            default: 'primary',
	            'neutral-contrast-low': 'contrast-low',
	            'neutral-contrast-medium': 'contrast-medium',
	            'neutral-contrast-high': 'contrast-high',
	            'notification-neutral': 'notification-info',
	        };
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'color', deprecationMap);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.name, this.source, (deprecationMap[this.color] || this.color), this.size, this.theme);
	        return (validateProps.h("img", { key: '87103a288948ca6bd5a3cec369be301f37438a81', src: window.PDS_SKIP_FETCH ? undefined : buildIconUrl(this.source || this.name), width: 24, height: 24, loading: "lazy", alt: validateProps.parseAndGetAriaAttributes(this.aria)?.['aria-label'] ?? '' }));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pIcon_cjs_entry.p_icon = Icon;

	
	return pIcon_cjs_entry;
}

var pInlineNotification_cjs_entry = {};

var hasRequiredPInlineNotification_cjs_entry;

function requirePInlineNotification_cjs_entry () {
	if (hasRequiredPInlineNotification_cjs_entry) return pInlineNotification_cjs_entry;
	hasRequiredPInlineNotification_cjs_entry = 1;

	Object.defineProperty(pInlineNotification_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const inlineNotificationUtils = requireInlineNotificationUtilsFb9eaa4e();
	const hasHeading = requireHasHeading5ac42b7f();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed91ceea3c();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed76f87eda();
	const theme = requireThemeBfc10573();
	const headingTag = requireHeadingTag6cfe20fe();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const typographyStyles = requireTypographyStyles226e4585();
	const getMediaQueryMax = requireGetMediaQueryMax5b73ea17();
	const headingSmallStyle = requireHeadingSmallStyle43f95761();
	const textSmallStyle = requireTextSmallStyle00e1c6e2();
	const slottedAnchorStyles = requireSlottedAnchorStylesFe1a10c2();
	requireSpacingStaticMedium94812711();
	requireBorderRadiusSmall5f37fc45();
	requireSpacingStaticXSmallB7d708b8();
	requireSpacingStaticSmall2130ed04();
	requireBannerUtils2cc83734();
	requireHasNamedSlot273cd3ae();
	requireGetNamedSlot223c478a();
	requireHelper22e15c0e();
	requireHeadingShared888aa084();
	requireFontFamily23874d28();
	requireFontLineHeightD4b9e1a9();
	requireFontWeightSemiBold4482c830();
	requireFontVariant6ba3b7cb();
	requireFontSizeHeadingSmallA15141a5();
	requireFontSizeTextSmall508930e5();
	requireTextShared5216bb19();
	requireFontWeightRegularD0c768ac();
	requireBorderRadiusMedium758b9411();

	const mediaQueryMaxS = getMediaQueryMax.getMediaQueryMax('s');
	const getTextJssStyle = (theme) => ({
	    margin: 0,
	    color: validateProps.getThemedColors(theme).primaryColor,
	    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	        color: validateProps.getThemedColors('dark').primaryColor,
	    }),
	});
	const getHeadingJssStyle = (theme) => ({
	    ...headingSmallStyle.headingSmallStyle,
	    ...getTextJssStyle(theme),
	});
	const getComponentCss = (state, hasAction, hasClose, theme) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'grid',
	                ...validateProps.addImportantToEachRule({
	                    ...inlineNotificationUtils.getNotificationRootJssStyle(state, hasAction, hasClose, theme),
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            [`::slotted(:is(${headingTag.HEADING_TAGS.join()}))`]: validateProps.addImportantToEachRule(typographyStyles.getTypographySlottedJssStyle()),
	            'slot[name="heading"]': getHeadingJssStyle(theme),
	        },
	        heading: getHeadingJssStyle(theme),
	        description: {
	            ...textSmallStyle.textSmallStyle,
	            ...getTextJssStyle(theme),
	        },
	        icon: inlineNotificationUtils.getNotificationIconJssStyle(),
	        content: inlineNotificationUtils.getNotificationContentJssStyle(),
	        ...(hasAction && {
	            action: {
	                marginTop: validateProps.borderWidthBase, // To visually align with close button
	                [mediaQueryMaxS]: {
	                    gridRowStart: 2,
	                },
	            },
	        }),
	        close: {
	            ...validateProps.dismissButtonJssStyle,
	            mixBlendMode: validateProps.isThemeDark(theme) ? 'plus-lighter' : 'multiply',
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                mixBlendMode: 'plus-lighter',
	            }),
	        },
	    });
	};

	const propTypes = {
	    heading: validateProps.AllowedTypes.string,
	    headingTag: validateProps.AllowedTypes.oneOf(headingTag.HEADING_TAGS),
	    description: validateProps.AllowedTypes.string,
	    state: validateProps.AllowedTypes.oneOf(inlineNotificationUtils.INLINE_NOTIFICATION_STATES),
	    dismissButton: validateProps.AllowedTypes.boolean,
	    persistent: validateProps.AllowedTypes.boolean,
	    actionLabel: validateProps.AllowedTypes.string,
	    actionLoading: validateProps.AllowedTypes.boolean,
	    actionIcon: validateProps.AllowedTypes.string, // TODO: we could use AllowedTypes.oneOf<IconName>(Object.keys(ICONS_MANIFEST) as IconName[]) but then main chunk will increase
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const InlineNotification = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.dismiss = validateProps.createEvent(this, "dismiss", 3);
	        this.action = validateProps.createEvent(this, "action", 3);
	        this.heading = '';
	        this.headingTag = 'h5';
	        this.description = '';
	        this.state = 'info';
	        this.dismissButton = true;
	        this.persistent = undefined;
	        this.actionLabel = undefined;
	        this.actionLoading = false;
	        this.actionIcon = 'arrow-right';
	        this.theme = 'light';
	    }
	    get hasDismissButton() {
	        return this.persistent ? false : this.dismissButton;
	    }
	    connectedCallback() {
	        validateProps.applyConstructableStylesheetStyles(this.host, slottedAnchorStyles.getSlottedAnchorStyles);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'state', {
	            neutral: 'info',
	        });
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'persistent', 'Please use dismissButton prop instead.');
	        validateProps.attachComponentCss(this.host, getComponentCss, this.state, !!this.actionLabel, this.hasDismissButton, this.theme);
	        const bannerId = 'banner';
	        const labelId = 'label';
	        const descriptionId = 'description';
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        const Heading = this.headingTag;
	        return (validateProps.h(validateProps.Host, { key: 'd792bc82097cff56d42536ed34288e37bde487db' }, validateProps.h(PrefixedTagNames.pIcon, { key: '2c99b715693cbe78f555190c5f4dac2d164cfe8a', class: "icon", name: inlineNotificationUtils.getInlineNotificationIconName(this.state), color: `notification-${this.state}`, theme: this.theme, "aria-hidden": "true" }), validateProps.h("div", { key: '76f0e1c2b06d9e623ab9e84a0212ef99ee4933c8', id: bannerId, class: "content", ...inlineNotificationUtils.getContentAriaAttributes(this.state, labelId, descriptionId) }, hasHeading.hasHeading(this.host, this.heading) &&
	            (this.heading ? (validateProps.h(Heading, { id: labelId, class: "heading" }, this.heading)) : (validateProps.h("slot", { name: "heading" }))), validateProps.h("p", { key: '0ff10dee636d275a2fc80e4893eafb64668a6a03', id: descriptionId, class: "description" }, this.description || validateProps.h("slot", { key: '5630207f24126ab7cd28f47c3a2b82b6fa4ab3e5' }))), this.actionLabel && (validateProps.h(PrefixedTagNames.pButtonPure, { key: 'acc848de4a326eb3f3ba0a70e170e73170934721', class: "action", theme: this.theme, icon: this.actionIcon, loading: this.actionLoading, onClick: this.action.emit }, this.actionLabel)), this.hasDismissButton && (validateProps.h(PrefixedTagNames.pButton, { key: '44d2cd4136d8cbb40981f6d6dbacfcb288f01f01', class: "close", type: "button", variant: "ghost", icon: "close", theme: this.theme, hideLabel: true, "aria-controls": bannerId, onClick: this.dismiss.emit }, "Close notification"))));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pInlineNotification_cjs_entry.p_inline_notification = InlineNotification;

	
	return pInlineNotification_cjs_entry;
}

var pLinkPure_cjs_entry = {};

var throwIfInvalidLinkUsageB47cf9ae = {};

var hasRequiredThrowIfInvalidLinkUsageB47cf9ae;

function requireThrowIfInvalidLinkUsageB47cf9ae () {
	if (hasRequiredThrowIfInvalidLinkUsageB47cf9ae) return throwIfInvalidLinkUsageB47cf9ae;
	hasRequiredThrowIfInvalidLinkUsageB47cf9ae = 1;

	const validateProps = requireValidateProps788e2bc5();
	const getOnlyChildOfKindHTMLElementOrThrow = requireGetOnlyChildOfKindHTMLElementOrThrowCdb95e52();

	const throwIfInvalidLinkUsage = (host, hrefValue) => {
	    let isInvalid = hrefValue && host.children.length > 0;
	    if (!isInvalid || !hrefValue) {
	        try {
	            if (!hrefValue) {
	                getOnlyChildOfKindHTMLElementOrThrow.getOnlyChildOfKindHTMLElementOrThrow(host, 'a');
	            }
	        }
	        catch {
	            isInvalid = true;
	        }
	    }
	    if (isInvalid) {
	        validateProps.throwException(`usage of ${validateProps.getTagNameWithoutPrefix(host)} is not valid. Please provide a href property or a single and direct <a> child element.`);
	    }
	};

	throwIfInvalidLinkUsageB47cf9ae.throwIfInvalidLinkUsage = throwIfInvalidLinkUsage;

	
	return throwIfInvalidLinkUsageB47cf9ae;
}

var hasRequiredPLinkPure_cjs_entry;

function requirePLinkPure_cjs_entry () {
	if (hasRequiredPLinkPure_cjs_entry) return pLinkPure_cjs_entry;
	hasRequiredPLinkPure_cjs_entry = 1;

	Object.defineProperty(pLinkPure_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const linkAriaAttribute = requireLinkAriaAttribute6f29e1a0();
	const buttonLinkPureUtils = requireButtonLinkPureUtils42aabf78();
	const isSsrHydration = requireIsSsrHydration78eae0b3();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed91ceea3c();
	const theme = requireThemeBfc10573();
	const textSize = requireTextSizeBe3fca13();
	const typographyTextWeight = requireTypographyTextWeight02ea3596();
	const throwIfInvalidLinkUsage = requireThrowIfInvalidLinkUsageB47cf9ae();
	const alignLabel = requireAlignLabel7a9d9074();
	const linkButtonPureStyles = requireLinkButtonPureStyles102ff74a();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	requireIsParentOfKind4b323732();
	requireHelper22e15c0e();
	requireGetOnlyChildOfKindHTMLElementOrThrowCdb95e52();
	requireGetDirectChildHTMLElements2594e5bd();
	requireGetHTMLElements3f1c700f();
	requireTransformSelectorToDirectChildSelectorEcc1a9c4();
	requireColorSchemeStyles4bc3d59c();
	requireHoverMediaQuery5e6deda8();
	requirePreventFoucOfNestedElementsStylesE5a706ce();
	requireFontSizeTextStyles4439a071();
	requireFontSizeTextXXSmallA02f9c40();
	requireFontSizeTextXSmallE59d35d7();
	requireFontSizeTextSmall508930e5();
	requireFontSizeTextMedium88887ad8();
	requireFontSizeTextLarge05a4bc90();
	requireFontSizeTextXLarge0ecf9ef3();
	requireTextSmallStyle00e1c6e2();
	requireTextShared5216bb19();
	requireFontFamily23874d28();
	requireFontLineHeightD4b9e1a9();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireSpacingStaticXSmallB7d708b8();
	requireFrostedGlassStyleBd067e45();

	const getComponentCss = (icon, iconSource, active, stretch, size, hideLabel, alignLabel, underline, hasSlottedAnchor, theme) => {
	    return validateProps.getCss(validateProps.mergeDeep(linkButtonPureStyles.getLinkButtonPureStyles(icon, iconSource, active, false, stretch, size, hideLabel, alignLabel, underline, hasSlottedAnchor, theme), hasSlottedAnchor && {
	        '@global': validateProps.addImportantToEachRule({
	            '::slotted': {
	                '&(a)': {
	                    ...validateProps.getResetInitialStylesForSlottedAnchor,
	                    textDecoration: underline ? 'underline' : 'none',
	                    font: 'inherit',
	                    color: 'inherit',
	                },
	                // The clickable area for Safari < ~15 (<= release date: 2021-10-28) is reduced to the slotted anchor itself,
	                // since Safari prior to this major release does not support pseudo-elements in the slotted context
	                // (https://bugs.webkit.org/show_bug.cgi?id=178237)
	                '&(a)::before': {
	                    content: '""',
	                    position: 'fixed',
	                    insetBlock: linkButtonPureStyles.offsetVertical,
	                    borderRadius: borderRadiusSmall.borderRadiusSmall,
	                    ...validateProps.buildResponsiveStyles(hideLabel, (hideLabelValue) => ({
	                        insetInline: hideLabelValue ? linkButtonPureStyles.offsetVertical : linkButtonPureStyles.offsetHorizontal,
	                    })),
	                },
	                ...validateProps.getFocusJssStyle(theme, { slotted: 'a', pseudo: true, offset: '-2px' }),
	            },
	        }),
	    }));
	};

	const propTypes = {
	    alignLabel: validateProps.AllowedTypes.breakpoint(alignLabel.ALIGN_LABELS),
	    stretch: validateProps.AllowedTypes.breakpoint('boolean'),
	    size: validateProps.AllowedTypes.breakpoint(textSize.TEXT_SIZES),
	    weight: validateProps.AllowedTypes.oneOf(typographyTextWeight.TYPOGRAPHY_TEXT_WEIGHTS),
	    icon: validateProps.AllowedTypes.string,
	    iconSource: validateProps.AllowedTypes.string,
	    underline: validateProps.AllowedTypes.boolean,
	    href: validateProps.AllowedTypes.string,
	    active: validateProps.AllowedTypes.boolean,
	    hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    target: validateProps.AllowedTypes.string,
	    download: validateProps.AllowedTypes.string,
	    rel: validateProps.AllowedTypes.string,
	    aria: validateProps.AllowedTypes.aria(linkAriaAttribute.LINK_ARIA_ATTRIBUTES),
	};
	const LinkPure = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.alignLabel = 'end';
	        this.stretch = false;
	        this.size = 'small';
	        this.weight = 'regular';
	        this.icon = 'arrow-right';
	        this.iconSource = undefined;
	        this.underline = false;
	        this.href = undefined;
	        this.active = false;
	        this.hideLabel = false;
	        this.theme = 'light';
	        this.target = '_self';
	        this.download = undefined;
	        this.rel = undefined;
	        this.aria = undefined;
	    }
	    componentWillLoad() {
	        if (!isSsrHydration.isSsrHydration(this.host)) {
	            // when ssr rendered component is partially hydrated before being rerendered by its parent (e.g. link-tile)
	            // it has no href prop and no slotted anchor, so validation fails
	            throwIfInvalidLinkUsage.throwIfInvalidLinkUsage(this.host, this.href);
	        }
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        buttonLinkPureUtils.warnIfParentIsPTextAndIconIsNone(this.host, this.icon, this.iconSource);
	        const alignLabelDeprecationMap = {
	            left: 'start',
	            right: 'end',
	        };
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'alignLabel', alignLabelDeprecationMap);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.icon, this.iconSource, this.active, this.stretch, this.size, this.hideLabel, this.alignLabel, this.underline, !this.href, this.theme);
	        const TagType = this.href === undefined ? 'span' : 'a';
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        const hasIcon = buttonLinkPureUtils.hasVisibleIcon(this.icon, this.iconSource);
	        return (validateProps.h(TagType, { key: '39c9cbf78f5b2a7e5cbcd896107def446eff9e12', class: "root", ...(TagType === 'a' && {
	                href: this.href,
	                target: this.target,
	                download: this.download,
	                rel: this.rel,
	                ...validateProps.parseAndGetAriaAttributes(this.aria),
	            }) }, hasIcon && (validateProps.h(PrefixedTagNames.pIcon, { key: '304d2e76a86a511f4fe28c03e1fdbd515423e573', class: "icon", size: "inherit", name: this.icon, source: this.iconSource, theme: this.theme, "aria-hidden": "true" })), validateProps.h("span", { key: '734eb5bd6517bcbafa8321671ad845c9d728c332', class: "label" }, validateProps.h("slot", { key: '03cca1fb38a2cef26d32b289abe7116db758e2ce' }))));
	    }
	    static get delegatesFocus() { return true; }
	    get host() { return validateProps.getElement(this); }
	};

	pLinkPure_cjs_entry.p_link_pure = LinkPure;

	
	return pLinkPure_cjs_entry;
}

var pLinkSocial_cjs_entry = {};

var hasRequiredPLinkSocial_cjs_entry;

function requirePLinkSocial_cjs_entry () {
	if (hasRequiredPLinkSocial_cjs_entry) return pLinkSocial_cjs_entry;
	hasRequiredPLinkSocial_cjs_entry = 1;

	Object.defineProperty(pLinkSocial_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const warnIfDeprecatedComponentIsUsed = requireWarnIfDeprecatedComponentIsUsedB14eebd2();
	const theme = requireThemeBfc10573();
	const throwIfInvalidLinkUsage = requireThrowIfInvalidLinkUsageB47cf9ae();
	const linkStyles = requireLinkStyles76fc91e3();
	requireGetOnlyChildOfKindHTMLElementOrThrowCdb95e52();
	requireGetDirectChildHTMLElements2594e5bd();
	requireGetHTMLElements3f1c700f();
	requireTransformSelectorToDirectChildSelectorEcc1a9c4();
	requireLinkButtonStyles7215407d();
	requireChangeColor50831612();
	requireButtonLinkPureUtils42aabf78();
	requireIsParentOfKind4b323732();
	requireColorSchemeStyles4bc3d59c();
	requireHoverMediaQuery5e6deda8();
	requirePreventFoucOfNestedElementsStylesE5a706ce();
	requireBorderRadiusSmall5f37fc45();
	requireTextSmallStyle00e1c6e2();
	requireTextShared5216bb19();
	requireFontFamily23874d28();
	requireFontLineHeightD4b9e1a9();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireFrostedGlassStyleBd067e45();

	const propTypes = {
	    icon: validateProps.AllowedTypes.string,
	    iconSource: validateProps.AllowedTypes.string,
	    href: validateProps.AllowedTypes.string,
	    target: validateProps.AllowedTypes.string,
	    rel: validateProps.AllowedTypes.string,
	    hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	    compact: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const LinkSocial = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.icon = undefined;
	        this.iconSource = undefined;
	        this.href = undefined;
	        this.target = '_self';
	        this.rel = undefined;
	        this.hideLabel = false;
	        this.compact = false;
	        this.theme = 'light';
	    }
	    componentWillLoad() {
	        throwIfInvalidLinkUsage.throwIfInvalidLinkUsage(this.host, this.href);
	        warnIfDeprecatedComponentIsUsed.warnIfDeprecatedComponentIsUsed(this.host, 'Use p-link component with corresponding social icon instead.');
	        validateProps.doNothing(); // TODO: this function does nothing but treats for unknowns reasons e.g. getThemedColors to be bundled into main chunk
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, linkStyles.getComponentCss, this.icon, this.iconSource, 'primary', this.hideLabel, !this.href, this.compact, this.theme);
	        const TagType = this.href === undefined ? 'span' : 'a';
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(TagType, { key: '3531596cad72a97a5020e0ee41c9a5b57eab7956', class: "root", ...(TagType === 'a' && {
	                href: this.href,
	                target: this.target,
	                rel: this.rel,
	            }) }, validateProps.h(PrefixedTagNames.pIcon, { key: '523eac359a3a08735f795d5d849de46cdad1924f', class: "icon", size: "inherit", name: this.icon, source: this.iconSource, theme: this.theme, "aria-hidden": "true" }), validateProps.h("span", { key: '4c9e66b693eeb2f3bec4eb8681b657590d1662a0', class: "label" }, validateProps.h("slot", { key: 'eca728e106b9c79d09f32dc53032c735586f39d0' }))));
	    }
	    static get delegatesFocus() { return true; }
	    get host() { return validateProps.getElement(this); }
	};

	pLinkSocial_cjs_entry.p_link_social = LinkSocial;

	
	return pLinkSocial_cjs_entry;
}

var pLinkTileModelSignature_cjs_entry = {};

var throwIfElementIsNotOfKindAb86026b = {};

var hasRequiredThrowIfElementIsNotOfKindAb86026b;

function requireThrowIfElementIsNotOfKindAb86026b () {
	if (hasRequiredThrowIfElementIsNotOfKindAb86026b) return throwIfElementIsNotOfKindAb86026b;
	hasRequiredThrowIfElementIsNotOfKindAb86026b = 1;

	const validateProps = requireValidateProps788e2bc5();

	const throwIfElementIsNotOfKind = (host, element, tagNameOrNames) => {
	    const prefixedTagNamesMap = validateProps.getPrefixedTagNames(host);
	    const prefixedTagNames = Array.isArray(tagNameOrNames)
	        ? tagNameOrNames.map((tagName) => prefixedTagNamesMap[validateProps.paramCaseToCamelCase(tagName)])
	        : [prefixedTagNamesMap[validateProps.paramCaseToCamelCase(tagNameOrNames)]];
	    const actualTagName = validateProps.getTagName(element);
	    if (!prefixedTagNames.includes(actualTagName)) {
	        validateProps.throwException(`child ${actualTagName} of ${validateProps.getTagName(host)} has to be a ${prefixedTagNames.join(' | ')}.`);
	    }
	};

	throwIfElementIsNotOfKindAb86026b.throwIfElementIsNotOfKind = throwIfElementIsNotOfKind;

	
	return throwIfElementIsNotOfKindAb86026b;
}

var hasRequiredPLinkTileModelSignature_cjs_entry;

function requirePLinkTileModelSignature_cjs_entry () {
	if (hasRequiredPLinkTileModelSignature_cjs_entry) return pLinkTileModelSignature_cjs_entry;
	hasRequiredPLinkTileModelSignature_cjs_entry = 1;

	Object.defineProperty(pLinkTileModelSignature_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const groupDirectionStyles = requireGroupDirectionStylesC4bd8b11();
	const tileUtils = requireTileUtils82ea5cf8();
	const getNamedSlot = requireGetNamedSlot223c478a();
	const throwIfElementIsNotOfKind = requireThrowIfElementIsNotOfKindAb86026b();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const forcedColorsMediaQuery = requireForcedColorsMediaQuery69d5b1ca();
	const fontWeightStyles = requireFontWeightStylesB74e8683();
	const textShared = requireTextShared5216bb19();
	const fontSizeTextLarge = requireFontSizeTextLarge05a4bc90();
	const textSmallStyle = requireTextSmallStyle00e1c6e2();
	const spacingFluidMedium = requireSpacingFluidMedium88ab712b();
	const spacingFluidLarge = requireSpacingFluidLarge6087a0f7();
	const borderRadiusLarge = requireBorderRadiusLargeA0aa3a01();
	const spacingFluidSmall = requireSpacingFluidSmall2c6caae7();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();
	const slottedPictureImageStyles = requireSlottedPictureImageStyles3121dac8();
	requireGetDirectChildHTMLElement18d9487f();
	requireTransformSelectorToDirectChildSelectorEcc1a9c4();
	requireFontWeightRegularD0c768ac();
	requireFontWeightSemiBold4482c830();
	requireFontFamily23874d28();
	requireFontLineHeightD4b9e1a9();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();

	const textLargeStyle = {
	    font: `${textShared._textFontPartA}${fontSizeTextLarge.fontSizeTextLarge}${textShared._textFontPartB}`,
	    ...textShared.fontHyphenationStyle,
	};

	const getNamedSlotOrThrow = (el, slotName) => {
	    const slot = getNamedSlot.getNamedSlot(el, slotName);
	    if (!slot) {
	        validateProps.throwException(`named slot='${slotName}' is missing for component ${validateProps.getTagNameWithoutPrefix(el)}.`);
	    }
	    return slot;
	};

	const getComponentCss = (aspectRatio, weight, // to get deprecated semibold typed
	direction, hasDescription) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block', // `display: flex` would be more ideal, but doesn't work in Safari in all cases
	                hyphens: 'auto', // TODO: shouldn't we expose a CSS variable instead?
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            slot: {
	                '&:not([name])': {
	                    display: 'block',
	                    width: '100%',
	                    height: '100%',
	                    transition: validateProps.getTransition('transform', 'moderate'),
	                },
	                '&[name=primary]': {
	                    pointerEvents: 'auto',
	                },
	                '&[name=secondary]': {
	                    pointerEvents: 'auto',
	                },
	            },
	            '::slotted(:is(img,picture,video))': validateProps.addImportantToEachRule({
	                display: 'block',
	                width: '100%',
	                height: '100%',
	            }),
	            '::slotted(:is(img,video))': validateProps.addImportantToEachRule({
	                objectFit: 'cover',
	            }),
	            a: {
	                gridArea: '1/1/-1 /-1',
	                zIndex: 4,
	                outline: 0, // reset focus style since this element is used to improve mouse interaction only
	            },
	            'h1,h2,h3,h4,h5,h6': {
	                margin: 0,
	                zIndex: 3,
	                maxWidth: '34.375rem',
	                ...textLargeStyle,
	                hyphens: 'inherit',
	                color: validateProps.getThemedColors('dark').primaryColor,
	                ...validateProps.buildResponsiveStyles(weight, (w) => ({ fontWeight: fontWeightStyles.getFontWeight(w) })),
	            },
	            ...(hasDescription && {
	                p: {
	                    margin: '-12px 0 0 ',
	                    zIndex: 3,
	                    maxWidth: '34.375rem',
	                    ...textSmallStyle.textSmallStyle,
	                    color: validateProps.getThemedColors('dark').primaryColor,
	                    hyphens: 'inherit',
	                },
	            }),
	        },
	        root: {
	            ...validateProps.buildResponsiveStyles(aspectRatio, (aspectRatioValue) => ({
	                aspectRatio: aspectRatioValue.replace(':', '/'), // mapping of the deprecated aspect-ratio with ':'
	            })),
	            width: '100%', // necessary in case tile content overflows in grid or flex context
	            height: '100%', // necessary in case tile content overflows in grid or flex context
	            display: 'grid',
	            gridTemplate: `${spacingFluidMedium.spacingFluidMedium} auto minmax(0px, 1fr) auto ${spacingFluidMedium.spacingFluidMedium}/${spacingFluidMedium.spacingFluidMedium} minmax(0px, 1fr) ${spacingFluidMedium.spacingFluidMedium}`,
	            '&::after': {
	                content: '""',
	                zIndex: 2,
	                gridArea: '4/1/6/-1',
	                ...tileUtils.gradientToTopStyle,
	                marginTop: `calc(${spacingFluidLarge.spacingFluidLarge} * -1)`, // to increase the gradient area without reserving additional layout space
	                borderEndStartRadius: borderRadiusLarge.borderRadiusLarge,
	                borderEndEndRadius: borderRadiusLarge.borderRadiusLarge,
	                ...forcedColorsMediaQuery.forcedColorsMediaQuery({
	                    background: 'rgba(0,0,0,0.7)',
	                }),
	            },
	            ...hoverMediaQuery.hoverMediaQuery({
	                '&:hover slot:not([name])': {
	                    transform: 'scale3d(1.05,1.05,1.05)',
	                },
	            }),
	        },
	        header: {
	            gridArea: '2/2',
	            zIndex: 3,
	            display: 'flex',
	            flexDirection: 'column',
	            gap: spacingFluidSmall.spacingFluidSmall,
	        },
	        media: {
	            position: 'relative', // necessary if custom `position: absolute` style is added to media elements
	            gridArea: '1/1/-1 /-1',
	            zIndex: 1,
	            overflow: 'hidden', // relevant for scaling of nested image
	            borderRadius: borderRadiusLarge.borderRadiusLarge,
	        },
	        footer: {
	            gridArea: '4/2',
	            display: 'flex',
	            gap: spacingStaticMedium.spacingStaticMedium,
	            justifyContent: 'space-between',
	            alignItems: 'flex-start',
	            flexDirection: 'column',
	        },
	        'link-group': {
	            zIndex: 5,
	            display: 'flex',
	            width: '100%',
	            pointerEvents: 'none',
	            gap: spacingFluidSmall.spacingFluidSmall,
	            ...validateProps.buildResponsiveStyles(direction, groupDirectionStyles.getGroupDirectionJssStyles),
	        },
	    });
	};

	// array is redefined instead of using the one from in model-signature
	// because it is created via Object.keys(MODEL_SIGNATURES_MANIFEST) would bundle the entire manifest into both chunks
	const LINK_TILE_MODEL_SIGNATURE_MODELS = [
	    '718',
	    '911',
	    'boxster',
	    'cayenne',
	    'cayman',
	    'macan',
	    'panamera',
	    'taycan',
	    'turbo-s',
	    'turbo',
	];
	const LINK_TILE_MODEL_SIGNATURE_HEADING_TAGS = ['h2', 'h3', 'h4', 'h5', 'h6'];
	const setRequiredPropsOfSlottedLinks = (linkElements) => {
	    for (const link of linkElements) {
	        link.theme = 'dark';
	        link.variant = link.slot;
	    }
	};
	const getLinkOrSlottedAnchorElement = (linkElement) => {
	    return linkElement.href ? linkElement : linkElement.querySelector('a');
	};

	const propTypes = {
	    model: validateProps.AllowedTypes.oneOf(LINK_TILE_MODEL_SIGNATURE_MODELS),
	    weight: validateProps.AllowedTypes.breakpoint(tileUtils.TILE_WEIGHTS),
	    aspectRatio: validateProps.AllowedTypes.breakpoint(tileUtils.TILE_ASPECT_RATIOS),
	    heading: validateProps.AllowedTypes.string,
	    description: validateProps.AllowedTypes.string,
	    linkDirection: validateProps.AllowedTypes.breakpoint(groupDirectionStyles.GROUP_DIRECTIONS),
	    headingTag: validateProps.AllowedTypes.oneOf(LINK_TILE_MODEL_SIGNATURE_HEADING_TAGS),
	};
	const LinkTileModelSignature = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.model = '911';
	        this.weight = 'semi-bold';
	        this.aspectRatio = '3/4';
	        this.heading = undefined;
	        this.description = undefined;
	        this.linkDirection = {
	            base: 'column',
	            xs: 'row',
	        };
	        this.headingTag = 'h2';
	    }
	    connectedCallback() {
	        validateProps.applyConstructableStylesheetStyles(this.host, slottedPictureImageStyles.getSlottedPictureImageStyles);
	    }
	    componentWillLoad() {
	        tileUtils.preventAutoPlayOfSlottedVideoOnPrefersReducedMotion(this.host); // only checked once during component initialization
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        // If we do this earlier than render, there are cases where primaryLink.href is undefined
	        // TODO: Here and in other components, validation happens only on initial render. We could extend this to watch props of the required slots.
	        const primaryLink = getNamedSlotOrThrow(this.host, 'primary');
	        const secondaryLink = getNamedSlotOrThrow(this.host, 'secondary');
	        throwIfElementIsNotOfKind.throwIfElementIsNotOfKind(this.host, primaryLink, 'p-link');
	        throwIfElementIsNotOfKind.throwIfElementIsNotOfKind(this.host, secondaryLink, 'p-link');
	        setRequiredPropsOfSlottedLinks([primaryLink, secondaryLink]);
	        const linkEl = getLinkOrSlottedAnchorElement(primaryLink); // support for slotted a tag within p-link
	        validateProps.attachComponentCss(this.host, getComponentCss, this.aspectRatio, this.weight, this.linkDirection, !!this.description);
	        const overlayLinkProps = {
	            href: linkEl.href,
	            target: linkEl.target || '_self',
	            download: linkEl.download || null,
	            rel: linkEl.rel || null,
	            tabIndex: -1,
	            'aria-hidden': 'true',
	        };
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h("div", { key: 'c00945308adf5867f225ff3e465f0d40d90515a6', class: "root" }, validateProps.h("a", { key: 'cf17a337b6db303716cf4bd9ce20bb587f931f1c', ...overlayLinkProps }), validateProps.h("div", { key: '312cd5bf7c374f95a0e73d4769c0a7099e3df53d', class: "header" }, validateProps.h(PrefixedTagNames.pModelSignature, { key: '16ede8790555f39909873b0a49bb0e9f766f958c', theme: "dark", model: this.model }), validateProps.h("slot", { key: 'd226a11dee8bee1529304146c9f98759968a09f7', name: "header" })), validateProps.h("div", { key: '4a74e9c26d11edb0d516d86916d444e29b3403ff', class: "media" }, validateProps.h("slot", { key: 'fd743de306ba988772af3430ca5975aa9ca27cbe', onSlotchange: () => tileUtils.preventAutoPlayOfSlottedVideoOnPrefersReducedMotion(this.host) })), validateProps.h("div", { key: 'a4865c5057865c4843e4567412371d2f585fa1e0', class: "footer" }, validateProps.h(this.headingTag, { key: '124102c6db62a25a066c4fa8ca69051bcbb78271' }, this.heading), this.description && validateProps.h("p", { key: 'b2dda5b52e8d64d66d84de1bb6cd27353767c429' }, this.description), validateProps.h("div", { key: '51dc4cf1df97930b03ef8577ec01c30408177d24', class: "link-group", role: "group" }, validateProps.h("slot", { key: '351dafce222a36dc545b97746ea9fc80141f8902', name: "primary" }), validateProps.h("slot", { key: '22c93cbf1d8e8bf888d516fb83989e02641c2731', name: "secondary" })))));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pLinkTileModelSignature_cjs_entry.p_link_tile_model_signature = LinkTileModelSignature;

	
	return pLinkTileModelSignature_cjs_entry;
}

var pLinkTileProduct_cjs_entry = {};

var hasRequiredPLinkTileProduct_cjs_entry;

function requirePLinkTileProduct_cjs_entry () {
	if (hasRequiredPLinkTileProduct_cjs_entry) return pLinkTileProduct_cjs_entry;
	hasRequiredPLinkTileProduct_cjs_entry = 1;

	Object.defineProperty(pLinkTileProduct_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const slottedPictureImageStyles = requireSlottedPictureImageStyles3121dac8();
	const theme = requireThemeBfc10573();
	const getNamedSlot = requireGetNamedSlot223c478a();
	const getOnlyChildOfKindHTMLElementOrThrow = requireGetOnlyChildOfKindHTMLElementOrThrowCdb95e52();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const borderRadiusMedium = requireBorderRadiusMedium758b9411();
	const spacingFluidXSmall = requireSpacingFluidXSmall0dd753ae();
	const borderRadiusLarge = requireBorderRadiusLargeA0aa3a01();
	const spacingFluidSmall = requireSpacingFluidSmall2c6caae7();
	const spacingFluidMedium = requireSpacingFluidMedium88ab712b();
	const headingSmallStyle = requireHeadingSmallStyle43f95761();
	const textShared = requireTextShared5216bb19();
	const textXSmallStyle = requireTextXSmallStyle30d03035();
	const fontSizeTextXXSmall = requireFontSizeTextXXSmallA02f9c40();
	requireGetDirectChildHTMLElements2594e5bd();
	requireGetHTMLElements3f1c700f();
	requireTransformSelectorToDirectChildSelectorEcc1a9c4();
	requireHeadingShared888aa084();
	requireFontFamily23874d28();
	requireFontLineHeightD4b9e1a9();
	requireFontWeightSemiBold4482c830();
	requireFontVariant6ba3b7cb();
	requireFontSizeHeadingSmallA15141a5();
	requireFontSizeTextSmall508930e5();
	requireFontWeightRegularD0c768ac();
	requireFontSizeTextXSmallE59d35d7();

	const textXXSmallStyle = {
	    font: `${textShared._textFontPartA}${fontSizeTextXXSmall.fontSizeTextXXSmall}${textShared._textFontPartB}`,
	    ...textShared.fontHyphenationStyle,
	};

	const TILE_PRODUCT_ASPECT_RATIOS = ['3:4', '9:16'];
	const headerSlot = 'header';
	const anchorSlot = 'anchor';

	const throwIfInvalidLinkTileProductUsage = (host, hrefValue) => {
	    let invalidA11y = false;
	    if (!hrefValue) {
	        if (!getNamedSlot.getNamedSlot(host, anchorSlot)) {
	            throwMissingHrefAndSlottedLinkException(host);
	        }
	        try {
	            const linkElement = getOnlyChildOfKindHTMLElementOrThrow.getOnlyChildOfKindHTMLElementOrThrow(host, 'a');
	            if (!linkElement.textContent.trim() && !linkElement.getAttribute('aria-label')) {
	                invalidA11y = true;
	            }
	        }
	        catch {
	            throwMissingHrefAndSlottedLinkException(host);
	        }
	    }
	    if (invalidA11y) {
	        throwMissingSlottedLinkA11yException(host);
	    }
	};
	const throwMissingHrefAndSlottedLinkException = (host) => validateProps.throwException(`usage of ${validateProps.getTagNameWithoutPrefix(host)} is not valid. Please provide a href property or a single and direct <a> child element in the anchor slot.`);
	const throwMissingSlottedLinkA11yException = (host) => validateProps.throwException(`usage of ${validateProps.getTagNameWithoutPrefix(host)} is not valid. Anchor tag must have slotted text content or an aria-label attribute for accessibility.`);

	const slottedAnchorSelector = `a[slot='${anchorSlot}']`;
	const anchorJssStyle = {
	    position: 'absolute',
	    inset: 0,
	    zIndex: 1, // necessary to be on top of img
	    borderRadius: borderRadiusMedium.borderRadiusMedium,
	};
	const getMultilineEllipsis = (lineClamp) => {
	    return {
	        display: '-webkit-box',
	        WebkitLineClamp: lineClamp,
	        WebkitBoxOrient: 'vertical',
	        overflow: 'hidden',
	    };
	};
	const getComponentCss = (hasLikeButton, hasSlottedAnchor, hasPriceOriginal, hasDescription, aspectRatio, theme) => {
	    const { primaryColor, contrastHighColor, contrastMediumColor, backgroundSurfaceColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, contrastHighColor: contrastHighColorDark, contrastMediumColor: contrastMediumColorDark, backgroundSurfaceColor: backgroundSurfaceColorDark, } = validateProps.getThemedColors('dark');
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                position: 'relative', // needed for ::slotted(a) to overlay correctly
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            [`slot[name="${headerSlot}"]`]: {
	                display: 'block', // to ensure correct like button positioning when slot is unused
	            },
	            ...validateProps.addImportantToEachRule({
	                '::slotted': {
	                    ...(hasSlottedAnchor && {
	                        [`&(${slottedAnchorSelector})`]: {
	                            ...anchorJssStyle,
	                            textIndent: '-999999px', // hide anchor label visually but still usable for a11y (only works in RTL-mode because of `overflow: hidden;` parent)
	                        },
	                        ...validateProps.getFocusJssStyle(theme, { slotted: slottedAnchorSelector }),
	                    }),
	                    [`&([slot="${headerSlot}"])`]: {
	                        display: 'flex',
	                        flexWrap: 'wrap',
	                        gap: spacingFluidXSmall.spacingFluidXSmall,
	                    },
	                    '&(img), &(picture)': {
	                        display: 'block',
	                        width: '100%',
	                        height: '100%',
	                        objectFit: 'cover',
	                        borderRadius: borderRadiusLarge.borderRadiusLarge,
	                        overflow: 'hidden', // needed for picture > img to have correct border-radius
	                    },
	                },
	            }),
	            ...(hasPriceOriginal && {
	                s: {
	                    color: contrastMediumColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        color: contrastMediumColorDark,
	                    }),
	                },
	            }),
	        },
	        root: {
	            display: 'flex',
	            flexDirection: 'column',
	            aspectRatio: '3/4',
	            overflow: 'hidden', // TODO: discussable if we should prevent text to overflow .root,  e.g. it also prevents a popover from being shown correctly
	            boxSizing: 'border-box',
	            borderRadius: borderRadiusMedium.borderRadiusMedium,
	            padding: spacingFluidSmall.spacingFluidSmall,
	            color: primaryColor,
	            backgroundColor: backgroundSurfaceColor,
	            ...validateProps.buildResponsiveStyles(aspectRatio, (ratio) => ({
	                aspectRatio: ratio.replace(':', '/'),
	            })),
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                color: primaryColorDark,
	                backgroundColor: backgroundSurfaceColorDark,
	            }),
	        },
	        ...(!hasSlottedAnchor && {
	            anchor: {
	                ...anchorJssStyle,
	                ...validateProps.getFocusJssStyle(theme),
	            },
	        }),
	        header: {
	            display: 'flex',
	            gap: spacingFluidSmall.spacingFluidSmall,
	            justifyContent: 'space-between',
	            alignItems: 'flex-start',
	        },
	        ...(hasLikeButton && {
	            button: {
	                position: 'relative',
	                zIndex: 2, // Necessary to be on top of anchor link
	            },
	        }),
	        image: {
	            aspectRatio: '8/9',
	            margin: `${spacingFluidSmall.spacingFluidSmall} auto ${spacingFluidXSmall.spacingFluidXSmall}`,
	            overflow: 'hidden',
	            transition: validateProps.getTransition('transform', 'moderate'),
	            [validateProps.getMediaQueryMin('s')]: {
	                padding: `0 ${spacingFluidMedium.spacingFluidMedium}`, // ensures image is not getting to large
	            },
	            ...hoverMediaQuery.hoverMediaQuery({
	                '.root:hover &': {
	                    transform: 'scale3d(1.05,1.05,1.05)',
	                },
	            }),
	        },
	        wrapper: {
	            display: 'flex',
	            flexDirection: 'column',
	            margin: 'auto',
	            textAlign: 'center',
	        },
	        heading: {
	            margin: '0 0 2px', // ua-style reset
	            ...headingSmallStyle.headingSmallStyle,
	            ...textShared.fontHyphenationStyle,
	            ...getMultilineEllipsis(3),
	        },
	        price: {
	            margin: 0, // ua-style reset
	            ...textXSmallStyle.textXSmallStyle,
	            ...(hasPriceOriginal && {
	                display: 'flex',
	                flexWrap: 'wrap',
	                justifyContent: 'center',
	                columnGap: spacingFluidXSmall.spacingFluidXSmall,
	            }),
	        },
	        ...(hasDescription && {
	            description: {
	                margin: 0, // ua-style reset
	                ...textXXSmallStyle,
	                ...getMultilineEllipsis(2),
	                color: contrastHighColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: contrastHighColorDark,
	                }),
	            },
	        }),
	        ...(hasPriceOriginal && {
	            'sr-only': validateProps.getHiddenTextJssStyle(),
	        }),
	    });
	};

	const propTypes = {
	    heading: validateProps.AllowedTypes.string,
	    price: validateProps.AllowedTypes.string,
	    priceOriginal: validateProps.AllowedTypes.string,
	    description: validateProps.AllowedTypes.string,
	    likeButton: validateProps.AllowedTypes.boolean,
	    liked: validateProps.AllowedTypes.boolean,
	    href: validateProps.AllowedTypes.string,
	    aspectRatio: validateProps.AllowedTypes.breakpoint(TILE_PRODUCT_ASPECT_RATIOS),
	    target: validateProps.AllowedTypes.string,
	    rel: validateProps.AllowedTypes.string,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const LinkTileProduct = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.like = validateProps.createEvent(this, "like", 3);
	        this.onLikeClick = () => {
	            this.like.emit({
	                liked: this.liked,
	            });
	        };
	        this.heading = undefined;
	        this.price = undefined;
	        this.priceOriginal = undefined;
	        this.description = undefined;
	        this.likeButton = true;
	        this.liked = false;
	        this.href = undefined;
	        this.aspectRatio = '3:4';
	        this.target = '_self';
	        this.rel = undefined;
	        this.theme = 'light';
	    }
	    connectedCallback() {
	        validateProps.applyConstructableStylesheetStyles(this.host, slottedPictureImageStyles.getSlottedPictureImageStyles);
	    }
	    componentWillLoad() {
	        throwIfInvalidLinkTileProductUsage(this.host, this.href);
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.likeButton, !this.href, !!this.priceOriginal, !!this.description, this.aspectRatio, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        const headerId = 'header';
	        const headingId = 'heading';
	        const priceId = 'price';
	        const descriptionId = 'description';
	        return (validateProps.h("div", { key: '2cc2f3b963cc8ec0205b32d67ab06fd34236ac25', class: "root" }, this.href ? (validateProps.h("a", { class: "anchor", href: this.href, target: this.target, rel: this.rel, "aria-labelledby": `${headingId} ${priceId}`, "aria-describedby": `${headerId} ${descriptionId}` })) : (validateProps.h("slot", { name: anchorSlot })), validateProps.h("div", { key: '8fe3c9f2c3ceea48e5b5ea542b39a7251dddc529', id: headerId, class: "header" }, validateProps.h("slot", { key: 'f2c1499f7f8ec8b7ebea19db138a03723c156e2e', name: headerSlot }), this.likeButton && (validateProps.h(PrefixedTagNames.pButtonPure, { key: '1e252039eabe2bb8bd17ab35cecc0a1abd9d225e', class: "button", type: "button", icon: this.liked ? 'heart-filled' : 'heart', hideLabel: true, onClick: this.onLikeClick, theme: this.theme }, this.liked ? 'Remove from wishlist' : 'Add to wishlist'))), validateProps.h("div", { key: '4fcd3469dbc30fbbeeaf238374c17f0123f08cee', class: "image" }, validateProps.h("slot", { key: '5791c45c4eeaa12b587cc0746e94a1a9ae285f0e' })), validateProps.h("div", { key: 'b118c2781e48fb8c82d432d38adbcfae1ffbef70', class: "wrapper" }, this.heading && (validateProps.h("h3", { key: '2c773ce478d576e2e4a9ecc3c67007848f09c60c', id: headingId, class: "heading" }, this.heading)), this.price && (validateProps.h("p", { key: 'af9fd58b6c9324cac6454adbb35c517eaac0c33c', id: priceId, class: "price" }, this.priceOriginal ? (validateProps.h(validateProps.Fragment, null, validateProps.h("span", { class: "sr-only" }, "sale price"), this.price, validateProps.h("span", { class: "sr-only" }, "original price"), validateProps.h("s", null, this.priceOriginal))) : (this.price))), this.description && (validateProps.h("p", { key: 'fa4ec6e1b84552f1cd25db7d18b90b96159464cd', id: descriptionId, class: "description" }, this.description)))));
	    }
	    static get delegatesFocus() { return true; }
	    get host() { return validateProps.getElement(this); }
	};

	pLinkTileProduct_cjs_entry.p_link_tile_product = LinkTileProduct;

	
	return pLinkTileProduct_cjs_entry;
}

var pLinkTile_cjs_entry = {};

var hasRequiredPLinkTile_cjs_entry;

function requirePLinkTile_cjs_entry () {
	if (hasRequiredPLinkTile_cjs_entry) return pLinkTile_cjs_entry;
	hasRequiredPLinkTile_cjs_entry = 1;

	Object.defineProperty(pLinkTile_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const linkAriaAttribute = requireLinkAriaAttribute6f29e1a0();
	const tileUtils = requireTileUtils82ea5cf8();
	const slottedPictureImageStyles = requireSlottedPictureImageStyles3121dac8();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const forcedColorsMediaQuery = requireForcedColorsMediaQuery69d5b1ca();
	const fontWeightStyles = requireFontWeightStylesB74e8683();
	const fontSizeTextStyles = requireFontSizeTextStyles4439a071();
	const textMediumStyle = requireTextMediumStyle59c59854();
	const spacingFluidMedium = requireSpacingFluidMedium88ab712b();
	const linkTileUtils = requireLinkTileUtilsFce9594a();
	const spacingFluidLarge = requireSpacingFluidLarge6087a0f7();
	const borderRadiusLarge = requireBorderRadiusLargeA0aa3a01();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();
	requireGetDirectChildHTMLElement18d9487f();
	requireTransformSelectorToDirectChildSelectorEcc1a9c4();
	requireFontWeightRegularD0c768ac();
	requireFontWeightSemiBold4482c830();
	requireFontSizeTextXXSmallA02f9c40();
	requireFontSizeTextXSmallE59d35d7();
	requireFontSizeTextSmall508930e5();
	requireFontSizeTextMedium88887ad8();
	requireFontSizeTextLarge05a4bc90();
	requireFontSizeTextXLarge0ecf9ef3();
	requireTextShared5216bb19();
	requireFontFamily23874d28();
	requireFontLineHeightD4b9e1a9();
	requireFontVariant6ba3b7cb();
	requireThemeBfc10573();

	const getComponentCss = (aspectRatio, size, weight, // to get deprecated semibold typed
	background, align, compact, hasGradient, isDisabled) => {
	    const isTopAligned = align === 'top';
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block', // `display: flex` would be more ideal, but doesn't work in Safari in all cases
	                hyphens: 'auto', // TODO: shouldn't we expose a CSS variable instead?
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            slot: {
	                display: 'block',
	                '&:not([name])': {
	                    width: '100%',
	                    height: '100%',
	                    transition: validateProps.getTransition('transform', 'moderate'),
	                },
	                '&[name="header"]': {
	                    gridArea: `${isTopAligned ? 4 : 2}/2`,
	                    zIndex: 3,
	                },
	            },
	            '::slotted(:is(img,picture,video))': validateProps.addImportantToEachRule({
	                display: 'block',
	                width: '100%',
	                height: '100%',
	            }),
	            '::slotted(:is(img,video))': validateProps.addImportantToEachRule({
	                objectFit: 'cover',
	            }),
	            a: {
	                gridArea: '1/1/-1 /-1',
	                zIndex: 4,
	                outline: 0, // reset focus style since this element is used to improve mouse interaction only
	            },
	            p: {
	                ...textMediumStyle.textMediumStyle,
	                zIndex: 3,
	                margin: 0, // reset ua-style
	                maxWidth: '34.375rem',
	                hyphens: 'inherit',
	                ...validateProps.mergeDeep(validateProps.buildResponsiveStyles(size, (sizeValue) => ({
	                    fontSize: fontSizeTextStyles.getFontSizeText(sizeValue === 'default' ? 'medium' : sizeValue), // mapping of the deprecated size 'default'
	                })), validateProps.buildResponsiveStyles(weight, (weightValue) => ({
	                    fontWeight: fontWeightStyles.getFontWeight(weightValue === 'semibold' ? 'semi-bold' : weightValue), // mapping of the deprecated weight 'semibold'
	                })), validateProps.buildResponsiveStyles(background, (backgroundValue) => ({
	                    color: validateProps.getThemedColors(backgroundValue).primaryColor,
	                }))),
	            },
	        },
	        root: {
	            ...validateProps.buildResponsiveStyles(aspectRatio, (aspectRatioValue) => ({
	                aspectRatio: aspectRatioValue.replace(':', '/'), // mapping of the deprecated aspect-ratio with ':'
	            })),
	            width: '100%', // necessary in case tile content overflows in grid or flex context
	            height: '100%', // necessary in case tile content overflows in grid or flex context
	            display: 'grid',
	            gridTemplate: `${spacingFluidMedium.spacingFluidMedium} auto minmax(0px, 1fr) auto ${spacingFluidMedium.spacingFluidMedium}/${spacingFluidMedium.spacingFluidMedium} minmax(0px, 1fr) ${spacingFluidMedium.spacingFluidMedium}`,
	            ...(hasGradient &&
	                validateProps.isThemeDark(background) && {
	                '&::after': {
	                    content: '""',
	                    zIndex: 2,
	                    ...(isTopAligned
	                        ? {
	                            gridArea: '1/1/3/-1',
	                            ...linkTileUtils.gradientToBottomStyle,
	                            marginBottom: `calc(${spacingFluidLarge.spacingFluidLarge} * -1)`, // to increase the gradient area without reserving additional layout space
	                            borderStartStartRadius: borderRadiusLarge.borderRadiusLarge,
	                            borderStartEndRadius: borderRadiusLarge.borderRadiusLarge,
	                        }
	                        : {
	                            gridArea: '4/1/6/-1',
	                            ...tileUtils.gradientToTopStyle,
	                            marginTop: `calc(${spacingFluidLarge.spacingFluidLarge} * -1)`, // to increase the gradient area without reserving additional layout space
	                            borderEndStartRadius: borderRadiusLarge.borderRadiusLarge,
	                            borderEndEndRadius: borderRadiusLarge.borderRadiusLarge,
	                        }),
	                    ...forcedColorsMediaQuery.forcedColorsMediaQuery({
	                        background: 'rgba(0,0,0,0.7)',
	                    }),
	                },
	            }),
	            ...(!isDisabled &&
	                hoverMediaQuery.hoverMediaQuery({
	                    '&:hover slot:not([name])': {
	                        transform: 'scale3d(1.05,1.05,1.05)',
	                    },
	                })),
	        },
	        media: {
	            position: 'relative', // necessary if custom `position: absolute` style is added to media elements
	            gridArea: '1/1/-1 /-1',
	            zIndex: 1,
	            overflow: 'hidden', // relevant for scaling of nested image
	            borderRadius: borderRadiusLarge.borderRadiusLarge,
	        },
	        footer: {
	            gridArea: `${isTopAligned ? 2 : 4}/2`,
	            display: 'flex',
	            gap: spacingStaticMedium.spacingStaticMedium,
	            justifyContent: 'space-between',
	            ...validateProps.buildResponsiveStyles(compact, (compactValue) => compactValue
	                ? {
	                    alignItems: 'center',
	                    flexDirection: 'row',
	                }
	                : {
	                    alignItems: 'flex-start',
	                    flexDirection: 'column',
	                }),
	        },
	        'link-or-button-pure': {
	            zIndex: 5,
	            ...validateProps.buildResponsiveStyles(compact, (compactValue) => ({
	                display: compactValue ? 'inline-block' : 'none',
	            })),
	        },
	        'link-or-button': {
	            minHeight: '54px', // prevent content shift
	            zIndex: 5,
	            ...validateProps.buildResponsiveStyles(compact, (compactValue) => ({
	                display: compactValue ? 'none' : 'inline-block',
	            })),
	        },
	    });
	};

	const propTypes = {
	    ...linkTileUtils.sharedTilePropTypes,
	    weight: validateProps.AllowedTypes.breakpoint(linkTileUtils.LINK_TILE_WEIGHTS),
	    href: validateProps.AllowedTypes.string,
	    target: validateProps.AllowedTypes.string,
	    download: validateProps.AllowedTypes.string,
	    rel: validateProps.AllowedTypes.string,
	    aria: validateProps.AllowedTypes.aria(linkAriaAttribute.LINK_ARIA_ATTRIBUTES),
	};
	const LinkTile = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.size = 'medium';
	        this.weight = 'semi-bold';
	        this.background = 'dark';
	        this.aspectRatio = '4/3';
	        this.label = undefined;
	        this.description = undefined;
	        this.align = 'bottom';
	        this.gradient = true;
	        this.compact = false;
	        this.href = undefined;
	        this.target = '_self';
	        this.download = undefined;
	        this.rel = undefined;
	        this.aria = undefined;
	    }
	    connectedCallback() {
	        validateProps.applyConstructableStylesheetStyles(this.host, slottedPictureImageStyles.getSlottedPictureImageStyles);
	    }
	    componentWillLoad() {
	        tileUtils.preventAutoPlayOfSlottedVideoOnPrefersReducedMotion(this.host);
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.aspectRatio, this.size, this.weight, this.background, this.align, this.compact, this.gradient);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        const linkProps = {
	            theme: this.background,
	            variant: 'secondary',
	            aria: this.aria,
	        };
	        const sharedLinkProps = {
	            href: this.href,
	            target: this.target,
	            download: this.download,
	            rel: this.rel,
	        };
	        const link = (validateProps.h(PrefixedTagNames.pLink, { ...sharedLinkProps, ...linkProps, key: "link-or-button", class: "link-or-button" }, this.label));
	        const linkPure = (validateProps.h(PrefixedTagNames.pLinkPure, { ...sharedLinkProps, ...linkProps, key: "link-or-button-pure", class: "link-or-button-pure", hideLabel: true, icon: "arrow-right" }, this.label));
	        return (validateProps.h("div", { key: '0009b93c0e65b2b5e5201c8744d1322712fcaa2a', class: "root" }, validateProps.h("a", { key: '0c6a277e8a53573730869af70a8ec882db9c76b1', ...sharedLinkProps, tabIndex: -1, "aria-hidden": "true" }), validateProps.h("slot", { key: '75898294a9f8fb72e09ef4bc59fb91b34d5180d2', name: "header" }), validateProps.h("div", { key: '056bcb8affeda44e19a5d47f5dd414c7e2b17b39', class: "media" }, validateProps.h("slot", { key: 'd7ff1b0bdf4637b89fc1be9bb37fe13f22e7d3d6', onSlotchange: () => tileUtils.preventAutoPlayOfSlottedVideoOnPrefersReducedMotion(this.host) })), validateProps.h("div", { key: '1c214255968f316258806c4536824acb1c22cab4', class: "footer" }, validateProps.h("p", { key: '4764029ca79cb60ef2ea8df6e910f529c8e452dd' }, this.description), typeof this.compact === 'boolean' ? (this.compact ? linkPure : link) : [linkPure, link])));
	    }
	    static get delegatesFocus() { return true; }
	    get host() { return validateProps.getElement(this); }
	};

	pLinkTile_cjs_entry.p_link_tile = LinkTile;

	
	return pLinkTile_cjs_entry;
}

var pLink_cjs_entry = {};

var hasRequiredPLink_cjs_entry;

function requirePLink_cjs_entry () {
	if (hasRequiredPLink_cjs_entry) return pLink_cjs_entry;
	hasRequiredPLink_cjs_entry = 1;

	Object.defineProperty(pLink_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const linkAriaAttribute = requireLinkAriaAttribute6f29e1a0();
	const buttonLinkPureUtils = requireButtonLinkPureUtils42aabf78();
	const isSsrHydration = requireIsSsrHydration78eae0b3();
	const theme = requireThemeBfc10573();
	const throwIfInvalidLinkUsage = requireThrowIfInvalidLinkUsageB47cf9ae();
	const linkButtonVariant = requireLinkButtonVariantB99795db();
	const linkStyles = requireLinkStyles76fc91e3();
	requireIsParentOfKind4b323732();
	requireGetOnlyChildOfKindHTMLElementOrThrowCdb95e52();
	requireGetDirectChildHTMLElements2594e5bd();
	requireGetHTMLElements3f1c700f();
	requireTransformSelectorToDirectChildSelectorEcc1a9c4();
	requireLinkButtonStyles7215407d();
	requireChangeColor50831612();
	requireColorSchemeStyles4bc3d59c();
	requireHoverMediaQuery5e6deda8();
	requirePreventFoucOfNestedElementsStylesE5a706ce();
	requireBorderRadiusSmall5f37fc45();
	requireTextSmallStyle00e1c6e2();
	requireTextShared5216bb19();
	requireFontFamily23874d28();
	requireFontLineHeightD4b9e1a9();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireFrostedGlassStyleBd067e45();

	const propTypes = {
	    variant: validateProps.AllowedTypes.oneOf(linkButtonVariant.LINK_BUTTON_VARIANTS),
	    icon: validateProps.AllowedTypes.string,
	    iconSource: validateProps.AllowedTypes.string,
	    href: validateProps.AllowedTypes.string,
	    target: validateProps.AllowedTypes.string,
	    download: validateProps.AllowedTypes.string,
	    rel: validateProps.AllowedTypes.string,
	    hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	    compact: validateProps.AllowedTypes.breakpoint('boolean'),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    aria: validateProps.AllowedTypes.aria(linkAriaAttribute.LINK_ARIA_ATTRIBUTES),
	};
	const Link = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.variant = 'primary';
	        this.icon = 'none';
	        this.iconSource = undefined;
	        this.href = undefined;
	        this.target = '_self';
	        this.download = undefined;
	        this.rel = undefined;
	        this.hideLabel = false;
	        this.compact = false;
	        this.theme = 'light';
	        this.aria = undefined;
	    }
	    componentWillLoad() {
	        if (!isSsrHydration.isSsrHydration(this.host)) {
	            // when ssr rendered component is partially hydrated before being rerendered by its parent (e.g. link-tile)
	            // it has no href prop and no slotted anchor, so validation fails
	            throwIfInvalidLinkUsage.throwIfInvalidLinkUsage(this.host, this.href);
	        }
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, linkStyles.getComponentCss, this.icon, this.iconSource, this.variant, this.hideLabel, !this.href, this.compact, this.theme);
	        const TagType = this.href === undefined ? 'span' : 'a';
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(TagType, { key: '2f5ee5cc4a5509f35eac9fbe22aa4a0396e0d994', class: "root", ...(TagType === 'a' && {
	                href: this.href,
	                target: this.target,
	                download: this.download,
	                rel: this.rel,
	                ...validateProps.parseAndGetAriaAttributes(this.aria),
	            }) }, buttonLinkPureUtils.hasVisibleIcon(this.icon, this.iconSource) && (validateProps.h(PrefixedTagNames.pIcon, { key: 'a29542f52eaf5f0f2cf74813eb62a201943271eb', class: "icon", size: "inherit", name: this.iconSource ? undefined : this.icon, source: this.iconSource, theme: this.theme, "aria-hidden": "true" })), validateProps.h("span", { key: 'a4f73501e40312b6bce8d7fa0f9454b53a483565', class: "label" }, validateProps.h("slot", { key: '64034a3c4aa8e2a1bd71a24f36f1f891f98ad2b2' }))));
	    }
	    static get delegatesFocus() { return true; }
	    get host() { return validateProps.getElement(this); }
	};

	pLink_cjs_entry.p_link = Link;

	
	return pLink_cjs_entry;
}

var pMarque_cjs_entry = {};

var hasRequiredPMarque_cjs_entry;

function requirePMarque_cjs_entry () {
	if (hasRequiredPMarque_cjs_entry) return pMarque_cjs_entry;
	hasRequiredPMarque_cjs_entry = 1;

	Object.defineProperty(pMarque_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const getCDNBaseURL = requireGetCDNBaseURLE7722df3();
	const linkAriaAttribute = requireLinkAriaAttribute6f29e1a0();
	const warnIfDeprecatedComponentIsUsed = requireWarnIfDeprecatedComponentIsUsedB14eebd2();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();

	// index.ts
	var MARQUES_MANIFEST = { "porscheMarqueTrademark": { "medium": { "1x": { "png": "porsche-marque-trademark.medium.da07531@1x.png", "webp": "porsche-marque-trademark.medium.5c6af9a@1x.webp" }, "2x": { "png": "porsche-marque-trademark.medium.aa801f4@2x.png", "webp": "porsche-marque-trademark.medium.fff6e9b@2x.webp" }, "3x": { "png": "porsche-marque-trademark.medium.824818d@3x.png", "webp": "porsche-marque-trademark.medium.f67092f@3x.webp" } }, "small": { "1x": { "png": "porsche-marque-trademark.small.020244b@1x.png", "webp": "porsche-marque-trademark.small.7836397@1x.webp" }, "2x": { "png": "porsche-marque-trademark.small.92184fa@2x.png", "webp": "porsche-marque-trademark.small.760a57e@2x.webp" }, "3x": { "png": "porsche-marque-trademark.small.fd545ce@3x.png", "webp": "porsche-marque-trademark.small.1726036@3x.webp" } } }, "porscheMarque": { "medium": { "1x": { "png": "porsche-marque.medium.a986274@1x.png", "webp": "porsche-marque.medium.fa908e4@1x.webp" }, "2x": { "png": "porsche-marque.medium.089d6dd@2x.png", "webp": "porsche-marque.medium.7f0893d@2x.webp" }, "3x": { "png": "porsche-marque.medium.2cb8743@3x.png", "webp": "porsche-marque.medium.3534cf0@3x.webp" } }, "small": { "1x": { "png": "porsche-marque.small.ac20427@1x.png", "webp": "porsche-marque.small.005debe@1x.webp" }, "2x": { "png": "porsche-marque.small.22f1e9d@2x.png", "webp": "porsche-marque.small.df43173@2x.webp" }, "3x": { "png": "porsche-marque.small.4920924@3x.png", "webp": "porsche-marque.small.cfd6149@3x.webp" } } }, "porscheMarque75": { "medium": { "1x": { "png": "porsche-marque75.medium.0a02e22@1x.png", "webp": "porsche-marque75.medium.99b2d65@1x.webp" }, "2x": { "png": "porsche-marque75.medium.1d41ecf@2x.png", "webp": "porsche-marque75.medium.e32580c@2x.webp" }, "3x": { "png": "porsche-marque75.medium.373bcb5@3x.png", "webp": "porsche-marque75.medium.4a003d1@3x.webp" } }, "small": { "1x": { "png": "porsche-marque75.small.f5b37fe@1x.png", "webp": "porsche-marque75.small.146b06c@1x.webp" }, "2x": { "png": "porsche-marque75.small.20d8690@2x.png", "webp": "porsche-marque75.small.025770f@2x.webp" }, "3x": { "png": "porsche-marque75.small.e89b13e@3x.png", "webp": "porsche-marque75.small.a725d2e@3x.webp" } } } };

	const MARQUE_VARIANTS = ['75-years', 'default'];
	const getInnerManifest = (variant, trademark) => MARQUES_MANIFEST[variant === '75-years' ? 'porscheMarque75' : `porscheMarque${trademark ? 'Trademark' : ''}`];
	const buildSrcSet = (innerManifest, size, format) => 
	// eslint-disable-next-line @typescript-eslint/no-unsafe-argument
	Object.entries(innerManifest[size])
	    .map(([resolution, fileName]) => `${getCDNBaseURL.getCDNBaseURL()}/marque/${fileName[format]} ${resolution}`)
	    .join();
	const buildImgSrc = (innerManifest) => `${getCDNBaseURL.getCDNBaseURL()}/marque/${innerManifest.medium['2x'].png}`;

	const baseSizes = {
	    small: {
	        width: '100px',
	        height: '60px',
	    },
	    medium: {
	        width: '120px',
	        height: '72px',
	    },
	};
	const getComponentCss = (size) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                position: 'relative',
	                display: 'inline-flex',
	                verticalAlign: 'top',
	                ...validateProps.addImportantToEachRule({
	                    outline: 0,
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            a: {
	                display: 'block',
	                textDecoration: 'none',
	                outline: 0,
	                '&::before': {
	                    // needs to be defined always to have correct custom click area
	                    content: '""',
	                    position: 'absolute',
	                    inset: 0,
	                    borderRadius: '1px',
	                },
	                ...validateProps.getFocusJssStyle('light', { pseudo: true }), // TODO: we need to support theme
	            },
	            picture: {
	                display: 'block',
	                ...(size === 'responsive'
	                    ? {
	                        ...baseSizes.small,
	                        [validateProps.getMediaQueryMin('l')]: baseSizes.medium,
	                    }
	                    : baseSizes[size]),
	            },
	            img: {
	                display: 'block',
	                width: '100%',
	                height: 'auto',
	            },
	        },
	    });
	};

	const MARQUE_SIZES = ['responsive', 'small', 'medium'];

	const propTypes = {
	    trademark: validateProps.AllowedTypes.boolean,
	    variant: validateProps.AllowedTypes.oneOf(MARQUE_VARIANTS),
	    size: validateProps.AllowedTypes.oneOf(MARQUE_SIZES),
	    href: validateProps.AllowedTypes.string,
	    target: validateProps.AllowedTypes.string,
	    aria: validateProps.AllowedTypes.aria(linkAriaAttribute.LINK_ARIA_ATTRIBUTES),
	};
	const Marque = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.trademark = true;
	        this.variant = 'default';
	        this.size = 'responsive';
	        this.href = undefined;
	        this.target = '_self';
	        this.aria = undefined;
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedComponentIsUsed.warnIfDeprecatedComponentIsUsed(this.host, 'Please use new p-wordmark component instead.');
	        validateProps.attachComponentCss(this.host, getComponentCss, this.size);
	        const innerManifest = getInnerManifest(this.variant, this.trademark);
	        const mediumMedia = `(min-width: ${validateProps.breakpoint.l}px)`;
	        const picture = window.PDS_SKIP_FETCH ? undefined :  (validateProps.h("picture", { key: 'db3c99e42b46f23b59c348f5075efee40bcc5643' }, this.size === 'responsive'
	            ? [
	                validateProps.h("source", { key: "medium-webp", srcSet: buildSrcSet(innerManifest, 'medium', 'webp'), media: mediumMedia, type: "image/webp" }),
	                validateProps.h("source", { key: "medium-png", srcSet: buildSrcSet(innerManifest, 'medium', 'png'), media: mediumMedia, type: "image/png" }),
	                validateProps.h("source", { key: "small-webp", srcSet: buildSrcSet(innerManifest, 'small', 'webp'), type: "image/webp" }),
	                validateProps.h("source", { key: "small-png", srcSet: buildSrcSet(innerManifest, 'small', 'png'), type: "image/png" }),
	            ]
	            : [
	                validateProps.h("source", { key: "webp", srcSet: buildSrcSet(innerManifest, this.size, 'webp'), type: "image/webp" }),
	                validateProps.h("source", { key: "png", srcSet: buildSrcSet(innerManifest, this.size, 'png'), type: "image/png" }),
	            ], validateProps.h("img", { key: '190cafd4acd93add14e1bec3288da037c60e3757', src: buildImgSrc(innerManifest), alt: "Porsche" })));
	        return (validateProps.h(validateProps.Host, { key: 'cbee7fe3bf28d0008b3309293eec21a1bb3bbae0' }, this.href === undefined ? (picture) : (validateProps.h("a", { href: this.href, target: this.target, ...validateProps.parseAndGetAriaAttributes(this.aria) }, picture))));
	    }
	    static get delegatesFocus() { return true; }
	    get host() { return validateProps.getElement(this); }
	};

	pMarque_cjs_entry.p_marque = Marque;

	
	return pMarque_cjs_entry;
}

var pModal_cjs_entry = {};

var warnIfAriaAndHeadingPropsAreUndefined52718ac1 = {};

var hasRequiredWarnIfAriaAndHeadingPropsAreUndefined52718ac1;

function requireWarnIfAriaAndHeadingPropsAreUndefined52718ac1 () {
	if (hasRequiredWarnIfAriaAndHeadingPropsAreUndefined52718ac1) return warnIfAriaAndHeadingPropsAreUndefined52718ac1;
	hasRequiredWarnIfAriaAndHeadingPropsAreUndefined52718ac1 = 1;

	const validateProps = requireValidateProps788e2bc5();

	const warnIfAriaAndHeadingPropsAreUndefined = (host, hasHeading, aria) => {
	    if (!hasHeading && !aria) {
	        validateProps.consoleWarn(`heading prop (deprecated), aria prop or header slot has to be set for component ${validateProps.getTagNameWithoutPrefix(host)} in order to ensure accessibility.`, host);
	    }
	};

	warnIfAriaAndHeadingPropsAreUndefined52718ac1.warnIfAriaAndHeadingPropsAreUndefined = warnIfAriaAndHeadingPropsAreUndefined;

	
	return warnIfAriaAndHeadingPropsAreUndefined52718ac1;
}

var hasRequiredPModal_cjs_entry;

function requirePModal_cjs_entry () {
	if (hasRequiredPModal_cjs_entry) return pModal_cjs_entry;
	hasRequiredPModal_cjs_entry = 1;

	Object.defineProperty(pModal_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const dialogStyles = requireDialogStyles52804ea9();
	const getSlotTextContent = requireGetSlotTextContent3ec731e2();
	const hasNamedSlot = requireHasNamedSlot273cd3ae();
	const observer = requireObserver98c271bc();
	const hasHeading = requireHasHeading5ac42b7f();
	const warnIfAriaAndHeadingPropsAreUndefined = requireWarnIfAriaAndHeadingPropsAreUndefined52718ac1();
	const helper = requireHelper22e15c0e();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed76f87eda();
	const setScrollLock = requireSetScrollLock68edfbd1();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const spacingFluidSmall = requireSpacingFluidSmall2c6caae7();
	const spacingFluidMedium = requireSpacingFluidMedium88ab712b();
	const spacingFluidLarge = requireSpacingFluidLarge6087a0f7();
	const borderRadiusMedium = requireBorderRadiusMedium758b9411();
	const headingShared = requireHeadingShared888aa084();
	const fontSizeHeadingLarge = requireFontSizeHeadingLargeC355151d();
	const gridExtendedOffsetBase = requireGridExtendedOffsetBaseFb9830f6();
	requireGridGapB5b73e4a();
	requireSpacingStaticMedium94812711();
	requireFrostedGlassStyleBd067e45();
	requireGetNamedSlot223c478a();
	requireFontFamily23874d28();
	requireFontLineHeightD4b9e1a9();
	requireFontWeightSemiBold4482c830();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextLarge05a4bc90();

	const headingLargeStyle = {
	    font: `${headingShared._headingFontPartA}${fontSizeHeadingLarge.fontSizeHeadingLarge}${headingShared._headingFontPartB}`,
	};

	const cssVariableWidth = '--p-modal-width';
	const cssVariableSpacingTop = '--p-modal-spacing-top'; // TODO: maybe --p-modal-spacing-block-start would be more precise?
	const cssVariableSpacingBottom = '--p-modal-spacing-bottom'; // TODO: maybe --p-modal-spacing-block-end would be more precise?
	const safeZoneVertical = `calc(${spacingFluidSmall.spacingFluidSmall} + ${spacingFluidMedium.spacingFluidMedium})`;
	const safeZoneHorizontal = `${spacingFluidLarge.spacingFluidLarge}`;
	const cssClassNameStretchToFullModalWidth = 'stretch-to-full-modal-width';
	const getComponentCss = (isOpen, backdrop, fullscreen, hasDismissButton, hasHeader, hasFooter, theme) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...dialogStyles.dialogHostJssStyle,
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            // TODO: why not available to Flyout too?
	            // TODO: discussable if so many styles are a good thing, since we could also expose one or two CSS variables with which a stretch to full width is possible too
	            '::slotted': validateProps.addImportantToEachRule(validateProps.mergeDeep({
	                [`&(.${cssClassNameStretchToFullModalWidth})`]: {
	                    display: 'block',
	                    margin: `0 calc(${safeZoneHorizontal} * -1)`,
	                    width: `calc(100% + calc(${safeZoneHorizontal} * 2))`,
	                },
	                ...(!hasHeader && {
	                    [`&(.${cssClassNameStretchToFullModalWidth}:first-child)`]: {
	                        marginBlockStart: `calc(${safeZoneVertical} * -1)`,
	                    },
	                }),
	                ...(!hasFooter && {
	                    [`&(.${cssClassNameStretchToFullModalWidth}:last-child)`]: {
	                        marginBlockEnd: `calc(${safeZoneVertical} * -1)`,
	                    },
	                }),
	            }, validateProps.buildResponsiveStyles(fullscreen, (fullscreenValue) => ({
	                [`&(.${cssClassNameStretchToFullModalWidth}:first-child)`]: {
	                    borderTopLeftRadius: fullscreenValue ? 0 : borderRadiusMedium.borderRadiusMedium,
	                    borderTopRightRadius: fullscreenValue ? 0 : borderRadiusMedium.borderRadiusMedium,
	                },
	                [`&(.${cssClassNameStretchToFullModalWidth}:last-child)`]: {
	                    borderBottomLeftRadius: fullscreenValue ? 0 : borderRadiusMedium.borderRadiusMedium,
	                    borderBottomRightRadius: fullscreenValue ? 0 : borderRadiusMedium.borderRadiusMedium,
	                },
	            })))),
	            slot: {
	                display: 'block',
	                '&:first-of-type': {
	                    gridRowStart: 1,
	                },
	                '&:not([name])': {
	                    gridColumn: '2/3',
	                    zIndex: 0, // controls layering + creates new stacking context (prevents content within to be above other dialog areas)
	                },
	                ...(hasHeader && {
	                    '&[name=header]': {
	                        gridColumn: '2/3',
	                        zIndex: 0, // controls layering + creates new stacking context (prevents content within to be above other dialog areas)
	                    },
	                }),
	                ...(hasFooter && {
	                    '&[name=footer]': {
	                        ...dialogStyles.getDialogStickyAreaJssStyle('footer', theme),
	                        gridColumn: '1/-1',
	                        zIndex: 1, // controls layering + creates new stacking context (prevents content within to be above other dialog areas)
	                    },
	                }),
	            },
	            ...(hasHeader && {
	                // TODO: we should either deprecate heading slot + pre-styled headings or implement it in flyout too
	                [`slot[name=heading],${dialogStyles.headingTags}`]: {
	                    gridRowStart: 1,
	                    gridColumn: '2/3',
	                    zIndex: 0, // controls layering + creates new stacking context (prevents content within to be above other dialog areas)
	                    ...headingLargeStyle,
	                    margin: 0, // relevant for shadowed h1,h2,h3,
	                },
	                [`:is(${dialogStyles.headingTags}) ~ slot:first-of-type`]: {
	                    gridRowStart: 'auto',
	                },
	                [`::slotted([slot="heading"]:is(${dialogStyles.headingTags}))`]: {
	                    margin: 0, // ua-style (relevant for e.g. <h3 slot="heading"/>)
	                },
	            }),
	            dialog: dialogStyles.getDialogJssStyle(isOpen, theme, backdrop),
	        },
	        scroller: dialogStyles.getScrollerJssStyle('fullscreen', theme),
	        modal: {
	            ...dialogStyles.dialogGridJssStyle,
	            ...dialogStyles.getDialogColorJssStyle(theme),
	            ...dialogStyles.getDialogTransitionJssStyle(isOpen, '^'),
	            // TODO: maybe we should deprecate the fullscreen property and force the modal to be fullscreen on mobile only
	            ...validateProps.buildResponsiveStyles(fullscreen, (fullscreenValue) => fullscreenValue
	                ? {
	                    width: 'auto',
	                    minWidth: 'auto',
	                    maxWidth: 'none',
	                    placeSelf: 'stretch',
	                    margin: 0,
	                    borderRadius: 0,
	                }
	                : {
	                    width: `var(${cssVariableWidth},auto)`,
	                    minWidth: '276px', // to be in sync with "Porsche Grid" on viewport = 320px: calc(${gridColumnWidthBase} * 6 + ${gridGap} * 5)
	                    maxWidth: '1535.5px', // to be in sync with "Porsche Grid" on viewport >= 1920px: `calc(${gridColumnWidthXXL} * 14 + ${gridGap} * 13)`
	                    placeSelf: 'center',
	                    margin: `var(${cssVariableSpacingTop},clamp(16px, 10vh, 192px)) ${gridExtendedOffsetBase.gridExtendedOffsetBase} var(${cssVariableSpacingBottom},clamp(16px, 10vh, 192px))`, // horizontal margin is needed to ensure modal is placed on "Porsche Grid" when slotted content is wider than the viewport width
	                    borderRadius: borderRadiusMedium.borderRadiusMedium,
	                }),
	        },
	        ...(hasDismissButton && {
	            dismiss: {
	                ...validateProps.dismissButtonJssStyle,
	                gridArea: '1/3',
	                zIndex: 2, // ensures dismiss button is above sticky footer, header and content
	                position: 'sticky',
	                insetBlockStart: spacingFluidSmall.spacingFluidSmall,
	                marginBlockStart: `calc(${spacingFluidMedium.spacingFluidMedium} * -1)`,
	                marginInlineEnd: spacingFluidSmall.spacingFluidSmall,
	                placeSelf: 'flex-start flex-end',
	            },
	        }),
	    });
	};

	const MODAL_ARIA_ATTRIBUTES = ['aria-label', 'role'];

	const propTypes = {
	    open: validateProps.AllowedTypes.boolean,
	    disableCloseButton: validateProps.AllowedTypes.boolean,
	    dismissButton: validateProps.AllowedTypes.boolean,
	    disableBackdropClick: validateProps.AllowedTypes.boolean,
	    heading: validateProps.AllowedTypes.string,
	    backdrop: validateProps.AllowedTypes.oneOf(dialogStyles.BACKDROPS),
	    fullscreen: validateProps.AllowedTypes.breakpoint('boolean'),
	    aria: validateProps.AllowedTypes.aria(MODAL_ARIA_ATTRIBUTES),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Modal = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.close = validateProps.createEvent(this, "close", 3);
	        this.dismiss = validateProps.createEvent(this, "dismiss", 3);
	        this.motionVisibleEnd = validateProps.createEvent(this, "motionVisibleEnd", 3);
	        this.motionHiddenEnd = validateProps.createEvent(this, "motionHiddenEnd", 3);
	        this.dismissDialog = () => {
	            this.dismiss.emit();
	            this.close.emit();
	        };
	        this.ariaLabel = () => {
	            return (this.heading ||
	                (hasNamedSlot.hasNamedSlot(this.host, 'heading') && getSlotTextContent.getSlotTextContent(this.host, 'heading')) ||
	                (hasNamedSlot.hasNamedSlot(this.host, 'header') && getSlotTextContent.getSlotTextContent(this.host, 'header')));
	        };
	        this.open = false;
	        this.disableCloseButton = undefined;
	        this.dismissButton = true;
	        this.disableBackdropClick = false;
	        this.heading = undefined;
	        this.backdrop = 'blur';
	        this.fullscreen = false;
	        this.aria = undefined;
	        this.theme = 'light';
	    }
	    get hasDismissButton() {
	        return this.disableCloseButton ? false : this.dismissButton;
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    connectedCallback() {
	        // Observe dynamic slot changes
	        validateProps.observeChildren(this.host, () => {
	            validateProps.forceUpdate(this.host);
	        }, undefined, { subtree: false, childList: true, attributes: false });
	    }
	    componentWillRender() {
	        setScrollLock.setScrollLock(this.open);
	    }
	    componentDidRender() {
	        dialogStyles.setDialogVisibility(this.open, this.dialog, this.scroller);
	    }
	    componentDidLoad() {
	        if (this.hasFooter) {
	            // Has to be called here instead of render to assure that the slot references are available
	            observer.observeStickyArea(this.scroller, this.footer);
	        }
	    }
	    componentDidUpdate() {
	        if (this.hasFooter) {
	            // Has to be called here instead of render to assure that the slot references are available
	            // When slots change dynamically the intersection observer for the scroll shadows has to be added
	            observer.observeStickyArea(this.scroller, this.footer);
	        }
	    }
	    disconnectedCallback() {
	        setScrollLock.setScrollLock(false);
	        validateProps.unobserveChildren(this.host);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'disableCloseButton', 'Please use dismissButton prop instead.');
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'heading', 'Please use the slot="header" instead.');
	        if (hasNamedSlot.hasNamedSlot(this.host, 'heading')) {
	            validateProps.consoleWarn(helper.getDeprecatedPropOrSlotWarningMessage(this.host, 'slot="heading"'), 'Please use the slot="header" instead.');
	        }
	        this.hasHeader = hasHeading.hasHeading(this.host, this.heading) || hasNamedSlot.hasNamedSlot(this.host, 'header');
	        this.hasFooter = hasNamedSlot.hasNamedSlot(this.host, 'footer');
	        // TODO: why do we validate only when opened?
	        if (this.open) {
	            warnIfAriaAndHeadingPropsAreUndefined.warnIfAriaAndHeadingPropsAreUndefined(this.host, this.hasHeader, this.aria);
	        }
	        validateProps.attachComponentCss(this.host, getComponentCss, this.open, this.backdrop, this.fullscreen, this.hasDismissButton, this.hasHeader, this.hasFooter, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h("dialog", { key: '53d49aae81348bdfd513ac474daa56e8ba36b10e', inert: !this.open, tabIndex: -1, ref: (el) => (this.dialog = el), onCancel: (e) => dialogStyles.onCancelDialog(e, this.dismissDialog, !this.hasDismissButton),
	            // Previously done with onMouseDown to change the click behavior (not closing when pressing mousedown on modal and mouseup on backdrop) but changed back to native behavior
	            onClick: (e) => dialogStyles.onClickDialog(e, this.dismissDialog, this.disableBackdropClick), onTransitionEnd: (e) => dialogStyles.onTransitionEnd(e, this.open, this.motionVisibleEnd, this.motionHiddenEnd), ...validateProps.parseAndGetAriaAttributes({
	                'aria-modal': true,
	                ...(this.hasHeader && { 'aria-label': this.ariaLabel() }),
	                ...validateProps.parseAndGetAriaAttributes(this.aria),
	            }) }, validateProps.h("div", { key: '3bb15cd43ec1b1bd33239a0577e561361a05d648', class: "scroller", ref: (el) => (this.scroller = el) }, validateProps.h("div", { key: '6c8f13386a97483f18507fa1bbe3441bcaaff7c9', class: "modal" }, this.hasDismissButton && (validateProps.h(PrefixedTagNames.pButton, { key: '9b8439ca901fa86c71435f83b08d073de4f61460', variant: "ghost", class: "dismiss", type: "button", hideLabel: true, icon: "close", onClick: this.dismissDialog, theme: this.theme }, "Dismiss modal")), this.hasHeader &&
	            (this.heading ? (validateProps.h("h2", null, this.heading)) : hasNamedSlot.hasNamedSlot(this.host, 'heading') ? (validateProps.h("slot", { name: "heading" })) : (validateProps.h("slot", { name: "header" }))), validateProps.h("slot", { key: '26a1eaee8acdc78a0bb6715549f5dbe4cce66ee8' }), this.hasFooter && validateProps.h("slot", { key: '57dd277bf92f7388d7b69da103656209ba36951f', name: "footer", ref: (el) => (this.footer = el) })))));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pModal_cjs_entry.p_modal = Modal;

	
	return pModal_cjs_entry;
}

var pModelSignature_cjs_entry = {};

var hasRequiredPModelSignature_cjs_entry;

function requirePModelSignature_cjs_entry () {
	if (hasRequiredPModelSignature_cjs_entry) return pModelSignature_cjs_entry;
	hasRequiredPModelSignature_cjs_entry = 1;

	Object.defineProperty(pModelSignature_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const theme = requireThemeBfc10573();
	const getCDNBaseURL = requireGetCDNBaseURLE7722df3();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const forcedColorsMediaQuery = requireForcedColorsMediaQuery69d5b1ca();

	// index.ts
	var MODEL_SIGNATURES_MANIFEST = { "718": { "src": "718.493a9e3.svg", "width": 79, "height": 26 }, "911": { "src": "911.b68f913.svg", "width": 94, "height": 25 }, "boxster": { "src": "boxster.c321738.svg", "width": 239, "height": 26 }, "cayenne": { "src": "cayenne.2556201.svg", "width": 245, "height": 35 }, "cayman": { "src": "cayman.cc89196.svg", "width": 229, "height": 35 }, "macan": { "src": "macan.a1844f4.svg", "width": 196, "height": 26 }, "panamera": { "src": "panamera.6dae809.svg", "width": 260, "height": 25 }, "taycan": { "src": "taycan.df444c6.svg", "width": 167, "height": 36 }, "turbo-s": { "src": "turbo-s.73f1e10.svg", "width": 199, "height": 25 }, "turbo": { "src": "turbo.6a4084a.svg", "width": 143, "height": 25 } };

	const MODEL_SIGNATURE_FETCH_PRIORITY = ['low', 'high', 'auto'];
	const MODEL_SIGNATURE_SIZES = ['small', 'inherit'];
	const MODEL_SIGNATURE_MODELS = Object.keys(MODEL_SIGNATURES_MANIFEST);
	const MODEL_SIGNATURE_COLORS = [
	    'primary',
	    'contrast-low',
	    'contrast-medium',
	    'contrast-high',
	    'inherit',
	];
	const getSvgUrl = (model) => {
	    return `${getCDNBaseURL.getCDNBaseURL()}/model-signatures/${MODEL_SIGNATURES_MANIFEST[model].src}`;
	};

	const cssVariableWidth = '--p-model-signature-width';
	const cssVariableHeight = '--p-model-signature-height';
	const cssVariableColor = '--p-model-signature-color';
	const { canvasTextColor } = validateProps.getHighContrastColors();
	const getThemedColor = (color, themedColors) => {
	    const colorMap = {
	        primary: themedColors.primaryColor,
	        inherit: 'black',
	        'contrast-low': themedColors.contrastLowColor,
	        'contrast-medium': themedColors.contrastMediumColor,
	        'contrast-high': themedColors.contrastHighColor,
	    };
	    return colorMap[color];
	};
	const getComponentCss = (model, safeZone, size, color, theme) => {
	    const { width, height } = MODEL_SIGNATURES_MANIFEST[model];
	    const isSizeInherit = size === 'inherit';
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'inline-block',
	                verticalAlign: 'top',
	                maxWidth: '100%',
	                maxHeight: '100%',
	                // width + height style can't be !important atm to be backwards compatible with e.g. `<p-model-signature size="inherit" style="height: 50px"/>`
	                width: `var(${cssVariableWidth},${isSizeInherit ? 'auto' : `${width}px`})`,
	                height: `var(${cssVariableHeight},auto)`,
	                ...validateProps.addImportantToEachRule({
	                    mask: `url(${getSvgUrl(model)}) no-repeat left top / contain`,
	                    aspectRatio: `${width} / ${safeZone ? 36 : height}`, // 36px is the max-height for SVG model signature creation
	                    background: `var(${cssVariableColor},${getThemedColor(color, validateProps.getThemedColors(theme))})`,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        background: `var(${cssVariableColor},${getThemedColor(color, validateProps.getThemedColors('dark'))})`,
	                    }),
	                    ...forcedColorsMediaQuery.forcedColorsMediaQuery({
	                        background: canvasTextColor,
	                    }),
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            '::slotted(:is(img,video))': validateProps.addImportantToEachRule({
	                display: 'block', // prevents unintended bottom white-space
	                width: '100%',
	                height: '100%',
	                objectFit: 'cover',
	            }),
	            // the <img /> is only needed for a11y compliance because of alt text and to handle the fetch priority
	            img: {
	                position: 'absolute', // prevents unintended bottom white-space
	                opacity: 0,
	                width: '1px',
	                height: '1px',
	            },
	        },
	    });
	};

	const propTypes = {
	    model: validateProps.AllowedTypes.oneOf(MODEL_SIGNATURE_MODELS),
	    safeZone: validateProps.AllowedTypes.boolean,
	    fetchPriority: validateProps.AllowedTypes.oneOf(MODEL_SIGNATURE_FETCH_PRIORITY),
	    lazy: validateProps.AllowedTypes.boolean,
	    size: validateProps.AllowedTypes.oneOf(MODEL_SIGNATURE_SIZES),
	    color: validateProps.AllowedTypes.oneOf(MODEL_SIGNATURE_COLORS),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const ModelSignature = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.model = '911';
	        this.safeZone = true;
	        this.fetchPriority = 'auto';
	        this.lazy = false;
	        this.size = 'small';
	        this.color = 'primary';
	        this.theme = 'light';
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.model, this.safeZone, this.size, this.color, this.theme);
	        const fetchPriority = this.fetchPriority !== 'auto' ? this.fetchPriority : null;
	        const loading = this.lazy === true ? 'lazy' : null;
	        return (validateProps.h(validateProps.Host, { key: '789514a21f3fd986465006eeb43a2ab0569aa511' }, validateProps.h("slot", { key: '1d16b700e07cd56aefb9f07aa6a1492237a68b1a' }), validateProps.h("img", { key: '1ffcfbe432c4f89aeaf37f8359d6dea89d847e8c', fetchpriority: fetchPriority, loading: loading, src: getSvgUrl(this.model), alt: this.model })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pModelSignature_cjs_entry.p_model_signature = ModelSignature;

	
	return pModelSignature_cjs_entry;
}

var pMultiSelect_2_cjs_entry = {};

var popover8518c8b1 = {};

var hasRequiredPopover8518c8b1;

function requirePopover8518c8b1 () {
	if (hasRequiredPopover8518c8b1) return popover8518c8b1;
	hasRequiredPopover8518c8b1 = 1;

	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();
	const fontFamily = requireFontFamily23874d28();
	const fontLineHeight = requireFontLineHeightD4b9e1a9();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const validateProps = requireValidateProps788e2bc5();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const textSmallStyle = requireTextSmallStyle00e1c6e2();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const isClickOutside = requireIsClickOutside050dc86b();
	const borderRadiusMedium = requireBorderRadiusMedium758b9411();

	const getFilterInputAriaAttributes = (isOpen, isRequired, labelId, descriptionId, dropdownId, activeDescendantId) => {
	    return {
	        ...getSelectDropdownButtonAriaAttributes(isOpen, labelId, descriptionId, dropdownId, activeDescendantId),
	        'aria-autocomplete': 'list',
	        ...(isRequired && {
	            'aria-required': 'true',
	        }),
	    };
	};
	const getSelectDropdownButtonAriaAttributes = (isOpen, labelId, descriptionId, dropdownId, activeDescendantId) => {
	    return {
	        'aria-labelledby': labelId || null,
	        'aria-describedby': descriptionId || null,
	        'aria-haspopup': 'listbox',
	        'aria-expanded': isOpen ? 'true' : 'false',
	        'aria-controls': dropdownId,
	        ...(isOpen &&
	            activeDescendantId !== undefined && {
	            'aria-activedescendant': `option-${activeDescendantId}`,
	        }),
	    };
	};
	// TODO: Can this be shared with select-wrapper dropdown?
	const getComboboxAriaAttributes = (isOpen, isRequired, labelId, descriptionId, dropdownId) => {
	    return {
	        'aria-labelledby': labelId || null,
	        'aria-describedby': descriptionId || null,
	        'aria-haspopup': 'listbox',
	        'aria-expanded': isOpen ? 'true' : 'false',
	        'aria-required': isRequired ? 'true' : 'false',
	        'aria-controls': dropdownId,
	    };
	};
	// TODO: Change to aria-labelledby
	const getListAriaAttributes = (label, isRequired, hasFilter, isOpen, multiple = false) => {
	    return {
	        role: 'listbox',
	        'aria-label': label,
	        ...(isRequired &&
	            !hasFilter && {
	            'aria-required': 'true',
	        }),
	        ...(!isOpen && {
	            'aria-hidden': 'true',
	        }),
	        ...(multiple && {
	            'aria-multiselectable': 'true',
	        }),
	    };
	};
	const getOptionAriaAttributes = (isSelected, isDisabled, isHidden, hasValue) => ({
	    ...(!isHidden && { 'aria-selected': isSelected ? 'true' : 'false' }),
	    'aria-disabled': isDisabled ? 'true' : null,
	    'aria-hidden': isHidden ? 'true' : null,
	    'aria-label': hasValue ? null : 'Empty value',
	});

	const OPTION_LIST_SAFE_ZONE = 6;
	const optionListUpdatePosition = async (direction, anchor, popover) => {
	    const { x, y } = await isClickOutside.computePosition(anchor, popover, {
	        placement: direction === 'up' ? 'top' : 'bottom',
	        middleware: [
	            isClickOutside.size({
	                // @ts-expect-error
	                apply({ rects, elements }) {
	                    Object.assign(elements.floating.style, {
	                        width: `${rects.reference.width}px`,
	                    });
	                },
	            }),
	            isClickOutside.offset(OPTION_LIST_SAFE_ZONE),
	            isClickOutside.flip({
	                padding: OPTION_LIST_SAFE_ZONE,
	                fallbackAxisSideDirection: 'none',
	            }),
	        ],
	    });
	    Object.assign(popover.style, {
	        left: `${x}px`,
	        top: `${y}px`,
	    });
	};

	const getNoResultsOptionJssStyle = () => ({
	    '&[role=status]': {
	        cursor: 'not-allowed',
	    },
	    // TODO: shouldn't be used here, instead use sr-only functional component and style
	    '&__sr': validateProps.getHiddenTextJssStyle(),
	});

	const getButtonImageJssStyle = {
	    font: `${fontSizeTextSmall.fontSizeTextSmall} ${fontFamily.fontFamily}`, // needed for correct calculations based on ex-unit
	    width: 'auto',
	    height: fontLineHeight.fontLineHeight,
	    borderRadius: borderRadiusSmall.borderRadiusSmall,
	};

	const getOptionJssStyle = (componentName, cssVarScaling, // "1" is needed for components not yet supporting compact mode
	theme) => {
	    const { primaryColor: primaryColorDark, hoverColor: hoverColorDark, contrastHighColor: contrastHighColorDark, disabledColor: disabledColorDark, contrastLowColor: contrastLowColorDark, } = validateProps.getThemedColors('dark');
	    const { primaryColor, hoverColor, contrastLowColor, contrastHighColor, disabledColor } = validateProps.getThemedColors(theme);
	    const { highlightColor } = validateProps.getHighContrastColors();
	    const gap = `max(4px, ${cssVarScaling} * 12px)`;
	    const paddingBlock = `max(2px, ${cssVarScaling} * ${spacingStaticSmall.spacingStaticSmall})`;
	    const paddingInline = `max(4px, ${cssVarScaling} * var(--p-internal-${componentName}-padding-left, 12px)) max(4px, ${cssVarScaling} * 12px)`;
	    return {
	        display: 'flex',
	        gap,
	        paddingBlock,
	        paddingInline,
	        minHeight: fontLineHeight.fontLineHeight, // preserves height for empty option
	        ...textSmallStyle.textSmallStyle,
	        color: contrastHighColor,
	        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	            color: contrastHighColorDark,
	        }),
	        cursor: 'pointer',
	        textAlign: 'start',
	        wordBreak: 'break-word',
	        boxSizing: 'content-box',
	        borderRadius: borderRadiusSmall.borderRadiusSmall,
	        transition: `${validateProps.getTransition('background-color')}, ${validateProps.getTransition('color')}`,
	        ...getNoResultsOptionJssStyle(),
	        ...hoverMediaQuery.hoverMediaQuery({
	            '&:not([aria-disabled]):not(.option--disabled):not([role=status]):hover': {
	                color: validateProps.isHighContrastMode ? highlightColor : primaryColor,
	                background: hoverColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: validateProps.isHighContrastMode ? highlightColor : primaryColorDark,
	                    background: hoverColorDark,
	                }),
	            },
	        }),
	        '&--selected': {
	            ...(componentName === 'select-option' && {
	                cursor: 'default',
	                pointerEvents: 'none',
	            }),
	            background: hoverColor,
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                background: hoverColorDark,
	            }),
	        },
	        '&--highlighted': {
	            background: contrastLowColor,
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                background: contrastLowColorDark,
	            }),
	        },
	        '&--highlighted, &--selected': {
	            color: validateProps.isHighContrastMode ? highlightColor : primaryColor,
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                color: validateProps.isHighContrastMode ? highlightColor : primaryColorDark,
	            }),
	        },
	        '&--disabled': {
	            cursor: 'not-allowed',
	            color: disabledColor,
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                color: disabledColorDark,
	            }),
	        },
	        '&--hidden': {
	            display: 'none',
	        },
	    };
	};

	const keyframesName = 'fade-in';
	const getPopoverKeyframesStyles = {
	    [`@keyframes ${keyframesName}`]: {
	        from: {
	            opacity: 0,
	        },
	        to: {
	            opacity: 1,
	        },
	    },
	};
	const getPopoverJssStyle = (isOpen, cssVarScaling, // "1" is needed for components not yet supporting compact mode
	optionHeight, theme) => {
	    const { contrastLowColor, backgroundColor, backgroundSurfaceColor } = validateProps.getThemedColors(theme);
	    const { contrastLowColor: contrastLowColorDark, backgroundSurfaceColor: backgroundSurfaceColorDark } = validateProps.getThemedColors('dark');
	    const minHeightOptionList = `calc(${4.5 * (optionHeight + 8) + 6 + 2}px)`; // 4.5 options * option height + 8px gap + additional spacing (6px = padding, 2px = border)
	    return {
	        all: 'unset',
	        position: 'absolute',
	        zIndex: 99, // needed for backwards compatibility, to enable browsers not supporting #top-layer
	        padding: `max(2px, ${cssVarScaling} * 6px)`,
	        display: isOpen ? 'flex' : 'none', // needed for backwards compatibility, otherwise 'flex' would be enough
	        flexDirection: 'column',
	        gap: `max(2px, ${cssVarScaling} * ${spacingStaticSmall.spacingStaticSmall})`,
	        maxHeight: `max(${minHeightOptionList}, calc(50vh - 54px / 2 - ${OPTION_LIST_SAFE_ZONE}px * 2))`,
	        boxSizing: 'border-box',
	        overflow: 'hidden auto',
	        scrollbarWidth: 'thin', // firefox
	        scrollbarColor: 'auto', // firefox
	        animation: `var(${validateProps.cssVariableAnimationDuration}, ${validateProps.motionDurationShort}) ${keyframesName} ${validateProps.motionEasingBase} forwards`,
	        filter: 'drop-shadow(0 0 8px rgba(0,0,0,0.15))',
	        background: validateProps.isThemeDark(theme) ? backgroundSurfaceColor : backgroundColor,
	        border: `1px solid ${contrastLowColor}`,
	        borderRadius: borderRadiusMedium.borderRadiusMedium,
	        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	            background: backgroundSurfaceColorDark,
	            borderColor: contrastLowColorDark,
	        }),
	        '&:not(:popover-open)': {
	            display: 'none',
	        },
	    };
	};

	popover8518c8b1.getButtonImageJssStyle = getButtonImageJssStyle;
	popover8518c8b1.getComboboxAriaAttributes = getComboboxAriaAttributes;
	popover8518c8b1.getFilterInputAriaAttributes = getFilterInputAriaAttributes;
	popover8518c8b1.getListAriaAttributes = getListAriaAttributes;
	popover8518c8b1.getNoResultsOptionJssStyle = getNoResultsOptionJssStyle;
	popover8518c8b1.getOptionAriaAttributes = getOptionAriaAttributes;
	popover8518c8b1.getOptionJssStyle = getOptionJssStyle;
	popover8518c8b1.getPopoverJssStyle = getPopoverJssStyle;
	popover8518c8b1.getPopoverKeyframesStyles = getPopoverKeyframesStyles;
	popover8518c8b1.getSelectDropdownButtonAriaAttributes = getSelectDropdownButtonAriaAttributes;
	popover8518c8b1.optionListUpdatePosition = optionListUpdatePosition;

	
	return popover8518c8b1;
}

var selectDropdownD9989ebd = {};

var hasRequiredSelectDropdownD9989ebd;

function requireSelectDropdownD9989ebd () {
	if (hasRequiredSelectDropdownD9989ebd) return selectDropdownD9989ebd;
	hasRequiredSelectDropdownD9989ebd = 1;

	const SELECT_DROPDOWN_DIRECTIONS_INTERNAL = ['down', 'up'];
	const SELECT_DROPDOWN_DIRECTIONS = [...SELECT_DROPDOWN_DIRECTIONS_INTERNAL, 'auto'];

	selectDropdownD9989ebd.SELECT_DROPDOWN_DIRECTIONS = SELECT_DROPDOWN_DIRECTIONS;

	
	return selectDropdownD9989ebd;
}

var hasRequiredPMultiSelect_2_cjs_entry;

function requirePMultiSelect_2_cjs_entry () {
	if (hasRequiredPMultiSelect_2_cjs_entry) return pMultiSelect_2_cjs_entry;
	hasRequiredPMultiSelect_2_cjs_entry = 1;

	Object.defineProperty(pMultiSelect_2_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const isClickOutside = requireIsClickOutside050dc86b();
	const isElementOfKind = requireIsElementOfKindF7da6ac6();
	const popover = requirePopover8518c8b1();
	const buttonHandling = requireButtonHandling39869edc();
	const stateMessageStyles = requireStateMessageStylesD1c4637f();
	const selectDropdown = requireSelectDropdownD9989ebd();
	const theme = requireThemeBfc10573();
	const throwIfElementIsNotOfKind = requireThrowIfElementIsNotOfKindAb86026b();
	const slottedAnchorStyles = requireSlottedAnchorStylesFe1a10c2();
	const labelStyles = requireLabelStylesD5916d0e();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const formStyles = requireFormStylesDeecb9a1();
	const fontLineHeight = requireFontLineHeightD4b9e1a9();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const textSmallStyle = requireTextSmallStyle00e1c6e2();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const throwIfParentIsNotOfKind = requireThrowIfParentIsNotOfKindE0807bbc();
	requireFontSizeTextSmall508930e5();
	requireFontFamily23874d28();
	requireBorderRadiusMedium758b9411();
	requireGetClosestHTMLElement83d01a84();
	requireSetAttributesF96a52a9();
	requireHasNamedSlot273cd3ae();
	requireGetNamedSlot223c478a();
	requireHasDescription050833e0();
	requireIsParentOfKind4b323732();
	requireFontSizeTextXSmallE59d35d7();
	requireSpacingStaticMedium94812711();
	requireTextShared5216bb19();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();

	/**
	 * Generates placeholder styles for an input element.
	 *
	 * @param {JssStyle} styles - The styles to apply to the placeholder.
	 * @returns {JssStyle} - The generated placeholder styles.
	 */
	const getPlaceholderJssStyle = (styles) => ({
	    '&::placeholder': styles,
	    '&::-webkit-input-placeholder': styles /* Chrome/Opera/Safari */,
	    '&::-moz-placeholder': styles /* Firefox 19+ */,
	    '&:-moz-placeholder': styles /* Firefox 18- */,
	});

	const getComponentCss$1 = (isOpen, isDisabled, hideLabel, state, theme) => {
	    const { primaryColor, disabledColor, contrastHighColor, contrastMediumColor, backgroundColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, disabledColor: disabledColorDark, contrastMediumColor: contrastMediumColorDark, contrastHighColor: contrastHighColorDark, backgroundColor: backgroundColorDark, } = validateProps.getThemedColors('dark');
	    const { formStateColor, formStateHoverColor } = stateMessageStyles.getThemedFormStateColors(theme, state);
	    const { formStateColor: formStateColorDark, formStateHoverColor: formStateHoverColorDark } = stateMessageStyles.getThemedFormStateColors('dark', state);
	    return validateProps.getCss({
	        '@global': {
	            // @keyframes fade-in
	            ...popover.getPopoverKeyframesStyles,
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            input: {
	                gridArea: '1/1/1/-1',
	                flex: 1,
	                minWidth: 0,
	                height: `calc(${fontLineHeight.fontLineHeight} + 10px + ${validateProps.borderWidthBase} * 2 + ${spacingStaticSmall.spacingStaticSmall} * 2)`, // we need 10px additionally so input height becomes 54px, // we need 6px additionally so input height becomes 50px
	                font: textSmallStyle.textSmallStyle.font.replace('ex', 'ex + 6px'), // a minimum line-height is needed for input, otherwise value is scrollable in Chrome, +6px is alig
	                margin: 0, // necessary reset for iOS Safari 15 (and maybe other browsers)
	                padding: `${formStyles.formElementPaddingVertical} ${formStyles.formElementPaddingHorizontal}`,
	                paddingInlineEnd: formStyles.getCalculatedFormElementPaddingHorizontal(2),
	                boxSizing: 'border-box',
	                outline: 0,
	                WebkitAppearance: 'none', // iOS safari
	                appearance: 'none',
	                ...textSmallStyle.textSmallStyle,
	                textOverflow: 'ellipsis',
	                '&:disabled': {
	                    cursor: 'not-allowed',
	                },
	                transition: `${validateProps.getTransition('background-color')}, ${validateProps.getTransition('border-color')}, ${validateProps.getTransition('color')}`, // for smooth transitions between e.g. disabled states
	                color: primaryColor,
	                '&:not(:focus)': {
	                    ...getPlaceholderJssStyle({ color: primaryColor, opacity: 1 }),
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, getPlaceholderJssStyle({ color: primaryColorDark, opacity: 1 })),
	                }, // Opacity fixes placeholder being shown lighter in firefox
	                ...hoverMediaQuery.hoverMediaQuery({
	                    '&:hover:not(:disabled):not(:focus),label:hover~.wrapper &:not(:disabled):not(:focus)': {
	                        borderColor: isOpen ? primaryColor : formStateHoverColor || primaryColor,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            borderColor: isOpen ? primaryColorDark : formStateHoverColorDark || primaryColorDark,
	                        }),
	                    },
	                }),
	                ...(!isDisabled && {
	                    '&:focus': {
	                        borderColor: primaryColor,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            borderColor: primaryColorDark,
	                        }),
	                    },
	                }),
	                background: backgroundColor,
	                border: `${validateProps.borderWidthBase} solid ${isOpen ? primaryColor : formStateColor || contrastMediumColor}`,
	                borderRadius: borderRadiusSmall.borderRadiusSmall,
	                ...(isDisabled && {
	                    ...getPlaceholderJssStyle({ color: disabledColor }),
	                    cursor: 'not-allowed',
	                    color: disabledColor,
	                    borderColor: disabledColor,
	                    WebkitTextFillColor: disabledColor,
	                }),
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: primaryColorDark,
	                    background: backgroundColorDark,
	                    border: `${validateProps.borderWidthBase} solid ${isOpen ? primaryColorDark : formStateColorDark || contrastMediumColorDark}`,
	                    ...(isDisabled && {
	                        ...getPlaceholderJssStyle({ color: disabledColorDark }),
	                        color: disabledColorDark,
	                        borderColor: disabledColorDark,
	                        WebkitTextFillColor: disabledColorDark,
	                    }),
	                }),
	            },
	            '[popover]': popover.getPopoverJssStyle(isOpen, 1, 44, theme),
	        },
	        root: {
	            display: 'grid',
	            gap: spacingStaticXSmall.spacingStaticXSmall,
	            // min width is needed for showing at least 1 character in very narrow containers. The "1rem" value is the minimum safe zone to show at least 1 character plus the ellipsis dots.
	            minWidth: `calc(1rem + ${formStyles.formElementPaddingHorizontal} + ${validateProps.borderWidthBase} * 2 + ${formStyles.getCalculatedFormElementPaddingHorizontal(2)})`,
	        },
	        wrapper: {
	            position: 'relative',
	            display: 'grid',
	            gridTemplateColumns: `minmax(0, 1fr) auto auto ${formStyles.formElementLayeredSafeZone}`,
	        },
	        // TODO: extract for multi-select, select-wrapper and text-field (not gridArea and placeSelf)
	        icon: {
	            gridArea: '1/3',
	            placeSelf: 'center',
	            padding: formStyles.formButtonOrIconPadding,
	            pointerEvents: 'none',
	            transform: 'rotate3d(0,0,1,0.0001deg)', // needs to be a little more than 0 for correct direction in safari
	            transition: validateProps.getTransition('transform'),
	            '&--rotate': {
	                transform: 'rotate3d(0,0,1,180deg)',
	            },
	        },
	        // TODO: extract for multi-select, select-wrapper and text-field (not gridArea and placeSelf)
	        button: {
	            gridArea: '1/2',
	            placeSelf: 'center',
	            padding: formStyles.formButtonOrIconPadding,
	        },
	        // TODO: extract (maybe even as functional component) and re-use in multi-select and select-wrapper
	        'no-results': {
	            padding: `${spacingStaticSmall.spacingStaticSmall} 12px`,
	            boxSizing: 'border-box',
	            color: contrastHighColor,
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                color: contrastHighColorDark,
	            }),
	            ...popover.getNoResultsOptionJssStyle(),
	        },
	        // TODO: maybe we should extract it as functional component too
	        'sr-only': validateProps.getHiddenTextJssStyle(),
	        // .label / .required
	        ...labelStyles.getFunctionalComponentLabelStyles(isDisabled, hideLabel, theme),
	        // .message
	        ...stateMessageStyles.getFunctionalComponentStateMessageStyles(theme, state),
	    });
	};

	// TODO: share between select & multi-select
	const syncMultiSelectChildrenProps = (children, theme) => {
	    for (const child of children.filter((child) => child.theme !== theme)) {
	        child.theme = theme;
	        validateProps.forceUpdate(child);
	    }
	};
	const updateOptionsFilterState = (searchString, options, optGroups) => {
	    for (const option of options) {
	        option.hidden = !option.textContent.toLowerCase().includes(searchString.toLowerCase());
	    }
	    for (const optgroup of optGroups) {
	        optgroup.hidden = !Array.from(optgroup.children).some((child) => !child.hidden);
	    }
	};
	const hasFilterOptionResults = (options) => options.some((option) => !option.hidden);
	const resetFilteredOptions = (options, optGroups) => {
	    for (const option of options) {
	        option.hidden = false;
	    }
	    for (const optgroup of optGroups) {
	        optgroup.hidden = false;
	    }
	};
	const getSelectedOptions = (options) => options.filter((option) => option.selected);
	const getSelectedOptionValues = (options) => options.filter((option) => option.selected).map((option) => option.value);
	const getSelectedOptionsString = (options) => getSelectedOptions(options)
	    .map((option) => option.textContent)
	    .join(', ');
	const getUsableOptions = (options) => options.filter((option) => !option.hidden && !option.disabled);
	const getHighlightedOption = (options) => options.find((option) => option.highlighted);
	const setSelectedOptions = (options, value) => {
	    const selectedValues = new Set(value);
	    for (const option of options) {
	        const shouldBeSelected = selectedValues.has(option.value);
	        if ((option.selected ?? false) !== shouldBeSelected) {
	            option.selected = shouldBeSelected;
	            validateProps.forceUpdate(option);
	        }
	    }
	    const valuesNotIncluded = value.filter((val) => !options.some((option) => option.value === val));
	    if (valuesNotIncluded.length > 0) {
	        validateProps.consoleWarn('The following values are not included in the options of the p-multi-select:', valuesNotIncluded.join(', '));
	    }
	};
	const setHighlightedOption = (option, highlighted) => {
	    option.highlighted = highlighted;
	    validateProps.forceUpdate(option);
	};
	const getHighlightedOptionIndex = (options) => options.indexOf(getHighlightedOption(options));
	const setNextOptionHighlighted = (host, options, newIndex) => {
	    const oldIndex = getHighlightedOptionIndex(options);
	    if (oldIndex !== -1) {
	        setHighlightedOption(options[oldIndex], false);
	    }
	    setHighlightedOption(options[newIndex], true);
	    handleDropdownScroll(host, options[newIndex]);
	};
	const setFirstOptionHighlighted = (host, options) => {
	    const validOptions = getUsableOptions(options);
	    setNextOptionHighlighted(host, options, options.indexOf(validOptions[0]));
	};
	const setLastOptionHighlighted = (host, options) => {
	    const validOptions = getUsableOptions(options);
	    setNextOptionHighlighted(host, options, options.indexOf(validOptions.at(-1)));
	};
	const resetHighlightedOptions = (options) => {
	    for (const option of options) {
	        setHighlightedOption(option, false);
	    }
	};
	const resetSelectedOptions = (options) => {
	    for (const option of options) {
	        if (option.selected) {
	            option.selected = false;
	            validateProps.forceUpdate(option);
	        }
	    }
	};
	const getNewOptionIndex = (options, direction) => {
	    const validItems = getUsableOptions(options);
	    const validMax = validItems.length - 1;
	    if (validMax < 0) {
	        return undefined;
	    }
	    const oldIndex = getHighlightedOptionIndex(validItems);
	    let newIndex = oldIndex;
	    if (direction === 'down') {
	        newIndex = oldIndex < validMax ? oldIndex + 1 : 0;
	    }
	    else if (direction === 'up') {
	        newIndex = oldIndex > 0 ? oldIndex - 1 : validMax;
	    }
	    return options.indexOf(validItems[newIndex]);
	};
	const updateHighlightedOption = (host, options, direction) => {
	    const newIndex = getNewOptionIndex(options, direction);
	    if (newIndex !== undefined) {
	        setNextOptionHighlighted(host, options, newIndex);
	    }
	};
	/**
	 * Handles scrolling within the list to ensure that the highlighted item is always visible.
	 * @param {HTMLElement} scrollElement - The HTML element to be scrolled.
	 * @param {HTMLElement} element - The element to scroll to.
	 * @returns {void}
	 */
	const handleDropdownScroll = (scrollElement, element) => {
	    const { maxHeight } = getComputedStyle(scrollElement);
	    const hostElementHeight = Number.parseInt(maxHeight, 10);
	    if (scrollElement.scrollHeight > hostElementHeight) {
	        element.scrollIntoView({
	            block: 'nearest',
	        });
	    }
	};

	const propTypes$1 = {
	    label: validateProps.AllowedTypes.string,
	    description: validateProps.AllowedTypes.string,
	    name: validateProps.AllowedTypes.string,
	    value: validateProps.AllowedTypes.array(validateProps.AllowedTypes.string),
	    state: validateProps.AllowedTypes.oneOf(stateMessageStyles.FORM_STATES),
	    message: validateProps.AllowedTypes.string,
	    hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	    disabled: validateProps.AllowedTypes.boolean,
	    required: validateProps.AllowedTypes.boolean,
	    form: validateProps.AllowedTypes.string,
	    dropdownDirection: validateProps.AllowedTypes.oneOf(selectDropdown.SELECT_DROPDOWN_DIRECTIONS),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const MultiSelect = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.update = validateProps.createEvent(this, "update", 3);
	        if (hostRef.$hostElement$["s-ei"]) {
	            this.internals = hostRef.$hostElement$["s-ei"];
	        }
	        else {
	            this.internals = hostRef.$hostElement$.attachInternals?.();
	            hostRef.$hostElement$["s-ei"] = this.internals;
	        }
	        this.multiSelectOptions = [];
	        this.multiSelectOptgroups = [];
	        this.preventOptionUpdate = false; // Used to prevent value watcher from updating options when options are already updated
	        this.hasNativePopoverSupport = validateProps.getHasNativePopoverSupport();
	        this.onSlotchange = () => {
	            this.updateOptions();
	            setSelectedOptions(this.multiSelectOptions, this.value);
	            // Necessary to update selected options in placeholder
	            validateProps.forceUpdate(this.host);
	        };
	        this.updateOptions = () => {
	            this.multiSelectOptions = [];
	            this.multiSelectOptgroups = [];
	            for (const child of Array.from(this.host.children).filter((el) => el.tagName !== 'SELECT' && el.slot !== 'label' && el.slot !== 'description' && el.slot !== 'message')) {
	                throwIfElementIsNotOfKind.throwIfElementIsNotOfKind(this.host, child, ['p-multi-select-option', 'p-optgroup']);
	                if (isElementOfKind.isElementOfKind(child, 'p-multi-select-option')) {
	                    this.multiSelectOptions.push(child);
	                }
	                else if (isElementOfKind.isElementOfKind(child, 'p-optgroup')) {
	                    this.multiSelectOptgroups.push(child);
	                    for (const optGroupChild of Array.from(child.children)) {
	                        throwIfElementIsNotOfKind.throwIfElementIsNotOfKind(child, optGroupChild, 'p-multi-select-option');
	                        this.multiSelectOptions.push(optGroupChild);
	                    }
	                }
	            }
	        };
	        this.onClickOutside = (e) => {
	            if (this.isOpen &&
	                isClickOutside.isClickOutside(e, this.inputElement) &&
	                isClickOutside.isClickOutside(e, this.resetButtonElement) &&
	                isClickOutside.isClickOutside(e, this.popoverElement)) {
	                this.isOpen = false;
	                this.resetFilter();
	            }
	        };
	        this.onInputChange = (e) => {
	            if (e.target.value.startsWith(' ')) {
	                this.resetFilter();
	            }
	            else {
	                updateOptionsFilterState(e.target.value, this.multiSelectOptions, this.multiSelectOptgroups);
	                this.hasFilterResults = hasFilterOptionResults(this.multiSelectOptions);
	            }
	            // in case input is focused via tab instead of click
	            this.isOpen = true;
	        };
	        this.onInputClick = () => {
	            this.isOpen = true;
	        };
	        this.onResetClick = () => {
	            resetSelectedOptions(this.multiSelectOptions);
	            this.value = this.currentValue;
	            this.inputElement.focus();
	            this.emitUpdateEvent();
	            validateProps.forceUpdate(this.host);
	        };
	        this.resetFilter = () => {
	            this.inputElement.value = '';
	            resetFilteredOptions(this.multiSelectOptions, this.multiSelectOptgroups);
	        };
	        this.onInputKeyDown = (e) => {
	            switch (e.key) {
	                case 'ArrowUp':
	                case 'Up': {
	                    e.preventDefault();
	                    this.cycleDropdown('up');
	                    break;
	                }
	                case 'ArrowDown':
	                case 'Down': {
	                    e.preventDefault();
	                    this.cycleDropdown('down');
	                    break;
	                }
	                case 'Enter': {
	                    const highlightedOption = getHighlightedOption(this.multiSelectOptions);
	                    if (highlightedOption) {
	                        highlightedOption.selected = !highlightedOption.selected;
	                        this.value = this.currentValue;
	                        this.emitUpdateEvent();
	                        validateProps.forceUpdate(highlightedOption);
	                    }
	                    else if (this.internals?.form) {
	                        buttonHandling.handleButtonEvent(e, this.host, () => 'submit', () => this.disabled);
	                    }
	                    break;
	                }
	                case 'Escape': {
	                    this.isOpen = false;
	                    resetHighlightedOptions(this.multiSelectOptions);
	                    break;
	                }
	                case 'Tab': {
	                    // If there is a value the reset button will be focused and the dropdown stays open
	                    if (this.currentValue.length === 0) {
	                        this.isOpen = false;
	                    }
	                    resetHighlightedOptions(this.multiSelectOptions);
	                    break;
	                }
	                case 'PageUp':
	                    if (this.isOpen) {
	                        e.preventDefault();
	                        setFirstOptionHighlighted(this.popoverElement, this.multiSelectOptions);
	                    }
	                    break;
	                case 'PageDown':
	                    if (this.isOpen) {
	                        e.preventDefault();
	                        setLastOptionHighlighted(this.popoverElement, this.multiSelectOptions);
	                    }
	                    break;
	                // TODO: seems to be difficult to combine multiple keys as native select does
	            }
	        };
	        this.updateSrHighlightedOptionText = () => {
	            const highlightedOptionIndex = getHighlightedOptionIndex(this.multiSelectOptions);
	            // TODO: Does this consider hidden/disabled options?
	            const highlightedOption = this.multiSelectOptions[highlightedOptionIndex];
	            this.srHighlightedOptionText =
	                highlightedOption &&
	                    `${highlightedOption.textContent}${highlightedOption.selected ? ', selected' : ' not selected'} (${highlightedOptionIndex + 1} of ${this.multiSelectOptions.length})`;
	        };
	        this.emitUpdateEvent = () => {
	            this.update.emit({
	                value: this.currentValue,
	                name: this.name,
	            });
	        };
	        this.label = '';
	        this.description = '';
	        this.name = undefined;
	        this.value = [];
	        this.state = 'none';
	        this.message = '';
	        this.hideLabel = false;
	        this.disabled = false;
	        this.required = false;
	        this.dropdownDirection = 'auto';
	        this.theme = 'light';
	        this.form = undefined;
	        this.isOpen = false;
	        this.srHighlightedOptionText = '';
	        this.hasFilterResults = true;
	    }
	    get currentValue() {
	        return getSelectedOptionValues(this.multiSelectOptions);
	    }
	    updateOptionHandler(e) {
	        e.target.selected = !e.target.selected;
	        validateProps.forceUpdate(e.target);
	        this.preventOptionUpdate = true; // Avoid unnecessary looping over options in setSelectedOptions in value watcher
	        this.value = this.currentValue;
	        e.stopPropagation();
	        this.emitUpdateEvent();
	    }
	    onValueChange() {
	        this.setFormValue(this.value);
	        // When setting initial value the watcher gets called before the options are defined
	        if (this.multiSelectOptions.length > 0) {
	            if (!this.preventOptionUpdate) {
	                setSelectedOptions(this.multiSelectOptions, this.value);
	            }
	            this.preventOptionUpdate = false;
	        }
	    }
	    onIsOpenChange() {
	        if (this.isOpen) {
	            if (this.hasNativePopoverSupport) {
	                this.popoverElement.showPopover();
	            }
	            if (typeof this.cleanUpAutoUpdate === 'undefined') {
	                // ensures floating ui event listeners are added when options list is opened
	                this.cleanUpAutoUpdate = isClickOutside.autoUpdate(this.inputElement, this.popoverElement, async () => {
	                    await popover.optionListUpdatePosition(this.dropdownDirection, this.inputElement, this.popoverElement);
	                });
	            }
	        }
	        else {
	            if (this.hasNativePopoverSupport) {
	                this.popoverElement.hidePopover();
	            }
	            if (typeof this.cleanUpAutoUpdate === 'function') {
	                // ensures floating ui event listeners are removed when options list is closed
	                this.cleanUpAutoUpdate();
	                this.cleanUpAutoUpdate = undefined;
	            }
	        }
	    }
	    setFormValue(value) {
	        const formData = new FormData();
	        for (const val of value) {
	            formData.append(this.name, val);
	        }
	        this.internals?.setFormValue(formData);
	    }
	    connectedCallback() {
	        validateProps.applyConstructableStylesheetStyles(this.host, slottedAnchorStyles.getSlottedAnchorStyles);
	        document.addEventListener('mousedown', this.onClickOutside, true);
	    }
	    disconnectedCallback() {
	        document.removeEventListener('mousedown', this.onClickOutside, true);
	        if (typeof this.cleanUpAutoUpdate === 'function') {
	            // ensures floating ui event listeners are removed in case popover is removed from DOM
	            this.cleanUpAutoUpdate();
	        }
	    }
	    componentWillLoad() {
	        this.defaultValue = this.value;
	        this.setFormValue(this.value);
	        this.updateOptions();
	        // Use initial value to set options
	        setSelectedOptions(this.multiSelectOptions, this.value);
	    }
	    componentDidLoad() {
	        validateProps.getShadowRootHTMLElement(this.host, 'slot').addEventListener('slotchange', this.onSlotchange);
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    formDisabledCallback(disabled) {
	        this.disabled = disabled;
	    }
	    formStateRestoreCallback(state) {
	        this.value = state.getAll(this.name);
	    }
	    formResetCallback() {
	        this.setFormValue(this.defaultValue);
	        this.value = this.defaultValue;
	    }
	    render() {
	        validateProps.validateProps(this, propTypes$1);
	        validateProps.attachComponentCss(this.host, getComponentCss$1, this.isOpen, this.disabled, this.hideLabel, this.state, this.theme);
	        syncMultiSelectChildrenProps([...this.multiSelectOptions, ...this.multiSelectOptgroups], this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        const inputId = 'filter';
	        const popoverId = 'list';
	        const optionsSelectedId = 'options-selected';
	        return (validateProps.h("div", { key: '2cafbdb7e1454d2ae2685341d53875db125fbe9d', class: "root" }, validateProps.h(labelStyles.Label, { key: 'd2964ae905fc1b137856324c896f7139f3545528', host: this.host, label: this.label, description: this.description, htmlFor: inputId, isRequired: this.required, isDisabled: this.disabled }), this.currentValue.length > 0 && (validateProps.h("span", { key: 'd9a0254d4f23e564949420d9d75d261151602fea', id: optionsSelectedId, class: "sr-only" }, getSelectedOptions(this.multiSelectOptions).length, " options selected")), validateProps.h("div", { key: 'aa1e1bd751fd1d7e1381038a5404dbb8768f41fe', class: { wrapper: true, disabled: this.disabled } }, validateProps.h("input", { key: 'c090a08b9b7b2daa986c8ddaea4ceb8d88391bfd', id: inputId, role: "combobox", placeholder: getSelectedOptionsString(this.multiSelectOptions) || null, autoComplete: "off", disabled: this.disabled, required: this.required, onInput: this.onInputChange, onClick: this.onInputClick, onKeyDown: this.onInputKeyDown, ref: (el) => (this.inputElement = el), "aria-invalid": this.state === 'error' ? 'true' : null, ...popover.getFilterInputAriaAttributes(this.isOpen, this.required, labelStyles.labelId, `${labelStyles.descriptionId} ${optionsSelectedId} ${stateMessageStyles.messageId}`, popoverId) }), validateProps.h(PrefixedTagNames.pIcon, { key: 'd880d4657df94f993bb3639de15b32568cb1d29e', class: { icon: true, 'icon--rotate': this.isOpen }, name: "arrow-head-down", theme: this.theme, color: this.disabled ? 'state-disabled' : 'primary', "aria-hidden": "true" }), this.currentValue.length > 0 && (validateProps.h(PrefixedTagNames.pButtonPure, { key: '51013763838ea87fb533d4ef1b64f5d895d3ee81', type: "button", class: "button", icon: "close", hideLabel: true, theme: this.theme, onClick: this.onResetClick, onKeyDown: (e) => e.key === 'Tab' && (this.isOpen = false), disabled: this.disabled, ref: (el) => (this.resetButtonElement = el) }, "Reset selection")), validateProps.h("div", { key: '766d5d20101fd14a12ba87ec363c1d60c3efcf1b', id: popoverId, popover: "manual", tabIndex: -1, ...popover.getListAriaAttributes(this.label, this.required, true, this.isOpen, true), ref: (el) => (this.popoverElement = el) }, !this.hasFilterResults && (validateProps.h("div", { key: 'ffed622e70f44f3f81d19e3b683cf682a4b6c23f', class: "no-results", role: "option" }, validateProps.h("span", { key: '464ae35cadb03d66677dc895be200d4168b272b7', "aria-hidden": "true" }, "---"), validateProps.h("span", { key: '8263e816743d2a198ae1a868c71a3e7d8fb8e974', class: "sr-only" }, "No results found"))), validateProps.h("slot", { key: '547d80eb99f933eec2dc3bca2be0750330a08806' }))), validateProps.h(stateMessageStyles.StateMessage, { key: 'e1aacdeb5ef6037b7172e0e873f5f59227061318', state: this.state, message: this.message, theme: this.theme, host: this.host }), validateProps.h("span", { key: '0a8e914b10411f7db97e6d38d4caf53c2a2145a9', class: "sr-only", role: "status", "aria-live": "assertive", "aria-relevant": "additions text" }, this.hasFilterResults ? this.srHighlightedOptionText : 'No results found')));
	    }
	    cycleDropdown(direction) {
	        this.isOpen = true;
	        updateHighlightedOption(this.popoverElement, this.multiSelectOptions, direction);
	        this.updateSrHighlightedOptionText();
	    }
	    static get delegatesFocus() { return true; }
	    static get formAssociated() { return true; }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "value": ["onValueChange"],
	        "isOpen": ["onIsOpenChange"]
	    }; }
	};

	const getComponentCss = (theme) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    scrollMargin: '6px', // Aligns option when list is scrolled by navigating with keyboard
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	        },
	        option: popover.getOptionJssStyle('multi-select-option', 1, theme),
	        checkbox: {
	            pointerEvents: 'none', // Avoid checkbox label click which updates input within p-checkbox-wrapper
	        },
	    });
	};

	const propTypes = {
	    value: validateProps.AllowedTypes.string,
	    disabled: validateProps.AllowedTypes.boolean,
	};
	const MultiSelectOption = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.onClick = () => {
	            this.host.dispatchEvent(new CustomEvent('internalOptionUpdate', {
	                bubbles: true,
	            }));
	        };
	        this.value = undefined;
	        this.disabled = false;
	    }
	    connectedCallback() {
	        throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, ['p-multi-select', 'p-optgroup']);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        const { theme = 'light', selected, highlighted } = this.host;
	        validateProps.attachComponentCss(this.host, getComponentCss, theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        const isDisabled = this.disabled || this.host.disabledParent;
	        return (validateProps.h(validateProps.Host, { key: 'cbb6ca3683da60920e542173ae66571ee138d98a', onClick: !isDisabled && this.onClick }, validateProps.h("div", { key: '1e2139e544697128871127af3a6de46568b6e229', role: "option", "aria-labelledby": "checkbox", ...popover.getOptionAriaAttributes(selected, isDisabled, false, !!this.value), class: {
	                option: true,
	                'option--selected': selected,
	                'option--highlighted': highlighted,
	                'option--disabled': isDisabled,
	            } }, validateProps.h(PrefixedTagNames.pCheckbox, { key: 'd32490086065dfa3e344288688a08a071fb78165', id: "checkbox", class: "checkbox", theme: theme, checked: selected, disabled: isDisabled, "aria-hidden": "true" }, validateProps.h("slot", { key: '2acd4c97182eb09c87231bcb8a46d83987b17a6d', slot: "label" })))));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pMultiSelect_2_cjs_entry.p_multi_select = MultiSelect;
	pMultiSelect_2_cjs_entry.p_multi_select_option = MultiSelectOption;

	
	return pMultiSelect_2_cjs_entry;
}

var pOptgroup_cjs_entry = {};

var hasRequiredPOptgroup_cjs_entry;

function requirePOptgroup_cjs_entry () {
	if (hasRequiredPOptgroup_cjs_entry) return pOptgroup_cjs_entry;
	hasRequiredPOptgroup_cjs_entry = 1;

	Object.defineProperty(pOptgroup_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const throwIfParentIsNotOfKind = requireThrowIfParentIsNotOfKindE0807bbc();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const textXSmallStyle = requireTextXSmallStyle30d03035();
	const fontWeightSemiBold = requireFontWeightSemiBold4482c830();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	requireIsParentOfKind4b323732();
	requireTextShared5216bb19();
	requireFontFamily23874d28();
	requireFontLineHeightD4b9e1a9();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextXSmallE59d35d7();

	const updateOptionsDisabled = (host, disabled) => {
	    for (const child of Array.from(host.children)) {
	        child.disabledParent = disabled;
	        validateProps.forceUpdate(child);
	    }
	};

	const cssVarInternalOptgroupScaling = '--p-internal-optgroup-scaling';
	const scalingVar = `var(${cssVarInternalOptgroupScaling}, 1)`;
	const getComponentCss = (isDisabled, theme) => {
	    const { primaryColor, disabledColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, disabledColor: disabledColorDark } = validateProps.getThemedColors('dark');
	    const padding = `max(2px, ${scalingVar} * ${spacingStaticSmall.spacingStaticSmall}) max(4px, ${scalingVar} * 12px)`;
	    const gap = `max(2px, ${scalingVar} * ${spacingStaticSmall.spacingStaticSmall})`;
	    return validateProps.getCss({
	        '@global': {
	            ':host': validateProps.addImportantToEachRule({
	                ...colorSchemeStyles.colorSchemeStyles,
	                ...colorSchemeStyles.hostHiddenStyles,
	            }),
	            '::slotted(*)': {
	                '--p-internal-select-option-padding-left': '28px',
	                '--p-internal-multi-select-option-padding-left': '28px',
	            },
	            '[role="group"]': {
	                display: 'flex',
	                flexDirection: 'column',
	                gap,
	            },
	            '[role="presentation"]': {
	                padding,
	                font: textXSmallStyle.textXSmallStyle.font.replace(' 400 ', ` ${fontWeightSemiBold.fontWeightSemiBold} `),
	                color: primaryColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: primaryColorDark,
	                }),
	                ...(isDisabled && {
	                    color: disabledColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        color: disabledColorDark,
	                    }),
	                }),
	            },
	        },
	    });
	};

	const propTypes = {
	    label: validateProps.AllowedTypes.string,
	    disabled: validateProps.AllowedTypes.boolean,
	};
	const Optgroup = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.label = undefined;
	        this.disabled = false;
	    }
	    handleDisabledChange() {
	        updateOptionsDisabled(this.host, this.disabled);
	    }
	    connectedCallback() {
	        throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, ['p-select', 'p-multi-select']);
	    }
	    componentWillLoad() {
	        updateOptionsDisabled(this.host, this.disabled);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        const { theme = 'light', hidden } = this.host;
	        validateProps.attachComponentCss(this.host, getComponentCss, this.disabled, theme);
	        const labelId = 'label';
	        return (validateProps.h(validateProps.Host, { key: '119c3bc66ac578a222957978296aff0ea5d4786f' }, validateProps.h("div", { key: '1588cb4aeecd21cf5e2e556092d8df1e6859342c', role: "group", "aria-disabled": this.disabled ? 'true' : null, "aria-hidden": hidden ? 'true' : null, "aria-labelledby": labelId }, validateProps.h("span", { key: 'c6caad24bf850de69c5e94cf3ec65280b6bd9b4a', id: labelId, role: "presentation" }, this.label), validateProps.h("slot", { key: '7099242cba59d9694361fed18fead3474e87a292' }))));
	    }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "disabled": ["handleDisabledChange"]
	    }; }
	};

	pOptgroup_cjs_entry.p_optgroup = Optgroup;

	
	return pOptgroup_cjs_entry;
}

var pPagination_cjs_entry = {};

var hasRequiredPPagination_cjs_entry;

function requirePPagination_cjs_entry () {
	if (hasRequiredPPagination_cjs_entry) return pPagination_cjs_entry;
	hasRequiredPPagination_cjs_entry = 1;

	Object.defineProperty(pPagination_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed76f87eda();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const getMediaQueryMax = requireGetMediaQueryMax5b73ea17();
	const fontLineHeight = requireFontLineHeightD4b9e1a9();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const textSmallStyle = requireTextSmallStyle00e1c6e2();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const frostedGlassStyle = requireFrostedGlassStyleBd067e45();
	requireHelper22e15c0e();
	requireTextShared5216bb19();
	requireFontFamily23874d28();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();

	const mediaQueryMinS = validateProps.getMediaQueryMin('s');
	const mediaQueryMaxS = getMediaQueryMax.getMediaQueryMax('s');
	// button size needs to be fluid between 320px and 360px viewport width, so that the pagination fits into 320px viewport
	// and text scale 200% works (almost) on mobile viewports too
	const buttonSize = `clamp(36px, calc(${fontLineHeight.fontLineHeight} + 10vw - 20px), 40px)`;
	const disabledCursorStyle = {
	    cursor: 'default',
	    pointerEvents: 'none', // prevents :hover (has no effect when forced), maybe we can remove it since CSS selectors already cover desired behavior
	};
	const hiddenStyle = { display: 'none' };
	const getComponentCss = (activePage, pageTotal, showLastPage, theme) => {
	    const { primaryColor, disabledColor, hoverColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, disabledColor: disabledColorDark, hoverColor: hoverColorDark, } = validateProps.getThemedColors('dark');
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            nav: {
	                display: 'flex',
	                justifyContent: 'center',
	                userSelect: 'none',
	            },
	            ul: {
	                display: 'flex',
	                gap: spacingStaticXSmall.spacingStaticXSmall,
	                margin: 0,
	                padding: 0,
	                [mediaQueryMinS]: {
	                    gap: spacingStaticSmall.spacingStaticSmall,
	                },
	            },
	            li: {
	                listStyleType: 'none',
	                ...(pageTotal > 5 && {
	                    // max 5 items including ellipsis at the same time on mobile
	                    [mediaQueryMaxS]: {
	                        [activePage < 4
	                            ? // we are at the start, so let's hide start ellipsis and 2 items before end ellipsis
	                                '&.ellip-start,&:nth-child(6),&:nth-child(7),&:not(.ellip):nth-child(8)'
	                            : pageTotal - activePage < 3
	                                ? // we are at the end, so let's hide end ellipsis and 2 items after start ellipsis
	                                    '&.ellip-end, &.ellip-start + &:not(.current), &.ellip-start + &:not(.current) + &:not(.current)'
	                                : // we are at in the middle, so let's hide elements after start and before end ellipsis
	                                    '&.ellip-start + &:not(.current), &.current-1, &.current\\+1, &.current\\+1 + &:not(.ellip)']: hiddenStyle,
	                        // without last page we need to adjust end page handling
	                        ...(!showLastPage &&
	                            (pageTotal - activePage < 2
	                                ? { [`&.current-2${pageTotal - activePage === 1 ? ',&.current-1' : ''}`]: hiddenStyle }
	                                : activePage > 2 && {
	                                    '&.current\\+1,&.current\\+2': hiddenStyle,
	                                    '&.ellip-end': { display: 'initial' },
	                                })),
	                    },
	                }),
	                [mediaQueryMinS]: {
	                    // prev
	                    '&:first-child': { marginInlineEnd: spacingStaticSmall.spacingStaticSmall },
	                    // next
	                    '&:last-child': { marginInlineStart: spacingStaticSmall.spacingStaticSmall },
	                    ...(pageTotal < 8
	                        ? { '&.ellip': hiddenStyle }
	                        : // max 7 items including ellipsis at the same time on tablet
	                            {
	                                // we are at the start, so let's hide start ellipsis
	                                ...(activePage <= 4 && { '&.ellip-start': hiddenStyle }),
	                                // we are at the end, so let's hide end ellipsis
	                                ...(pageTotal - activePage < 4 && { '&.ellip-end:nth-last-child(3)': hiddenStyle }),
	                                // we are at the end without last page, so let's hide end ellipsis
	                                ...(pageTotal - activePage < 3 && { '&.ellip-end:nth-last-child(2)': hiddenStyle }),
	                            }),
	                },
	            },
	            span: {
	                display: 'flex',
	                justifyContent: 'center',
	                alignItems: 'center',
	                transition: `${validateProps.getTransition('background-color')}, ${validateProps.getTransition('border-color')}, ${validateProps.getTransition('color')}`, // for smooth transition between states
	                position: 'relative',
	                width: buttonSize,
	                height: buttonSize,
	                boxSizing: 'border-box',
	                ...textSmallStyle.textSmallStyle,
	                whiteSpace: 'nowrap',
	                cursor: 'pointer',
	                color: primaryColor,
	                borderRadius: borderRadiusSmall.borderRadiusSmall,
	                borderColor: 'transparent', // default value is needed for smooth transition
	                outline: 0, // TODO: only relevant for VRT testing with forced states - prevents :focus style
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: primaryColorDark,
	                }),
	                ...hoverMediaQuery.hoverMediaQuery({
	                    '&:not([aria-disabled]):not(.ellipsis):hover': {
	                        ...frostedGlassStyle.frostedGlassStyle,
	                        background: hoverColor,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            background: hoverColorDark,
	                        }),
	                    },
	                }),
	                '&[aria-current]': {
	                    ...disabledCursorStyle,
	                    color: primaryColor,
	                    border: `${validateProps.borderWidthBase} solid ${primaryColor}`,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        color: primaryColorDark,
	                        borderColor: primaryColorDark,
	                    }),
	                },
	                '&[aria-disabled]': {
	                    ...disabledCursorStyle,
	                    color: disabledColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        color: disabledColorDark,
	                    }),
	                },
	                // TODO :not(.ellipsis) is only needed for VRT states tests to work properly
	                '&:not(.ellipsis)': validateProps.getFocusJssStyle(theme),
	            },
	        },
	        ellipsis: {
	            ...disabledCursorStyle,
	            '&::after': {
	                content: '""',
	            },
	        },
	    });
	};

	/**
	 * Universal pagination model generation algorithm
	 *
	 * The idea behind this module is to move the logic of creating pagination out of the component
	 * and place it in a separate module.
	 *
	 * Adapted from ultimate-pagination
	 * https://github.com/ultimate-pagination/ultimate-pagination
	 */
	var ItemType;
	(function (ItemType) {
	    ItemType[ItemType["PAGE"] = 0] = "PAGE";
	    ItemType[ItemType["ELLIPSIS"] = 1] = "ELLIPSIS";
	    ItemType[ItemType["PREVIOUS"] = 2] = "PREVIOUS";
	    ItemType[ItemType["NEXT"] = 3] = "NEXT";
	})(ItemType || (ItemType = {}));
	const ellipsisItem = {
	    type: ItemType.ELLIPSIS,
	    isActive: false,
	};
	const createPreviousPageLink = (options) => {
	    const { activePage } = options;
	    return {
	        type: ItemType.PREVIOUS,
	        value: Math.max(1, activePage - 1),
	        isActive: activePage > 1,
	    };
	};
	const createNextPageLink = (options) => {
	    const { activePage, pageTotal } = options;
	    return {
	        type: ItemType.NEXT,
	        value: Math.min(pageTotal, activePage + 1),
	        isActive: activePage < pageTotal,
	    };
	};
	const createPageFunctionFactory = ({ activePage }) => {
	    return (pageNumber) => ({
	        type: ItemType.PAGE,
	        value: pageNumber,
	        isActive: pageNumber === activePage,
	        isBeforeCurrent: pageNumber === activePage - 1,
	        isBeforeBeforeCurrent: pageNumber === activePage - 2,
	        isAfterCurrent: pageNumber === activePage + 1,
	        isAfterAfterCurrent: pageNumber === activePage + 2,
	    });
	};
	const createRange = (start, end) => Array.from(new Array(end - start + 1), (_, i) => i + start);
	const createPaginationItems = (options) => {
	    const { pageTotal, activePage, showLastPage } = options;
	    const pageRange = 1;
	    const boundaryPagesRange = 1;
	    const ellipsisSize = 1;
	    const paginationItems = [createPreviousPageLink(options)];
	    const createPage = createPageFunctionFactory(options);
	    // Simplify generation of pages if number of available items is equal or greater than total pages to show
	    if (1 + 2 * ellipsisSize + 2 * boundaryPagesRange >= pageTotal) {
	        const allPages = createRange(1, pageTotal).map(createPage);
	        paginationItems.push(...allPages);
	    }
	    else {
	        // Add first page
	        paginationItems.push(createPage(1));
	        // Calculate group of middle pages
	        const middlePagesStart = Math.min(Math.max(activePage - pageRange, 2 + ellipsisSize), pageTotal - ellipsisSize - 2 - (showLastPage ? 1 : 0));
	        const middlePagesEnd = middlePagesStart + 2;
	        const middlePages = createRange(middlePagesStart, middlePagesEnd).map(createPage);
	        // Calculate and add ellipsis before group of middle pages
	        const firstEllipsisPageNumber = middlePagesStart - 1;
	        const showPageInsteadOfFirstEllipsis = firstEllipsisPageNumber === 2;
	        const firstEllipsisOrPage = showPageInsteadOfFirstEllipsis ? createPage(firstEllipsisPageNumber) : ellipsisItem;
	        if (showPageInsteadOfFirstEllipsis && pageTotal > 5) {
	            paginationItems.push(ellipsisItem);
	        }
	        paginationItems.push(firstEllipsisOrPage);
	        // Add group of middle pages
	        paginationItems.push(...middlePages);
	        // Calculate and add ellipsis after group of middle pages
	        const lastEllipsisPageNumber = middlePagesEnd + 1;
	        const showPageInsteadOfLastEllipsis = lastEllipsisPageNumber === pageTotal - (showLastPage ? 1 : 0);
	        const lastEllipsisOrPage = showPageInsteadOfLastEllipsis ? createPage(lastEllipsisPageNumber) : ellipsisItem;
	        paginationItems.push(lastEllipsisOrPage);
	        if (showPageInsteadOfLastEllipsis && pageTotal > 5) {
	            paginationItems.push(ellipsisItem);
	        }
	        // Add last page
	        if (showLastPage) {
	            paginationItems.push(createPage(pageTotal));
	        }
	    }
	    paginationItems.push(createNextPageLink(options));
	    return paginationItems;
	};
	const getCurrentActivePage = (activePage, totalPages) => {
	    return activePage < 1 ? 1 : activePage > totalPages ? totalPages : activePage;
	};
	const getTotalPages = (totalItemsCount, itemsPerPage) => {
	    return Math.ceil((totalItemsCount < 1 ? 1 : totalItemsCount) / (itemsPerPage < 1 ? 1 : itemsPerPage));
	};

	const propTypes = {
	    totalItemsCount: validateProps.AllowedTypes.number,
	    itemsPerPage: validateProps.AllowedTypes.number,
	    activePage: validateProps.AllowedTypes.number,
	    showLastPage: validateProps.AllowedTypes.boolean,
	    allyLabel: validateProps.AllowedTypes.string,
	    allyLabelPrev: validateProps.AllowedTypes.string,
	    allyLabelPage: validateProps.AllowedTypes.string,
	    allyLabelNext: validateProps.AllowedTypes.string,
	    intl: validateProps.AllowedTypes.shape({
	        root: validateProps.AllowedTypes.string,
	        prev: validateProps.AllowedTypes.string,
	        next: validateProps.AllowedTypes.string,
	        page: validateProps.AllowedTypes.string,
	    }),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Pagination = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.pageChange = validateProps.createEvent(this, "pageChange", 3);
	        this.update = validateProps.createEvent(this, "update", 3);
	        this.totalItemsCount = 1;
	        this.itemsPerPage = 1;
	        this.activePage = 1;
	        this.maxNumberOfPageLinks = undefined;
	        this.showLastPage = true;
	        this.allyLabel = undefined;
	        this.allyLabelPrev = undefined;
	        this.allyLabelPage = undefined;
	        this.allyLabelNext = undefined;
	        this.intl = {
	            root: 'Pagination',
	            prev: 'Previous page',
	            next: 'Next page',
	            page: 'Page',
	        };
	        this.theme = 'light';
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    disconnectedCallback() {
	        validateProps.unobserveBreakpointChange(this.host);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'maxNumberOfPageLinks');
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'allyLabel', 'Please use intl prop with intl.root instead.');
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'allyLabelNext', 'Please use intl prop with intl.next instead.');
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'allyLabelPrev', 'Please use intl prop with intl.prev instead.');
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'allyLabelPage', 'Please use intl prop with intl.page instead.');
	        const pageTotal = getTotalPages(this.totalItemsCount, this.itemsPerPage);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.activePage, pageTotal, this.showLastPage, this.theme);
	        const paginationItems = createPaginationItems({
	            activePage: getCurrentActivePage(this.activePage, pageTotal),
	            pageTotal,
	            showLastPage: this.showLastPage,
	        });
	        const parsedIntl = validateProps.parseJSONAttribute(this.intl);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h("nav", { key: 'a2c508f6e19ccec8340c7167cbbbe26add311abb', "aria-label": this.allyLabel || parsedIntl.root }, validateProps.h("ul", { key: '552d809586cdcbf043c2a77cc9f520d5e7ac031b' }, paginationItems.map((pageModel, index) => {
	            const { type, isActive, value, isBeforeCurrent, isAfterCurrent, isBeforeBeforeCurrent, isAfterAfterCurrent, } = pageModel;
	            const spanProps = {
	                role: 'button',
	                tabIndex: isActive ? 0 : null,
	                onClick: () => this.onClick(value),
	                onKeyDown: (e) => this.onKeyDown(e, value),
	            };
	            const iconProps = {
	                theme: this.theme,
	                color: isActive ? 'primary' : 'state-disabled',
	                'aria-hidden': 'true',
	            };
	            switch (type) {
	                case ItemType.PREVIOUS:
	                    return (validateProps.h("li", { key: "prev", class: "prev" }, validateProps.h("span", { ...spanProps, "aria-label": this.allyLabelPrev || parsedIntl.prev, "aria-disabled": isActive ? null : 'true' }, validateProps.h(PrefixedTagNames.pIcon, { ...iconProps, name: "arrow-left" }))));
	                case ItemType.ELLIPSIS:
	                    return (validateProps.h("li", { key: "ellip", class: { ellip: true, [`ellip-${index === 2 ? 'start' : 'end'}`]: true } }, validateProps.h("span", { class: "ellipsis" })));
	                case ItemType.PAGE:
	                    return (validateProps.h("li", { key: value, class: {
	                            current: isActive,
	                            'current-1': isBeforeCurrent,
	                            'current+1': isAfterCurrent,
	                            'current-2': isBeforeBeforeCurrent,
	                            'current+2': isAfterAfterCurrent,
	                        } }, validateProps.h("span", { ...spanProps, tabIndex: 0, "aria-label": `${this.allyLabelPage || parsedIntl.page} ${value}`, "aria-current": isActive ? 'page' : null }, value)));
	                case ItemType.NEXT:
	                    return (validateProps.h("li", { key: "next", class: "next" }, validateProps.h("span", { ...spanProps, "aria-label": this.allyLabelNext || parsedIntl.next, "aria-disabled": isActive ? null : 'true' }, validateProps.h(PrefixedTagNames.pIcon, { ...iconProps, name: "arrow-right" }))));
	            }
	        }))));
	    }
	    onKeyDown(event, page) {
	        // from https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/button_role
	        const { key } = event;
	        if (key === ' ' || key === 'Enter' || key === 'Spacebar') {
	            event.preventDefault(); // prevent the default action to stop scrolling when space is pressed
	            this.onClick(page);
	        }
	    }
	    onClick(page) {
	        if (page !== this.activePage) {
	            this.update.emit({ page, previousPage: this.activePage });
	            this.pageChange.emit({ page, previousPage: this.activePage });
	            this.activePage = page; // TODO: should become a controlled component
	        }
	    }
	    static get delegatesFocus() { return true; }
	    get host() { return validateProps.getElement(this); }
	};

	pPagination_cjs_entry.p_pagination = Pagination;

	
	return pPagination_cjs_entry;
}

var pPinCode_cjs_entry = {};

var hasRequiredPPinCode_cjs_entry;

function requirePPinCode_cjs_entry () {
	if (hasRequiredPPinCode_cjs_entry) return pPinCode_cjs_entry;
	hasRequiredPPinCode_cjs_entry = 1;

	Object.defineProperty(pPinCode_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const stateMessageStyles = requireStateMessageStylesD1c4637f();
	const theme = requireThemeBfc10573();
	const slottedAnchorStyles = requireSlottedAnchorStylesFe1a10c2();
	const labelStyles = requireLabelStylesD5916d0e();
	const loadingMessageStyles = requireLoadingMessageStyles100c7f01();
	const formStyles = requireFormStylesDeecb9a1();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const getMediaQueryMax = requireGetMediaQueryMax5b73ea17();
	const fontLineHeight = requireFontLineHeightD4b9e1a9();
	requireHasNamedSlot273cd3ae();
	requireGetNamedSlot223c478a();
	requireTextSmallStyle00e1c6e2();
	requireTextShared5216bb19();
	requireFontFamily23874d28();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireBorderRadiusSmall5f37fc45();
	requireBorderRadiusMedium758b9411();
	requireGetClosestHTMLElement83d01a84();
	requireHasDescription050833e0();
	requireIsParentOfKind4b323732();
	requireFontSizeTextXSmallE59d35d7();
	requireHoverMediaQuery5e6deda8();
	requireSpacingStaticMedium94812711();

	const PIN_CODE_TYPES = ['number', 'password'];
	const PIN_CODE_LENGTHS = [1, 2, 3, 4, 5, 6];
	const removeSlottedSelector = (styles) => Object.fromEntries(Object.entries(styles).map(([key, value]) => {
	    value = typeof value === 'object' ? removeSlottedSelector(value) : value;
	    return [key.replace(/::slotted\(([^,]+)\)/g, '$1'), value];
	}));
	const removeStyles = (selector, styles) => Object.fromEntries(Object.entries(styles)
	    .filter(([key]) => key !== selector)
	    .map(([key, value]) => {
	    value = typeof value === 'object' ? removeStyles(selector, value) : value;
	    return [key, value];
	}));
	const warnAboutTransformedValue = (host, length) => {
	    const warningPrefix = `Property value of component ${validateProps.getTagNameWithoutPrefix(host)}:`;
	    validateProps.consoleWarn(warningPrefix, length
	        ? `Provided value has too many characters and was truncated to the max length of ${length}.`
	        : 'Provided value contains characters that are not of type number, the value was therefore reset.');
	};
	const isInputOnlyDigits = (input) => /^[0-9]*$/.test(input);
	const hasInputOnlyDigitsOrWhitespaces = (input) => /^[\d ]+$/.test(input);
	const getConcatenatedInputValues = (pinCodeElements) => pinCodeElements.map((el) => el.value || ' ').join('');
	// reset value if it contains invalid characters and cut string if pasted value is longer than pin code length
	const getSanitisedValue = (host, value, length) => {
	    if (value && !hasInputOnlyDigitsOrWhitespaces(value)) {
	        warnAboutTransformedValue(host);
	        return '';
	    }
	    if (removeWhiteSpaces(value)?.length > length) {
	        warnAboutTransformedValue(host, length);
	        return value.slice(0, length);
	    }
	    return value;
	};
	const removeWhiteSpaces = (value) => value.replace(/\s/g, '');
	// This reproduces native behavior where the form is only submittable under certain circumstances
	const isFormSubmittable = (host, form) => {
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(host);
	    return !!(form.querySelectorAll('input:not([type=submit]):not([type=hidden])').length === 0 || // other sibling form elements e.g. select, textarea do not prevent submission
	        Array.from(form.querySelectorAll(`${PrefixedTagNames.pButton},${PrefixedTagNames.pButtonPure},button[type=submit],input[type=submit]`)).some((el) => el.type === 'submit'));
	};
	/**
	 * Determines if the current input element corresponds to the first non-filled input
	 *
	 * @param {number} index - The index of the current input element.
	 * @param {string} value - The input value.
	 * @param {number} length - The total number of input elements.
	 * @returns {boolean} - True if the current input should have a specific identifier, indicating it corresponds to the first non-filled input; otherwise, false.
	 */
	const isCurrentInput = (index, value, length) => {
	    if (!value) {
	        return index === 0; // No value entered at all: set current-input id on the first input element
	    }
	    const firstWhitespaceIndex = value.indexOf(' ');
	    if (firstWhitespaceIndex === -1) {
	        return index === length - 1; // All inputs have a value: set current-input id on the last input element
	    }
	    return index === firstWhitespaceIndex; // Some value is entered: set current-input id on the first input element which does not have a value
	};

	const getComponentCss = (hideLabel, state, isDisabled, isLoading, length, theme) => {
	    const inputSize = `calc(${fontLineHeight.fontLineHeight} + 10px + ${validateProps.borderWidthBase} * 2 + ${spacingStaticSmall.spacingStaticSmall} * 2)`; // equivalent to calculation of input height within form-styles
	    const inputStyles = removeStyles('input[readonly]', removeSlottedSelector(formStyles.getSlottedTextFieldTextareaSelectStyles('input', state, isLoading, theme, {
	        // TODO: move into getSlottedTextFieldTextareaSelectStyles()
	        padding: `${formStyles.formElementPaddingVertical} ${spacingStaticXSmall.spacingStaticXSmall}`,
	        // TODO: move into getSlottedTextFieldTextareaSelectStyles() via parameter, e.g. textAlign=center|start
	        textAlign: 'center',
	        // TODO: move into getSlottedTextFieldTextareaSelectStyles() via parameter, e.g. size=max|min
	        maxWidth: inputSize,
	        // min width is needed for showing at least 1 character in very narrow containers. The "1rem" value is the minimum safe zone to show at least.
	        minWidth: `calc(1rem + ${validateProps.borderWidthBase}*2 + ${spacingStaticSmall.spacingStaticSmall}*2)`,
	        ...(length > 4 && {
	            [getMediaQueryMax.getMediaQueryMax('xs')]: {
	                // TODO: instead of having dedicated css rules depending on length we should try to implement a fluid one fits all solution
	                maxWidth: 'auto',
	                width: `calc((276px - (${spacingStaticSmall.spacingStaticSmall} * ${length - 1})) / ${length})`, // calculate the max with of the inputs that fit into grid in viewport base (276px)
	            },
	        }),
	        // TODO: move into getSlottedTextFieldTextareaSelectStyles() via parameter, e.g. isLoading
	        ...(isLoading && {
	            opacity: 0.2, // TODO: not in sync with e.g. checkbox/radio-button loading style
	            cursor: 'not-allowed',
	        }),
	        // since @playwright/test@1.40.1 this does not work anymore in Webkit browser engine for unknown reasons
	        /* ...Object.fromEntries(
	          Array.from(Array(length)).map((_, i) => {
	            return [`&:nth-of-type(${i + 1})`, { gridArea: `1/${i + 1}` }];
	          })
	        ),*/
	        '&:nth-of-type(1)': { gridArea: '1/1' },
	        '&:nth-of-type(2)': { gridArea: '1/2' },
	        '&:nth-of-type(3)': { gridArea: '1/3' },
	        '&:nth-of-type(4)': { gridArea: '1/4' },
	        '&:nth-of-type(5)': { gridArea: '1/5' },
	        '&:nth-of-type(6)': { gridArea: '1/6' },
	    })));
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            // input
	            ...inputStyles,
	        },
	        root: {
	            display: 'grid',
	            gap: spacingStaticXSmall.spacingStaticXSmall,
	        },
	        wrapper: {
	            display: 'grid',
	            gridTemplateColumns: `repeat(${length}, minmax(auto, 1fr))`,
	            justifySelf: 'flex-start',
	            gap: spacingStaticSmall.spacingStaticSmall,
	        },
	        ...(isLoading && {
	            spinner: {
	                gridArea: '1/1/1/-1',
	                placeSelf: 'center',
	                width: inputSize,
	                height: inputSize,
	                pointerEvents: 'none',
	            },
	        }),
	        // .label / .required
	        ...labelStyles.getFunctionalComponentLabelStyles(isDisabled, hideLabel, theme),
	        // .message
	        ...stateMessageStyles.getFunctionalComponentStateMessageStyles(theme, state),
	        // .loading
	        ...loadingMessageStyles.getFunctionalComponentLoadingMessageStyles(),
	    });
	};

	const propTypes = {
	    label: validateProps.AllowedTypes.string,
	    description: validateProps.AllowedTypes.string,
	    name: validateProps.AllowedTypes.string,
	    length: validateProps.AllowedTypes.oneOf(PIN_CODE_LENGTHS),
	    hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	    state: validateProps.AllowedTypes.oneOf(stateMessageStyles.FORM_STATES),
	    disabled: validateProps.AllowedTypes.boolean,
	    loading: validateProps.AllowedTypes.boolean,
	    required: validateProps.AllowedTypes.boolean,
	    form: validateProps.AllowedTypes.string,
	    message: validateProps.AllowedTypes.string,
	    type: validateProps.AllowedTypes.oneOf(PIN_CODE_TYPES),
	    value: validateProps.AllowedTypes.string,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const PinCode = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.update = validateProps.createEvent(this, "update", 3);
	        if (hostRef.$hostElement$["s-ei"]) {
	            this.internals = hostRef.$hostElement$["s-ei"];
	        }
	        else {
	            this.internals = hostRef.$hostElement$.attachInternals?.();
	            hostRef.$hostElement$["s-ei"] = this.internals;
	        }
	        this.initialLoading = false;
	        this.inputElements = [];
	        this.onInput = (event) => {
	            // Validation already happened in the beforeinput event
	            const { target } = event;
	            // Android keyboard suggestion calls single input event and inputs everything in the first input. By updating our value to what has been input, the component will update and distribute the values to the corresponding inputs.
	            if (target.value.length >= this.length) {
	                const sanitisedValue = removeWhiteSpaces(getSanitisedValue(this.host, target.value, this.length));
	                this.updateValue(sanitisedValue);
	                this.focusFirstEmptyOrLastInput(sanitisedValue);
	            }
	            else {
	                // iOS keyboard suggestion calls separate input events for each digit
	                this.updateValue(getConcatenatedInputValues(this.inputElements));
	                target.nextElementSibling?.focus();
	            }
	        };
	        this.onKeyDown = (event) => {
	            const { key, target, target: { previousElementSibling, nextElementSibling }, } = event;
	            if (key === 'Backspace' || key === 'Delete') {
	                // transfer focus backward/forward, if the input value is empty
	                if (!target.value) {
	                    event.preventDefault();
	                    if (key === 'Backspace' && previousElementSibling) {
	                        previousElementSibling.value = '';
	                        previousElementSibling.focus();
	                    }
	                    else if (key === 'Delete' && nextElementSibling) {
	                        nextElementSibling.value = '';
	                        nextElementSibling.focus();
	                    }
	                }
	                target.value = '';
	                this.updateValue(getConcatenatedInputValues(this.inputElements));
	            }
	            else if (key === 'Enter') {
	                if (this.internals?.form && isFormSubmittable(this.host, this.internals?.form)) {
	                    this.internals?.form.requestSubmit();
	                }
	            }
	            // workaround since 'Dead' key e.g. ^ can not be prevented with e.preventDefault()
	            // workaround for ^ in firefox key: 'Process'
	            else if (key === 'Dead' || key === 'Process') {
	                target.blur();
	                requestAnimationFrame(() => target.focus());
	            }
	        };
	        this.onPaste = (event) => {
	            const sanitisedPastedValue = removeWhiteSpaces(getSanitisedValue(this.host, event.clipboardData.getData('Text'), this.length));
	            if (sanitisedPastedValue !== this.value) {
	                this.updateValue(sanitisedPastedValue);
	                this.focusFirstEmptyOrLastInput(sanitisedPastedValue);
	            }
	            event.preventDefault();
	        };
	        this.updateValue = (newValue) => {
	            this.value = newValue;
	            this.internals?.setFormValue(this.value);
	            this.update.emit({ value: newValue, isComplete: removeWhiteSpaces(newValue).length === this.length });
	        };
	        this.focusFirstEmptyOrLastInput = (sanitisedValue) => {
	            this.inputElements[sanitisedValue.length === this.length ? sanitisedValue.length - 1 : sanitisedValue.length]?.focus();
	        };
	        this.label = '';
	        this.description = '';
	        this.name = undefined;
	        this.length = 4;
	        this.hideLabel = false;
	        this.state = 'none';
	        this.disabled = false;
	        this.loading = false;
	        this.required = false;
	        this.message = '';
	        this.type = 'number';
	        this.value = '';
	        this.theme = 'light';
	        this.form = undefined;
	    }
	    connectedCallback() {
	        this.initialLoading = this.loading;
	        validateProps.applyConstructableStylesheetStyles(this.host, slottedAnchorStyles.getSlottedAnchorStyles);
	    }
	    componentWillLoad() {
	        this.initialLoading = this.loading;
	        this.value = getSanitisedValue(this.host, this.value, this.length);
	        this.defaultValue = this.value;
	    }
	    componentWillUpdate() {
	        if (this.loading) {
	            this.initialLoading = true;
	        }
	    }
	    componentDidLoad() {
	        this.internals?.setFormValue(this.value);
	        // The beforeinput event is the only event which fires and can be prevented reliably on all keyboard types
	        for (const input of this.inputElements) {
	            input.addEventListener('beforeinput', (event) => {
	                const { data, inputType, target } = event;
	                // This is equivalent to maxLength={1} but since some keyboard suggestions fire a single input event we cant use the maxLength attribute
	                // This causes the keyboard suggestion to only work if input is empty
	                const preventMultipleInput = inputType === 'insertText' && target.value.length > 0;
	                const preventNonDigitInput = data && !isInputOnlyDigits(data);
	                if (preventMultipleInput || preventNonDigitInput || this.loading) {
	                    event.preventDefault();
	                }
	            });
	        }
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    formResetCallback() {
	        this.internals?.setFormValue(this.defaultValue);
	        this.value = this.defaultValue;
	    }
	    formDisabledCallback(disabled) {
	        this.disabled = disabled;
	    }
	    formStateRestoreCallback(state) {
	        this.value = state;
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.hideLabel, this.state, this.disabled, this.loading, this.length, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        // reset array of input elements
	        this.inputElements = [];
	        const currentInputId = 'current-input';
	        return (validateProps.h("div", { key: '230cc203d80c32c7545139df4881ddf1ea9ac6f5', class: "root" }, validateProps.h(labelStyles.Label, { key: 'e45ef120d3d2228b6513fa7c74cec44f4177d42e', host: this.host, label: this.label, description: this.description, htmlFor: currentInputId, isRequired: this.required, isLoading: this.loading, isDisabled: this.disabled }), validateProps.h("div", { key: '5591a675058b0cc6dff4cd955950f9ef76a39f1b', class: "wrapper", onKeyDown: this.onKeyDown, onPaste: this.onPaste, onInput: this.onInput }, Array.from(new Array(this.length), (_, index) => (validateProps.h("input", { key: index, name: this.name, form: this.form, ...(isCurrentInput(index, this.value, this.length) && { id: currentInputId }), type: this.type === 'number' ? 'text' : this.type, "aria-label": `${index + 1}-${this.length}`, "aria-describedby": `${labelStyles.labelId} ${labelStyles.descriptionId} ${stateMessageStyles.messageId}`, "aria-invalid": this.state === 'error' ? 'true' : null, "aria-disabled": this.loading ? 'true' : null, autoComplete: "one-time-code", pattern: "\\d*", inputMode: "numeric" // get numeric keyboard on mobile
	            ,
	            value: this.value[index] === ' ' ? null : this.value[index], disabled: this.disabled, required: this.required, ref: (el) => this.inputElements.push(el) }))), this.loading && (validateProps.h(PrefixedTagNames.pSpinner, { key: '6b1b252130327b928e373f65ee5ff7ff25773aa2', class: "spinner", size: "inherit", theme: this.theme, "aria-hidden": "true" }))), validateProps.h(stateMessageStyles.StateMessage, { key: '854bcbed280b228d3f82bbf18701274c5925c7fb', state: this.state, message: this.message, theme: this.theme, host: this.host }), validateProps.h(loadingMessageStyles.LoadingMessage, { key: 'aa5b9b3735739a314755922847cfbfd8bde0e2ea', loading: this.loading, initialLoading: this.initialLoading })));
	    }
	    static get delegatesFocus() { return true; }
	    static get formAssociated() { return true; }
	    get host() { return validateProps.getElement(this); }
	};

	pPinCode_cjs_entry.p_pin_code = PinCode;

	
	return pPinCode_cjs_entry;
}

var pPopover_cjs_entry = {};

var hasRequiredPPopover_cjs_entry;

function requirePPopover_cjs_entry () {
	if (hasRequiredPPopover_cjs_entry) return pPopover_cjs_entry;
	hasRequiredPPopover_cjs_entry = 1;

	Object.defineProperty(pPopover_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const isClickOutside = requireIsClickOutside050dc86b();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const textSmallStyle = requireTextSmallStyle00e1c6e2();
	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();
	const fontFamily = requireFontFamily23874d28();
	const fontLineHeight = requireFontLineHeightD4b9e1a9();
	const frostedGlassStyle = requireFrostedGlassStyleBd067e45();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	requireTextShared5216bb19();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();

	const POPOVER_DIRECTIONS = ['top', 'right', 'bottom', 'left'];
	const POPOVER_ARIA_ATTRIBUTES = ['aria-label'];
	const POPOVER_SAFE_ZONE = 8;

	const { canvasTextColor } = validateProps.getHighContrastColors();
	const getComponentCss = (theme) => {
	    const { hoverColor, backgroundColor, primaryColor, backgroundSurfaceColor } = validateProps.getThemedColors(theme);
	    const { hoverColor: hoverColorDark, primaryColor: primaryColorDark, backgroundSurfaceColor: backgroundSurfaceColorDark, } = validateProps.getThemedColors('dark');
	    const shadowColor = 'rgba(0,0,0,0.3)';
	    return validateProps.getCss({
	        '@global': {
	            '@keyframes fade-in': {
	                from: {
	                    opacity: 0,
	                },
	                to: {
	                    opacity: 1,
	                },
	            },
	            ':host': {
	                position: 'relative', // ensures correct reference for floating ui fallback positioning in older browsers
	                display: 'inline-block',
	                verticalAlign: 'top',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            p: {
	                ...textSmallStyle.textSmallStyle,
	                margin: 0,
	            },
	            button: {
	                all: 'unset',
	                display: 'block',
	                font: `${fontSizeTextSmall.fontSizeTextSmall} ${fontFamily.fontFamily}`, // needed for correct width/height definition based on ex-unit
	                width: fontLineHeight.fontLineHeight, // width needed to improve ssr support
	                height: fontLineHeight.fontLineHeight, // height needed to improve ssr support
	                borderRadius: '50%',
	                cursor: 'pointer',
	                ...hoverMediaQuery.hoverMediaQuery({
	                    transition: validateProps.getTransition('background-color'),
	                    '&:hover': {
	                        ...frostedGlassStyle.frostedGlassStyle,
	                        backgroundColor: hoverColor,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            backgroundColor: hoverColorDark,
	                        }),
	                    },
	                }),
	                ...validateProps.getFocusJssStyle(theme, { offset: 0 }),
	            },
	            '[popover]': {
	                all: 'unset',
	                position: 'absolute',
	                pointerEvents: 'none',
	                filter: `drop-shadow(0 0 16px ${shadowColor})`,
	                animation: `var(${validateProps.cssVariableAnimationDuration}, ${validateProps.motionDurationShort}) fade-in ${validateProps.motionEasingBase} forwards`,
	                '&:not(:popover-open)': {
	                    display: 'none', // ensures popover is not flickering when closed in some situations
	                },
	            },
	        },
	        label: validateProps.getHiddenTextJssStyle(),
	        icon: {
	            transform: 'translate3d(0,0,0)', // Fixes movement on hover in Safari
	        },
	        arrow: {
	            position: 'absolute',
	            width: '24px',
	            height: '12px',
	            clipPath: 'polygon(50% 0, 100% 110%, 0 110%)',
	            ...(validateProps.isHighContrastMode
	                ? {
	                    background: canvasTextColor,
	                }
	                : {
	                    background: validateProps.isThemeDark(theme) ? backgroundSurfaceColor : backgroundColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        background: backgroundSurfaceColorDark,
	                    }),
	                }),
	        },
	        content: {
	            maxWidth: `min(calc(100dvw - ${POPOVER_SAFE_ZONE * 2}px), 48ch)`,
	            width: 'max-content', // ensures in older browsers correct width
	            boxSizing: 'border-box',
	            padding: `${spacingStaticSmall.spacingStaticSmall} ${spacingStaticMedium.spacingStaticMedium}`,
	            pointerEvents: 'auto',
	            borderRadius: borderRadiusSmall.borderRadiusSmall,
	            ...(validateProps.isHighContrastMode && {
	                outline: `1px solid ${canvasTextColor}`,
	            }),
	            ...textSmallStyle.textSmallStyle,
	            background: validateProps.isThemeDark(theme) ? backgroundSurfaceColor : backgroundColor,
	            color: primaryColor,
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                background: backgroundSurfaceColorDark,
	                color: primaryColorDark,
	            }),
	        },
	    });
	};

	const propTypes = {
	    direction: validateProps.AllowedTypes.oneOf(POPOVER_DIRECTIONS),
	    description: validateProps.AllowedTypes.string,
	    aria: validateProps.AllowedTypes.aria(POPOVER_ARIA_ATTRIBUTES),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Popover = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.hasNativePopoverSupport = validateProps.getHasNativePopoverSupport();
	        this.handlePopover = (open) => {
	            if (open) {
	                if (this.hasNativePopoverSupport) {
	                    this.popover.showPopover();
	                }
	                if (typeof this.cleanUpAutoUpdate === 'undefined') {
	                    // ensures floating ui event listeners are added when popover is opened
	                    this.cleanUpAutoUpdate = isClickOutside.autoUpdate(this.button, this.popover, this.updatePosition);
	                }
	            }
	            else {
	                // we can't call hidePopover() because the popover element itself is rendered conditionally
	                // if (this.hasNativePopoverSupport) {
	                //   this.popover.hidePopover();
	                // }
	                if (typeof this.cleanUpAutoUpdate === 'function') {
	                    // ensures floating ui event listeners are removed when popover is closed
	                    this.cleanUpAutoUpdate();
	                    this.cleanUpAutoUpdate = undefined;
	                }
	            }
	        };
	        this.onClickOutside = (e) => {
	            if (this.isOpen && isClickOutside.isClickOutside(e, this.button) && isClickOutside.isClickOutside(e, this.popover)) {
	                this.isOpen = false;
	            }
	        };
	        this.updatePosition = async () => {
	            const { x, y, placement, middlewareData } = await isClickOutside.computePosition(this.button, this.popover, {
	                placement: this.direction,
	                middleware: [
	                    isClickOutside.offset(16),
	                    isClickOutside.shift({
	                        padding: POPOVER_SAFE_ZONE,
	                        limiter: isClickOutside.limitShift({
	                            offset: ({ rects }) => rects.reference.width,
	                        }),
	                    }),
	                    isClickOutside.flip({
	                        padding: POPOVER_SAFE_ZONE,
	                        fallbackAxisSideDirection: 'end',
	                    }),
	                    isClickOutside.arrow({ element: this.arrow }),
	                ],
	            });
	            const placementVertical = placement === 'top' || placement === 'bottom';
	            const placementTopLeft = placement === 'top' || placement === 'left';
	            Object.assign(this.popover.style, {
	                left: `${x}px`,
	                top: `${y}px`,
	            });
	            const { x: xArrow, y: yArrow } = middlewareData.arrow;
	            Object.assign(this.arrow.style, {
	                clipPath: placementVertical ? 'polygon(50% 0, 100% 110%, 0 110%)' : 'polygon(0 50%, 110% 0, 110% 100%)',
	                width: placementVertical ? '24px' : '12px',
	                height: placementVertical ? '12px' : '24px',
	                transform: `rotate(${placementTopLeft ? '180deg' : '0'}`,
	                left: ['right', 'bottom', 'top'].includes(placement) ? (xArrow != null ? `${xArrow}px` : '-12px') : '',
	                right: placement === 'left' ? (xArrow != null ? `${xArrow}px` : '-12px') : '',
	                top: ['bottom', 'left', 'right'].includes(placement) ? (yArrow != null ? `${yArrow}px` : '-12px') : '',
	                bottom: placement === 'top' ? (yArrow != null ? `${yArrow}px` : '-12px') : '',
	            });
	        };
	        this.direction = 'bottom';
	        this.description = undefined;
	        this.aria = undefined;
	        this.theme = 'light';
	        this.isOpen = false;
	    }
	    connectedCallback() {
	        document.addEventListener('mousedown', this.onClickOutside, true);
	    }
	    disconnectedCallback() {
	        document.removeEventListener('mousedown', this.onClickOutside, true);
	        // ensures floating ui event listeners are removed in case popover is removed from DOM
	        this.handlePopover(false);
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(validateProps.Host, { key: '0050ff2a9a9491be88f749b1d79f7500c3b2460f', onKeydown: (e) => e.key === 'Escape' && this.button.focus() }, validateProps.h("button", { key: '9a3c71f0d32503c7cbd50e21d3e851ccf61e569b', type: "button", onClick: () => (this.isOpen = !this.isOpen), ...validateProps.parseAndGetAriaAttributes({
	                ...validateProps.parseAndGetAriaAttributes(this.aria),
	                ...{ 'aria-expanded': this.isOpen },
	            }), ref: (el) => (this.button = el) }, validateProps.h(PrefixedTagNames.pIcon, { key: '2b799fa0cb2603cfd14f64b9b600c88fcad6c5da', class: "icon", name: "information", theme: this.theme }), validateProps.h("span", { key: 'b1ce3949908853abd2a6b9ef39e619c834cbe675', class: "label" }, "More information")), this.isOpen && (validateProps.h("div", { key: '48e8941296d3f6d33644d96cda351aa72e0576c3', popover: "auto", onToggle: (e) => (this.isOpen = e.newState === 'open'), ref: (el) => (this.popover = el) }, validateProps.h("div", { key: '207dbe7623f90f48d86aef19a6c95986707d4744', class: "arrow", ref: (el) => (this.arrow = el) }), validateProps.h("div", { key: '66e7b7c505add544486f56f605eb837ca0d35246', class: "content" }, this.description ? validateProps.h("p", null, this.description) : validateProps.h("slot", null))))));
	    }
	    componentDidRender() {
	        // needs to be called after render cycle to be able to render the popover conditionally
	        this.handlePopover(this.isOpen);
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pPopover_cjs_entry.p_popover = Popover;

	
	return pPopover_cjs_entry;
}

var pRadioButtonWrapper_cjs_entry = {};

var hasRequiredPRadioButtonWrapper_cjs_entry;

function requirePRadioButtonWrapper_cjs_entry () {
	if (hasRequiredPRadioButtonWrapper_cjs_entry) return pRadioButtonWrapper_cjs_entry;
	hasRequiredPRadioButtonWrapper_cjs_entry = 1;

	Object.defineProperty(pRadioButtonWrapper_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const stateMessageStyles = requireStateMessageStylesD1c4637f();
	const theme = requireThemeBfc10573();
	const getOnlyChildOfKindHTMLElementOrThrow = requireGetOnlyChildOfKindHTMLElementOrThrowCdb95e52();
	const applyCheckboxRadioButtonSafariRenderingFix = requireApplyCheckboxRadioButtonSafariRenderingFixE0db2b50();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const schemedHighContrastMediaQuery = requireSchemedHighContrastMediaQuery462417a0();
	const isDisabledOrLoading = requireIsDisabledOrLoadingB1f56d7f();
	const getInlineSVGBackgroundImage = requireGetInlineSVGBackgroundImageB65404d9();
	const labelStyles = requireLabelStylesD5916d0e();
	const loadingMessageStyles = requireLoadingMessageStyles100c7f01();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const fontLineHeight = requireFontLineHeightD4b9e1a9();
	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();
	const fontFamily = requireFontFamily23874d28();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const slottedAnchorStyles = requireSlottedAnchorStylesFe1a10c2();
	requireHasNamedSlot273cd3ae();
	requireGetNamedSlot223c478a();
	requireTextSmallStyle00e1c6e2();
	requireTextShared5216bb19();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireGetDirectChildHTMLElements2594e5bd();
	requireGetHTMLElements3f1c700f();
	requireTransformSelectorToDirectChildSelectorEcc1a9c4();
	requireSupportsChromiumMediaQueryE79aefa2();
	requireHoverMediaQuery5e6deda8();
	requireGetClosestHTMLElement83d01a84();
	requireHasDescription050833e0();
	requireIsParentOfKind4b323732();
	requireFontSizeTextXSmallE59d35d7();
	requireBorderRadiusSmall5f37fc45();
	requireBorderRadiusMedium758b9411();

	const getCheckedSVGBackgroundImage = (fill) => {
	    return getInlineSVGBackgroundImage.getInlineSVGBackgroundImage(`<circle fill="${fill}" cx="12" cy="12" r="6"/>`);
	};
	const getComponentCss = (hideLabel, state, isDisabled, isLoading, theme) => {
	    const checkedIconColor = getInlineSVGBackgroundImage.escapeHashCharacter(validateProps.getInvertedThemedColors(theme).primaryColor);
	    const checkedIconColorDark = getInlineSVGBackgroundImage.escapeHashCharacter(validateProps.getInvertedThemedColors('dark').primaryColor);
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            // ::slotted(input)
	            ...validateProps.addImportantToEachRule(validateProps.mergeDeep(applyCheckboxRadioButtonSafariRenderingFix.getSlottedCheckboxRadioButtonStyles(state, isDisabled, isLoading, theme), {
	                '::slotted': {
	                    '&(input)': {
	                        gridArea: '1/1',
	                        borderRadius: '50%',
	                    },
	                    // TODO: is it somehow useful possible to make following styles configurable by paramter?
	                    ...(!isLoading && {
	                        '&(input:checked)': {
	                            backgroundImage: getCheckedSVGBackgroundImage(checkedIconColor),
	                            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                                backgroundImage: getCheckedSVGBackgroundImage(checkedIconColorDark),
	                            }),
	                            // This is a workaround for Blink based browsers, which do not reflect the high contrast system colors (e.g.: "Canvas" and "CanvasText") when added to background SVG's.
	                            ...(validateProps.isHighContrastMode &&
	                                schemedHighContrastMediaQuery.getSchemedHighContrastMediaQuery({
	                                    backgroundImage: getCheckedSVGBackgroundImage('white'),
	                                }, {
	                                    backgroundImage: getCheckedSVGBackgroundImage('black'),
	                                })),
	                        },
	                    }),
	                },
	            })),
	        },
	        root: {
	            display: 'grid',
	            gridTemplateColumns: 'auto minmax(0, 1fr)',
	            rowGap: spacingStaticXSmall.spacingStaticXSmall,
	        },
	        wrapper: {
	            display: 'grid',
	            gridArea: '1/1',
	            alignSelf: 'flex-start', // in case label becomes multiline
	            ...(isDisabledOrLoading.isDisabledOrLoading(isDisabled, isLoading) && {
	                // TODO: maybe .wrapper should handle it for all form components while pointer-events: none is set to input
	                cursor: 'not-allowed',
	            }),
	        },
	        ...(isLoading && {
	            // TODO: extract for checkbox-wrapper and radio-button-wrapper (not gridArea and placeSelf)
	            spinner: {
	                position: 'relative', // ensure correct stacking, can be removed as soon as focus for input is handled with outline
	                gridArea: '1/1',
	                placeSelf: 'center',
	                width: fontLineHeight.fontLineHeight,
	                height: fontLineHeight.fontLineHeight,
	                font: `${fontSizeTextSmall.fontSizeTextSmall} ${fontFamily.fontFamily}`, // needed for correct width and height definition based on ex-unit
	                pointerEvents: 'none',
	            },
	        }),
	        // .label / .required
	        ...labelStyles.getFunctionalComponentLabelStyles(isDisabled || isLoading, hideLabel, theme, {
	            gridArea: '1/2',
	        }, {
	            paddingTop: '2px', // compensate vertical alignment
	            paddingInlineStart: spacingStaticSmall.spacingStaticSmall, // asymmetric padding used instead of gap to prevent not clickable area between label and input
	        }),
	        // .message
	        ...stateMessageStyles.getFunctionalComponentStateMessageStyles(theme, state, {
	            gridColumn: '1/3',
	        }),
	        // .loading
	        ...loadingMessageStyles.getFunctionalComponentLoadingMessageStyles(),
	    });
	};

	const propTypes = {
	    label: validateProps.AllowedTypes.string,
	    state: validateProps.AllowedTypes.oneOf(stateMessageStyles.FORM_STATES),
	    message: validateProps.AllowedTypes.string,
	    hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	    loading: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const RadioButtonWrapper = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.initialLoading = false;
	        this.observeAttributes = () => {
	            validateProps.observeAttributes(this.input, ['disabled', 'required'], () => validateProps.forceUpdate(this.host));
	        };
	        this.label = '';
	        this.state = 'none';
	        this.message = '';
	        this.hideLabel = false;
	        this.loading = false;
	        this.theme = 'light';
	    }
	    connectedCallback() {
	        this.initialLoading = this.loading;
	        validateProps.applyConstructableStylesheetStyles(this.host, slottedAnchorStyles.getSlottedAnchorStyles, applyCheckboxRadioButtonSafariRenderingFix.getCheckboxRadioButtonSafariRenderingFix);
	        this.observeAttributes(); // on every reconnect
	    }
	    componentWillLoad() {
	        this.initialLoading = this.loading;
	        this.input = getOnlyChildOfKindHTMLElementOrThrow.getOnlyChildOfKindHTMLElementOrThrow(this.host, 'input[type=radio]');
	        this.observeAttributes(); // once initially
	    }
	    componentWillUpdate() {
	        if (this.loading) {
	            this.initialLoading = true;
	        }
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    componentDidRender() {
	        /*
	         * This is a workaround to improve accessibility because the input and the label/description/message text are placed in different DOM.
	         * Referencing ID's from outside the component is impossible because the web components DOM is separate.
	         * We have to wait for full support of the Accessibility Object Model (AOM) to provide the relationship between shadow DOM and slots
	         */
	        validateProps.setAriaAttributes(this.input, {
	            label: this.label,
	            message: this.message,
	            state: this.state,
	        });
	    }
	    disconnectedCallback() {
	        validateProps.unobserveAttributes(this.input);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        const { disabled } = this.input;
	        const isLoading = this.loading && !this.input.checked; // spinner is only displayed when radio is not checked already
	        validateProps.attachComponentCss(this.host, getComponentCss, this.hideLabel, this.state, disabled, isLoading, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h("div", { key: 'deb72cefe48d3b4f2d41eccf71c824c4370d81f1', class: "root" }, validateProps.h(labelStyles.Label, { key: 'de69ba3ea29d7d97997e634b1234d1c8e6647445', host: this.host, label: this.label, isLoading: isLoading, isDisabled: disabled, formElement: this.input }), validateProps.h("div", { key: '48591a680fdce89a3f17751c6c502dd150d95fa1', class: "wrapper" }, validateProps.h("slot", { key: '490a8f11b8bb62ca5c92c359703b90eb96f76082' }), isLoading && (validateProps.h(PrefixedTagNames.pSpinner, { key: 'f11fbedcd85acf2f6d00adc8934c1c6e80f64e00', class: "spinner", size: "inherit", theme: this.theme, "aria-hidden": "true" }))), validateProps.h(stateMessageStyles.StateMessage, { key: '5bd8666015f6ebfcff6d8660594da435b3ac3d3b', state: this.state, message: this.message, theme: this.theme, host: this.host }), validateProps.h(loadingMessageStyles.LoadingMessage, { key: 'fa8933bbf3d6ff244f28870581d5f10b03425bce', loading: isLoading, initialLoading: this.initialLoading })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pRadioButtonWrapper_cjs_entry.p_radio_button_wrapper = RadioButtonWrapper;

	
	return pRadioButtonWrapper_cjs_entry;
}

var pScroller_cjs_entry = {};

var scrollingD5dce8b3 = {};

var hasRequiredScrollingD5dce8b3;

function requireScrollingD5dce8b3 () {
	if (hasRequiredScrollingD5dce8b3) return scrollingD5dce8b3;
	hasRequiredScrollingD5dce8b3 = 1;

	requireValidateProps788e2bc5();
	const getHTMLElements = requireGetHTMLElements3f1c700f();

	// This class is shared since the popover needs to register a scroll listener to this node in order to hide the popover when the table is scrolled
	const scrollAreaClass = 'scroll-area';

	const SCROLLER_ARIA_ATTRIBUTES = ['role'];
	/** @deprecated */
	const GRADIENT_COLOR_SCHEMES = ['default', 'surface'];
	const GRADIENT_COLORS = ['background-base', 'background-surface'];
	const SCROLL_INDICATOR_POSITIONS = ['top', 'center'];
	const getScrollPositionAfterPrevNextClick = (scrollAreaElement, direction) => {
	    const { scrollLeft } = scrollAreaElement;
	    const scrollByX = getScrollByX(scrollAreaElement);
	    return direction === 'next' ? scrollLeft + scrollByX : scrollLeft - scrollByX;
	};
	const getScrollerElements = (scrollerElement) => {
	    return getHTMLElements.getHTMLElements(scrollerElement.shadowRoot, `.${scrollAreaClass},.action-prev`);
	};
	const isScrollable = (isPrevHidden, isNextHidden) => {
	    return !(isPrevHidden && isNextHidden);
	};

	const scrollElementTo = (el, amount) => {
	    el.scrollTo({
	        left: amount,
	        behavior: 'smooth', // TODO: make conditional so we don't need to wait in e2e or vrt tests
	    });
	};
	const getScrollByX = (scrollAreaElement) => {
	    return Math.round(scrollAreaElement.offsetWidth * 0.2);
	};
	const FOCUS_PADDING_WIDTH = 4;
	const getScrollActivePosition = (elements, direction, activeElementIndex, scrollerElement) => {
	    const { offsetLeft: activeElementOffsetLeft, offsetWidth: activeElementOffsetWidth } = elements[activeElementIndex <= 0 ? 0 : activeElementIndex] || {}; // empty object fallback for tabs without children
	    // offsetLeft: is the number of pixels that the upper left corner of the current element is offset to the left within the offsetParent node
	    // offsetParent: is a reference to the element which is the closest (nearest in the containment hierarchy) positioned ancestor element
	    // which usually is an element with a non-static position
	    // - in chrome this seems to respect shadow DOM and therefore is the div.scroll-wrapper element in p-scroller
	    // - in firefox and safari this is not the case and some other parent element (up to the body element) is used
	    // this obviously leads to completely wrong calculations which are being corrected
	    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetLeft
	    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent
	    const correctedActiveElementOffsetLeft = elements[0]?.offsetLeft === 0 ? activeElementOffsetLeft : activeElementOffsetLeft - scrollerElement.offsetLeft;
	    const [scrollAreaElement, prevGradientElement] = getScrollerElements(scrollerElement);
	    let scrollPosition;
	    if (direction === 'next') {
	        if (activeElementIndex === elements.length - 1) {
	            // go to last element
	            scrollPosition = correctedActiveElementOffsetLeft - FOCUS_PADDING_WIDTH;
	        }
	        else {
	            // go to next element
	            scrollPosition = correctedActiveElementOffsetLeft - prevGradientElement.offsetWidth + FOCUS_PADDING_WIDTH * 2;
	        }
	    }
	    else if (activeElementIndex === 0) {
	        // go to first element
	        scrollPosition = 0;
	    }
	    else {
	        // go to prev element
	        scrollPosition =
	            correctedActiveElementOffsetLeft +
	                activeElementOffsetWidth +
	                prevGradientElement.offsetWidth -
	                scrollAreaElement.offsetWidth;
	    }
	    return scrollPosition;
	};

	scrollingD5dce8b3.GRADIENT_COLORS = GRADIENT_COLORS;
	scrollingD5dce8b3.GRADIENT_COLOR_SCHEMES = GRADIENT_COLOR_SCHEMES;
	scrollingD5dce8b3.SCROLLER_ARIA_ATTRIBUTES = SCROLLER_ARIA_ATTRIBUTES;
	scrollingD5dce8b3.SCROLL_INDICATOR_POSITIONS = SCROLL_INDICATOR_POSITIONS;
	scrollingD5dce8b3.getScrollActivePosition = getScrollActivePosition;
	scrollingD5dce8b3.getScrollPositionAfterPrevNextClick = getScrollPositionAfterPrevNextClick;
	scrollingD5dce8b3.isScrollable = isScrollable;
	scrollingD5dce8b3.scrollAreaClass = scrollAreaClass;
	scrollingD5dce8b3.scrollElementTo = scrollElementTo;

	
	return scrollingD5dce8b3;
}

var hasRequiredPScroller_cjs_entry;

function requirePScroller_cjs_entry () {
	if (hasRequiredPScroller_cjs_entry) return pScroller_cjs_entry;
	hasRequiredPScroller_cjs_entry = 1;

	Object.defineProperty(pScroller_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const getHTMLElements = requireGetHTMLElements3f1c700f();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed91ceea3c();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed76f87eda();
	const scrolling = requireScrollingD5dce8b3();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const fontLineHeight = requireFontLineHeightD4b9e1a9();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const dropShadowShared = requireDropShadowShared6e50faf3();
	requireHelper22e15c0e();

	const dropShadowLowStyle = {
	    boxShadow: `0px 3px 8px ${dropShadowShared._dropShadowBackgroundColor}`, // filter: drop-shadow() causes visual glitches in Firefox in combination with frostedGlassStyle
	};

	const gradientColorLight = {
	    'background-base': '255,255,255',
	    'background-surface': '238,239,242',
	};
	const gradientColorDark = {
	    'background-base': '14,14,18',
	    'background-surface': '33,34,37',
	};
	const gradientColorMap = {
	    auto: gradientColorLight,
	    light: gradientColorLight,
	    dark: gradientColorDark,
	};
	const getGradient = (theme, gradientColorTheme) => {
	    const gradientColor = gradientColorMap[theme][gradientColorTheme];
	    return (`rgba(${gradientColor},1) 20%,` +
	        `rgba(${gradientColor},0.6) 48%,` +
	        `rgba(${gradientColor},0.3) 68%,` +
	        `rgba(${gradientColor},0)`);
	};
	const prevNextWrapperWidth = `calc(${fontLineHeight.fontLineHeight} + 24px)`;
	const getComponentCss = (gradientColor, isNextHidden, isPrevHidden, scrollIndicatorPosition, hasScrollbar, theme) => {
	    const actionPrevNextStyles = {
	        position: 'absolute',
	        top: 0,
	        bottom: 0,
	        direction: 'ltr',
	        width: prevNextWrapperWidth,
	        padding: '4px 0',
	        display: 'flex',
	        alignItems: scrollIndicatorPosition === 'center' ? 'center' : 'flex-start',
	    };
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    height: 'inherit',
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	        },
	        root: {
	            position: 'relative',
	            display: 'grid',
	            gridTemplateColumns: `${prevNextWrapperWidth} minmax(0, 1fr) ${prevNextWrapperWidth}`,
	            margin: '0 -4px',
	            height: 'inherit',
	        },
	        'scroll-area': {
	            gridArea: '1 / 1 / 1 / -1',
	            padding: '4px',
	            overflow: 'auto hidden',
	            ...(!hasScrollbar && {
	                // If scrollbar is disabled - hide scrollbar
	                msOverflowStyle: 'none' /* IE and Edge */,
	                scrollbarWidth: 'none' /* Firefox */,
	                '&::-webkit-scrollbar': {
	                    display: 'none',
	                },
	            }),
	        },
	        // Extra wrapper needed to compensate different offset parent calculation depending on browser.
	        // Needed for position of status bar.
	        'scroll-wrapper': {
	            position: 'relative',
	            display: 'inline-flex',
	            minHeight: '28px',
	            minWidth: '100%',
	            verticalAlign: 'top',
	            borderRadius: borderRadiusSmall.borderRadiusSmall,
	            ...validateProps.getFocusJssStyle(theme),
	        },
	        trigger: {
	            position: 'absolute',
	            top: 0,
	            bottom: 0,
	            width: '1px',
	            visibility: 'hidden',
	            '&:first-of-type': {
	                left: 0,
	            },
	            '&:last-of-type': {
	                right: 0,
	            },
	        },
	        'action-prev': {
	            ...actionPrevNextStyles,
	            left: '-1px', // ensures that the gradient always overlays the content (e.g. when zoomed)
	            justifyContent: 'flex-start',
	            background: `linear-gradient(to right, ${getGradient(theme, gradientColor)} 100%)`,
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                background: `linear-gradient(to right, ${getGradient('dark', gradientColor)} 100%)`,
	            }),
	            visibility: isPrevHidden ? 'hidden' : 'inherit',
	            '& .action-button': {
	                marginLeft: '8px',
	                // hide buttons on mobile (actually devices not supporting hover)
	                ...hoverMediaQuery.hoverMediaQuery({
	                    visibility: isPrevHidden ? 'hidden' : 'inherit',
	                }),
	            },
	        },
	        'action-next': {
	            ...actionPrevNextStyles,
	            right: '-1px', // ensures that the gradient always overlays the content (e.g. when zoomed)
	            justifyContent: 'flex-end',
	            background: `linear-gradient(to left, ${getGradient(theme, gradientColor)} 100%)`,
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                background: `linear-gradient(to left, ${getGradient('dark', gradientColor)} 100%)`,
	            }),
	            visibility: isNextHidden ? 'hidden' : 'inherit',
	            '& .action-button': {
	                marginRight: '8px',
	                // hide buttons on mobile (actually devices not supporting hover)
	                ...hoverMediaQuery.hoverMediaQuery({
	                    visibility: isNextHidden ? 'hidden' : 'inherit',
	                }),
	            },
	        },
	        'action-button': {
	            ...validateProps.dismissButtonJssStyle,
	            ...(!validateProps.isThemeDark(theme) && dropShadowLowStyle),
	        },
	        icon: {
	            '&:dir(rtl)': {
	                transform: 'scaleX(-1)',
	            },
	        },
	    });
	};

	const propTypes = {
	    gradientColorScheme: validateProps.AllowedTypes.oneOf([undefined, ...scrolling.GRADIENT_COLOR_SCHEMES]),
	    gradientColor: validateProps.AllowedTypes.oneOf(scrolling.GRADIENT_COLORS),
	    scrollToPosition: validateProps.AllowedTypes.shape({
	        scrollPosition: validateProps.AllowedTypes.number,
	        isSmooth: validateProps.AllowedTypes.boolean,
	    }),
	    scrollIndicatorPosition: validateProps.AllowedTypes.oneOf([
	        undefined,
	        ...scrolling.SCROLL_INDICATOR_POSITIONS,
	    ]),
	    alignScrollIndicator: validateProps.AllowedTypes.oneOf(scrolling.SCROLL_INDICATOR_POSITIONS),
	    scrollbar: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    aria: validateProps.AllowedTypes.aria(scrolling.SCROLLER_ARIA_ATTRIBUTES),
	};
	const Scroller = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.initIntersectionObserver = () => {
	            const [firstTrigger, lastTrigger] = getHTMLElements.getHTMLElements(this.host.shadowRoot, '.trigger');
	            this.intersectionObserver = new IntersectionObserver((entries) => {
	                for (const { target, isIntersecting } of entries) {
	                    if (target === firstTrigger) {
	                        this.isPrevHidden = isIntersecting;
	                    }
	                    else if (target === lastTrigger) {
	                        this.isNextHidden = isIntersecting;
	                    }
	                }
	            }, {
	                root: this.scrollAreaElement,
	                // Defines the percentage of how much of the target (trigger) is visible within the element specified (this.host).
	                // In this case 0.9px of the trigger have to be hidden to show the gradient
	                threshold: 0.1,
	            });
	            this.intersectionObserver.observe(firstTrigger);
	            this.intersectionObserver.observe(lastTrigger);
	        };
	        this.scrollOnPrevNextClick = (direction) => {
	            const scrollPosition = scrolling.getScrollPositionAfterPrevNextClick(this.scrollAreaElement, direction);
	            scrolling.scrollElementTo(this.scrollAreaElement, scrollPosition);
	        };
	        this.gradientColorScheme = undefined;
	        this.gradientColor = 'background-base';
	        this.scrollToPosition = undefined;
	        this.scrollIndicatorPosition = undefined;
	        this.alignScrollIndicator = 'center';
	        this.theme = 'light';
	        this.scrollbar = false;
	        this.aria = undefined;
	        this.isPrevHidden = true;
	        this.isNextHidden = true;
	    }
	    scrollToPositionHandler() {
	        // TODO: does this.scrollToPosition already have the new value? or why aren't we using the first parameter of this function
	        this.scrollToPosition = validateProps.parseJSONAttribute(this.scrollToPosition);
	        // watcher might trigger before ref is defined with ssr
	        if (this.scrollAreaElement) {
	            const { scrollPosition, isSmooth } = this.scrollToPosition;
	            if (isSmooth) {
	                scrolling.scrollElementTo(this.scrollAreaElement, scrollPosition);
	            }
	            else {
	                this.scrollAreaElement.scrollLeft = scrollPosition;
	            }
	        }
	    }
	    connectedCallback() {
	        if (this.scrollAreaElement) {
	            this.scrollToPosition = validateProps.parseJSONAttribute(this.scrollToPosition);
	        }
	    }
	    componentDidLoad() {
	        this.initIntersectionObserver();
	        if (this.scrollToPosition) {
	            this.scrollToPositionHandler();
	        }
	    }
	    componentShouldUpdate(newVal, oldVal, propName) {
	        return (!(propName === 'scrollToPosition' && !scrolling.isScrollable(this.isNextHidden, this.isPrevHidden)) && // should only update if scrollable
	            validateProps.hasPropValueChanged(newVal, oldVal));
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'gradientColorScheme', 'Please use gradientColor prop instead.');
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'scrollIndicatorPosition', 'Please use alignScrollIndicator prop instead.');
	        const deprecationMap = {
	            default: 'background-base',
	            surface: 'background-surface',
	        };
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'gradientColorScheme', deprecationMap);
	        validateProps.attachComponentCss(this.host, getComponentCss, deprecationMap[this.gradientColorScheme] || this.gradientColor, this.isNextHidden, this.isPrevHidden, this.scrollIndicatorPosition || this.alignScrollIndicator, this.scrollbar, this.theme);
	        const renderPrevNextButton = (direction) => {
	            const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	            return (validateProps.h("div", { key: direction, class: direction === 'next' ? 'action-next' : 'action-prev' }, validateProps.h(PrefixedTagNames.pButton, { class: "action-button", variant: "ghost", "hide-label": "true", icon: direction === 'next' ? 'arrow-head-right' : 'arrow-head-left', type: "button", tabIndex: -1, onClick: () => this.scrollOnPrevNextClick(direction), theme: this.theme, dir: "ltr" // Otherwise icon will be flipped which doesn't make sense in this use case
	            }, direction)));
	        };
	        return (validateProps.h("div", { class: "root" }, validateProps.h("div", { class: scrolling.scrollAreaClass, ref: (el) => (this.scrollAreaElement = el) }, validateProps.h("div", { class: "scroll-wrapper", role: validateProps.parseAndGetAriaAttributes(this.aria)?.role || null, tabIndex: scrolling.isScrollable(this.isPrevHidden, this.isNextHidden) ? 0 : null }, validateProps.h("slot", null), validateProps.h("div", { class: "trigger" }), validateProps.h("div", { class: "trigger" }))), ['prev', 'next'].map(renderPrevNextButton)));
	    }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "scrollToPosition": ["scrollToPositionHandler"]
	    }; }
	};

	pScroller_cjs_entry.p_scroller = Scroller;

	
	return pScroller_cjs_entry;
}

var pSegmentedControl_2_cjs_entry = {};

var throwIfChildrenAreNotOfKind288748e4 = {};

var hasRequiredThrowIfChildrenAreNotOfKind288748e4;

function requireThrowIfChildrenAreNotOfKind288748e4 () {
	if (hasRequiredThrowIfChildrenAreNotOfKind288748e4) return throwIfChildrenAreNotOfKind288748e4;
	hasRequiredThrowIfChildrenAreNotOfKind288748e4 = 1;

	const validateProps = requireValidateProps788e2bc5();

	const updateParent = (host) => {
	    validateProps.forceUpdate(host.parentElement);
	};

	const areAllChildrenOfKind = (element, tagName) => {
	    const children = Array.from(element.children);
	    const prefixedElementTagName = validateProps.getPrefixedTagNames(element)[validateProps.paramCaseToCamelCase(tagName)];
	    return !children.some((child) => validateProps.getTagName(child) !== prefixedElementTagName);
	};

	const throwIfChildrenAreNotOfKind = (element, tagName) => {
	    if (!areAllChildrenOfKind(element, tagName)) {
	        const allowedTagName = validateProps.getPrefixedTagNames(element)[validateProps.paramCaseToCamelCase(tagName)];
	        const actualTagNames = Array.from(element.children, validateProps.getTagName)
	            .filter((actualTagName) => actualTagName !== allowedTagName)
	            .join(', ');
	        validateProps.throwException(`child HTMLElements of ${validateProps.getTagNameWithoutPrefix(element)} should be of kind ${allowedTagName} but got ${actualTagNames}.`);
	    }
	};

	throwIfChildrenAreNotOfKind288748e4.throwIfChildrenAreNotOfKind = throwIfChildrenAreNotOfKind;
	throwIfChildrenAreNotOfKind288748e4.updateParent = updateParent;

	
	return throwIfChildrenAreNotOfKind288748e4;
}

var hasRequiredPSegmentedControl_2_cjs_entry;

function requirePSegmentedControl_2_cjs_entry () {
	if (hasRequiredPSegmentedControl_2_cjs_entry) return pSegmentedControl_2_cjs_entry;
	hasRequiredPSegmentedControl_2_cjs_entry = 1;

	Object.defineProperty(pSegmentedControl_2_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed76f87eda();
	const theme = requireThemeBfc10573();
	const throwIfChildrenAreNotOfKind = requireThrowIfChildrenAreNotOfKind288748e4();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hasDocument = requireHasDocument079654e6();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const textSmallStyle = requireTextSmallStyle00e1c6e2();
	const textXSmallStyle = requireTextXSmallStyle30d03035();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const fontFamily = requireFontFamily23874d28();
	const throwIfParentIsNotOfKind = requireThrowIfParentIsNotOfKindE0807bbc();
	const getButtonBaseAriaAttributes = requireGetButtonBaseAriaAttributes84dbc1f1();
	requireHelper22e15c0e();
	requireTextShared5216bb19();
	requireFontLineHeightD4b9e1a9();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireFontSizeTextXSmallE59d35d7();
	requireIsParentOfKind4b323732();
	requireIsDisabledOrLoadingB1f56d7f();

	const throwIfPropIsUndefined = (element, propName, value) => {
	    if (value === undefined) {
	        validateProps.throwException(`the required property '${propName}' is undefined on ${validateProps.getTagNameWithoutPrefix(element)}.`);
	    }
	};

	const MIN_ITEM_WIDTH = 46;
	const MAX_ITEM_WIDTH = 220;
	const getComponentCss$1 = (maxWidth, columns) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'grid',
	                ...validateProps.addImportantToEachRule({
	                    gridAutoRows: '1fr', // for equal height
	                    ...validateProps.buildResponsiveStyles(columns, (col) => ({
	                        gridTemplateColumns: col === 'auto'
	                            ? `repeat(auto-fit, ${(maxWidth > MAX_ITEM_WIDTH && MAX_ITEM_WIDTH) || (maxWidth < MIN_ITEM_WIDTH && MIN_ITEM_WIDTH) || maxWidth}px)`
	                            : `repeat(${col}, minmax(0, 1fr))`,
	                    })),
	                    gap: '6px',
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	        },
	    });
	};

	const ITEM_PADDING = '17px';
	const { font: BUTTON_FONT } = textSmallStyle.textSmallStyle;
	const { font: LABEL_FONT } = textXSmallStyle.textXSmallStyle;
	const ICON_SIZE = '1.5rem';
	const ICON_MARGIN = '.25rem';
	const getColors = (isDisabled, isSelected, theme) => {
	    const { primaryColor, contrastMediumColor, disabledColor, contrastLowColor } = validateProps.getThemedColors(theme);
	    const { highlightColor } = validateProps.getHighContrastColors();
	    return {
	        buttonColor: isDisabled ? disabledColor : primaryColor,
	        labelColor: isDisabled ? disabledColor : contrastMediumColor,
	        borderColor: isSelected
	            ? isDisabled
	                ? disabledColor
	                : validateProps.isHighContrastMode
	                    ? highlightColor
	                    : primaryColor
	            : contrastLowColor,
	        hoverBorderColor: primaryColor,
	    };
	};
	const getItemPadding = (hasIconAndSlottedContent) => hasIconAndSlottedContent ? `13px ${ITEM_PADDING} 13px 13px` : `13px ${ITEM_PADDING}`;
	const getComponentCss = (isDisabled, isSelected, hasIcon, hasSlottedContent, theme) => {
	    const { buttonColor, labelColor, borderColor, hoverBorderColor } = getColors(isDisabled, isSelected, theme);
	    const { buttonColor: buttonColorDark, labelColor: labelColorDark, borderColor: borderColorDark, hoverBorderColor: hoverBorderColorDark, } = getColors(isDisabled, isSelected, 'dark');
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    outline: 0,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            // All width relevant styling has to be kept in sync with the tempDiv of the p-segmented-control utils
	            button: {
	                position: 'relative',
	                display: 'block',
	                height: '100%',
	                width: '100%',
	                padding: getItemPadding(hasIcon && hasSlottedContent),
	                margin: 0, // Removes default button margin on safari 15
	                border: `${validateProps.borderWidthBase} solid ${borderColor}`,
	                borderRadius: borderRadiusSmall.borderRadiusSmall,
	                background: 'transparent',
	                color: buttonColor,
	                ...textSmallStyle.textSmallStyle,
	                ...(isDisabled
	                    ? {
	                        cursor: 'not-allowed',
	                    }
	                    : {
	                        cursor: 'pointer',
	                        ...(!isSelected &&
	                            hoverMediaQuery.hoverMediaQuery({
	                                transition: validateProps.getTransition('border-color'),
	                                '&:hover': {
	                                    borderColor: hoverBorderColor,
	                                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                                        borderColor: hoverBorderColorDark,
	                                    }),
	                                },
	                            })),
	                    }),
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    borderColor: borderColorDark,
	                    color: buttonColorDark,
	                }),
	                ...validateProps.getFocusJssStyle(theme),
	            },
	            // label
	            span: {
	                display: 'block',
	                ...textXSmallStyle.textXSmallStyle,
	                overflowWrap: 'normal',
	                color: labelColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: labelColorDark,
	                }),
	            },
	        },
	        ...(hasIcon && {
	            icon: {
	                height: ICON_SIZE,
	                width: ICON_SIZE,
	                ...(hasSlottedContent && {
	                    marginInlineEnd: ICON_MARGIN,
	                }),
	            },
	        }),
	    });
	};

	const SEGMENTED_CONTROL_BACKGROUND_COLORS = ['background-surface', 'background-default']; // 'background-color' prop is deprecated
	const SEGMENTED_CONTROL_COLUMNS = ['auto', ...Array.from(new Array(25), (_, i) => i + 1)];
	// Expect Porsche Next to be available and use sans-serif (wide font for safety buffer) as fallback
	const tempFont = 'Porsche Next, sans-serif';
	// temporary dom node to measure max-width of children content
	// All width relevant styling has to be kept in sync with the button of the p-segmented-control-item
	const tempDiv = hasDocument.hasDocument ? document.createElement('div') : undefined;
	if (tempDiv) {
	    tempDiv.style.position = 'absolute';
	    tempDiv.style.visibility = 'hidden';
	    tempDiv.style.padding = `0 ${ITEM_PADDING}`; // Uses the largest possible padding of the item
	    tempDiv.style.border = `${validateProps.borderWidthBase} solid`;
	    tempDiv.style.boxSizing = 'border-box';
	    tempDiv.style.font = BUTTON_FONT.replace(fontFamily.fontFamily, tempFont);
	}
	const tempLabel = hasDocument.hasDocument ? document.createElement('div') : undefined;
	if (tempLabel) {
	    tempLabel.style.font = LABEL_FONT.replace(fontFamily.fontFamily, tempFont);
	}
	const tempIcon = hasDocument.hasDocument ? document.createElement('div') : undefined;
	if (tempIcon) {
	    tempIcon.style.display = 'inline-block';
	    tempIcon.style.width = ICON_SIZE;
	    tempIcon.style.marginRight = ICON_MARGIN;
	}
	const getItemMaxWidth = (host) => {
	    tempDiv.innerHTML = '';
	    host.shadowRoot.append(tempDiv);
	    const widths = Array.from(host.children, (item) => {
	        tempDiv.innerHTML = item.innerHTML;
	        if (item.icon || item.iconSource) {
	            tempDiv.prepend(tempIcon);
	        }
	        if (item.label) {
	            tempLabel.innerHTML = item.label;
	            tempDiv.prepend(tempLabel);
	        }
	        return Number.parseFloat(getComputedStyle(tempDiv).width);
	    });
	    tempDiv.remove();
	    return Math.max(...widths);
	};
	const syncSegmentedControlItemsProps = (host, value, disabled, theme) => {
	    for (const item of Array.from(host.children)) {
	        item.selected = item.value === value;
	        item.theme = theme;
	        item.disabledParent = disabled;
	        validateProps.forceUpdate(item);
	    }
	};

	const propTypes$1 = {
	    backgroundColor: validateProps.AllowedTypes.oneOf([
	        undefined,
	        ...SEGMENTED_CONTROL_BACKGROUND_COLORS,
	    ]),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    value: validateProps.AllowedTypes.oneOf([validateProps.AllowedTypes.string, validateProps.AllowedTypes.number]),
	    columns: validateProps.AllowedTypes.breakpoint(SEGMENTED_CONTROL_COLUMNS),
	    name: validateProps.AllowedTypes.string,
	    form: validateProps.AllowedTypes.string,
	    disabled: validateProps.AllowedTypes.boolean,
	};
	const SegmentedControl = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.segmentedControlChange = validateProps.createEvent(this, "segmentedControlChange", 3);
	        this.update = validateProps.createEvent(this, "update", 3);
	        if (hostRef.$hostElement$["s-ei"]) {
	            this.internals = hostRef.$hostElement$["s-ei"];
	        }
	        else {
	            this.internals = hostRef.$hostElement$.attachInternals?.();
	            hostRef.$hostElement$["s-ei"] = this.internals;
	        }
	        this.updateValue = (item) => {
	            this.value = item.value; // causes rerender
	            this.update.emit({ value: this.value });
	            this.segmentedControlChange.emit({ value: this.value });
	            item.focus();
	        };
	        this.backgroundColor = undefined;
	        this.theme = 'light';
	        this.value = undefined;
	        this.name = undefined;
	        this.columns = 'auto';
	        this.form = undefined;
	        this.disabled = false;
	    }
	    updateSegmentedControlItemHandler(e) {
	        e.stopPropagation();
	        if (!this.disabled) {
	            this.updateValue(e.target);
	        }
	    }
	    onValueChange() {
	        this.internals?.setFormValue(this.value.toString());
	    }
	    connectedCallback() {
	        throwIfChildrenAreNotOfKind.throwIfChildrenAreNotOfKind(this.host, 'p-segmented-control-item');
	        // child property changes to label or icon are detected via prop watchers within child
	        // here we take care of dom changes like adding/removing a child or changing its content
	        validateProps.observeChildren(this.host, () => {
	            throwIfChildrenAreNotOfKind.throwIfChildrenAreNotOfKind(this.host, 'p-segmented-control-item');
	            validateProps.forceUpdate(this.host);
	        });
	    }
	    componentWillLoad() {
	        this.defaultValue = this.value;
	    }
	    componentDidLoad() {
	        this.internals?.setFormValue(this.value?.toString());
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    disconnectedCallback() {
	        validateProps.unobserveChildren(this.host);
	    }
	    formResetCallback() {
	        this.internals?.setFormValue(this.defaultValue?.toString());
	        this.value = this.defaultValue;
	    }
	    formDisabledCallback(disabled) {
	        this.disabled = disabled;
	    }
	    formStateRestoreCallback(state) {
	        this.value = state;
	    }
	    render() {
	        validateProps.validateProps(this, propTypes$1);
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'backgroundColor');
	        validateProps.attachComponentCss(this.host, getComponentCss$1, getItemMaxWidth(this.host), this.columns);
	        syncSegmentedControlItemsProps(this.host, this.value, this.disabled, this.theme);
	        return (validateProps.h(validateProps.Host, { key: '63c6b761f59676bdd162b463fe835bad1b62f2c7', role: "group", inert: this.disabled }, validateProps.h("slot", { key: '4df8cea273579b170f4bf60cad64ec5e887bb8ee' })));
	    }
	    static get formAssociated() { return true; }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "value": ["onValueChange"]
	    }; }
	};

	// ARIA for `aria` prop
	const SEGMENTED_CONTROL_ITEM_ARIA_ATTRIBUTES = ['aria-label'];
	const getSegmentedControlItemAriaAttributes = (isSelected, isDisabled, ariaProp) => ({
	    ...getButtonBaseAriaAttributes.getButtonBaseAriaAttributes(isDisabled, false),
	    ...validateProps.parseAndGetAriaAttributes({ 'aria-pressed': isSelected }),
	    ...validateProps.parseAndGetAriaAttributes(ariaProp),
	});
	const getIconColor = (isDisabled) => {
	    return isDisabled ? 'contrast-medium' : 'primary';
	};

	const propTypes = {
	    value: validateProps.AllowedTypes.oneOf([validateProps.AllowedTypes.string, validateProps.AllowedTypes.number]),
	    disabled: validateProps.AllowedTypes.boolean,
	    label: validateProps.AllowedTypes.string,
	    icon: validateProps.AllowedTypes.string,
	    iconSource: validateProps.AllowedTypes.string,
	    aria: validateProps.AllowedTypes.aria(SEGMENTED_CONTROL_ITEM_ARIA_ATTRIBUTES),
	};
	const SegmentedControlItem = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.onClick = () => {
	            if (!this.disabled && !this.host.selected) {
	                this.host.dispatchEvent(new CustomEvent('internalSegmentedControlItemUpdate', {
	                    bubbles: true,
	                }));
	            }
	        };
	        this.value = undefined;
	        this.disabled = false;
	        this.label = undefined;
	        this.icon = undefined;
	        this.iconSource = undefined;
	        this.aria = undefined;
	    }
	    handleLabelChange() {
	        // when these props change, we inform the parent to recalculate the max width for all items
	        throwIfChildrenAreNotOfKind.updateParent(this.host);
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    connectedCallback() {
	        throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-segmented-control');
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        // this additional validation is still needed because undefined is allowed with current propTypes
	        throwIfPropIsUndefined(this.host, 'value', this.value);
	        const hasIcon = !!this.icon || !!this.iconSource;
	        const hasSlottedContent = !!this.host.innerHTML;
	        const isDisabled = this.disabled || this.host.disabledParent;
	        validateProps.attachComponentCss(this.host, getComponentCss, isDisabled, this.host.selected, hasIcon, hasSlottedContent, this.host.theme || 'light' // default as fallback
	        );
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(validateProps.Host, { key: 'f57f4ae102964b79462df0a88ffc63978bcfd301', onClick: !isDisabled && this.onClick }, validateProps.h("button", { key: '969755e88991835f7c9427a9ca96fd1991993a11', type: "button", ...getSegmentedControlItemAriaAttributes(this.host.selected, this.disabled, this.aria) }, this.label && validateProps.h("span", { key: 'b570718212fef076a28628044aa8606613104a00' }, this.label), hasIcon && (validateProps.h(PrefixedTagNames.pIcon, { key: '0afbdea1b301f6617bd78c8aff760000795a9b90', class: "icon", size: "inherit", name: this.icon, source: this.iconSource, color: getIconColor(this.disabled), theme: this.host.theme || 'light', "aria-hidden": "true" })), validateProps.h("slot", { key: '64490c40529ff4fbf8ffdeac9d5cc357781634f6' }))));
	    }
	    static get delegatesFocus() { return true; }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "label": ["handleLabelChange"],
	        "icon": ["handleLabelChange"],
	        "iconSource": ["handleLabelChange"]
	    }; }
	};

	pSegmentedControl_2_cjs_entry.p_segmented_control = SegmentedControl;
	pSegmentedControl_2_cjs_entry.p_segmented_control_item = SegmentedControlItem;

	
	return pSegmentedControl_2_cjs_entry;
}

var pSelect_2_cjs_entry = {};

var hasRequiredPSelect_2_cjs_entry;

function requirePSelect_2_cjs_entry () {
	if (hasRequiredPSelect_2_cjs_entry) return pSelect_2_cjs_entry;
	hasRequiredPSelect_2_cjs_entry = 1;

	Object.defineProperty(pSelect_2_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const isClickOutside = requireIsClickOutside050dc86b();
	const isElementOfKind = requireIsElementOfKindF7da6ac6();
	const popover = requirePopover8518c8b1();
	const stateMessageStyles = requireStateMessageStylesD1c4637f();
	const selectDropdown = requireSelectDropdownD9989ebd();
	const theme = requireThemeBfc10573();
	const throwIfElementIsNotOfKind = requireThrowIfElementIsNotOfKindAb86026b();
	const slottedAnchorStyles = requireSlottedAnchorStylesFe1a10c2();
	const labelStyles = requireLabelStylesD5916d0e();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const formStyles = requireFormStylesDeecb9a1();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const fontLineHeight = requireFontLineHeightD4b9e1a9();
	const textSmallStyle = requireTextSmallStyle00e1c6e2();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const throwIfParentIsNotOfKind = requireThrowIfParentIsNotOfKindE0807bbc();
	requireFontSizeTextSmall508930e5();
	requireFontFamily23874d28();
	requireSpacingStaticSmall2130ed04();
	requireBorderRadiusMedium758b9411();
	requireHasNamedSlot273cd3ae();
	requireGetNamedSlot223c478a();
	requireGetClosestHTMLElement83d01a84();
	requireHasDescription050833e0();
	requireIsParentOfKind4b323732();
	requireFontSizeTextXSmallE59d35d7();
	requireSpacingStaticMedium94812711();
	requireTextShared5216bb19();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();

	// The amount of time in ms after the last key press before the searchString will get cleared
	const SELECT_SEARCH_TIMEOUT = 500;
	// The amount of options to be jumped when performing a page-based navigation using PageUp or PageDown.
	const PAGE_UP_DOWN_STEP_AMOUNT = 10;
	/**
	 * Handles scrolling within the list to ensure that the highlighted item is always visible.
	 * @param {HTMLElement} scrollElement - The HTML element to be scrolled.
	 * @param {HTMLElement} element - The element to scroll to.
	 * @returns {void}
	 */
	const handleSelectDropdownScroll = (scrollElement, element) => {
	    const { maxHeight } = getComputedStyle(scrollElement);
	    const hostElementHeight = Number.parseInt(maxHeight, 10);
	    // TODO: If dropdown was closed this might get called too early before the list is opened which causes the scrollHeight to be 0
	    if (scrollElement.scrollHeight > hostElementHeight) {
	        element.scrollIntoView({
	            block: 'nearest',
	            // behavior: 'smooth' // Intentionally not smooth since highlighted options can quickly change when searching
	        });
	    }
	};
	/**
	 * Determines the action to be taken based on a keyboard event and the state of the select menu.
	 *
	 * @param {KeyboardEvent} event - The keyboard event triggering the action.
	 * @param {boolean} menuOpen - A boolean indicating whether the select menu is open or closed.
	 * @returns {SelectAction} - The corresponding action to be performed.
	 */
	const getActionFromKeyboardEvent = (event, menuOpen) => {
	    const { key, altKey, ctrlKey, metaKey } = event;
	    const openKeys = ['ArrowDown', 'ArrowUp', 'Enter', ' ']; // all keys that will do the default open action
	    // handle opening when closed
	    if (!menuOpen && openKeys.includes(key)) {
	        return 'Open';
	    }
	    // home and end move the selected option when open or closed
	    if (key === 'Home') {
	        return 'First';
	    }
	    if (key === 'End') {
	        return 'Last';
	    }
	    // handle typing characters when open or closed
	    if (key === 'Backspace' || key === 'Clear' || (key.length === 1 && key !== ' ' && !altKey && !ctrlKey && !metaKey)) {
	        return 'Type';
	    }
	    // handle keys when open
	    if (menuOpen) {
	        if (key === 'ArrowUp' && altKey) {
	            return 'CloseSelect';
	        }
	        if (key === 'ArrowDown' && !altKey) {
	            return 'Next';
	        }
	        if (key === 'ArrowUp') {
	            return 'Previous';
	        }
	        if (key === 'PageUp') {
	            return 'PageUp';
	        }
	        if (key === 'PageDown') {
	            return 'PageDown';
	        }
	        if (key === 'Escape') {
	            return 'Close';
	        }
	        if (key === 'Enter' || key === ' ' || key === 'Tab') {
	            return 'CloseSelect';
	        }
	    }
	    return undefined;
	};
	/**
	 * Gets the updated index based on the current index, maximum index, and the select action.
	 *
	 * @param {number} currentIndex - The current index in the list of options.
	 * @param {number} maxIndex - The maximum index in the list of options.
	 * @param {SelectAction} action - The select action indicating how to update the index.
	 * @returns {number} - The updated index after applying the specified action.
	 */
	const getUpdatedIndex = (currentIndex, maxIndex, action) => {
	    switch (action) {
	        case 'First':
	            return 0;
	        case 'Last':
	            return maxIndex;
	        case 'Previous':
	            return Math.max(0, currentIndex - 1);
	        case 'Next':
	            return Math.min(maxIndex, currentIndex + 1);
	        case 'PageUp':
	            return Math.max(0, currentIndex - PAGE_UP_DOWN_STEP_AMOUNT);
	        case 'PageDown':
	            return Math.min(maxIndex, currentIndex + PAGE_UP_DOWN_STEP_AMOUNT);
	        default:
	            return currentIndex;
	    }
	};
	/**
	 * Sets the next option in a select dropdown as highlighted, updating the visual state and handling scrolling.
	 *
	 * @template T - The type of options in the dropdown.
	 * @param {HTMLElement} listElement - The parent element containing the dropdown options.
	 * @param {T[]} options - The array of options in the dropdown.
	 * @param {number} newIndex - The index of the option to be highlighted.
	 * @returns {void}
	 */
	const setNextSelectOptionHighlighted = (listElement, options, newIndex) => {
	    const oldIndex = getHighlightedSelectOptionIndex(options);
	    const usableOptions = getUsableSelectOptions(options);
	    if (oldIndex !== -1) {
	        setHighlightedSelectOption(usableOptions[oldIndex], false);
	    }
	    setHighlightedSelectOption(usableOptions[newIndex], true);
	    handleSelectDropdownScroll(listElement, usableOptions[newIndex]);
	};
	/**
	 * Filters an array of select options to include only those that are usable (not hidden or disabled).
	 *
	 * @template T - The type of options in the array.
	 * @param {T[]} options - The array of select options to filter.
	 * @returns {T[]} - An array of usable select options.
	 */
	const getUsableSelectOptions = (options) => options.filter((option) => !option.hidden && !option.disabled);
	/**
	 * Filters an array of select options based on a filter string, considering visibility and usability.
	 *
	 * @template T - The type of options in the array.
	 * @param {T[]} options - The array of select options to filter.
	 * @param {string} filter - The filter string to match against option text content.
	 * @returns {T[]} - An array of filtered and usable select options.
	 */
	const filterSelectOptions = (options, filter) => getUsableSelectOptions(options).filter((option) => option.textContent.trim().toLowerCase().indexOf(filter.toLowerCase()) === 0);
	/**
	 * Determines the index of the next matching select option based on a filter string.
	 *
	 * @template T - The type of options in the array.
	 * @param {T[]} options - The array of select options to search.
	 * @param {string} filter - The filter string to match against option text content.
	 * @returns {number} - The index of the next matching select option, or -1 if none is found.
	 */
	const getMatchingSelectOptionIndex = (options, filter) => {
	    const usableOptions = getUsableSelectOptions(options);
	    const startIndex = getHighlightedSelectOptionIndex(options) + 1;
	    // Shift already searched options to the end of the array in order to find the next matching option
	    const orderedOptions = [...usableOptions.slice(startIndex), ...usableOptions.slice(0, startIndex)];
	    const firstMatch = filterSelectOptions(orderedOptions, filter)[0];
	    const allSameLetter = (str) => str.split('').every((letter) => letter === str[0]);
	    // first check if there is an exact match for the typed string
	    if (firstMatch) {
	        return usableOptions.indexOf(firstMatch);
	    }
	    // if the same letter is being repeated, cycle through first-letter matches
	    if (allSameLetter(filter)) {
	        const matches = filterSelectOptions(orderedOptions, filter[0]);
	        return usableOptions.indexOf(matches[0]);
	    }
	    // No matching option found
	    return -1;
	};
	/**
	 * Sets the highlighted state of a select option and triggers an update.
	 *
	 * @template T - The type of the select option.
	 * @param {T} option - The select option to set the highlighted state for.
	 * @param {boolean} highlighted - The new highlighted state.
	 * @returns {void}
	 */
	const setHighlightedSelectOption = (option, highlighted) => {
	    option.highlighted = highlighted;
	    validateProps.forceUpdate(option);
	};
	/**
	 * Gets the index of the currently highlighted select option.
	 *
	 * @template T - The type of options in the array.
	 * @param {T[]} options - The array of select options.
	 * @returns {number} - The index of the highlighted select option, or -1 if none is highlighted.
	 */
	const getHighlightedSelectOptionIndex = (options) => getUsableSelectOptions(options).indexOf(getHighlightedSelectOption(options));
	/**
	 * Gets the currently highlighted select option.
	 *
	 * @template T - The type of options in the array.
	 * @param {T[]} options - The array of select options.
	 * @returns {T} - The currently highlighted select option, or undefined if none is highlighted.
	 */
	const getHighlightedSelectOption = (options) => options.find((option) => option.highlighted);

	const getButtonJssStyle = (componentName, isOpen, isDisabled, state, hasSlottedImage, cssVarScaling, theme) => {
	    const cssVarBackgroundColor = `--p-${componentName}-background-color`;
	    const cssVarTextColor = `--p-${componentName}-text-color`;
	    const cssVarBorderColor = `--p-${componentName}-border-color`;
	    const { backgroundColor, primaryColor, disabledColor, contrastMediumColor } = validateProps.getThemedColors(theme);
	    const { backgroundColor: backgroundColorDark, primaryColor: primaryColorDark, disabledColor: disabledColorDark, contrastMediumColor: contrastMediumColorDark, } = validateProps.getThemedColors('dark');
	    const { formStateColor, formStateHoverColor } = stateMessageStyles.getThemedFormStateColors(theme, state);
	    const { formStateColor: formStateColorDark, formStateHoverColor: formStateHoverColorDark } = stateMessageStyles.getThemedFormStateColors('dark', state);
	    return {
	        all: 'unset',
	        display: 'grid',
	        gridTemplateColumns: `${hasSlottedImage ? 'auto ' : ''}minmax(0, 1fr) auto`,
	        alignItems: 'center',
	        gap: `max(4px, ${cssVarScaling} * 12px)`,
	        padding: `max(2px, ${cssVarScaling} * ${formStyles.formElementPaddingVertical}) max(4px, ${cssVarScaling} * ${formStyles.formElementPaddingHorizontal})`,
	        minWidth: 0,
	        height: `max(${fontLineHeight.fontLineHeight}, ${cssVarScaling} * (${fontLineHeight.fontLineHeight} + 10px))`,
	        boxSizing: 'content-box', // ensures height calculation is based on content, not including padding
	        font: textSmallStyle.textSmallStyle.font,
	        cursor: 'pointer',
	        transition: `${validateProps.getTransition('background-color')}, ${validateProps.getTransition('border-color')}, ${validateProps.getTransition('color')}`, // for smooth transitions between e.g. disabled states
	        color: `var(${cssVarTextColor}, ${primaryColor})`,
	        background: `var(${cssVarBackgroundColor}, ${backgroundColor})`,
	        border: `${validateProps.borderWidthBase} solid var(${cssVarBorderColor}, ${isOpen ? primaryColor : formStateColor || contrastMediumColor})`,
	        borderRadius: borderRadiusSmall.borderRadiusSmall,
	        ...(isDisabled && {
	            cursor: 'not-allowed',
	            color: disabledColor,
	            borderColor: disabledColor,
	        }),
	        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	            color: `var(${cssVarTextColor}, ${primaryColorDark})`,
	            background: `var(${cssVarBackgroundColor}, ${backgroundColorDark})`,
	            border: `${validateProps.borderWidthBase} solid var(${cssVarBorderColor}, ${isOpen ? primaryColorDark : formStateColorDark || contrastMediumColorDark})`,
	            ...(isDisabled && {
	                color: disabledColorDark,
	                borderColor: disabledColorDark,
	            }),
	        }),
	        ...(!isDisabled && {
	            ...hoverMediaQuery.hoverMediaQuery({
	                '&:hover,label:hover~&': {
	                    borderColor: `var(${cssVarBorderColor}, ${isOpen ? primaryColor : formStateHoverColor || primaryColor})`,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        borderColor: `var(${cssVarBorderColor}, ${isOpen ? primaryColorDark : formStateHoverColorDark || primaryColorDark})`,
	                    }),
	                },
	            }),
	            ...validateProps.getFocusJssStyle(theme),
	        }),
	    };
	};

	const getButtonLabelJssStyle = {
	    overflow: 'hidden',
	    textOverflow: 'ellipsis',
	    whiteSpace: 'nowrap',
	};

	const getIconJssStyle = (componentName, isOpen) => {
	    const cssVarIconFilter = `--p-${componentName}-icon-filter`;
	    return {
	        marginInlineEnd: '-3px', // to temporarily align with multi-select and select-wrapper
	        pointerEvents: 'none',
	        transform: `rotate3d(0,0,1,${isOpen ? '180' : '0.0001'}deg)`, // needs to be a little more than 0 for correct direction in safari
	        transition: validateProps.getTransition('transform'),
	        ...(!validateProps.isHighContrastMode && {
	            filter: `var(${cssVarIconFilter})`,
	        }),
	    };
	};

	// TODO: share between select & multi-select
	const syncSelectChildrenProps = (children, theme) => {
	    for (const child of children.filter((child) => child.theme !== theme)) {
	        child.theme = theme;
	        validateProps.forceUpdate(child);
	    }
	};
	const getSelectedOptionString = (options) => options.find((option) => option.selected)?.textContent ?? '';
	const resetSelectedOption = (options) => {
	    const currentSelectedOption = options.find((option) => option.selected);
	    if (currentSelectedOption) {
	        currentSelectedOption.selected = false;
	        validateProps.forceUpdate(currentSelectedOption);
	    }
	};
	const updateSelectOptions = (options, value) => {
	    resetSelectedOption(options);
	    if (value === undefined) {
	        // Option without value for empty selection
	        const optionToSelect = options.find((option) => option.value === undefined);
	        if (optionToSelect) {
	            optionToSelect.selected = true;
	            validateProps.forceUpdate(optionToSelect);
	        }
	    }
	    else {
	        // TODO: Do we want to cover multiple options with the same value?
	        const optionToSelect = options.find((option) => option.value === value);
	        if (optionToSelect) {
	            optionToSelect.selected = true;
	            validateProps.forceUpdate(optionToSelect);
	        }
	        else {
	            // TODO: Add select node
	            validateProps.consoleWarn('The provided value is not included in the options of the p-select:', value);
	        }
	    }
	};
	const setSelectedOption = (options, selectedOption) => {
	    resetSelectedOption(options);
	    selectedOption.selected = true;
	    validateProps.forceUpdate(selectedOption);
	};
	const getSrHighlightedOptionText = (options) => {
	    const highlightedOptionIndex = getHighlightedSelectOptionIndex(options);
	    const highlightedOption = getUsableSelectOptions(options)[highlightedOptionIndex];
	    return (highlightedOption &&
	        `${highlightedOption.textContent || 'Empty option'}${highlightedOption.selected ? ', selected' : ' not selected'} (${highlightedOptionIndex + 1} of ${options.length})`);
	};

	const cssVarInternalSelectScaling = '--p-internal-select-scaling';
	const getComponentCss$1 = (isOpen, isDisabled, hideLabel, state, compact, theme, hasSlottedImage) => {
	    const scalingVar = `var(${cssVarInternalSelectScaling}, ${compact ? 0.5 : 1})`;
	    return validateProps.getCss({
	        '@global': {
	            // @keyframes fade-in
	            ...popover.getPopoverKeyframesStyles,
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            '::slotted(*)': validateProps.addImportantToEachRule({
	                '--p-internal-select-option-scaling': scalingVar,
	                '--p-internal-optgroup-scaling': scalingVar,
	            }),
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            button: {
	                ...getButtonJssStyle('select', isOpen, isDisabled, state, hasSlottedImage, scalingVar, theme),
	                '& img': popover.getButtonImageJssStyle,
	                '& span': getButtonLabelJssStyle,
	            },
	            '[popover]': popover.getPopoverJssStyle(isOpen, scalingVar, 40, theme),
	        },
	        root: {
	            display: 'grid',
	            gap: `max(2px, ${scalingVar} * ${spacingStaticXSmall.spacingStaticXSmall})`,
	            // min width is needed for showing at least 1 character in very narrow containers. The "1rem" value is the minimum safe zone to show at least 1 character plus the ellipsis dots.
	            minWidth: `calc(1rem + ${formStyles.formElementPaddingHorizontal} + ${validateProps.borderWidthBase} * 2 + ${formStyles.getCalculatedFormElementPaddingHorizontal(1)})`,
	        },
	        icon: getIconJssStyle('select', isOpen),
	        'sr-only': validateProps.getHiddenTextJssStyle(),
	        // .label / .required
	        ...labelStyles.getFunctionalComponentLabelStyles(isDisabled, hideLabel, theme),
	        // .message
	        ...stateMessageStyles.getFunctionalComponentStateMessageStyles(theme, state),
	    });
	};

	const propTypes$1 = {
	    label: validateProps.AllowedTypes.string,
	    description: validateProps.AllowedTypes.string,
	    name: validateProps.AllowedTypes.string,
	    value: validateProps.AllowedTypes.string,
	    state: validateProps.AllowedTypes.oneOf(stateMessageStyles.FORM_STATES),
	    message: validateProps.AllowedTypes.string,
	    hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	    disabled: validateProps.AllowedTypes.boolean,
	    required: validateProps.AllowedTypes.boolean,
	    form: validateProps.AllowedTypes.string,
	    dropdownDirection: validateProps.AllowedTypes.oneOf(selectDropdown.SELECT_DROPDOWN_DIRECTIONS),
	    compact: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Select = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.update = validateProps.createEvent(this, "update", 3);
	        if (hostRef.$hostElement$["s-ei"]) {
	            this.internals = hostRef.$hostElement$["s-ei"];
	        }
	        else {
	            this.internals = hostRef.$hostElement$.attachInternals?.();
	            hostRef.$hostElement$["s-ei"] = this.internals;
	        }
	        this.selectOptions = [];
	        this.selectOptgroups = [];
	        this.preventOptionUpdate = false; // Used to prevent value watcher from updating options when options are already updated
	        this.searchString = '';
	        this.searchTimeout = null;
	        this.slottedImagePath = '';
	        this.hasNativePopoverSupport = validateProps.getHasNativePopoverSupport();
	        this.onSlotchange = () => {
	            this.updateOptions();
	            updateSelectOptions(this.selectOptions, this.value);
	            this.slottedImagePath = this.getSelectedOptionImagePath(this.selectOptions);
	            // Necessary to update selected options in placeholder
	            validateProps.forceUpdate(this.host);
	        };
	        this.onComboClick = () => {
	            this.updateMenuState(!this.isOpen);
	        };
	        this.onClickOutside = (e) => {
	            if (this.isOpen && isClickOutside.isClickOutside(e, this.buttonElement) && isClickOutside.isClickOutside(e, this.popoverElement)) {
	                this.isOpen = false;
	            }
	        };
	        this.onComboKeyDown = (event) => {
	            const { key } = event;
	            const action = getActionFromKeyboardEvent(event, this.isOpen);
	            switch (action) {
	                case 'Last':
	                case 'First':
	                    // biome-ignore lint/suspicious/noFallthroughSwitchClause: intentional fallthrough
	                    this.updateMenuState(true);
	                // intentional fallthrough
	                case 'Next':
	                case 'Previous':
	                case 'PageUp':
	                case 'PageDown': {
	                    event.preventDefault();
	                    setNextSelectOptionHighlighted(this.popoverElement, this.selectOptions, getUpdatedIndex(getHighlightedSelectOptionIndex(this.selectOptions), getUsableSelectOptions(this.selectOptions).length - 1, action));
	                    this.updateSrHighlightedOptionText();
	                    break;
	                }
	                case 'CloseSelect': {
	                    // biome-ignore lint/suspicious/noFallthroughSwitchClause: intentional fallthrough
	                    event.preventDefault();
	                    this.updateSelectedOption(getHighlightedSelectOption(this.selectOptions));
	                }
	                // intentional fallthrough
	                case 'Close': {
	                    event.preventDefault();
	                    this.updateMenuState(false);
	                    break;
	                }
	                case 'Type':
	                    this.onComboType(key);
	                    break;
	                case 'Open': {
	                    event.preventDefault();
	                    this.updateMenuState(true);
	                    break;
	                }
	            }
	        };
	        this.onComboType = (letter) => {
	            this.updateMenuState(true);
	            this.updateSearchString(letter);
	            const matchingIndex = getMatchingSelectOptionIndex(this.selectOptions, this.searchString);
	            if (matchingIndex !== -1) {
	                setNextSelectOptionHighlighted(this.popoverElement, this.selectOptions, matchingIndex);
	                this.updateSrHighlightedOptionText();
	            }
	            else {
	                window.clearTimeout(this.searchTimeout);
	                this.searchString = '';
	            }
	        };
	        this.updateOptions = () => {
	            this.selectOptions = [];
	            this.selectOptgroups = [];
	            for (const child of Array.from(this.host.children).filter((el) => el.tagName !== 'SELECT' && el.slot !== 'label' && el.slot !== 'description' && el.slot !== 'message')) {
	                throwIfElementIsNotOfKind.throwIfElementIsNotOfKind(this.host, child, ['p-select-option', 'p-optgroup']);
	                if (isElementOfKind.isElementOfKind(child, 'p-select-option')) {
	                    this.selectOptions.push(child);
	                }
	                else if (isElementOfKind.isElementOfKind(child, 'p-optgroup')) {
	                    this.selectOptgroups.push(child);
	                    for (const optGroupChild of Array.from(child.children)) {
	                        throwIfElementIsNotOfKind.throwIfElementIsNotOfKind(child, optGroupChild, 'p-select-option');
	                        this.selectOptions.push(optGroupChild);
	                    }
	                }
	            }
	        };
	        this.updateMenuState = (open) => {
	            if (this.isOpen === open) {
	                return;
	            }
	            this.isOpen = open;
	        };
	        this.updateSelectedOption = (selectedOption) => {
	            // option can be undefined when no option is highlighted and keyboard action calls this
	            if (selectedOption) {
	                this.preventOptionUpdate = true; // Avoid unnecessary updating of options in value watcher
	                setSelectedOption(this.selectOptions, selectedOption);
	                this.value = selectedOption.value;
	                this.emitUpdateEvent();
	                this.updateSrHighlightedOptionText();
	            }
	            this.updateMenuState(false);
	            this.buttonElement.focus();
	        };
	        this.updateSearchString = (char) => {
	            // reset typing timeout and start new timeout
	            // this allows us to make multiple-letter matches, like a native select
	            if (this.searchTimeout) {
	                window.clearTimeout(this.searchTimeout);
	            }
	            this.searchTimeout = window.setTimeout(() => {
	                this.searchString = '';
	            }, SELECT_SEARCH_TIMEOUT);
	            // add most recent letter to saved search string
	            this.searchString += char;
	        };
	        this.updateSrHighlightedOptionText = () => {
	            this.srHighlightedOptionText = getSrHighlightedOptionText(this.selectOptions);
	        };
	        this.emitUpdateEvent = () => {
	            this.update.emit({
	                value: this.value,
	                name: this.name,
	            });
	        };
	        this.getSelectedOptionImagePath = (options) => {
	            return (options
	                .find((option) => option.selected)
	                ?.querySelector('img')
	                ?.getAttribute('src') ?? '');
	        };
	        this.label = '';
	        this.description = '';
	        this.name = undefined;
	        this.value = undefined;
	        this.state = 'none';
	        this.message = '';
	        this.hideLabel = false;
	        this.disabled = false;
	        this.required = false;
	        this.dropdownDirection = 'auto';
	        this.compact = false;
	        this.theme = 'light';
	        this.form = undefined;
	        this.isOpen = false;
	        this.srHighlightedOptionText = '';
	    }
	    updateOptionHandler(e) {
	        e.stopPropagation();
	        this.updateSelectedOption(e.target);
	    }
	    onValueChange() {
	        this.internals?.setFormValue(this.value);
	        // When setting initial value the watcher gets called before the options are defined
	        if (this.selectOptions.length > 0) {
	            if (!this.preventOptionUpdate) {
	                updateSelectOptions(this.selectOptions, this.value);
	            }
	            this.slottedImagePath = this.getSelectedOptionImagePath(this.selectOptions);
	            this.preventOptionUpdate = false;
	        }
	    }
	    onIsOpenChange() {
	        if (this.isOpen) {
	            if (this.hasNativePopoverSupport) {
	                this.popoverElement.showPopover();
	            }
	            if (typeof this.cleanUpAutoUpdate === 'undefined') {
	                // ensures floating ui event listeners are added when options list is opened
	                this.cleanUpAutoUpdate = isClickOutside.autoUpdate(this.buttonElement, this.popoverElement, async () => {
	                    await popover.optionListUpdatePosition(this.dropdownDirection, this.buttonElement, this.popoverElement);
	                });
	            }
	        }
	        else {
	            if (this.hasNativePopoverSupport) {
	                this.popoverElement.hidePopover();
	            }
	            if (typeof this.cleanUpAutoUpdate === 'function') {
	                // ensures floating ui event listeners are removed when options list is closed
	                this.cleanUpAutoUpdate();
	                this.cleanUpAutoUpdate = undefined;
	            }
	        }
	    }
	    connectedCallback() {
	        validateProps.applyConstructableStylesheetStyles(this.host, slottedAnchorStyles.getSlottedAnchorStyles);
	        document.addEventListener('mousedown', this.onClickOutside, true);
	    }
	    disconnectedCallback() {
	        document.removeEventListener('mousedown', this.onClickOutside, true);
	        if (typeof this.cleanUpAutoUpdate === 'function') {
	            // ensures floating ui event listeners are removed in case popover is removed from DOM
	            this.cleanUpAutoUpdate();
	        }
	    }
	    componentWillLoad() {
	        this.defaultValue = this.value;
	        this.internals?.setFormValue(this.value);
	        this.updateOptions();
	        updateSelectOptions(this.selectOptions, this.value);
	        this.slottedImagePath = this.getSelectedOptionImagePath(this.selectOptions);
	    }
	    componentDidLoad() {
	        validateProps.getShadowRootHTMLElement(this.host, 'slot').addEventListener('slotchange', this.onSlotchange);
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    formDisabledCallback(disabled) {
	        this.disabled = disabled;
	    }
	    formStateRestoreCallback(state) {
	        this.value = state;
	    }
	    formResetCallback() {
	        this.internals?.setFormValue(this.defaultValue);
	        this.value = this.defaultValue;
	    }
	    render() {
	        validateProps.validateProps(this, propTypes$1);
	        validateProps.attachComponentCss(this.host, getComponentCss$1, this.isOpen, this.disabled, this.hideLabel, this.state, this.compact, this.theme, !!this.slottedImagePath);
	        syncSelectChildrenProps([...this.selectOptions, ...this.selectOptgroups], this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        const buttonId = 'value';
	        const popoverId = 'list';
	        const descriptionId = this.description ? 'description' : undefined;
	        const selectMessageId = stateMessageStyles.hasMessage(this.host, this.message, this.state) ? stateMessageStyles.messageId : undefined;
	        const initialStatusId = 'initial-status';
	        const ariaDescribedBy = [descriptionId, selectMessageId, initialStatusId].filter(Boolean).join(' ');
	        const selectedOption = getSelectedOptionString(this.selectOptions);
	        return (validateProps.h("div", { key: '33aa8b4fefe5aa9a9b05ad5da76d1e7ee182394d', class: "root" }, validateProps.h(labelStyles.Label, { key: '3e9e2f79bf6e649cad61e2025855d607d20ff21d', host: this.host, label: this.label, description: this.description, htmlFor: buttonId, isRequired: this.required, isDisabled: this.disabled }), validateProps.h("span", { key: '9203752dcc3230c89c40996adf12a7ad41c48325', class: "sr-only", id: initialStatusId }, `${selectedOption ? '' : 'No option selected. '} ${this.selectOptions.length} options in total.`), validateProps.h("button", { key: '6a77b552fa6b4bb7e3838389304116ac65de30b3', "aria-invalid": this.state === 'error' ? 'true' : null, type: "button", role: "combobox", id: buttonId, ...popover.getComboboxAriaAttributes(this.isOpen, this.required, labelStyles.labelId, ariaDescribedBy, popoverId), disabled: this.disabled, onClick: this.onComboClick, onKeyDown: this.onComboKeyDown, ref: (el) => (this.buttonElement = el) }, this.slottedImagePath && validateProps.h("img", { key: '97d1c99d0578554629de1be2ee665ae94a10ed5e', src: this.slottedImagePath, alt: "" }), validateProps.h("span", { key: '08fd2dee1ef3b9be093c83d5c6ef72341f10cd24' }, selectedOption), validateProps.h(PrefixedTagNames.pIcon, { key: 'bc520e45484cfabc0dd6c3100dbfdb2da656ce69', class: "icon", name: "arrow-head-down", theme: this.theme, color: this.disabled ? 'state-disabled' : 'primary', "aria-hidden": "true" })), validateProps.h("div", { key: 'b699b24f4e9677476ff59fc2b5c5804666051a83', id: popoverId, popover: "manual", tabIndex: -1, ...popover.getListAriaAttributes(this.label, this.required, false, this.isOpen), ref: (el) => (this.popoverElement = el) }, validateProps.h("slot", { key: 'ffb61531b6f82c5a2e4da55c4d0d8fc3ca2b929b' })), validateProps.h(stateMessageStyles.StateMessage, { key: 'fb00fb2c2153cb5034fdb970f18fce9d43b19f56', state: this.state, message: this.message, theme: this.theme, host: this.host }), validateProps.h("span", { key: '37f3b6390adfcccf235ab0aa72a959d416805cd2', class: "sr-only", role: "status", "aria-live": "assertive", "aria-relevant": "additions text" }, this.srHighlightedOptionText)));
	    }
	    static get delegatesFocus() { return true; }
	    static get formAssociated() { return true; }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "value": ["onValueChange"],
	        "isOpen": ["onIsOpenChange"]
	    }; }
	};

	// TODO: Partially copied from getOnlyChildrenOfKindHTMLElementOrThrow, maybe change getOnlyChildrenOfKindHTMLElementOrThrow to make it usable here
	const validateSelectOption = (slot, host) => {
	    const directChildren = slot.assignedNodes();
	    const notValid = directChildren.some((child) => {
	        return !((child.nodeType === Node.ELEMENT_NODE && child.tagName.toLowerCase() === 'img') ||
	            child.nodeType === Node.TEXT_NODE);
	    });
	    if (notValid) {
	        validateProps.consoleError(`child HTMLElements of ${validateProps.getTagNameWithoutPrefix(host)} are invalid. Expected all of: #text or <img />.`, host);
	    }
	};

	const cssVarInternalSelectOptionScaling = '--p-internal-select-option-scaling';
	const getComponentCss = (theme) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	            },
	            ...validateProps.addImportantToEachRule({
	                ':host': {
	                    scrollMargin: '6px', // Aligns option when list is scrolled by navigating with keyboard
	                    ...colorSchemeStyles.hostHiddenStyles,
	                },
	                '::slotted(img)': popover.getButtonImageJssStyle,
	            }),
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	        },
	        option: popover.getOptionJssStyle('select-option', `var(${cssVarInternalSelectOptionScaling}, 1)`, theme),
	        icon: {
	            marginInlineStart: 'auto',
	        },
	    });
	};

	const propTypes = {
	    value: validateProps.AllowedTypes.string,
	    disabled: validateProps.AllowedTypes.boolean,
	};
	const SelectOption = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.onClick = () => {
	            this.host.dispatchEvent(new CustomEvent('internalOptionUpdate', {
	                bubbles: true,
	            }));
	        };
	        this.onSlotChange = (e) => {
	            validateSelectOption(e.target, this.host);
	        };
	        this.value = undefined;
	        this.disabled = false;
	    }
	    connectedCallback() {
	        throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, ['p-select', 'p-optgroup']);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        const { theme = 'light', selected, highlighted, hidden } = this.host;
	        validateProps.attachComponentCss(this.host, getComponentCss, theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        const isDisabled = this.disabled || this.host.disabledParent;
	        return (validateProps.h(validateProps.Host, { key: 'e8017087c9b9cb8481aeb81554aefaf1df66508d', onClick: !isDisabled && this.onClick }, validateProps.h("div", { key: 'b26cb134262c71cfc8d57668c75e99d7aa23dc8e', role: "option", class: {
	                option: true,
	                'option--selected': selected,
	                'option--highlighted': highlighted,
	                'option--disabled': isDisabled,
	            }, ...popover.getOptionAriaAttributes(selected, isDisabled, hidden, !!this.value) }, validateProps.h("slot", { key: '9c47c9a8df8f398b737449a6d3c1899cac14d951', onSlotchange: this.onSlotChange }), selected && (validateProps.h(PrefixedTagNames.pIcon, { key: '3275169b38e528cb6b576de15f9f5e53e8044ba8', class: "icon", "aria-hidden": "true", name: "check", color: isDisabled ? 'state-disabled' : 'primary', theme: theme })))));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pSelect_2_cjs_entry.p_select = Select;
	pSelect_2_cjs_entry.p_select_option = SelectOption;

	
	return pSelect_2_cjs_entry;
}

var pSelectWrapper_2_cjs_entry = {};

var propertyObserver4331cfab = {};

var hasRequiredPropertyObserver4331cfab;

function requirePropertyObserver4331cfab () {
	if (hasRequiredPropertyObserver4331cfab) return propertyObserver4331cfab;
	hasRequiredPropertyObserver4331cfab = 1;

	// inspired by react
	// https://github.com/facebook/react/blob/c88fb49d37fd01024e0a254a37b7810d107bdd1d/packages/react-dom/src/client/inputValueTracking.js#L53
	const observeProperties = (node, props, callback) => {
	    const proto = Object.getPrototypeOf(node);
	    const properties = props.reduce((result, prop) => {
	        const descriptor = Object.getOwnPropertyDescriptor(proto, prop);
	        if (
	        // node.hasOwnProperty(prop) || // this condition breaks p-text-field-wrapper type="search" clear button functionality in react
	        typeof descriptor === 'undefined' ||
	            typeof descriptor.get !== 'function' ||
	            typeof descriptor.set !== 'function') {
	            return result;
	        }
	        // eslint-disable-next-line @typescript-eslint/unbound-method
	        const { get, set } = descriptor;
	        return {
	            ...result,
	            [prop]: {
	                configurable: true,
	                get() {
	                    return get.call(this);
	                },
	                set(val) {
	                    set.call(this, val);
	                    callback();
	                },
	            },
	        };
	    }, {});
	    Object.defineProperties(node, properties);
	};

	propertyObserver4331cfab.observeProperties = observeProperties;

	
	return propertyObserver4331cfab;
}

var throwIfRootNodeIsNotOneOfKind201fcf02 = {};

var hasRequiredThrowIfRootNodeIsNotOneOfKind201fcf02;

function requireThrowIfRootNodeIsNotOneOfKind201fcf02 () {
	if (hasRequiredThrowIfRootNodeIsNotOneOfKind201fcf02) return throwIfRootNodeIsNotOneOfKind201fcf02;
	hasRequiredThrowIfRootNodeIsNotOneOfKind201fcf02 = 1;

	const validateProps = requireValidateProps788e2bc5();

	const throwIfRootNodeIsNotOneOfKind = (element, tagNames) => {
	    const shadowHost = element.getRootNode()?.host;
	    const actualTagName = shadowHost && validateProps.getTagName(shadowHost);
	    const prefixedTagNames = validateProps.getPrefixedTagNames(element);
	    const allowedTagNames = tagNames.map((tagName) => prefixedTagNames[validateProps.paramCaseToCamelCase(tagName)]);
	    if (!allowedTagNames.includes(actualTagName)) {
	        validateProps.throwException(`${validateProps.getTagNameWithoutPrefix(element)} can't be used like this.`);
	    }
	};

	throwIfRootNodeIsNotOneOfKind201fcf02.throwIfRootNodeIsNotOneOfKind = throwIfRootNodeIsNotOneOfKind;

	
	return throwIfRootNodeIsNotOneOfKind201fcf02;
}

var hasRequiredPSelectWrapper_2_cjs_entry;

function requirePSelectWrapper_2_cjs_entry () {
	if (hasRequiredPSelectWrapper_2_cjs_entry) return pSelectWrapper_2_cjs_entry;
	hasRequiredPSelectWrapper_2_cjs_entry = 1;

	Object.defineProperty(pSelectWrapper_2_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const getSlotTextContent = requireGetSlotTextContent3ec731e2();
	const stateMessageStyles = requireStateMessageStylesD1c4637f();
	const labelStyles = requireLabelStylesD5916d0e();
	const theme = requireThemeBfc10573();
	const getOnlyChildOfKindHTMLElementOrThrow = requireGetOnlyChildOfKindHTMLElementOrThrowCdb95e52();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const formStyles = requireFormStylesDeecb9a1();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const slottedAnchorStyles = requireSlottedAnchorStylesFe1a10c2();
	const isClickOutside = requireIsClickOutside050dc86b();
	const popover = requirePopover8518c8b1();
	const isSsrHydration = requireIsSsrHydration78eae0b3();
	const propertyObserver = requirePropertyObserver4331cfab();
	const throwIfRootNodeIsNotOneOfKind = requireThrowIfRootNodeIsNotOneOfKind201fcf02();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const fontSizeTextXSmall = requireFontSizeTextXSmallE59d35d7();
	const fontWeightSemiBold = requireFontWeightSemiBold4482c830();
	const textSmallStyle = requireTextSmallStyle00e1c6e2();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const getHTMLElements = requireGetHTMLElements3f1c700f();
	const hasAttribute = requireHasAttributeBf22c03a();
	requireHasNamedSlot273cd3ae();
	requireGetNamedSlot223c478a();
	requireGetClosestHTMLElement83d01a84();
	requireHasDescription050833e0();
	requireIsParentOfKind4b323732();
	requireGetDirectChildHTMLElements2594e5bd();
	requireTransformSelectorToDirectChildSelectorEcc1a9c4();
	requireSpacingStaticMedium94812711();
	requireFontLineHeightD4b9e1a9();
	requireBorderRadiusMedium758b9411();
	requireFontSizeTextSmall508930e5();
	requireFontFamily23874d28();
	requireTextShared5216bb19();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();

	const isTouchDevice = () => {
	    if (!validateProps.hasWindow) {
	        return undefined;
	    }
	    return !!('ontouchstart' in window || window.navigator.maxTouchPoints > 0);
	};

	const DROPDOWN_DIRECTIONS_INTERNAL = ['down', 'up'];
	const DROPDOWN_DIRECTIONS = [...DROPDOWN_DIRECTIONS_INTERNAL, 'auto'];
	const isCustomDropdown = (filter, native) => {
	    if (filter) {
	        return true;
	    }
	    if (native) {
	        return false;
	    }
	    return !isTouchDevice();
	};

	const getComponentCss$1 = (isDisabled, hasCustomDropdown, hideLabel, state, theme) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            // ::slotted(select)
	            ...validateProps.addImportantToEachRule(formStyles.getSlottedTextFieldTextareaSelectStyles('select', state, false, theme, {
	                gridArea: '1/1/1/-1',
	                position: 'static',
	                zIndex: 0, // TODO: overrides global style.css in e2e and vrts
	                cursor: 'pointer',
	                // TODO: move into getSlottedTextFieldTextareaSelectStyles()
	                padding: `${formStyles.formElementPaddingVertical} ${formStyles.formElementPaddingHorizontal}`,
	                paddingInlineEnd: formStyles.getCalculatedFormElementPaddingHorizontal(1),
	                // TODO: needs to be aligned with multi-select
	                ...(hasCustomDropdown && !isDisabled && { borderColor: 'transparent' }),
	            })),
	        },
	        root: {
	            display: 'grid',
	            gap: spacingStaticXSmall.spacingStaticXSmall,
	            // min width is needed for showing at least 1 character in very narrow containers. The "1rem" value is the minimum safe zone to show at least 1 character plus the ellipsis dots.
	            minWidth: `calc(1rem + ${formStyles.formElementPaddingHorizontal} + ${validateProps.borderWidthBase} * 2 + ${formStyles.getCalculatedFormElementPaddingHorizontal(1)})`,
	        },
	        wrapper: {
	            display: 'grid',
	            gridTemplateColumns: `minmax(0, 1fr) auto ${formStyles.formElementLayeredSafeZone}`,
	        },
	        // TODO: extract for multi-select, select-wrapper and text-field (not gridArea and placeSelf)
	        icon: {
	            gridArea: '1/2',
	            placeSelf: 'center',
	            position: 'relative',
	            zIndex: 2, // ensures icon is above input or button of select dropdown
	            pointerEvents: 'none',
	            padding: formStyles.formButtonOrIconPadding,
	            transform: 'rotate3d(0,0,1,0.0001deg)', // needs to be a little more than 0 for correct direction in safari
	            transition: validateProps.getTransition('transform'),
	            '&--open': {
	                transform: 'rotate3d(0,0,1,180deg)',
	            },
	        },
	        dropdown: {
	            gridArea: '1/1/1/-1',
	        },
	        // .label / .required
	        ...labelStyles.getFunctionalComponentLabelStyles(isDisabled, hideLabel, theme),
	        // .message
	        ...stateMessageStyles.getFunctionalComponentStateMessageStyles(theme, state),
	    });
	};

	/*
	 * This is a bug fix Windows when using a touch device or the native property where the <option> elements are not visible in dark mode.
	 * We set the styles explicitly regardless of theme as a workaround to avoid dynamic stylesheet manipulation.
	 * These styles will be ignored in most iOS and Android browsers anyway.
	 */
	const getSlottedSelectOptionStyles = (tagName) => {
	    const { primaryColor, backgroundColor } = validateProps.getThemedColors('light');
	    return {
	        '@global': {
	            [`${tagName} select > option`]: validateProps.addImportantToEachRule({
	                color: primaryColor,
	                backgroundColor,
	            }),
	        },
	    };
	};

	const propTypes = {
	    label: validateProps.AllowedTypes.string,
	    description: validateProps.AllowedTypes.string,
	    state: validateProps.AllowedTypes.oneOf(stateMessageStyles.FORM_STATES),
	    message: validateProps.AllowedTypes.string,
	    hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	    filter: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    dropdownDirection: validateProps.AllowedTypes.oneOf(DROPDOWN_DIRECTIONS),
	    native: validateProps.AllowedTypes.boolean,
	};
	const SelectWrapper = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.label = '';
	        this.description = '';
	        this.state = 'none';
	        this.message = '';
	        this.hideLabel = false;
	        this.filter = false;
	        this.theme = 'light';
	        this.dropdownDirection = 'auto';
	        this.native = false;
	    }
	    connectedCallback() {
	        validateProps.applyConstructableStylesheetStyles(this.host, slottedAnchorStyles.getSlottedAnchorStyles, getSlottedSelectOptionStyles);
	        this.observeAttributes(); // on every reconnect
	    }
	    componentWillLoad() {
	        this.select = getOnlyChildOfKindHTMLElementOrThrow.getOnlyChildOfKindHTMLElementOrThrow(this.host, 'select');
	        this.observeAttributes(); // once initially
	        this.hasCustomDropdown = isCustomDropdown(this.filter, this.native);
	        if (this.hasCustomDropdown) {
	            validateProps.setAttribute(this.select, 'tabindex', '-1');
	            validateProps.setAttribute(this.select, 'aria-hidden', 'true');
	        }
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    componentDidRender() {
	        /*
	         * This is a workaround to improve accessibility because the select and the label/description/message text are placed in different DOM.
	         * Referencing ID's from outside the component is impossible because the web components DOM is separate.
	         * We have to wait for full support of the Accessibility Object Model (AOM) to provide the relationship between shadow DOM and slots.
	         */
	        if (!this.hasCustomDropdown) {
	            validateProps.setAriaAttributes(this.select, {
	                label: this.label,
	                message: this.message || this.description,
	                state: this.state,
	            });
	        }
	    }
	    disconnectedCallback() {
	        validateProps.unobserveAttributes(this.select);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        const { disabled } = this.select;
	        validateProps.attachComponentCss(this.host, getComponentCss$1, disabled, this.hasCustomDropdown, this.hideLabel, this.state, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h("div", { key: 'fb0fe295719513fef7ad4b08dad565207b2c35fe', class: "root" }, validateProps.h(labelStyles.Label, { key: '43d513662a918ab7ac26d4e823855feee43794b0', host: this.host, label: this.label, description: this.description, isDisabled: disabled, formElement: this.select }), validateProps.h("div", { key: 'e9df3a3d631410990f23cd85dd2481a24e373f26', class: "wrapper" }, validateProps.h("slot", { key: '4a2dd996228b5dcdb5ba9bb7e7a16efb89931164' }), validateProps.h(PrefixedTagNames.pIcon, { key: 'a972f4f9cc3a28b1f000331e361fff4b483e855d', class: "icon", name: "arrow-head-down", theme: this.theme, color: disabled ? 'state-disabled' : 'primary', "aria-hidden": "true", ref: (el) => (this.iconElement = el) }), this.hasCustomDropdown && !disabled && (validateProps.h(PrefixedTagNames.pSelectWrapperDropdown, { key: '850a98534b6b3e127ba5c02e6f9bf5fb838b4851', class: "dropdown", selectRef: this.select, label: this.label || getSlotTextContent.getSlotTextContent(this.host, 'label'), message: this.message || getSlotTextContent.getSlotTextContent(this.host, 'message'), description: this.description || getSlotTextContent.getSlotTextContent(this.host, 'description'), state: this.state, direction: this.dropdownDirection, filter: this.filter, theme: this.theme, required: labelStyles.isRequiredAndParentNotRequired(this.host, this.select), disabled: disabled, onOpenChange: (isOpen) => this.iconElement.classList.toggle('icon--open', isOpen) }))), validateProps.h(stateMessageStyles.StateMessage, { key: '20509b2f2f98e15b64c64e0df3816295ec69b111', state: this.state, message: this.message, theme: this.theme, host: this.host })));
	    }
	    observeAttributes() {
	        validateProps.observeAttributes(this.select, ['disabled', 'required'], () => validateProps.forceUpdate(this.host));
	    }
	    static get delegatesFocus() { return true; }
	    get host() { return validateProps.getElement(this); }
	};

	const getButtonStyles = (isOpen, state, theme) => {
	    const { primaryColor, disabledColor, contrastMediumColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, disabledColor: disabledColorDark, contrastMediumColor: contrastMediumColorDark, } = validateProps.getThemedColors('dark');
	    const { formStateHoverColor, formStateColor } = stateMessageStyles.getThemedFormStateColors(theme, state);
	    const { formStateHoverColor: formStateHoverColorDark, formStateColor: formStateColorDark } = stateMessageStyles.getThemedFormStateColors('dark', state);
	    return {
	        '@global': {
	            // TODO: extract generic default button/anchor reset style
	            button: {
	                position: 'absolute',
	                inset: 0,
	                width: '100%', // fixes Firefox positioning issue
	                height: '100%', // fixes Firefox positioning issue
	                margin: 0,
	                padding: 0,
	                background: 'transparent',
	                border: `${validateProps.borderWidthBase} solid ${isOpen ? primaryColor : formStateColor || contrastMediumColor}`, // using border of styled select below for label:hover selector
	                borderRadius: borderRadiusSmall.borderRadiusSmall,
	                outline: '0',
	                cursor: 'pointer',
	                transition: validateProps.getTransition('border-color'), // background and text color are handled on select
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    borderColor: isOpen ? primaryColorDark : formStateColorDark || contrastMediumColorDark,
	                }),
	                '&:disabled': {
	                    cursor: 'not-allowed',
	                    borderColor: disabledColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        borderColor: disabledColorDark,
	                    }),
	                },
	                ...hoverMediaQuery.hoverMediaQuery({
	                    '&:not(:disabled):hover': {
	                        borderColor: isOpen ? primaryColor : formStateHoverColor || primaryColor,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            borderColor: isOpen ? primaryColorDark : formStateHoverColorDark || primaryColorDark,
	                        }),
	                    },
	                }),
	                ...validateProps.getFocusJssStyle(theme),
	            },
	        },
	    };
	};
	const getFilterStyles = (isOpen, state, disabled, theme) => {
	    const { primaryColor, backgroundColor, disabledColor, contrastMediumColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, backgroundColor: backgroundColorDark, disabledColor: disabledColorDark, contrastMediumColor: contrastMediumColorDark, } = validateProps.getThemedColors('dark');
	    const { formStateHoverColor, formStateColor } = stateMessageStyles.getThemedFormStateColors(theme, state);
	    const { formStateHoverColor: formStateHoverColorDark, formStateColor: formStateColorDark } = stateMessageStyles.getThemedFormStateColors('dark', state);
	    const placeHolderJssStyle = {
	        opacity: 1,
	        color: disabled ? disabledColor : primaryColor,
	    };
	    const placeHolderDarkJssStyle = {
	        opacity: 1,
	        color: disabled ? disabledColorDark : primaryColorDark,
	    };
	    return {
	        '@global': {
	            input: {
	                display: 'block',
	                position: 'absolute',
	                inset: validateProps.borderWidthBase,
	                width: 'calc(100% - 4px)', // fixes Firefox positioning issue, 4px = 2 x borderWidthBase
	                height: 'calc(100% - 4px)', // fixes Firefox positioning issue, 4px = 2 x borderWidthBase
	                zIndex: 1,
	                font: textSmallStyle.textSmallStyle.font.replace('ex', 'ex + 6px'), // a minimum line-height is needed for input, otherwise value is scrollable in Chrome, +6px is alig
	                margin: 0, // necessary reset for iOS Safari 15 (and maybe other browsers)
	                // TODO: could be done with css subgrid much more elegant in the near future
	                //  or move input into select-wrapper and handle it the same like multi-select
	                padding: `${formStyles.formElementPaddingVertical} ${formStyles.formElementPaddingHorizontal}`,
	                paddingInlineEnd: formStyles.getCalculatedFormElementPaddingHorizontal(1),
	                outline: '0',
	                WebkitAppearance: 'none', // iOS safari
	                appearance: 'none',
	                boxSizing: 'border-box',
	                border: '0', // done via span
	                borderRadius: borderRadiusSmall.borderRadiusSmall, // for white corners
	                opacity: 0, // is used to overlay input on focus
	                ...textSmallStyle.textSmallStyle,
	                textIndent: 0,
	                cursor: disabled ? 'not-allowed' : 'text',
	                color: primaryColor,
	                background: backgroundColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: primaryColorDark,
	                    background: backgroundColorDark,
	                }),
	                '&::placeholder': {
	                    ...placeHolderJssStyle,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, placeHolderDarkJssStyle),
	                },
	                '&::-webkit-input-placeholder': {
	                    ...placeHolderJssStyle,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, placeHolderDarkJssStyle),
	                },
	                '&::-moz-placeholder': {
	                    ...placeHolderJssStyle,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, placeHolderDarkJssStyle),
	                },
	                '&:not(:disabled):focus': {
	                    opacity: 1, // to display value while typing
	                    '&+span, &~ ul': {
	                        borderColor: primaryColor,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            borderColor: primaryColorDark,
	                        }),
	                    },
	                },
	                ...hoverMediaQuery.hoverMediaQuery({
	                    '&:not(:disabled)': {
	                        '&+span:hover': {
	                            borderColor: isOpen ? primaryColor : formStateHoverColor || primaryColor,
	                            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                                borderColor: isOpen ? primaryColorDark : formStateHoverColorDark || primaryColorDark,
	                            }),
	                        },
	                        '&:hover': {
	                            '&+span, &~ul': {
	                                borderColor: isOpen ? primaryColor : formStateHoverColor || primaryColor,
	                                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                                    borderColor: isOpen ? primaryColorDark : formStateHoverColorDark || primaryColorDark,
	                                }),
	                            },
	                        },
	                    },
	                }),
	                // TODO: we should try to get rid of the span and apply the border-styles on either select or input
	                '&+span': {
	                    // for focus outline and clicking arrow since input ends left of the icon
	                    position: 'absolute',
	                    inset: 0,
	                    transition: validateProps.getTransition('border-color'),
	                    pointerEvents: 'all',
	                    cursor: disabled ? 'not-allowed' : 'pointer',
	                    border: `${validateProps.borderWidthBase} solid ${isOpen ? primaryColor : formStateColor || contrastMediumColor}`,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        borderColor: isOpen ? primaryColorDark : formStateColorDark || contrastMediumColorDark,
	                    }),
	                    borderRadius: borderRadiusSmall.borderRadiusSmall,
	                },
	            },
	        },
	    };
	};
	const getListStyles = (isOpen, theme) => {
	    const { primaryColor, disabledColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, disabledColor: disabledColorDark } = validateProps.getThemedColors('dark');
	    return {
	        '@global': {
	            // @keyframes fade-in
	            ...popover.getPopoverKeyframesStyles,
	            '[popover]': popover.getPopoverJssStyle(isOpen, 1, 40, theme),
	        },
	        option: {
	            ...popover.getOptionJssStyle('select-wrapper', 1, theme),
	            '&--indent': {
	                paddingLeft: '28px',
	            },
	        },
	        icon: {
	            marginInlineStart: 'auto',
	        },
	        optgroup: {
	            '&--hidden': {
	                display: 'none',
	            },
	            '&--disabled': {
	                color: disabledColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: disabledColorDark,
	                }),
	            },
	            color: primaryColor,
	            display: 'block',
	            padding: `${spacingStaticSmall.spacingStaticSmall} 12px`,
	            fontSize: fontSizeTextXSmall.fontSizeTextXSmall,
	            fontWeight: fontWeightSemiBold.fontWeightSemiBold,
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                color: primaryColorDark,
	            }),
	        },
	    };
	};
	const getComponentCss = (isOpen, state, disabled, filter, theme) => {
	    return validateProps.getCss(
	    // merge because of global styles
	    validateProps.mergeDeep({
	        '@global': {
	            ':host': {
	                display: 'block',
	                position: 'relative',
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	        },
	        'sr-text': {
	            display: 'none',
	        },
	    }, filter ? getFilterStyles(isOpen, state, disabled, theme) : getButtonStyles(isOpen, state, theme), getListStyles(isOpen, theme)));
	};

	/**
	 * Handles scrolling within the list to ensure that the highlighted item is always visible.
	 * @param {HTMLElement} ul - The HTML element to be scrolled.
	 * @param {number} highlightedIndex - The index of the currently highlighted item within the element.
	 * @returns {void}
	 */
	const handleScroll = (ul, highlightedIndex) => {
	    const { maxHeight } = getComputedStyle(ul);
	    const hostElementHeight = Number.parseInt(maxHeight, 10);
	    if (ul.scrollHeight > hostElementHeight) {
	        const highlightedNode = getHTMLElements.getHTMLElements(ul, 'li')[highlightedIndex];
	        if (highlightedNode) {
	            highlightedNode.scrollIntoView({ block: 'nearest' });
	        }
	    }
	};
	const getOptionsElements = (select) => Array.from(select.options);
	const getOptionMaps = (options) => options.map((item) => {
	    const { selected, parentElement, previousElementSibling } = item;
	    const option = {
	        value: item.text,
	        disabled: hasAttribute.hasAttribute(item, 'disabled') || hasAttribute.hasAttribute(parentElement, 'disabled'),
	        hidden: false,
	        initiallyHidden: hasAttribute.hasAttribute(item, 'hidden') || hasAttribute.hasAttribute(parentElement, 'hidden'),
	        selected,
	        highlighted: selected,
	        ...(validateProps.getTagName(parentElement) === 'optgroup' && { title: parentElement.label }),
	        showOptgroup: validateProps.getTagName(parentElement) === 'optgroup' && previousElementSibling == null,
	        optgroupOptions: {
	            hidden: hasAttribute.hasAttribute(parentElement, 'hidden'),
	            disabled: hasAttribute.hasAttribute(parentElement, 'disabled'),
	        },
	    };
	    return option;
	});
	const setSelectedOptionMaps = (options, newIndex) => options.map((item, idx) => ({
	    ...item,
	    selected: idx === newIndex,
	    highlighted: idx === newIndex,
	    hidden: false,
	}));
	const setHighlightedOptionMaps = (options, newIndex) => options.map((item, idx) => ({
	    ...item,
	    highlighted: idx === newIndex,
	}));
	const resetHighlightedToSelectedOptionMaps = (options) => options.map((item) => ({ ...item, highlighted: item.selected }));
	const setFirstHighlightedOptionMaps = (options) => setHighlightedOptionMaps(options, 0);
	const setLastHighlightedOptionMaps = (options) => setHighlightedOptionMaps(options, options.length - 1);
	const getHighlightedOptionMapIndex = (arr) => arr.findIndex((item) => item.highlighted);
	const getSelectedOptionMap = (arr) => arr.find((item) => item.selected);
	const getValidOptions = (options) => options.filter((item) => !item.hidden && !item.initiallyHidden && !item.disabled);
	const getMatchingOptionMaps = (options, searchString) => {
	    const lowerCaseSearchString = searchString.toLowerCase();
	    return lowerCaseSearchString && options.filter((item) => item.value.toLowerCase() === lowerCaseSearchString);
	};
	const getFirstMatchingOptionMapIndex = (options, key) => {
	    // TODO: what about other characters?
	    if ([...'abcdefghijklmnopqrstuvwxyz1234567890'].includes(key)) {
	        const lowerCaseSearchString = key.toLowerCase();
	        const firstMatchingIndex = lowerCaseSearchString && options.findIndex((item) => item.value.toLowerCase().startsWith(lowerCaseSearchString));
	        // jump to last item if no match is found
	        return firstMatchingIndex >= 0 ? firstMatchingIndex : options.length - 1;
	    }
	    return undefined;
	};
	const setHighlightedFirstMatchingOptionMaps = (options, key) => {
	    const targetIndex = getFirstMatchingOptionMapIndex(options, key);
	    return targetIndex && targetIndex >= 0
	        ? options.map((item, idx) => ({ ...item, highlighted: idx === targetIndex }))
	        : options;
	};
	const setFilteredOptionMaps = (options, searchString) => {
	    const lowerCaseSearchString = searchString.toLowerCase();
	    const matchedItems = options.filter((item) => item.title && !item.initiallyHidden && item.value.toLowerCase().includes(lowerCaseSearchString));
	    const firstInOptgroup = matchedItems.filter((value, index, self) => index === self.findIndex((v) => v.title === value.title));
	    return options.map((item) => ({
	        ...item,
	        hidden: !item.initiallyHidden && !item.value.toLowerCase().includes(lowerCaseSearchString),
	        showOptgroup: firstInOptgroup.indexOf(item) !== -1,
	    }));
	};
	const resetFilteredOptionMaps = (options) => options.map((item) => ({
	    ...item,
	    hidden: false,
	}));
	const hasFilterResults = (options) => options.some((item) => !item.hidden && !item.initiallyHidden);
	const getNewOptionMapIndex = (options, direction) => {
	    const validItems = getValidOptions(options);
	    const validMax = validItems.length - 1;
	    // prob. needs to be <= 0
	    if (validMax < 0) {
	        // @ts-expect-error: Not all code paths return a value
	        return;
	    }
	    let i = getHighlightedOptionMapIndex(validItems);
	    if (direction === 'down') {
	        i = i < validMax ? i + 1 : 0;
	    }
	    else if (direction === 'up') {
	        i = i > 0 ? i - 1 : validMax;
	    }
	    return options.indexOf(validItems[i]);
	};
	const getDropdownVisibility = (isOpen, type, resetFilter) => {
	    if (isOpen && (type === 'hide' || type === 'toggle')) {
	        if (resetFilter) {
	            resetFilter();
	        }
	        return false;
	    }
	    if (!isOpen && (type === 'show' || type === 'toggle')) {
	        return true;
	    }
	    return isOpen;
	};

	const SelectWrapperDropdown = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.hasNativePopoverSupport = validateProps.getHasNativePopoverSupport();
	        this.onClickOutside = (e) => {
	            if (this.isOpen && isClickOutside.isClickOutside(e, this.host)) {
	                this.setDropdownVisibility('hide');
	            }
	        };
	        this.setDropdownVisibility = (type) => {
	            this.isOpen = getDropdownVisibility(this.isOpen, type, this.filter && this.resetFilter);
	            this.onOpenChange(this.isOpen);
	        };
	        this.onComboboxKeyDown = (e) => {
	            switch (e.key) {
	                case 'ArrowUp':
	                case 'Up': {
	                    e.preventDefault();
	                    this.cycleDropdown('up');
	                    break;
	                }
	                case 'ArrowDown':
	                case 'Down': {
	                    e.preventDefault();
	                    this.cycleDropdown('down');
	                    break;
	                }
	                case ' ':
	                case 'Spacebar':
	                case 'Enter':
	                    if (this.filter) {
	                        if (e.key === 'Enter') {
	                            e.preventDefault();
	                            const matchingOptions = getMatchingOptionMaps(this.optionMaps, this.searchString);
	                            if (matchingOptions.length === 1) {
	                                this.setOptionSelected(this.optionMaps.indexOf(matchingOptions[0]));
	                            }
	                            else {
	                                this.setOptionSelected(getHighlightedOptionMapIndex(this.optionMaps));
	                            }
	                        }
	                    }
	                    else {
	                        e.preventDefault();
	                        if (this.isOpen) {
	                            this.setOptionSelected(getHighlightedOptionMapIndex(this.optionMaps));
	                        }
	                        else {
	                            this.setDropdownVisibility('show');
	                        }
	                    }
	                    break;
	                case 'Escape':
	                case 'Tab': {
	                    this.setDropdownVisibility('hide');
	                    this.resetHighlightedToSelectedOptionMaps();
	                    break;
	                }
	                case 'PageUp':
	                    if (this.isOpen) {
	                        e.preventDefault();
	                        this.optionMaps = setFirstHighlightedOptionMaps(this.optionMaps);
	                    }
	                    break;
	                case 'PageDown':
	                    if (this.isOpen) {
	                        e.preventDefault();
	                        this.optionMaps = setLastHighlightedOptionMaps(this.optionMaps);
	                    }
	                    break;
	                default:
	                    if (!this.filter) {
	                        // TODO: seems to be difficult to combine multiple keys as native select does
	                        this.optionMaps = setHighlightedFirstMatchingOptionMaps(this.optionMaps, e.key);
	                    }
	            }
	        };
	        this.syncSelectedIndex = () => {
	            this.optionMaps = setSelectedOptionMaps(this.optionMaps, this.selectedIndex);
	        };
	        this.setOptionMaps = () => {
	            this.optionMaps = setSelectedOptionMaps(getOptionMaps(getOptionsElements(this.selectRef)), this.selectedIndex);
	        };
	        this.resetHighlightedToSelectedOptionMaps = () => {
	            this.optionMaps = resetHighlightedToSelectedOptionMaps(this.optionMaps);
	        };
	        this.setOptionSelected = (newIndex) => {
	            this.setDropdownVisibility('hide');
	            if (this.selectedIndex !== newIndex) {
	                this.selectRef.selectedIndex = newIndex;
	                this.selectRef.dispatchEvent(new Event('change', { bubbles: true }));
	            }
	            else {
	                this.resetHighlightedToSelectedOptionMaps();
	                this.resetFilter();
	            }
	        };
	        this.resetFilter = () => {
	            if (this.filter) {
	                this.searchString = '';
	                this.optionMaps = resetFilteredOptionMaps(this.optionMaps);
	                this.inputOrButtonElement.value = '';
	            }
	        };
	        this.onFilterChange = (e) => {
	            this.searchString = e.target.value;
	            if (this.searchString.startsWith(' ')) {
	                this.resetFilter();
	            }
	            else {
	                this.optionMaps = setFilteredOptionMaps(this.optionMaps, this.searchString);
	            }
	            // in case input is focused via tab instead of click
	            this.setDropdownVisibility('show');
	        };
	        this.selectRef = undefined;
	        this.label = undefined;
	        this.description = undefined;
	        this.message = undefined;
	        this.state = undefined;
	        this.direction = 'auto';
	        this.theme = 'light';
	        this.filter = false;
	        this.required = false;
	        this.disabled = false;
	        this.onOpenChange = undefined;
	        this.isOpenOverride = false;
	        this.isOpen = this.isOpenOverride;
	        this.optionMaps = [];
	        this.searchString = '';
	    }
	    get selectedIndex() {
	        return this.selectRef.selectedIndex;
	    }
	    onIsOpenChange() {
	        if (this.isOpen) {
	            if (this.hasNativePopoverSupport) {
	                this.popoverElement.showPopover();
	            }
	            if (typeof this.cleanUpAutoUpdate === 'undefined') {
	                // ensures floating ui event listeners are added when options list is opened
	                this.cleanUpAutoUpdate = isClickOutside.autoUpdate(this.inputOrButtonElement, this.popoverElement, async () => {
	                    await popover.optionListUpdatePosition(this.direction, this.inputOrButtonElement, this.popoverElement);
	                });
	            }
	        }
	        else {
	            if (this.hasNativePopoverSupport) {
	                this.popoverElement.hidePopover();
	            }
	            if (typeof this.cleanUpAutoUpdate === 'function') {
	                // ensures floating ui event listeners are removed when options list is closed
	                this.cleanUpAutoUpdate();
	                this.cleanUpAutoUpdate = undefined;
	            }
	        }
	    }
	    connectedCallback() {
	        throwIfRootNodeIsNotOneOfKind.throwIfRootNodeIsNotOneOfKind(this.host, ['p-select-wrapper']);
	        validateProps.observeChildren(this.selectRef, () => {
	            this.setOptionMaps();
	            this.observeOptions(); // new option might have been added
	        }, 
	        // unfortunately we can't observe hidden property of option elements via observeProperties
	        // therefore we do it here via attribute
	        ['hidden', 'disabled', 'selected']);
	    }
	    disconnectedCallback() {
	        document.removeEventListener('mousedown', this.onClickOutside, true);
	        validateProps.unobserveChildren(this.host);
	        if (typeof this.cleanUpAutoUpdate === 'function') {
	            // ensures floating ui event listeners are removed in case popover is removed from DOM
	            this.cleanUpAutoUpdate();
	        }
	    }
	    componentDidRender() {
	        if (this.isOpen) {
	            handleScroll(this.popoverElement, getHighlightedOptionMapIndex(this.optionMaps));
	        }
	    }
	    componentWillLoad() {
	        if (!isSsrHydration.isSsrHydration(this.host)) {
	            // when ssr rendered component is partially hydrated before being rerendered by its parent select-wrapper
	            // it has no select ref and options can't be accessed
	            this.observeProperties();
	            document.addEventListener('mousedown', this.onClickOutside, true);
	        }
	    }
	    render() {
	        validateProps.attachComponentCss(this.host, getComponentCss, this.isOpen, this.state, this.disabled, this.filter, this.theme);
	        // TODO: part won't be needed as soon as button/input of select-wrapper-dropdown is part of shadow dom of select-wrapper itself
	        const part = 'select-wrapper-dropdown';
	        const popoverId = 'list';
	        const labelId = 'label';
	        const inputId = 'filter';
	        const descriptionId = this.description && 'description';
	        const buttonId = 'value';
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(validateProps.Host, { key: '5f5399017668a941085a12b81c1f5a3ab3586841' }, this.filter ? ([
	            validateProps.h("input", { id: inputId, key: "input", type: "text", role: "combobox", disabled: this.disabled, placeholder: getSelectedOptionMap(this.optionMaps)?.value || null, autoComplete: "off", value: this.searchString, ...popover.getFilterInputAriaAttributes(this.isOpen, this.required, labelId, descriptionId, popoverId, getHighlightedOptionMapIndex(this.optionMaps)), onKeyDown: this.onComboboxKeyDown, onInput: this.onFilterChange, onClick: () => this.setDropdownVisibility('show'), ref: (el) => (this.inputOrButtonElement = el) }),
	            validateProps.h("span", { part: part, key: "span", onClick: this.disabled ? undefined : () => this.setDropdownVisibility('toggle') }),
	        ]) : (validateProps.h("button", { part: part, type: "button", role: "combobox", id: buttonId, disabled: this.disabled, ...popover.getSelectDropdownButtonAriaAttributes(this.isOpen, labelId, descriptionId, popoverId, getHighlightedOptionMapIndex(this.optionMaps)), onClick: () => this.setDropdownVisibility('toggle'), onKeyDown: this.onComboboxKeyDown, ref: (el) => (this.inputOrButtonElement = el) })), [
	            validateProps.h("div", { key: '268f5df51539f418536e75e3da0ca4f2a091962c', class: "sr-text", id: labelId }, getSelectedOptionMap(this.optionMaps)?.value, ", ", this.label, !!this.message && `. ${this.message}`),
	            this.description && (validateProps.h("div", { key: '6257afd00e21280c7c90317116c4baa26056c956', class: "sr-text", id: descriptionId }, this.description)),
	            validateProps.h("div", { key: '709cdb1e69b3aaafacc3639f5e1b2ca011cad74d', id: popoverId, popover: "manual", tabIndex: -1, ...popover.getListAriaAttributes(this.label, this.required, this.filter, this.isOpen), ref: (el) => (this.popoverElement = el) }, this.filter && !hasFilterResults(this.optionMaps) ? (validateProps.h("div", { class: "option", "aria-live": "polite", role: "option" }, validateProps.h("span", { "aria-hidden": "true" }, "---"), validateProps.h("span", { class: "option__sr" }, "No results found"))) : (this.optionMaps.map((option, index) => {
	                const { value, disabled, hidden, initiallyHidden, selected, highlighted, title, showOptgroup, optgroupOptions, } = option;
	                return [
	                    showOptgroup && (validateProps.h("span", { class: {
	                            optgroup: true,
	                            'optgroup--hidden': optgroupOptions.hidden,
	                            'optgroup--disabled': optgroupOptions.disabled,
	                        }, role: "presentation" }, title)),
	                    validateProps.h("div", { id: `option-${index}`, role: "option", class: {
	                            option: true,
	                            'option--selected': selected,
	                            'option--highlighted': highlighted,
	                            'option--disabled': disabled,
	                            'option--hidden': hidden || initiallyHidden,
	                            'option--indent': !!title,
	                        }, onClick: !selected && !disabled ? () => this.setOptionSelected(index) : undefined, ...popover.getOptionAriaAttributes(selected, disabled, hidden, !!value) }, value, selected && !disabled && (validateProps.h(PrefixedTagNames.pIcon, { class: "icon", "aria-hidden": "true", name: "check", color: disabled ? 'state-disabled' : 'primary', theme: this.theme }))),
	                ];
	            }))),
	        ]));
	    }
	    observeProperties() {
	        this.setOptionMaps(); // initial
	        this.observeOptions(); // initial
	        propertyObserver.observeProperties(this.selectRef, ['value', 'selectedIndex'], this.syncSelectedIndex);
	    }
	    observeOptions() {
	        for (const el of getOptionsElements(this.selectRef)) {
	            propertyObserver.observeProperties(el, ['selected', 'disabled'], this.setOptionMaps);
	        }
	    }
	    cycleDropdown(direction) {
	        if (this.isOpen) {
	            const newIndex = getNewOptionMapIndex(this.optionMaps, direction);
	            this.optionMaps = setHighlightedOptionMaps(this.optionMaps, newIndex);
	        }
	        this.setDropdownVisibility('show');
	    }
	    static get delegatesFocus() { return true; }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "isOpen": ["onIsOpenChange"]
	    }; }
	};

	pSelectWrapper_2_cjs_entry.p_select_wrapper = SelectWrapper;
	pSelectWrapper_2_cjs_entry.p_select_wrapper_dropdown = SelectWrapperDropdown;

	
	return pSelectWrapper_2_cjs_entry;
}

var pSheet_cjs_entry = {};

var hasRequiredPSheet_cjs_entry;

function requirePSheet_cjs_entry () {
	if (hasRequiredPSheet_cjs_entry) return pSheet_cjs_entry;
	hasRequiredPSheet_cjs_entry = 1;

	Object.defineProperty(pSheet_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const getSlotTextContent = requireGetSlotTextContent3ec731e2();
	const hasNamedSlot = requireHasNamedSlot273cd3ae();
	const dialogStyles = requireDialogStyles52804ea9();
	const warnIfAriaAndHeadingPropsAreUndefined = requireWarnIfAriaAndHeadingPropsAreUndefined52718ac1();
	const setScrollLock = requireSetScrollLock68edfbd1();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const spacingFluidLarge = requireSpacingFluidLarge6087a0f7();
	const borderRadiusLarge = requireBorderRadiusLargeA0aa3a01();
	const spacingFluidSmall = requireSpacingFluidSmall2c6caae7();
	const spacingFluidMedium = requireSpacingFluidMedium88ab712b();
	requireGetNamedSlot223c478a();
	requireGridGapB5b73e4a();
	requireSpacingStaticMedium94812711();
	requireFrostedGlassStyleBd067e45();

	const getComponentCss = (isOpen, hasDismissButton, theme) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...dialogStyles.dialogHostJssStyle,
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            slot: {
	                display: 'block',
	                gridColumn: '2/3',
	                zIndex: 0, // controls layering + creates new stacking context (prevents content within to be above other dialog areas)
	            },
	            dialog: dialogStyles.getDialogJssStyle(isOpen, theme, 'shading'),
	        },
	        scroller: dialogStyles.getScrollerJssStyle('fullscreen', theme),
	        sheet: {
	            ...dialogStyles.dialogGridJssStyle,
	            ...dialogStyles.getDialogColorJssStyle(theme),
	            ...dialogStyles.getDialogTransitionJssStyle(isOpen, '^'),
	            width: '100%',
	            alignSelf: 'flex-end',
	            marginBlockStart: spacingFluidLarge.spacingFluidLarge, // ensures minimal space at the top to visualize paper sheet like border top radius in case sheet becomes scrollable
	            borderTopLeftRadius: borderRadiusLarge.borderRadiusLarge,
	            borderTopRightRadius: borderRadiusLarge.borderRadiusLarge,
	        },
	        ...(hasDismissButton && {
	            dismiss: {
	                ...validateProps.dismissButtonJssStyle,
	                gridArea: '1/3',
	                zIndex: 2, // ensures dismiss button is above header and content
	                position: 'sticky',
	                insetBlockStart: spacingFluidSmall.spacingFluidSmall,
	                marginBlockStart: `calc(${spacingFluidMedium.spacingFluidMedium} * -1)`,
	                marginInlineEnd: spacingFluidSmall.spacingFluidSmall,
	                placeSelf: 'flex-start flex-end',
	            },
	        }),
	    });
	};

	const SHEET_ARIA_ATTRIBUTES = ['aria-label', 'role'];

	const propTypes = {
	    open: validateProps.AllowedTypes.boolean,
	    dismissButton: validateProps.AllowedTypes.boolean,
	    disableBackdropClick: validateProps.AllowedTypes.boolean,
	    aria: validateProps.AllowedTypes.aria(SHEET_ARIA_ATTRIBUTES),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Sheet = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.dismiss = validateProps.createEvent(this, "dismiss", 3);
	        this.motionVisibleEnd = validateProps.createEvent(this, "motionVisibleEnd", 3);
	        this.motionHiddenEnd = validateProps.createEvent(this, "motionHiddenEnd", 3);
	        this.dismissDialog = () => {
	            this.dismiss.emit();
	        };
	        this.open = false;
	        this.dismissButton = true;
	        this.disableBackdropClick = false;
	        this.aria = undefined;
	        this.theme = 'light';
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    componentWillRender() {
	        setScrollLock.setScrollLock(this.open);
	    }
	    componentDidRender() {
	        dialogStyles.setDialogVisibility(this.open, this.dialog, this.scroller);
	    }
	    disconnectedCallback() {
	        setScrollLock.setScrollLock(false);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        this.hasHeader = hasNamedSlot.hasNamedSlot(this.host, 'header');
	        if (this.open) {
	            warnIfAriaAndHeadingPropsAreUndefined.warnIfAriaAndHeadingPropsAreUndefined(this.host, this.hasHeader, this.aria);
	        }
	        validateProps.attachComponentCss(this.host, getComponentCss, this.open, this.dismissButton, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h("dialog", { key: '8b4daed260653879b36567f2cfe05fefce8ef949', inert: !this.open, tabIndex: -1, ref: (el) => (this.dialog = el), onCancel: (e) => dialogStyles.onCancelDialog(e, this.dismissDialog, !this.dismissButton),
	            // Previously done with onMouseDown to change the click behavior (not closing when pressing mousedown on sheet and mouseup on backdrop) but changed back to native behavior
	            onClick: (e) => dialogStyles.onClickDialog(e, this.dismissDialog, this.disableBackdropClick), onTransitionEnd: (e) => dialogStyles.onTransitionEnd(e, this.open, this.motionVisibleEnd, this.motionHiddenEnd), ...validateProps.parseAndGetAriaAttributes({
	                'aria-modal': true,
	                ...(this.hasHeader && {
	                    'aria-label': hasNamedSlot.hasNamedSlot(this.host, 'header') && getSlotTextContent.getSlotTextContent(this.host, 'header'),
	                }),
	                ...validateProps.parseAndGetAriaAttributes(this.aria),
	            }) }, validateProps.h("div", { key: '50cd5d031a225070b11ee3971a77d80b45e93b30', class: "scroller", ref: (el) => (this.scroller = el) }, validateProps.h("div", { key: 'a7865b4e659be03d7f9afcde32c463e0471f3bb8', class: "sheet" }, this.dismissButton && (validateProps.h(PrefixedTagNames.pButton, { key: '87f0efa8de5be2f55fc41c85efb4bb20a7a9465f', variant: "ghost", class: "dismiss", type: "button", hideLabel: true, icon: "close", onClick: this.dismissDialog, theme: this.theme }, "Dismiss sheet")), this.hasHeader && validateProps.h("slot", { key: '4e09e064d064eaec2d28f5a5261d82f313556d6a', name: "header" }), validateProps.h("slot", { key: '24cde20216218fbd2b4afa860d8f8495846e4e2a' })))));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pSheet_cjs_entry.p_sheet = Sheet;

	
	return pSheet_cjs_entry;
}

var pSpinner_cjs_entry = {};

var hasRequiredPSpinner_cjs_entry;

function requirePSpinner_cjs_entry () {
	if (hasRequiredPSpinner_cjs_entry) return pSpinner_cjs_entry;
	hasRequiredPSpinner_cjs_entry = 1;

	Object.defineProperty(pSpinner_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();

	const SPINNER_SIZES = ['small', 'medium', 'large', 'inherit'];
	const SPINNER_ARIA_ATTRIBUTES = ['aria-label'];

	const sizeSmall = '48px';
	const sizeMedium = '72px';
	const sizeLarge = '104px';
	const sizeMap = {
	    small: { height: sizeSmall, width: sizeSmall },
	    medium: { height: sizeMedium, width: sizeMedium },
	    large: { height: sizeLarge, width: sizeLarge },
	    inherit: { height: 'inherit', width: 'inherit' },
	};
	const getComponentCss = (size, theme) => {
	    const strokeDasharray = '57'; // C = 2R
	    const animationDuration = `var(${validateProps.cssVariableAnimationDuration}, ${validateProps.motionDurationVeryLong})`;
	    const { primaryColor, contrastMediumColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, contrastMediumColor: contrastMediumColorDark } = validateProps.getThemedColors('dark');
	    const { canvasColor, canvasTextColor } = validateProps.getHighContrastColors();
	    const firstHighContrastStrokeColor = validateProps.isHighContrastMode && canvasTextColor;
	    const lastHighContrastStrokeColor = validateProps.isHighContrastMode && canvasColor;
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'inline-flex',
	                ...validateProps.addImportantToEachRule({
	                    verticalAlign: 'top',
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            svg: {
	                display: 'block', // for correct vertical alignment
	                fill: 'none',
	                animation: `$rotate ${animationDuration} steps(50) infinite`,
	            },
	            circle: {
	                '&:first-child': {
	                    // TODO: High Contrast Mode should be handled within a local color helper function
	                    stroke: firstHighContrastStrokeColor || contrastMediumColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        stroke: firstHighContrastStrokeColor || contrastMediumColorDark,
	                    }),
	                },
	                '&:last-child': {
	                    animation: `$dash ${animationDuration} steps(50) infinite`,
	                    // TODO: High Contrast Mode should be handled within a local color helper function
	                    stroke: lastHighContrastStrokeColor || primaryColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        stroke: lastHighContrastStrokeColor || primaryColorDark,
	                    }),
	                    strokeDasharray: strokeDasharray
	                        ,
	                    strokeLinecap: 'round',
	                },
	            },
	            '@keyframes rotate': {
	                '0%': {
	                    transform: 'rotateZ(0deg)',
	                },
	                '100%': {
	                    transform: 'rotateZ(360deg)',
	                },
	            },
	            '@keyframes dash': {
	                '0%': {
	                    strokeDashoffset: 57,
	                    transform: 'rotateZ(0)',
	                },
	                '50%, 75%': {
	                    strokeDashoffset: 20,
	                    transform: 'rotateZ(80deg)',
	                },
	                '100%': {
	                    strokeDashoffset: 57,
	                    transform: 'rotateZ(360deg)',
	                },
	            },
	        },
	        root: {
	            display: 'block',
	            ...validateProps.buildResponsiveStyles(size, (s) => sizeMap[s]),
	            strokeWidth: 1.5,
	        },
	        'sr-only': validateProps.getHiddenTextJssStyle(),
	    });
	};

	const propTypes = {
	    size: validateProps.AllowedTypes.breakpoint(SPINNER_SIZES),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    aria: validateProps.AllowedTypes.aria(SPINNER_ARIA_ATTRIBUTES),
	};
	const Spinner = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.size = 'small';
	        this.theme = 'light';
	        this.aria = undefined;
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.size, this.theme);
	        return (validateProps.h("span", { key: '39eda1089a50ef62172817e251d1bd7e5e412342', class: "root", role: "alert", "aria-live": "assertive", ...validateProps.parseAndGetAriaAttributes(this.aria) }, validateProps.h("span", { key: 'cb41ad75d462903b7322afa54870787ff07b417b', class: "sr-only" }, "\u00A0"), validateProps.h("svg", { key: 'ed86400e678d077f645f5aea37f8f27e5caa3557', viewBox: "-16 -16 32 32", width: "100%", height: "100%", focusable: "false", "aria-hidden": "true" }, validateProps.h("circle", { key: 'ca9a3fa0057e2033f8629b8d517405c118407fe6', r: "9" }), validateProps.h("circle", { key: '2196a202fa30396eff36cfd53e7573c7fd197386', r: "9" }))));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pSpinner_cjs_entry.p_spinner = Spinner;

	
	return pSpinner_cjs_entry;
}

var pStepperHorizontal_2_cjs_entry = {};

var hasRequiredPStepperHorizontal_2_cjs_entry;

function requirePStepperHorizontal_2_cjs_entry () {
	if (hasRequiredPStepperHorizontal_2_cjs_entry) return pStepperHorizontal_2_cjs_entry;
	hasRequiredPStepperHorizontal_2_cjs_entry = 1;

	Object.defineProperty(pStepperHorizontal_2_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const scrolling = requireScrollingD5dce8b3();
	const theme = requireThemeBfc10573();
	const throwIfChildrenAreNotOfKind = requireThrowIfChildrenAreNotOfKind288748e4();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const textSmallStyle = requireTextSmallStyle00e1c6e2();
	const fontSizeText = requireFontSizeText728b6387();
	const throwIfParentIsNotOfKind = requireThrowIfParentIsNotOfKindE0807bbc();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const getInlineSVGBackgroundImage = requireGetInlineSVGBackgroundImageB65404d9();
	const spacingFluidXSmall = requireSpacingFluidXSmall0dd753ae();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const frostedGlassStyle = requireFrostedGlassStyleBd067e45();
	const fontLineHeight = requireFontLineHeightD4b9e1a9();
	requireGetHTMLElements3f1c700f();
	requireTextShared5216bb19();
	requireFontFamily23874d28();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireFontSizeTextXXSmallA02f9c40();
	requireFontSizeTextXSmallE59d35d7();
	requireFontSizeTextMedium88887ad8();
	requireFontSizeTextLarge05a4bc90();
	requireFontSizeTextXLarge0ecf9ef3();
	requireIsParentOfKind4b323732();

	const throwIfChildCountIsExceeded = (element, allowedAmount) => {
	    const childCount = element.children.length;
	    if (childCount > allowedAmount) {
	        validateProps.throwException(`only ${allowedAmount} children are allowed in ${validateProps.getTagNameWithoutPrefix(element)} but got ${childCount}.`);
	    }
	};

	const getComponentCss$1 = (size) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	        },
	        scroller: {
	            ...textSmallStyle.textSmallStyle,
	            ...validateProps.buildResponsiveStyles(size, (s) => ({ fontSize: fontSizeText.fontSizeText[s] })),
	        },
	    });
	};

	const STEPPER_HORIZONTAL_SIZES = ['small', 'medium'];
	const getIndexOfStepWithStateCurrent = (stepperHorizontalItems) => {
	    return stepperHorizontalItems.findIndex((item) => item.state === 'current');
	};
	const throwIfMultipleCurrentStates = (host, stepperHorizontalItems) => {
	    const currentStateCount = stepperHorizontalItems.filter((item) => item.state === 'current').length;
	    if (currentStateCount > 1) {
	        validateProps.throwException(`only one child with current state is allowed in ${validateProps.getTagNameWithoutPrefix(host)} but got ${currentStateCount}.`);
	    }
	};
	const syncStepperHorizontalItemsProps = (host, theme) => {
	    for (const item of Array.from(host.children)) {
	        item.theme = theme;
	        validateProps.forceUpdate(item);
	    }
	};

	const getClickedItem = (host, tagName, targets) => {
	    const item = validateProps.getPrefixedTagNames(host)[validateProps.paramCaseToCamelCase(tagName)];
	    return targets.find((x) => x.tagName?.toLowerCase() === item);
	};

	const propTypes$1 = {
	    size: validateProps.AllowedTypes.breakpoint(STEPPER_HORIZONTAL_SIZES),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const StepperHorizontal = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.stepChange = validateProps.createEvent(this, "stepChange", 3);
	        this.update = validateProps.createEvent(this, "update", 3);
	        this.stepperHorizontalItems = [];
	        this.onClickScroller = (e) => {
	            const target = getClickedItem(this.host, 'p-stepper-horizontal-item', e.composedPath());
	            if (target) {
	                const clickedStepIndex = this.stepperHorizontalItems.indexOf(target);
	                this.update.emit({ activeStepIndex: clickedStepIndex });
	                this.stepChange.emit({ activeStepIndex: clickedStepIndex });
	            }
	        };
	        this.validateComponent = () => {
	            throwIfChildrenAreNotOfKind.throwIfChildrenAreNotOfKind(this.host, 'p-stepper-horizontal-item');
	            throwIfChildCountIsExceeded(this.host, 9);
	            this.stepperHorizontalItems = Array.from(this.host.children);
	            throwIfMultipleCurrentStates(this.host, this.stepperHorizontalItems);
	        };
	        this.scrollIntoView = () => {
	            const newStepIndex = getIndexOfStepWithStateCurrent(this.stepperHorizontalItems);
	            // If state is set to undefined index is -1
	            if (newStepIndex !== -1) {
	                const scrollActivePosition = scrolling.getScrollActivePosition(this.stepperHorizontalItems, newStepIndex > this.currentStepIndex ? 'next' : 'prev', newStepIndex, this.scrollerElement);
	                this.currentStepIndex = newStepIndex;
	                this.scrollerElement.scrollToPosition = {
	                    scrollPosition: scrollActivePosition,
	                    isSmooth: true,
	                };
	            }
	        };
	        this.observeBreakpointChange = () => {
	            if (typeof validateProps.parseJSON(this.size) === 'object') {
	                validateProps.observeBreakpointChange(this.host, this.scrollIntoView);
	            }
	        };
	        this.onSlotChange = () => {
	            this.validateComponent();
	            this.currentStepIndex = getIndexOfStepWithStateCurrent(this.stepperHorizontalItems);
	            this.scrollIntoView();
	        };
	        this.size = 'small';
	        this.theme = 'light';
	    }
	    connectedCallback() {
	        this.validateComponent(); // on every reconnect
	        this.observeBreakpointChange();
	    }
	    componentWillLoad() {
	        // Initial validation
	        this.validateComponent();
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    componentDidLoad() {
	        this.currentStepIndex = getIndexOfStepWithStateCurrent(this.stepperHorizontalItems);
	        this.observeBreakpointChange();
	        // Sometimes lifecycle gets called after disconnectedCallback()
	        if (this.scrollerElement) {
	            // Initial scroll current into view
	            this.scrollerElement.scrollToPosition = {
	                scrollPosition: scrolling.getScrollActivePosition(this.stepperHorizontalItems, 'next', this.currentStepIndex, this.scrollerElement),
	                isSmooth: false,
	            };
	        }
	        // TODO: would be great to use this in jsx but that doesn't work reliable and causes jsdom-polyfill unit test to fail
	        validateProps.getShadowRootHTMLElement(this.host, 'slot').addEventListener('slotchange', this.onSlotChange);
	    }
	    componentDidUpdate() {
	        throwIfMultipleCurrentStates(this.host, this.stepperHorizontalItems);
	        this.scrollIntoView();
	    }
	    disconnectedCallback() {
	        validateProps.unobserveBreakpointChange(this.host);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes$1);
	        validateProps.attachComponentCss(this.host, getComponentCss$1, this.size);
	        syncStepperHorizontalItemsProps(this.host, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(validateProps.Host, { key: 'c59df652b87a1664990f0d4d2b9a27600ac08eaf' }, validateProps.h(PrefixedTagNames.pScroller, { key: 'bfca6e27c0430c8231cd25e01e3c5f15029f5e4c', class: "scroller", aria: { role: 'list' }, theme: this.theme, onClick: this.onClickScroller, ref: (el) => (this.scrollerElement = el) }, validateProps.h("slot", { key: '8657f4a6136b97e5b66c8f3426cf88a640dbe5ef' }))));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	const STEPPER_ITEM_STATES = ['current', 'complete', 'warning'];
	const isStateCompleteOrWarning = (state) => {
	    return state === 'complete' || state === 'warning';
	};
	const getStepperHorizontalIconName = (state) => {
	    return state === 'complete' ? 'success' : 'warning';
	};
	const throwIfCurrentAndDisabled = (host) => {
	    if (host.state === 'current' &&
	        host.disabled) {
	        validateProps.throwException(`using state='current' and disabled='true' for ${validateProps.getTagNameWithoutPrefix(host)} is not allowed.`);
	    }
	};
	const isItemClickable = (state, disabled) => {
	    return !!state && isStateCompleteOrWarning(state) && !disabled;
	};

	const getSVGPath = (stepCount, numberedCircleColors, isStateCurrent) => {
	    // # of the hex color starts a fragment identifier in URLs, so we have to replace it with the escaped value of # = %23
	    const escapedNumberedCircleColors = Object.entries(numberedCircleColors).reduce((result, [key, value]) => ({ ...result, [key]: getInlineSVGBackgroundImage.escapeHashCharacter(value) }), {});
	    const { disabledColor, invertedBaseColor, primaryColor } = escapedNumberedCircleColors;
	    const fillColor = isStateCurrent ? invertedBaseColor : disabledColor;
	    const svgCirclePath = `<circle fill="${isStateCurrent ? primaryColor : 'none'}"${isStateCurrent ? '' : ` stroke="${fillColor}"`} stroke-width="1px" cx="12" cy="12" r="9"/>`;
	    // Full SVG is provided by design (./numbers_raw.svg), created with illustrator and optimized with ImageOptim.
	    // The optimized file can be found in ./numbers_optim.svg.
	    // TODO: could certainly be optimized size wise by exporting icons larger and having less decimals
	    const svgNumberedCirclePaths = [
	        `${svgCirclePath}<path fill="${fillColor}" d="m12.33 8.67-2.43.91v-.94l2.6-1.03h.85v8.78h-1.02z"/>`,
	        `${svgCirclePath}<path fill="${fillColor}" d="m9.46 15.58c0-1.35.73-2.07 1.7-2.72l.95-.63c.78-.52 1.57-1.05 1.57-2.24 0-1.12-.62-1.58-1.7-1.58s-1.68.48-1.78 1.97h-.96c.06-1.82.78-2.91 2.74-2.91s2.72.92 2.72 2.52-.92 2.23-1.79 2.8l-.95.63c-1.11.75-1.52 1.18-1.52 2.01v.16h4.17v.81h-5.15v-.81z"/>`,
	        `${svgCirclePath}<path fill="${fillColor}" d="m10.1 13.73c.1 1.43.63 2 1.92 2 1.2 0 1.8-.49 1.8-1.68 0-1.08-.51-1.66-1.8-1.66h-.89v-.9h.83c1.12 0 1.66-.56 1.66-1.53 0-1.08-.64-1.55-1.73-1.55s-1.69.49-1.79 1.97h-.97c.1-1.79.84-2.91 2.76-2.91s2.74.92 2.74 2.49c0 .79-.38 1.54-1.16 1.9.84.28 1.36.92 1.36 2.19 0 1.54-.97 2.49-2.81 2.49-1.96 0-2.8-.9-2.88-2.81z"/>`,
	        `${svgCirclePath}<path fill="${fillColor}" d="m8.87 13.6 3.54-5.99h1.43v5.89h1.25v.86h-1.25v2.02h-.99v-2.02h-3.98zm3.98-.1v-4.98l-2.91 4.98z"/>`,
	        `${svgCirclePath}<path fill="${fillColor}" d="m9.34 12.45.42-4.83h4.71v.94h-3.9l-.26 2.95c.38-.43 1-.68 1.79-.68 1.86 0 2.76.9 2.76 2.81 0 2.06-1.03 2.91-2.86 2.91s-2.74-.84-2.81-2.51h.97c.06 1.13.57 1.7 1.84 1.7 1.39 0 1.85-.68 1.85-2.06s-.48-2-1.85-2c-1.07 0-1.54.42-1.75 1.17h-.91v-.39z"/>`,
	        `${svgCirclePath}<path fill="${fillColor}" d="m9.97 11.02 2.22-3.4h1.1l-2.27 3.44c.33-.16.69-.23 1.1-.23 1.84 0 2.76.9 2.76 2.81 0 2.06-1.04 2.91-2.86 2.91s-2.87-.85-2.87-2.91c0-1.08.3-1.8.83-2.61zm2.05 4.71c1.38 0 1.84-.68 1.84-2.05s-.47-2.01-1.84-2.01-1.85.64-1.85 2.01.46 2.05 1.85 2.05z"/>`,
	        `${svgCirclePath}<path fill="${fillColor}" d="m9.21 7.61h5.57v.74l-3.58 8.04h-1.05l3.54-7.84h-4.49v-.94z"/>`,
	        `${svgCirclePath}<path fill="${fillColor}" d="m10.47 11.94c-.65-.33-1.13-.92-1.13-2.01 0-1.53.85-2.47 2.66-2.47s2.66.94 2.66 2.47c0 1.08-.47 1.68-1.15 2.01.92.35 1.34 1.07 1.34 2.11 0 1.73-.99 2.49-2.86 2.49s-2.86-.76-2.86-2.49c0-1.04.41-1.76 1.33-2.11zm1.53 3.78c1.27 0 1.85-.51 1.85-1.69 0-1.1-.58-1.61-1.85-1.61s-1.85.52-1.85 1.61c0 1.18.58 1.69 1.85 1.69zm1.65-5.76c0-1.1-.56-1.56-1.65-1.56s-1.65.47-1.65 1.56c0 1 .46 1.6 1.65 1.6s1.65-.6 1.65-1.6z"/>`,
	        `${svgCirclePath}<path fill="${fillColor}" d="m9.16 10.33c0-2.03 1.02-2.86 2.83-2.86s2.82.81 2.82 2.85c0 1.11-.3 1.82-.81 2.64l-2.18 3.44h-1.1l2.18-3.37c-.31.14-.65.2-1.01.2-1.82 0-2.74-.99-2.74-2.9zm4.65 0c0-1.23-.47-1.92-1.81-1.92s-1.81.69-1.81 1.92c0 1.37.49 2.05 1.81 2.05s1.81-.68 1.81-2.05z"/>`,
	    ];
	    return svgNumberedCirclePaths[stepCount];
	};
	const getComponentCss = (state, disabled, theme) => {
	    const { primaryColor, hoverColor, disabledColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, hoverColor: hoverColorDark, disabledColor: disabledColorDark, } = validateProps.getThemedColors('dark');
	    const isStateCurrent = state === 'current';
	    const isStateCurrentOrUndefined = !state || isStateCurrent;
	    const isDisabled = !state || disabled;
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                ...(isStateCurrentOrUndefined &&
	                    Array.from(new Array(9)).reduce((result, _, i) => ({
	                        ...result,
	                        [`&(:nth-of-type(${i + 1})) $button::before`]: {
	                            backgroundImage: getInlineSVGBackgroundImage.getInlineSVGBackgroundImage(getSVGPath(i, {
	                                primaryColor,
	                                invertedBaseColor: validateProps.getInvertedThemedColors(theme).primaryColor,
	                                disabledColor,
	                            }, isStateCurrent)),
	                            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                                backgroundImage: getInlineSVGBackgroundImage.getInlineSVGBackgroundImage(getSVGPath(i, {
	                                    primaryColor: primaryColorDark,
	                                    invertedBaseColor: validateProps.getInvertedThemedColors('dark').primaryColor,
	                                    disabledColor: disabledColorDark,
	                                }, isStateCurrent)),
	                            }),
	                        },
	                    }), {})),
	                ...validateProps.addImportantToEachRule({
	                    fontSize: 'inherit',
	                    ...colorSchemeStyles.hostHiddenStyles,
	                    '&(:not(:last-of-type))': {
	                        marginInlineEnd: spacingFluidXSmall.spacingFluidXSmall,
	                    },
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            button: {
	                display: 'flex',
	                position: 'relative',
	                gap: '3px',
	                color: isDisabled ? disabledColor : primaryColor,
	                padding: '4px 10px 4px 6px',
	                margin: 0, // Removes default button margin on safari 15
	                background: 0,
	                border: 0,
	                ...textSmallStyle.textSmallStyle,
	                fontSize: 'inherit',
	                width: 'max-content',
	                cursor: isDisabled ? 'not-allowed' : 'pointer',
	                borderRadius: borderRadiusSmall.borderRadiusSmall,
	                ...(isStateCurrent && {
	                    ...frostedGlassStyle.frostedGlassStyle,
	                    background: hoverColor,
	                }),
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: isDisabled ? disabledColorDark : primaryColorDark,
	                    ...(isStateCurrent && {
	                        background: hoverColorDark,
	                    }),
	                }),
	                ...(!isDisabled &&
	                    hoverMediaQuery.hoverMediaQuery({
	                        transition: validateProps.getTransition('background-color'),
	                        '&:hover': {
	                            ...frostedGlassStyle.frostedGlassStyle,
	                            background: hoverColor,
	                            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                                background: hoverColorDark,
	                            }),
	                        },
	                    })),
	                ...(isStateCurrentOrUndefined && {
	                    // counter
	                    // Pseudo element is needed to center the counter to the text, as it is not working optimal directly on the button
	                    '&::before': {
	                        content: '""',
	                        height: fontLineHeight.fontLineHeight,
	                        width: fontLineHeight.fontLineHeight,
	                    },
	                }),
	                ...validateProps.getFocusJssStyle(theme, { offset: '-2px' }),
	            },
	        },
	        ...(!isStateCurrentOrUndefined && {
	            // complete / warning icons via icon component
	            icon: {
	                height: fontLineHeight.fontLineHeight,
	                width: fontLineHeight.fontLineHeight,
	            },
	        }),
	        'sr-only': validateProps.getHiddenTextJssStyle(),
	    });
	};

	const propTypes = {
	    state: validateProps.AllowedTypes.oneOf([undefined, ...STEPPER_ITEM_STATES]),
	    disabled: validateProps.AllowedTypes.boolean,
	};
	const StepperHorizontalItem = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.state = undefined;
	        this.disabled = false;
	    }
	    onClick(e) {
	        if (!isItemClickable(this.state, this.disabled)) {
	            e.stopPropagation();
	        }
	    }
	    onStateChange() {
	        throwIfChildrenAreNotOfKind.updateParent(this.host);
	    }
	    connectedCallback() {
	        throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-stepper-horizontal');
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        throwIfCurrentAndDisabled(this.host);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.state, this.disabled, this.host.theme || 'light');
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(validateProps.Host, { key: '0eed47ae3f14a66e1f4b7db2494c0e312d289d9d', role: "listitem" }, validateProps.h("button", { key: 'bdeec94e354d4cdcdb983e6e22b2cbea56420dae', type: "button", "aria-disabled": !this.state || this.disabled ? 'true' : null, "aria-current": this.state === 'current' ? 'step' : null }, isStateCompleteOrWarning(this.state) && (validateProps.h(PrefixedTagNames.pIcon, { key: '470b153eb5e9d72c29efc76213caefd1cacd1b69', class: "icon", name: getStepperHorizontalIconName(this.state), size: "inherit", theme: this.host.theme || 'light', color: this.disabled ? 'state-disabled' : `notification-${getStepperHorizontalIconName(this.state)}`, "aria-hidden": "true" })), this.state && validateProps.h("span", { key: '20d2ddfd1eddc24a9708a0d2e6715b21af813bd4', class: "sr-only" }, this.state, ": "), validateProps.h("slot", { key: '5fb546b6b0e59523c79f29693d3d8bdcbd5ebec6' }))));
	    }
	    static get delegatesFocus() { return true; }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "state": ["onStateChange"]
	    }; }
	};

	pStepperHorizontal_2_cjs_entry.p_stepper_horizontal = StepperHorizontal;
	pStepperHorizontal_2_cjs_entry.p_stepper_horizontal_item = StepperHorizontalItem;

	
	return pStepperHorizontal_2_cjs_entry;
}

var pSwitch_cjs_entry = {};

var hasRequiredPSwitch_cjs_entry;

function requirePSwitch_cjs_entry () {
	if (hasRequiredPSwitch_cjs_entry) return pSwitch_cjs_entry;
	hasRequiredPSwitch_cjs_entry = 1;

	Object.defineProperty(pSwitch_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const isDisabledOrLoading = requireIsDisabledOrLoadingB1f56d7f();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed91ceea3c();
	const theme = requireThemeBfc10573();
	const alignLabel = requireAlignLabel7a9d9074();
	const slottedAnchorStyles = requireSlottedAnchorStylesFe1a10c2();
	const loadingMessageStyles = requireLoadingMessageStyles100c7f01();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();
	const fontFamily = requireFontFamily23874d28();
	const textSmallStyle = requireTextSmallStyle00e1c6e2();
	const fontLineHeight = requireFontLineHeightD4b9e1a9();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const getButtonBaseAriaAttributes = requireGetButtonBaseAriaAttributes84dbc1f1();
	requireHelper22e15c0e();
	requireBorderRadiusSmall5f37fc45();
	requireBorderRadiusMedium758b9411();
	requireTextShared5216bb19();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();

	const cssVarInternalSwitchScaling = '--p-internal-switch-scaling';
	const getColors = (checked, disabled, loading, theme) => {
	    const { primaryColor, contrastMediumColor, successColor, successColorDarken, disabledColor } = validateProps.getThemedColors(theme);
	    const { backgroundColor: lightThemeBackgroundColor } = validateProps.getThemedColors('light');
	    const { canvasColor, canvasTextColor } = validateProps.getHighContrastColors();
	    const checkedColor = validateProps.isHighContrastMode ? canvasTextColor : successColor;
	    const disabledOrLoadingColor = isDisabledOrLoading.isDisabledOrLoading(disabled, loading) && disabledColor;
	    return {
	        buttonBorderColor: disabledOrLoadingColor || (checked ? checkedColor : contrastMediumColor),
	        buttonBorderColorHover: checked ? (validateProps.isHighContrastMode ? primaryColor : successColorDarken) : primaryColor,
	        buttonBackgroundColor: checked ? disabledOrLoadingColor || checkedColor : 'transparent',
	        buttonBackgroundColorHover: checked ? (validateProps.isHighContrastMode ? checkedColor : successColorDarken) : 'transparent',
	        toggleBackgroundColor: (loading && 'transparent') ||
	            (disabled && !checked && disabledColor) ||
	            (checked
	                ? validateProps.isHighContrastMode
	                    ? canvasColor
	                    : lightThemeBackgroundColor
	                : validateProps.isHighContrastMode
	                    ? canvasTextColor
	                    : primaryColor),
	        toggleBackgroundColorHover: checked
	            ? lightThemeBackgroundColor
	            : validateProps.isHighContrastMode
	                ? canvasTextColor
	                : primaryColor,
	        textColor: disabledOrLoadingColor || primaryColor,
	    };
	};
	const getComponentCss = (alignLabel, hideLabel, stretch, checked, disabled, loading, compact, theme) => {
	    const { buttonBorderColor, buttonBorderColorHover, buttonBackgroundColor, buttonBackgroundColorHover, toggleBackgroundColor, toggleBackgroundColorHover, textColor, } = getColors(checked, disabled, loading, theme);
	    const { buttonBorderColor: buttonBorderColorDark, buttonBorderColorHover: buttonBorderColorHoverDark, buttonBackgroundColor: buttonBackgroundColorDark, buttonBackgroundColorHover: buttonBackgroundColorHoverDark, toggleBackgroundColor: toggleBackgroundColorDark, toggleBackgroundColorHover: toggleBackgroundColorHoverDark, textColor: textColorDark, } = getColors(checked, disabled, loading, 'dark');
	    const minimumTouchTargetSize = '24px'; // Minimum touch target size to comply with accessibility guidelines.
	    const scalingVar = `var(${cssVarInternalSwitchScaling}, ${compact ? 0.6668 : 1})`;
	    // Determines the scaling factor for the switch size. In "compact" mode, it uses 0.6668 to achieve a 20px switch (compact size).
	    // Defaults to 1 for the standard size and can be overridden by the CSS variable `cssVarInternalSwitchScaling`.
	    const dimension = `calc(max(${validateProps.SCALING_BASE_VALUE} * 0.75, ${scalingVar} * ${fontLineHeight.fontLineHeight}))`;
	    // Calculates the switch size and ensures a minimum size of 12px (0.75 * SCALING_BASE_VALUE).
	    // Scales proportionally with the line height and the scaling factor.
	    const dimensionFull = `calc(${dimension} + ${validateProps.borderWidthBase} * 2)`; // Calculates the total size of the switch including its borders.
	    const touchTargetSizeDiff = `calc(${minimumTouchTargetSize} - ${dimensionFull})`; // Difference between the minimum touch target size and the switch full size.
	    const gap = `max(${spacingStaticXSmall.spacingStaticXSmall}, calc(${spacingStaticSmall.spacingStaticSmall} - (max(0px, ${touchTargetSizeDiff}))))`;
	    // Adjusts padding to maintain consistent spacing when the switch is smaller than the minimum touch target size.
	    // Uses asymmetric padding instead of `gap` to ensure there is no non-clickable area between the label and the input.
	    const marginTop = `max(0px, calc((${fontLineHeight.fontLineHeight} - ${dimensionFull}) / 2))`; // Vertically centers the switch label relative to the switch size (depending on which is smaller).
	    const paddingTop = `max(0px, calc((${dimensionFull} - ${fontLineHeight.fontLineHeight}) / 2))`; // Vertically centers the switch label relative to the switch size (depending on which is smaller).
	    const inset = `calc(-${validateProps.borderWidthBase} - max(0px, ${touchTargetSizeDiff} / 2))`; // Positions the switch ::before pseudo-element with a negative offset to align it with the touch target.
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                ...validateProps.buildResponsiveStyles(stretch, (stretchValue) => ({
	                    display: stretchValue ? 'flex' : 'inline-flex',
	                })),
	                ...validateProps.addImportantToEachRule({
	                    outline: 0, // custom element is able to delegate the focus
	                    font: `${fontSizeTextSmall.fontSizeTextSmall} ${fontFamily.fontFamily}`, // needed for correct gap definition based on ex-unit
	                    gap,
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                    ...validateProps.buildResponsiveStyles(stretch, (stretchValue) => ({
	                        justifyContent: stretchValue ? 'space-between' : 'flex-start',
	                        width: stretchValue ? '100%' : 'auto', // prevents adjusting its size when used as flex or grid child
	                        ...(!stretchValue && { verticalAlign: 'top' }),
	                    })),
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            button: {
	                position: 'relative', // ensures relative positioning for ::before pseudo element
	                display: 'flex',
	                alignItems: 'center',
	                flexShrink: 0,
	                width: `calc(${dimension} * 2 - ${validateProps.borderWidthBase} * 2)`,
	                height: dimension,
	                font: `${fontSizeTextSmall.fontSizeTextSmall} ${fontFamily.fontFamily}`, // needed for correct width and height definition based on ex-unit
	                boxSizing: 'content-box',
	                border: `${validateProps.borderWidthBase} solid ${buttonBorderColor}`,
	                borderRadius: `calc((${dimension} + ${validateProps.borderWidthBase} * 2) / 2)`,
	                backgroundColor: buttonBackgroundColor,
	                cursor: isDisabledOrLoading.isDisabledOrLoading(disabled, loading) ? 'not-allowed' : 'pointer',
	                transition: `${validateProps.getTransition('background-color')}, ${validateProps.getTransition('border-color')}, ${validateProps.getTransition('color')}`,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    borderColor: buttonBorderColorDark,
	                    backgroundColor: buttonBackgroundColorDark,
	                }),
	                margin: 0, // Removes default button margin on safari 15
	                padding: 0,
	                marginTop,
	                WebkitAppearance: 'none', // iOS safari
	                appearance: 'none',
	                ...(!isDisabledOrLoading.isDisabledOrLoading(disabled, loading) &&
	                    hoverMediaQuery.hoverMediaQuery({
	                        '&:hover': {
	                            borderColor: buttonBorderColorHover,
	                            backgroundColor: buttonBackgroundColorHover,
	                            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                                borderColor: buttonBorderColorHoverDark,
	                                backgroundColor: buttonBackgroundColorHoverDark,
	                            }),
	                            '& .toggle': {
	                                backgroundColor: toggleBackgroundColorHover,
	                                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                                    backgroundColor: toggleBackgroundColorHoverDark,
	                                }),
	                            },
	                        },
	                    })),
	                ...validateProps.getFocusJssStyle(theme),
	                '&::before': {
	                    // Ensures the touch target is at least 24px, even if the switch is smaller than the minimum touch target size.
	                    // This pseudo-element expands the clickable area without affecting the visual size of the switch itself.
	                    content: '""',
	                    position: 'absolute',
	                    inset,
	                },
	            },
	            label: {
	                ...textSmallStyle.textSmallStyle,
	                minWidth: 0, // prevents flex child to overflow max available parent size
	                minHeight: 0, // prevents flex child to overflow max available parent size
	                cursor: isDisabledOrLoading.isDisabledOrLoading(disabled, loading) ? 'not-allowed' : 'pointer',
	                color: textColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: textColorDark,
	                }),
	                ...validateProps.mergeDeep(validateProps.buildResponsiveStyles(alignLabel, (alignLabelValue) => ({
	                    // TODO: we should remove 'left' here and map the value in the component class already to 'start' but might be difficult due to breakpoint customizable prop value
	                    order: alignLabelValue === 'left' || alignLabelValue === 'start' ? -1 : 0,
	                })), validateProps.buildResponsiveStyles(hideLabel, (isHidden) => validateProps.getHiddenTextJssStyle(isHidden, {
	                    paddingTop,
	                }))),
	            },
	        },
	        toggle: {
	            display: 'flex',
	            placeItems: 'center',
	            placeContent: 'center',
	            width: `calc(${dimension} - ${validateProps.borderWidthBase} * 2)`,
	            height: `calc(${dimension} - ${validateProps.borderWidthBase} * 2)`,
	            borderRadius: '50%',
	            backgroundColor: toggleBackgroundColor,
	            transition: `${validateProps.getTransition('background-color')}, ${validateProps.getTransition('transform')}`,
	            transform: `translate3d(${checked ? `calc(100% + ${validateProps.borderWidthBase})` : validateProps.borderWidthBase}, 0, 0)`,
	            '&:dir(rtl)': {
	                transform: `translate3d(calc(${checked ? `calc(100% + ${validateProps.borderWidthBase})` : validateProps.borderWidthBase} * -1), 0, 0)`,
	            },
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                backgroundColor: toggleBackgroundColorDark,
	            }),
	        },
	        ...(loading && {
	            spinner: {
	                width: dimensionFull,
	                height: dimensionFull,
	            },
	        }),
	        // .loading
	        ...loadingMessageStyles.getFunctionalComponentLoadingMessageStyles(),
	    });
	};

	const getSwitchButtonAriaAttributes = (isDisabled, isLoading, isChecked) => {
	    return {
	        ...getButtonBaseAriaAttributes.getButtonBaseAriaAttributes(isDisabled, isLoading),
	        'aria-checked': isChecked ? 'true' : 'false',
	    };
	};

	const propTypes = {
	    alignLabel: validateProps.AllowedTypes.breakpoint(alignLabel.ALIGN_LABELS),
	    hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	    stretch: validateProps.AllowedTypes.breakpoint('boolean'),
	    checked: validateProps.AllowedTypes.boolean,
	    disabled: validateProps.AllowedTypes.boolean,
	    loading: validateProps.AllowedTypes.boolean,
	    compact: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Switch = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.switchChange = validateProps.createEvent(this, "switchChange", 3);
	        this.update = validateProps.createEvent(this, "update", 3);
	        this.initialLoading = false;
	        this.onSwitchClick = () => {
	            this.update.emit({ checked: !this.checked });
	            this.switchChange.emit({ checked: !this.checked });
	        };
	        this.alignLabel = 'end';
	        this.hideLabel = false;
	        this.stretch = false;
	        this.checked = false;
	        this.disabled = false;
	        this.loading = false;
	        this.compact = false;
	        this.theme = 'light';
	    }
	    onClick(e) {
	        if (isDisabledOrLoading.isDisabledOrLoading(this.disabled, this.loading)) {
	            e.stopPropagation();
	        }
	    }
	    connectedCallback() {
	        this.initialLoading = this.loading;
	        validateProps.applyConstructableStylesheetStyles(this.host, slottedAnchorStyles.getSlottedAnchorStyles);
	    }
	    componentWillLoad() {
	        this.initialLoading = this.loading;
	    }
	    componentWillUpdate() {
	        if (this.loading) {
	            this.initialLoading = true;
	        }
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        const alignLabelDeprecationMap = {
	            left: 'start',
	            right: 'end',
	        };
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'alignLabel', alignLabelDeprecationMap);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.alignLabel, this.hideLabel, this.stretch, this.checked, this.disabled, this.loading, this.compact, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(validateProps.Host, { key: '8e6ad8572d0ca559c0e465abb3a1b99f0c9639e3' }, validateProps.h("button", { key: '7f3ec1d48cb53b34a1079122371320baaf20481b', ...getSwitchButtonAriaAttributes(this.disabled, this.loading, this.checked), id: "switch", type: "button", role: "switch", "aria-labelledby": "label" // only relevant for axe-core because of https://github.com/dequelabs/axe-core/issues/1393
	            ,
	            "aria-describedby": this.loading ? loadingMessageStyles.loadingId : undefined, onClick: this.onSwitchClick }, validateProps.h("span", { key: 'd5317ebf21ed076d25fa724908a09cf5e3900247', class: "toggle" }, this.loading && (validateProps.h(PrefixedTagNames.pSpinner, { key: '18aad995db2622c6f93f76bfd18f13ede24db097', class: "spinner", size: "inherit", theme: this.theme, "aria-hidden": "true" })))), validateProps.h("label", { key: '605bbc4ac1d2e9af5e1071857dc75ffdcec7de96', id: "label", htmlFor: "switch" }, validateProps.h("slot", { key: '9c88a181c39f656dfd03a46bc40587ec003ad823' })), validateProps.h(loadingMessageStyles.LoadingMessage, { key: '574716a1bf70bf7cb2af53acacaa1988d42ed3ab', loading: this.loading, initialLoading: this.initialLoading })));
	    }
	    static get delegatesFocus() { return true; }
	    get host() { return validateProps.getElement(this); }
	};

	pSwitch_cjs_entry.p_switch = Switch;

	
	return pSwitch_cjs_entry;
}

var pTable_7_cjs_entry = {};

var hasRequiredPTable_7_cjs_entry;

function requirePTable_7_cjs_entry () {
	if (hasRequiredPTable_7_cjs_entry) return pTable_7_cjs_entry;
	hasRequiredPTable_7_cjs_entry = 1;

	Object.defineProperty(pTable_7_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const hasNamedSlot = requireHasNamedSlot273cd3ae();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const schemedHighContrastMediaQuery = requireSchemedHighContrastMediaQuery462417a0();
	const textSmallStyle = requireTextSmallStyle00e1c6e2();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const spacingFluidMedium = requireSpacingFluidMedium88ab712b();
	const slottedAnchorStyles = requireSlottedAnchorStylesFe1a10c2();
	const throwIfParentIsNotOfKind = requireThrowIfParentIsNotOfKindE0807bbc();
	const spacingFluidSmall = requireSpacingFluidSmall2c6caae7();
	const fontSizeTextXSmall = requireFontSizeTextXSmallE59d35d7();
	const fontLineHeight = requireFontLineHeightD4b9e1a9();
	const fontWeightSemiBold = requireFontWeightSemiBold4482c830();
	const getAttribute = requireGetAttribute9c66ed26();
	const hasAttribute = requireHasAttributeBf22c03a();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const frostedGlassStyle = requireFrostedGlassStyleBd067e45();
	requireGetNamedSlot223c478a();
	requireTextShared5216bb19();
	requireFontFamily23874d28();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireBorderRadiusMedium758b9411();
	requireIsParentOfKind4b323732();

	const throwIfElementHasAttribute = (el, name) => {
	    if (hasAttribute.hasAttribute(el, name)) {
	        validateProps.throwException(`attribute ${name}='${getAttribute.getAttribute(el, name)}' needs to be set as property.`);
	    }
	};

	const cssVariableTablePadding = '--p-internal-table-padding';
	const cssVariableTableHoverColor = '--p-internal-table-hover-color';
	const cssVariableTableBorderColor = '--p-internal-table-border-color';
	const cssVariableTableBorderWidth = '--p-internal-table-border-width';
	const cssVariableTableHeadCellIconFilter = '--p-internal-table-head-cell-icon-filter';
	const getComponentCss$6 = (compact, layout, theme) => {
	    const { primaryColor, hoverColor, contrastLowColor } = validateProps.doGetThemedColors(theme);
	    const { primaryColor: primaryColorDark, hoverColor: hoverColorDark, contrastLowColor: contrastLowColorDark, } = validateProps.doGetThemedColors('dark');
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...textSmallStyle.textSmallStyle,
	                    color: primaryColor,
	                    textAlign: 'start',
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        color: primaryColorDark,
	                    }),
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            '::slotted(*)': validateProps.addImportantToEachRule({
	                ...(compact && { [cssVariableTablePadding]: spacingStaticSmall.spacingStaticSmall }),
	                [cssVariableTableHoverColor]: hoverColor,
	                [cssVariableTableBorderColor]: contrastLowColor,
	                [cssVariableTableHeadCellIconFilter]: validateProps.isThemeDark(theme) ? 'invert(100%)' : 'none',
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    [cssVariableTableHoverColor]: hoverColorDark,
	                    [cssVariableTableBorderColor]: contrastLowColorDark,
	                    [cssVariableTableHeadCellIconFilter]: 'invert(100%)',
	                }),
	                ...(validateProps.isHighContrastMode &&
	                    schemedHighContrastMediaQuery.getSchemedHighContrastMediaQuery({
	                        [cssVariableTableHeadCellIconFilter]: 'none',
	                    }, {
	                        [cssVariableTableHeadCellIconFilter]: 'invert(100%)',
	                    })),
	            }),
	        },
	        caption: {
	            marginBottom: spacingFluidMedium.spacingFluidMedium,
	        },
	        table: {
	            display: 'table',
	            borderCollapse: 'collapse',
	            // with table-layout: fixed, width: 100% crops border-bottom of p-table-row when scrollable
	            // also relative width units (%, vw) don't work as expected when scrollable or combined with auto columns
	            ...(layout === 'fixed'
	                ? {
	                    tableLayout: 'fixed',
	                    minWidth: '100%',
	                }
	                : { width: '100%' }),
	            whiteSpace: 'nowrap', // shouldn't be inherited for caption, that's why it's defined here
	        },
	    });
	};

	const warnIfCaptionIsMissing = (host, caption) => {
	    if (!caption && !hasNamedSlot.hasNamedSlot(host, 'caption')) {
	        validateProps.consoleWarn(`caption has to be set via property or named slot for component ${validateProps.getTagNameWithoutPrefix(host)} in order to ensure accessibility.`, host);
	    }
	};
	const TABLE_LAYOUTS = ['auto', 'fixed'];
	const SORT_EVENT_NAME = 'internalSortingChange';

	const propTypes$2 = {
	    caption: validateProps.AllowedTypes.string,
	    compact: validateProps.AllowedTypes.boolean,
	    layout: validateProps.AllowedTypes.oneOf(TABLE_LAYOUTS),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Table = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.sortingChange = validateProps.createEvent(this, "sortingChange", 3);
	        this.update = validateProps.createEvent(this, "update", 3);
	        this.caption = undefined;
	        this.compact = false;
	        this.layout = 'auto';
	        this.theme = 'light';
	    }
	    connectedCallback() {
	        validateProps.applyConstructableStylesheetStyles(this.host, slottedAnchorStyles.getSlottedAnchorStyles);
	    }
	    componentWillLoad() {
	        warnIfCaptionIsMissing(this.host, this.caption);
	        this.host.shadowRoot.addEventListener(SORT_EVENT_NAME, (e) => {
	            e.stopPropagation();
	            this.update.emit(e.detail);
	            this.sortingChange.emit(e.detail);
	        });
	    }
	    render() {
	        validateProps.validateProps(this, propTypes$2);
	        validateProps.attachComponentCss(this.host, getComponentCss$6, this.compact, this.layout, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        const hasSlottedCaption = hasNamedSlot.hasNamedSlot(this.host, 'caption');
	        const captionId = 'caption';
	        const tableAttr = this.caption
	            ? { 'aria-label': this.caption }
	            : hasSlottedCaption && { 'aria-labelledby': captionId };
	        return (validateProps.h(validateProps.Host, { key: 'ecf29733884aede4a57d45a0a80dd1dd58db080a' }, hasSlottedCaption && (validateProps.h("div", { key: 'feb0255af198714faad6e7d0ed3e521d9a35d80e', id: captionId, class: "caption" }, validateProps.h("slot", { key: 'c693667535754ed4e042885987e06a0f189954fb', name: "caption" }))), validateProps.h(PrefixedTagNames.pScroller, { key: '809a1089fbea1f9e02698e72dfa9e2d2dd26161b', scrollbar: true, theme: this.theme }, validateProps.h("div", { key: '450ad6e1567d8c73928f4686ad048d3f3a00fed4', class: "table", role: "table", ...tableAttr }, validateProps.h("slot", { key: '7caed1ffa42294cb7b293d73e81739212980468c' })))));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	const getComponentCss$5 = () => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'table-row-group',
	                ...validateProps.addImportantToEachRule(colorSchemeStyles.hostHiddenStyles),
	            },
	        },
	    });
	};

	const TableBody = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	    }
	    connectedCallback() {
	        throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-table');
	    }
	    render() {
	        validateProps.attachComponentCss(this.host, getComponentCss$5);
	        return (validateProps.h(validateProps.Host, { key: 'e0c4051955af0c813ec393a04598e70a228297df', role: "rowgroup" }, validateProps.h("slot", { key: '14203508175ac307366cecd6f34d3a2e3c39c987' })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	const getComponentCss$4 = (multiline) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'table-cell',
	                verticalAlign: 'middle',
	                ...validateProps.addImportantToEachRule({
	                    padding: `var(${cssVariableTablePadding}, ${spacingFluidSmall.spacingFluidSmall})`,
	                    margin: 0,
	                    whiteSpace: multiline ? 'normal' : 'nowrap',
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	        },
	    });
	};

	const propTypes$1 = {
	    multiline: validateProps.AllowedTypes.boolean,
	};
	const TableCell = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.multiline = false;
	    }
	    connectedCallback() {
	        throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-table-row');
	    }
	    render() {
	        validateProps.validateProps(this, propTypes$1);
	        validateProps.attachComponentCss(this.host, getComponentCss$4, this.multiline);
	        return (validateProps.h(validateProps.Host, { key: 'dce04bab3247a1c85b2f7a2bb7635c3399a2d8ee', role: "cell" }, validateProps.h("slot", { key: '9b42638ab3b4574bb3323781400a0163f24a7cfe' })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	const getComponentCss$3 = () => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'table-header-group',
	                ...validateProps.addImportantToEachRule({
	                    fontSize: fontSizeTextXSmall.fontSizeTextXSmall,
	                    lineHeight: fontLineHeight.fontLineHeight,
	                    fontWeight: fontWeightSemiBold.fontWeightSemiBold,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            '::slotted(*)': validateProps.addImportantToEachRule({
	                [cssVariableTableBorderWidth]: '0px',
	                [cssVariableTableHoverColor]: 'none',
	            }),
	        },
	    });
	};

	const TableHead = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	    }
	    connectedCallback() {
	        throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-table');
	    }
	    render() {
	        validateProps.attachComponentCss(this.host, getComponentCss$3);
	        return (validateProps.h(validateProps.Host, { key: '2a98500173d392908fa39d510cec97f0ccfbc7bb', role: "rowgroup" }, validateProps.h("slot", { key: '775d09e09f70ec5c58deb70f726cc4225e4c95c8' })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	const isDirectionAsc = (dir) => dir === 'asc';
	const getAriaSort = (sort) => {
	    return sort?.active ? (isDirectionAsc(sort.direction) ? 'ascending' : 'descending') : null;
	};
	const toggleDirection = (dir) => (isDirectionAsc(dir) ? 'desc' : 'asc');
	const createSortedEventInitDictDetail = (sort) => ({
	    bubbles: true,
	    detail: { ...sort, active: true, direction: sort.active ? toggleDirection(sort.direction) : sort.direction },
	});
	const isSortable = (active, direction) => {
	    return active !== undefined && direction !== undefined;
	};

	const { hoverColor } = validateProps.getThemedColors('light'); // hover color and focus color are the same for light and dark
	const buttonBeforeOffsetVertical = '-2px';
	const buttonBeforeOffsetHorizontal = '-4px';
	const getComponentCss$2 = (active, direction, hideLabel, multiline) => {
	    const sortable = isSortable(active, direction);
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'table-cell',
	                ...validateProps.addImportantToEachRule({
	                    padding: `2px var(${cssVariableTablePadding}, ${spacingFluidSmall.spacingFluidSmall}) var(${cssVariableTablePadding}, ${spacingFluidSmall.spacingFluidSmall})`,
	                    verticalAlign: 'bottom',
	                    whiteSpace: multiline ? 'normal' : 'nowrap',
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            ...(sortable
	                ? {
	                    button: {
	                        position: 'relative',
	                        display: 'flex',
	                        gap: spacingStaticXSmall.spacingStaticXSmall,
	                        width: 'auto',
	                        margin: 0, // Removes default button margin on safari 15
	                        padding: 0,
	                        font: 'inherit',
	                        color: 'inherit',
	                        alignItems: 'flex-end',
	                        WebkitAppearance: 'none', // iOS safari
	                        appearance: 'none',
	                        background: 'transparent',
	                        textAlign: 'start',
	                        border: 0,
	                        zIndex: 0,
	                        cursor: 'pointer',
	                        // TODO: re-think if ::before is still needed
	                        '&::before': {
	                            content: '""',
	                            position: 'absolute',
	                            inset: `${buttonBeforeOffsetVertical} ${buttonBeforeOffsetHorizontal}`,
	                            borderRadius: borderRadiusSmall.borderRadiusSmall,
	                            zIndex: -1, // needed so that text behind element is selectable and/or visible
	                            transition: validateProps.getTransition('background-color'),
	                        },
	                        ...hoverMediaQuery.hoverMediaQuery({
	                            '&:hover, &:focus-visible': {
	                                '& .icon': {
	                                    opacity: 1,
	                                },
	                            },
	                            '&:hover::before': {
	                                ...frostedGlassStyle.frostedGlassStyle,
	                                backgroundColor: hoverColor,
	                            },
	                        }),
	                        // TODO: to be future proof, we need to pass theme parameter
	                        ...validateProps.getFocusJssStyle('light', { pseudo: true, offset: '-2px' }),
	                    },
	                }
	                : hideLabel && {
	                    span: {
	                        ...validateProps.getHiddenTextJssStyle(),
	                        display: 'block',
	                        border: 0,
	                    },
	                }),
	        },
	        ...(sortable && {
	            icon: {
	                transition: validateProps.getTransition('opacity'),
	                opacity: active ? 1 : 0,
	                transform: `rotate3d(0,0,1,${isDirectionAsc(direction) ? 0 : 180}deg)`,
	                transformOrigin: '50% 50%', // for iOS
	                filter: `var(${cssVariableTableHeadCellIconFilter})`,
	            },
	        }),
	    });
	};

	const propTypes = {
	    sort: validateProps.AllowedTypes.shape({
	        id: validateProps.AllowedTypes.string,
	        active: validateProps.AllowedTypes.boolean,
	        direction: validateProps.AllowedTypes.oneOf([undefined, 'asc', 'desc']),
	    }),
	    hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	    multiline: validateProps.AllowedTypes.boolean,
	};
	const TableHeadCell = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.onButtonClick = () => {
	            this.host.dispatchEvent(new CustomEvent(SORT_EVENT_NAME, createSortedEventInitDictDetail(this.sort)));
	        };
	        this.sort = undefined;
	        this.hideLabel = false;
	        this.multiline = false;
	    }
	    connectedCallback() {
	        throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, ['p-table-head-row', 'p-table-row']);
	        throwIfElementHasAttribute(this.host, 'sort');
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        const { active, direction } = this.sort || {};
	        validateProps.attachComponentCss(this.host, getComponentCss$2, active, direction, this.hideLabel, this.multiline);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(validateProps.Host, { key: '3013418385ec0f21a938285b20e5f8542dbf994d', scope: "col", role: "columnheader", "aria-sort": getAriaSort(this.sort) }, isSortable(active, direction) ? (validateProps.h("button", { type: "button", onClick: this.onButtonClick }, validateProps.h("slot", null), validateProps.h(PrefixedTagNames.pIcon, { class: "icon", color: "inherit", size: "x-small", name: "arrow-up", "aria-hidden": "true" }))) : (validateProps.h("span", null, validateProps.h("slot", null)))));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	const getComponentCss$1 = () => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'table-row',
	                ...validateProps.addImportantToEachRule(colorSchemeStyles.hostHiddenStyles),
	            },
	        },
	    });
	};

	const TableHeadRow = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	    }
	    connectedCallback() {
	        throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-table-head');
	    }
	    render() {
	        validateProps.attachComponentCss(this.host, getComponentCss$1);
	        return (validateProps.h(validateProps.Host, { key: '5db6a0f4009cc63c6652ef023af769aaed0d1bd5', role: "row" }, validateProps.h("slot", { key: '2c544eedd5e04201271be1e056910d6afea49f4d' })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	const getComponentCss = () => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'table-row',
	                ...validateProps.addImportantToEachRule({
	                    borderTop: `var(${cssVariableTableBorderWidth},1px) solid var(${cssVariableTableBorderColor})`,
	                    borderBottom: `var(${cssVariableTableBorderWidth},1px) solid var(${cssVariableTableBorderColor})`,
	                    transition: validateProps.getTransition('background'),
	                    ...colorSchemeStyles.hostHiddenStyles,
	                    ...hoverMediaQuery.hoverMediaQuery({
	                        '&(:hover)': {
	                            // ...frostedGlassStyle, // will result in not smooth transition when applied
	                            background: `var(${cssVariableTableHoverColor})`,
	                        },
	                    }),
	                }),
	            },
	        },
	    });
	};

	const TableRow = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	    }
	    connectedCallback() {
	        throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, ['p-table-body', 'p-table-head']);
	    }
	    render() {
	        validateProps.attachComponentCss(this.host, getComponentCss);
	        return (validateProps.h(validateProps.Host, { key: '3d97cd1aba072023500da498ebcde7d5e95089ab', role: "row" }, validateProps.h("slot", { key: '10f8e792bada7e83e543320efe174fa67de3227d' })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pTable_7_cjs_entry.p_table = Table;
	pTable_7_cjs_entry.p_table_body = TableBody;
	pTable_7_cjs_entry.p_table_cell = TableCell;
	pTable_7_cjs_entry.p_table_head = TableHead;
	pTable_7_cjs_entry.p_table_head_cell = TableHeadCell;
	pTable_7_cjs_entry.p_table_head_row = TableHeadRow;
	pTable_7_cjs_entry.p_table_row = TableRow;

	
	return pTable_7_cjs_entry;
}

var pTabs_2_cjs_entry = {};

var tabsBarUtils55e09519 = {};

var hasRequiredTabsBarUtils55e09519;

function requireTabsBarUtils55e09519 () {
	if (hasRequiredTabsBarUtils55e09519) return tabsBarUtils55e09519;
	hasRequiredTabsBarUtils55e09519 = 1;

	const validateProps = requireValidateProps788e2bc5();
	const getAttribute = requireGetAttribute9c66ed26();

	const TABS_BAR_SIZES = ['small', 'medium'];
	/** @deprecated */
	const TABS_BAR_WEIGHTS_DEPRECATED = ['semibold'];
	const TABS_BAR_WEIGHTS = ['regular', 'semi-bold', ...TABS_BAR_WEIGHTS_DEPRECATED];
	const sanitizeActiveTabIndex = (index, tabElementsCount) => {
	    const maxIndex = tabElementsCount - 1; // can be -1 without children
	    if (index === undefined || index === null || maxIndex < 0 || index < 0 || index > maxIndex) {
	        return undefined;
	    }
	    return index;
	};
	const getTransformation = (el = {}) => {
	    const rect = el.getBoundingClientRect();
	    return `transform: translate3d(${el.offsetLeft > 0 ? el.offsetLeft : 0}px,0,0);width: ${rect.width}px`;
	};
	const getPrevNextTabIndex = (direction, tabElementsLength, focusedTabIndex) => {
	    const newTabIndex = focusedTabIndex + (direction === 'next' ? 1 : -1);
	    return (newTabIndex + tabElementsLength) % tabElementsLength;
	};
	const getFocusedTabIndex = (tabElements) => {
	    const indexOfActiveElement = tabElements.indexOf(document.activeElement);
	    return indexOfActiveElement < 0 ? 0 : indexOfActiveElement;
	};
	const setBarStyle = (tabElements, activeTabIndex, barElement) => {
	    // in frameworks, when chunk is already loaded, the watcher for activeTabIndex can trigger
	    // before the component is rendered, therefore barElement is not defined, yet
	    if (barElement) {
	        // el.ariaSelected isn't supported in firefox, therefore we need to read the attribute
	        // https://caniuse.com/mdn-api_element_ariaselected
	        const currentActiveTabElement = tabElements.find((el) => getAttribute.getAttribute(el, 'aria-selected') === 'true' || getAttribute.getAttribute(el, 'aria-current') === 'true');
	        if (currentActiveTabElement) {
	            // for initial activeTabIndex > 0 and resized window with fluid font-size for size="medium"
	            // we need to adjust the starting point of the transition
	            validateProps.setAttribute(barElement, 'style', `transition: none;${getTransformation(currentActiveTabElement)}`);
	        }
	        const newActiveTabElement = tabElements[activeTabIndex];
	        if (newActiveTabElement) {
	            validateProps.setAttribute(barElement, 'style', getTransformation(newActiveTabElement));
	        }
	        // when there was an active item before, we need to reset the animation
	        if (currentActiveTabElement) {
	            // reset animation that hides the bar after the transition
	            barElement.style.animation = 'none';
	            window.requestAnimationFrame(() => (barElement.style.animation = ''));
	        }
	    }
	};

	tabsBarUtils55e09519.TABS_BAR_SIZES = TABS_BAR_SIZES;
	tabsBarUtils55e09519.TABS_BAR_WEIGHTS = TABS_BAR_WEIGHTS;
	tabsBarUtils55e09519.getFocusedTabIndex = getFocusedTabIndex;
	tabsBarUtils55e09519.getPrevNextTabIndex = getPrevNextTabIndex;
	tabsBarUtils55e09519.sanitizeActiveTabIndex = sanitizeActiveTabIndex;
	tabsBarUtils55e09519.setBarStyle = setBarStyle;

	
	return tabsBarUtils55e09519;
}

var hasRequiredPTabs_2_cjs_entry;

function requirePTabs_2_cjs_entry () {
	if (hasRequiredPTabs_2_cjs_entry) return pTabs_2_cjs_entry;
	hasRequiredPTabs_2_cjs_entry = 1;

	Object.defineProperty(pTabs_2_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const setAttributes = requireSetAttributesF96a52a9();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed76f87eda();
	const scrolling = requireScrollingD5dce8b3();
	const theme = requireThemeBfc10573();
	const throwIfChildrenAreNotOfKind = requireThrowIfChildrenAreNotOfKind288748e4();
	const slottedAnchorStyles = requireSlottedAnchorStylesFe1a10c2();
	const tabsBarUtils = requireTabsBarUtils55e09519();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const throwIfParentIsNotOfKind = requireThrowIfParentIsNotOfKindE0807bbc();
	requireHelper22e15c0e();
	requireGetHTMLElements3f1c700f();
	requireBorderRadiusSmall5f37fc45();
	requireBorderRadiusMedium758b9411();
	requireGetAttribute9c66ed26();
	requireIsParentOfKind4b323732();

	const getComponentCss$1 = () => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	        },
	        root: {
	            marginBottom: '8px',
	        },
	    });
	};

	const syncTabsItemsProps = (items, theme) => {
	    for (const item of items) {
	        item.theme = theme;
	        validateProps.forceUpdate(item);
	    }
	};

	const propTypes$1 = {
	    size: validateProps.AllowedTypes.breakpoint(tabsBarUtils.TABS_BAR_SIZES),
	    weight: validateProps.AllowedTypes.oneOf(tabsBarUtils.TABS_BAR_WEIGHTS),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    gradientColorScheme: validateProps.AllowedTypes.oneOf([undefined, ...scrolling.GRADIENT_COLOR_SCHEMES]),
	    gradientColor: validateProps.AllowedTypes.oneOf(scrolling.GRADIENT_COLORS),
	    activeTabIndex: validateProps.AllowedTypes.number,
	};
	const Tabs = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.tabChange = validateProps.createEvent(this, "tabChange", 3);
	        this.update = validateProps.createEvent(this, "update", 3);
	        this.defineTabsItemElements = () => {
	            throwIfChildrenAreNotOfKind.throwIfChildrenAreNotOfKind(this.host, 'p-tabs-item');
	            this.tabsItemElements = Array.from(this.host.children);
	        };
	        this.setAccessibilityAttributes = () => {
	            this.tabsItemElements.forEach((tab, index) => {
	                const attrs = {
	                    role: 'tabpanel',
	                    'aria-label': tab.label,
	                };
	                setAttributes.setAttributes(tab, attrs);
	                if (index === this.activeTabIndex) {
	                    validateProps.removeAttribute(tab, 'hidden');
	                    validateProps.setAttribute(tab, 'tabindex', '0');
	                }
	                else {
	                    validateProps.setAttribute(tab, 'hidden');
	                    validateProps.removeAttribute(tab, 'tabindex');
	                }
	            });
	        };
	        this.onTabsBarUpdate = (e) => {
	            e.stopPropagation(); // prevent double event emission because of identical name
	            this.activeTabIndex = e.detail.activeTabIndex;
	        };
	        this.size = 'small';
	        this.weight = 'regular';
	        this.theme = 'light';
	        this.gradientColorScheme = undefined;
	        this.gradientColor = 'background-base';
	        this.activeTabIndex = 0;
	        this.tabsItemElements = [];
	    }
	    activeTabHandler(newValue) {
	        this.setAccessibilityAttributes();
	        this.update.emit({ activeTabIndex: newValue });
	        this.tabChange.emit({ activeTabIndex: newValue });
	    }
	    connectedCallback() {
	        validateProps.applyConstructableStylesheetStyles(this.host, slottedAnchorStyles.getSlottedAnchorStyles);
	    }
	    componentWillLoad() {
	        this.defineTabsItemElements();
	    }
	    componentDidLoad() {
	        validateProps.getShadowRootHTMLElement(this.host, 'slot').addEventListener('slotchange', this.defineTabsItemElements);
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    componentDidRender() {
	        this.setAccessibilityAttributes();
	    }
	    render() {
	        validateProps.validateProps(this, propTypes$1);
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'gradientColorScheme', 'Please use gradientColor prop instead.');
	        validateProps.attachComponentCss(this.host, getComponentCss$1);
	        syncTabsItemsProps(this.tabsItemElements, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(validateProps.Host, { key: '71ee191d5204e560e111c17da0f6da178bcc1a73' }, validateProps.h(PrefixedTagNames.pTabsBar, { key: 'f280b8a875e1145507c033472e1899fd53933960', class: "root", size: this.size, weight: this.weight, theme: this.theme, gradientColorScheme: this.gradientColorScheme, gradientColor: this.gradientColor, activeTabIndex: this.activeTabIndex, onUpdate: this.onTabsBarUpdate, onTabChange: (e) => e.stopPropagation() }, this.tabsItemElements.map((tab, index) => (validateProps.h("button", { key: index, type: "button" }, tab.label)))), validateProps.h("slot", { key: '8fda43f3956b5c5ffabdf4abd2f7a1a022dfd449' })));
	    }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "activeTabIndex": ["activeTabHandler"]
	    }; }
	};

	const getComponentCss = (theme) => {
	    const { primaryColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark } = validateProps.getThemedColors('dark');
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    color: primaryColor, // enables color inheritance for e.g. slotted anchor
	                    borderRadius: '2px',
	                    ...colorSchemeStyles.hostHiddenStyles,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        color: primaryColorDark,
	                    }),
	                    ...validateProps.getFocusJssStyle(theme, { slotted: true }),
	                }),
	            },
	        },
	    });
	};

	const propTypes = {
	    label: validateProps.AllowedTypes.string,
	};
	const TabsItem = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.label = undefined;
	    }
	    handleLabelChange() {
	        throwIfChildrenAreNotOfKind.updateParent(this.host);
	    }
	    connectedCallback() {
	        throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-tabs');
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.host.theme || 'light' // default as fallback
	        );
	        return validateProps.h("slot", { key: '7eee2749375e014dcd976e2bb60cf9ef57cf5de1' });
	    }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "label": ["handleLabelChange"]
	    }; }
	};

	pTabs_2_cjs_entry.p_tabs = Tabs;
	pTabs_2_cjs_entry.p_tabs_item = TabsItem;

	
	return pTabs_2_cjs_entry;
}

var pTabsBar_cjs_entry = {};

var hasRequiredPTabsBar_cjs_entry;

function requirePTabsBar_cjs_entry () {
	if (hasRequiredPTabsBar_cjs_entry) return pTabsBar_cjs_entry;
	hasRequiredPTabsBar_cjs_entry = 1;

	Object.defineProperty(pTabsBar_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const setAttributes = requireSetAttributesF96a52a9();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed91ceea3c();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed76f87eda();
	const scrolling = requireScrollingD5dce8b3();
	const theme = requireThemeBfc10573();
	const getDirectChildHTMLElements = requireGetDirectChildHTMLElements2594e5bd();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const fontWeightStyles = requireFontWeightStylesB74e8683();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const frostedGlassStyle = requireFrostedGlassStyleBd067e45();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();
	const textSmallStyle = requireTextSmallStyle00e1c6e2();
	const fontSizeText = requireFontSizeText728b6387();
	const tabsBarUtils = requireTabsBarUtils55e09519();
	requireHelper22e15c0e();
	requireGetHTMLElements3f1c700f();
	requireTransformSelectorToDirectChildSelectorEcc1a9c4();
	requireFontWeightRegularD0c768ac();
	requireFontWeightSemiBold4482c830();
	requireTextShared5216bb19();
	requireFontFamily23874d28();
	requireFontLineHeightD4b9e1a9();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireFontSizeTextXXSmallA02f9c40();
	requireFontSizeTextXSmallE59d35d7();
	requireFontSizeTextMedium88887ad8();
	requireFontSizeTextLarge05a4bc90();
	requireFontSizeTextXLarge0ecf9ef3();
	requireGetAttribute9c66ed26();

	const isShadowRootParentOfKind = (element, tagName) => {
	    const parentElement = element.getRootNode().host;
	    return !!(parentElement &&
	        validateProps.getTagName(parentElement) === validateProps.getPrefixedTagNames(element)[validateProps.paramCaseToCamelCase(tagName)]);
	};

	/* eslint-disable prefer-arrow/prefer-arrow-functions */
	function getOnlyChildrenOfKindHTMLElementOrThrow(element, selector) {
	    const directChildren = getDirectChildHTMLElements.getDirectChildHTMLElements(element, selector);
	    const notValid = directChildren.some((child) => child.tagName !== directChildren[0].tagName);
	    if (notValid) {
	        validateProps.throwException(`child HTMLElements of ${validateProps.getTagNameWithoutPrefix(element)} are invalid. Expected all of: ${selector.replace(/,/g, ' or ')}.`);
	    }
	    return directChildren;
	}

	const scrollerAnimatedCssClass = 'scroller--animated';
	const targetSelectors = ['a', 'button'];
	const transformSelector = (selector) => targetSelectors.map((tag) => selector.replace(/\[role]/g, tag)).join();
	const getComponentCss = (size, weight, theme) => {
	    const { primaryColor, hoverColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, hoverColor: hoverColorDark } = validateProps.getThemedColors('dark');
	    const barJssStyle = {
	        position: 'absolute',
	        height: '2px',
	        left: 0,
	        ...(validateProps.isHighContrastMode
	            ? {
	                background: validateProps.getHighContrastColors().canvasTextColor,
	            }
	            : {
	                background: primaryColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    background: primaryColorDark,
	                }),
	            }),
	    };
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    position: 'relative',
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            ...validateProps.addImportantToEachRule({
	                '::slotted': {
	                    // TODO: produces duplicated css code in SSR context, we should try to make use of multiple selector like
	                    //  `::slotted(:is(a,button))`.
	                    ...validateProps.getFocusJssStyle(theme, { slotted: 'a', offset: '1px' }),
	                    ...validateProps.getFocusJssStyle(theme, { slotted: 'button', offset: '1px' }),
	                },
	                // would be nice to use shared selector like '::slotted([role])'
	                // but this doesn't work reliably when rendering in browser
	                [transformSelector('::slotted([role])')]: {
	                    ...validateProps.getResetInitialStylesForSlottedAnchor,
	                    display: 'inline-block',
	                    position: 'relative',
	                    margin: '0 0 4px 0',
	                    verticalAlign: 'top',
	                    // TODO: can we use `all: 'inherit'` instead?
	                    fontFamily: 'inherit',
	                    fontStyle: 'inherit',
	                    fontVariant: 'inherit',
	                    fontWeight: 'inherit',
	                    fontSize: 'inherit',
	                    lineHeight: 'inherit',
	                    whiteSpace: 'nowrap',
	                    boxSizing: 'border-box',
	                    WebkitAppearance: 'none', // iOS safari
	                    appearance: 'none',
	                    outlineOffset: '1px',
	                    textDecoration: 'none',
	                    textAlign: 'start',
	                    border: 0,
	                    color: primaryColor,
	                    cursor: 'pointer',
	                    borderRadius: borderRadiusSmall.borderRadiusSmall,
	                    zIndex: 0, // needed for ::before pseudo element to be visible
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        color: primaryColorDark,
	                    }),
	                    ...hoverMediaQuery.hoverMediaQuery({
	                        '&::before': {
	                            content: '""',
	                            position: 'absolute',
	                            inset: '-2px -4px',
	                            borderRadius: borderRadiusSmall.borderRadiusSmall,
	                            zIndex: -1, // Stack the pseudo-element behind the button to avoid overlay of frosted-glass effect with label text
	                            transition: validateProps.getTransition('background-color'),
	                        },
	                    }),
	                },
	                ...hoverMediaQuery.hoverMediaQuery({
	                    [transformSelector('::slotted([role]:hover)::before')]: {
	                        ...frostedGlassStyle.frostedGlassStyle,
	                        background: hoverColor,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            background: hoverColorDark,
	                        }),
	                    },
	                }),
	                // basic invisible bar, that will be delayed via transition: visibility
	                [transformSelector('::slotted([role])::after')]: {
	                    content: '""',
	                    visibility: 'hidden',
	                },
	                // visible bar for selected tab
	                [transformSelector('::slotted([role][aria-selected="true"])::after, ::slotted([role][aria-current="true"])::after')]: {
	                    ...barJssStyle,
	                    right: '0px',
	                    bottom: validateProps.isHighContrastMode ? '-4px' : '-6px',
	                    visibility: 'inherit',
	                },
	                [transformSelector('::slotted([role]:not(:last-child))')]: {
	                    marginInlineEnd: spacingStaticMedium.spacingStaticMedium,
	                },
	            }),
	        },
	        scroller: {
	            ...textSmallStyle.textSmallStyle,
	            fontWeight: fontWeightStyles.getFontWeight(weight),
	            ...validateProps.buildResponsiveStyles(size, (s) => ({ fontSize: fontSizeText.fontSizeText[s] })),
	        },
	        // conditionally applied and removed based on if activeTabIndex exists
	        [scrollerAnimatedCssClass]: {
	            [`& ${transformSelector('::slotted([role][aria-selected="true"])::after, ::slotted([role][aria-current="true"])::after')}`]: {
	                transition: validateProps.addImportantToRule(`visibility 0s linear var(${validateProps.cssVariableTransitionDuration}, ${validateProps.motionDurationModerate})`), // bar appears after transition
	            },
	        },
	        // moving bar
	        bar: {
	            ...barJssStyle,
	            width: 0, // actual width and transform is set via inline css
	            bottom: validateProps.isHighContrastMode ? '0' : '-2px',
	            visibility: 'inherit',
	            transition: `${validateProps.getTransition('transform', 'moderate')}, ${validateProps.getTransition('width', 'moderate')}`,
	            animation: `$hide 0s var(${validateProps.cssVariableAnimationDuration},0.5s) forwards`, // auto hide bar after transition, needs to be a little longer in Safari
	        },
	        '@keyframes hide': {
	            to: {
	                visibility: 'hidden',
	            },
	        },
	    });
	};

	const propTypes = {
	    size: validateProps.AllowedTypes.breakpoint(tabsBarUtils.TABS_BAR_SIZES),
	    weight: validateProps.AllowedTypes.oneOf(tabsBarUtils.TABS_BAR_WEIGHTS),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    gradientColorScheme: validateProps.AllowedTypes.oneOf([undefined, ...scrolling.GRADIENT_COLOR_SCHEMES]),
	    gradientColor: validateProps.AllowedTypes.oneOf(scrolling.GRADIENT_COLORS),
	    activeTabIndex: validateProps.AllowedTypes.number,
	};
	const TabsBar = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.tabChange = validateProps.createEvent(this, "tabChange", 3);
	        this.update = validateProps.createEvent(this, "update", 3);
	        this.internalTabIndex = this.activeTabIndex; // to not override and mutate external prop value
	        this.direction = 'next';
	        this.setAccessibilityAttributes = () => {
	            this.tabElements.forEach((tab, index) => {
	                const isCurrent = this.internalTabIndex === index;
	                const attrs = this.areTabsButtons
	                    ? {
	                        role: 'tab',
	                        tabindex: this.internalTabIndex ? (isCurrent ? '0' : '-1') : index === 0 ? '0' : '-1',
	                        'aria-selected': isCurrent ? 'true' : 'false',
	                    }
	                    : {
	                        'aria-current': isCurrent ? 'true' : 'false',
	                    };
	                setAttributes.setAttributes(tab, attrs);
	            });
	        };
	        this.setTabElements = () => {
	            this.tabElements = getOnlyChildrenOfKindHTMLElementOrThrow(this.host, 'a,button');
	            this.areTabsButtons = this.tabElements[0]?.tagName === 'BUTTON';
	            this.internalTabIndex = tabsBarUtils.sanitizeActiveTabIndex(this.activeTabIndex, this.tabElements.length); // since watcher doesn't trigger on first render
	        };
	        this.onClick = (e) => {
	            // e.target can be nested span or font element within a or button when page is translated
	            const newTabIndex = this.tabElements.findIndex((el) => el.contains(e.target));
	            if (newTabIndex >= 0) {
	                this.onTabClick(newTabIndex);
	            }
	        };
	        this.onTabClick = (newTabIndex) => {
	            this.update.emit({ activeTabIndex: newTabIndex });
	            this.tabChange.emit({ activeTabIndex: newTabIndex });
	        };
	        this.onKeydown = (e) => {
	            let upcomingFocusedTabIndex;
	            const focusedTabIndex = this.hasPTabsParent ? this.internalTabIndex || 0 : tabsBarUtils.getFocusedTabIndex(this.tabElements);
	            const { target } = e;
	            switch (e.key) {
	                case 'ArrowLeft':
	                case 'Left':
	                    upcomingFocusedTabIndex = tabsBarUtils.getPrevNextTabIndex('prev', this.tabElements.length, focusedTabIndex);
	                    break;
	                case 'ArrowRight':
	                case 'Right':
	                    upcomingFocusedTabIndex = tabsBarUtils.getPrevNextTabIndex('next', this.tabElements.length, focusedTabIndex);
	                    break;
	                case 'Home':
	                    upcomingFocusedTabIndex = 0;
	                    break;
	                case 'End':
	                    upcomingFocusedTabIndex = this.tabElements.length - 1;
	                    break;
	                // the slotted buttons have a different tabbing sequence in chrome and safari and it appears that on hitting
	                // tab the first slotted one with tabindex=0 becomes focused instead of the one after,
	                // therefor the 'Tab' case needs to be handled
	                case 'Tab': {
	                    if (target.matches('button')) {
	                        const { tabIndex } = target;
	                        target.tabIndex = null;
	                        setTimeout(() => {
	                            target.tabIndex = tabIndex;
	                        });
	                    }
	                    return;
	                }
	                default:
	                    return;
	            }
	            if (this.hasPTabsParent) {
	                this.onTabClick(upcomingFocusedTabIndex);
	            }
	            if (target.matches('button')) {
	                this.tabElements[upcomingFocusedTabIndex].focus();
	            }
	            // disable default behavior only for buttons and links but not for scrollable container
	            if (target.matches('button,a')) {
	                e.preventDefault();
	            }
	        };
	        this.scrollActiveTabIntoView = (isSmooth = true) => {
	            // scrollAreaElement might be undefined in certain scenarios with framework routing involved
	            // where the activeTabIndex watcher triggers this function before the scroller is rendered and the ref defined
	            if (this.scrollerElement && this.internalTabIndex !== undefined) {
	                const scrollActivePosition = scrolling.getScrollActivePosition(this.tabElements, this.direction, this.internalTabIndex, this.scrollerElement);
	                this.scrollerElement.scrollToPosition = {
	                    scrollPosition: scrollActivePosition,
	                    isSmooth,
	                };
	            }
	        };
	        this.setBarStyle = () => {
	            tabsBarUtils.setBarStyle(this.tabElements, this.internalTabIndex, this.barElement);
	        };
	        this.observeBreakpointChange = () => {
	            if (typeof validateProps.parseJSON(this.size) === 'object') {
	                validateProps.observeBreakpointChange(this.host, () => {
	                    this.setBarStyle();
	                    this.scrollActiveTabIntoView(false);
	                });
	            }
	        };
	        this.size = 'small';
	        this.weight = 'regular';
	        this.theme = 'light';
	        this.gradientColorScheme = undefined;
	        this.gradientColor = 'background-base';
	        this.activeTabIndex = undefined;
	        this.tabElements = [];
	    }
	    activeTabIndexHandler(_newValue, oldValue) {
	        // in Angular, when chunk is already loaded and component is rendered almost identical after navigation
	        // (or with hot reloading in stackblitz) this watcher is called between `connectedCallback` and `componentDidLoad`
	        // this would reset `this.activeTabIndex` to undefined when `this.tabElements = []`
	        // so we have a separate `this.internalTabIndex` to not override the prop value
	        // https://github.com/porsche-design-system/porsche-design-system/issues/2674
	        this.setTabElements();
	        this.direction = this.internalTabIndex > oldValue || oldValue === undefined ? 'next' : 'prev';
	        this.setBarStyle();
	        this.scrollActiveTabIntoView();
	    }
	    connectedCallback() {
	        this.hasPTabsParent = isShadowRootParentOfKind(this.host, 'p-tabs');
	        this.observeBreakpointChange(); // on reconnect
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    componentWillLoad() {
	        this.setTabElements();
	    }
	    componentDidLoad() {
	        this.scrollActiveTabIntoView(false);
	        this.observeBreakpointChange(); // initially or slow prop binding
	        // TODO: would be great to use this in jsx but that doesn't work reliable or triggers initially when component is rendered via framework
	        validateProps.getShadowRootHTMLElement(this.host, 'slot').addEventListener('slotchange', () => {
	            this.setTabElements();
	            this.setBarStyle();
	        });
	    }
	    disconnectedCallback() {
	        validateProps.unobserveBreakpointChange(this.host);
	    }
	    componentDidRender() {
	        // 1 tick delay to prevent transition
	        window.requestAnimationFrame(() => {
	            this.scrollerElement.classList.toggle(scrollerAnimatedCssClass, this.internalTabIndex !== undefined);
	        });
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'gradientColorScheme', 'Please use gradientColor prop instead.');
	        const deprecationMap = {
	            semibold: 'semi-bold',
	        };
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'weight', deprecationMap);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.size, (deprecationMap[this.weight] || this.weight), this.theme);
	        this.setAccessibilityAttributes();
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(PrefixedTagNames.pScroller, { key: '59fc42e7c775cded0ed69eac262d3a0587d98ef7', class: "scroller", ...(this.areTabsButtons && { aria: { role: 'tablist' } }), theme: this.theme, gradientColorScheme: this.gradientColorScheme, gradientColor: this.gradientColor, alignScrollIndicator: "top", ref: (el) => (this.scrollerElement = el), onClick: this.onClick, onKeyDown: this.onKeydown }, validateProps.h("slot", { key: '6e5975e652a85412a296d47040ddc35d26294331' }), validateProps.h("span", { key: '6dc5c60274131b7fae50cabfbbe832b54493a118', class: "bar", ref: (el) => (this.barElement = el) })));
	    }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "activeTabIndex": ["activeTabIndexHandler"]
	    }; }
	};

	pTabsBar_cjs_entry.p_tabs_bar = TabsBar;

	
	return pTabsBar_cjs_entry;
}

var pTagDismissible_cjs_entry = {};

var tagSharedUtilsB71f947a = {};

var hasRequiredTagSharedUtilsB71f947a;

function requireTagSharedUtilsB71f947a () {
	if (hasRequiredTagSharedUtilsB71f947a) return tagSharedUtilsB71f947a;
	hasRequiredTagSharedUtilsB71f947a = 1;

	/** @deprecated */
	const TAG_DISMISSIBLE_COLORS_DEPRECATED = ['background-default']; // 'background-default' is deprecated (replaced with 'background-base')
	const TAG_DISMISSIBLE_COLORS = [
	    'background-base',
	    'background-surface',
	    ...TAG_DISMISSIBLE_COLORS_DEPRECATED,
	];
	const TAG_DISMISSIBLE_ARIA_ATTRIBUTES = ['aria-label'];

	const getThemedBackgroundColor = (tagColor, themedColors) => {
	    const colorMap = {
	        'background-base': themedColors.backgroundColor,
	        'background-surface': themedColors.backgroundSurfaceColor,
	        'background-frosted': themedColors.backgroundFrostedColor,
	        primary: themedColors.primaryColor,
	        'notification-info-soft': themedColors.infoSoftColor,
	        'notification-warning-soft': themedColors.warningSoftColor,
	        'notification-success-soft': themedColors.successSoftColor,
	        'notification-error-soft': themedColors.errorSoftColor,
	    };
	    return colorMap[tagColor];
	};

	tagSharedUtilsB71f947a.TAG_DISMISSIBLE_ARIA_ATTRIBUTES = TAG_DISMISSIBLE_ARIA_ATTRIBUTES;
	tagSharedUtilsB71f947a.TAG_DISMISSIBLE_COLORS = TAG_DISMISSIBLE_COLORS;
	tagSharedUtilsB71f947a.getThemedBackgroundColor = getThemedBackgroundColor;

	
	return tagSharedUtilsB71f947a;
}

var hasRequiredPTagDismissible_cjs_entry;

function requirePTagDismissible_cjs_entry () {
	if (hasRequiredPTagDismissible_cjs_entry) return pTagDismissible_cjs_entry;
	hasRequiredPTagDismissible_cjs_entry = 1;

	Object.defineProperty(pTagDismissible_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed91ceea3c();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const tagSharedUtils = requireTagSharedUtilsB71f947a();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const textSmallStyle = requireTextSmallStyle00e1c6e2();
	const fontSizeTextXSmall = requireFontSizeTextXSmallE59d35d7();
	requireHelper22e15c0e();
	requireTextShared5216bb19();
	requireFontFamily23874d28();
	requireFontLineHeightD4b9e1a9();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();

	const getComponentCss = (color, hasLabel, theme) => {
	    const themedColors = validateProps.getThemedColors(theme);
	    const themedColorsDark = validateProps.getThemedColors('dark');
	    const { primaryColor, hoverColor, contrastHighColor } = themedColors;
	    const { primaryColor: primaryColorDark, hoverColor: hoverColorDark, contrastHighColor: contrastHighColorDark, } = themedColorsDark;
	    const backgroundColor = tagSharedUtils.getThemedBackgroundColor(color, themedColors);
	    const backgroundColorDark = tagSharedUtils.getThemedBackgroundColor(color, themedColorsDark);
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'inline-block',
	                verticalAlign: 'top',
	                ...validateProps.addImportantToEachRule({
	                    outline: 0,
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            button: {
	                display: 'flex',
	                position: 'relative',
	                alignItems: 'center',
	                gap: '12px',
	                minHeight: '54px',
	                padding: '4px 12px',
	                margin: 0, // Removes default button margin on safari 15
	                borderRadius: borderRadiusSmall.borderRadiusSmall,
	                border: 0,
	                cursor: 'pointer',
	                background: backgroundColor,
	                color: primaryColor,
	                textAlign: 'start',
	                ...textSmallStyle.textSmallStyle,
	                ...(validateProps.isHighContrastMode && {
	                    // TODO: using border would increase the dimension but using outline interferes with the focus style
	                    outline: '1px solid transparent',
	                }),
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    background: backgroundColorDark,
	                    color: primaryColorDark,
	                }),
	                ...hoverMediaQuery.hoverMediaQuery({
	                    '&:hover > .icon': {
	                        backgroundColor: hoverColor,
	                        ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                            backgroundColor: hoverColorDark,
	                        }),
	                    },
	                }),
	                ...validateProps.getFocusJssStyle(theme),
	            },
	        },
	        ...(hasLabel && {
	            label: {
	                display: 'block',
	                marginBottom: '-4px',
	                color: contrastHighColor,
	                fontSize: fontSizeTextXSmall.fontSizeTextXSmall,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: contrastHighColorDark,
	                }),
	            },
	        }),
	        icon: {
	            padding: '4px',
	            marginInlineEnd: '-2px', // compensate white space of svg icon and optimize visual alignment
	            transition: validateProps.getTransition('background-color'),
	            borderRadius: borderRadiusSmall.borderRadiusSmall,
	        },
	        'sr-only': validateProps.getHiddenTextJssStyle(),
	    });
	};

	const propTypes = {
	    color: validateProps.AllowedTypes.oneOf(tagSharedUtils.TAG_DISMISSIBLE_COLORS),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    label: validateProps.AllowedTypes.string,
	    aria: validateProps.AllowedTypes.aria(tagSharedUtils.TAG_DISMISSIBLE_ARIA_ATTRIBUTES),
	};
	const TagDismissible = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.color = 'background-surface';
	        this.theme = 'light';
	        this.label = undefined;
	        this.aria = undefined;
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        const deprecationMap = {
	            'background-default': 'background-base',
	        };
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'color', deprecationMap);
	        validateProps.attachComponentCss(this.host, getComponentCss, (deprecationMap[this.color] || this.color), !!this.label, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h("button", { key: '8000db458c1bd1740f774ded57502c6fbac466ac', type: "button", ...validateProps.parseAndGetAriaAttributes(this.aria) }, validateProps.h("span", { key: 'eaf56fc35d88ae98c7a00101ce5b8b2bcecb5b9c', class: "sr-only" }, "Remove:"), validateProps.h("span", { key: '410daee93f49c3f9db1ef83ecc36c2a1fb9f6253' }, this.label && validateProps.h("span", { key: '1d001463b6e5f0baf652a505ce6dddffd5f18d68', class: "label" }, this.label), validateProps.h("slot", { key: 'a06434a982a52fe31a41f43aaed8b354a6f28e6f' })), validateProps.h(PrefixedTagNames.pIcon, { key: '7cce7aef73fd4443c9194094610a142b873d5129', class: "icon", name: "close", theme: this.theme, "aria-hidden": "true" })));
	    }
	    static get delegatesFocus() { return true; }
	    get host() { return validateProps.getElement(this); }
	};

	pTagDismissible_cjs_entry.p_tag_dismissible = TagDismissible;

	
	return pTagDismissible_cjs_entry;
}

var pTag_cjs_entry = {};

var hasRequiredPTag_cjs_entry;

function requirePTag_cjs_entry () {
	if (hasRequiredPTag_cjs_entry) return pTag_cjs_entry;
	hasRequiredPTag_cjs_entry = 1;

	Object.defineProperty(pTag_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const tagSharedUtils = requireTagSharedUtilsB71f947a();
	const changeColor = requireChangeColor50831612();
	const getDirectChildHTMLElement = requireGetDirectChildHTMLElement18d9487f();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed91ceea3c();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const textXSmallStyle = requireTextXSmallStyle30d03035();
	const frostedGlassStyle = requireFrostedGlassStyleBd067e45();
	requireTransformSelectorToDirectChildSelectorEcc1a9c4();
	requireHelper22e15c0e();
	requireTextShared5216bb19();
	requireFontFamily23874d28();
	requireFontLineHeightD4b9e1a9();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextXSmallE59d35d7();

	/** @deprecated */
	const TAG_COLORS_DEPRECATED = [
	    'neutral-contrast-high', // 'notification-contrast-high' is deprecated (replaced with 'primary')
	    'notification-neutral', // 'notification-neutral' is deprecated (replaced with 'notification-info-soft')
	    'notification-warning',
	    'notification-success',
	    'notification-error',
	];
	const TAG_COLORS = [
	    ...tagSharedUtils.TAG_DISMISSIBLE_COLORS,
	    'background-frosted',
	    'primary',
	    'notification-info-soft',
	    'notification-warning-soft',
	    'notification-success-soft',
	    'notification-error-soft',
	    ...TAG_COLORS_DEPRECATED,
	];
	const getThemedBackgroundHoverColor = (tagColor, themedColors, theme) => {
	    const isDark = validateProps.isThemeDark(theme);
	    const keySuffix = isDark ? 'Lighten' : 'Darken';
	    const colorMap = {
	        'background-base': themedColors[`backgroundColor${keySuffix}`],
	        'background-surface': themedColors[`backgroundSurfaceColor${keySuffix}`],
	        'background-frosted': isDark
	            ? changeColor.lighten(themedColors.backgroundFrostedColor)
	            : changeColor.darken(themedColors.backgroundFrostedColor),
	        primary: isDark ? themedColors.contrastHighColorLighten : themedColors.contrastHighColor,
	        'notification-info-soft': themedColors[`infoSoftColor${keySuffix}`],
	        'notification-success-soft': themedColors[`successSoftColor${keySuffix}`],
	        'notification-error-soft': themedColors[`errorSoftColor${keySuffix}`],
	        'notification-warning-soft': themedColors[`warningSoftColor${keySuffix}`],
	    };
	    return colorMap[tagColor];
	};

	const getColors = (tagColor, theme) => {
	    const themedColors = validateProps.getThemedColors(theme);
	    const { primaryColor } = tagColor === 'primary' ? validateProps.getInvertedThemedColors(theme) : themedColors;
	    return {
	        textColor: primaryColor,
	        backgroundColor: tagSharedUtils.getThemedBackgroundColor(tagColor, themedColors),
	        backgroundHoverColor: getThemedBackgroundHoverColor(tagColor, themedColors, theme),
	    };
	};
	const getComponentCss = (tagColor, compact, isFocusable, hasIcon, theme) => {
	    const { textColor, backgroundColor, backgroundHoverColor } = getColors(tagColor, theme);
	    const { textColor: textColorDark, backgroundColor: backgroundColorDark, backgroundHoverColor: backgroundHoverColorDark, } = getColors(tagColor, 'dark');
	    const isBackgroundFrosted = tagColor === 'background-frosted';
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'inline-flex',
	                verticalAlign: 'top', // TODO: should we set this CSS style at all?
	                whiteSpace: 'nowrap', // TODO: should either be exposed by a controlled CSS variable or a component prop or whitelist as supported custom styles
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            span: {
	                position: 'relative', // necessary as relative anchor to ensure click area of optional slotted focusable element is in sync
	                display: 'flex',
	                gap: '2px',
	                padding: compact ? '1px 6px' : `${spacingStaticXSmall.spacingStaticXSmall} 9px`,
	                borderRadius: borderRadiusSmall.borderRadiusSmall,
	                font: textXSmallStyle.textXSmallStyle.font,
	                color: textColor,
	                background: backgroundColor,
	                ...(isBackgroundFrosted && frostedGlassStyle.frostedGlassStyle),
	                ...(validateProps.isHighContrastMode && {
	                    outline: '1px solid transparent',
	                }),
	                transition: `${validateProps.getTransition('color')}, ${validateProps.getTransition('background-color')}, ${validateProps.getTransition('backdrop-filter')}`, // transition style should always be applied to have a smooth color change in case color prop gets updated during runtime
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: textColorDark,
	                    background: backgroundColorDark,
	                }),
	                ...(isFocusable &&
	                    hoverMediaQuery.hoverMediaQuery({
	                        '&:hover': {
	                            background: backgroundHoverColor,
	                            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                                background: backgroundHoverColorDark,
	                            }),
	                        },
	                    })),
	            },
	            '::slotted': validateProps.addImportantToEachRule({
	                '&(a),&(button)': {
	                    all: 'unset', // resets any ua-style + custom style set in light dom
	                    textDecoration: 'underline',
	                    cursor: 'pointer',
	                    font: 'inherit',
	                    color: 'inherit',
	                },
	                '&(a)::before,&(button)::before': {
	                    content: '""',
	                    position: 'absolute',
	                    inset: 0,
	                    borderRadius: '4px',
	                },
	                ...validateProps.getFocusJssStyle(theme, { slotted: 'a', pseudo: true }),
	                ...validateProps.getFocusJssStyle(theme, { slotted: 'button', pseudo: true }),
	                '&(br)': {
	                    display: 'none',
	                },
	            }),
	        },
	        ...(hasIcon && {
	            icon: {
	                marginInlineStart: '-2px', // compensate white space of svg icon and optimize visual alignment
	                ...(!validateProps.isHighContrastMode &&
	                    tagColor === 'primary' && {
	                    filter: 'invert(1)',
	                }),
	            },
	        }),
	    });
	};

	const propTypes = {
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    color: validateProps.AllowedTypes.oneOf(TAG_COLORS),
	    icon: validateProps.AllowedTypes.string, // TODO: we could use AllowedTypes.oneOf<IconName>(Object.keys(ICONS_MANIFEST) as IconName[]) but then main chunk will increase
	    iconSource: validateProps.AllowedTypes.string,
	    compact: validateProps.AllowedTypes.boolean,
	};
	const Tag = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.theme = 'light';
	        this.color = 'background-surface';
	        this.icon = undefined;
	        this.iconSource = undefined;
	        this.compact = false;
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        const hasIcon = !!(this.icon || this.iconSource);
	        const deprecationMap = {
	            'background-default': 'background-base',
	            'neutral-contrast-high': 'primary',
	            'notification-neutral': 'notification-info-soft',
	            'notification-warning': 'notification-warning-soft',
	            'notification-success': 'notification-success-soft',
	            'notification-error': 'notification-error-soft',
	        };
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'color', deprecationMap);
	        validateProps.attachComponentCss(this.host, getComponentCss, (deprecationMap[this.color] || this.color), this.compact, !!getDirectChildHTMLElement.getDirectChildHTMLElement(this.host, 'a,button'), hasIcon, this.theme);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h("span", { key: '5e430d4cf0692d89f8c9e10711fdd691ecbc884c' }, hasIcon && (validateProps.h(PrefixedTagNames.pIcon, { key: 'cbf1878332bfb9f3f1b0e9e7bea17b14773df17a', class: "icon", name: this.icon, source: this.iconSource, color: "primary", size: "x-small", theme: this.theme, "aria-hidden": "true" })), validateProps.h("slot", { key: 'f05a18a1d5118b07a4aca98e1bd3e3595742556b' })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pTag_cjs_entry.p_tag = Tag;

	
	return pTag_cjs_entry;
}

var pTextFieldWrapper_cjs_entry = {};

var hasRequiredPTextFieldWrapper_cjs_entry;

function requirePTextFieldWrapper_cjs_entry () {
	if (hasRequiredPTextFieldWrapper_cjs_entry) return pTextFieldWrapper_cjs_entry;
	hasRequiredPTextFieldWrapper_cjs_entry = 1;

	Object.defineProperty(pTextFieldWrapper_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const buttonHandling = requireButtonHandling39869edc();
	const stateMessageStyles = requireStateMessageStylesD1c4637f();
	const formUtils = requireFormUtils876806ab();
	const getClosestHTMLElement = requireGetClosestHTMLElement83d01a84();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed76f87eda();
	const propertyObserver = requirePropertyObserver4331cfab();
	const theme = requireThemeBfc10573();
	const getOnlyChildOfKindHTMLElementOrThrow = requireGetOnlyChildOfKindHTMLElementOrThrowCdb95e52();
	const slottedAnchorStyles = requireSlottedAnchorStylesFe1a10c2();
	const labelStyles = requireLabelStylesD5916d0e();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const formStyles = requireFormStylesDeecb9a1();
	const hasDocument = requireHasDocument079654e6();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const fontLineHeight = requireFontLineHeightD4b9e1a9();
	requireSetAttributesF96a52a9();
	requireHasNamedSlot273cd3ae();
	requireGetNamedSlot223c478a();
	requireTextSmallStyle00e1c6e2();
	requireTextShared5216bb19();
	requireFontFamily23874d28();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireHelper22e15c0e();
	requireGetDirectChildHTMLElements2594e5bd();
	requireGetHTMLElements3f1c700f();
	requireTransformSelectorToDirectChildSelectorEcc1a9c4();
	requireBorderRadiusSmall5f37fc45();
	requireBorderRadiusMedium758b9411();
	requireHasDescription050833e0();
	requireIsParentOfKind4b323732();
	requireFontSizeTextXSmallE59d35d7();
	requireHoverMediaQuery5e6deda8();
	requireSpacingStaticSmall2130ed04();
	requireSpacingStaticMedium94812711();

	const isWithinForm = (host) => !!getClosestHTMLElement.getClosestHTMLElement(host, 'form');

	const getSlottedInputIndicatorStyles = (tagName) => ({
	    '@global': {
	        [`${tagName} input`]: {
	            // unfortunately we cant use :is() for ::-webkit pseudo selectors in Chrome for unknown reasons
	            '&::-webkit-outer-spin-button, &::-webkit-inner-spin-button, &::-webkit-search-decoration, &::-webkit-search-cancel-button, &::-webkit-calendar-picker-indicator': validateProps.addImportantToEachRule({
	                display: 'none',
	            }),
	            // for type="date" and type="time" we need to override some mobile safari user agent styles
	            // https://stackoverflow.com/questions/37457097/input-type-date-text-alignright-ios-devices
	            '&::-webkit-date-and-time-value': validateProps.addImportantToEachRule({
	                display: 'inline-block',
	                textAlign: 'inherit', // for LTR/RTL
	                verticalAlign: 'middle',
	            }),
	        },
	    },
	});

	const UNIT_POSITIONS = ['prefix', 'suffix'];
	const hasCounterAndIsTypeText = (el) => el && isType(el.type, 'text') && formUtils.hasCounter(el);
	const hasUnitAndIsTypeTextOrNumber = (el, unit) => {
	    return el && !!unit && (isType(el.type, 'text') || isType(el.type, 'number'));
	};
	const isType = (inputType, typeToValidate) => inputType === typeToValidate;
	const hasLocateAction = (icon) => icon === 'locate';
	const throwIfUnitLengthExceeded = (unit) => {
	    if (unit.length > 5) {
	        validateProps.throwException(`unit='${unit}' passed to p-text-field-wrapper exceeds the maximum length of 5.`);
	    }
	};
	const addInputEventListenerForSearch = (input, inputChangeCallback) => {
	    input.addEventListener('input', (e) => {
	        inputChangeCallback(!!e.target.value);
	    });
	    input.addEventListener('keydown', (e) => {
	        if (e.key === 'Escape' && e.target.value) {
	            e.preventDefault();
	            e.target.value = '';
	            // need to emit event so consumer's change listeners fire for resetting a search, etc.
	            dispatchInputEvent(e.target);
	        }
	    });
	};
	const dispatchInputEvent = (el) => {
	    // { bubbles: true } is crucial for react onChange callback getting invoked
	    el.dispatchEvent(new Event('input', { bubbles: true }));
	};
	// eslint-disable-next-line no-underscore-dangle
	const _hasShowPickerSupport = () => {
	    return (hasDocument.hasDocument &&
	        'showPicker' in HTMLInputElement.prototype &&
	        // TODO: it would be better to determinate support by checking for existence of "calendar-picker-indicator"
	        !!window.navigator.userAgent.match(/chrome|chromium|crios|edg/i));
	};
	const hasShowPickerSupport = _hasShowPickerSupport();
	const showCustomCalendarOrTimeIndicator = (isCalendar, isTime) => {
	    return hasShowPickerSupport && (isCalendar || isTime);
	};
	/**
	 * Map of flyout instances and their corresponding css stylesheets including the experimental css property --p-flyout-sticky-top.
	 */
	const counterCharacterLengthCssVarStyleSheetMap = new Map();
	// Called once in didRender for setup
	const addCounterCharacterLengthCssVarStyleSheet = (host) => {
	    if (validateProps.getHasConstructableStylesheetSupport()) {
	        counterCharacterLengthCssVarStyleSheetMap.set(host, new CSSStyleSheet());
	        // It's very important to create and push the stylesheet after `attachComponentCss()` has been called, otherwise styles might replace each other.
	        // TODO: for some reason unit test in Docker environment throws TS2339: Property 'push' does not exist on type 'readonly CSSStyleSheet[]'
	        /* eslint-disable @typescript-eslint/prefer-ts-expect-error, @typescript-eslint/ban-ts-comment */
	        // @ts-ignore
	        host.shadowRoot.adoptedStyleSheets.push(counterCharacterLengthCssVarStyleSheetMap.get(host));
	        updateCounterCharacterLengthCssVarStyleSheet(host, 0);
	    }
	};
	const updateCounterCharacterLengthCssVarStyleSheet = (host, value) => {
	    // EXPERIMENTAL CSS variable
	    counterCharacterLengthCssVarStyleSheetMap
	        .get(host)
	        .replaceSync(`:host{--p-internal-counter-character-length:${value}}`);
	};

	const cssVariableInputPaddingStart = '--p-internal-text-field-input-padding-start';
	const cssVariableInputPaddingEnd = '--p-internal-text-field-input-padding-end';
	const cssVarInternalTextFieldScaling = '--p-internal-text-field-scaling';
	const getComponentCss = (isDisabled, isReadonly, hideLabel, state, hasUnitOrVisibleCounter, unitPosition, inputType, showPasswordToggle, isWithinForm, hasSubmitButton, theme, unitLength) => {
	    const isSearch = isType(inputType, 'search');
	    const isPassword = isType(inputType, 'password');
	    const isNumber = isType(inputType, 'number');
	    const isCalendar = isType(inputType, 'date') || isType(inputType, 'week') || isType(inputType, 'month');
	    const isTime = isType(inputType, 'time');
	    const isSearchOrPassword = isSearch || (isPassword && showPasswordToggle);
	    const isSearchWithoutFormOrSubmitButton = isSearch && (!isWithinForm || !hasSubmitButton);
	    const isSearchWithForm = isSearch && isWithinForm;
	    const isCalendarOrTimeWithCustomIndicator = showCustomCalendarOrTimeIndicator(isCalendar, isTime);
	    const counterCharacterLengthCssVar = 'var(--p-internal-counter-character-length)';
	    const paddingInlineIfUnitOrCounter = hasUnitOrVisibleCounter &&
	        `calc(${formStyles.formElementLayeredGap} + ${formStyles.formElementPaddingHorizontal} + ${validateProps.borderWidthBase} + ${unitLength || counterCharacterLengthCssVar} * 1ch * log(2.6))`;
	    // Determines the scaling factor for the text field size. In "compact" mode, it uses 0.5 to achieve a 36px text field (compact size).
	    // Defaults to 1 for the standard size and can be overridden by the CSS variable `cssVarInternalTextFieldScaling`.
	    const scalingVar = `var(${cssVarInternalTextFieldScaling}, 1)`;
	    const paddingBlock = `max(2px, ${formStyles.formElementPaddingVertical} * ${scalingVar})`;
	    const paddingInline = `max(4px, ${formStyles.formElementPaddingHorizontal} * ${scalingVar})`;
	    const height = `max(${fontLineHeight.fontLineHeight}, ${scalingVar} * (${fontLineHeight.fontLineHeight} + 10px))`;
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            // ::slotted(input)
	            ...validateProps.addImportantToEachRule({
	                ...formStyles.getSlottedTextFieldTextareaSelectStyles('input', state, false, theme, {
	                    gridArea: '1/1/1/-1',
	                    paddingBlock,
	                    paddingInline,
	                    width: 'auto',
	                    height,
	                    boxSizing: 'content-box',
	                    paddingInlineStart: hasUnitOrVisibleCounter && unitPosition === 'prefix'
	                        ? paddingInlineIfUnitOrCounter
	                        : `var(${cssVariableInputPaddingStart})`, // iOS Safari 14.5 can't handle padding-inline shorthand with css variables
	                    paddingInlineEnd: hasUnitOrVisibleCounter && unitPosition === 'suffix'
	                        ? paddingInlineIfUnitOrCounter
	                        : `var(${cssVariableInputPaddingEnd})`, // iOS Safari 14.5 can't handle padding-inline shorthand with css variables
	                    // TODO: move into getSlottedTextFieldTextareaSelectStyles()
	                    ...(isNumber && {
	                        MozAppearance: 'textfield', // hides up/down spin button for Firefox
	                    }),
	                    ...((isCalendar || isTime) && {
	                        // for native placeholder color in safari, background has to be a special value, `transparent` or `rgba(0,0,0,0)` won't work
	                        // this works nice for `theme="light"`, but for `theme="dark"` placeholder appears blue which is still better
	                        // than having invisible dots or colons for data/time or not seeing the value at all after selection
	                        // found on https://browserstrangeness.bitbucket.io/css_hacks.html#safari
	                        '@supports (-webkit-hyphens: none)': {
	                            background: 'rgba(0,0,1,0)',
	                            color: validateProps.isThemeDark(theme) ? validateProps.getThemedColors(theme).primaryColor : 'initial',
	                        },
	                    }),
	                }),
	                // TODO: move into getSlottedTextFieldTextareaSelectStyles()
	                '::slotted': {
	                    '&(input:-internal-autofill-selected),&(input:-internal-autofill-previewed),&(input:-webkit-autofill),&(input:-webkit-autofill:focus)': {
	                        WebkitBackgroundClip: 'padding-box', // reset webkit autofill styles
	                    },
	                    '&(input[type="email"]),&(input[type="tel"])': {
	                        direction: 'ltr', // fixes specific input types in RTL mode. Should always be LTR. See https://rtlstyling.com/posts/rtl-styling#form-inputs
	                    },
	                },
	            }),
	        },
	        root: {
	            [cssVariableInputPaddingStart]: isSearchWithoutFormOrSubmitButton
	                ? formStyles.getCalculatedFormElementPaddingHorizontal(1)
	                : paddingInline,
	            [cssVariableInputPaddingEnd]: isSearchOrPassword || isCalendarOrTimeWithCustomIndicator
	                ? formStyles.getCalculatedFormElementPaddingHorizontal(isSearchWithForm && hasSubmitButton ? 2 : 1)
	                : paddingInline,
	            display: 'grid',
	            gap: spacingStaticXSmall.spacingStaticXSmall,
	            // min width is needed for showing at least 1 character in very narrow containers. The "2rem" value is the minimum safe zone to show at least 1 character plus the ellipsis dots.
	            minWidth: `calc(2rem + ${formStyles.formElementPaddingHorizontal} + ${validateProps.borderWidthBase}*2 + ${hasUnitOrVisibleCounter || isSearch || isPassword || isCalendarOrTimeWithCustomIndicator ? formStyles.getCalculatedFormElementPaddingHorizontal(isSearch ? 2 : 1) : '0px'})`,
	        },
	        wrapper: {
	            display: 'grid',
	            gridTemplateColumns: `${formStyles.formElementLayeredSafeZone} auto minmax(0, 1fr) auto auto ${formStyles.formElementLayeredSafeZone}`,
	        },
	        ...((isSearchOrPassword || isCalendarOrTimeWithCustomIndicator) && {
	            // TODO: extract for multi-select, select-wrapper and text-field (not gridArea and placeSelf) like done for unit class
	            button: {
	                gridArea: '1/5',
	                placeSelf: 'center',
	                padding: formStyles.formButtonOrIconPadding,
	                // TODO: maybe we should render hidden button conditionally, needs to be checked if a11y compliant
	                '&:not([hidden])~.button': {
	                    gridArea: '1/4',
	                },
	            },
	        }),
	        ...(isSearchWithoutFormOrSubmitButton && {
	            // TODO: extract for multi-select, select-wrapper and text-field (not gridArea and placeSelf) like done for unit class
	            icon: {
	                gridArea: '1/2',
	                placeSelf: 'center',
	                padding: formStyles.formButtonOrIconPadding,
	                pointerEvents: 'none',
	            },
	        }),
	        ...(hasUnitOrVisibleCounter && {
	            'unit-counter': {
	                ...formStyles.getUnitCounterJssStyle(isDisabled, isReadonly, theme),
	                gridArea: `1/${unitPosition === 'suffix' ? 5 : 1}/1/${unitPosition === 'suffix' ? 7 : 3}`,
	                placeSelf: 'center',
	                paddingInline: unitPosition === 'suffix'
	                    ? `${formStyles.formElementLayeredGap} calc(${formStyles.formElementPaddingHorizontal} + ${validateProps.borderWidthBase})`
	                    : `calc(${formStyles.formElementPaddingHorizontal} + ${validateProps.borderWidthBase}) ${formStyles.formElementLayeredGap}`, // padding needed for correct input padding synchronisation
	            },
	        }),
	        // TODO: maybe we should extract it as functional component too
	        'sr-only': validateProps.getHiddenTextJssStyle(),
	        // .label / .required
	        ...labelStyles.getFunctionalComponentLabelStyles(isDisabled, hideLabel, theme),
	        // .message
	        ...stateMessageStyles.getFunctionalComponentStateMessageStyles(theme, state),
	    });
	};

	const propTypes = {
	    label: validateProps.AllowedTypes.string,
	    unit: validateProps.AllowedTypes.string,
	    unitPosition: validateProps.AllowedTypes.oneOf(UNIT_POSITIONS),
	    description: validateProps.AllowedTypes.string,
	    state: validateProps.AllowedTypes.oneOf(stateMessageStyles.FORM_STATES),
	    message: validateProps.AllowedTypes.string,
	    hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	    showCharacterCount: validateProps.AllowedTypes.boolean,
	    showCounter: validateProps.AllowedTypes.boolean,
	    actionIcon: validateProps.AllowedTypes.oneOf([undefined, 'locate']),
	    actionLoading: validateProps.AllowedTypes.boolean,
	    submitButton: validateProps.AllowedTypes.boolean,
	    showPasswordToggle: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const TextFieldWrapper = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.action = validateProps.createEvent(this, "action", 3);
	        this.onLabelClick = () => {
	            this.input.focus();
	        };
	        this.togglePassword = () => {
	            this.input.type = isType(this.input.type, 'password') ? 'text' : 'password';
	            this.showPassword = !this.showPassword;
	            this.onLabelClick();
	        };
	        this.onSubmit = (event) => {
	            buttonHandling.handleButtonEvent(event, this.host, () => 'submit', () => this.input.disabled);
	        };
	        this.onClear = () => {
	            this.onLabelClick();
	            this.input.value = '';
	            dispatchInputEvent(this.input);
	        };
	        this.observeAttributes = () => {
	            validateProps.observeAttributes(this.input, ['disabled', 'readonly', 'required', 'maxlength'], () => {
	                this.updateCounterVisibility();
	                validateProps.forceUpdate(this.host);
	            });
	        };
	        this.updateCounterVisibility = () => {
	            this.hasCounter = hasCounterAndIsTypeText(this.input);
	            this.isCounterVisible =
	                this.hasCounter && (typeof this.showCharacterCount === 'undefined' ? this.showCounter : this.showCharacterCount);
	            this.hasUnit = !this.isCounterVisible && hasUnitAndIsTypeTextOrNumber(this.input, this.unit);
	        };
	        this.addInputEventListenerForCounter = (characterCountElement, counterElement) => {
	            formUtils.updateCounter(this.input, characterCountElement, counterElement); // Initial value
	            if (this.isCounterVisible) {
	                updateCounterCharacterLengthCssVarStyleSheet(this.host, counterElement.innerText.length);
	            }
	            // When value changes programmatically
	            propertyObserver.observeProperties(this.input, ['value'], () => {
	                formUtils.updateCounter(this.input, characterCountElement, counterElement);
	                if (this.isCounterVisible) {
	                    updateCounterCharacterLengthCssVarStyleSheet(this.host, counterElement.innerText.length);
	                }
	            });
	            this.eventListener = formUtils.inputEventListenerCurry(characterCountElement, counterElement, () => {
	                if (this.isCounterVisible) {
	                    updateCounterCharacterLengthCssVarStyleSheet(this.host, counterElement.innerText.length);
	                }
	            });
	            this.input.removeEventListener('input', this.eventListener);
	            this.input.addEventListener('input', this.eventListener);
	        };
	        this.label = '';
	        this.unit = '';
	        this.unitPosition = 'prefix';
	        this.description = '';
	        this.state = 'none';
	        this.message = '';
	        this.hideLabel = false;
	        this.showCharacterCount = undefined;
	        this.showCounter = true;
	        this.actionIcon = undefined;
	        this.actionLoading = false;
	        this.submitButton = true;
	        this.showPasswordToggle = true;
	        this.theme = 'light';
	        this.showPassword = false;
	        this.isClearable = false;
	    }
	    onShowCounterChange() {
	        this.updateCounterVisibility();
	    }
	    connectedCallback() {
	        validateProps.applyConstructableStylesheetStyles(this.host, slottedAnchorStyles.getSlottedAnchorStyles, getSlottedInputIndicatorStyles);
	        this.observeAttributes(); // on every reconnect
	    }
	    componentWillLoad() {
	        this.input = getOnlyChildOfKindHTMLElementOrThrow.getOnlyChildOfKindHTMLElementOrThrow(this.host, ['text', 'number', 'email', 'tel', 'search', 'url', 'date', 'time', 'month', 'week', 'password']
	            .map((v) => `input[type=${v}]`)
	            .join());
	        const { type } = this.input;
	        this.observeAttributes(); // once initially
	        this.isSearch = isType(type, 'search');
	        this.isPassword = isType(type, 'password');
	        this.isCalendar = isType(type, 'date') || isType(type, 'week') || isType(type, 'month');
	        this.isTime = isType(type, 'time');
	        this.isWithinForm = isWithinForm(this.host);
	        this.hasAction = hasLocateAction(this.actionIcon);
	        this.updateCounterVisibility();
	        if (this.isSearch) {
	            this.isClearable = !!this.input.value;
	            // detect programmatic value changes like it happens in frameworks
	            propertyObserver.observeProperties(this.input, ['value'], () => (this.isClearable = !!this.input.value));
	        }
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    componentDidRender() {
	        if (this.isCounterVisible) {
	            addCounterCharacterLengthCssVarStyleSheet(this.host);
	        }
	        if (this.isCounterVisible || this.hasCounter) {
	            // renders innerHTML of unitOrCounterElement initially and on every input event
	            this.addInputEventListenerForCounter(this.ariaElement, this.isCounterVisible && this.unitOrCounterElement);
	        }
	        /*
	         * This is a workaround to improve accessibility because the input and the label/description/message text are placed in different DOM.
	         * Referencing ID's from outside the component is impossible because the web components DOM is separate.
	         * We have to wait for full support of the Accessibility Object Model (AOM) to provide the relationship between shadow DOM and slots
	         */
	        validateProps.setAriaAttributes(this.input, {
	            label: this.label,
	            message: this.message || this.description,
	            state: this.state,
	        });
	    }
	    componentDidLoad() {
	        if (this.isSearch) {
	            addInputEventListenerForSearch(this.input, (hasValue) => (this.isClearable = hasValue));
	        }
	    }
	    disconnectedCallback() {
	        validateProps.unobserveAttributes(this.input);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'showCharacterCount', 'Please use showCounter prop instead.');
	        throwIfUnitLengthExceeded(this.unit);
	        const { readOnly, disabled, type } = this.input;
	        validateProps.attachComponentCss(this.host, getComponentCss, disabled, readOnly, this.hideLabel, this.state, this.hasUnit || this.isCounterVisible, this.isCounterVisible ? 'suffix' : this.unitPosition, this.isPassword ? 'password' : type, this.showPasswordToggle, this.isWithinForm, this.submitButton, this.theme, 
	        // biome-ignore lint/style/useExplicitLengthCheck: to be refactored
	        !!this.hasUnit && this.unit.length);
	        const disabledOrReadOnly = disabled || readOnly;
	        const buttonProps = {
	            hideLabel: true,
	            theme: this.theme,
	            class: 'button',
	        };
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h("div", { key: '7fb0358621fc56badd1725ec3da8cf82ac223d18', class: "root" }, validateProps.h(labelStyles.Label, { key: 'b0de3e84554e2ce9ff0c00841c57bd7295ba4f30', host: this.host, label: this.label, description: this.description, formElement: this.input, isDisabled: disabled }), validateProps.h("div", { key: '16546daef8e0747c0bf2b3d50cd49c60edee9f8c', class: "wrapper" }, validateProps.h("slot", { key: 'd6bd792e9b9ac011166ef0dc32877857b36abdb7' }), this.hasCounter && validateProps.h("span", { key: 'c9fac3b6f3568560123146b9e4d9bf5140241587', class: "sr-only", ref: (el) => (this.ariaElement = el), "aria-live": "polite" }), (this.hasUnit || this.isCounterVisible) && (validateProps.h("span", { key: 'ead0d24fac28d4133179f9adbec7dbbfda6b233e', class: "unit-counter", ref: (el) => (this.unitOrCounterElement = el), "aria-hidden": "true" }, this.unit)), this.isPassword && this.showPasswordToggle ? (validateProps.h(PrefixedTagNames.pButtonPure, { ...buttonProps, type: "button", icon: this.showPassword ? 'view-off' : 'view', disabled: disabled, onClick: this.togglePassword, aria: { 'aria-pressed': this.showPassword ? 'true' : 'false' } }, "Toggle password visibility")) : showCustomCalendarOrTimeIndicator(this.isCalendar, this.isTime) ? (validateProps.h(PrefixedTagNames.pButtonPure, { ...buttonProps, type: "button", icon: this.isCalendar ? 'calendar' : 'clock', disabled: disabled, onClick: () => this.input.showPicker() }, "Show $", this.isCalendar ? 'date' : 'time', " picker")) : (this.isSearch && [
	            // TODO: create an own component, which would fix SSR support too
	            this.isWithinForm && this.submitButton ? (validateProps.h(PrefixedTagNames.pButtonPure, { ...buttonProps, key: "btn-submit", type: "submit", icon: "search", disabled: disabledOrReadOnly, onClick: this.onSubmit }, "Search")) : (validateProps.h(PrefixedTagNames.pIcon, { key: "icon", class: "icon", name: "search", color: "state-disabled", theme: this.theme, "aria-hidden": "true" })),
	            validateProps.h(PrefixedTagNames.pButtonPure, { ...buttonProps, key: "btn-clear", type: "button", icon: "close", tabIndex: -1, hidden: !this.isClearable, disabled: disabledOrReadOnly, onClick: this.onClear }, "Clear field"),
	            this.hasAction && (validateProps.h(PrefixedTagNames.pButtonPure, { ...buttonProps, key: "btn-action", type: "button", icon: "locate", hidden: this.isClearable, disabled: disabledOrReadOnly, onClick: this.actionLoading ? null : this.action.emit, loading: this.actionLoading }, "Locate me")),
	        ])), validateProps.h(stateMessageStyles.StateMessage, { key: '7ac69bd397ac00cfae2aa917e06cd6d061ca1415', state: this.state, message: this.message, theme: this.theme, host: this.host })));
	    }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "showCounter": ["onShowCounterChange"]
	    }; }
	};

	pTextFieldWrapper_cjs_entry.p_text_field_wrapper = TextFieldWrapper;

	
	return pTextFieldWrapper_cjs_entry;
}

var pTextList_2_cjs_entry = {};

var hasRequiredPTextList_2_cjs_entry;

function requirePTextList_2_cjs_entry () {
	if (hasRequiredPTextList_2_cjs_entry) return pTextList_2_cjs_entry;
	hasRequiredPTextList_2_cjs_entry = 1;

	Object.defineProperty(pTextList_2_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed76f87eda();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const textSmallStyle = requireTextSmallStyle00e1c6e2();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();
	const slottedAnchorStyles = requireSlottedAnchorStylesFe1a10c2();
	const throwIfParentIsNotOfKind = requireThrowIfParentIsNotOfKindE0807bbc();
	requireHelper22e15c0e();
	requireTextShared5216bb19();
	requireFontFamily23874d28();
	requireFontLineHeightD4b9e1a9();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireBorderRadiusSmall5f37fc45();
	requireBorderRadiusMedium758b9411();
	requireIsParentOfKind4b323732();

	/** @deprecated */
	const LIST_TYPES = ['unordered', 'ordered'];
	/** @deprecated */
	const ORDER_TYPES = ['numbered', 'alphabetically'];
	const TEXT_LIST_TYPES = ['unordered', 'numbered', 'alphabetically'];
	const isListTypeOrdered = (type) => type !== 'unordered';
	const isListTypeNumbered = (type) => type === 'numbered';

	const cssVariablePaddingTop = '--p-internal-text-list-padding-top';
	const cssVariablePaddingBottom = '--p-internal-text-list-padding-bottom';
	const cssVariablePseudoSpace = '--p-internal-text-list-pseudo-space';
	const cssVariableUnorderedGridColumn = '--p-internal-text-list-unordered-grid-column';
	const cssVariableUnorderedPseudoContent = '--p-internal-text-list-unordered-pseudo-content';
	const cssVariableOrderedGridColumn = '--p-internal-text-list-ordered-grid-column';
	const cssVariableOrderedPseudoSuffix = '--p-internal-text-list-ordered-pseudo-suffix';
	const counter = 'p-text-list-counter';
	const getComponentCss$1 = (type, theme) => {
	    const isOrderedList = isListTypeOrdered(type);
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    counterReset: counter,
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            'ol,ul': {
	                ...textSmallStyle.textSmallStyle,
	                margin: 0,
	                padding: `var(${cssVariablePaddingTop},0) 0 var(${cssVariablePaddingBottom},0) 0`,
	                listStyleType: 'none',
	                color: validateProps.getThemedColors(theme).primaryColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: validateProps.getThemedColors('dark').primaryColor,
	                }),
	            },
	            // css selector for text-list-item
	            '::slotted(*)': validateProps.addImportantToEachRule({
	                [cssVariablePaddingTop]: spacingStaticXSmall.spacingStaticXSmall, // padding top for nested list
	                [cssVariablePaddingBottom]: spacingStaticMedium.spacingStaticMedium, // padding bottom for nested list, TODO: in case it's last root list item with a nested list it would result in outer spacing which is not desired
	                [cssVariablePseudoSpace]: isOrderedList
	                    ? `var(${cssVariableOrderedGridColumn},1.5rem)`
	                    : `var(${cssVariableUnorderedGridColumn},.375rem)`,
	                '&::before': isOrderedList
	                    ? {
	                        content: `counters(${counter},'.',${isListTypeNumbered(type) ? 'decimal' : 'lower-latin'}) var(${cssVariableOrderedPseudoSuffix},'.')`,
	                        counterIncrement: counter,
	                        justifySelf: 'flex-end',
	                        whiteSpace: 'nowrap',
	                    }
	                    : {
	                        content: `var(${cssVariableUnorderedPseudoContent},'')`,
	                    },
	            }),
	        },
	    });
	};

	const propTypes = {
	    listType: validateProps.AllowedTypes.oneOf([undefined, ...LIST_TYPES]),
	    orderType: validateProps.AllowedTypes.oneOf([undefined, ...ORDER_TYPES]),
	    type: validateProps.AllowedTypes.oneOf(TEXT_LIST_TYPES),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const TextList = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.listType = undefined;
	        this.orderType = undefined;
	        this.type = 'unordered';
	        this.theme = 'light';
	    }
	    connectedCallback() {
	        validateProps.applyConstructableStylesheetStyles(this.host, slottedAnchorStyles.getSlottedAnchorStyles);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'listType', 'Please use type prop instead.');
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'orderType', 'Please use type prop instead.');
	        validateProps.attachComponentCss(this.host, getComponentCss$1, this.listType === 'ordered' ? this.orderType || 'numbered' : this.type, this.theme);
	        const TagType = isListTypeOrdered(this.listType || this.type) ? 'ol' : 'ul';
	        return (validateProps.h(TagType, { key: 'aaa6481b73e02bd31a2cf97c3d4ade4fe0e4cca5' }, validateProps.h("slot", { key: 'e54eeaf8f832c186cbb69babb8de842ecc274002' })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	const getComponentCss = () => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'grid',
	                ...validateProps.addImportantToEachRule({
	                    gridTemplateColumns: `var(${cssVariablePseudoSpace}) 1fr`,
	                    columnGap: spacingStaticMedium.spacingStaticMedium,
	                    font: 'inherit', // ensures style can't be overwritten from outside
	                    color: 'inherit', // ensures style can't be overwritten from outside
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...validateProps.addImportantToEachRule({
	                '::slotted(*)': {
	                    [cssVariableUnorderedGridColumn]: '.625rem', // reserves space for ::before (nested unordered list)
	                    [cssVariableUnorderedPseudoContent]: '""', // custom ::before char "" (nested unordered list)
	                    [cssVariableOrderedGridColumn]: '2rem', // reserves space for ::before (nested ordered list)
	                    [cssVariableOrderedPseudoSuffix]: '""', // don't show ::before suffix "." (nested ordered list)
	                },
	                '::slotted(*:last-child)': {
	                    gridColumn: 2,
	                },
	            }),
	        },
	    });
	};

	const TextListItem = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	    }
	    connectedCallback() {
	        throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-text-list');
	    }
	    render() {
	        validateProps.attachComponentCss(this.host, getComponentCss);
	        return (validateProps.h(validateProps.Host, { key: '6e4a2918638dd9abfa9822d41fc2935e0492b3fa', role: "listitem" }, validateProps.h("span", { key: 'f6fc356a39e929c44c1b1fb62a84dd5f35a5eb2a' }, validateProps.h("slot", { key: '27c4b02e41307a94fe3c088bc9f2cf5bc5dda0d8' }))));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pTextList_2_cjs_entry.p_text_list = TextList;
	pTextList_2_cjs_entry.p_text_list_item = TextListItem;

	
	return pTextList_2_cjs_entry;
}

var pText_cjs_entry = {};

var hasRequiredPText_cjs_entry;

function requirePText_cjs_entry () {
	if (hasRequiredPText_cjs_entry) return pText_cjs_entry;
	hasRequiredPText_cjs_entry = 1;

	Object.defineProperty(pText_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const typographyAlign = requireTypographyAlign844cd863();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed91ceea3c();
	const theme = requireThemeBfc10573();
	const textSize = requireTextSizeBe3fca13();
	const typographyTextColor = requireTypographyTextColor524bae09();
	const typographyTextWeight = requireTypographyTextWeight02ea3596();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const typographyStyles = requireTypographyStyles226e4585();
	const fontWeightStyles = requireFontWeightStylesB74e8683();
	const fontSizeTextXXSmall = requireFontSizeTextXXSmallA02f9c40();
	const fontSizeTextXSmall = requireFontSizeTextXSmallE59d35d7();
	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();
	const fontSizeTextMedium = requireFontSizeTextMedium88887ad8();
	const fontSizeTextLarge = requireFontSizeTextLarge05a4bc90();
	const fontSizeTextXLarge = requireFontSizeTextXLarge0ecf9ef3();
	const textSmallStyle = requireTextSmallStyle00e1c6e2();
	const slottedAnchorStyles = requireSlottedAnchorStylesFe1a10c2();
	requireGetDirectChildHTMLElement18d9487f();
	requireTransformSelectorToDirectChildSelectorEcc1a9c4();
	requireHelper22e15c0e();
	requireFontWeightRegularD0c768ac();
	requireFontWeightSemiBold4482c830();
	requireTextShared5216bb19();
	requireFontFamily23874d28();
	requireFontLineHeightD4b9e1a9();
	requireFontVariant6ba3b7cb();
	requireBorderRadiusSmall5f37fc45();
	requireBorderRadiusMedium758b9411();

	const TEXT_TAGS = ['p', 'span', 'div', 'address', 'blockquote', 'figcaption', 'cite', 'time', 'legend'];
	const getTextTagType = (host, tag) => {
	    if (typographyAlign.hasSpecificDirectChildTag(host, TEXT_TAGS.join())) {
	        return 'div';
	    }
	    return tag;
	};

	const sizeMap = {
	    'xx-small': fontSizeTextXXSmall.fontSizeTextXXSmall,
	    'x-small': fontSizeTextXSmall.fontSizeTextXSmall,
	    small: fontSizeTextSmall.fontSizeTextSmall,
	    medium: fontSizeTextMedium.fontSizeTextMedium,
	    large: fontSizeTextLarge.fontSizeTextLarge,
	    'x-large': fontSizeTextXLarge.fontSizeTextXLarge,
	};
	const getComponentCss = (size, weight, align, color, ellipsis, theme) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            [`::slotted(:is(${TEXT_TAGS.join()}))`]: validateProps.addImportantToEachRule(typographyStyles.getTypographySlottedJssStyle()),
	        },
	        root: typographyStyles.getTypographyRootJssStyle(textSmallStyle.textSmallStyle, validateProps.buildResponsiveStyles(size, (sizeValue) => ({
	            fontSize: sizeValue === 'inherit' ? sizeValue : sizeMap[sizeValue],
	            fontWeight: fontWeightStyles.getFontWeight(weight),
	        })), align, color, ellipsis, theme),
	    });
	};

	const propTypes = {
	    tag: validateProps.AllowedTypes.oneOf(TEXT_TAGS),
	    size: validateProps.AllowedTypes.breakpoint(textSize.TEXT_SIZES),
	    weight: validateProps.AllowedTypes.oneOf(typographyTextWeight.TYPOGRAPHY_TEXT_WEIGHTS),
	    align: validateProps.AllowedTypes.oneOf(typographyAlign.TYPOGRAPHY_ALIGNS),
	    color: validateProps.AllowedTypes.oneOf(typographyTextColor.TYPOGRAPHY_TEXT_COLORS),
	    ellipsis: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Text = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.tag = 'p';
	        this.size = 'small';
	        this.weight = 'regular';
	        this.align = 'start';
	        this.color = 'primary';
	        this.ellipsis = false;
	        this.theme = 'light';
	    }
	    connectedCallback() {
	        validateProps.applyConstructableStylesheetStyles(this.host, slottedAnchorStyles.getSlottedAnchorStyles);
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        const colorDeprecationMap = {
	            brand: 'primary',
	            default: 'primary',
	            'neutral-contrast-low': 'contrast-low',
	            'neutral-contrast-medium': 'contrast-medium',
	            'neutral-contrast-high': 'contrast-high',
	            'notification-neutral': 'notification-info',
	        };
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'color', colorDeprecationMap);
	        const weightDeprecationMap = {
	            thin: 'regular',
	            semibold: 'semi-bold',
	        };
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'weight', weightDeprecationMap);
	        const alignDeprecationMap = {
	            left: 'start',
	            right: 'end',
	        };
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'align', alignDeprecationMap);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.size, (weightDeprecationMap[this.weight] || this.weight), (alignDeprecationMap[this.align] || this.align), (colorDeprecationMap[this.color] || this.color), this.ellipsis, this.theme);
	        const TagType = getTextTagType(this.host, this.tag);
	        return (validateProps.h(TagType, { key: 'ab1e2f19c0f02a49de4c2c30e2768b4310337a9e', class: "root" }, validateProps.h("slot", { key: '0010e92a0ce341f26e51a189609794a4f7021d41' })));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pText_cjs_entry.p_text = Text;

	
	return pText_cjs_entry;
}

var pTextareaWrapper_cjs_entry = {};

var spacingStaticLargeAbe11a7d = {};

var hasRequiredSpacingStaticLargeAbe11a7d;

function requireSpacingStaticLargeAbe11a7d () {
	if (hasRequiredSpacingStaticLargeAbe11a7d) return spacingStaticLargeAbe11a7d;
	hasRequiredSpacingStaticLargeAbe11a7d = 1;

	const spacingStaticLarge = '32px';

	spacingStaticLargeAbe11a7d.spacingStaticLarge = spacingStaticLarge;

	
	return spacingStaticLargeAbe11a7d;
}

var hasRequiredPTextareaWrapper_cjs_entry;

function requirePTextareaWrapper_cjs_entry () {
	if (hasRequiredPTextareaWrapper_cjs_entry) return pTextareaWrapper_cjs_entry;
	hasRequiredPTextareaWrapper_cjs_entry = 1;

	Object.defineProperty(pTextareaWrapper_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const stateMessageStyles = requireStateMessageStylesD1c4637f();
	const formUtils = requireFormUtils876806ab();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed76f87eda();
	const propertyObserver = requirePropertyObserver4331cfab();
	const theme = requireThemeBfc10573();
	const getOnlyChildOfKindHTMLElementOrThrow = requireGetOnlyChildOfKindHTMLElementOrThrowCdb95e52();
	const slottedAnchorStyles = requireSlottedAnchorStylesFe1a10c2();
	const labelStyles = requireLabelStylesD5916d0e();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const formStyles = requireFormStylesDeecb9a1();
	const textSmallStyle = requireTextSmallStyle00e1c6e2();
	const spacingStaticLarge = requireSpacingStaticLargeAbe11a7d();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	requireHasNamedSlot273cd3ae();
	requireGetNamedSlot223c478a();
	requireHelper22e15c0e();
	requireGetDirectChildHTMLElements2594e5bd();
	requireGetHTMLElements3f1c700f();
	requireTransformSelectorToDirectChildSelectorEcc1a9c4();
	requireBorderRadiusSmall5f37fc45();
	requireBorderRadiusMedium758b9411();
	requireGetClosestHTMLElement83d01a84();
	requireHasDescription050833e0();
	requireIsParentOfKind4b323732();
	requireFontSizeTextXSmallE59d35d7();
	requireHoverMediaQuery5e6deda8();
	requireSpacingStaticSmall2130ed04();
	requireSpacingStaticMedium94812711();
	requireFontLineHeightD4b9e1a9();
	requireTextShared5216bb19();
	requireFontFamily23874d28();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();

	const getComponentCss = (isDisabled, isReadonly, hideLabel, state, hasCounter, theme) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            // ::slotted(textarea)
	            ...validateProps.mergeDeep(validateProps.addImportantToEachRule(formStyles.getSlottedTextFieldTextareaSelectStyles('textarea', state, false, theme, {
	                gridArea: '1/1',
	                // TODO: move into getSlottedTextFieldTextareaSelectStyles()
	                font: textSmallStyle.textSmallStyle.font, // to override line-height
	                // TODO: move into getSlottedTextFieldTextareaSelectStyles()
	                padding: hasCounter
	                    ? `12px ${formStyles.formElementPaddingHorizontal} ${spacingStaticLarge.spacingStaticLarge}`
	                    : `12px ${formStyles.formElementPaddingHorizontal}`,
	            })), {
	                // TODO: is it possible to move into getSlottedTextFieldTextareaSelectStyles()?
	                '::slotted(textarea)': {
	                    height: 'auto', // removes !important from getBaseChildStyles
	                    minHeight: '200px', // min-height should be overridable
	                    resize: 'vertical', // overridable, too
	                },
	            }),
	        },
	        root: {
	            display: 'grid',
	            gap: spacingStaticXSmall.spacingStaticXSmall,
	            // min width is needed for showing at least 1 character in very narrow containers. The "1rem" value is the minimum safe zone to show at least 1 character.
	            minWidth: `calc(1rem + ${formStyles.formElementPaddingHorizontal}*2 + ${validateProps.borderWidthBase}*2)`,
	        },
	        wrapper: {
	            display: 'grid',
	        },
	        ...(hasCounter && {
	            counter: {
	                ...formStyles.getUnitCounterJssStyle(isDisabled, isReadonly, theme),
	                gridArea: '1/1',
	                placeSelf: 'flex-end',
	                padding: `6px calc(${formStyles.formElementPaddingHorizontal} + ${validateProps.borderWidthBase})`,
	            },
	            // TODO: maybe we should extract it as functional component too
	            'sr-only': validateProps.getHiddenTextJssStyle(),
	        }),
	        // .label / .required
	        ...labelStyles.getFunctionalComponentLabelStyles(isDisabled, hideLabel, theme),
	        // .message
	        ...stateMessageStyles.getFunctionalComponentStateMessageStyles(theme, state),
	    });
	};

	const propTypes = {
	    label: validateProps.AllowedTypes.string,
	    description: validateProps.AllowedTypes.string,
	    state: validateProps.AllowedTypes.oneOf(stateMessageStyles.FORM_STATES),
	    message: validateProps.AllowedTypes.string,
	    hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	    showCharacterCount: validateProps.AllowedTypes.boolean,
	    showCounter: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const TextareaWrapper = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.observeAttributes = () => {
	            validateProps.observeAttributes(this.textarea, ['disabled', 'readonly', 'required', 'maxlength'], () => {
	                validateProps.forceUpdate(this.host);
	                this.updateCounterVisibility();
	            });
	        };
	        this.updateCounterVisibility = () => {
	            this.hasCounter =
	                formUtils.hasCounter(this.textarea) &&
	                    (typeof this.showCharacterCount === 'undefined' ? this.showCounter : this.showCharacterCount);
	        };
	        this.addInputEventListenerForCounter = (characterCountElement, counterElement, inputChangeCallback) => {
	            formUtils.updateCounter(this.textarea, characterCountElement, counterElement); // Initial value
	            // When value changes programmatically
	            propertyObserver.observeProperties(this.textarea, ['value'], () => {
	                formUtils.updateCounter(this.textarea, characterCountElement, counterElement, inputChangeCallback);
	            });
	            this.eventListener = formUtils.inputEventListenerCurry(characterCountElement, counterElement, inputChangeCallback);
	            this.textarea.removeEventListener('input', this.eventListener);
	            this.textarea.addEventListener('input', this.eventListener);
	        };
	        this.label = '';
	        this.description = '';
	        this.state = 'none';
	        this.message = '';
	        this.hideLabel = false;
	        this.showCharacterCount = undefined;
	        this.showCounter = true;
	        this.theme = 'light';
	    }
	    onShowCounterChange() {
	        this.updateCounterVisibility();
	    }
	    connectedCallback() {
	        validateProps.applyConstructableStylesheetStyles(this.host, slottedAnchorStyles.getSlottedAnchorStyles);
	        this.observeAttributes(); // on every reconnect
	    }
	    componentWillLoad() {
	        this.textarea = getOnlyChildOfKindHTMLElementOrThrow.getOnlyChildOfKindHTMLElementOrThrow(this.host, 'textarea');
	        this.observeAttributes(); // once initially
	        this.updateCounterVisibility();
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    componentDidRender() {
	        if (this.hasCounter) {
	            this.addInputEventListenerForCounter(this.ariaElement, this.counterElement);
	        }
	        /*
	         * This is a workaround to improve accessibility because the textarea and the label/description/message text are placed in different DOM.
	         * Referencing ID's from outside the component is impossible because the web components DOM is separate.
	         * We have to wait for full support of the Accessibility Object Model (AOM) to provide the relationship between shadow DOM and slots.
	         */
	        validateProps.setAriaAttributes(this.textarea, {
	            label: this.label,
	            message: this.message || this.description,
	            state: this.state,
	        });
	    }
	    disconnectedCallback() {
	        validateProps.unobserveAttributes(this.textarea);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'showCharacterCount', 'Please use showCounter prop instead.');
	        const { disabled, readOnly } = this.textarea;
	        validateProps.attachComponentCss(this.host, getComponentCss, disabled, readOnly, this.hideLabel, this.state, this.hasCounter, this.theme);
	        return (validateProps.h("div", { key: '68311db3a34ca4a8c34f6770516d46da44a93224', class: "root" }, validateProps.h(labelStyles.Label, { key: '4fd3c779c3de7fc86bb7b38a100ce5ee03f61708', host: this.host, label: this.label, description: this.description, isDisabled: disabled, formElement: this.textarea }), validateProps.h("div", { key: 'ab53df4d078d059b69515ba46ade6526749594f1', class: "wrapper" }, validateProps.h("slot", { key: '95ec2fbb87aef0b94c72eb33674c39eccd681654' }), this.hasCounter && validateProps.h("span", { key: '84ef0c112c6579c33260209afd5a10f49060d621', class: "counter", "aria-hidden": "true", ref: (el) => (this.counterElement = el) }), this.hasCounter && validateProps.h("span", { key: '7c309835c7ecbb1079e867c52859603f9e3e145a', class: "sr-only", ref: (el) => (this.ariaElement = el), "aria-live": "polite" })), validateProps.h(stateMessageStyles.StateMessage, { key: '356b9f9a3d87a70303a20081e07dd97d58b033a1', state: this.state, message: this.message, theme: this.theme, host: this.host })));
	    }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "showCounter": ["onShowCounterChange"]
	    }; }
	};

	pTextareaWrapper_cjs_entry.p_textarea_wrapper = TextareaWrapper;

	
	return pTextareaWrapper_cjs_entry;
}

var pTextarea_cjs_entry = {};

var hasRequiredPTextarea_cjs_entry;

function requirePTextarea_cjs_entry () {
	if (hasRequiredPTextarea_cjs_entry) return pTextarea_cjs_entry;
	hasRequiredPTextarea_cjs_entry = 1;

	Object.defineProperty(pTextarea_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const stateMessageStyles = requireStateMessageStylesD1c4637f();
	const formUtils = requireFormUtils876806ab();
	const theme = requireThemeBfc10573();
	const slottedAnchorStyles = requireSlottedAnchorStylesFe1a10c2();
	const labelStyles = requireLabelStylesD5916d0e();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const hoverMediaQuery = requireHoverMediaQuery5e6deda8();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const formStyles = requireFormStylesDeecb9a1();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const textSmallStyle = requireTextSmallStyle00e1c6e2();
	const spacingStaticLarge = requireSpacingStaticLargeAbe11a7d();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	requireHasNamedSlot273cd3ae();
	requireGetNamedSlot223c478a();
	requireBorderRadiusMedium758b9411();
	requireGetClosestHTMLElement83d01a84();
	requireHasDescription050833e0();
	requireIsParentOfKind4b323732();
	requireFontSizeTextXSmallE59d35d7();
	requireSpacingStaticSmall2130ed04();
	requireSpacingStaticMedium94812711();
	requireFontLineHeightD4b9e1a9();
	requireTextShared5216bb19();
	requireFontFamily23874d28();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();

	const getComponentCss = (isDisabled, isReadonly, hideLabel, state, hasCounter, resize, theme) => {
	    const { primaryColor, contrastLowColor, contrastMediumColor, disabledColor } = validateProps.getThemedColors(theme);
	    const { primaryColor: primaryColorDark, contrastLowColor: contrastLowColorDark, contrastMediumColor: contrastMediumColorDark, disabledColor: disabledColorDark, } = validateProps.getThemedColors('dark');
	    const { formStateColor, formStateHoverColor } = stateMessageStyles.getThemedFormStateColors(theme, state);
	    const { formStateColor: formStateColorDark, formStateHoverColor: formStateHoverColorDark } = stateMessageStyles.getThemedFormStateColors('dark', state);
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'block',
	                ...validateProps.addImportantToEachRule({
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            textarea: {
	                resize,
	                display: 'block',
	                width: '100%',
	                height: 'auto',
	                margin: 0,
	                outline: 0,
	                WebkitAppearance: 'none', // iOS safari
	                appearance: 'none',
	                boxSizing: 'border-box',
	                border: `${validateProps.borderWidthBase} solid ${formStateColor || contrastMediumColor}`,
	                borderRadius: borderRadiusSmall.borderRadiusSmall,
	                background: 'transparent',
	                textIndent: 0,
	                color: primaryColor,
	                // min width is needed for showing at least 1 character in very narrow containers. The "1rem" value is the minimum safe zone to show at least 1 character.
	                minWidth: `calc(1rem + ${formStyles.formElementPaddingHorizontal}*2 + ${validateProps.borderWidthBase}*2)`,
	                transition: `${validateProps.getTransition('background-color')}, ${validateProps.getTransition('border-color')}, ${validateProps.getTransition('color')}`, // for smooth transitions between e.g. disabled states
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    borderColor: formStateColorDark || contrastMediumColorDark,
	                    color: primaryColorDark,
	                }),
	                gridArea: '1/1',
	                font: textSmallStyle.textSmallStyle.font, // to override line-height
	                padding: hasCounter
	                    ? `12px ${formStyles.formElementPaddingHorizontal} ${spacingStaticLarge.spacingStaticLarge}`
	                    : `12px ${formStyles.formElementPaddingHorizontal}`,
	                // TODO: getFocusJssStyle() can't be re-used because focus style differs for form elements
	                '&:focus': {
	                    borderColor: primaryColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        borderColor: primaryColorDark,
	                    }),
	                },
	                '&:disabled': {
	                    cursor: 'not-allowed',
	                    color: disabledColor,
	                    borderColor: disabledColor,
	                    WebkitTextFillColor: disabledColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        color: disabledColorDark,
	                        borderColor: disabledColorDark,
	                        WebkitTextFillColor: disabledColorDark,
	                    }),
	                },
	                '&[readonly]': {
	                    borderColor: contrastLowColor,
	                    background: contrastLowColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        borderColor: contrastLowColorDark,
	                        background: contrastLowColorDark,
	                    }),
	                },
	            },
	            ...hoverMediaQuery.hoverMediaQuery({
	                // with the media query the selector has higher priority and overrides disabled styles
	                'textarea:not(:disabled):not(:focus):not([readonly]):hover,label:hover~.wrapper textarea:not(:disabled):not(:focus):not([readonly])': {
	                    borderColor: formStateHoverColor || primaryColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        borderColor: formStateHoverColorDark || primaryColorDark,
	                    }),
	                },
	            }),
	        },
	        root: {
	            display: 'grid',
	            gap: spacingStaticXSmall.spacingStaticXSmall,
	        },
	        wrapper: {
	            display: 'grid',
	        },
	        ...(hasCounter && {
	            counter: {
	                ...formStyles.getUnitCounterJssStyle(isDisabled, isReadonly, theme),
	                gridArea: '1/1',
	                placeSelf: 'flex-end',
	                padding: `6px calc(${formStyles.formElementPaddingHorizontal} + ${validateProps.borderWidthBase})`,
	            },
	            // TODO: maybe we should extract it as functional component too
	            'sr-only': validateProps.getHiddenTextJssStyle(),
	        }),
	        // .label / .required
	        ...labelStyles.getFunctionalComponentLabelStyles(isDisabled, hideLabel, theme),
	        // .message
	        ...stateMessageStyles.getFunctionalComponentStateMessageStyles(theme, state),
	    });
	};

	const AUTO_COMPLETE = ['off', 'on', ''];
	const TEXTAREA_WRAPS = ['hard', 'soft', 'off'];
	const TEXTAREA_RESIZE = ['none', 'both', 'horizontal', 'vertical', 'block', 'inline'];

	const propTypes = {
	    label: validateProps.AllowedTypes.string,
	    description: validateProps.AllowedTypes.string,
	    name: validateProps.AllowedTypes.string,
	    value: validateProps.AllowedTypes.string,
	    state: validateProps.AllowedTypes.oneOf(stateMessageStyles.FORM_STATES),
	    message: validateProps.AllowedTypes.string,
	    hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	    showCounter: validateProps.AllowedTypes.boolean,
	    placeholder: validateProps.AllowedTypes.string,
	    required: validateProps.AllowedTypes.boolean,
	    disabled: validateProps.AllowedTypes.boolean,
	    maxLength: validateProps.AllowedTypes.number,
	    minLength: validateProps.AllowedTypes.number,
	    form: validateProps.AllowedTypes.string,
	    rows: validateProps.AllowedTypes.number,
	    autoComplete: validateProps.AllowedTypes.oneOf(AUTO_COMPLETE),
	    spellCheck: validateProps.AllowedTypes.boolean,
	    wrap: validateProps.AllowedTypes.oneOf(TEXTAREA_WRAPS),
	    resize: validateProps.AllowedTypes.oneOf(TEXTAREA_RESIZE),
	    readOnly: validateProps.AllowedTypes.boolean,
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Textarea = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.change = validateProps.createEvent(this, "change", 7);
	        this.blur = validateProps.createEvent(this, "blur", 3);
	        this.input = validateProps.createEvent(this, "input", 7);
	        if (hostRef.$hostElement$["s-ei"]) {
	            this.internals = hostRef.$hostElement$["s-ei"];
	        }
	        else {
	            this.internals = hostRef.$hostElement$.attachInternals?.();
	            hostRef.$hostElement$["s-ei"] = this.internals;
	        }
	        this.setCounterAriaTextDebounced = formUtils.debounce(() => this.setCounterAriaText());
	        this.onChange = (e) => {
	            this.change.emit(e);
	        };
	        this.onBlur = (e) => {
	            e.stopPropagation();
	            e.stopImmediatePropagation();
	            this.blur.emit(e);
	        };
	        this.onInput = (e) => {
	            e.stopPropagation();
	            e.stopImmediatePropagation();
	            this.input.emit(e);
	            const target = e.target;
	            this.value = target.value; // triggers @Watch('value')
	        };
	        this.updateCounterVisibility = () => {
	            this.hasCounter = this.maxLength >= 0 && this.showCounter;
	        };
	        this.setCounterAriaText = () => {
	            this.counterElement.innerText = `You have ${this.maxLength - this.value.length} out of ${this.maxLength} characters left`;
	        };
	        this.label = '';
	        this.description = '';
	        this.name = undefined;
	        this.value = '';
	        this.state = 'none';
	        this.message = '';
	        this.hideLabel = false;
	        this.showCounter = true;
	        this.placeholder = '';
	        this.required = false;
	        this.disabled = false;
	        this.maxLength = undefined;
	        this.minLength = undefined;
	        this.form = undefined;
	        this.rows = 7;
	        this.autoComplete = '';
	        this.spellCheck = undefined;
	        this.wrap = 'soft';
	        this.resize = 'vertical';
	        this.readOnly = false;
	        this.theme = 'light';
	    }
	    onValueChange(newValue) {
	        this.internals?.setFormValue(newValue);
	    }
	    onMaxLengthChange() {
	        this.updateCounterVisibility();
	    }
	    onShowCounterChange() {
	        this.updateCounterVisibility();
	    }
	    connectedCallback() {
	        validateProps.applyConstructableStylesheetStyles(this.host, slottedAnchorStyles.getSlottedAnchorStyles);
	    }
	    componentWillLoad() {
	        this.defaultValue = this.value;
	        this.updateCounterVisibility();
	    }
	    formResetCallback() {
	        this.internals?.setFormValue(this.defaultValue);
	        this.value = this.defaultValue;
	    }
	    formDisabledCallback(disabled) {
	        this.disabled = disabled;
	    }
	    formStateRestoreCallback(state) {
	        this.value = state;
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    componentDidLoad() {
	        this.internals?.setFormValue(this.value);
	    }
	    componentDidRender() {
	        if (this.hasCounter) {
	            this.setCounterAriaTextDebounced();
	        }
	        this.internals?.setValidity(this.textAreaElement.validity, this.textAreaElement.validationMessage, this.textAreaElement);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.disabled, this.readOnly, this.hideLabel, this.state, this.hasCounter, this.resize, this.theme);
	        const id = 'textarea';
	        return (validateProps.h("div", { key: '45f40962ef9fecdf478035d399be9c5b2496d794', class: "root" }, validateProps.h(labelStyles.Label, { key: '61b9eca82870fe05a7b3c49ad7635815385ed0a0', host: this.host, htmlFor: id, label: this.label, description: this.description, isRequired: this.required, isDisabled: this.disabled }), validateProps.h("div", { key: '8cd9711708a9a9e3d4ef9fcd9012147bf49d11fb', class: "wrapper" }, validateProps.h("textarea", { key: 'aed45b15d131a3c9ba6f323f5002499a6defd590', "aria-describedby": `${labelStyles.descriptionId} ${stateMessageStyles.messageId}`, "aria-invalid": this.state === 'error' ? 'true' : null, id: id, ref: (el) => (this.textAreaElement = el), onInput: this.onInput, onChange: this.onChange, onBlur: this.onBlur, name: this.name, value: this.value, form: this.form, disabled: this.disabled, required: this.required, placeholder: this.placeholder, maxlength: this.maxLength, minlength: this.minLength, rows: this.rows, readonly: this.readOnly, spellcheck: this.spellCheck, autocomplete: this.autoComplete, wrap: this.wrap }), this.hasCounter && (validateProps.h("span", { key: '1dccca424498d12ace824684f0ead8a21d6659a1', class: "counter", "aria-hidden": "true" }, `${this.value.length}/${this.maxLength}`)), this.hasCounter && validateProps.h("span", { key: 'dbdad09cacc69aa10a1575a1d233ad94f3ce31b7', class: "sr-only", "aria-live": "polite", ref: (el) => (this.counterElement = el) })), validateProps.h(stateMessageStyles.StateMessage, { key: 'f2059ff0574bbd51929ea8344cbd53a7d1032caf', state: this.state, message: this.message, theme: this.theme, host: this.host })));
	    }
	    static get delegatesFocus() { return true; }
	    static get formAssociated() { return true; }
	    get host() { return validateProps.getElement(this); }
	    static get watchers() { return {
	        "value": ["onValueChange"],
	        "maxLength": ["onMaxLengthChange"],
	        "showCounter": ["onShowCounterChange"]
	    }; }
	};

	pTextarea_cjs_entry.p_textarea = Textarea;

	
	return pTextarea_cjs_entry;
}

var pToast_2_cjs_entry = {};

var hasRequiredPToast_2_cjs_entry;

function requirePToast_2_cjs_entry () {
	if (hasRequiredPToast_2_cjs_entry) return pToast_2_cjs_entry;
	hasRequiredPToast_2_cjs_entry = 1;

	Object.defineProperty(pToast_2_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();
	const preventFoucOfNestedElementsStyles = requirePreventFoucOfNestedElementsStylesE5a706ce();
	const constants = requireConstants3998cc0f();
	const gridExtendedOffsetBase = requireGridExtendedOffsetBaseFb9830f6();
	const theme = requireThemeBfc10573();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsed91ceea3c();
	const throwIfRootNodeIsNotOneOfKind = requireThrowIfRootNodeIsNotOneOfKind201fcf02();
	const inlineNotificationUtils = requireInlineNotificationUtilsFb9eaa4e();
	const textSmallStyle = requireTextSmallStyle00e1c6e2();
	requireDropShadowShared6e50faf3();
	requireHelper22e15c0e();
	requireGetMediaQueryMax5b73ea17();
	requireSpacingStaticMedium94812711();
	requireBorderRadiusSmall5f37fc45();
	requireSpacingStaticXSmallB7d708b8();
	requireSpacingStaticSmall2130ed04();
	requireBannerUtils2cc83734();
	requireTextShared5216bb19();
	requireFontFamily23874d28();
	requireFontLineHeightD4b9e1a9();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();

	const cssVariablePositionBottom = '--p-toast-position-bottom'; // CSS custom property exposed as public interface
	const cssVariablePositionBottomInternal = '--p-internal-toast-position-bottom';
	const ANIMATION_DURATION = validateProps.motionDurationModerate;
	const duration = ANIMATION_DURATION;
	const getKeyframes = (direction, outsideStyle) => {
	    const insideStyle = { opacity: 1, transform: 'translate3d(0,0,0)' };
	    return direction === 'in'
	        ? {
	            from: outsideStyle,
	            to: insideStyle,
	        }
	        : {
	            from: insideStyle,
	            to: outsideStyle,
	        };
	};
	const getKeyframesMobile = (direction, bottomVar) => getKeyframes(direction, {
	    opacity: 0,
	    transform: `translate3d(0,calc(var(${bottomVar}) + 100%),0)`, // space before and after "+" is crucial
	});
	const toastCloseClassName = 'close';
	const getComponentCss$1 = () => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': validateProps.addImportantToEachRule({
	                position: 'fixed', // fallback for older browsers without native `popover` support
	                insetInline: gridExtendedOffsetBase.gridExtendedOffsetBase,
	                // Needs a not overridable internal css variable to cover default position depending on viewport size and to handle animation properly.
	                // In addition, a public css variable can be passed to overwrite the default position.
	                [cssVariablePositionBottomInternal]: `var(${cssVariablePositionBottom}, 56px)`,
	                bottom: `var(${cssVariablePositionBottomInternal})`,
	                zIndex: constants.TOAST_Z_INDEX, // fallback for older browsers without native `popover` support
	                [validateProps.getMediaQueryMin('s')]: {
	                    insetInline: '64px auto',
	                    maxWidth: 'min(42rem, calc(100vw - 64px * 2))',
	                    [cssVariablePositionBottomInternal]: `var(${cssVariablePositionBottom}, 64px)`,
	                    bottom: `var(${cssVariablePositionBottomInternal})`,
	                },
	                ...colorSchemeStyles.colorSchemeStyles,
	                ...colorSchemeStyles.hostHiddenStyles,
	            }),
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            '@keyframes in': getKeyframesMobile('in', cssVariablePositionBottomInternal),
	            '@keyframes out': getKeyframesMobile('out', cssVariablePositionBottomInternal),
	        },
	        hydrated: {
	            animation: `${duration} $in ${validateProps.motionEasingIn} forwards`,
	        },
	        [toastCloseClassName]: {
	            animation: validateProps.addImportantToRule(`${ANIMATION_DURATION} $out ${validateProps.motionEasingOut} forwards`),
	        },
	    });
	};

	const TOAST_DEFAULT_TIMEOUT = 6000;
	const MOTION_DURATION = Number.parseFloat(ANIMATION_DURATION) * 1000;
	class ToastManagerClass {
	    constructor() {
	        this.dismissToastItem = () => {
	            this.removeTimeout();
	            this.message = undefined;
	            this.onDismissCallback();
	            setTimeout(() => validateProps.forceUpdate(this.toastEl), 
	            // respect --p-temporary-toast-timeout css variable to override timeout during e2e and vrt tests
	            MOTION_DURATION
	                );
	        };
	    }
	    register(toastElement, onDismiss) {
	        if (this.toastEl) {
	            validateProps.throwException('p-toast was rendered multiple times.');
	        }
	        this.toastEl = toastElement;
	        this.onDismissCallback = onDismiss;
	    }
	    unregister() {
	        this.toastEl = null;
	        this.message = undefined;
	        this.removeTimeout();
	    }
	    addMessage(message) {
	        if (!this.toastEl) {
	            validateProps.throwException('missing p-toast element.');
	        }
	        if (!message.text) {
	            validateProps.throwException('p-toast empty text provided to addMessage().');
	        }
	        const msg = {
	            state: message.state || 'info', // info is our default state
	            text: message.text.replace(/<(?!br)[^>]*>/g, ''), // strip all html tags except linebreaks
	        };
	        if (!this.message) {
	            validateProps.forceUpdate(this.toastEl);
	        }
	        else if (this.message.text !== message.text) {
	            this.dismissToastItem();
	        }
	        this.message = msg;
	    }
	    getToast() {
	        this.startTimeout();
	        return this.message;
	    }
	    startTimeout() {
	        if (this.message) {
	            {
	                this.timeout = setTimeout(this.dismissToastItem, TOAST_DEFAULT_TIMEOUT);
	            }
	        }
	    }
	    removeTimeout() {
	        clearTimeout(this.timeout);
	        this.timeout = null;
	    }
	}
	const toastManager = new ToastManagerClass();

	const propTypes$1 = {
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Toast = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.theme = 'light';
	    }
	    addMessage(message) {
	        toastManager.addMessage(message);
	    }
	    connectedCallback() {
	        toastManager.register(this.host, () => this.toastItemElement.classList.add(toastCloseClassName));
	    }
	    componentDidLoad() {
	        this.host.addEventListener('dismiss', (e) => {
	            e.stopPropagation(); // to cancel bubbling chain from toast-item
	            toastManager.dismissToastItem();
	        });
	    }
	    componentShouldUpdate(_, __, propName) {
	        return propName !== 'theme';
	    }
	    disconnectedCallback() {
	        toastManager.unregister();
	    }
	    render() {
	        validateProps.validateProps(this, propTypes$1);
	        validateProps.attachComponentCss(this.host, getComponentCss$1);
	        this.toastItemElement?.classList.remove(toastCloseClassName);
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        const toast = toastManager.getToast();
	        return (validateProps.h(validateProps.Host, { key: 'f002a161fbd6173e89c754ff062a55d458363e60', role: "status", "aria-live": "polite" }, toast && (validateProps.h(PrefixedTagNames.pToastItem, { key: '9f249d997b787e47b76da81b9891bad36f69dee3', ...toast, theme: this.theme, ref: (el) => (this.toastItemElement = el) }))));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	/** @deprecated */
	const TOAST_STATES_DEPRECATED = ['neutral']; // state neutral as default state is deprecated in v3 (new state: 'info')
	const TOAST_STATES = ['info', 'success', ...TOAST_STATES_DEPRECATED];

	const getComponentCss = (state, theme) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                display: 'grid',
	                opacity: 0, // needed to prevent flickering on initial render
	                ...validateProps.addImportantToEachRule({
	                    maxWidth: 'inherit',
	                    boxSizing: 'border-box',
	                    margin: 0, // ua popover reset
	                    inset: 'inherit', // ua popover reset
	                    border: '0', // ua popover reset
	                    outline: '0', // ua popover reset
	                    overflow: 'visible', // ua popover reset
	                    width: 'auto', // ua popover reset
	                    height: 'auto', // ua popover reset
	                }),
	                ...inlineNotificationUtils.getNotificationRootJssStyle(state, false, true, theme),
	                ...constants.dropShadowHighStyle,
	                '&::backdrop': {
	                    display: 'none',
	                },
	            },
	            ...preventFoucOfNestedElementsStyles.preventFoucOfNestedElementsStyles,
	            p: {
	                ...textSmallStyle.textSmallStyle,
	                margin: 0,
	                color: validateProps.getThemedColors(theme).primaryColor,
	                ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                    color: validateProps.getThemedColors('dark').primaryColor,
	                }),
	                ...inlineNotificationUtils.getNotificationContentJssStyle(),
	            },
	        },
	        icon: inlineNotificationUtils.getNotificationIconJssStyle(),
	        close: {
	            ...validateProps.dismissButtonJssStyle,
	            mixBlendMode: validateProps.isThemeDark(theme) ? 'plus-lighter' : 'multiply',
	            ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                mixBlendMode: 'plus-lighter',
	            }),
	        },
	    });
	};

	const propTypes = {
	    text: validateProps.AllowedTypes.string,
	    state: validateProps.AllowedTypes.oneOf(TOAST_STATES),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const ToastItem = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.dismiss = validateProps.createEvent(this, "dismiss", 7);
	        this.text = '';
	        this.state = 'info';
	        this.theme = 'light';
	    }
	    connectedCallback() {
	        throwIfRootNodeIsNotOneOfKind.throwIfRootNodeIsNotOneOfKind(this.host, ['p-toast']);
	    }
	    componentDidRender() {
	        if (validateProps.getHasNativePopoverSupport()) {
	            this.host.showPopover();
	        }
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'state', {
	            neutral: 'info',
	        });
	        validateProps.attachComponentCss(this.host, getComponentCss, this.state, this.theme);
	        const toastId = 'toast';
	        const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	        return (validateProps.h(validateProps.Host, { key: '57823d6e42272e147e1bece692db236a0621d641', popover: "manual" }, validateProps.h(PrefixedTagNames.pIcon, { key: 'cfc730e49b0b444b65c0348807bc022fd6f3b3eb', class: "icon", name: inlineNotificationUtils.getInlineNotificationIconName(this.state), color: `notification-${this.state}`, theme: this.theme, "aria-hidden": "true" }), validateProps.h("p", { key: '624a1bcfb3b447e21db4ee55e6db70f0069abdf0', id: toastId, innerHTML: this.text }), validateProps.h(PrefixedTagNames.pButton, { key: 'd8520b77a3f177130398deb68fd95231d4bb86a6', variant: "ghost", theme: this.theme, class: "close", type: "button", icon: "close", hideLabel: true, "aria-controls": toastId, onClick: this.dismiss.emit }, "Close notification message")));
	    }
	    get host() { return validateProps.getElement(this); }
	};

	pToast_2_cjs_entry.p_toast = Toast;
	pToast_2_cjs_entry.p_toast_item = ToastItem;

	
	return pToast_2_cjs_entry;
}

var pWordmark_cjs_entry = {};

var hasRequiredPWordmark_cjs_entry;

function requirePWordmark_cjs_entry () {
	if (hasRequiredPWordmark_cjs_entry) return pWordmark_cjs_entry;
	hasRequiredPWordmark_cjs_entry = 1;

	Object.defineProperty(pWordmark_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const linkAriaAttribute = requireLinkAriaAttribute6f29e1a0();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles4bc3d59c();

	const WORDMARK_SIZES = ['small', 'inherit'];

	const getComponentCss = (size, theme) => {
	    return validateProps.getCss({
	        '@global': {
	            ':host': {
	                position: 'relative',
	                display: 'inline-block',
	                verticalAlign: 'top',
	                ...validateProps.addImportantToEachRule({
	                    outline: 0,
	                    maxWidth: '100%',
	                    maxHeight: '100%',
	                    boxSizing: 'content-box', // needed for correct height calculation when padding is set on host (e.g. custom click area)
	                    ...(size !== 'inherit' && {
	                        height: 'clamp(0.63rem, 0.42vw + 0.5rem, 1rem)',
	                        // workaround for Safari to optimize image rendering
	                        '@supports (height: round(down, 1px, 1px))': {
	                            height: 'round(down, clamp(0.63rem, 0.42vw + 0.5rem, 1rem), 1px)',
	                        },
	                    }),
	                    ...colorSchemeStyles.colorSchemeStyles,
	                    ...colorSchemeStyles.hostHiddenStyles,
	                }),
	            },
	            'a, svg': {
	                display: 'block',
	                maxWidth: '100%',
	                maxHeight: '100%',
	                height: 'inherit',
	            },
	            a: {
	                textDecoration: 'none',
	                '&::before': {
	                    // needs to be defined always to have correct custom click area
	                    content: '""',
	                    position: 'absolute',
	                    inset: 0,
	                    borderRadius: '1px',
	                },
	                ...validateProps.getFocusJssStyle('light', { pseudo: true }), // TODO: we need to support theme
	            },
	            svg: validateProps.isHighContrastMode
	                ? {
	                    fill: validateProps.getHighContrastColors().canvasTextColor,
	                }
	                : {
	                    fill: validateProps.getThemedColors(theme).primaryColor,
	                    ...validateProps.prefersColorSchemeDarkMediaQuery(theme, {
	                        fill: validateProps.getThemedColors('dark').primaryColor,
	                    }),
	                },
	        },
	    });
	};

	const propTypes = {
	    size: validateProps.AllowedTypes.oneOf(WORDMARK_SIZES),
	    theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	    href: validateProps.AllowedTypes.string,
	    target: validateProps.AllowedTypes.string,
	    aria: validateProps.AllowedTypes.aria(linkAriaAttribute.LINK_ARIA_ATTRIBUTES),
	};
	const Wordmark = class {
	    constructor(hostRef) {
	        validateProps.registerInstance(this, hostRef);
	        this.size = 'small';
	        this.theme = 'light';
	        this.href = undefined;
	        this.target = '_self';
	        this.aria = undefined;
	    }
	    componentShouldUpdate(newVal, oldVal) {
	        return validateProps.hasPropValueChanged(newVal, oldVal);
	    }
	    render() {
	        validateProps.validateProps(this, propTypes);
	        validateProps.attachComponentCss(this.host, getComponentCss, this.size, this.theme);
	        // optimized with SVGO, see docs in assets folder
	        const svg = (validateProps.h("svg", { key: '7d4df80ccdd1903eea962542c3ebb4be83dbca3d', xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 4500 300" }, validateProps.h("title", { key: 'c57f3efb77e44dc80ceca095b892ac49279d187d' }, "Porsche"), validateProps.h("path", { key: '7d6f3c0bea68e8ff9948d2fcb2a7d1474b74c263', d: "M502 221c48.1 0 74-25.9 74-74V74c0-48.1-25.9-74-74-74H0v300h68v-79h434zm6-143v65c0 7.8-4.2 12-12 12H68V66h428c7.8 0 12 4.2 12 12zm228 222c-48.1 0-74-25.9-74-74V74c0-48.1 25.9-74 74-74h417c48.1 0 74 25.9 74 74v152c0 48.1-25.9 74-74 74H736zm411-66c7.8 0 12-4.2 12-12V78c0-7.8-4.2-12-12-12H742c-7.8 0-12 4.2-12 12v144c0 7.8 4.2 12 12 12h405zm675-36c39.844 16.757 67.853 56.1 68 102h-68c0-54-25-79-79-79h-361v79h-68V0h502c48.1 0 74 25.9 74 74v50.14c0 46.06-23.75 71.76-68 73.86zm-12-43c7.8 0 12-4.2 12-12V78c0-7.8-4.2-12-12-12h-428v89h428zm162-81c0-48.1 25.9-74 74-74h492v56h-486c-7.8 0-12 4.2-12 12v42c0 7.8 4.2 12 12 12h422c48.1 0 74 25.9 74 74v30c0 48.1-25.9 74-74 74h-492v-56h486c7.8 0 12-4.2 12-12v-42c0-7.8-4.2-12-12-12h-422c-48.1 0-74-25.9-74-74V74zm661 0c0-48.1 25.9-74 74-74h480v66h-474c-7.8 0-12 4.2-12 12v144c0 7.8 4.2 12 12 12h474v66h-480c-48.1 0-74-25.9-74-74V74zM3817 0v300h-68V183h-407v117h-68V0h68v117h407V0h68zm156 56v66h527v56h-527v66h527v56h-595V0h595v56h-527z" })));
	        return (validateProps.h(validateProps.Host, { key: '2a4620d88ac9cc0272a76f41dea9971659e9f955' }, this.href === undefined ? (svg) : (validateProps.h("a", { href: this.href, target: this.target, ...validateProps.parseAndGetAriaAttributes(this.aria) }, svg))));
	    }
	    static get delegatesFocus() { return true; }
	    get host() { return validateProps.getElement(this); }
	};

	pWordmark_cjs_entry.p_wordmark = Wordmark;

	
	return pWordmark_cjs_entry;
}

var porscheDesignSystem_cjs = {};

var hasRequiredPorscheDesignSystem_cjs;

function requirePorscheDesignSystem_cjs () {
	if (hasRequiredPorscheDesignSystem_cjs) return porscheDesignSystem_cjs;
	hasRequiredPorscheDesignSystem_cjs = 1;

	Object.defineProperty(porscheDesignSystem_cjs, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const appGlobals = requireAppGlobals2f0cb516();
	requireGetCDNBaseURLE7722df3();

	/*
	 Stencil Client Patch Browser v4.23.0 | MIT Licensed | https://stenciljs.com
	 */
	var patchBrowser = () => {
	  const importMeta = (typeof document === 'undefined' ? new (createCommonjsRequire("/src/lib")('u' + 'rl').URL)('file:' + __filename).href : (document.currentScript && document.currentScript.src || new URL('porsche-design-system.cjs.js', document.baseURI).href));
	  const opts = {};
	  if (importMeta !== "") {
	    opts.resourcesUrl = new URL(".", importMeta).href;
	  }
	  return validateProps.promiseResolve(opts);
	};

	patchBrowser().then(async (options) => {
	  if(!window.PDS_SKIP_FETCH) { appGlobals.globalScripts(); }
	  return validateProps.bootstrapLazy(JSON.parse("[[\"p-table_7.cjs\",[[1,\"p-table\",{\"caption\":[1],\"compact\":[4],\"layout\":[1],\"theme\":[1]}],[1,\"p-table-body\"],[1,\"p-table-cell\",{\"multiline\":[4]}],[1,\"p-table-head\"],[1,\"p-table-head-cell\",{\"sort\":[16],\"hideLabel\":[4,\"hide-label\"],\"multiline\":[4]}],[1,\"p-table-head-row\"],[1,\"p-table-row\"]]],[\"p-flex_2.cjs\",[[1,\"p-flex\",{\"inline\":[8],\"wrap\":[1],\"direction\":[1],\"justifyContent\":[1,\"justify-content\"],\"alignItems\":[1,\"align-items\"],\"alignContent\":[1,\"align-content\"]}],[1,\"p-flex-item\",{\"width\":[1],\"offset\":[1],\"alignSelf\":[1,\"align-self\"],\"grow\":[8],\"shrink\":[8],\"flex\":[1]}]]],[\"p-flyout-multilevel_2.cjs\",[[1,\"p-flyout-multilevel\",{\"open\":[4],\"activeIdentifier\":[1,\"active-identifier\"],\"aria\":[1],\"theme\":[1],\"flyoutMultilevelItemElements\":[32],\"primary\":[32],\"isSecondaryDrawerVisible\":[32]},[[0,\"internalUpdate\",\"onInternalUpdate\"]],{\"open\":[\"openChangeHandler\"],\"activeIdentifier\":[\"activeIdentifierChangeHandler\"],\"theme\":[\"themeChangeHandler\"]}],[1,\"p-flyout-multilevel-item\",{\"label\":[1],\"identifier\":[513],\"primary\":[1540],\"secondary\":[1540],\"cascade\":[1540]}]]],[\"p-grid_2.cjs\",[[1,\"p-grid\",{\"direction\":[1],\"wrap\":[1],\"gutter\":[8]}],[1,\"p-grid-item\",{\"size\":[8],\"offset\":[8]}]]],[\"p-multi-select_2.cjs\",[[81,\"p-multi-select\",{\"label\":[1],\"description\":[1],\"name\":[513],\"value\":[1040],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"disabled\":[4],\"required\":[4],\"dropdownDirection\":[1,\"dropdown-direction\"],\"theme\":[1],\"form\":[513],\"isOpen\":[32],\"srHighlightedOptionText\":[32],\"hasFilterResults\":[32]},[[0,\"internalOptionUpdate\",\"updateOptionHandler\"]],{\"value\":[\"onValueChange\"],\"isOpen\":[\"onIsOpenChange\"]}],[1,\"p-multi-select-option\",{\"value\":[1],\"disabled\":[4]}]]],[\"p-segmented-control_2.cjs\",[[65,\"p-segmented-control\",{\"backgroundColor\":[1,\"background-color\"],\"theme\":[1],\"value\":[1032],\"name\":[513],\"columns\":[8],\"form\":[513],\"disabled\":[1028]},[[0,\"internalSegmentedControlItemUpdate\",\"updateSegmentedControlItemHandler\"]],{\"value\":[\"onValueChange\"]}],[17,\"p-segmented-control-item\",{\"value\":[8],\"disabled\":[4],\"label\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"aria\":[1]},null,{\"label\":[\"handleLabelChange\"],\"icon\":[\"handleLabelChange\"],\"iconSource\":[\"handleLabelChange\"]}]]],[\"p-select-wrapper_2.cjs\",[[17,\"p-select-wrapper\",{\"label\":[1],\"description\":[1],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"filter\":[4],\"theme\":[1],\"dropdownDirection\":[1,\"dropdown-direction\"],\"native\":[4]}],[17,\"p-select-wrapper-dropdown\",{\"selectRef\":[16],\"label\":[1],\"description\":[1],\"message\":[1],\"state\":[1],\"direction\":[1],\"theme\":[1],\"filter\":[4],\"required\":[4],\"disabled\":[4],\"onOpenChange\":[16],\"isOpenOverride\":[4,\"is-open-override\"],\"isOpen\":[32],\"optionMaps\":[32],\"searchString\":[32]},null,{\"isOpen\":[\"onIsOpenChange\"]}]]],[\"p-select_2.cjs\",[[81,\"p-select\",{\"label\":[1],\"description\":[1],\"name\":[513],\"value\":[1025],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"disabled\":[1028],\"required\":[4],\"dropdownDirection\":[1,\"dropdown-direction\"],\"compact\":[4],\"theme\":[1],\"form\":[513],\"isOpen\":[32],\"srHighlightedOptionText\":[32]},[[0,\"internalOptionUpdate\",\"updateOptionHandler\"]],{\"value\":[\"onValueChange\"],\"isOpen\":[\"onIsOpenChange\"]}],[1,\"p-select-option\",{\"value\":[1],\"disabled\":[4]}]]],[\"p-stepper-horizontal_2.cjs\",[[1,\"p-stepper-horizontal\",{\"size\":[1],\"theme\":[1]}],[17,\"p-stepper-horizontal-item\",{\"state\":[1],\"disabled\":[4]},[[2,\"click\",\"onClick\"]],{\"state\":[\"onStateChange\"]}]]],[\"p-tabs_2.cjs\",[[1,\"p-tabs\",{\"size\":[1],\"weight\":[1],\"theme\":[1],\"gradientColorScheme\":[1,\"gradient-color-scheme\"],\"gradientColor\":[1,\"gradient-color\"],\"activeTabIndex\":[1026,\"active-tab-index\"],\"tabsItemElements\":[32]},null,{\"activeTabIndex\":[\"activeTabHandler\"]}],[1,\"p-tabs-item\",{\"label\":[1]},null,{\"label\":[\"handleLabelChange\"]}]]],[\"p-text-list_2.cjs\",[[1,\"p-text-list\",{\"listType\":[1,\"list-type\"],\"orderType\":[1,\"order-type\"],\"type\":[1],\"theme\":[1]}],[1,\"p-text-list-item\"]]],[\"p-toast_2.cjs\",[[1,\"p-toast\",{\"theme\":[1],\"addMessage\":[64]}],[1,\"p-toast-item\",{\"text\":[1],\"state\":[1],\"theme\":[1]}]]],[\"p-accordion.cjs\",[[1,\"p-accordion\",{\"size\":[1],\"theme\":[1],\"heading\":[1],\"headingTag\":[1,\"heading-tag\"],\"tag\":[1],\"open\":[4],\"compact\":[4],\"sticky\":[4]}]]],[\"p-banner.cjs\",[[1,\"p-banner\",{\"open\":[4],\"heading\":[1],\"headingTag\":[1,\"heading-tag\"],\"description\":[1],\"state\":[1],\"dismissButton\":[4,\"dismiss-button\"],\"persistent\":[4],\"width\":[1],\"theme\":[1]},null,{\"open\":[\"openChangeHandler\"]}]]],[\"p-button.cjs\",[[81,\"p-button\",{\"type\":[1],\"name\":[513],\"value\":[1],\"disabled\":[4],\"loading\":[4],\"variant\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"hideLabel\":[8,\"hide-label\"],\"compact\":[8],\"theme\":[1],\"aria\":[1],\"form\":[513]},[[2,\"click\",\"onClick\"]],{\"value\":[\"onValueChange\"]}]]],[\"p-button-group.cjs\",[[1,\"p-button-group\",{\"direction\":[1]}]]],[\"p-button-pure.cjs\",[[81,\"p-button-pure\",{\"type\":[1],\"name\":[513],\"value\":[1],\"disabled\":[4],\"loading\":[4],\"size\":[1],\"weight\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"underline\":[4],\"active\":[4],\"hideLabel\":[8,\"hide-label\"],\"alignLabel\":[1,\"align-label\"],\"stretch\":[8],\"theme\":[1],\"aria\":[1],\"form\":[513]},[[2,\"click\",\"onClick\"]],{\"value\":[\"onValueChange\"]}]]],[\"p-button-tile.cjs\",[[17,\"p-button-tile\",{\"size\":[1],\"weight\":[1],\"background\":[1],\"aspectRatio\":[1,\"aspect-ratio\"],\"label\":[1],\"description\":[1],\"align\":[1],\"gradient\":[4],\"compact\":[8],\"type\":[1],\"disabled\":[4],\"loading\":[4],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"aria\":[1]},[[2,\"click\",\"onClick\"]]]]],[\"p-canvas.cjs\",[[1,\"p-canvas\",{\"sidebarStartOpen\":[4,\"sidebar-start-open\"],\"sidebarEndOpen\":[4,\"sidebar-end-open\"],\"theme\":[1],\"isMediaQueryS\":[32],\"isMediaQueryM\":[32]},null,{\"sidebarStartOpen\":[\"openChangeHandlerSidebarStart\"],\"sidebarEndOpen\":[\"openChangeHandlerSidebarEnd\"]}]]],[\"p-carousel.cjs\",[[1,\"p-carousel\",{\"heading\":[1],\"headingSize\":[1,\"heading-size\"],\"description\":[1],\"alignHeader\":[1,\"align-header\"],\"alignControls\":[1,\"align-controls\"],\"rewind\":[4],\"wrapContent\":[4,\"wrap-content\"],\"width\":[1],\"slidesPerPage\":[8,\"slides-per-page\"],\"disablePagination\":[8,\"disable-pagination\"],\"pagination\":[8],\"aria\":[1],\"intl\":[1],\"theme\":[1],\"activeSlideIndex\":[2,\"active-slide-index\"],\"skipLinkTarget\":[1,\"skip-link-target\"],\"focusOnCenterSlide\":[4,\"focus-on-center-slide\"],\"gradientColor\":[1,\"gradient-color\"],\"trimSpace\":[4,\"trim-space\"],\"amountOfPages\":[32]},null,{\"activeSlideIndex\":[\"activeSlideHandler\"]}]]],[\"p-checkbox.cjs\",[[81,\"p-checkbox\",{\"name\":[513],\"required\":[4],\"disabled\":[4],\"indeterminate\":[4],\"checked\":[1028],\"form\":[513],\"value\":[1],\"label\":[1],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"loading\":[4],\"compact\":[4],\"theme\":[1]},[[0,\"keydown\",\"onKeydown\"]],{\"value\":[\"onValueChange\"],\"indeterminate\":[\"onIndeterminateChange\"],\"checked\":[\"onCheckedChange\"]}]]],[\"p-checkbox-wrapper.cjs\",[[1,\"p-checkbox-wrapper\",{\"label\":[1],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"loading\":[4],\"theme\":[1]},[[0,\"keydown\",\"onKeydown\"]]]]],[\"p-content-wrapper.cjs\",[[1,\"p-content-wrapper\",{\"width\":[1],\"backgroundColor\":[1,\"background-color\"],\"theme\":[1]}]]],[\"p-crest.cjs\",[[17,\"p-crest\",{\"href\":[1],\"target\":[1],\"aria\":[1]}]]],[\"p-display.cjs\",[[1,\"p-display\",{\"tag\":[1],\"size\":[1],\"align\":[1],\"color\":[1],\"ellipsis\":[4],\"theme\":[1]}]]],[\"p-divider.cjs\",[[1,\"p-divider\",{\"color\":[1],\"orientation\":[1],\"direction\":[1],\"theme\":[1]}]]],[\"p-fieldset.cjs\",[[1,\"p-fieldset\",{\"label\":[1],\"labelSize\":[1,\"label-size\"],\"required\":[4],\"state\":[1],\"message\":[1],\"theme\":[1]}]]],[\"p-fieldset-wrapper.cjs\",[[1,\"p-fieldset-wrapper\",{\"label\":[1],\"labelSize\":[1,\"label-size\"],\"required\":[4],\"state\":[1],\"message\":[1],\"theme\":[1]}]]],[\"p-flyout.cjs\",[[1,\"p-flyout\",{\"open\":[4],\"position\":[1],\"disableBackdropClick\":[4,\"disable-backdrop-click\"],\"footerBehavior\":[1,\"footer-behavior\"],\"theme\":[1],\"aria\":[1]}]]],[\"p-heading.cjs\",[[1,\"p-heading\",{\"tag\":[1],\"size\":[1],\"align\":[1],\"color\":[1],\"ellipsis\":[4],\"theme\":[1]}]]],[\"p-headline.cjs\",[[1,\"p-headline\",{\"variant\":[1],\"tag\":[1],\"align\":[1],\"color\":[1],\"ellipsis\":[4],\"theme\":[1]}]]],[\"p-icon.cjs\",[[1,\"p-icon\",{\"name\":[1],\"source\":[1],\"color\":[1],\"size\":[1],\"lazy\":[4],\"theme\":[1],\"aria\":[1]}]]],[\"p-inline-notification.cjs\",[[1,\"p-inline-notification\",{\"heading\":[1],\"headingTag\":[1,\"heading-tag\"],\"description\":[1],\"state\":[1],\"dismissButton\":[4,\"dismiss-button\"],\"persistent\":[4],\"actionLabel\":[1,\"action-label\"],\"actionLoading\":[4,\"action-loading\"],\"actionIcon\":[1,\"action-icon\"],\"theme\":[1]}]]],[\"p-link.cjs\",[[17,\"p-link\",{\"variant\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"href\":[1],\"target\":[1],\"download\":[1],\"rel\":[1],\"hideLabel\":[8,\"hide-label\"],\"compact\":[8],\"theme\":[1],\"aria\":[1]}]]],[\"p-link-pure.cjs\",[[17,\"p-link-pure\",{\"alignLabel\":[1,\"align-label\"],\"stretch\":[8],\"size\":[1],\"weight\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"underline\":[4],\"href\":[1],\"active\":[4],\"hideLabel\":[8,\"hide-label\"],\"theme\":[1],\"target\":[1],\"download\":[1],\"rel\":[1],\"aria\":[1]}]]],[\"p-link-social.cjs\",[[17,\"p-link-social\",{\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"href\":[1],\"target\":[1],\"rel\":[1],\"hideLabel\":[8,\"hide-label\"],\"compact\":[4],\"theme\":[1]}]]],[\"p-link-tile.cjs\",[[17,\"p-link-tile\",{\"size\":[1],\"weight\":[1],\"background\":[1],\"aspectRatio\":[1,\"aspect-ratio\"],\"label\":[1],\"description\":[1],\"align\":[1],\"gradient\":[4],\"compact\":[8],\"href\":[1],\"target\":[1],\"download\":[1],\"rel\":[1],\"aria\":[1]}]]],[\"p-link-tile-model-signature.cjs\",[[1,\"p-link-tile-model-signature\",{\"model\":[1],\"weight\":[1],\"aspectRatio\":[1,\"aspect-ratio\"],\"heading\":[1],\"description\":[1],\"linkDirection\":[1,\"link-direction\"],\"headingTag\":[1,\"heading-tag\"]}]]],[\"p-link-tile-product.cjs\",[[17,\"p-link-tile-product\",{\"heading\":[1],\"price\":[1],\"priceOriginal\":[1,\"price-original\"],\"description\":[1],\"likeButton\":[4,\"like-button\"],\"liked\":[4],\"href\":[1],\"aspectRatio\":[1,\"aspect-ratio\"],\"target\":[1],\"rel\":[1],\"theme\":[1]}]]],[\"p-marque.cjs\",[[17,\"p-marque\",{\"trademark\":[4],\"variant\":[1],\"size\":[1],\"href\":[1],\"target\":[1],\"aria\":[1]}]]],[\"p-modal.cjs\",[[1,\"p-modal\",{\"open\":[4],\"disableCloseButton\":[4,\"disable-close-button\"],\"dismissButton\":[4,\"dismiss-button\"],\"disableBackdropClick\":[4,\"disable-backdrop-click\"],\"heading\":[1],\"backdrop\":[1],\"fullscreen\":[8],\"aria\":[1],\"theme\":[1]}]]],[\"p-model-signature.cjs\",[[1,\"p-model-signature\",{\"model\":[1],\"safeZone\":[4,\"safe-zone\"],\"fetchPriority\":[1,\"fetch-priority\"],\"lazy\":[4],\"size\":[1],\"color\":[1],\"theme\":[1]}]]],[\"p-optgroup.cjs\",[[1,\"p-optgroup\",{\"label\":[1],\"disabled\":[4]},null,{\"disabled\":[\"handleDisabledChange\"]}]]],[\"p-pagination.cjs\",[[17,\"p-pagination\",{\"totalItemsCount\":[2,\"total-items-count\"],\"itemsPerPage\":[2,\"items-per-page\"],\"activePage\":[1026,\"active-page\"],\"maxNumberOfPageLinks\":[8,\"max-number-of-page-links\"],\"showLastPage\":[4,\"show-last-page\"],\"allyLabel\":[1,\"ally-label\"],\"allyLabelPrev\":[1,\"ally-label-prev\"],\"allyLabelPage\":[1,\"ally-label-page\"],\"allyLabelNext\":[1,\"ally-label-next\"],\"intl\":[1],\"theme\":[1]}]]],[\"p-pin-code.cjs\",[[81,\"p-pin-code\",{\"label\":[1],\"description\":[1],\"name\":[513],\"length\":[2],\"hideLabel\":[8,\"hide-label\"],\"state\":[1],\"disabled\":[4],\"loading\":[4],\"required\":[4],\"message\":[1],\"type\":[1],\"value\":[1025],\"theme\":[1],\"form\":[513]}]]],[\"p-popover.cjs\",[[1,\"p-popover\",{\"direction\":[1],\"description\":[1],\"aria\":[1],\"theme\":[1],\"isOpen\":[32]}]]],[\"p-radio-button-wrapper.cjs\",[[1,\"p-radio-button-wrapper\",{\"label\":[1],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"loading\":[4],\"theme\":[1]}]]],[\"p-scroller.cjs\",[[1,\"p-scroller\",{\"gradientColorScheme\":[1,\"gradient-color-scheme\"],\"gradientColor\":[1,\"gradient-color\"],\"scrollToPosition\":[1025,\"scroll-to-position\"],\"scrollIndicatorPosition\":[1,\"scroll-indicator-position\"],\"alignScrollIndicator\":[1,\"align-scroll-indicator\"],\"theme\":[1],\"scrollbar\":[4],\"aria\":[1],\"isPrevHidden\":[32],\"isNextHidden\":[32]},null,{\"scrollToPosition\":[\"scrollToPositionHandler\"]}]]],[\"p-sheet.cjs\",[[1,\"p-sheet\",{\"open\":[4],\"dismissButton\":[4,\"dismiss-button\"],\"disableBackdropClick\":[4,\"disable-backdrop-click\"],\"aria\":[1],\"theme\":[1]}]]],[\"p-spinner.cjs\",[[1,\"p-spinner\",{\"size\":[1],\"theme\":[1],\"aria\":[1]}]]],[\"p-switch.cjs\",[[17,\"p-switch\",{\"alignLabel\":[1,\"align-label\"],\"hideLabel\":[8,\"hide-label\"],\"stretch\":[8],\"checked\":[4],\"disabled\":[4],\"loading\":[4],\"compact\":[4],\"theme\":[1]},[[2,\"click\",\"onClick\"]]]]],[\"p-tabs-bar.cjs\",[[1,\"p-tabs-bar\",{\"size\":[1],\"weight\":[1],\"theme\":[1],\"gradientColorScheme\":[1,\"gradient-color-scheme\"],\"gradientColor\":[1,\"gradient-color\"],\"activeTabIndex\":[2,\"active-tab-index\"],\"tabElements\":[32]},null,{\"activeTabIndex\":[\"activeTabIndexHandler\"]}]]],[\"p-tag.cjs\",[[1,\"p-tag\",{\"theme\":[1],\"color\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"compact\":[4]}]]],[\"p-tag-dismissible.cjs\",[[17,\"p-tag-dismissible\",{\"color\":[1],\"theme\":[1],\"label\":[1],\"aria\":[1]}]]],[\"p-text.cjs\",[[1,\"p-text\",{\"tag\":[1],\"size\":[1],\"weight\":[1],\"align\":[1],\"color\":[1],\"ellipsis\":[4],\"theme\":[1]}]]],[\"p-text-field-wrapper.cjs\",[[1,\"p-text-field-wrapper\",{\"label\":[1],\"unit\":[1],\"unitPosition\":[1,\"unit-position\"],\"description\":[1],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"showCharacterCount\":[4,\"show-character-count\"],\"showCounter\":[4,\"show-counter\"],\"actionIcon\":[1,\"action-icon\"],\"actionLoading\":[4,\"action-loading\"],\"submitButton\":[4,\"submit-button\"],\"showPasswordToggle\":[4,\"show-password-toggle\"],\"theme\":[1],\"showPassword\":[32],\"isClearable\":[32]},null,{\"showCounter\":[\"onShowCounterChange\"]}]]],[\"p-textarea.cjs\",[[81,\"p-textarea\",{\"label\":[1],\"description\":[1],\"name\":[513],\"value\":[1025],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"showCounter\":[4,\"show-counter\"],\"placeholder\":[1],\"required\":[4],\"disabled\":[4],\"maxLength\":[2,\"max-length\"],\"minLength\":[2,\"min-length\"],\"form\":[513],\"rows\":[2],\"autoComplete\":[1,\"auto-complete\"],\"spellCheck\":[4,\"spell-check\"],\"wrap\":[1],\"resize\":[1],\"readOnly\":[4,\"read-only\"],\"theme\":[1]},null,{\"value\":[\"onValueChange\"],\"maxLength\":[\"onMaxLengthChange\"],\"showCounter\":[\"onShowCounterChange\"]}]]],[\"p-textarea-wrapper.cjs\",[[1,\"p-textarea-wrapper\",{\"label\":[1],\"description\":[1],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"showCharacterCount\":[4,\"show-character-count\"],\"showCounter\":[4,\"show-counter\"],\"theme\":[1]},null,{\"showCounter\":[\"onShowCounterChange\"]}]]],[\"p-wordmark.cjs\",[[17,\"p-wordmark\",{\"size\":[1],\"theme\":[1],\"href\":[1],\"target\":[1],\"aria\":[1]}]]]]"), options);
	});

	porscheDesignSystem_cjs.setNonce = validateProps.setNonce;

	
	return porscheDesignSystem_cjs;
}

var dynamicModules;

function getDynamicModules() {
	return dynamicModules || (dynamicModules = {
		"/src/index.js": requireSrc,
		"/src/lib/align-label-7a9d9074.js": requireAlignLabel7a9d9074,
		"/src/lib/app-globals-2f0cb516.js": requireAppGlobals2f0cb516,
		"/src/lib/applyCheckboxRadioButtonSafariRenderingFix-e0db2b50.js": requireApplyCheckboxRadioButtonSafariRenderingFixE0db2b50,
		"/src/lib/banner-utils-2cc83734.js": requireBannerUtils2cc83734,
		"/src/lib/borderRadiusLarge-a0aa3a01.js": requireBorderRadiusLargeA0aa3a01,
		"/src/lib/borderRadiusMedium-758b9411.js": requireBorderRadiusMedium758b9411,
		"/src/lib/borderRadiusSmall-5f37fc45.js": requireBorderRadiusSmall5f37fc45,
		"/src/lib/button-handling-39869edc.js": requireButtonHandling39869edc,
		"/src/lib/button-link-pure-utils-42aabf78.js": requireButtonLinkPureUtils42aabf78,
		"/src/lib/button-type-ae0c09db.js": requireButtonTypeAe0c09db,
		"/src/lib/changeColor-50831612.js": requireChangeColor50831612,
		"/src/lib/color-scheme-styles-4bc3d59c.js": requireColorSchemeStyles4bc3d59c,
		"/src/lib/constants-3998cc0f.js": requireConstants3998cc0f,
		"/src/lib/dialog-styles-52804ea9.js": requireDialogStyles52804ea9,
		"/src/lib/displayShared-adef5fa6.js": requireDisplaySharedAdef5fa6,
		"/src/lib/dropShadowShared-6e50faf3.js": requireDropShadowShared6e50faf3,
		"/src/lib/fieldset-utils-7753153f.js": requireFieldsetUtils7753153f,
		"/src/lib/font-size-text-styles-4439a071.js": requireFontSizeTextStyles4439a071,
		"/src/lib/font-weight-styles-b74e8683.js": requireFontWeightStylesB74e8683,
		"/src/lib/fontFamily-23874d28.js": requireFontFamily23874d28,
		"/src/lib/fontLineHeight-d4b9e1a9.js": requireFontLineHeightD4b9e1a9,
		"/src/lib/fontSizeHeadingLarge-c355151d.js": requireFontSizeHeadingLargeC355151d,
		"/src/lib/fontSizeHeadingMedium-c49ab5a2.js": requireFontSizeHeadingMediumC49ab5a2,
		"/src/lib/fontSizeHeadingSmall-a15141a5.js": requireFontSizeHeadingSmallA15141a5,
		"/src/lib/fontSizeText-728b6387.js": requireFontSizeText728b6387,
		"/src/lib/fontSizeTextLarge-05a4bc90.js": requireFontSizeTextLarge05a4bc90,
		"/src/lib/fontSizeTextMedium-88887ad8.js": requireFontSizeTextMedium88887ad8,
		"/src/lib/fontSizeTextSmall-508930e5.js": requireFontSizeTextSmall508930e5,
		"/src/lib/fontSizeTextXLarge-0ecf9ef3.js": requireFontSizeTextXLarge0ecf9ef3,
		"/src/lib/fontSizeTextXSmall-e59d35d7.js": requireFontSizeTextXSmallE59d35d7,
		"/src/lib/fontSizeTextXXSmall-a02f9c40.js": requireFontSizeTextXXSmallA02f9c40,
		"/src/lib/fontVariant-6ba3b7cb.js": requireFontVariant6ba3b7cb,
		"/src/lib/fontWeightRegular-d0c768ac.js": requireFontWeightRegularD0c768ac,
		"/src/lib/fontWeightSemiBold-4482c830.js": requireFontWeightSemiBold4482c830,
		"/src/lib/forced-colors-media-query-69d5b1ca.js": requireForcedColorsMediaQuery69d5b1ca,
		"/src/lib/form-styles-deecb9a1.js": requireFormStylesDeecb9a1,
		"/src/lib/form-utils-876806ab.js": requireFormUtils876806ab,
		"/src/lib/frostedGlassStyle-bd067e45.js": requireFrostedGlassStyleBd067e45,
		"/src/lib/get-button-base-aria-attributes-84dbc1f1.js": requireGetButtonBaseAriaAttributes84dbc1f1,
		"/src/lib/getAttribute-9c66ed26.js": requireGetAttribute9c66ed26,
		"/src/lib/getCDNBaseURL-e7722df3.js": requireGetCDNBaseURLE7722df3,
		"/src/lib/getClosestHTMLElement-83d01a84.js": requireGetClosestHTMLElement83d01a84,
		"/src/lib/getDirectChildHTMLElement-18d9487f.js": requireGetDirectChildHTMLElement18d9487f,
		"/src/lib/getDirectChildHTMLElements-2594e5bd.js": requireGetDirectChildHTMLElements2594e5bd,
		"/src/lib/getHTMLElements-3f1c700f.js": requireGetHTMLElements3f1c700f,
		"/src/lib/getInlineSVGBackgroundImage-b65404d9.js": requireGetInlineSVGBackgroundImageB65404d9,
		"/src/lib/getMediaQueryMax-5b73ea17.js": requireGetMediaQueryMax5b73ea17,
		"/src/lib/getNamedSlot-223c478a.js": requireGetNamedSlot223c478a,
		"/src/lib/getOnlyChildOfKindHTMLElementOrThrow-cdb95e52.js": requireGetOnlyChildOfKindHTMLElementOrThrowCdb95e52,
		"/src/lib/getSlotTextContent-3ec731e2.js": requireGetSlotTextContent3ec731e2,
		"/src/lib/gridBasicOffset-92343778.js": requireGridBasicOffset92343778,
		"/src/lib/gridExtendedOffsetBase-fb9830f6.js": requireGridExtendedOffsetBaseFb9830f6,
		"/src/lib/gridExtendedOffsetXXL-c7a41e50.js": requireGridExtendedOffsetXXLC7a41e50,
		"/src/lib/gridGap-b5b73e4a.js": requireGridGapB5b73e4a,
		"/src/lib/group-direction-styles-c4bd8b11.js": requireGroupDirectionStylesC4bd8b11,
		"/src/lib/has-document-079654e6.js": requireHasDocument079654e6,
		"/src/lib/hasAttribute-bf22c03a.js": requireHasAttributeBf22c03a,
		"/src/lib/hasDescription-050833e0.js": requireHasDescription050833e0,
		"/src/lib/hasHeading-5ac42b7f.js": requireHasHeading5ac42b7f,
		"/src/lib/hasNamedSlot-273cd3ae.js": requireHasNamedSlot273cd3ae,
		"/src/lib/heading-tag-6cfe20fe.js": requireHeadingTag6cfe20fe,
		"/src/lib/headingShared-888aa084.js": requireHeadingShared888aa084,
		"/src/lib/headingSmallStyle-43f95761.js": requireHeadingSmallStyle43f95761,
		"/src/lib/headingXXLargeStyle-0857cde1.js": requireHeadingXXLargeStyle0857cde1,
		"/src/lib/helper-22e15c0e.js": requireHelper22e15c0e,
		"/src/lib/hover-media-query-5e6deda8.js": requireHoverMediaQuery5e6deda8,
		"/src/lib/index.cjs.js": requireIndex_cjs,
		"/src/lib/inline-notification-utils-fb9eaa4e.js": requireInlineNotificationUtilsFb9eaa4e,
		"/src/lib/is-click-outside-050dc86b.js": requireIsClickOutside050dc86b,
		"/src/lib/is-ssr-hydration-78eae0b3.js": requireIsSsrHydration78eae0b3,
		"/src/lib/isDisabledOrLoading-b1f56d7f.js": requireIsDisabledOrLoadingB1f56d7f,
		"/src/lib/isElementOfKind-f7da6ac6.js": requireIsElementOfKindF7da6ac6,
		"/src/lib/isParentOfKind-4b323732.js": requireIsParentOfKind4b323732,
		"/src/lib/label-styles-d5916d0e.js": requireLabelStylesD5916d0e,
		"/src/lib/link-aria-attribute-6f29e1a0.js": requireLinkAriaAttribute6f29e1a0,
		"/src/lib/link-button-pure-styles-102ff74a.js": requireLinkButtonPureStyles102ff74a,
		"/src/lib/link-button-styles-7215407d.js": requireLinkButtonStyles7215407d,
		"/src/lib/link-button-variant-b99795db.js": requireLinkButtonVariantB99795db,
		"/src/lib/link-styles-76fc91e3.js": requireLinkStyles76fc91e3,
		"/src/lib/link-tile-utils-fce9594a.js": requireLinkTileUtilsFce9594a,
		"/src/lib/loader.cjs.js": requireLoader_cjs,
		"/src/lib/loading-message-styles-100c7f01.js": requireLoadingMessageStyles100c7f01,
		"/src/lib/observer-98c271bc.js": requireObserver98c271bc,
		"/src/lib/p-accordion.cjs.entry.js": requirePAccordion_cjs_entry,
		"/src/lib/p-banner.cjs.entry.js": requirePBanner_cjs_entry,
		"/src/lib/p-button-group.cjs.entry.js": requirePButtonGroup_cjs_entry,
		"/src/lib/p-button-pure.cjs.entry.js": requirePButtonPure_cjs_entry,
		"/src/lib/p-button-tile.cjs.entry.js": requirePButtonTile_cjs_entry,
		"/src/lib/p-button.cjs.entry.js": requirePButton_cjs_entry,
		"/src/lib/p-canvas.cjs.entry.js": requirePCanvas_cjs_entry,
		"/src/lib/p-carousel.cjs.entry.js": requirePCarousel_cjs_entry,
		"/src/lib/p-checkbox-wrapper.cjs.entry.js": requirePCheckboxWrapper_cjs_entry,
		"/src/lib/p-checkbox.cjs.entry.js": requirePCheckbox_cjs_entry,
		"/src/lib/p-content-wrapper.cjs.entry.js": requirePContentWrapper_cjs_entry,
		"/src/lib/p-crest.cjs.entry.js": requirePCrest_cjs_entry,
		"/src/lib/p-display.cjs.entry.js": requirePDisplay_cjs_entry,
		"/src/lib/p-divider.cjs.entry.js": requirePDivider_cjs_entry,
		"/src/lib/p-fieldset-wrapper.cjs.entry.js": requirePFieldsetWrapper_cjs_entry,
		"/src/lib/p-fieldset.cjs.entry.js": requirePFieldset_cjs_entry,
		"/src/lib/p-flex_2.cjs.entry.js": requirePFlex_2_cjs_entry,
		"/src/lib/p-flyout-multilevel_2.cjs.entry.js": requirePFlyoutMultilevel_2_cjs_entry,
		"/src/lib/p-flyout.cjs.entry.js": requirePFlyout_cjs_entry,
		"/src/lib/p-grid_2.cjs.entry.js": requirePGrid_2_cjs_entry,
		"/src/lib/p-heading.cjs.entry.js": requirePHeading_cjs_entry,
		"/src/lib/p-headline.cjs.entry.js": requirePHeadline_cjs_entry,
		"/src/lib/p-icon.cjs.entry.js": requirePIcon_cjs_entry,
		"/src/lib/p-inline-notification.cjs.entry.js": requirePInlineNotification_cjs_entry,
		"/src/lib/p-link-pure.cjs.entry.js": requirePLinkPure_cjs_entry,
		"/src/lib/p-link-social.cjs.entry.js": requirePLinkSocial_cjs_entry,
		"/src/lib/p-link-tile-model-signature.cjs.entry.js": requirePLinkTileModelSignature_cjs_entry,
		"/src/lib/p-link-tile-product.cjs.entry.js": requirePLinkTileProduct_cjs_entry,
		"/src/lib/p-link-tile.cjs.entry.js": requirePLinkTile_cjs_entry,
		"/src/lib/p-link.cjs.entry.js": requirePLink_cjs_entry,
		"/src/lib/p-marque.cjs.entry.js": requirePMarque_cjs_entry,
		"/src/lib/p-modal.cjs.entry.js": requirePModal_cjs_entry,
		"/src/lib/p-model-signature.cjs.entry.js": requirePModelSignature_cjs_entry,
		"/src/lib/p-multi-select_2.cjs.entry.js": requirePMultiSelect_2_cjs_entry,
		"/src/lib/p-optgroup.cjs.entry.js": requirePOptgroup_cjs_entry,
		"/src/lib/p-pagination.cjs.entry.js": requirePPagination_cjs_entry,
		"/src/lib/p-pin-code.cjs.entry.js": requirePPinCode_cjs_entry,
		"/src/lib/p-popover.cjs.entry.js": requirePPopover_cjs_entry,
		"/src/lib/p-radio-button-wrapper.cjs.entry.js": requirePRadioButtonWrapper_cjs_entry,
		"/src/lib/p-scroller.cjs.entry.js": requirePScroller_cjs_entry,
		"/src/lib/p-segmented-control_2.cjs.entry.js": requirePSegmentedControl_2_cjs_entry,
		"/src/lib/p-select_2.cjs.entry.js": requirePSelect_2_cjs_entry,
		"/src/lib/p-select-wrapper_2.cjs.entry.js": requirePSelectWrapper_2_cjs_entry,
		"/src/lib/p-sheet.cjs.entry.js": requirePSheet_cjs_entry,
		"/src/lib/p-spinner.cjs.entry.js": requirePSpinner_cjs_entry,
		"/src/lib/p-stepper-horizontal_2.cjs.entry.js": requirePStepperHorizontal_2_cjs_entry,
		"/src/lib/p-switch.cjs.entry.js": requirePSwitch_cjs_entry,
		"/src/lib/p-table_7.cjs.entry.js": requirePTable_7_cjs_entry,
		"/src/lib/p-tabs_2.cjs.entry.js": requirePTabs_2_cjs_entry,
		"/src/lib/p-tabs-bar.cjs.entry.js": requirePTabsBar_cjs_entry,
		"/src/lib/p-tag-dismissible.cjs.entry.js": requirePTagDismissible_cjs_entry,
		"/src/lib/p-tag.cjs.entry.js": requirePTag_cjs_entry,
		"/src/lib/p-text-field-wrapper.cjs.entry.js": requirePTextFieldWrapper_cjs_entry,
		"/src/lib/p-text-list_2.cjs.entry.js": requirePTextList_2_cjs_entry,
		"/src/lib/p-text.cjs.entry.js": requirePText_cjs_entry,
		"/src/lib/p-textarea-wrapper.cjs.entry.js": requirePTextareaWrapper_cjs_entry,
		"/src/lib/p-textarea.cjs.entry.js": requirePTextarea_cjs_entry,
		"/src/lib/p-toast_2.cjs.entry.js": requirePToast_2_cjs_entry,
		"/src/lib/p-wordmark.cjs.entry.js": requirePWordmark_cjs_entry,
		"/src/lib/popover-8518c8b1.js": requirePopover8518c8b1,
		"/src/lib/porsche-design-system.cjs.js": requirePorscheDesignSystem_cjs,
		"/src/lib/prevent-fouc-of-nested-elements-styles-e5a706ce.js": requirePreventFoucOfNestedElementsStylesE5a706ce,
		"/src/lib/property-observer-4331cfab.js": requirePropertyObserver4331cfab,
		"/src/lib/schemed-high-contrast-media-query-462417a0.js": requireSchemedHighContrastMediaQuery462417a0,
		"/src/lib/scrolling-d5dce8b3.js": requireScrollingD5dce8b3,
		"/src/lib/select-dropdown-d9989ebd.js": requireSelectDropdownD9989ebd,
		"/src/lib/setAttributes-f96a52a9.js": requireSetAttributesF96a52a9,
		"/src/lib/setScrollLock-68edfbd1.js": requireSetScrollLock68edfbd1,
		"/src/lib/slotted-anchor-styles-fe1a10c2.js": requireSlottedAnchorStylesFe1a10c2,
		"/src/lib/slotted-picture-image-styles-3121dac8.js": requireSlottedPictureImageStyles3121dac8,
		"/src/lib/spacingFluidLarge-6087a0f7.js": requireSpacingFluidLarge6087a0f7,
		"/src/lib/spacingFluidMedium-88ab712b.js": requireSpacingFluidMedium88ab712b,
		"/src/lib/spacingFluidSmall-2c6caae7.js": requireSpacingFluidSmall2c6caae7,
		"/src/lib/spacingFluidXSmall-0dd753ae.js": requireSpacingFluidXSmall0dd753ae,
		"/src/lib/spacingStaticLarge-abe11a7d.js": requireSpacingStaticLargeAbe11a7d,
		"/src/lib/spacingStaticMedium-94812711.js": requireSpacingStaticMedium94812711,
		"/src/lib/spacingStaticSmall-2130ed04.js": requireSpacingStaticSmall2130ed04,
		"/src/lib/spacingStaticXSmall-b7d708b8.js": requireSpacingStaticXSmallB7d708b8,
		"/src/lib/state-message-styles-d1c4637f.js": requireStateMessageStylesD1c4637f,
		"/src/lib/supportsChromiumMediaQuery-e79aefa2.js": requireSupportsChromiumMediaQueryE79aefa2,
		"/src/lib/tabs-bar-utils-55e09519.js": requireTabsBarUtils55e09519,
		"/src/lib/tag-shared-utils-b71f947a.js": requireTagSharedUtilsB71f947a,
		"/src/lib/text-size-be3fca13.js": requireTextSizeBe3fca13,
		"/src/lib/textMediumStyle-59c59854.js": requireTextMediumStyle59c59854,
		"/src/lib/textShared-5216bb19.js": requireTextShared5216bb19,
		"/src/lib/textSmallStyle-00e1c6e2.js": requireTextSmallStyle00e1c6e2,
		"/src/lib/textXSmallStyle-30d03035.js": requireTextXSmallStyle30d03035,
		"/src/lib/theme-bfc10573.js": requireThemeBfc10573,
		"/src/lib/throwIfChildrenAreNotOfKind-288748e4.js": requireThrowIfChildrenAreNotOfKind288748e4,
		"/src/lib/throwIfElementIsNotOfKind-ab86026b.js": requireThrowIfElementIsNotOfKindAb86026b,
		"/src/lib/throwIfInvalidLinkUsage-b47cf9ae.js": requireThrowIfInvalidLinkUsageB47cf9ae,
		"/src/lib/throwIfParentIsNotOfKind-e0807bbc.js": requireThrowIfParentIsNotOfKindE0807bbc,
		"/src/lib/throwIfRootNodeIsNotOneOfKind-201fcf02.js": requireThrowIfRootNodeIsNotOneOfKind201fcf02,
		"/src/lib/tile-utils-82ea5cf8.js": requireTileUtils82ea5cf8,
		"/src/lib/transformSelectorToDirectChildSelector-ecc1a9c4.js": requireTransformSelectorToDirectChildSelectorEcc1a9c4,
		"/src/lib/typography-align-844cd863.js": requireTypographyAlign844cd863,
		"/src/lib/typography-styles-226e4585.js": requireTypographyStyles226e4585,
		"/src/lib/typography-text-color-524bae09.js": requireTypographyTextColor524bae09,
		"/src/lib/typography-text-weight-02ea3596.js": requireTypographyTextWeight02ea3596,
		"/src/lib/validateProps-788e2bc5.js": requireValidateProps788e2bc5,
		"/src/lib/warnIfAriaAndHeadingPropsAreUndefined-52718ac1.js": requireWarnIfAriaAndHeadingPropsAreUndefined52718ac1,
		"/src/lib/warnIfDeprecatedComponentIsUsed-b14eebd2.js": requireWarnIfDeprecatedComponentIsUsedB14eebd2,
		"/src/lib/warnIfDeprecatedPropIsUsed-76f87eda.js": requireWarnIfDeprecatedPropIsUsed76f87eda,
		"/src/lib/warnIfDeprecatedPropValueIsUsed-91ceea3c.js": requireWarnIfDeprecatedPropValueIsUsed91ceea3c
	});
}

function createCommonjsRequire(originalModuleDir) {
	function handleRequire(path) {
		var resolvedPath = commonjsResolve(path, originalModuleDir);
		if (resolvedPath !== null) {
			return getDynamicModules()[resolvedPath]();
		}
		throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
	}
	handleRequire.resolve = function (path) {
		var resolvedPath = commonjsResolve(path, originalModuleDir);
		if (resolvedPath !== null) {
			return resolvedPath;
		}
		return require.resolve(path);
	};
	return handleRequire;
}

function commonjsResolve (path, originalModuleDir) {
	var shouldTryNodeModules = isPossibleNodeModulesPath(path);
	path = normalize(path);
	var relPath;
	if (path[0] === '/') {
		originalModuleDir = '';
	}
	var modules = getDynamicModules();
	var checkedExtensions = ['', '.js', '.json'];
	while (true) {
		if (!shouldTryNodeModules) {
			relPath = normalize(originalModuleDir + '/' + path);
		} else {
			relPath = normalize(originalModuleDir + '/node_modules/' + path);
		}

		if (relPath.endsWith('/..')) {
			break; // Travelled too far up, avoid infinite loop
		}

		for (var extensionIndex = 0; extensionIndex < checkedExtensions.length; extensionIndex++) {
			var resolvedPath = relPath + checkedExtensions[extensionIndex];
			if (modules[resolvedPath]) {
				return resolvedPath;
			}
		}
		if (!shouldTryNodeModules) break;
		var nextDir = normalize(originalModuleDir + '/..');
		if (nextDir === originalModuleDir) break;
		originalModuleDir = nextDir;
	}
	return null;
}

function isPossibleNodeModulesPath (modulePath) {
	var c0 = modulePath[0];
	if (c0 === '/' || c0 === '\\') return false;
	var c1 = modulePath[1], c2 = modulePath[2];
	if ((c0 === '.' && (!c1 || c1 === '/' || c1 === '\\')) ||
		(c0 === '.' && c1 === '.' && (!c2 || c2 === '/' || c2 === '\\'))) return false;
	if (c1 === ':' && (c2 === '/' || c2 === '\\')) return false;
	return true;
}

function normalize (path) {
	path = path.replace(/\\/g, '/');
	var parts = path.split('/');
	var slashed = parts[0] === '';
	for (var i = 1; i < parts.length; i++) {
		if (parts[i] === '.' || parts[i] === '') {
			parts.splice(i--, 1);
		}
	}
	for (var i = 1; i < parts.length; i++) {
		if (parts[i] !== '..') continue;
		if (i > 0 && parts[i - 1] !== '..' && parts[i - 1] !== '.') {
			parts.splice(--i, 2);
			i--;
		}
	}
	path = parts.join('/');
	if (slashed && path[0] !== '/') path = '/' + path;
	else if (path.length === 0) path = '.';
	return path;
}

var validateProps788e2bc5 = {};

var hasRequiredValidateProps788e2bc5;

function requireValidateProps788e2bc5 () {
	if (hasRequiredValidateProps788e2bc5) return validateProps788e2bc5;
	hasRequiredValidateProps788e2bc5 = 1;
	(function (exports) {

		function _interopNamespace(e) {
		  if (e && e.__esModule) return e;
		  var n = Object.create(null);
		  if (e) {
		    Object.keys(e).forEach(function (k) {
		      if (k !== 'default') {
		        var d = Object.getOwnPropertyDescriptor(e, k);
		        Object.defineProperty(n, k, d.get ? d : {
		          enumerable: true,
		          get: function () {
		            return e[k];
		          }
		        });
		      }
		    });
		  }
		  n['default'] = e;
		  return Object.freeze(n);
		}

		const NAMESPACE = 'porsche-design-system';
		const BUILD = /* porsche-design-system */ { allRenderFn: true, appendChildSlotFix: false, asyncLoading: true, asyncQueue: false, attachStyles: true, cloneNodeFix: false, cmpDidLoad: true, cmpDidRender: true, cmpDidUnload: false, cmpDidUpdate: true, cmpShouldUpdate: true, cmpWillLoad: true, cmpWillRender: true, cmpWillUpdate: true, connectedCallback: true, constructableCSS: true, cssAnnotations: true, devTools: false, disconnectedCallback: true, element: false, event: true, experimentalScopedSlotChanges: false, experimentalSlotFixes: false, formAssociated: true, hasRenderFn: true, hostListener: true, hostListenerTarget: false, hostListenerTargetBody: false, hostListenerTargetDocument: false, hostListenerTargetParent: false, hostListenerTargetWindow: false, hotModuleReplacement: false, hydrateClientSide: false, hydrateServerSide: false, hydratedAttribute: false, hydratedClass: true, hydratedSelectorName: "hydrated", initializeNextTick: false, invisiblePrehydration: false, isDebug: false, isDev: false, isTesting: false, lazyLoad: true, lifecycle: true, lifecycleDOMEvents: false, member: true, method: true, mode: false, observeAttribute: true, profile: false, prop: true, propBoolean: true, propMutable: true, propNumber: true, propString: true, reflect: true, scoped: false, scopedSlotTextContentFix: false, scriptDataOpts: false, shadowDelegatesFocus: true, shadowDom: true, slot: true, slotChildNodesFix: false, slotRelocation: false, state: true, style: false, svg: true, taskQueue: true, transformTagName: true, updatable: true, vdomAttribute: true, vdomClass: true, vdomFunctional: true, vdomKey: true, vdomListener: true, vdomPropOrAttr: true, vdomRef: true, vdomRender: true, vdomStyle: true, vdomText: true, vdomXlink: true, watchCallback: true };

		/*
		 Stencil Client Platform v4.23.0 | MIT Licensed | https://stenciljs.com
		 */
		var __defProp = Object.defineProperty;
		var __export = (target, all) => {
		  for (var name in all)
		    __defProp(target, name, { get: all[name], enumerable: true });
		};
		var hostRefs = /* @__PURE__ */ new WeakMap();
		var getHostRef = (ref) => hostRefs.get(ref);
		var registerInstance = (lazyInstance, hostRef) => hostRefs.set(hostRef.$lazyInstance$ = lazyInstance, hostRef);
		var registerHost = (hostElement, cmpMeta) => {
		  const hostRef = {
		    $flags$: 0,
		    $hostElement$: hostElement,
		    $cmpMeta$: cmpMeta,
		    $instanceValues$: /* @__PURE__ */ new Map()
		  };
		  {
		    hostRef.$onInstancePromise$ = new Promise((r) => hostRef.$onInstanceResolve$ = r);
		  }
		  {
		    hostRef.$onReadyPromise$ = new Promise((r) => hostRef.$onReadyResolve$ = r);
		    hostElement["s-p"] = [];
		    hostElement["s-rc"] = [];
		  }
		  return hostRefs.set(hostElement, hostRef);
		};
		var isMemberInElement = (elm, memberName) => memberName in elm;
		var consoleError$1 = (e, el) => (0, console.error)(e, el);

		// src/client/client-load-module.ts
		var cmpModules = /* @__PURE__ */ new Map();
		var loadModule = (cmpMeta, hostRef, hmrVersionId) => {
		  const exportName = cmpMeta.$tagName$.replace(/-/g, "_");
		  const bundleId = cmpMeta.$lazyBundleId$;
		  if (!bundleId) {
		    return void 0;
		  }
		  const module = cmpModules.get(bundleId) ;
		  if (module) {
		    return module[exportName];
		  }
		  /*!__STENCIL_STATIC_IMPORT_SWITCH__*/
		  return Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(createCommonjsRequire("/src/lib")(
		    /* @vite-ignore */
		    /* webpackInclude: /\.entry\.js$/ */
		    /* webpackExclude: /\.system\.entry\.js$/ */
		    /* webpackMode: "lazy" */
		    `./${bundleId}.entry.js${""}`
		  )); }).then((importedModule) => {
		    {
		      cmpModules.set(bundleId, importedModule);
		    }
		    return importedModule[exportName];
		  }, consoleError$1);
		};
		var SLOT_FB_CSS = "slot-fb{display:contents}slot-fb[hidden]{display:none}";
		var XLINK_NS = "http://www.w3.org/1999/xlink";
		var FORM_ASSOCIATED_CUSTOM_ELEMENT_CALLBACKS = [
		  "formAssociatedCallback",
		  "formResetCallback",
		  "formDisabledCallback",
		  "formStateRestoreCallback"
		];
		var win = typeof window !== "undefined" ? window : {};
		var doc = win.document || { head: {} };
		var plt = {
		  $flags$: 0,
		  $resourcesUrl$: "",
		  jmp: (h2) => h2(),
		  raf: (h2) => requestAnimationFrame(h2),
		  ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),
		  rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),
		  ce: (eventName, opts) => new CustomEvent(eventName, opts)
		};
		var supportsListenerOptions = /* @__PURE__ */ (() => {
		  let supportsListenerOptions2 = false;
		  try {
		    doc.addEventListener(
		      "e",
		      null,
		      Object.defineProperty({}, "passive", {
		        get() {
		          supportsListenerOptions2 = true;
		        }
		      })
		    );
		  } catch (e) {
		  }
		  return supportsListenerOptions2;
		})();
		var promiseResolve = (v) => Promise.resolve(v);
		var queuePending = false;
		var queueDomReads = [];
		var queueDomWrites = [];
		var queueTask = (queue, write) => (cb) => {
		  queue.push(cb);
		  if (!queuePending) {
		    queuePending = true;
		    if (plt.$flags$ & 4 /* queueSync */) {
		      nextTick(flush);
		    } else {
		      plt.raf(flush);
		    }
		  }
		};
		var consume = (queue) => {
		  for (let i2 = 0; i2 < queue.length; i2++) {
		    try {
		      queue[i2](performance.now());
		    } catch (e) {
		      consoleError$1(e);
		    }
		  }
		  queue.length = 0;
		};
		var flush = () => {
		  consume(queueDomReads);
		  {
		    consume(queueDomWrites);
		    if (queuePending = queueDomReads.length > 0) {
		      plt.raf(flush);
		    }
		  }
		};
		var nextTick = (cb) => promiseResolve().then(cb);
		var writeTask = /* @__PURE__ */ queueTask(queueDomWrites);

		// src/utils/constants.ts
		var EMPTY_OBJ = {};
		var SVG_NS = "http://www.w3.org/2000/svg";
		var HTML_NS = "http://www.w3.org/1999/xhtml";
		var isComplexType = (o) => {
		  o = typeof o;
		  return o === "object" || o === "function";
		};

		// src/utils/query-nonce-meta-tag-content.ts
		function queryNonceMetaTagContent(doc2) {
		  var _a, _b, _c;
		  return (_c = (_b = (_a = doc2.head) == null ? void 0 : _a.querySelector('meta[name="csp-nonce"]')) == null ? void 0 : _b.getAttribute("content")) != null ? _c : void 0;
		}

		// src/utils/result.ts
		var result_exports = {};
		__export(result_exports, {
		  err: () => err,
		  map: () => map,
		  ok: () => ok,
		  unwrap: () => unwrap,
		  unwrapErr: () => unwrapErr
		});
		var ok = (value) => ({
		  isOk: true,
		  isErr: false,
		  value
		});
		var err = (value) => ({
		  isOk: false,
		  isErr: true,
		  value
		});
		function map(result, fn) {
		  if (result.isOk) {
		    const val = fn(result.value);
		    if (val instanceof Promise) {
		      return val.then((newVal) => ok(newVal));
		    } else {
		      return ok(val);
		    }
		  }
		  if (result.isErr) {
		    const value = result.value;
		    return err(value);
		  }
		  throw "should never get here";
		}
		var unwrap = (result) => {
		  if (result.isOk) {
		    return result.value;
		  } else {
		    throw result.value;
		  }
		};
		var unwrapErr = (result) => {
		  if (result.isErr) {
		    return result.value;
		  } else {
		    throw result.value;
		  }
		};
		var h = (nodeName, vnodeData, ...children) => {
		  let child = null;
		  let key = null;
		  let simple = false;
		  let lastSimple = false;
		  const vNodeChildren = [];
		  const walk = (c) => {
		    for (let i2 = 0; i2 < c.length; i2++) {
		      child = c[i2];
		      if (Array.isArray(child)) {
		        walk(child);
		      } else if (child != null && typeof child !== "boolean") {
		        if (simple = typeof nodeName !== "function" && !isComplexType(child)) {
		          child = String(child);
		        }
		        if (simple && lastSimple) {
		          vNodeChildren[vNodeChildren.length - 1].$text$ += child;
		        } else {
		          vNodeChildren.push(simple ? newVNode(null, child) : child);
		        }
		        lastSimple = simple;
		      }
		    }
		  };
		  walk(children);
		  if (vnodeData) {
		    if (vnodeData.key) {
		      key = vnodeData.key;
		    }
		    {
		      const classData = vnodeData.className || vnodeData.class;
		      if (classData) {
		        vnodeData.class = typeof classData !== "object" ? classData : Object.keys(classData).filter((k) => classData[k]).join(" ");
		      }
		    }
		  }
		  if (typeof nodeName === "function") {
		    return nodeName(
		      vnodeData === null ? {} : vnodeData,
		      vNodeChildren,
		      vdomFnUtils
		    );
		  }
		  const vnode = newVNode(nodeName, null);
		  vnode.$attrs$ = vnodeData;
		  if (vNodeChildren.length > 0) {
		    vnode.$children$ = vNodeChildren;
		  }
		  {
		    vnode.$key$ = key;
		  }
		  return vnode;
		};
		var newVNode = (tag, text) => {
		  const vnode = {
		    $flags$: 0,
		    $tag$: tag,
		    $text$: text,
		    $elm$: null,
		    $children$: null
		  };
		  {
		    vnode.$attrs$ = null;
		  }
		  {
		    vnode.$key$ = null;
		  }
		  return vnode;
		};
		var Host = {};
		var isHost = (node) => node && node.$tag$ === Host;
		var vdomFnUtils = {
		  forEach: (children, cb) => children.map(convertToPublic).forEach(cb),
		  map: (children, cb) => children.map(convertToPublic).map(cb).map(convertToPrivate)
		};
		var convertToPublic = (node) => ({
		  vattrs: node.$attrs$,
		  vchildren: node.$children$,
		  vkey: node.$key$,
		  vname: node.$name$,
		  vtag: node.$tag$,
		  vtext: node.$text$
		});
		var convertToPrivate = (node) => {
		  if (typeof node.vtag === "function") {
		    const vnodeData = { ...node.vattrs };
		    if (node.vkey) {
		      vnodeData.key = node.vkey;
		    }
		    if (node.vname) {
		      vnodeData.name = node.vname;
		    }
		    return h(node.vtag, vnodeData, ...node.vchildren || []);
		  }
		  const vnode = newVNode(node.vtag, node.vtext);
		  vnode.$attrs$ = node.vattrs;
		  vnode.$children$ = node.vchildren;
		  vnode.$key$ = node.vkey;
		  vnode.$name$ = node.vname;
		  return vnode;
		};
		var setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {
		  if (oldValue !== newValue) {
		    let isProp = isMemberInElement(elm, memberName);
		    let ln = memberName.toLowerCase();
		    if (memberName === "class") {
		      const classList = elm.classList;
		      const oldClasses = parseClassList(oldValue);
		      const newClasses = parseClassList(newValue);
		      if (elm["s-si"] && newClasses.indexOf(elm["s-si"]) < 0) {
		        newClasses.push(elm["s-si"]);
		      }
		      classList.remove(...oldClasses.filter((c) => c && !newClasses.includes(c)));
		      classList.add(...newClasses.filter((c) => c && !oldClasses.includes(c)));
		    } else if (memberName === "style") {
		      {
		        for (const prop in oldValue) {
		          if (!newValue || newValue[prop] == null) {
		            if (prop.includes("-")) {
		              elm.style.removeProperty(prop);
		            } else {
		              elm.style[prop] = "";
		            }
		          }
		        }
		      }
		      for (const prop in newValue) {
		        if (!oldValue || newValue[prop] !== oldValue[prop]) {
		          if (prop.includes("-")) {
		            elm.style.setProperty(prop, newValue[prop]);
		          } else {
		            elm.style[prop] = newValue[prop];
		          }
		        }
		      }
		    } else if (memberName === "key") ; else if (memberName === "ref") {
		      if (newValue) {
		        newValue(elm);
		      }
		    } else if ((!isProp ) && memberName[0] === "o" && memberName[1] === "n") {
		      if (memberName[2] === "-") {
		        memberName = memberName.slice(3);
		      } else if (isMemberInElement(win, ln)) {
		        memberName = ln.slice(2);
		      } else {
		        memberName = ln[2] + memberName.slice(3);
		      }
		      if (oldValue || newValue) {
		        const capture = memberName.endsWith(CAPTURE_EVENT_SUFFIX);
		        memberName = memberName.replace(CAPTURE_EVENT_REGEX, "");
		        if (oldValue) {
		          plt.rel(elm, memberName, oldValue, capture);
		        }
		        if (newValue) {
		          plt.ael(elm, memberName, newValue, capture);
		        }
		      }
		    } else {
		      const isComplex = isComplexType(newValue);
		      if ((isProp || isComplex && newValue !== null) && !isSvg) {
		        try {
		          if (!elm.tagName.includes("-")) {
		            const n = newValue == null ? "" : newValue;
		            if (memberName === "list") {
		              isProp = false;
		            } else if (oldValue == null || elm[memberName] != n) {
		              if (typeof elm.__lookupSetter__(memberName) === "function") {
		                elm[memberName] = n;
		              } else {
		                elm.setAttribute(memberName, n);
		              }
		            }
		          } else {
		            elm[memberName] = newValue;
		          }
		        } catch (e) {
		        }
		      }
		      let xlink = false;
		      {
		        if (ln !== (ln = ln.replace(/^xlink\:?/, ""))) {
		          memberName = ln;
		          xlink = true;
		        }
		      }
		      if (newValue == null || newValue === false) {
		        if (newValue !== false || elm.getAttribute(memberName) === "") {
		          if (xlink) {
		            elm.removeAttributeNS(XLINK_NS, memberName);
		          } else {
		            elm.removeAttribute(memberName);
		          }
		        }
		      } else if ((!isProp || flags & 4 /* isHost */ || isSvg) && !isComplex) {
		        newValue = newValue === true ? "" : newValue;
		        if (xlink) {
		          elm.setAttributeNS(XLINK_NS, memberName, newValue);
		        } else {
		          elm.setAttribute(memberName, newValue);
		        }
		      }
		    }
		  }
		};
		var parseClassListRegex = /\s/;
		var parseClassList = (value) => !value ? [] : value.split(parseClassListRegex);
		var CAPTURE_EVENT_SUFFIX = "Capture";
		var CAPTURE_EVENT_REGEX = new RegExp(CAPTURE_EVENT_SUFFIX + "$");

		// src/runtime/vdom/update-element.ts
		var updateElement = (oldVnode, newVnode, isSvgMode2) => {
		  const elm = newVnode.$elm$.nodeType === 11 /* DocumentFragment */ && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;
		  const oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || EMPTY_OBJ;
		  const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;
		  {
		    for (const memberName of sortedAttrNames(Object.keys(oldVnodeAttrs))) {
		      if (!(memberName in newVnodeAttrs)) {
		        setAccessor(elm, memberName, oldVnodeAttrs[memberName], void 0, isSvgMode2, newVnode.$flags$);
		      }
		    }
		  }
		  for (const memberName of sortedAttrNames(Object.keys(newVnodeAttrs))) {
		    setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode2, newVnode.$flags$);
		  }
		};
		function sortedAttrNames(attrNames) {
		  return attrNames.includes("ref") ? (
		    // we need to sort these to ensure that `'ref'` is the last attr
		    [...attrNames.filter((attr) => attr !== "ref"), "ref"]
		  ) : (
		    // no need to sort, return the original array
		    attrNames
		  );
		}
		var hostTagName;
		var useNativeShadowDom = false;
		var isSvgMode = false;
		var createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {
		  const newVNode2 = newParentVNode.$children$[childIndex];
		  let i2 = 0;
		  let elm;
		  let childNode;
		  if (newVNode2.$text$ !== null) {
		    elm = newVNode2.$elm$ = doc.createTextNode(newVNode2.$text$);
		  } else {
		    if (!isSvgMode) {
		      isSvgMode = newVNode2.$tag$ === "svg";
		    }
		    elm = newVNode2.$elm$ = doc.createElementNS(
		      isSvgMode ? SVG_NS : HTML_NS,
		      newVNode2.$tag$
		    ) ;
		    if (isSvgMode && newVNode2.$tag$ === "foreignObject") {
		      isSvgMode = false;
		    }
		    {
		      updateElement(null, newVNode2, isSvgMode);
		    }
		    const rootNode = elm.getRootNode();
		    !rootNode.querySelector("body");
		    if (newVNode2.$children$) {
		      for (i2 = 0; i2 < newVNode2.$children$.length; ++i2) {
		        childNode = createElm(oldParentVNode, newVNode2, i2);
		        if (childNode) {
		          elm.appendChild(childNode);
		        }
		      }
		    }
		    {
		      if (newVNode2.$tag$ === "svg") {
		        isSvgMode = false;
		      } else if (elm.tagName === "foreignObject") {
		        isSvgMode = true;
		      }
		    }
		  }
		  elm["s-hn"] = hostTagName;
		  return elm;
		};
		var addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {
		  let containerElm = parentElm;
		  let childNode;
		  if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {
		    containerElm = containerElm.shadowRoot;
		  }
		  for (; startIdx <= endIdx; ++startIdx) {
		    if (vnodes[startIdx]) {
		      childNode = createElm(null, parentVNode, startIdx);
		      if (childNode) {
		        vnodes[startIdx].$elm$ = childNode;
		        insertBefore(containerElm, childNode, before);
		      }
		    }
		  }
		};
		var removeVnodes = (vnodes, startIdx, endIdx) => {
		  for (let index = startIdx; index <= endIdx; ++index) {
		    const vnode = vnodes[index];
		    if (vnode) {
		      const elm = vnode.$elm$;
		      nullifyVNodeRefs(vnode);
		      if (elm) {
		        elm.remove();
		      }
		    }
		  }
		};
		var updateChildren = (parentElm, oldCh, newVNode2, newCh, isInitialRender = false) => {
		  let oldStartIdx = 0;
		  let newStartIdx = 0;
		  let idxInOld = 0;
		  let i2 = 0;
		  let oldEndIdx = oldCh.length - 1;
		  let oldStartVnode = oldCh[0];
		  let oldEndVnode = oldCh[oldEndIdx];
		  let newEndIdx = newCh.length - 1;
		  let newStartVnode = newCh[0];
		  let newEndVnode = newCh[newEndIdx];
		  let node;
		  let elmToMove;
		  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
		    if (oldStartVnode == null) {
		      oldStartVnode = oldCh[++oldStartIdx];
		    } else if (oldEndVnode == null) {
		      oldEndVnode = oldCh[--oldEndIdx];
		    } else if (newStartVnode == null) {
		      newStartVnode = newCh[++newStartIdx];
		    } else if (newEndVnode == null) {
		      newEndVnode = newCh[--newEndIdx];
		    } else if (isSameVnode(oldStartVnode, newStartVnode, isInitialRender)) {
		      patch(oldStartVnode, newStartVnode, isInitialRender);
		      oldStartVnode = oldCh[++oldStartIdx];
		      newStartVnode = newCh[++newStartIdx];
		    } else if (isSameVnode(oldEndVnode, newEndVnode, isInitialRender)) {
		      patch(oldEndVnode, newEndVnode, isInitialRender);
		      oldEndVnode = oldCh[--oldEndIdx];
		      newEndVnode = newCh[--newEndIdx];
		    } else if (isSameVnode(oldStartVnode, newEndVnode, isInitialRender)) {
		      patch(oldStartVnode, newEndVnode, isInitialRender);
		      insertBefore(parentElm, oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
		      oldStartVnode = oldCh[++oldStartIdx];
		      newEndVnode = newCh[--newEndIdx];
		    } else if (isSameVnode(oldEndVnode, newStartVnode, isInitialRender)) {
		      patch(oldEndVnode, newStartVnode, isInitialRender);
		      insertBefore(parentElm, oldEndVnode.$elm$, oldStartVnode.$elm$);
		      oldEndVnode = oldCh[--oldEndIdx];
		      newStartVnode = newCh[++newStartIdx];
		    } else {
		      idxInOld = -1;
		      {
		        for (i2 = oldStartIdx; i2 <= oldEndIdx; ++i2) {
		          if (oldCh[i2] && oldCh[i2].$key$ !== null && oldCh[i2].$key$ === newStartVnode.$key$) {
		            idxInOld = i2;
		            break;
		          }
		        }
		      }
		      if (idxInOld >= 0) {
		        elmToMove = oldCh[idxInOld];
		        if (elmToMove.$tag$ !== newStartVnode.$tag$) {
		          node = createElm(oldCh && oldCh[newStartIdx], newVNode2, idxInOld);
		        } else {
		          patch(elmToMove, newStartVnode, isInitialRender);
		          oldCh[idxInOld] = void 0;
		          node = elmToMove.$elm$;
		        }
		        newStartVnode = newCh[++newStartIdx];
		      } else {
		        node = createElm(oldCh && oldCh[newStartIdx], newVNode2, newStartIdx);
		        newStartVnode = newCh[++newStartIdx];
		      }
		      if (node) {
		        {
		          insertBefore(oldStartVnode.$elm$.parentNode, node, oldStartVnode.$elm$);
		        }
		      }
		    }
		  }
		  if (oldStartIdx > oldEndIdx) {
		    addVnodes(
		      parentElm,
		      newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$,
		      newVNode2,
		      newCh,
		      newStartIdx,
		      newEndIdx
		    );
		  } else if (newStartIdx > newEndIdx) {
		    removeVnodes(oldCh, oldStartIdx, oldEndIdx);
		  }
		};
		var isSameVnode = (leftVNode, rightVNode, isInitialRender = false) => {
		  if (leftVNode.$tag$ === rightVNode.$tag$) {
		    if (!isInitialRender) {
		      return leftVNode.$key$ === rightVNode.$key$;
		    }
		    return true;
		  }
		  return false;
		};
		var patch = (oldVNode, newVNode2, isInitialRender = false) => {
		  const elm = newVNode2.$elm$ = oldVNode.$elm$;
		  const oldChildren = oldVNode.$children$;
		  const newChildren = newVNode2.$children$;
		  const tag = newVNode2.$tag$;
		  const text = newVNode2.$text$;
		  if (text === null) {
		    {
		      isSvgMode = tag === "svg" ? true : tag === "foreignObject" ? false : isSvgMode;
		    }
		    {
		      if (tag === "slot" && !useNativeShadowDom) ; else {
		        updateElement(oldVNode, newVNode2, isSvgMode);
		      }
		    }
		    if (oldChildren !== null && newChildren !== null) {
		      updateChildren(elm, oldChildren, newVNode2, newChildren, isInitialRender);
		    } else if (newChildren !== null) {
		      if (oldVNode.$text$ !== null) {
		        elm.textContent = "";
		      }
		      addVnodes(elm, null, newVNode2, newChildren, 0, newChildren.length - 1);
		    } else if (
		      // don't do this on initial render as it can cause non-hydrated content to be removed
		      !isInitialRender && BUILD.updatable && oldChildren !== null
		    ) {
		      removeVnodes(oldChildren, 0, oldChildren.length - 1);
		    }
		    if (isSvgMode && tag === "svg") {
		      isSvgMode = false;
		    }
		  } else if (oldVNode.$text$ !== text) {
		    elm.data = text;
		  }
		};
		var nullifyVNodeRefs = (vNode) => {
		  {
		    vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);
		    vNode.$children$ && vNode.$children$.map(nullifyVNodeRefs);
		  }
		};
		var insertBefore = (parent, newNode, reference) => {
		  const inserted = parent == null ? void 0 : parent.insertBefore(newNode, reference);
		  return inserted;
		};
		var renderVdom = (hostRef, renderFnResults, isInitialLoad = false) => {
		  const hostElm = hostRef.$hostElement$;
		  const cmpMeta = hostRef.$cmpMeta$;
		  const oldVNode = hostRef.$vnode$ || newVNode(null, null);
		  const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);
		  hostTagName = hostElm.tagName;
		  if (cmpMeta.$attrsToReflect$) {
		    rootVnode.$attrs$ = rootVnode.$attrs$ || {};
		    cmpMeta.$attrsToReflect$.map(
		      ([propName, attribute]) => rootVnode.$attrs$[attribute] = hostElm[propName]
		    );
		  }
		  if (isInitialLoad && rootVnode.$attrs$) {
		    for (const key of Object.keys(rootVnode.$attrs$)) {
		      if (hostElm.hasAttribute(key) && !["key", "ref", "style", "class"].includes(key)) {
		        rootVnode.$attrs$[key] = hostElm[key];
		      }
		    }
		  }
		  rootVnode.$tag$ = null;
		  rootVnode.$flags$ |= 4 /* isHost */;
		  hostRef.$vnode$ = rootVnode;
		  rootVnode.$elm$ = oldVNode.$elm$ = hostElm.shadowRoot || hostElm ;
		  {
		    hostElm["s-sc"];
		  }
		  useNativeShadowDom = (cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) !== 0;
		  patch(oldVNode, rootVnode, isInitialLoad);
		};
		var createTime = (fnName, tagName = "") => {
		  {
		    return () => {
		      return;
		    };
		  }
		};
		var uniqueTime = (key, measureText) => {
		  {
		    return () => {
		      return;
		    };
		  }
		};
		var parsePropertyValue = (propValue, propType) => {
		  if (propValue != null && !isComplexType(propValue)) {
		    if (propType & 4 /* Boolean */) {
		      return propValue === "false" ? false : propValue === "" || !!propValue;
		    }
		    if (propType & 2 /* Number */) {
		      return parseFloat(propValue);
		    }
		    if (propType & 1 /* String */) {
		      return String(propValue);
		    }
		    return propValue;
		  }
		  return propValue;
		};
		var getElement = (ref) => getHostRef(ref).$hostElement$ ;

		// src/runtime/event-emitter.ts
		var createEvent = (ref, name, flags) => {
		  const elm = getElement(ref);
		  return {
		    emit: (detail) => {
		      return emitEvent(elm, name, {
		        bubbles: !!(flags & 4 /* Bubbles */),
		        composed: !!(flags & 2 /* Composed */),
		        cancelable: !!(flags & 1 /* Cancellable */),
		        detail
		      });
		    }
		  };
		};
		var emitEvent = (elm, name, opts) => {
		  const ev = plt.ce(name, opts);
		  elm.dispatchEvent(ev);
		  return ev;
		};

		// src/runtime/update-component.ts
		var attachToAncestor = (hostRef, ancestorComponent) => {
		  if (ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent["s-p"]) {
		    ancestorComponent["s-p"].push(new Promise((r) => hostRef.$onRenderResolve$ = r));
		  }
		};
		var scheduleUpdate = (hostRef, isInitialLoad) => {
		  {
		    hostRef.$flags$ |= 16 /* isQueuedForUpdate */;
		  }
		  if (hostRef.$flags$ & 4 /* isWaitingForChildren */) {
		    hostRef.$flags$ |= 512 /* needsRerender */;
		    return;
		  }
		  attachToAncestor(hostRef, hostRef.$ancestorComponent$);
		  const dispatch = () => dispatchHooks(hostRef, isInitialLoad);
		  return writeTask(dispatch) ;
		};
		var dispatchHooks = (hostRef, isInitialLoad) => {
		  const elm = hostRef.$hostElement$;
		  const endSchedule = createTime("scheduleUpdate", hostRef.$cmpMeta$.$tagName$);
		  const instance = hostRef.$lazyInstance$ ;
		  if (!instance) {
		    throw new Error(
		      `Can't render component <${elm.tagName.toLowerCase()} /> with invalid Stencil runtime! Make sure this imported component is compiled with a \`externalRuntime: true\` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime`
		    );
		  }
		  let maybePromise;
		  if (isInitialLoad) {
		    {
		      hostRef.$flags$ |= 256 /* isListenReady */;
		      if (hostRef.$queuedListeners$) {
		        hostRef.$queuedListeners$.map(([methodName, event]) => safeCall(instance, methodName, event));
		        hostRef.$queuedListeners$ = void 0;
		      }
		    }
		    {
		      maybePromise = safeCall(instance, "componentWillLoad");
		    }
		  } else {
		    {
		      maybePromise = safeCall(instance, "componentWillUpdate");
		    }
		  }
		  {
		    maybePromise = enqueue(maybePromise, () => safeCall(instance, "componentWillRender"));
		  }
		  endSchedule();
		  return enqueue(maybePromise, () => updateComponent(hostRef, instance, isInitialLoad));
		};
		var enqueue = (maybePromise, fn) => isPromisey(maybePromise) ? maybePromise.then(fn).catch((err2) => {
		  console.error(err2);
		  fn();
		}) : fn();
		var isPromisey = (maybePromise) => maybePromise instanceof Promise || maybePromise && maybePromise.then && typeof maybePromise.then === "function";
		var updateComponent = async (hostRef, instance, isInitialLoad) => {
		  var _a;
		  const elm = hostRef.$hostElement$;
		  const endUpdate = createTime("update", hostRef.$cmpMeta$.$tagName$);
		  const rc = elm["s-rc"];
		  const endRender = createTime("render", hostRef.$cmpMeta$.$tagName$);

		    //========= PDS PATCH START
		    if (elm.hasDSR) {
		        elm.shadowRoot.innerHTML = '';
		        delete elm.hasDSR;
		    }
		    //========= PDS PATCH END

		  {
		    callRender(hostRef, instance, elm, isInitialLoad);
		  }
		  if (rc) {
		    rc.map((cb) => cb());
		    elm["s-rc"] = void 0;
		  }
		  endRender();
		  endUpdate();
		  {
		    const childrenPromises = (_a = elm["s-p"]) != null ? _a : [];
		    const postUpdate = () => postUpdateComponent(hostRef);
		    if (childrenPromises.length === 0) {
		      postUpdate();
		    } else {
		      Promise.all(childrenPromises).then(postUpdate);
		      hostRef.$flags$ |= 4 /* isWaitingForChildren */;
		      childrenPromises.length = 0;
		    }
		  }
		};
		var callRender = (hostRef, instance, elm, isInitialLoad) => {
		  try {
		    instance = instance.render() ;
		    {
		      hostRef.$flags$ &= ~16 /* isQueuedForUpdate */;
		    }
		    {
		      hostRef.$flags$ |= 2 /* hasRendered */;
		    }
		    {
		      {
		        {
		          renderVdom(hostRef, instance, isInitialLoad);
		        }
		      }
		    }
		  } catch (e) {
		    consoleError$1(e, hostRef.$hostElement$);
		  }
		  return null;
		};
		var postUpdateComponent = (hostRef) => {
		  const tagName = hostRef.$cmpMeta$.$tagName$;
		  const elm = hostRef.$hostElement$;
		  const endPostUpdate = createTime("postUpdate", tagName);
		  const instance = hostRef.$lazyInstance$ ;
		  const ancestorComponent = hostRef.$ancestorComponent$;
		  {
		    safeCall(instance, "componentDidRender");
		  }
		  if (!(hostRef.$flags$ & 64 /* hasLoadedComponent */)) {
		    hostRef.$flags$ |= 64 /* hasLoadedComponent */;
		    {
		      addHydratedFlag(elm);
		    }
		    {
		      safeCall(instance, "componentDidLoad");
		    }
		    endPostUpdate();
		    {
		      hostRef.$onReadyResolve$(elm);
		      if (!ancestorComponent) {
		        appDidLoad();
		      }
		    }
		  } else {
		    {
		      safeCall(instance, "componentDidUpdate");
		    }
		    endPostUpdate();
		  }
		  {
		    hostRef.$onInstanceResolve$(elm);
		  }
		  {
		    if (hostRef.$onRenderResolve$) {
		      hostRef.$onRenderResolve$();
		      hostRef.$onRenderResolve$ = void 0;
		    }
		    if (hostRef.$flags$ & 512 /* needsRerender */) {
		      nextTick(() => scheduleUpdate(hostRef, false));
		    }
		    hostRef.$flags$ &= ~(4 /* isWaitingForChildren */ | 512 /* needsRerender */);
		  }
		};
		var forceUpdate = (ref) => {
		  {
		    const hostRef = getHostRef(ref);
		    const isConnected = hostRef.$hostElement$.isConnected;
		    if (isConnected && (hostRef.$flags$ & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {
		      scheduleUpdate(hostRef, false);
		    }
		    return isConnected;
		  }
		};
		var appDidLoad = (who) => {
		  {
		    addHydratedFlag(doc.documentElement);
		  }
		  nextTick(() => emitEvent(win, "appload", { detail: { namespace: NAMESPACE } }));
		};
		var safeCall = (instance, method, arg) => {
		  if (instance && instance[method]) {
		    try {
		      return instance[method](arg);
		    } catch (e) {
		      consoleError$1(e);
		    }
		  }
		  return void 0;
		};
		var addHydratedFlag = (elm) => {
		  var _a;
		  return elm.classList.add((_a = BUILD.hydratedSelectorName) != null ? _a : "hydrated") ;
		};

		// src/runtime/set-value.ts
		var getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);
		var setValue = (ref, propName, newVal, cmpMeta) => {
		  const hostRef = getHostRef(ref);
		  if (!hostRef) {
		    throw new Error(
		      `Couldn't find host element for "${cmpMeta.$tagName$}" as it is unknown to this Stencil runtime. This usually happens when integrating a 3rd party Stencil component with another Stencil component or application. Please reach out to the maintainers of the 3rd party Stencil component or report this on the Stencil Discord server (https://chat.stenciljs.com) or comment on this similar [GitHub issue](https://github.com/ionic-team/stencil/issues/5457).`
		    );
		  }
		  const elm = hostRef.$hostElement$ ;
		  const oldVal = hostRef.$instanceValues$.get(propName);
		  const flags = hostRef.$flags$;
		  const instance = hostRef.$lazyInstance$ ;
		  newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);
		  const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);
		  const didValueChange = newVal !== oldVal && !areBothNaN;
		  if ((!(flags & 8 /* isConstructingInstance */) || oldVal === void 0) && didValueChange) {
		    hostRef.$instanceValues$.set(propName, newVal);
		    if (instance) {
		      if (cmpMeta.$watchers$ && flags & 128 /* isWatchReady */) {
		        const watchMethods = cmpMeta.$watchers$[propName];
		        if (watchMethods) {
		          watchMethods.map((watchMethodName) => {
		            try {
		              instance[watchMethodName](newVal, oldVal, propName);
		            } catch (e) {
		              consoleError$1(e, elm);
		            }
		          });
		        }
		      }
		      if ((flags & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {
		        if (instance.componentShouldUpdate) {
		          if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {
		            return;
		          }
		        }
		        scheduleUpdate(hostRef, false);
		      }
		    }
		  }
		};

		// src/runtime/proxy-component.ts
		var proxyComponent = (Cstr, cmpMeta, flags) => {
		  var _a, _b;
		  const prototype = Cstr.prototype;
		  if (cmpMeta.$flags$ & 64 /* formAssociated */ && flags & 1 /* isElementConstructor */) {
		    FORM_ASSOCIATED_CUSTOM_ELEMENT_CALLBACKS.forEach((cbName) => {
		      Object.defineProperty(prototype, cbName, {
		        value(...args) {
		          const hostRef = getHostRef(this);
		          const instance = hostRef.$lazyInstance$ ;
		          if (!instance) {
		            hostRef.$onReadyPromise$.then((asyncInstance) => {
		              const cb = asyncInstance[cbName];
		              typeof cb === "function" && cb.call(asyncInstance, ...args);
		            });
		          } else {
		            const cb = instance[cbName] ;
		            typeof cb === "function" && cb.call(instance, ...args);
		          }
		        }
		      });
		    });
		  }
		  if (cmpMeta.$members$ || (cmpMeta.$watchers$ || Cstr.watchers)) {
		    if (Cstr.watchers && !cmpMeta.$watchers$) {
		      cmpMeta.$watchers$ = Cstr.watchers;
		    }
		    const members = Object.entries((_a = cmpMeta.$members$) != null ? _a : {});
		    members.map(([memberName, [memberFlags]]) => {
		      if ((memberFlags & 31 /* Prop */ || (flags & 2 /* proxyState */) && memberFlags & 32 /* State */)) {
		        if ((memberFlags & 2048 /* Getter */) === 0) {
		          Object.defineProperty(prototype, memberName, {
		            get() {
		              return getValue(this, memberName);
		            },
		            set(newValue) {
		              setValue(this, memberName, newValue, cmpMeta);
		            },
		            configurable: true,
		            enumerable: true
		          });
		        } else if (flags & 1 /* isElementConstructor */ && memberFlags & 2048 /* Getter */) {
		          {
		            Object.defineProperty(prototype, memberName, {
		              get() {
		                const ref = getHostRef(this);
		                const instance = ref ? ref.$lazyInstance$ : prototype;
		                if (!instance) return;
		                return instance[memberName];
		              },
		              configurable: true,
		              enumerable: true
		            });
		          }
		          if (memberFlags & 4096 /* Setter */) {
		            const origSetter = Object.getOwnPropertyDescriptor(prototype, memberName).set;
		            Object.defineProperty(prototype, memberName, {
		              set(newValue) {
		                const ref = getHostRef(this);
		                if (origSetter) {
		                  const currentValue = ref.$hostElement$[memberName];
		                  if (!ref.$instanceValues$.get(memberName) && currentValue) {
		                    ref.$instanceValues$.set(memberName, currentValue);
		                  }
		                  origSetter.apply(this, [parsePropertyValue(newValue, cmpMeta.$members$[memberName][0])]);
		                  setValue(this, memberName, ref.$hostElement$[memberName], cmpMeta);
		                  return;
		                }
		                if (!ref) return;
		                const setterSetVal = () => {
		                  const currentValue = ref.$lazyInstance$[memberName];
		                  if (!ref.$instanceValues$.get(memberName) && currentValue) {
		                    ref.$instanceValues$.set(memberName, currentValue);
		                  }
		                  ref.$lazyInstance$[memberName] = parsePropertyValue(newValue, cmpMeta.$members$[memberName][0]);
		                  setValue(this, memberName, ref.$lazyInstance$[memberName], cmpMeta);
		                };
		                if (ref.$lazyInstance$) {
		                  setterSetVal();
		                } else {
		                  ref.$onReadyPromise$.then(() => setterSetVal());
		                }
		              }
		            });
		          }
		        }
		      } else if (flags & 1 /* isElementConstructor */ && memberFlags & 64 /* Method */) {
		        Object.defineProperty(prototype, memberName, {
		          value(...args) {
		            var _a2;
		            const ref = getHostRef(this);
		            return (_a2 = ref == null ? void 0 : ref.$onInstancePromise$) == null ? void 0 : _a2.then(() => {
		              var _a3;
		              return (_a3 = ref.$lazyInstance$) == null ? void 0 : _a3[memberName](...args);
		            });
		          }
		        });
		      }
		    });
		    if ((flags & 1 /* isElementConstructor */)) {
		      const attrNameToPropName = /* @__PURE__ */ new Map();
		      prototype.attributeChangedCallback = function(attrName, oldValue, newValue) {
		        plt.jmp(() => {
		          var _a2;
		          const propName = attrNameToPropName.get(attrName);
		          if (this.hasOwnProperty(propName)) {
		            newValue = this[propName];
		            delete this[propName];
		          } else if (prototype.hasOwnProperty(propName) && typeof this[propName] === "number" && // cast type to number to avoid TS compiler issues
		          this[propName] == newValue) {
		            return;
		          } else if (propName == null) {
		            const hostRef = getHostRef(this);
		            const flags2 = hostRef == null ? void 0 : hostRef.$flags$;
		            if (flags2 && !(flags2 & 8 /* isConstructingInstance */) && flags2 & 128 /* isWatchReady */ && newValue !== oldValue) {
		              const instance = hostRef.$lazyInstance$ ;
		              const entry = (_a2 = cmpMeta.$watchers$) == null ? void 0 : _a2[attrName];
		              entry == null ? void 0 : entry.forEach((callbackName) => {
		                if (instance[callbackName] != null) {
		                  instance[callbackName].call(instance, newValue, oldValue, attrName);
		                }
		              });
		            }
		            return;
		          }
		          const propDesc = Object.getOwnPropertyDescriptor(prototype, propName);
		          if (!propDesc.get || !!propDesc.set) {
		            this[propName] = newValue === null && typeof this[propName] === "boolean" ? false : newValue;
		          }
		        });
		      };
		      Cstr.observedAttributes = Array.from(
		        /* @__PURE__ */ new Set([
		          ...Object.keys((_b = cmpMeta.$watchers$) != null ? _b : {}),
		          ...members.filter(([_, m]) => m[0] & 15 /* HasAttribute */).map(([propName, m]) => {
		            var _a2;
		            const attrName = m[1] || propName;
		            attrNameToPropName.set(attrName, propName);
		            if (m[0] & 512 /* ReflectAttr */) {
		              (_a2 = cmpMeta.$attrsToReflect$) == null ? void 0 : _a2.push([propName, attrName]);
		            }
		            return attrName;
		          })
		        ])
		      );
		    }
		  }
		  return Cstr;
		};

		// src/runtime/initialize-component.ts
		var initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId) => {
		  let Cstr;
		  if ((hostRef.$flags$ & 32 /* hasInitializedComponent */) === 0) {
		    hostRef.$flags$ |= 32 /* hasInitializedComponent */;
		    const bundleId = cmpMeta.$lazyBundleId$;
		    if (bundleId) {
		      const CstrImport = loadModule(cmpMeta);
		      if (CstrImport && "then" in CstrImport) {
		        const endLoad = uniqueTime();
		        Cstr = await CstrImport;
		        endLoad();
		      } else {
		        Cstr = CstrImport;
		      }
		      if (!Cstr) {
		        throw new Error(`Constructor for "${cmpMeta.$tagName$}#${hostRef.$modeName$}" was not found`);
		      }
		      if (!Cstr.isProxied) {
		        {
		          cmpMeta.$watchers$ = Cstr.watchers;
		        }
		        proxyComponent(Cstr, cmpMeta, 2 /* proxyState */);
		        Cstr.isProxied = true;
		      }
		      const endNewInstance = createTime("createInstance", cmpMeta.$tagName$);
		      {
		        hostRef.$flags$ |= 8 /* isConstructingInstance */;
		      }
		      try {
		        new Cstr(hostRef);
		      } catch (e) {
		        consoleError$1(e);
		      }
		      {
		        hostRef.$flags$ &= ~8 /* isConstructingInstance */;
		      }
		      {
		        hostRef.$flags$ |= 128 /* isWatchReady */;
		      }
		      endNewInstance();
		      fireConnectedCallback(hostRef.$lazyInstance$);
		    } else {
		      Cstr = elm.constructor;
		      const cmpTag = elm.localName;
		      customElements.whenDefined(cmpTag).then(() => hostRef.$flags$ |= 128 /* isWatchReady */);
		    }
		  }
		  const ancestorComponent = hostRef.$ancestorComponent$;
		  const schedule = () => scheduleUpdate(hostRef, true);
		  if (ancestorComponent && ancestorComponent["s-rc"]) {
		    ancestorComponent["s-rc"].push(schedule);
		  } else {
		    schedule();
		  }
		};
		var fireConnectedCallback = (instance) => {
		  {
		    safeCall(instance, "connectedCallback");
		  }
		};

		// src/runtime/connected-callback.ts
		var connectedCallback = (elm) => {
		  if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {
		    const hostRef = getHostRef(elm);
		    const cmpMeta = hostRef.$cmpMeta$;
		    const endConnected = createTime("connectedCallback", cmpMeta.$tagName$);
		    if (!(hostRef.$flags$ & 1 /* hasConnected */)) {
		      hostRef.$flags$ |= 1 /* hasConnected */;
		      {
		        let ancestorComponent = elm;
		        while (ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host) {
		          if (ancestorComponent["s-p"]) {
		            attachToAncestor(hostRef, hostRef.$ancestorComponent$ = ancestorComponent);
		            break;
		          }
		        }
		      }
		      if (cmpMeta.$members$) {
		        Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {
		          if (memberFlags & 31 /* Prop */ && elm.hasOwnProperty(memberName)) {
		            const value = elm[memberName];
		            delete elm[memberName];
		            elm[memberName] = value;
		          }
		        });
		      }
		      {
		        initializeComponent(elm, hostRef, cmpMeta);
		      }
		    } else {
		      addHostEventListeners(elm, hostRef, cmpMeta.$listeners$);
		      if (hostRef == null ? void 0 : hostRef.$lazyInstance$) {
		        fireConnectedCallback(hostRef.$lazyInstance$);
		      } else if (hostRef == null ? void 0 : hostRef.$onReadyPromise$) {
		        hostRef.$onReadyPromise$.then(() => fireConnectedCallback(hostRef.$lazyInstance$));
		      }
		    }
		    endConnected();
		  }
		};
		var disconnectInstance = (instance) => {
		  {
		    safeCall(instance, "disconnectedCallback");
		  }
		};
		var disconnectedCallback = async (elm) => {
		  if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {
		    const hostRef = getHostRef(elm);
		    {
		      if (hostRef.$rmListeners$) {
		        hostRef.$rmListeners$.map((rmListener) => rmListener());
		        hostRef.$rmListeners$ = void 0;
		      }
		    }
		    if (hostRef == null ? void 0 : hostRef.$lazyInstance$) {
		      disconnectInstance(hostRef.$lazyInstance$);
		    } else if (hostRef == null ? void 0 : hostRef.$onReadyPromise$) {
		      hostRef.$onReadyPromise$.then(() => disconnectInstance(hostRef.$lazyInstance$));
		    }
		  }
		};

		// src/runtime/bootstrap-lazy.ts
		var bootstrapLazy = (lazyBundles, options = {}) => {
		  var _a;
		  const endBootstrap = createTime();
		  const cmpTags = [];
		  const exclude = options.exclude || [];
		  const customElements2 = win.customElements;
		  const head = doc.head;
		  const metaCharset = /* @__PURE__ */ head.querySelector("meta[charset]");
		  const dataStyles = /* @__PURE__ */ doc.createElement("style");
		  const deferredConnectedCallbacks = [];
		  let appLoadFallback;
		  let isBootstrapping = true;
		  Object.assign(plt, options);
		  plt.$resourcesUrl$ = new URL(options.resourcesUrl || "./", doc.baseURI).href;
		  let hasSlotRelocation = false;
		  lazyBundles.map((lazyBundle) => {
		    lazyBundle[1].map((compactMeta) => {
		      var _a2;
		      const cmpMeta = {
		        $flags$: compactMeta[0],
		        $tagName$: compactMeta[1],
		        $members$: compactMeta[2],
		        $listeners$: compactMeta[3]
		      };
		      if (cmpMeta.$flags$ & 4 /* hasSlotRelocation */) {
		        hasSlotRelocation = true;
		      }
		      {
		        cmpMeta.$members$ = compactMeta[2];
		      }
		      {
		        cmpMeta.$listeners$ = compactMeta[3];
		      }
		      {
		        cmpMeta.$attrsToReflect$ = [];
		      }
		      {
		        cmpMeta.$watchers$ = (_a2 = compactMeta[4]) != null ? _a2 : {};
		      }
		      const tagName = options.transformTagName ? options.transformTagName(cmpMeta.$tagName$) : cmpMeta.$tagName$;
		      const HostElement = class extends HTMLElement {
		        // StencilLazyHost
		        constructor(self) {
		          super(self);
		          this.hasRegisteredEventListeners = false;
		          self = this;
		          registerHost(self, cmpMeta);
		          if (cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {
		            {
		                            //========= PDS PATCH START
		                            let ssrInnerHTML = '';
		                            if (self.shadowRoot) {
		                              ssrInnerHTML = self.shadowRoot.innerHTML;
		                              self.hasDSR = true;
		                            }
		                            //========= PDS PATCH END

		              if (!self.shadowRoot) {
		                {
		                                //========= PDS PATCH START
		                                // in dsr ponyfilled browsers (e.g. Safari), the shadowRoot is already attached
		                                // and a 2nd attempt fails, therefore this needs to always run without SSR
		                                // and only with SSR for browsers that are not ponyfilled
		                                if (!self.hasDSR || HTMLTemplateElement.prototype.hasOwnProperty('shadowRoot')) {
		                                //========= PDS PATCH END

		                  self.attachShadow({
		                    mode: "open",
		                    delegatesFocus: !!(cmpMeta.$flags$ & 16 /* shadowDelegatesFocus */)
		                  });

		                                //========= PDS PATCH START
		                                    self.shadowRoot.innerHTML = ssrInnerHTML;
		                                }
		                                //========= PDS PATCH END

		                }
		              } else {
		                if (self.shadowRoot.mode !== "open") {
		                  throw new Error(
		                    `Unable to re-use existing shadow root for ${cmpMeta.$tagName$}! Mode is set to ${self.shadowRoot.mode} but Stencil only supports open shadow roots.`
		                  );
		                }
		              }
		            }
		          }
		        }
		        connectedCallback() {
		          const hostRef = getHostRef(this);
		          if (!this.hasRegisteredEventListeners) {
		            this.hasRegisteredEventListeners = true;
		            addHostEventListeners(this, hostRef, cmpMeta.$listeners$);
		          }
		          if (appLoadFallback) {
		            clearTimeout(appLoadFallback);
		            appLoadFallback = null;
		          }
		          if (isBootstrapping) {
		            deferredConnectedCallbacks.push(this);
		          } else {
		            plt.jmp(() => connectedCallback(this));
		          }
		        }
		        disconnectedCallback() {
		          plt.jmp(() => disconnectedCallback(this));
		        }
		        componentOnReady() {
		          return getHostRef(this).$onReadyPromise$;
		        }
		      };
		      if (cmpMeta.$flags$ & 64 /* formAssociated */) {
		        HostElement.formAssociated = true;
		      }
		      cmpMeta.$lazyBundleId$ = lazyBundle[0];
		      if (!exclude.includes(tagName) && !customElements2.get(tagName)) {
		        cmpTags.push(tagName);
		        customElements2.define(
		          tagName,
		          proxyComponent(HostElement, cmpMeta, 1 /* isElementConstructor */)
		        );
		      }
		    });
		  });
		  if (cmpTags.length > 0) {
		    if (hasSlotRelocation) {
		      dataStyles.textContent += SLOT_FB_CSS;
		    }
		    if (dataStyles.innerHTML.length) {
		      dataStyles.setAttribute("data-styles", "");
		      const nonce = (_a = plt.$nonce$) != null ? _a : queryNonceMetaTagContent(doc);
		      if (nonce != null) {
		        dataStyles.setAttribute("nonce", nonce);
		      }
		      head.insertBefore(dataStyles, metaCharset ? metaCharset.nextSibling : head.firstChild);
		    }
		  }
		  isBootstrapping = false;
		  if (deferredConnectedCallbacks.length) {
		    deferredConnectedCallbacks.map((host) => host.connectedCallback());
		  } else {
		    {
		      plt.jmp(() => appLoadFallback = setTimeout(appDidLoad, 30));
		    }
		  }
		  endBootstrap();
		};

		// src/runtime/fragment.ts
		var Fragment = (_, children) => children;
		var addHostEventListeners = (elm, hostRef, listeners, attachParentListeners) => {
		  if (listeners) {
		    listeners.map(([flags, name, method]) => {
		      const target = elm;
		      const handler = hostListenerProxy(hostRef, method);
		      const opts = hostListenerOpts(flags);
		      plt.ael(target, name, handler, opts);
		      (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));
		    });
		  }
		};
		var hostListenerProxy = (hostRef, methodName) => (ev) => {
		  var _a;
		  try {
		    {
		      if (hostRef.$flags$ & 256 /* isListenReady */) {
		        (_a = hostRef.$lazyInstance$) == null ? void 0 : _a[methodName](ev);
		      } else {
		        (hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([methodName, ev]);
		      }
		    }
		  } catch (e) {
		    consoleError$1(e);
		  }
		};
		var hostListenerOpts = (flags) => supportsListenerOptions ? {
		  passive: (flags & 1 /* Passive */) !== 0,
		  capture: (flags & 2 /* Capture */) !== 0
		} : (flags & 2 /* Capture */) !== 0;

		// src/runtime/nonce.ts
		var setNonce = (nonce) => plt.$nonce$ = nonce;

		const prefix = `[Porsche Design System v${"3.27.1"}]` // this part isn't covered by unit tests
		    ;
		const consoleWarn = (...messages) => {
		    console.warn(prefix, ...messages); // eslint-disable-line no-console
		};
		const consoleError = (...messages) => {
		    console.error(prefix, ...messages); // eslint-disable-line no-console
		};
		const throwException = (message) => {
		    throw new Error(`${prefix} ${message}`); // eslint-disable-line fp/no-throw
		};

		const TAG_NAMES = ['p-accordion', 'p-banner', 'p-button', 'p-button-group', 'p-button-pure', 'p-button-tile', 'p-canvas', 'p-carousel', 'p-checkbox', 'p-checkbox-wrapper', 'p-content-wrapper', 'p-crest', 'p-display', 'p-divider', 'p-fieldset', 'p-fieldset-wrapper', 'p-flex', 'p-flex-item', 'p-flyout', 'p-flyout-multilevel', 'p-flyout-multilevel-item', 'p-grid', 'p-grid-item', 'p-heading', 'p-headline', 'p-icon', 'p-inline-notification', 'p-link', 'p-link-pure', 'p-link-social', 'p-link-tile', 'p-link-tile-model-signature', 'p-link-tile-product', 'p-marque', 'p-modal', 'p-model-signature', 'p-multi-select', 'p-multi-select-option', 'p-optgroup', 'p-pagination', 'p-pin-code', 'p-popover', 'p-radio-button-wrapper', 'p-scroller', 'p-segmented-control', 'p-segmented-control-item', 'p-select', 'p-select-option', 'p-select-wrapper', 'p-select-wrapper-dropdown', 'p-sheet', 'p-spinner', 'p-stepper-horizontal', 'p-stepper-horizontal-item', 'p-switch', 'p-table', 'p-table-body', 'p-table-cell', 'p-table-head', 'p-table-head-cell', 'p-table-head-row', 'p-table-row', 'p-tabs', 'p-tabs-bar', 'p-tabs-item', 'p-tag', 'p-tag-dismissible', 'p-text', 'p-text-field-wrapper', 'p-text-list', 'p-text-list-item', 'p-textarea', 'p-textarea-wrapper', 'p-toast', 'p-toast-item', 'p-wordmark'];

		function _extends() {
		  _extends = Object.assign ? Object.assign.bind() : function (target) {
		    for (var i = 1; i < arguments.length; i++) {
		      var source = arguments[i];
		      for (var key in source) {
		        if (Object.prototype.hasOwnProperty.call(source, key)) {
		          target[key] = source[key];
		        }
		      }
		    }
		    return target;
		  };
		  return _extends.apply(this, arguments);
		}

		var _typeof$1 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

		var isBrowser = (typeof window === "undefined" ? "undefined" : _typeof$1(window)) === "object" && (typeof document === "undefined" ? "undefined" : _typeof$1(document)) === 'object' && document.nodeType === 9;

		function _typeof(o) {
		  "@babel/helpers - typeof";

		  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
		    return typeof o;
		  } : function (o) {
		    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
		  }, _typeof(o);
		}

		function toPrimitive(t, r) {
		  if ("object" != _typeof(t) || !t) return t;
		  var e = t[Symbol.toPrimitive];
		  if (void 0 !== e) {
		    var i = e.call(t, r);
		    if ("object" != _typeof(i)) return i;
		    throw new TypeError("@@toPrimitive must return a primitive value.");
		  }
		  return (String )(t);
		}

		function toPropertyKey(t) {
		  var i = toPrimitive(t, "string");
		  return "symbol" == _typeof(i) ? i : i + "";
		}

		function _defineProperties(target, props) {
		  for (var i = 0; i < props.length; i++) {
		    var descriptor = props[i];
		    descriptor.enumerable = descriptor.enumerable || false;
		    descriptor.configurable = true;
		    if ("value" in descriptor) descriptor.writable = true;
		    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
		  }
		}
		function _createClass(Constructor, protoProps, staticProps) {
		  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
		  Object.defineProperty(Constructor, "prototype", {
		    writable: false
		  });
		  return Constructor;
		}

		function _setPrototypeOf(o, p) {
		  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
		    o.__proto__ = p;
		    return o;
		  };
		  return _setPrototypeOf(o, p);
		}

		function _inheritsLoose(subClass, superClass) {
		  subClass.prototype = Object.create(superClass.prototype);
		  subClass.prototype.constructor = subClass;
		  _setPrototypeOf(subClass, superClass);
		}

		function _assertThisInitialized(self) {
		  if (self === void 0) {
		    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		  }
		  return self;
		}

		function _objectWithoutPropertiesLoose(source, excluded) {
		  if (source == null) return {};
		  var target = {};
		  var sourceKeys = Object.keys(source);
		  var key, i;
		  for (i = 0; i < sourceKeys.length; i++) {
		    key = sourceKeys[i];
		    if (excluded.indexOf(key) >= 0) continue;
		    target[key] = source[key];
		  }
		  return target;
		}

		var plainObjectConstrurctor = {}.constructor;
		function cloneStyle(style) {
		  if (style == null || typeof style !== 'object') return style;
		  if (Array.isArray(style)) return style.map(cloneStyle);
		  if (style.constructor !== plainObjectConstrurctor) return style;
		  var newStyle = {};

		  for (var name in style) {
		    newStyle[name] = cloneStyle(style[name]);
		  }

		  return newStyle;
		}

		/**
		 * Create a rule instance.
		 */

		function createRule(name, decl, options) {
		  if (name === void 0) {
		    name = 'unnamed';
		  }

		  var jss = options.jss;
		  var declCopy = cloneStyle(decl);
		  var rule = jss.plugins.onCreateRule(name, declCopy, options);
		  if (rule) return rule; // It is an at-rule and it has no instance.

		  return null;
		}

		var join = function join(value, by) {
		  var result = '';

		  for (var i = 0; i < value.length; i++) {
		    // Remove !important from the value, it will be readded later.
		    if (value[i] === '!important') break;
		    if (result) result += by;
		    result += value[i];
		  }

		  return result;
		};
		/**
		 * Converts JSS array value to a CSS string.
		 *
		 * `margin: [['5px', '10px']]` > `margin: 5px 10px;`
		 * `border: ['1px', '2px']` > `border: 1px, 2px;`
		 * `margin: [['5px', '10px'], '!important']` > `margin: 5px 10px !important;`
		 * `color: ['red', !important]` > `color: red !important;`
		 */


		var toCssValue = function toCssValue(value) {
		  if (!Array.isArray(value)) return value;
		  var cssValue = ''; // Support space separated values via `[['5px', '10px']]`.

		  if (Array.isArray(value[0])) {
		    for (var i = 0; i < value.length; i++) {
		      if (value[i] === '!important') break;
		      if (cssValue) cssValue += ', ';
		      cssValue += join(value[i], ' ');
		    }
		  } else cssValue = join(value, ', '); // Add !important, because it was ignored.


		  if (value[value.length - 1] === '!important') {
		    cssValue += ' !important';
		  }

		  return cssValue;
		};

		function getWhitespaceSymbols(options) {
		  if (options && options.format === false) {
		    return {
		      linebreak: '',
		      space: ''
		    };
		  }

		  return {
		    linebreak: '\n',
		    space: ' '
		  };
		}

		/**
		 * Indent a string.
		 * http://jsperf.com/array-join-vs-for
		 */

		function indentStr(str, indent) {
		  var result = '';

		  for (var index = 0; index < indent; index++) {
		    result += '  ';
		  }

		  return result + str;
		}
		/**
		 * Converts a Rule to CSS string.
		 */


		function toCss(selector, style, options) {
		  if (options === void 0) {
		    options = {};
		  }

		  var result = '';
		  if (!style) return result;
		  var _options = options,
		      _options$indent = _options.indent,
		      indent = _options$indent === void 0 ? 0 : _options$indent;
		  var fallbacks = style.fallbacks;

		  if (options.format === false) {
		    indent = -Infinity;
		  }

		  var _getWhitespaceSymbols = getWhitespaceSymbols(options),
		      linebreak = _getWhitespaceSymbols.linebreak,
		      space = _getWhitespaceSymbols.space;

		  if (selector) indent++; // Apply fallbacks first.

		  if (fallbacks) {
		    // Array syntax {fallbacks: [{prop: value}]}
		    if (Array.isArray(fallbacks)) {
		      for (var index = 0; index < fallbacks.length; index++) {
		        var fallback = fallbacks[index];

		        for (var prop in fallback) {
		          var value = fallback[prop];

		          if (value != null) {
		            if (result) result += linebreak;
		            result += indentStr(prop + ":" + space + toCssValue(value) + ";", indent);
		          }
		        }
		      }
		    } else {
		      // Object syntax {fallbacks: {prop: value}}
		      for (var _prop in fallbacks) {
		        var _value = fallbacks[_prop];

		        if (_value != null) {
		          if (result) result += linebreak;
		          result += indentStr(_prop + ":" + space + toCssValue(_value) + ";", indent);
		        }
		      }
		    }
		  }

		  for (var _prop2 in style) {
		    var _value2 = style[_prop2];

		    if (_value2 != null && _prop2 !== 'fallbacks') {
		      if (result) result += linebreak;
		      result += indentStr(_prop2 + ":" + space + toCssValue(_value2) + ";", indent);
		    }
		  } // Allow empty style in this case, because properties will be added dynamically.


		  if (!result && !options.allowEmpty) return result; // When rule is being stringified before selector was defined.

		  if (!selector) return result;
		  indent--;
		  if (result) result = "" + linebreak + result + linebreak;
		  return indentStr("" + selector + space + "{" + result, indent) + indentStr('}', indent);
		}

		var escapeRegex = /([[\].#*$><+~=|^:(),"'`\s])/g;
		var nativeEscape = typeof CSS !== 'undefined' && CSS.escape;
		var escape = (function (str) {
		  return nativeEscape ? nativeEscape(str) : str.replace(escapeRegex, '\\$1');
		});

		var BaseStyleRule =
		/*#__PURE__*/
		function () {
		  function BaseStyleRule(key, style, options) {
		    this.type = 'style';
		    this.isProcessed = false;
		    var sheet = options.sheet,
		        Renderer = options.Renderer;
		    this.key = key;
		    this.options = options;
		    this.style = style;
		    if (sheet) this.renderer = sheet.renderer;else if (Renderer) this.renderer = new Renderer();
		  }
		  /**
		   * Get or set a style property.
		   */


		  var _proto = BaseStyleRule.prototype;

		  _proto.prop = function prop(name, value, options) {
		    // It's a getter.
		    if (value === undefined) return this.style[name]; // Don't do anything if the value has not changed.

		    var force = options ? options.force : false;
		    if (!force && this.style[name] === value) return this;
		    var newValue = value;

		    if (!options || options.process !== false) {
		      newValue = this.options.jss.plugins.onChangeValue(value, name, this);
		    }

		    var isEmpty = newValue == null || newValue === false;
		    var isDefined = name in this.style; // Value is empty and wasn't defined before.

		    if (isEmpty && !isDefined && !force) return this; // We are going to remove this value.

		    var remove = isEmpty && isDefined;
		    if (remove) delete this.style[name];else this.style[name] = newValue; // Renderable is defined if StyleSheet option `link` is true.

		    if (this.renderable && this.renderer) {
		      if (remove) this.renderer.removeProperty(this.renderable, name);else this.renderer.setProperty(this.renderable, name, newValue);
		      return this;
		    }

		    return this;
		  };

		  return BaseStyleRule;
		}();
		var StyleRule =
		/*#__PURE__*/
		function (_BaseStyleRule) {
		  _inheritsLoose(StyleRule, _BaseStyleRule);

		  function StyleRule(key, style, options) {
		    var _this;

		    _this = _BaseStyleRule.call(this, key, style, options) || this;
		    var selector = options.selector,
		        scoped = options.scoped,
		        sheet = options.sheet,
		        generateId = options.generateId;

		    if (selector) {
		      _this.selectorText = selector;
		    } else if (scoped !== false) {
		      _this.id = generateId(_assertThisInitialized(_assertThisInitialized(_this)), sheet);
		      _this.selectorText = "." + escape(_this.id);
		    }

		    return _this;
		  }
		  /**
		   * Set selector string.
		   * Attention: use this with caution. Most browsers didn't implement
		   * selectorText setter, so this may result in rerendering of entire Style Sheet.
		   */


		  var _proto2 = StyleRule.prototype;

		  /**
		   * Apply rule to an element inline.
		   */
		  _proto2.applyTo = function applyTo(renderable) {
		    var renderer = this.renderer;

		    if (renderer) {
		      var json = this.toJSON();

		      for (var prop in json) {
		        renderer.setProperty(renderable, prop, json[prop]);
		      }
		    }

		    return this;
		  }
		  /**
		   * Returns JSON representation of the rule.
		   * Fallbacks are not supported.
		   * Useful for inline styles.
		   */
		  ;

		  _proto2.toJSON = function toJSON() {
		    var json = {};

		    for (var prop in this.style) {
		      var value = this.style[prop];
		      if (typeof value !== 'object') json[prop] = value;else if (Array.isArray(value)) json[prop] = toCssValue(value);
		    }

		    return json;
		  }
		  /**
		   * Generates a CSS string.
		   */
		  ;

		  _proto2.toString = function toString(options) {
		    var sheet = this.options.sheet;
		    var link = sheet ? sheet.options.link : false;
		    var opts = link ? _extends({}, options, {
		      allowEmpty: true
		    }) : options;
		    return toCss(this.selectorText, this.style, opts);
		  };

		  _createClass(StyleRule, [{
		    key: "selector",
		    set: function set(selector) {
		      if (selector === this.selectorText) return;
		      this.selectorText = selector;
		      var renderer = this.renderer,
		          renderable = this.renderable;
		      if (!renderable || !renderer) return;
		      var hasChanged = renderer.setSelector(renderable, selector); // If selector setter is not implemented, rerender the rule.

		      if (!hasChanged) {
		        renderer.replaceRule(renderable, this);
		      }
		    }
		    /**
		     * Get selector string.
		     */
		    ,
		    get: function get() {
		      return this.selectorText;
		    }
		  }]);

		  return StyleRule;
		}(BaseStyleRule);
		var pluginStyleRule = {
		  onCreateRule: function onCreateRule(key, style, options) {
		    if (key[0] === '@' || options.parent && options.parent.type === 'keyframes') {
		      return null;
		    }

		    return new StyleRule(key, style, options);
		  }
		};

		var defaultToStringOptions = {
		  indent: 1,
		  children: true
		};
		var atRegExp = /@([\w-]+)/;
		/**
		 * Conditional rule for @media, @supports
		 */

		var ConditionalRule =
		/*#__PURE__*/
		function () {
		  function ConditionalRule(key, styles, options) {
		    this.type = 'conditional';
		    this.isProcessed = false;
		    this.key = key;
		    var atMatch = key.match(atRegExp);
		    this.at = atMatch ? atMatch[1] : 'unknown'; // Key might contain a unique suffix in case the `name` passed by user was duplicate.

		    this.query = options.name || "@" + this.at;
		    this.options = options;
		    this.rules = new RuleList(_extends({}, options, {
		      parent: this
		    }));

		    for (var name in styles) {
		      this.rules.add(name, styles[name]);
		    }

		    this.rules.process();
		  }
		  /**
		   * Get a rule.
		   */


		  var _proto = ConditionalRule.prototype;

		  _proto.getRule = function getRule(name) {
		    return this.rules.get(name);
		  }
		  /**
		   * Get index of a rule.
		   */
		  ;

		  _proto.indexOf = function indexOf(rule) {
		    return this.rules.indexOf(rule);
		  }
		  /**
		   * Create and register rule, run plugins.
		   */
		  ;

		  _proto.addRule = function addRule(name, style, options) {
		    var rule = this.rules.add(name, style, options);
		    if (!rule) return null;
		    this.options.jss.plugins.onProcessRule(rule);
		    return rule;
		  }
		  /**
		   * Replace rule, run plugins.
		   */
		  ;

		  _proto.replaceRule = function replaceRule(name, style, options) {
		    var newRule = this.rules.replace(name, style, options);
		    if (newRule) this.options.jss.plugins.onProcessRule(newRule);
		    return newRule;
		  }
		  /**
		   * Generates a CSS string.
		   */
		  ;

		  _proto.toString = function toString(options) {
		    if (options === void 0) {
		      options = defaultToStringOptions;
		    }

		    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
		        linebreak = _getWhitespaceSymbols.linebreak;

		    if (options.indent == null) options.indent = defaultToStringOptions.indent;
		    if (options.children == null) options.children = defaultToStringOptions.children;

		    if (options.children === false) {
		      return this.query + " {}";
		    }

		    var children = this.rules.toString(options);
		    return children ? this.query + " {" + linebreak + children + linebreak + "}" : '';
		  };

		  return ConditionalRule;
		}();
		var keyRegExp = /@container|@media|@supports\s+/;
		var pluginConditionalRule = {
		  onCreateRule: function onCreateRule(key, styles, options) {
		    return keyRegExp.test(key) ? new ConditionalRule(key, styles, options) : null;
		  }
		};

		var defaultToStringOptions$1 = {
		  indent: 1,
		  children: true
		};
		var nameRegExp = /@keyframes\s+([\w-]+)/;
		/**
		 * Rule for @keyframes
		 */

		var KeyframesRule =
		/*#__PURE__*/
		function () {
		  function KeyframesRule(key, frames, options) {
		    this.type = 'keyframes';
		    this.at = '@keyframes';
		    this.isProcessed = false;
		    var nameMatch = key.match(nameRegExp);

		    if (nameMatch && nameMatch[1]) {
		      this.name = nameMatch[1];
		    } else {
		      this.name = 'noname';
		    }

		    this.key = this.type + "-" + this.name;
		    this.options = options;
		    var scoped = options.scoped,
		        sheet = options.sheet,
		        generateId = options.generateId;
		    this.id = scoped === false ? this.name : escape(generateId(this, sheet));
		    this.rules = new RuleList(_extends({}, options, {
		      parent: this
		    }));

		    for (var name in frames) {
		      this.rules.add(name, frames[name], _extends({}, options, {
		        parent: this
		      }));
		    }

		    this.rules.process();
		  }
		  /**
		   * Generates a CSS string.
		   */


		  var _proto = KeyframesRule.prototype;

		  _proto.toString = function toString(options) {
		    if (options === void 0) {
		      options = defaultToStringOptions$1;
		    }

		    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
		        linebreak = _getWhitespaceSymbols.linebreak;

		    if (options.indent == null) options.indent = defaultToStringOptions$1.indent;
		    if (options.children == null) options.children = defaultToStringOptions$1.children;

		    if (options.children === false) {
		      return this.at + " " + this.id + " {}";
		    }

		    var children = this.rules.toString(options);
		    if (children) children = "" + linebreak + children + linebreak;
		    return this.at + " " + this.id + " {" + children + "}";
		  };

		  return KeyframesRule;
		}();
		var keyRegExp$1 = /@keyframes\s+/;
		var refRegExp$1 = /\$([\w-]+)/g;

		var findReferencedKeyframe = function findReferencedKeyframe(val, keyframes) {
		  if (typeof val === 'string') {
		    return val.replace(refRegExp$1, function (match, name) {
		      if (name in keyframes) {
		        return keyframes[name];
		      }
		      return match;
		    });
		  }

		  return val;
		};
		/**
		 * Replace the reference for a animation name.
		 */


		var replaceRef = function replaceRef(style, prop, keyframes) {
		  var value = style[prop];
		  var refKeyframe = findReferencedKeyframe(value, keyframes);

		  if (refKeyframe !== value) {
		    style[prop] = refKeyframe;
		  }
		};

		var pluginKeyframesRule = {
		  onCreateRule: function onCreateRule(key, frames, options) {
		    return typeof key === 'string' && keyRegExp$1.test(key) ? new KeyframesRule(key, frames, options) : null;
		  },
		  // Animation name ref replacer.
		  onProcessStyle: function onProcessStyle(style, rule, sheet) {
		    if (rule.type !== 'style' || !sheet) return style;
		    if ('animation-name' in style) replaceRef(style, 'animation-name', sheet.keyframes);
		    if ('animation' in style) replaceRef(style, 'animation', sheet.keyframes);
		    return style;
		  },
		  onChangeValue: function onChangeValue(val, prop, rule) {
		    var sheet = rule.options.sheet;

		    if (!sheet) {
		      return val;
		    }

		    switch (prop) {
		      case 'animation':
		        return findReferencedKeyframe(val, sheet.keyframes);

		      case 'animation-name':
		        return findReferencedKeyframe(val, sheet.keyframes);

		      default:
		        return val;
		    }
		  }
		};

		var KeyframeRule =
		/*#__PURE__*/
		function (_BaseStyleRule) {
		  _inheritsLoose(KeyframeRule, _BaseStyleRule);

		  function KeyframeRule() {
		    return _BaseStyleRule.apply(this, arguments) || this;
		  }

		  var _proto = KeyframeRule.prototype;

		  /**
		   * Generates a CSS string.
		   */
		  _proto.toString = function toString(options) {
		    var sheet = this.options.sheet;
		    var link = sheet ? sheet.options.link : false;
		    var opts = link ? _extends({}, options, {
		      allowEmpty: true
		    }) : options;
		    return toCss(this.key, this.style, opts);
		  };

		  return KeyframeRule;
		}(BaseStyleRule);
		var pluginKeyframeRule = {
		  onCreateRule: function onCreateRule(key, style, options) {
		    if (options.parent && options.parent.type === 'keyframes') {
		      return new KeyframeRule(key, style, options);
		    }

		    return null;
		  }
		};

		var FontFaceRule =
		/*#__PURE__*/
		function () {
		  function FontFaceRule(key, style, options) {
		    this.type = 'font-face';
		    this.at = '@font-face';
		    this.isProcessed = false;
		    this.key = key;
		    this.style = style;
		    this.options = options;
		  }
		  /**
		   * Generates a CSS string.
		   */


		  var _proto = FontFaceRule.prototype;

		  _proto.toString = function toString(options) {
		    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
		        linebreak = _getWhitespaceSymbols.linebreak;

		    if (Array.isArray(this.style)) {
		      var str = '';

		      for (var index = 0; index < this.style.length; index++) {
		        str += toCss(this.at, this.style[index]);
		        if (this.style[index + 1]) str += linebreak;
		      }

		      return str;
		    }

		    return toCss(this.at, this.style, options);
		  };

		  return FontFaceRule;
		}();
		var keyRegExp$2 = /@font-face/;
		var pluginFontFaceRule = {
		  onCreateRule: function onCreateRule(key, style, options) {
		    return keyRegExp$2.test(key) ? new FontFaceRule(key, style, options) : null;
		  }
		};

		var ViewportRule =
		/*#__PURE__*/
		function () {
		  function ViewportRule(key, style, options) {
		    this.type = 'viewport';
		    this.at = '@viewport';
		    this.isProcessed = false;
		    this.key = key;
		    this.style = style;
		    this.options = options;
		  }
		  /**
		   * Generates a CSS string.
		   */


		  var _proto = ViewportRule.prototype;

		  _proto.toString = function toString(options) {
		    return toCss(this.key, this.style, options);
		  };

		  return ViewportRule;
		}();
		var pluginViewportRule = {
		  onCreateRule: function onCreateRule(key, style, options) {
		    return key === '@viewport' || key === '@-ms-viewport' ? new ViewportRule(key, style, options) : null;
		  }
		};

		var SimpleRule =
		/*#__PURE__*/
		function () {
		  function SimpleRule(key, value, options) {
		    this.type = 'simple';
		    this.isProcessed = false;
		    this.key = key;
		    this.value = value;
		    this.options = options;
		  }
		  /**
		   * Generates a CSS string.
		   */
		  // eslint-disable-next-line no-unused-vars


		  var _proto = SimpleRule.prototype;

		  _proto.toString = function toString(options) {
		    if (Array.isArray(this.value)) {
		      var str = '';

		      for (var index = 0; index < this.value.length; index++) {
		        str += this.key + " " + this.value[index] + ";";
		        if (this.value[index + 1]) str += '\n';
		      }

		      return str;
		    }

		    return this.key + " " + this.value + ";";
		  };

		  return SimpleRule;
		}();
		var keysMap = {
		  '@charset': true,
		  '@import': true,
		  '@namespace': true
		};
		var pluginSimpleRule = {
		  onCreateRule: function onCreateRule(key, value, options) {
		    return key in keysMap ? new SimpleRule(key, value, options) : null;
		  }
		};

		var plugins = [pluginStyleRule, pluginConditionalRule, pluginKeyframesRule, pluginKeyframeRule, pluginFontFaceRule, pluginViewportRule, pluginSimpleRule];

		var defaultUpdateOptions = {
		  process: true
		};
		var forceUpdateOptions = {
		  force: true,
		  process: true
		  /**
		   * Contains rules objects and allows adding/removing etc.
		   * Is used for e.g. by `StyleSheet` or `ConditionalRule`.
		   */

		};

		var RuleList =
		/*#__PURE__*/
		function () {
		  // Rules registry for access by .get() method.
		  // It contains the same rule registered by name and by selector.
		  // Original styles object.
		  // Used to ensure correct rules order.
		  function RuleList(options) {
		    this.map = {};
		    this.raw = {};
		    this.index = [];
		    this.counter = 0;
		    this.options = options;
		    this.classes = options.classes;
		    this.keyframes = options.keyframes;
		  }
		  /**
		   * Create and register rule.
		   *
		   * Will not render after Style Sheet was rendered the first time.
		   */


		  var _proto = RuleList.prototype;

		  _proto.add = function add(name, decl, ruleOptions) {
		    var _this$options = this.options,
		        parent = _this$options.parent,
		        sheet = _this$options.sheet,
		        jss = _this$options.jss,
		        Renderer = _this$options.Renderer,
		        generateId = _this$options.generateId,
		        scoped = _this$options.scoped;

		    var options = _extends({
		      classes: this.classes,
		      parent: parent,
		      sheet: sheet,
		      jss: jss,
		      Renderer: Renderer,
		      generateId: generateId,
		      scoped: scoped,
		      name: name,
		      keyframes: this.keyframes,
		      selector: undefined
		    }, ruleOptions); // When user uses .createStyleSheet(), duplicate names are not possible, but
		    // `sheet.addRule()` opens the door for any duplicate rule name. When this happens
		    // we need to make the key unique within this RuleList instance scope.


		    var key = name;

		    if (name in this.raw) {
		      key = name + "-d" + this.counter++;
		    } // We need to save the original decl before creating the rule
		    // because cache plugin needs to use it as a key to return a cached rule.


		    this.raw[key] = decl;

		    if (key in this.classes) {
		      // E.g. rules inside of @media container
		      options.selector = "." + escape(this.classes[key]);
		    }

		    var rule = createRule(key, decl, options);
		    if (!rule) return null;
		    this.register(rule);
		    var index = options.index === undefined ? this.index.length : options.index;
		    this.index.splice(index, 0, rule);
		    return rule;
		  }
		  /**
		   * Replace rule.
		   * Create a new rule and remove old one instead of overwriting
		   * because we want to invoke onCreateRule hook to make plugins work.
		   */
		  ;

		  _proto.replace = function replace(name, decl, ruleOptions) {
		    var oldRule = this.get(name);
		    var oldIndex = this.index.indexOf(oldRule);

		    if (oldRule) {
		      this.remove(oldRule);
		    }

		    var options = ruleOptions;
		    if (oldIndex !== -1) options = _extends({}, ruleOptions, {
		      index: oldIndex
		    });
		    return this.add(name, decl, options);
		  }
		  /**
		   * Get a rule by name or selector.
		   */
		  ;

		  _proto.get = function get(nameOrSelector) {
		    return this.map[nameOrSelector];
		  }
		  /**
		   * Delete a rule.
		   */
		  ;

		  _proto.remove = function remove(rule) {
		    this.unregister(rule);
		    delete this.raw[rule.key];
		    this.index.splice(this.index.indexOf(rule), 1);
		  }
		  /**
		   * Get index of a rule.
		   */
		  ;

		  _proto.indexOf = function indexOf(rule) {
		    return this.index.indexOf(rule);
		  }
		  /**
		   * Run `onProcessRule()` plugins on every rule.
		   */
		  ;

		  _proto.process = function process() {
		    var plugins = this.options.jss.plugins; // We need to clone array because if we modify the index somewhere else during a loop
		    // we end up with very hard-to-track-down side effects.

		    this.index.slice(0).forEach(plugins.onProcessRule, plugins);
		  }
		  /**
		   * Register a rule in `.map`, `.classes` and `.keyframes` maps.
		   */
		  ;

		  _proto.register = function register(rule) {
		    this.map[rule.key] = rule;

		    if (rule instanceof StyleRule) {
		      this.map[rule.selector] = rule;
		      if (rule.id) this.classes[rule.key] = rule.id;
		    } else if (rule instanceof KeyframesRule && this.keyframes) {
		      this.keyframes[rule.name] = rule.id;
		    }
		  }
		  /**
		   * Unregister a rule.
		   */
		  ;

		  _proto.unregister = function unregister(rule) {
		    delete this.map[rule.key];

		    if (rule instanceof StyleRule) {
		      delete this.map[rule.selector];
		      delete this.classes[rule.key];
		    } else if (rule instanceof KeyframesRule) {
		      delete this.keyframes[rule.name];
		    }
		  }
		  /**
		   * Update the function values with a new data.
		   */
		  ;

		  _proto.update = function update() {
		    var name;
		    var data;
		    var options;

		    if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {
		      name = arguments.length <= 0 ? undefined : arguments[0];
		      data = arguments.length <= 1 ? undefined : arguments[1];
		      options = arguments.length <= 2 ? undefined : arguments[2];
		    } else {
		      data = arguments.length <= 0 ? undefined : arguments[0];
		      options = arguments.length <= 1 ? undefined : arguments[1];
		      name = null;
		    }

		    if (name) {
		      this.updateOne(this.get(name), data, options);
		    } else {
		      for (var index = 0; index < this.index.length; index++) {
		        this.updateOne(this.index[index], data, options);
		      }
		    }
		  }
		  /**
		   * Execute plugins, update rule props.
		   */
		  ;

		  _proto.updateOne = function updateOne(rule, data, options) {
		    if (options === void 0) {
		      options = defaultUpdateOptions;
		    }

		    var _this$options2 = this.options,
		        plugins = _this$options2.jss.plugins,
		        sheet = _this$options2.sheet; // It is a rules container like for e.g. ConditionalRule.

		    if (rule.rules instanceof RuleList) {
		      rule.rules.update(data, options);
		      return;
		    }

		    var style = rule.style;
		    plugins.onUpdate(data, rule, sheet, options); // We rely on a new `style` ref in case it was mutated during onUpdate hook.

		    if (options.process && style && style !== rule.style) {
		      // We need to run the plugins in case new `style` relies on syntax plugins.
		      plugins.onProcessStyle(rule.style, rule, sheet); // Update and add props.

		      for (var prop in rule.style) {
		        var nextValue = rule.style[prop];
		        var prevValue = style[prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
		        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.

		        if (nextValue !== prevValue) {
		          rule.prop(prop, nextValue, forceUpdateOptions);
		        }
		      } // Remove props.


		      for (var _prop in style) {
		        var _nextValue = rule.style[_prop];
		        var _prevValue = style[_prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
		        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.

		        if (_nextValue == null && _nextValue !== _prevValue) {
		          rule.prop(_prop, null, forceUpdateOptions);
		        }
		      }
		    }
		  }
		  /**
		   * Convert rules to a CSS string.
		   */
		  ;

		  _proto.toString = function toString(options) {
		    var str = '';
		    var sheet = this.options.sheet;
		    var link = sheet ? sheet.options.link : false;

		    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
		        linebreak = _getWhitespaceSymbols.linebreak;

		    for (var index = 0; index < this.index.length; index++) {
		      var rule = this.index[index];
		      var css = rule.toString(options); // No need to render an empty rule.

		      if (!css && !link) continue;
		      if (str) str += linebreak;
		      str += css;
		    }

		    return str;
		  };

		  return RuleList;
		}();

		var StyleSheet =
		/*#__PURE__*/
		function () {
		  function StyleSheet(styles, options) {
		    this.attached = false;
		    this.deployed = false;
		    this.classes = {};
		    this.keyframes = {};
		    this.options = _extends({}, options, {
		      sheet: this,
		      parent: this,
		      classes: this.classes,
		      keyframes: this.keyframes
		    });

		    if (options.Renderer) {
		      this.renderer = new options.Renderer(this);
		    }

		    this.rules = new RuleList(this.options);

		    for (var name in styles) {
		      this.rules.add(name, styles[name]);
		    }

		    this.rules.process();
		  }
		  /**
		   * Attach renderable to the render tree.
		   */


		  var _proto = StyleSheet.prototype;

		  _proto.attach = function attach() {
		    if (this.attached) return this;
		    if (this.renderer) this.renderer.attach();
		    this.attached = true; // Order is important, because we can't use insertRule API if style element is not attached.

		    if (!this.deployed) this.deploy();
		    return this;
		  }
		  /**
		   * Remove renderable from render tree.
		   */
		  ;

		  _proto.detach = function detach() {
		    if (!this.attached) return this;
		    if (this.renderer) this.renderer.detach();
		    this.attached = false;
		    return this;
		  }
		  /**
		   * Add a rule to the current stylesheet.
		   * Will insert a rule also after the stylesheet has been rendered first time.
		   */
		  ;

		  _proto.addRule = function addRule(name, decl, options) {
		    var queue = this.queue; // Plugins can create rules.
		    // In order to preserve the right order, we need to queue all `.addRule` calls,
		    // which happen after the first `rules.add()` call.

		    if (this.attached && !queue) this.queue = [];
		    var rule = this.rules.add(name, decl, options);
		    if (!rule) return null;
		    this.options.jss.plugins.onProcessRule(rule);

		    if (this.attached) {
		      if (!this.deployed) return rule; // Don't insert rule directly if there is no stringified version yet.
		      // It will be inserted all together when .attach is called.

		      if (queue) queue.push(rule);else {
		        this.insertRule(rule);

		        if (this.queue) {
		          this.queue.forEach(this.insertRule, this);
		          this.queue = undefined;
		        }
		      }
		      return rule;
		    } // We can't add rules to a detached style node.
		    // We will redeploy the sheet once user will attach it.


		    this.deployed = false;
		    return rule;
		  }
		  /**
		   * Replace a rule in the current stylesheet.
		   */
		  ;

		  _proto.replaceRule = function replaceRule(nameOrSelector, decl, options) {
		    var oldRule = this.rules.get(nameOrSelector);
		    if (!oldRule) return this.addRule(nameOrSelector, decl, options);
		    var newRule = this.rules.replace(nameOrSelector, decl, options);

		    if (newRule) {
		      this.options.jss.plugins.onProcessRule(newRule);
		    }

		    if (this.attached) {
		      if (!this.deployed) return newRule; // Don't replace / delete rule directly if there is no stringified version yet.
		      // It will be inserted all together when .attach is called.

		      if (this.renderer) {
		        if (!newRule) {
		          this.renderer.deleteRule(oldRule);
		        } else if (oldRule.renderable) {
		          this.renderer.replaceRule(oldRule.renderable, newRule);
		        }
		      }

		      return newRule;
		    } // We can't replace rules to a detached style node.
		    // We will redeploy the sheet once user will attach it.


		    this.deployed = false;
		    return newRule;
		  }
		  /**
		   * Insert rule into the StyleSheet
		   */
		  ;

		  _proto.insertRule = function insertRule(rule) {
		    if (this.renderer) {
		      this.renderer.insertRule(rule);
		    }
		  }
		  /**
		   * Create and add rules.
		   * Will render also after Style Sheet was rendered the first time.
		   */
		  ;

		  _proto.addRules = function addRules(styles, options) {
		    var added = [];

		    for (var name in styles) {
		      var rule = this.addRule(name, styles[name], options);
		      if (rule) added.push(rule);
		    }

		    return added;
		  }
		  /**
		   * Get a rule by name or selector.
		   */
		  ;

		  _proto.getRule = function getRule(nameOrSelector) {
		    return this.rules.get(nameOrSelector);
		  }
		  /**
		   * Delete a rule by name.
		   * Returns `true`: if rule has been deleted from the DOM.
		   */
		  ;

		  _proto.deleteRule = function deleteRule(name) {
		    var rule = typeof name === 'object' ? name : this.rules.get(name);

		    if (!rule || // Style sheet was created without link: true and attached, in this case we
		    // won't be able to remove the CSS rule from the DOM.
		    this.attached && !rule.renderable) {
		      return false;
		    }

		    this.rules.remove(rule);

		    if (this.attached && rule.renderable && this.renderer) {
		      return this.renderer.deleteRule(rule.renderable);
		    }

		    return true;
		  }
		  /**
		   * Get index of a rule.
		   */
		  ;

		  _proto.indexOf = function indexOf(rule) {
		    return this.rules.indexOf(rule);
		  }
		  /**
		   * Deploy pure CSS string to a renderable.
		   */
		  ;

		  _proto.deploy = function deploy() {
		    if (this.renderer) this.renderer.deploy();
		    this.deployed = true;
		    return this;
		  }
		  /**
		   * Update the function values with a new data.
		   */
		  ;

		  _proto.update = function update() {
		    var _this$rules;

		    (_this$rules = this.rules).update.apply(_this$rules, arguments);

		    return this;
		  }
		  /**
		   * Updates a single rule.
		   */
		  ;

		  _proto.updateOne = function updateOne(rule, data, options) {
		    this.rules.updateOne(rule, data, options);
		    return this;
		  }
		  /**
		   * Convert rules to a CSS string.
		   */
		  ;

		  _proto.toString = function toString(options) {
		    return this.rules.toString(options);
		  };

		  return StyleSheet;
		}();

		var PluginsRegistry =
		/*#__PURE__*/
		function () {
		  function PluginsRegistry() {
		    this.plugins = {
		      internal: [],
		      external: []
		    };
		    this.registry = {};
		  }

		  var _proto = PluginsRegistry.prototype;

		  /**
		   * Call `onCreateRule` hooks and return an object if returned by a hook.
		   */
		  _proto.onCreateRule = function onCreateRule(name, decl, options) {
		    for (var i = 0; i < this.registry.onCreateRule.length; i++) {
		      var rule = this.registry.onCreateRule[i](name, decl, options);
		      if (rule) return rule;
		    }

		    return null;
		  }
		  /**
		   * Call `onProcessRule` hooks.
		   */
		  ;

		  _proto.onProcessRule = function onProcessRule(rule) {
		    if (rule.isProcessed) return;
		    var sheet = rule.options.sheet;

		    for (var i = 0; i < this.registry.onProcessRule.length; i++) {
		      this.registry.onProcessRule[i](rule, sheet);
		    }

		    if (rule.style) this.onProcessStyle(rule.style, rule, sheet);
		    rule.isProcessed = true;
		  }
		  /**
		   * Call `onProcessStyle` hooks.
		   */
		  ;

		  _proto.onProcessStyle = function onProcessStyle(style, rule, sheet) {
		    for (var i = 0; i < this.registry.onProcessStyle.length; i++) {
		      rule.style = this.registry.onProcessStyle[i](rule.style, rule, sheet);
		    }
		  }
		  /**
		   * Call `onProcessSheet` hooks.
		   */
		  ;

		  _proto.onProcessSheet = function onProcessSheet(sheet) {
		    for (var i = 0; i < this.registry.onProcessSheet.length; i++) {
		      this.registry.onProcessSheet[i](sheet);
		    }
		  }
		  /**
		   * Call `onUpdate` hooks.
		   */
		  ;

		  _proto.onUpdate = function onUpdate(data, rule, sheet, options) {
		    for (var i = 0; i < this.registry.onUpdate.length; i++) {
		      this.registry.onUpdate[i](data, rule, sheet, options);
		    }
		  }
		  /**
		   * Call `onChangeValue` hooks.
		   */
		  ;

		  _proto.onChangeValue = function onChangeValue(value, prop, rule) {
		    var processedValue = value;

		    for (var i = 0; i < this.registry.onChangeValue.length; i++) {
		      processedValue = this.registry.onChangeValue[i](processedValue, prop, rule);
		    }

		    return processedValue;
		  }
		  /**
		   * Register a plugin.
		   */
		  ;

		  _proto.use = function use(newPlugin, options) {
		    if (options === void 0) {
		      options = {
		        queue: 'external'
		      };
		    }

		    var plugins = this.plugins[options.queue]; // Avoids applying same plugin twice, at least based on ref.

		    if (plugins.indexOf(newPlugin) !== -1) {
		      return;
		    }

		    plugins.push(newPlugin);
		    this.registry = [].concat(this.plugins.external, this.plugins.internal).reduce(function (registry, plugin) {
		      for (var name in plugin) {
		        if (name in registry) {
		          registry[name].push(plugin[name]);
		        }
		      }

		      return registry;
		    }, {
		      onCreateRule: [],
		      onProcessRule: [],
		      onProcessStyle: [],
		      onProcessSheet: [],
		      onChangeValue: [],
		      onUpdate: []
		    });
		  };

		  return PluginsRegistry;
		}();

		/**
		 * Sheets registry to access all instances in one place.
		 */

		var SheetsRegistry =
		/*#__PURE__*/
		function () {
		  function SheetsRegistry() {
		    this.registry = [];
		  }

		  var _proto = SheetsRegistry.prototype;

		  /**
		   * Register a Style Sheet.
		   */
		  _proto.add = function add(sheet) {
		    var registry = this.registry;
		    var index = sheet.options.index;
		    if (registry.indexOf(sheet) !== -1) return;

		    if (registry.length === 0 || index >= this.index) {
		      registry.push(sheet);
		      return;
		    } // Find a position.


		    for (var i = 0; i < registry.length; i++) {
		      if (registry[i].options.index > index) {
		        registry.splice(i, 0, sheet);
		        return;
		      }
		    }
		  }
		  /**
		   * Reset the registry.
		   */
		  ;

		  _proto.reset = function reset() {
		    this.registry = [];
		  }
		  /**
		   * Remove a Style Sheet.
		   */
		  ;

		  _proto.remove = function remove(sheet) {
		    var index = this.registry.indexOf(sheet);
		    this.registry.splice(index, 1);
		  }
		  /**
		   * Convert all attached sheets to a CSS string.
		   */
		  ;

		  _proto.toString = function toString(_temp) {
		    var _ref = _temp === void 0 ? {} : _temp,
		        attached = _ref.attached,
		        options = _objectWithoutPropertiesLoose(_ref, ["attached"]);

		    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
		        linebreak = _getWhitespaceSymbols.linebreak;

		    var css = '';

		    for (var i = 0; i < this.registry.length; i++) {
		      var sheet = this.registry[i];

		      if (attached != null && sheet.attached !== attached) {
		        continue;
		      }

		      if (css) css += linebreak;
		      css += sheet.toString(options);
		    }

		    return css;
		  };

		  _createClass(SheetsRegistry, [{
		    key: "index",

		    /**
		     * Current highest index number.
		     */
		    get: function get() {
		      return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;
		    }
		  }]);

		  return SheetsRegistry;
		}();

		/**
		 * This is a global sheets registry. Only DomRenderer will add sheets to it.
		 * On the server one should use an own SheetsRegistry instance and add the
		 * sheets to it, because you need to make sure to create a new registry for
		 * each request in order to not leak sheets across requests.
		 */

		var sheets = new SheetsRegistry();

		/* eslint-disable */

		/**
		 * Now that `globalThis` is available on most platforms
		 * (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis#browser_compatibility)
		 * we check for `globalThis` first. `globalThis` is necessary for jss
		 * to run in Agoric's secure version of JavaScript (SES). Under SES,
		 * `globalThis` exists, but `window`, `self`, and `Function('return
		 * this')()` are all undefined for security reasons.
		 *
		 * https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
		 */
		var globalThis$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' && window.Math === Math ? window : typeof self !== 'undefined' && self.Math === Math ? self : Function('return this')();

		var ns = '2f1acc6c3a606b082e5eef5e54414ffb';
		if (globalThis$1[ns] == null) globalThis$1[ns] = 0; // Bundle may contain multiple JSS versions at the same time. In order to identify
		// the current version with just one short number and use it for classes generation
		// we use a counter. Also it is more accurate, because user can manually reevaluate
		// the module.

		var moduleId = globalThis$1[ns]++;
		/**
		 * Returns a function which generates unique class names based on counters.
		 * When new generator function is created, rule counter is reseted.
		 * We need to reset the rule counter for SSR for each request.
		 */

		var createGenerateId = function createGenerateId(options) {
		  if (options === void 0) {
		    options = {};
		  }

		  var ruleCounter = 0;

		  var generateId = function generateId(rule, sheet) {
		    ruleCounter += 1;

		    var jssId = '';
		    var prefix = '';

		    if (sheet) {
		      if (sheet.options.classNamePrefix) {
		        prefix = sheet.options.classNamePrefix;
		      }

		      if (sheet.options.jss.id != null) {
		        jssId = String(sheet.options.jss.id);
		      }
		    }

		    if (options.minify) {
		      // Using "c" because a number can't be the first char in a class name.
		      return "" + (prefix || 'c') + moduleId + jssId + ruleCounter;
		    }

		    return prefix + rule.key + "-" + moduleId + (jssId ? "-" + jssId : '') + "-" + ruleCounter;
		  };

		  return generateId;
		};

		/**
		 * Cache the value from the first time a function is called.
		 */

		var memoize = function memoize(fn) {
		  var value;
		  return function () {
		    if (!value) value = fn();
		    return value;
		  };
		};
		/**
		 * Get a style property value.
		 */


		var getPropertyValue = function getPropertyValue(cssRule, prop) {
		  try {
		    // Support CSSTOM.
		    if (cssRule.attributeStyleMap) {
		      return cssRule.attributeStyleMap.get(prop);
		    }

		    return cssRule.style.getPropertyValue(prop);
		  } catch (err) {
		    // IE may throw if property is unknown.
		    return '';
		  }
		};
		/**
		 * Set a style property.
		 */


		var setProperty = function setProperty(cssRule, prop, value) {
		  try {
		    var cssValue = value;

		    if (Array.isArray(value)) {
		      cssValue = toCssValue(value);
		    } // Support CSSTOM.


		    if (cssRule.attributeStyleMap) {
		      cssRule.attributeStyleMap.set(prop, cssValue);
		    } else {
		      var indexOfImportantFlag = cssValue ? cssValue.indexOf('!important') : -1;
		      var cssValueWithoutImportantFlag = indexOfImportantFlag > -1 ? cssValue.substr(0, indexOfImportantFlag - 1) : cssValue;
		      cssRule.style.setProperty(prop, cssValueWithoutImportantFlag, indexOfImportantFlag > -1 ? 'important' : '');
		    }
		  } catch (err) {
		    // IE may throw if property is unknown.
		    return false;
		  }

		  return true;
		};
		/**
		 * Remove a style property.
		 */


		var removeProperty = function removeProperty(cssRule, prop) {
		  try {
		    // Support CSSTOM.
		    if (cssRule.attributeStyleMap) {
		      cssRule.attributeStyleMap.delete(prop);
		    } else {
		      cssRule.style.removeProperty(prop);
		    }
		  } catch (err) {
		  }
		};
		/**
		 * Set the selector.
		 */


		var setSelector = function setSelector(cssRule, selectorText) {
		  cssRule.selectorText = selectorText; // Return false if setter was not successful.
		  // Currently works in chrome only.

		  return cssRule.selectorText === selectorText;
		};
		/**
		 * Gets the `head` element upon the first call and caches it.
		 * We assume it can't be null.
		 */


		var getHead = memoize(function () {
		  return document.querySelector('head');
		});
		/**
		 * Find attached sheet with an index higher than the passed one.
		 */

		function findHigherSheet(registry, options) {
		  for (var i = 0; i < registry.length; i++) {
		    var sheet = registry[i];

		    if (sheet.attached && sheet.options.index > options.index && sheet.options.insertionPoint === options.insertionPoint) {
		      return sheet;
		    }
		  }

		  return null;
		}
		/**
		 * Find attached sheet with the highest index.
		 */


		function findHighestSheet(registry, options) {
		  for (var i = registry.length - 1; i >= 0; i--) {
		    var sheet = registry[i];

		    if (sheet.attached && sheet.options.insertionPoint === options.insertionPoint) {
		      return sheet;
		    }
		  }

		  return null;
		}
		/**
		 * Find a comment with "jss" inside.
		 */


		function findCommentNode(text) {
		  var head = getHead();

		  for (var i = 0; i < head.childNodes.length; i++) {
		    var node = head.childNodes[i];

		    if (node.nodeType === 8 && node.nodeValue.trim() === text) {
		      return node;
		    }
		  }

		  return null;
		}
		/**
		 * Find a node before which we can insert the sheet.
		 */


		function findPrevNode(options) {
		  var registry = sheets.registry;

		  if (registry.length > 0) {
		    // Try to insert before the next higher sheet.
		    var sheet = findHigherSheet(registry, options);

		    if (sheet && sheet.renderer) {
		      return {
		        parent: sheet.renderer.element.parentNode,
		        node: sheet.renderer.element
		      };
		    } // Otherwise insert after the last attached.


		    sheet = findHighestSheet(registry, options);

		    if (sheet && sheet.renderer) {
		      return {
		        parent: sheet.renderer.element.parentNode,
		        node: sheet.renderer.element.nextSibling
		      };
		    }
		  } // Try to find a comment placeholder if registry is empty.


		  var insertionPoint = options.insertionPoint;

		  if (insertionPoint && typeof insertionPoint === 'string') {
		    var comment = findCommentNode(insertionPoint);

		    if (comment) {
		      return {
		        parent: comment.parentNode,
		        node: comment.nextSibling
		      };
		    } // If user specifies an insertion point and it can't be found in the document -
		  }

		  return false;
		}
		/**
		 * Insert style element into the DOM.
		 */


		function insertStyle(style, options) {
		  var insertionPoint = options.insertionPoint;
		  var nextNode = findPrevNode(options);

		  if (nextNode !== false && nextNode.parent) {
		    nextNode.parent.insertBefore(style, nextNode.node);
		    return;
		  } // Works with iframes and any node types.


		  if (insertionPoint && typeof insertionPoint.nodeType === 'number') {
		    var insertionPointElement = insertionPoint;
		    var parentNode = insertionPointElement.parentNode;
		    if (parentNode) parentNode.insertBefore(style, insertionPointElement.nextSibling);
		    return;
		  }

		  getHead().appendChild(style);
		}
		/**
		 * Read jss nonce setting from the page if the user has set it.
		 */


		var getNonce = memoize(function () {
		  var node = document.querySelector('meta[property="csp-nonce"]');
		  return node ? node.getAttribute('content') : null;
		});

		var _insertRule = function insertRule(container, rule, index) {
		  try {
		    if ('insertRule' in container) {
		      container.insertRule(rule, index);
		    } // Keyframes rule.
		    else if ('appendRule' in container) {
		        container.appendRule(rule);
		      }
		  } catch (err) {
		    return false;
		  }

		  return container.cssRules[index];
		};

		var getValidRuleInsertionIndex = function getValidRuleInsertionIndex(container, index) {
		  var maxIndex = container.cssRules.length; // In case previous insertion fails, passed index might be wrong

		  if (index === undefined || index > maxIndex) {
		    // eslint-disable-next-line no-param-reassign
		    return maxIndex;
		  }

		  return index;
		};

		var createStyle = function createStyle() {
		  var el = document.createElement('style'); // Without it, IE will have a broken source order specificity if we
		  // insert rules after we insert the style tag.
		  // It seems to kick-off the source order specificity algorithm.

		  el.textContent = '\n';
		  return el;
		};

		var DomRenderer =
		/*#__PURE__*/
		function () {
		  // Will be empty if link: true option is not set, because
		  // it is only for use together with insertRule API.
		  function DomRenderer(sheet) {
		    this.getPropertyValue = getPropertyValue;
		    this.setProperty = setProperty;
		    this.removeProperty = removeProperty;
		    this.setSelector = setSelector;
		    this.hasInsertedRules = false;
		    this.cssRules = [];
		    // There is no sheet when the renderer is used from a standalone StyleRule.
		    if (sheet) sheets.add(sheet);
		    this.sheet = sheet;

		    var _ref = this.sheet ? this.sheet.options : {},
		        media = _ref.media,
		        meta = _ref.meta,
		        element = _ref.element;

		    this.element = element || createStyle();
		    this.element.setAttribute('data-jss', '');
		    if (media) this.element.setAttribute('media', media);
		    if (meta) this.element.setAttribute('data-meta', meta);
		    var nonce = getNonce();
		    if (nonce) this.element.setAttribute('nonce', nonce);
		  }
		  /**
		   * Insert style element into render tree.
		   */


		  var _proto = DomRenderer.prototype;

		  _proto.attach = function attach() {
		    // In the case the element node is external and it is already in the DOM.
		    if (this.element.parentNode || !this.sheet) return;
		    insertStyle(this.element, this.sheet.options); // When rules are inserted using `insertRule` API, after `sheet.detach().attach()`
		    // most browsers create a new CSSStyleSheet, except of all IEs.

		    var deployed = Boolean(this.sheet && this.sheet.deployed);

		    if (this.hasInsertedRules && deployed) {
		      this.hasInsertedRules = false;
		      this.deploy();
		    }
		  }
		  /**
		   * Remove style element from render tree.
		   */
		  ;

		  _proto.detach = function detach() {
		    if (!this.sheet) return;
		    var parentNode = this.element.parentNode;
		    if (parentNode) parentNode.removeChild(this.element); // In the most browsers, rules inserted using insertRule() API will be lost when style element is removed.
		    // Though IE will keep them and we need a consistent behavior.

		    if (this.sheet.options.link) {
		      this.cssRules = [];
		      this.element.textContent = '\n';
		    }
		  }
		  /**
		   * Inject CSS string into element.
		   */
		  ;

		  _proto.deploy = function deploy() {
		    var sheet = this.sheet;
		    if (!sheet) return;

		    if (sheet.options.link) {
		      this.insertRules(sheet.rules);
		      return;
		    }

		    this.element.textContent = "\n" + sheet.toString() + "\n";
		  }
		  /**
		   * Insert RuleList into an element.
		   */
		  ;

		  _proto.insertRules = function insertRules(rules, nativeParent) {
		    for (var i = 0; i < rules.index.length; i++) {
		      this.insertRule(rules.index[i], i, nativeParent);
		    }
		  }
		  /**
		   * Insert a rule into element.
		   */
		  ;

		  _proto.insertRule = function insertRule(rule, index, nativeParent) {
		    if (nativeParent === void 0) {
		      nativeParent = this.element.sheet;
		    }

		    if (rule.rules) {
		      var parent = rule;
		      var latestNativeParent = nativeParent;

		      if (rule.type === 'conditional' || rule.type === 'keyframes') {
		        var _insertionIndex = getValidRuleInsertionIndex(nativeParent, index); // We need to render the container without children first.


		        latestNativeParent = _insertRule(nativeParent, parent.toString({
		          children: false
		        }), _insertionIndex);

		        if (latestNativeParent === false) {
		          return false;
		        }

		        this.refCssRule(rule, _insertionIndex, latestNativeParent);
		      }

		      this.insertRules(parent.rules, latestNativeParent);
		      return latestNativeParent;
		    }

		    var ruleStr = rule.toString();
		    if (!ruleStr) return false;
		    var insertionIndex = getValidRuleInsertionIndex(nativeParent, index);

		    var nativeRule = _insertRule(nativeParent, ruleStr, insertionIndex);

		    if (nativeRule === false) {
		      return false;
		    }

		    this.hasInsertedRules = true;
		    this.refCssRule(rule, insertionIndex, nativeRule);
		    return nativeRule;
		  };

		  _proto.refCssRule = function refCssRule(rule, index, cssRule) {
		    rule.renderable = cssRule; // We only want to reference the top level rules, deleteRule API doesn't support removing nested rules
		    // like rules inside media queries or keyframes

		    if (rule.options.parent instanceof StyleSheet) {
		      this.cssRules.splice(index, 0, cssRule);
		    }
		  }
		  /**
		   * Delete a rule.
		   */
		  ;

		  _proto.deleteRule = function deleteRule(cssRule) {
		    var sheet = this.element.sheet;
		    var index = this.indexOf(cssRule);
		    if (index === -1) return false;
		    sheet.deleteRule(index);
		    this.cssRules.splice(index, 1);
		    return true;
		  }
		  /**
		   * Get index of a CSS Rule.
		   */
		  ;

		  _proto.indexOf = function indexOf(cssRule) {
		    return this.cssRules.indexOf(cssRule);
		  }
		  /**
		   * Generate a new CSS rule and replace the existing one.
		   */
		  ;

		  _proto.replaceRule = function replaceRule(cssRule, rule) {
		    var index = this.indexOf(cssRule);
		    if (index === -1) return false;
		    this.element.sheet.deleteRule(index);
		    this.cssRules.splice(index, 1);
		    return this.insertRule(rule, index);
		  }
		  /**
		   * Get all rules elements.
		   */
		  ;

		  _proto.getRules = function getRules() {
		    return this.element.sheet.cssRules;
		  };

		  return DomRenderer;
		}();

		var instanceCounter = 0;

		var Jss =
		/*#__PURE__*/
		function () {
		  function Jss(options) {
		    this.id = instanceCounter++;
		    this.version = "10.10.0";
		    this.plugins = new PluginsRegistry();
		    this.options = {
		      id: {
		        minify: false
		      },
		      createGenerateId: createGenerateId,
		      Renderer: isBrowser ? DomRenderer : null,
		      plugins: []
		    };
		    this.generateId = createGenerateId({
		      minify: false
		    });

		    for (var i = 0; i < plugins.length; i++) {
		      this.plugins.use(plugins[i], {
		        queue: 'internal'
		      });
		    }

		    this.setup(options);
		  }
		  /**
		   * Prepares various options, applies plugins.
		   * Should not be used twice on the same instance, because there is no plugins
		   * deduplication logic.
		   */


		  var _proto = Jss.prototype;

		  _proto.setup = function setup(options) {
		    if (options === void 0) {
		      options = {};
		    }

		    if (options.createGenerateId) {
		      this.options.createGenerateId = options.createGenerateId;
		    }

		    if (options.id) {
		      this.options.id = _extends({}, this.options.id, options.id);
		    }

		    if (options.createGenerateId || options.id) {
		      this.generateId = this.options.createGenerateId(this.options.id);
		    }

		    if (options.insertionPoint != null) this.options.insertionPoint = options.insertionPoint;

		    if ('Renderer' in options) {
		      this.options.Renderer = options.Renderer;
		    } // eslint-disable-next-line prefer-spread


		    if (options.plugins) this.use.apply(this, options.plugins);
		    return this;
		  }
		  /**
		   * Create a Style Sheet.
		   */
		  ;

		  _proto.createStyleSheet = function createStyleSheet(styles, options) {
		    if (options === void 0) {
		      options = {};
		    }

		    var _options = options,
		        index = _options.index;

		    if (typeof index !== 'number') {
		      index = sheets.index === 0 ? 0 : sheets.index + 1;
		    }

		    var sheet = new StyleSheet(styles, _extends({}, options, {
		      jss: this,
		      generateId: options.generateId || this.generateId,
		      insertionPoint: this.options.insertionPoint,
		      Renderer: this.options.Renderer,
		      index: index
		    }));
		    this.plugins.onProcessSheet(sheet);
		    return sheet;
		  }
		  /**
		   * Detach the Style Sheet and remove it from the registry.
		   */
		  ;

		  _proto.removeStyleSheet = function removeStyleSheet(sheet) {
		    sheet.detach();
		    sheets.remove(sheet);
		    return this;
		  }
		  /**
		   * Create a rule without a Style Sheet.
		   * [Deprecated] will be removed in the next major version.
		   */
		  ;

		  _proto.createRule = function createRule$1(name, style, options) {
		    if (style === void 0) {
		      style = {};
		    }

		    if (options === void 0) {
		      options = {};
		    }

		    // Enable rule without name for inline styles.
		    if (typeof name === 'object') {
		      return this.createRule(undefined, name, style);
		    }

		    var ruleOptions = _extends({}, options, {
		      name: name,
		      jss: this,
		      Renderer: this.options.Renderer
		    });

		    if (!ruleOptions.generateId) ruleOptions.generateId = this.generateId;
		    if (!ruleOptions.classes) ruleOptions.classes = {};
		    if (!ruleOptions.keyframes) ruleOptions.keyframes = {};

		    var rule = createRule(name, style, ruleOptions);

		    if (rule) this.plugins.onProcessRule(rule);
		    return rule;
		  }
		  /**
		   * Register plugin. Passed function will be invoked with a rule instance.
		   */
		  ;

		  _proto.use = function use() {
		    var _this = this;

		    for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
		      plugins[_key] = arguments[_key];
		    }

		    plugins.forEach(function (plugin) {
		      _this.plugins.use(plugin);
		    });
		    return this;
		  };

		  return Jss;
		}();

		var createJss = function createJss(options) {
		  return new Jss(options);
		};

		/**
		 * SheetsManager is like a WeakMap which is designed to count StyleSheet
		 * instances and attach/detach automatically.
		 * Used in react-jss.
		 */

		var SheetsManager =
		/*#__PURE__*/
		function () {
		  function SheetsManager() {
		    this.length = 0;
		    this.sheets = new WeakMap();
		  }

		  var _proto = SheetsManager.prototype;

		  _proto.get = function get(key) {
		    var entry = this.sheets.get(key);
		    return entry && entry.sheet;
		  };

		  _proto.add = function add(key, sheet) {
		    if (this.sheets.has(key)) return;
		    this.length++;
		    this.sheets.set(key, {
		      sheet: sheet,
		      refs: 0
		    });
		  };

		  _proto.manage = function manage(key) {
		    var entry = this.sheets.get(key);

		    if (entry) {
		      if (entry.refs === 0) {
		        entry.sheet.attach();
		      }

		      entry.refs++;
		      return entry.sheet;
		    }
		    return undefined;
		  };

		  _proto.unmanage = function unmanage(key) {
		    var entry = this.sheets.get(key);

		    if (entry) {
		      if (entry.refs > 0) {
		        entry.refs--;
		        if (entry.refs === 0) entry.sheet.detach();
		      }
		    }
		  };

		  _createClass(SheetsManager, [{
		    key: "size",
		    get: function get() {
		      return this.length;
		    }
		  }]);

		  return SheetsManager;
		}();

		/**
		* Export a constant indicating if this browser has CSSTOM support.
		* https://developers.google.com/web/updates/2018/03/cssom
		*/
		var hasCSSTOMSupport = typeof CSS === 'object' && CSS != null && 'number' in CSS;

		/**
		 * Extracts a styles object with only props that contain function values.
		 */
		function getDynamicStyles(styles) {
		  var to = null;

		  for (var key in styles) {
		    var value = styles[key];
		    var type = typeof value;

		    if (type === 'function') {
		      if (!to) to = {};
		      to[key] = value;
		    } else if (type === 'object' && value !== null && !Array.isArray(value)) {
		      var extracted = getDynamicStyles(value);

		      if (extracted) {
		        if (!to) to = {};
		        to[key] = extracted;
		      }
		    }
		  }

		  return to;
		}

		/**
		 * A better abstraction over CSS.
		 *
		 * @copyright Oleg Isonen (Slobodskoi) / Isonen 2014-present
		 * @website https://github.com/cssinjs/jss
		 * @license MIT
		 */
		var index = createJss();

		const jss_esm = /*#__PURE__*/Object.freeze({
		  __proto__: null,
		  'default': index,
		  RuleList: RuleList,
		  SheetsManager: SheetsManager,
		  SheetsRegistry: SheetsRegistry,
		  create: createJss,
		  createGenerateId: createGenerateId,
		  createRule: createRule,
		  getDynamicStyles: getDynamicStyles,
		  hasCSSTOMSupport: hasCSSTOMSupport,
		  sheets: sheets,
		  toCssValue: toCssValue
		});

		var at = '@global';
		var atPrefix = '@global ';

		var GlobalContainerRule =
		/*#__PURE__*/
		function () {
		  function GlobalContainerRule(key, styles, options) {
		    this.type = 'global';
		    this.at = at;
		    this.isProcessed = false;
		    this.key = key;
		    this.options = options;
		    this.rules = new RuleList(_extends({}, options, {
		      parent: this
		    }));

		    for (var selector in styles) {
		      this.rules.add(selector, styles[selector]);
		    }

		    this.rules.process();
		  }
		  /**
		   * Get a rule.
		   */


		  var _proto = GlobalContainerRule.prototype;

		  _proto.getRule = function getRule(name) {
		    return this.rules.get(name);
		  }
		  /**
		   * Create and register rule, run plugins.
		   */
		  ;

		  _proto.addRule = function addRule(name, style, options) {
		    var rule = this.rules.add(name, style, options);
		    if (rule) this.options.jss.plugins.onProcessRule(rule);
		    return rule;
		  }
		  /**
		   * Replace rule, run plugins.
		   */
		  ;

		  _proto.replaceRule = function replaceRule(name, style, options) {
		    var newRule = this.rules.replace(name, style, options);
		    if (newRule) this.options.jss.plugins.onProcessRule(newRule);
		    return newRule;
		  }
		  /**
		   * Get index of a rule.
		   */
		  ;

		  _proto.indexOf = function indexOf(rule) {
		    return this.rules.indexOf(rule);
		  }
		  /**
		   * Generates a CSS string.
		   */
		  ;

		  _proto.toString = function toString(options) {
		    return this.rules.toString(options);
		  };

		  return GlobalContainerRule;
		}();

		var GlobalPrefixedRule =
		/*#__PURE__*/
		function () {
		  function GlobalPrefixedRule(key, style, options) {
		    this.type = 'global';
		    this.at = at;
		    this.isProcessed = false;
		    this.key = key;
		    this.options = options;
		    var selector = key.substr(atPrefix.length);
		    this.rule = options.jss.createRule(selector, style, _extends({}, options, {
		      parent: this
		    }));
		  }

		  var _proto2 = GlobalPrefixedRule.prototype;

		  _proto2.toString = function toString(options) {
		    return this.rule ? this.rule.toString(options) : '';
		  };

		  return GlobalPrefixedRule;
		}();

		var separatorRegExp$1 = /\s*,\s*/g;

		function addScope(selector, scope) {
		  var parts = selector.split(separatorRegExp$1);
		  var scoped = '';

		  for (var i = 0; i < parts.length; i++) {
		    scoped += scope + " " + parts[i].trim();
		    if (parts[i + 1]) scoped += ', ';
		  }

		  return scoped;
		}

		function handleNestedGlobalContainerRule(rule, sheet) {
		  var options = rule.options,
		      style = rule.style;
		  var rules = style ? style[at] : null;
		  if (!rules) return;

		  for (var name in rules) {
		    sheet.addRule(name, rules[name], _extends({}, options, {
		      selector: addScope(name, rule.selector)
		    }));
		  }

		  delete style[at];
		}

		function handlePrefixedGlobalRule(rule, sheet) {
		  var options = rule.options,
		      style = rule.style;

		  for (var prop in style) {
		    if (prop[0] !== '@' || prop.substr(0, at.length) !== at) continue;
		    var selector = addScope(prop.substr(at.length), rule.selector);
		    sheet.addRule(selector, style[prop], _extends({}, options, {
		      selector: selector
		    }));
		    delete style[prop];
		  }
		}
		/**
		 * Convert nested rules to separate, remove them from original styles.
		 */


		function jssGlobal() {
		  function onCreateRule(name, styles, options) {
		    if (!name) return null;

		    if (name === at) {
		      return new GlobalContainerRule(name, styles, options);
		    }

		    if (name[0] === '@' && name.substr(0, atPrefix.length) === atPrefix) {
		      return new GlobalPrefixedRule(name, styles, options);
		    }

		    var parent = options.parent;

		    if (parent) {
		      if (parent.type === 'global' || parent.options.parent && parent.options.parent.type === 'global') {
		        options.scoped = false;
		      }
		    }

		    if (!options.selector && options.scoped === false) {
		      options.selector = name;
		    }

		    return null;
		  }

		  function onProcessRule(rule, sheet) {
		    if (rule.type !== 'style' || !sheet) return;
		    handleNestedGlobalContainerRule(rule, sheet);
		    handlePrefixedGlobalRule(rule, sheet);
		  }

		  return {
		    onCreateRule: onCreateRule,
		    onProcessRule: onProcessRule
		  };
		}

		var separatorRegExp = /\s*,\s*/g;
		var parentRegExp = /&/g;
		var refRegExp = /\$([\w-]+)/g;
		/**
		 * Convert nested rules to separate, remove them from original styles.
		 */

		function jssNested() {
		  // Get a function to be used for $ref replacement.
		  function getReplaceRef(container, sheet) {
		    return function (match, key) {
		      var rule = container.getRule(key) || sheet && sheet.getRule(key);

		      if (rule) {
		        return rule.selector;
		      }
		      return key;
		    };
		  }

		  function replaceParentRefs(nestedProp, parentProp) {
		    var parentSelectors = parentProp.split(separatorRegExp);
		    var nestedSelectors = nestedProp.split(separatorRegExp);
		    var result = '';

		    for (var i = 0; i < parentSelectors.length; i++) {
		      var parent = parentSelectors[i];

		      for (var j = 0; j < nestedSelectors.length; j++) {
		        var nested = nestedSelectors[j];
		        if (result) result += ', '; // Replace all & by the parent or prefix & with the parent.

		        result += nested.indexOf('&') !== -1 ? nested.replace(parentRegExp, parent) : parent + " " + nested;
		      }
		    }

		    return result;
		  }

		  function getOptions(rule, container, prevOptions) {
		    // Options has been already created, now we only increase index.
		    if (prevOptions) return _extends({}, prevOptions, {
		      index: prevOptions.index + 1
		    });
		    var nestingLevel = rule.options.nestingLevel;
		    nestingLevel = nestingLevel === undefined ? 1 : nestingLevel + 1;

		    var options = _extends({}, rule.options, {
		      nestingLevel: nestingLevel,
		      index: container.indexOf(rule) + 1 // We don't need the parent name to be set options for chlid.

		    });

		    delete options.name;
		    return options;
		  }

		  function onProcessStyle(style, rule, sheet) {
		    if (rule.type !== 'style') return style;
		    var styleRule = rule;
		    var container = styleRule.options.parent;
		    var options;
		    var replaceRef;

		    for (var prop in style) {
		      var isNested = prop.indexOf('&') !== -1;
		      var isNestedConditional = prop[0] === '@';
		      if (!isNested && !isNestedConditional) continue;
		      options = getOptions(styleRule, container, options);

		      if (isNested) {
		        var selector = replaceParentRefs(prop, styleRule.selector); // Lazily create the ref replacer function just once for
		        // all nested rules within the sheet.

		        if (!replaceRef) replaceRef = getReplaceRef(container, sheet); // Replace all $refs.

		        selector = selector.replace(refRegExp, replaceRef);
		        var name = styleRule.key + "-" + prop;

		        if ('replaceRule' in container) {
		          // for backward compatibility
		          container.replaceRule(name, style[prop], _extends({}, options, {
		            selector: selector
		          }));
		        } else {
		          container.addRule(name, style[prop], _extends({}, options, {
		            selector: selector
		          }));
		        }
		      } else if (isNestedConditional) {
		        // Place conditional right after the parent rule to ensure right ordering.
		        container.addRule(prop, {}, options).addRule(styleRule.key, style[prop], {
		          selector: styleRule.selector
		        });
		      }

		      delete style[prop];
		    }

		    return style;
		  }

		  return {
		    onProcessStyle: onProcessStyle
		  };
		}

		/* eslint-disable no-var, prefer-template */
		var uppercasePattern = /[A-Z]/g;
		var msPattern = /^ms-/;
		var cache = {};

		function toHyphenLower(match) {
		  return '-' + match.toLowerCase()
		}

		function hyphenateStyleName(name) {
		  if (cache.hasOwnProperty(name)) {
		    return cache[name]
		  }

		  var hName = name.replace(uppercasePattern, toHyphenLower);
		  return (cache[name] = msPattern.test(hName) ? '-' + hName : hName)
		}

		/**
		 * Convert camel cased property names to dash separated.
		 */

		function convertCase(style) {
		  var converted = {};

		  for (var prop in style) {
		    var key = prop.indexOf('--') === 0 ? prop : hyphenateStyleName(prop);
		    converted[key] = style[prop];
		  }

		  if (style.fallbacks) {
		    if (Array.isArray(style.fallbacks)) converted.fallbacks = style.fallbacks.map(convertCase);else converted.fallbacks = convertCase(style.fallbacks);
		  }

		  return converted;
		}
		/**
		 * Allow camel cased property names by converting them back to dasherized.
		 */


		function camelCase() {
		  function onProcessStyle(style) {
		    if (Array.isArray(style)) {
		      // Handle rules like @font-face, which can have multiple styles in an array
		      for (var index = 0; index < style.length; index++) {
		        style[index] = convertCase(style[index]);
		      }

		      return style;
		    }

		    return convertCase(style);
		  }

		  function onChangeValue(value, prop, rule) {
		    if (prop.indexOf('--') === 0) {
		      return value;
		    }

		    var hyphenatedProp = hyphenateStyleName(prop); // There was no camel case in place

		    if (prop === hyphenatedProp) return value;
		    rule.prop(hyphenatedProp, value); // Core will ignore that property value we set the proper one above.

		    return null;
		  }

		  return {
		    onProcessStyle: onProcessStyle,
		    onChangeValue: onChangeValue
		  };
		}

		function getAugmentedNamespace(n) {
			if (n.__esModule) return n;
			var a = Object.defineProperty({}, '__esModule', {value: true});
			Object.keys(n).forEach(function (k) {
				var d = Object.getOwnPropertyDescriptor(n, k);
				Object.defineProperty(a, k, d.get ? d : {
					enumerable: true,
					get: function () {
						return n[k];
					}
				});
			});
			return a;
		}

		var _tslib$1 = {};

		(function (exports) {

		Object.defineProperty(exports, '__esModule', { value: true });

		/*! *****************************************************************************
		Copyright (c) Microsoft Corporation.

		Permission to use, copy, modify, and/or distribute this software for any
		purpose with or without fee is hereby granted.

		THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
		REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
		AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
		INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
		LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
		OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
		PERFORMANCE OF THIS SOFTWARE.
		***************************************************************************** */

		exports.__assign = function () {
			exports.__assign =
				Object.assign ||
				function __assign(t) {
					for (var s, i = 1, n = arguments.length; i < n; i++) {
						s = arguments[i];
						for (var p in s)
							if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
					}
					return t;
				};
			return exports.__assign.apply(this, arguments);
		};
		}(_tslib$1));

		const require$$1 = /*@__PURE__*/getAugmentedNamespace(jss_esm);

		/**
		 * The custom `sort` method for
		 * for the [`css-mqpacker`](https://www.npmjs.com/package/css-mqpacker) or
		 * [`pleeease`](https://www.npmjs.com/package/pleeease) which using `css-mqpacker`
		 * or, perhaps, something else ))
		 *
		 * @module sort-css-media-queries
		 * @author Oleg Dutchenko <dutchenko.o.wezom@gmail.com>
		 * @version 1.5.0
		 */

		// ----------------------------------------
		// Private
		// ----------------------------------------

		const minMaxWidth = /(!?\(\s*min(-device-)?-width)(.|\n)+\(\s*max(-device)?-width/i;
		const minWidth = /\(\s*min(-device)?-width/i;
		const maxMinWidth = /(!?\(\s*max(-device)?-width)(.|\n)+\(\s*min(-device)?-width/i;
		const maxWidth = /\(\s*max(-device)?-width/i;

		const isMinWidth = _testQuery(minMaxWidth, maxMinWidth, minWidth);
		const isMaxWidth = _testQuery(maxMinWidth, minMaxWidth, maxWidth);

		const minMaxHeight = /(!?\(\s*min(-device)?-height)(.|\n)+\(\s*max(-device)?-height/i;
		const minHeight = /\(\s*min(-device)?-height/i;
		const maxMinHeight = /(!?\(\s*max(-device)?-height)(.|\n)+\(\s*min(-device)?-height/i;
		const maxHeight = /\(\s*max(-device)?-height/i;

		const isMinHeight = _testQuery(minMaxHeight, maxMinHeight, minHeight);
		const isMaxHeight = _testQuery(maxMinHeight, minMaxHeight, maxHeight);

		const isPrint = /print/i;
		const isPrintOnly = /^print$/i;

		const maxValue = Number.MAX_VALUE;

		/**
		 * Obtain the length of the media request in pixels.
		 * Copy from original source `function inspectLength (length)`
		 * {@link https://github.com/hail2u/node-css-mqpacker/blob/master/index.js#L58}
		 * @private
		 * @param {string} length
		 * @return {number}
		 */
		function _getQueryLength (length) {
		  length = /(-?\d*\.?\d+)(ch|em|ex|px|rem)/.exec(length);

		  if (length === null) {
		    return maxValue
		  }

		  let number = length[1];
		  const unit = length[2];

		  switch (unit) {
		    case 'ch':
		      number = parseFloat(number) * 8.8984375;
		      break

		    case 'em':
		    case 'rem':
		      number = parseFloat(number) * 16;
		      break

		    case 'ex':
		      number = parseFloat(number) * 8.296875;
		      break

		    case 'px':
		      number = parseFloat(number);
		      break
		  }

		  return +number
		}

		/**
		 * Wrapper for creating test functions
		 * @private
		 * @param {RegExp} doubleTestTrue
		 * @param {RegExp} doubleTestFalse
		 * @param {RegExp} singleTest
		 * @return {Function}
		 */
		function _testQuery (doubleTestTrue, doubleTestFalse, singleTest) {
		  /**
		   * @param {string} query
		   * @return {boolean}
		   */
		  return function (query) {
		    if (doubleTestTrue.test(query)) {
		      return true
		    } else if (doubleTestFalse.test(query)) {
		      return false
		    }
		    return singleTest.test(query)
		  }
		}

		/**
		 * @private
		 * @param {string} a
		 * @param {string} b
		 * @return {number|null}
		 */
		function _testIsPrint (a, b) {
		  const isPrintA = isPrint.test(a);
		  const isPrintOnlyA = isPrintOnly.test(a);

		  const isPrintB = isPrint.test(b);
		  const isPrintOnlyB = isPrintOnly.test(b);

		  if (isPrintA && isPrintB) {
		    if (!isPrintOnlyA && isPrintOnlyB) {
		      return 1
		    }
		    if (isPrintOnlyA && !isPrintOnlyB) {
		      return -1
		    }
		    return a.localeCompare(b)
		  }
		  if (isPrintA) {
		    return 1
		  }
		  if (isPrintB) {
		    return -1
		  }

		  return null
		}

		// ----------------------------------------
		// Public
		// ----------------------------------------

		/**
		 * Sorting an array with media queries
		 * according to the mobile-first methodology.
		 * @param {string} a
		 * @param {string} b
		 * @return {number} 1 / 0 / -1
		 */
		function sortCSSmq$1 (a, b) {
		  const testIsPrint = _testIsPrint(a, b);
		  if (testIsPrint !== null) {
		    return testIsPrint
		  }

		  const minA = isMinWidth(a) || isMinHeight(a);
		  const maxA = isMaxWidth(a) || isMaxHeight(a);

		  const minB = isMinWidth(b) || isMinHeight(b);
		  const maxB = isMaxWidth(b) || isMaxHeight(b);

		  if (minA && maxB) {
		    return -1
		  }
		  if (maxA && minB) {
		    return 1
		  }

		  let lengthA = _getQueryLength(a);
		  let lengthB = _getQueryLength(b);

		  if (lengthA === maxValue && lengthB === maxValue) {
		    return a.localeCompare(b)
		  } else if (lengthA === maxValue) {
		    return 1
		  } else if (lengthB === maxValue) {
		    return -1
		  }

		  if (lengthA > lengthB) {
		    if (maxA) {
		      return -1
		    }
		    return 1
		  }

		  if (lengthA < lengthB) {
		    if (maxA) {
		      return 1
		    }
		    return -1
		  }

		  return a.localeCompare(b)
		}

		/**
		 * Sorting an array with media queries
		 * according to the desktop-first methodology.
		 * @param {string} a
		 * @param {string} b
		 * @return {number} 1 / 0 / -1
		 */
		sortCSSmq$1.desktopFirst = function (a, b) {
		  const testIsPrint = _testIsPrint(a, b);
		  if (testIsPrint !== null) {
		    return testIsPrint
		  }

		  const minA = isMinWidth(a) || isMinHeight(a);
		  const maxA = isMaxWidth(a) || isMaxHeight(a);

		  const minB = isMinWidth(b) || isMinHeight(b);
		  const maxB = isMaxWidth(b) || isMaxHeight(b);

		  if (minA && maxB) {
		    return 1
		  }
		  if (maxA && minB) {
		    return -1
		  }

		  const lengthA = _getQueryLength(a);
		  const lengthB = _getQueryLength(b);

		  if (lengthA === maxValue && lengthB === maxValue) {
		    return a.localeCompare(b)
		  } else if (lengthA === maxValue) {
		    return 1
		  } else if (lengthB === maxValue) {
		    return -1
		  }

		  if (lengthA > lengthB) {
		    if (maxA) {
		      return -1
		    }
		    return 1
		  }

		  if (lengthA < lengthB) {
		    if (maxA) {
		      return 1
		    }
		    return -1
		  }

		  return -(a.localeCompare(b))
		};

		// ----------------------------------------
		// Exports
		// ----------------------------------------

		var sortCssMediaQueries = sortCSSmq$1;

		var _tslib = _tslib$1;
		var jss$1 = require$$1;
		var sortCSSmq = sortCssMediaQueries;

		function _interopDefaultLegacy$1(e) {
			return typeof e === 'object' && 'default' in e ? e : { default: e };
		}

		var sortCSSmq__default = /*#__PURE__*/ _interopDefaultLegacy$1(sortCSSmq);

		function isPlainObject(sample) {
			return (
				sample !== null && typeof sample === 'object' && Array.isArray(sample) === false
			);
		}
		var UN_QUERIED = '__UN_QUERIED';
		function recursiveInnerAndGetQueries(pluginOptions, rules) {
			var queries = {
				groups: {},
				groupsSortNames: []
			};
			for (var index = 0; index < rules.length; index++) {
				var rule = rules[index];
				var query =
					rule.type === 'conditional' && typeof rule.query === 'string'
						? rule.query
						: UN_QUERIED;
				if (!queries.groups.hasOwnProperty(query)) {
					queries.groupsSortNames.push(query);
					queries.groups[query] = [];
				}
				queries.groups[query].push(index);
				// eslint-disable-next-line @typescript-eslint/no-use-before-define
				recursive(pluginOptions, rule);
			}
			queries.groupsSortNames.sort(function (a, b) {
				var aWeight = a === UN_QUERIED ? 0 : a.length;
				var bWeight = b === UN_QUERIED ? 0 : b.length;
				if (aWeight > 0 && bWeight > 0) {
					if (pluginOptions.desktopFirst) {
						return sortCSSmq__default['default'].desktopFirst(a, b);
					} else {
						return sortCSSmq__default['default'](a, b);
					}
				} else {
					return aWeight - bWeight;
				}
			});
			return queries;
		}
		function recursive(pluginOptions, data) {
			if (isPlainObject(data) && data.rules instanceof jss$1.RuleList) {
				data.rules.toString = function (options) {
					if (options === void 0) {
						options = {};
					}
					var str = '';
					var sheet = this.options.sheet;
					var link = sheet ? sheet.options.link : false;
					var _a = recursiveInnerAndGetQueries(pluginOptions, this.index),
						groups = _a.groups,
						groupsSortNames = _a.groupsSortNames;
					for (var i = 0; i < groupsSortNames.length; i++) {
						var groupName = groupsSortNames[i];
						var group = groups[groupsSortNames[i]];
						if (groupName !== UN_QUERIED && pluginOptions.combineMediaQueries) {
							str += '\n' + groupName + ' {';
							for (var i_1 = 0; i_1 < group.length; i_1++) {
								var rule = this.index[group[i_1]];
								var css = rule.rules.toString(
									_tslib.__assign(_tslib.__assign({}, options), {
										indent: (options.indent || 0) + 1
									})
								);
								if (!css && !link) continue;
								if (str) str += '\n';
								str += css;
							}
							str += '\n}\n';
						} else {
							for (var i_2 = 0; i_2 < group.length; i_2++) {
								var rule = this.index[group[i_2]];
								var css = rule.toString(options);
								if (!css && !link) continue;
								if (str) str += '\n';
								str += css;
							}
						}
					}
					return str;
				};
			}
		}
		function jssCombineAndSortMQ(options) {
			if (options === void 0) {
				options = {};
			}
			return {
				onProcessSheet: function (sheet) {
					recursive(options, sheet);
				}
			};
		}

		var dist = jssCombineAndSortMQ;

		const paramCaseToCamelCase = (str) => {
		    return str.replace(/-(\w)/g, (_, group) => group.toUpperCase());
		};

		// NOTE: these utils are in the same file on purpose
		// to force them being bundled into our core chunk
		const getTagName = (el) => el.tagName.toLowerCase();
		const getTagNameWithoutPrefix = (host) => {
		    const tagName = getTagName(host);
		    const [, tagNameWithoutPrefix = ''] = /^(?:[a-z-]+-)?(p-[a-z-]+)$/.exec(tagName) || [];
		    return (tagNameWithoutPrefix || tagName); // return tagName as fallback for default tags
		};
		const tagNamesWithoutTextAndHeadline = TAG_NAMES.filter((item) => item !== 'p-text' && item !== 'p-heading' && item !== 'p-headline' && item !== 'p-display');
		const PREFIXED_TAG_NAMES_CACHE = new Map();
		// TODO: typing support for components is missing
		const getPrefixedTagNames = (host) => {
		    const [, prefix = ''] = /^([a-z-]+)-p-[a-z-]+$/.exec(getTagName(host)) || [];
		    if (!PREFIXED_TAG_NAMES_CACHE.has(prefix)) {
		        const tagNames = tagNamesWithoutTextAndHeadline.reduce(prefix
		            ? (result, tag) => ({
		                ...result,
		                [paramCaseToCamelCase(tag)]: `${prefix}-${tag}`,
		            })
		            : (result, tag) => ({
		                ...result,
		                [paramCaseToCamelCase(tag)]: tag,
		            }), {});
		        PREFIXED_TAG_NAMES_CACHE.set(prefix, tagNames);
		    }
		    return PREFIXED_TAG_NAMES_CACHE.get(prefix);
		};

		function getHTMLElement(element, selector) {
		    return element?.querySelector(selector);
		}

		function getShadowRootHTMLElement(element, selector) {
		    return getHTMLElement(element.shadowRoot, selector);
		}

		const removeAttribute = (el, attributeName) => {
		    el.removeAttribute(attributeName);
		};

		const setAttribute = (el, attributeName, attributeValue = '') => {
		    el.setAttribute(attributeName, attributeValue);
		};

		const parseJSONAttribute = (attribute) => {
		    // Input is object, e.g. { 'aria-label': 'Some label' }
		    if (typeof attribute !== 'string') {
		        return attribute;
		    }
		    return JSON.parse(attribute
		        // Convert single quotes to double quotes except the ones which are escaped by backslash
		        .replace(/\\'/g, '__escaped_single_quote__')
		        .replace(/'/g, '"')
		        .replace(/__escaped_single_quote__/g, "\\'")
		        // Remove string escapes except the ones followed by unicode u0027
		        .replace(/([^\\])\\(?!u0027)/g, '$1')
		        // Wrap keys in double quotes
		        .replace(/[\s"]?([\w-]+)[\s"]?:/g, '"$1":'));
		};

		const hasWindow = typeof window !== 'undefined';

		const setAriaAttributes = (el, opts) => {
		    const { label, message, state } = opts;
		    if (label) {
		        setAttribute(el, 'aria-label', `${label}${message ? `. ${message}` : ''}`);
		    }
		    if (state === 'error') {
		        setAttribute(el, 'aria-invalid', 'true');
		    }
		    else {
		        removeAttribute(el, 'aria-invalid');
		    }
		};
		const parseAndGetAriaAttributes = (rawAttributes) => {
		    if (rawAttributes) {
		        return Object.fromEntries(Object.entries(parseJSONAttribute(rawAttributes)).map(([key, val]) => [
		            key,
		            // convert booleans to strings so that values are properly set and not just result in attributes without a value when true in jsx
		            typeof val === 'boolean' ? `${val}` : val,
		        ]));
		    }
		    return undefined;
		};
		const isHighContrastMode = hasWindow && window.matchMedia?.('(forced-colors: active)').matches;

		const borderWidthBase = '2px';

		const breakpointBase = 0;

		const breakpointXS = 480;

		const breakpointS = 760;

		const breakpointM = 1000;

		const breakpointL = 1300;

		const breakpointXL = 1760;

		const breakpointXXL = 1920;

		const breakpoint = {
		    base: breakpointBase,
		    xs: breakpointXS,
		    s: breakpointS,
		    m: breakpointM,
		    l: breakpointL,
		    xl: breakpointXL,
		    xxl: breakpointXXL,
		};

		function getMediaQueryMin(min) {
		    return `@media(min-width:${breakpoint[min]}px)`;
		}

		const motionDurationShort = '0.25s';

		const motionEasingBase = 'cubic-bezier(0.25,0.1,0.25,1)';

		const breakpoints = ['base', 'xs', 's', 'm', 'l', 'xl', 'xxl'];

		const motionDurationLong = '0.6s';

		const motionDurationModerate = '0.4s';

		const motionDurationVeryLong = '1.2s';

		const motionEasingIn = 'cubic-bezier(0,0,0.2,1)';

		const motionEasingOut = 'cubic-bezier(0.4,0,0.5,1)';

		/* Auto Generated Start */
		const themeLight = {
		    primaryColor: '#010205',
		    primaryColorDarken: '#000000',
		    backgroundColor: '#FFF',
		    backgroundColorDarken: '#E0E0E0',
		    backgroundColorLighten: '#FFFFFF',
		    backgroundSurfaceColor: '#EEEFF2',
		    backgroundSurfaceColorDarken: '#CBCED7',
		    backgroundSurfaceColorLighten: '#FFFFFF',
		    backgroundShadingColor: 'rgba(1, 2, 5, 0.67)',
		    backgroundFrostedColor: 'hsl(240 4% 85%/35%)',
		    contrastLowColor: '#D8D8DB',
		    contrastMediumColor: '#6B6D70',
		    contrastHighColor: '#535457',
		    contrastHighColorDarken: '#353638',
		    contrastHighColorLighten: '#717276',
		    hoverColor: 'rgba(148, 149, 152, .18)',
		    hoverColorDarken: '#75767A',
		    activeColor: 'rgba(148, 149, 152, 0.20)',
		    focusColor: '#1A44EA',
		    disabledColor: '#949598',
		    errorColor: '#CC1922',
		    errorColorDarken: '#951219',
		    errorSoftColor: '#FFE2E4',
		    errorSoftColorDarken: '#F4CED1',
		    errorSoftColorLighten: '#FFFFFF',
		    successColor: '#197E10',
		    successColorDarken: '#0E4809',
		    successSoftColor: '#E4FFEC',
		    successSoftColorDarken: '#D0F4DB',
		    successSoftColorLighten: '#FFFFFF',
		    warningColor: '#F3BE00',
		    warningSoftColor: '#FFF4D2',
		    warningSoftColorDarken: '#F1E5C1',
		    warningSoftColorLighten: '#FCFAF3',
		    infoColor: '#2762EC',
		    infoSoftColor: '#D3E1FF',
		    infoSoftColorDarken: '#C2D1F1',
		    infoSoftColorLighten: '#F4F7FD'
		};
		const themeDark = {
		    primaryColor: '#FBFCFF',
		    primaryColorDarken: '#BECEFF',
		    backgroundColor: '#0E0E12',
		    backgroundColorDarken: '#000000',
		    backgroundColorLighten: '#292934',
		    backgroundSurfaceColor: '#212225',
		    backgroundSurfaceColorDarken: '#040405',
		    backgroundSurfaceColorLighten: '#3E4045',
		    backgroundShadingColor: 'rgba(38, 38, 41, 0.67)',
		    backgroundFrostedColor: 'hsl(240 3% 26%/35%)',
		    contrastLowColor: '#404044',
		    contrastMediumColor: '#88898C',
		    contrastHighColor: '#AFB0B3',
		    contrastHighColorDarken: '#909195',
		    contrastHighColorLighten: '#CECFD1',
		    hoverColor: 'rgba(148, 149, 152, .18)',
		    hoverColorDarken: '#75767A',
		    activeColor: 'rgba(126, 127, 130, 0.20)',
		    focusColor: '#1A44EA',
		    disabledColor: '#7E7F82',
		    errorColor: '#FC4040',
		    errorColorDarken: '#FB0404',
		    errorSoftColor: '#3A0F0F',
		    errorSoftColorDarken: '#1A1111',
		    errorSoftColorLighten: '#3F2828',
		    successColor: '#09D087',
		    successColorDarken: '#069561',
		    successSoftColor: '#003320',
		    successSoftColorDarken: '#04110C',
		    successSoftColorLighten: '#0F432F',
		    warningColor: '#F7CB47',
		    warningSoftColor: '#362B0A',
		    warningSoftColorDarken: '#16130B',
		    warningSoftColorLighten: '#3E3720',
		    infoColor: '#178BFF',
		    infoSoftColor: '#04294E',
		    infoSoftColorDarken: '#0C1A27',
		    infoSoftColorLighten: '#1A3856'
		};
		const themeAuto = {
		    ...themeLight,
		};
		const themes = {
		    'light': themeLight,
		    'dark': themeDark,
		    'auto': themeAuto
		};
		/* Auto Generated End */
		const schemeHighContrastMerged = {
		    disabledColor: 'GrayText',
		    focusColor: 'Highlight',
		};
		const schemeHighContrast = {
		    canvasColor: 'Canvas',
		    canvasTextColor: 'CanvasText',
		    highlightColor: 'Highlight',
		    linkColor: 'LinkText',
		};
		const getThemedColors = (theme) => {
		    return isHighContrastMode ? { ...themes[theme], ...schemeHighContrastMerged } : themes[theme];
		};
		const getHighContrastColors = () => {
		    return schemeHighContrast;
		};
		const getInvertedThemedColors = (theme) => {
		    return getThemedColors(isThemeDark(theme) ? 'light' : 'dark');
		};

		const motionDurationMap = {
		    short: motionDurationShort,
		    moderate: motionDurationModerate,
		    long: motionDurationLong,
		    veryLong: motionDurationVeryLong,
		};
		const motionEasingMap = {
		    base: motionEasingBase,
		    in: motionEasingIn,
		    out: motionEasingOut,
		    linear: 'linear',
		};
		/**
		 * Base value used for spacing calculations
		 *
		 * This constant defines the base value of 16 pixels, which serves as a
		 * standard unit for calculating relative sizes. By multiplying this base
		 * value with scaling factors and proportions, you can derive consistent
		 * and proportional dimensions and spacings throughout the design.
		 *
		 * Example:
		 * const spacing = scalingFactor * proportion * SCALING_BASE_VALUE;
		 */
		const SCALING_BASE_VALUE = '16px';
		const dismissButtonJssStyle = {
		    '--p-internal-button-scaling': 0,
		};
		const cssVariableTransitionDuration = '--p-transition-duration';
		const cssVariableAnimationDuration = '--p-animation-duration';
		const getAnimation = (name, duration = 'short', easing = 'base') => {
		    return `${name} var(${cssVariableAnimationDuration}, ${motionDurationMap[duration]}) ${motionEasingMap[easing]}`;
		};
		const getTransition = (cssProperty, duration = 'short', easing = 'base', delay) => {
		    return `${cssProperty} var(${cssVariableTransitionDuration}, ${motionDurationMap[duration]}) ${motionEasingMap[easing]}${delay ? ` var(${cssVariableTransitionDuration}, ${motionDurationMap[delay]})` : ''}`;
		};
		const addImportantToRule = (value) => `${value} !important`;
		const addImportantToEachRule = (input) => {
		    return Object.entries(input).reduce((result, [key, value]) => value === null
		        ? result
		        : // @ts-expect-error: Type string can't be used to index type JssStyle
		            ((result[key] =
		                // biome-ignore lint/style/noCommaOperator: to be refactored
		                typeof value === 'object' ? addImportantToEachRule(value) : addImportantToRule(value)),
		                result), {});
		};
		// TODO: this is workaround, in order the colors to be bundled in the main bundle, we need to have at least one function here, which is used in project and which calls "getThemedColors"
		// TODO: This mechanism needs to be investigated as part of refactoring
		const doGetThemedColors = (theme = 'light') => {
		    return getThemedColors(theme);
		};
		const getFocusJssStyle = (theme, opts) => {
		    const { offset = '2px', slotted = '', pseudo = false } = opts || {};
		    const { focusColor } = getThemedColors(theme);
		    const { focusColor: focusColorDark } = getThemedColors('dark');
		    const slottedSelector = slotted && slotted !== true ? slotted : '';
		    return {
		        [`&${slotted ? '(' : ''}${slottedSelector}::-moz-focus-inner${slotted ? ')' : ''}`]: {
		            border: 0, // reset ua-style (for FF)
		        },
		        [`&${slotted ? '(' : ''}${slottedSelector}:focus${slotted ? ')' : ''}`]: {
		            outline: 0, // reset ua-style (for older browsers)
		        },
		        ...(pseudo && {
		            [`&${slotted ? '(' : ''}${slottedSelector}:focus-visible${slotted ? ')' : ''}`]: {
		                outline: 0, // reset ua-style (for modern browsers)
		            },
		        }),
		        [`&${slotted ? '(' : ''}${slottedSelector}:focus-visible${slotted ? ')' : ''}${pseudo ? '::before' : ''}`]: {
		            outline: `${borderWidthBase} solid ${focusColor}`,
		            outlineOffset: offset,
		            ...prefersColorSchemeDarkMediaQuery(theme, {
		                outlineColor: focusColorDark,
		            }),
		        },
		    };
		};
		// reset initial styles, e.g. in case link-pure is used with slotted anchor and nested within e.g. an accordion
		const getResetInitialStylesForSlottedAnchor = {
		    margin: 0,
		    padding: 0,
		    outline: 0, // reset native blue outline
		    borderRadius: 0,
		    background: 'transparent',
		};
		/**
		 * Returns a JSS style object that can be used to visually hide text in the browser, while still allowing it to be accessed by screen readers.
		 * @param {boolean} isHidden - A boolean value indicating whether the text should be hidden or not. Defaults to true.
		 * @param {JssStyle} isShownJssStyle - Additional styles applied when isHidden = false
		 * @returns {JssStyle} - A JSS style object containing styles depending on the value of isHidden and isShownJssStyle.
		 */
		const getHiddenTextJssStyle = (isHidden = true, isShownJssStyle) => {
		    return isHidden
		        ? {
		            position: 'absolute',
		            width: '1px',
		            height: '1px',
		            padding: 0,
		            margin: '-1px',
		            overflow: 'hidden',
		            clip: 'rect(0,0,0,0)',
		            whiteSpace: 'nowrap',
		        }
		        : {
		            position: 'static',
		            width: 'auto',
		            height: 'auto',
		            padding: 0,
		            margin: 0,
		            overflow: 'visible',
		            clip: 'auto',
		            whiteSpace: 'normal',
		            ...isShownJssStyle,
		        };
		};

		const prefersColorSchemeDarkMediaQuery = (theme, style) => {
		    return isThemeAuto(theme) && { '@media (prefers-color-scheme: dark)': style };
		};

		const parseJSON = (prop) => {
		    if (typeof prop === 'string') {
		        try {
		            // prop is potentially JSON parsable string, e.g. "{ base: 'block', l: 'inline' }" or "true" or "false"
		            return JSON.parse(prop
		                .replace(/'/g, '"') // convert single quotes to double quotes
		                .replace(/[\s"]?([a-z]+)[\s"]?:([^//])/g, '"$1":$2') // wrap keys in double quotes if they don't have them but ignore potential urls
		            );
		        }
		        catch {
		            // prop is string, e.g. "block" or "inline"
		            return prop;
		        }
		    }
		    else {
		        // prop is object, e.g. { base: 'block', l: 'inline' } or number, e.g. 123 or boolean, e.g. true
		        return prop;
		    }
		};

		// NOTE: handpicked selection of plugins from jss-preset-default
		const jss = createJss({
		    plugins: [
		        jssGlobal(),
		        jssNested(),
		        camelCase(),
		        dist({ combineMediaQueries: true }),
		    ],
		});
		const getCss = (jssStyles) => jss
		    .createStyleSheet(jssStyles, {
		    generateId: (rule) => rule.key,
		})
		    .toString();
		const supportsConstructableStylesheets = () => {
		    try {
		        return typeof new CSSStyleSheet().replaceSync === 'function';
		    }
		    catch {
		        return false;
		    }
		};
		// determine it once
		const hasConstructableStylesheetSupport$1 = supportsConstructableStylesheets();
		// getter for easy mocking
		const getHasConstructableStylesheetSupport = () => hasConstructableStylesheetSupport$1;
		const componentCssMap = new Map();
		const getCachedComponentCss = (host, getComponentCss, ...args) => {
		    const tagName = getTagNameWithoutPrefix(host);
		    if (!componentCssMap.has(tagName)) {
		        componentCssMap.set(tagName, new Map());
		    }
		    const id = args.map((arg) => (typeof arg === 'object' ? JSON.stringify(arg) : arg)).join('|');
		    const cache = componentCssMap.get(tagName);
		    if (!cache.has(id)) {
		        cache.set(id, getComponentCss(...args));
		    }
		    return cache.get(id);
		};
		const attachComponentCss = (host, getComponentCss, ...args) => {
		    const css = getCachedComponentCss(host, getComponentCss, ...args);
		    if (getHasConstructableStylesheetSupport()) {
		        const [sheet] = host.shadowRoot.adoptedStyleSheets;
		        if (sheet) {
		            sheet.replaceSync(css);
		        }
		        else {
		            const newSheet = new CSSStyleSheet();
		            newSheet.replaceSync(css);
		            host.shadowRoot.adoptedStyleSheets = [newSheet];
		        }
		    }
		    else {
		        // NOTE: fallback for Safari
		        // old style needs to be removed and added again in safari to be recognized
		        getShadowRootHTMLElement(host, 'style[jss]')?.remove();
		        const styleEl = document.createElement('style');
		        styleEl.setAttribute('jss', '');
		        styleEl.innerHTML = css;
		        host.shadowRoot.prepend(styleEl);
		    }
		};
		// TODO: this function does nothing but treats for unknowns reasons e.g. getThemedColors to be bundled into main chunk
		const doNothing = () => {
		    addImportantToEachRule({});
		    hasPropValueChanged(1, 1); // to force into main chunk
		};
		const buildResponsiveStyles = (rawValue, getJssStyle) => {
		    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
		    const value = parseJSON(rawValue);
		    return typeof value === 'object'
		        ? Object.keys(value)
		            // base styles are applied on root object, responsive styles are nested within
		            // hence it is used as the initial object within reduce function
		            .filter((key) => key !== 'base')
		            .reduce((result, breakpointValue) => ({
		            ...result,
		            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
		            [getMediaQueryMin(breakpointValue)]: getJssStyle(value[breakpointValue]),
		        }), getJssStyle(value.base))
		        : getJssStyle(value);
		};
		const isObject = (obj) => typeof obj === 'object' && !Array.isArray(obj);
		// NOTE: taken from https://stackoverflow.com/a/48218209
		const mergeDeep = (...objects) => {
		    return objects.reduce((prev, obj) => {
		        // biome-ignore lint/complexity/noForEach: to be refactored
		        Object.keys(obj).forEach((key) => {
		            const pVal = prev[key];
		            const oVal = obj[key];
		            if (isObject(pVal) && isObject(oVal)) {
		                prev[key] = mergeDeep(pVal, oVal);
		            }
		            else {
		                prev[key] = oVal;
		            }
		        });
		        return prev;
		    }, {});
		};

		const elementsMap = new Map();
		const getElementMap = (element) => {
		    const tagName = element.tagName;
		    if (!elementsMap.has(tagName)) {
		        elementsMap.set(tagName, new Map());
		    }
		    return elementsMap.get(tagName);
		};
		// TODO: Use function from ./jss (Causes bundling issues)
		const hasConstructableStylesheetSupport = (() => {
		    try {
		        return typeof new CSSStyleSheet().replaceSync === 'function';
		    }
		    catch {
		        return false;
		    }
		})(); // determine it once
		const applyConstructableStylesheetStyles = (element, ...getStyles) => {
		    if (hasConstructableStylesheetSupport) {
		        const documentOrShadowRoot = element.getRootNode();
		        const elementMap = getElementMap(element);
		        if (!elementMap.has(documentOrShadowRoot)) {
		            elementMap.set(documentOrShadowRoot, true);
		            const sheet = new CSSStyleSheet();
		            sheet.replaceSync(getStyles.map((getStyle) => getCss(getStyle(element.tagName.toLowerCase()))).join(''));
		            // TODO: for some reason unit test in Docker environment throws TS2339: Property 'push' does not exist on type 'readonly CSSStyleSheet[]'
		            /* eslint-disable @typescript-eslint/prefer-ts-expect-error, @typescript-eslint/ban-ts-comment */
		            // @ts-ignore
		            documentOrShadowRoot.adoptedStyleSheets?.push(sheet);
		        }
		    }
		};

		const attributeMutationMap = new Map();
		const attributeObserver = hasWindow &&
		    new MutationObserver((mutations) => {
		        for (const mutation of mutations
		            // reduce array to only entries that have really a changed value
		            .filter((mutation) => mutation.oldValue !== mutation.target.getAttribute(mutation.attributeName))
		            // remove duplicates so we execute callback only once per node
		            .filter((mutation, idx, arr) => arr.findIndex((m) => m.target === mutation.target) === idx)) {
		            attributeMutationMap.get(mutation.target)?.();
		        }
		    });
		const observeAttributes = (node, attributes, callback) => {
		    // node might not be defined in connectedCallback
		    if (node) {
		        attributeMutationMap.set(node, callback);
		        attributeObserver.observe(node, { attributeFilter: attributes, attributeOldValue: true });
		    }
		};
		const unobserveAttributes = (node) => {
		    attributeMutationMap.delete(node);
		};

		const mediaQueries = Object.values(breakpoint).map((v) => `(min-width:${v}px)`);
		let mediaQueryLists = hasWindow && window.matchMedia ? mediaQueries.map(window.matchMedia) : [];
		const breakpointChangeCallbackMap = new Map();
		const observeBreakpointChange = (node, callback) => {
		    // node might not be defined in connectedCallback
		    if (node) {
		        if (breakpointChangeCallbackMap.size === 0) {
		            for (const mediaQueryList of mediaQueryLists) {
		                // matchmedia-polyfill only implements addListener in jsdom-polyfill
		                mediaQueryList.addEventListener?.('change', handleBreakpointChange);
		            }
		        }
		        breakpointChangeCallbackMap.set(node, callback);
		    }
		};
		const unobserveBreakpointChange = (node) => {
		    breakpointChangeCallbackMap.delete(node);
		    if (breakpointChangeCallbackMap.size === 0) {
		        for (const mediaQueryList of mediaQueryLists) {
		            // matchmedia-polyfill only implements removeListener in jsdom-polyfill
		            mediaQueryList.removeEventListener?.('change', handleBreakpointChange);
		        }
		    }
		};
		const handleBreakpointChange = () => {
		    for (const [_, breakpointChangeCallback] of breakpointChangeCallbackMap) {
		        breakpointChangeCallback();
		    }
		};

		const flippedBreakpoint = Object.entries(breakpoint).reduce((result, [key, val]) => ({ ...result, [`${val}px`]: key }), {});
		const getCurrentBreakpointKey = () => {
		    const lastMatchingMediaQuery = mediaQueryLists
		        .filter((item) => item.matches)
		        .map((item) => item.media)
		        .pop();
		    return flippedBreakpoint[/\d+px/.exec(lastMatchingMediaQuery)[0]];
		};
		const getCurrentMatchingBreakpointValue = (data) => {
		    if (typeof data === 'object') {
		        const currentBreakpoint = getCurrentBreakpointKey();
		        const result = data[currentBreakpoint];
		        if (result) {
		            return result;
		        }
		        const valuesArray = breakpoints.map((bp) => data[bp]);
		        // fill gaps with value from preceding breakpoint
		        valuesArray.forEach((val, i, arr) => {
		            if (val === undefined) {
		                arr[i] = arr[i - 1];
		            }
		        });
		        return valuesArray[breakpoints.indexOf(currentBreakpoint)];
		    }
		    return data;
		};

		/**
		 * Map of observed nodes and their corresponding callback functions.
		 */
		const observedNodesMap = new Map();
		/**
		 * Mutation observer for observing changes in the children of observed nodes.
		 */
		const childrenObserver = hasWindow &&
		    new MutationObserver((mutations) => {
		        // there may be race conditions in jsdom-polyfill tests  where the map is already empty when a mutation happens
		        if (observedNodesMap.size > 0) {
		            const observedNodes = Array.from(observedNodesMap.keys());
		            // remove duplicates so we execute callback only once per node
		            for (const mutation of mutations.filter((mutation, idx, arr) => arr.findIndex((m) => m.target === mutation.target) === idx)) {
		                for (const node of observedNodes.filter((node) => node.contains(mutation.target))) {
		                    observedNodesMap.get(node)?.();
		                }
		            }
		        }
		    });
		/**
		 * Observes the children of a given node and invokes a callback when changes occur.
		 * @template T - The type of the node.
		 * @template K - The type of the node's attributes.
		 * @param {T} node - The node to observe.
		 * @param {() => void} callback - The callback function to invoke when changes occur.
		 * @param {(Lowercase<K extends string ? K : string> | keyof AriaAttributes)[]} [attributes] - Optional attribute names to be monitored.
		 * @param {MutationObserverInit} options - An object providing options that describe which DOM mutations should be reported to
		 * @returns {void}
		 */
		const observeChildren = (node, callback, 
		// TODO: Remove attributes parameter and always use options
		attributes, options = {
		    childList: true,
		    subtree: true,
		    characterData: true,
		}) => {
		    // node might not be defined in connectedCallback
		    if (node) {
		        observedNodesMap.set(node, callback);
		        childrenObserver.observe(node, {
		            attributeFilter: attributes,
		            ...options,
		        });
		    }
		};
		/**
		 * Stops observing the children of a given node.
		 * @template T - The type of the node.
		 * @param {T} node - The node to unobserve.
		 * @returns {void}
		 */
		const unobserveChildren = (node) => {
		    observedNodesMap.delete(node);
		};

		const hasPropValueChanged = (newVal, oldVal) => {
		    if (typeof newVal !== 'object' || typeof oldVal !== 'object') {
		        // primitive types
		        return newVal !== oldVal;
		    }
		    if (Array.isArray(newVal) && Array.isArray(oldVal)) {
		        // type array
		        return !(newVal.length === oldVal.length && newVal.every((val, i) => val === oldVal[i]));
		    }
		    // type object
		    // currently this does not take care of nested objects
		    return !(Object.keys(newVal).length === Object.keys(oldVal).length &&
		        Object.entries(newVal).every(([key1, val1]) => val1 === oldVal[key1]));
		};

		/**
		 * Checks if the current environment supports the native Popover API.
		 *
		 * @returns {boolean} `true` if the native Popover API is supported, `false` otherwise.
		 */
		const supportsNativePopover = () => {
		    if (!hasWindow) {
		        return false;
		    }
		    return Object.prototype.hasOwnProperty.call(HTMLElement.prototype, 'popover');
		};
		// determine it once
		const hasNativePopoverSupport = supportsNativePopover();
		// getter for easy mocking
		const getHasNativePopoverSupport = () => hasNativePopoverSupport;

		const isThemeAuto = (theme) => {
		    return theme === 'auto';
		};

		const isThemeDark = (theme) => {
		    return theme === 'dark';
		};

		const formatObjectOutput = (value) => {
		    return JSON.stringify(value)
		        .replace(/"([a-zA-Z?]+)":/g, '$1:') // remove double quotes from keys
		        .replace(/([,:{])/g, '$1 ') // add space after following: ,:{
		        .replace(/(})/g, ' $1') // add space before following: }
		        .replace(/^"(.+)"$/, '$1'); // remove wrapping double quotes
		};
		const formatArrayOutput = (value) => {
		    return (
		    // eslint-disable-next-line @typescript-eslint/no-base-to-string
		    JSON.stringify(value.map((x) => (x === undefined ? `${x}` : x))) // wrap undefined in quotes to not convert it to null
		        .replace(/'/g, '') // remove single quotes
		        // eslint-disable-next-line @typescript-eslint/quotes
		        .replace(/"/g, "'") // replace double quotes with single quotes
		        .replace(/'(undefined)'/, '$1') // remove quotes around undefined
		        .replace(/,/g, ', ') // add space after comma
		    );
		};
		const printErrorMessage = ({ propName, propValue, // TODO: might be nicer if this is always a string
		propType, componentName, }) => {
		    consoleError(`Invalid property '${propName}' with value '${formatObjectOutput(propValue)}' supplied to ${componentName}, expected one of: ${propType}`);
		};
		const isValueNotOfType = (propValue, propType) => {
		    // biome-ignore lint/suspicious/useValidTypeof: the comparison works because propValue has primitive values only
		    return propValue !== undefined && typeof propValue !== propType;
		};
		const validateValueOfType = (propName, propValue, propType) => {
		    if (isValueNotOfType(propValue, propType)) {
		        return { propName, propValue, propType };
		    }
		    return undefined;
		};
		const breakpointCustomizableTemplate = `value, ${formatObjectOutput(breakpoints.reduce((prev, key) => ({ ...prev, [key + (key !== 'base' ? '?' : '')]: 'value' }), {})).replace(/"/g, '')}`;
		const getBreakpointCustomizableStructure = (allowedValues) => {
		    return breakpointCustomizableTemplate.replace(/value/g, allowedValues !== 'boolean' && allowedValues !== 'number'
		        ? formatArrayOutput(allowedValues)
		            .replace(/\[/g, '(') // starting inline type literal array
		            .replace(/]/g, ')[]') // ending inline type literal array
		            .replace(/,/g, ' |') // replace commas with a pipe
		        : allowedValues);
		};
		const getAriaStructure = (allowedAriaAttributes) => {
		    return (formatObjectOutput(allowedAriaAttributes.reduce((prev, key) => ({
		        ...prev,
		        [key]: 'value',
		    }), {}))
		        .replace(/":/g, '"?:') // add optional modifier on keys before colon
		        // eslint-disable-next-line @typescript-eslint/quotes
		        .replace(/"/g, "'") // replace double quotes with single quotes
		    );
		};
		const getShapeStructure = (shapeStructure) => {
		    return formatObjectOutput(Object.keys(shapeStructure).reduce((prev, key) => ({ ...prev, [key]: shapeStructure[key].name }), {})).replace(/"/g, ''); // remove double quotes
		};
		const isBreakpointCustomizableValueInvalid = (value, allowedValues) => {
		    return allowedValues === 'boolean' || allowedValues === 'number'
		        ? isValueNotOfType(value, allowedValues)
		        : !allowedValues.includes(value);
		};
		// TODO: maybe dissolve object structure and have standalone utils
		const AllowedTypes = {
		    // eslint-disable-next-line id-blacklist
		    string: (...args) => validateValueOfType(...args, 'string'),
		    // eslint-disable-next-line id-blacklist
		    number: (...args) => validateValueOfType(...args, 'number'),
		    // eslint-disable-next-line id-blacklist
		    boolean: (...args) => validateValueOfType(...args, 'boolean'),
		    array: (allowedType) => 
		    // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
		    function array(propName, propValue) {
		        return isValidArray(propName, propValue, allowedType);
		    },
		    oneOf: (allowedValuesOrValidatorFunctions) => 
		    // @ts-expect-error: Not all code paths return a value
		    // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
		    function oneOf(propName, propValue) {
		        // use first item to determine if we've got primitive types or validator functions
		        if (typeof allowedValuesOrValidatorFunctions[0] !== 'function') {
		            if (!allowedValuesOrValidatorFunctions.includes(propValue)) {
		                return { propName, propValue, propType: formatArrayOutput(allowedValuesOrValidatorFunctions) };
		            }
		        }
		        else if (!allowedValuesOrValidatorFunctions.some((func) => func(propName, propValue) === undefined)) {
		            return {
		                propName,
		                propValue,
		                propType: allowedValuesOrValidatorFunctions.map((func) => func.name).join(', '),
		            };
		        }
		    },
		    breakpoint: (allowedValues) => 
		    // @ts-expect-error: Not all code paths return a value
		    // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
		    function breakpoint(propName, propValue) {
		        // TODO: do parseJSON once in the component, currently it is happening multiple times in a single lifecycle
		        const value = parseJSON(propValue);
		        let isInvalid = false;
		        if (typeof value === 'object') {
		            if (
		            // check structure keys: base, xs, s, m, l, xl
		            // TODO: check for base key
		            Object.keys(value).some((key) => !breakpoints.includes(key)) ||
		                // check actual values of keys, e.g. true, false, 'small' or 5
		                Object.values(value).some((val) => isBreakpointCustomizableValueInvalid(val, allowedValues))) {
		                isInvalid = true;
		            }
		        }
		        else if (isBreakpointCustomizableValueInvalid(value, allowedValues)) {
		            // single flat value like true, false, 'small' or 5, not breakpoint customizable object
		            isInvalid = true;
		        }
		        if (isInvalid) {
		            return {
		                propName,
		                propValue: formatObjectOutput(value),
		                propType: getBreakpointCustomizableStructure(allowedValues),
		            };
		        }
		    },
		    aria: (allowedAriaAttributes) => 
		    // @ts-expect-error: Not all code paths return a value
		    // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
		    function aria(propName, propValue) {
		        const ariaAttributes = parseJSONAttribute(propValue);
		        if (ariaAttributes &&
		            Object.keys(ariaAttributes).some((ariaKey) => !allowedAriaAttributes.includes(ariaKey))) {
		            return {
		                propName,
		                propValue: formatObjectOutput(ariaAttributes),
		                propType: getAriaStructure(allowedAriaAttributes),
		            };
		        }
		    },
		    shape: (shapeStructure) => 
		    // @ts-expect-error: Not all code paths return a value
		    // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
		    function shape(propName, propValue) {
		        if (propValue) {
		            // const propValueKeys = Object.keys(propValue);
		            if (
		            // check structure, but propValue could contain additional keys
		            // but how to handle optional keys like in table-head-cell's sort property?
		            // Object.keys(shapeStructure).some((key) => !propValueKeys.includes(key)) ||
		            // check values
		            Object.entries(shapeStructure).some(([structureKey, validatorFunc]) => validatorFunc(structureKey, propValue[structureKey]))) {
		                // TODO: more precise inner errors from value validation could be output
		                return {
		                    propName,
		                    propValue, // TODO: convert to string?
		                    propType: getShapeStructure(shapeStructure),
		                };
		            }
		        }
		    },
		};
		const validateProps = (instance, propTypes) => {
		    for (const error of Object.entries(propTypes)
		        .map(([propKey, validatorFunc]) => validatorFunc(propKey, instance[propKey]))
		        .filter((x) => x)) {
		        printErrorMessage({ ...error, componentName: getTagNameWithoutPrefix(instance.host) });
		    }
		};
		/**
		 * Validates an array using a provided validator function and returns the first encountered validation error.
		 *
		 * @param {string} propName - The name of the property being validated.
		 * @param {any} arr - The input to be validated.
		 * @param {ValidatorFunction} validator - The validator function that checks each array item.
		 * @returns {ValidationError | undefined} The first encountered validation error object, or undefined if the array is valid.
		 */
		const isValidArray = (propName, arr, validator) => {
		    const validationError = Array.isArray(arr)
		        ? validator(propName, arr.find((item) => validator(propName, item)))
		        : {
		            propName,
		            propValue: arr,
		            propType: validator(propName, null).propType, // Get propType by passing in null which will always result in error
		        };
		    if (validationError) {
		        return { ...validationError, propType: `${validationError.propType}[]` };
		    }
		    return undefined;
		};

		exports.AllowedTypes = AllowedTypes;
		exports.Fragment = Fragment;
		exports.Host = Host;
		exports.SCALING_BASE_VALUE = SCALING_BASE_VALUE;
		exports.addImportantToEachRule = addImportantToEachRule;
		exports.addImportantToRule = addImportantToRule;
		exports.applyConstructableStylesheetStyles = applyConstructableStylesheetStyles;
		exports.attachComponentCss = attachComponentCss;
		exports.bootstrapLazy = bootstrapLazy;
		exports.borderWidthBase = borderWidthBase;
		exports.breakpoint = breakpoint;
		exports.breakpointM = breakpointM;
		exports.breakpointS = breakpointS;
		exports.buildResponsiveStyles = buildResponsiveStyles;
		exports.consoleError = consoleError;
		exports.consoleWarn = consoleWarn;
		exports.createEvent = createEvent;
		exports.cssVariableAnimationDuration = cssVariableAnimationDuration;
		exports.cssVariableTransitionDuration = cssVariableTransitionDuration;
		exports.dismissButtonJssStyle = dismissButtonJssStyle;
		exports.doGetThemedColors = doGetThemedColors;
		exports.doNothing = doNothing;
		exports.forceUpdate = forceUpdate;
		exports.getAnimation = getAnimation;
		exports.getCss = getCss;
		exports.getCurrentMatchingBreakpointValue = getCurrentMatchingBreakpointValue;
		exports.getElement = getElement;
		exports.getFocusJssStyle = getFocusJssStyle;
		exports.getHTMLElement = getHTMLElement;
		exports.getHasConstructableStylesheetSupport = getHasConstructableStylesheetSupport;
		exports.getHasNativePopoverSupport = getHasNativePopoverSupport;
		exports.getHiddenTextJssStyle = getHiddenTextJssStyle;
		exports.getHighContrastColors = getHighContrastColors;
		exports.getInvertedThemedColors = getInvertedThemedColors;
		exports.getMediaQueryMin = getMediaQueryMin;
		exports.getPrefixedTagNames = getPrefixedTagNames;
		exports.getResetInitialStylesForSlottedAnchor = getResetInitialStylesForSlottedAnchor;
		exports.getShadowRootHTMLElement = getShadowRootHTMLElement;
		exports.getTagName = getTagName;
		exports.getTagNameWithoutPrefix = getTagNameWithoutPrefix;
		exports.getThemedColors = getThemedColors;
		exports.getTransition = getTransition;
		exports.h = h;
		exports.hasPropValueChanged = hasPropValueChanged;
		exports.hasWindow = hasWindow;
		exports.isHighContrastMode = isHighContrastMode;
		exports.isThemeDark = isThemeDark;
		exports.mergeDeep = mergeDeep;
		exports.motionDurationLong = motionDurationLong;
		exports.motionDurationMap = motionDurationMap;
		exports.motionDurationModerate = motionDurationModerate;
		exports.motionDurationShort = motionDurationShort;
		exports.motionDurationVeryLong = motionDurationVeryLong;
		exports.motionEasingBase = motionEasingBase;
		exports.motionEasingIn = motionEasingIn;
		exports.motionEasingOut = motionEasingOut;
		exports.observeAttributes = observeAttributes;
		exports.observeBreakpointChange = observeBreakpointChange;
		exports.observeChildren = observeChildren;
		exports.paramCaseToCamelCase = paramCaseToCamelCase;
		exports.parseAndGetAriaAttributes = parseAndGetAriaAttributes;
		exports.parseJSON = parseJSON;
		exports.parseJSONAttribute = parseJSONAttribute;
		exports.prefersColorSchemeDarkMediaQuery = prefersColorSchemeDarkMediaQuery;
		exports.promiseResolve = promiseResolve;
		exports.registerInstance = registerInstance;
		exports.removeAttribute = removeAttribute;
		exports.setAriaAttributes = setAriaAttributes;
		exports.setAttribute = setAttribute;
		exports.setNonce = setNonce;
		exports.throwException = throwException;
		exports.unobserveAttributes = unobserveAttributes;
		exports.unobserveBreakpointChange = unobserveBreakpointChange;
		exports.unobserveChildren = unobserveChildren;
		exports.validateProps = validateProps;

		
	} (validateProps788e2bc5));
	return validateProps788e2bc5;
}

var hasRequiredLoader_cjs;

function requireLoader_cjs () {
	if (hasRequiredLoader_cjs) return loader_cjs;
	hasRequiredLoader_cjs = 1;

	Object.defineProperty(loader_cjs, '__esModule', { value: true });

	const validateProps = requireValidateProps788e2bc5();
	const appGlobals = requireAppGlobals2f0cb516();
	requireGetCDNBaseURLE7722df3();

	const defineCustomElements = async (win, options) => {
	  if (typeof window === 'undefined') return undefined;
	  if(!window.PDS_SKIP_FETCH) { appGlobals.globalScripts(); }
	  return validateProps.bootstrapLazy(JSON.parse("[[\"p-table_7.cjs\",[[1,\"p-table\",{\"caption\":[1],\"compact\":[4],\"layout\":[1],\"theme\":[1]}],[1,\"p-table-body\"],[1,\"p-table-cell\",{\"multiline\":[4]}],[1,\"p-table-head\"],[1,\"p-table-head-cell\",{\"sort\":[16],\"hideLabel\":[4,\"hide-label\"],\"multiline\":[4]}],[1,\"p-table-head-row\"],[1,\"p-table-row\"]]],[\"p-flex_2.cjs\",[[1,\"p-flex\",{\"inline\":[8],\"wrap\":[1],\"direction\":[1],\"justifyContent\":[1,\"justify-content\"],\"alignItems\":[1,\"align-items\"],\"alignContent\":[1,\"align-content\"]}],[1,\"p-flex-item\",{\"width\":[1],\"offset\":[1],\"alignSelf\":[1,\"align-self\"],\"grow\":[8],\"shrink\":[8],\"flex\":[1]}]]],[\"p-flyout-multilevel_2.cjs\",[[1,\"p-flyout-multilevel\",{\"open\":[4],\"activeIdentifier\":[1,\"active-identifier\"],\"aria\":[1],\"theme\":[1],\"flyoutMultilevelItemElements\":[32],\"primary\":[32],\"isSecondaryDrawerVisible\":[32]},[[0,\"internalUpdate\",\"onInternalUpdate\"]],{\"open\":[\"openChangeHandler\"],\"activeIdentifier\":[\"activeIdentifierChangeHandler\"],\"theme\":[\"themeChangeHandler\"]}],[1,\"p-flyout-multilevel-item\",{\"label\":[1],\"identifier\":[513],\"primary\":[1540],\"secondary\":[1540],\"cascade\":[1540]}]]],[\"p-grid_2.cjs\",[[1,\"p-grid\",{\"direction\":[1],\"wrap\":[1],\"gutter\":[8]}],[1,\"p-grid-item\",{\"size\":[8],\"offset\":[8]}]]],[\"p-multi-select_2.cjs\",[[81,\"p-multi-select\",{\"label\":[1],\"description\":[1],\"name\":[513],\"value\":[1040],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"disabled\":[4],\"required\":[4],\"dropdownDirection\":[1,\"dropdown-direction\"],\"theme\":[1],\"form\":[513],\"isOpen\":[32],\"srHighlightedOptionText\":[32],\"hasFilterResults\":[32]},[[0,\"internalOptionUpdate\",\"updateOptionHandler\"]],{\"value\":[\"onValueChange\"],\"isOpen\":[\"onIsOpenChange\"]}],[1,\"p-multi-select-option\",{\"value\":[1],\"disabled\":[4]}]]],[\"p-segmented-control_2.cjs\",[[65,\"p-segmented-control\",{\"backgroundColor\":[1,\"background-color\"],\"theme\":[1],\"value\":[1032],\"name\":[513],\"columns\":[8],\"form\":[513],\"disabled\":[1028]},[[0,\"internalSegmentedControlItemUpdate\",\"updateSegmentedControlItemHandler\"]],{\"value\":[\"onValueChange\"]}],[17,\"p-segmented-control-item\",{\"value\":[8],\"disabled\":[4],\"label\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"aria\":[1]},null,{\"label\":[\"handleLabelChange\"],\"icon\":[\"handleLabelChange\"],\"iconSource\":[\"handleLabelChange\"]}]]],[\"p-select-wrapper_2.cjs\",[[17,\"p-select-wrapper\",{\"label\":[1],\"description\":[1],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"filter\":[4],\"theme\":[1],\"dropdownDirection\":[1,\"dropdown-direction\"],\"native\":[4]}],[17,\"p-select-wrapper-dropdown\",{\"selectRef\":[16],\"label\":[1],\"description\":[1],\"message\":[1],\"state\":[1],\"direction\":[1],\"theme\":[1],\"filter\":[4],\"required\":[4],\"disabled\":[4],\"onOpenChange\":[16],\"isOpenOverride\":[4,\"is-open-override\"],\"isOpen\":[32],\"optionMaps\":[32],\"searchString\":[32]},null,{\"isOpen\":[\"onIsOpenChange\"]}]]],[\"p-select_2.cjs\",[[81,\"p-select\",{\"label\":[1],\"description\":[1],\"name\":[513],\"value\":[1025],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"disabled\":[1028],\"required\":[4],\"dropdownDirection\":[1,\"dropdown-direction\"],\"compact\":[4],\"theme\":[1],\"form\":[513],\"isOpen\":[32],\"srHighlightedOptionText\":[32]},[[0,\"internalOptionUpdate\",\"updateOptionHandler\"]],{\"value\":[\"onValueChange\"],\"isOpen\":[\"onIsOpenChange\"]}],[1,\"p-select-option\",{\"value\":[1],\"disabled\":[4]}]]],[\"p-stepper-horizontal_2.cjs\",[[1,\"p-stepper-horizontal\",{\"size\":[1],\"theme\":[1]}],[17,\"p-stepper-horizontal-item\",{\"state\":[1],\"disabled\":[4]},[[2,\"click\",\"onClick\"]],{\"state\":[\"onStateChange\"]}]]],[\"p-tabs_2.cjs\",[[1,\"p-tabs\",{\"size\":[1],\"weight\":[1],\"theme\":[1],\"gradientColorScheme\":[1,\"gradient-color-scheme\"],\"gradientColor\":[1,\"gradient-color\"],\"activeTabIndex\":[1026,\"active-tab-index\"],\"tabsItemElements\":[32]},null,{\"activeTabIndex\":[\"activeTabHandler\"]}],[1,\"p-tabs-item\",{\"label\":[1]},null,{\"label\":[\"handleLabelChange\"]}]]],[\"p-text-list_2.cjs\",[[1,\"p-text-list\",{\"listType\":[1,\"list-type\"],\"orderType\":[1,\"order-type\"],\"type\":[1],\"theme\":[1]}],[1,\"p-text-list-item\"]]],[\"p-toast_2.cjs\",[[1,\"p-toast\",{\"theme\":[1],\"addMessage\":[64]}],[1,\"p-toast-item\",{\"text\":[1],\"state\":[1],\"theme\":[1]}]]],[\"p-accordion.cjs\",[[1,\"p-accordion\",{\"size\":[1],\"theme\":[1],\"heading\":[1],\"headingTag\":[1,\"heading-tag\"],\"tag\":[1],\"open\":[4],\"compact\":[4],\"sticky\":[4]}]]],[\"p-banner.cjs\",[[1,\"p-banner\",{\"open\":[4],\"heading\":[1],\"headingTag\":[1,\"heading-tag\"],\"description\":[1],\"state\":[1],\"dismissButton\":[4,\"dismiss-button\"],\"persistent\":[4],\"width\":[1],\"theme\":[1]},null,{\"open\":[\"openChangeHandler\"]}]]],[\"p-button.cjs\",[[81,\"p-button\",{\"type\":[1],\"name\":[513],\"value\":[1],\"disabled\":[4],\"loading\":[4],\"variant\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"hideLabel\":[8,\"hide-label\"],\"compact\":[8],\"theme\":[1],\"aria\":[1],\"form\":[513]},[[2,\"click\",\"onClick\"]],{\"value\":[\"onValueChange\"]}]]],[\"p-button-group.cjs\",[[1,\"p-button-group\",{\"direction\":[1]}]]],[\"p-button-pure.cjs\",[[81,\"p-button-pure\",{\"type\":[1],\"name\":[513],\"value\":[1],\"disabled\":[4],\"loading\":[4],\"size\":[1],\"weight\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"underline\":[4],\"active\":[4],\"hideLabel\":[8,\"hide-label\"],\"alignLabel\":[1,\"align-label\"],\"stretch\":[8],\"theme\":[1],\"aria\":[1],\"form\":[513]},[[2,\"click\",\"onClick\"]],{\"value\":[\"onValueChange\"]}]]],[\"p-button-tile.cjs\",[[17,\"p-button-tile\",{\"size\":[1],\"weight\":[1],\"background\":[1],\"aspectRatio\":[1,\"aspect-ratio\"],\"label\":[1],\"description\":[1],\"align\":[1],\"gradient\":[4],\"compact\":[8],\"type\":[1],\"disabled\":[4],\"loading\":[4],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"aria\":[1]},[[2,\"click\",\"onClick\"]]]]],[\"p-canvas.cjs\",[[1,\"p-canvas\",{\"sidebarStartOpen\":[4,\"sidebar-start-open\"],\"sidebarEndOpen\":[4,\"sidebar-end-open\"],\"theme\":[1],\"isMediaQueryS\":[32],\"isMediaQueryM\":[32]},null,{\"sidebarStartOpen\":[\"openChangeHandlerSidebarStart\"],\"sidebarEndOpen\":[\"openChangeHandlerSidebarEnd\"]}]]],[\"p-carousel.cjs\",[[1,\"p-carousel\",{\"heading\":[1],\"headingSize\":[1,\"heading-size\"],\"description\":[1],\"alignHeader\":[1,\"align-header\"],\"alignControls\":[1,\"align-controls\"],\"rewind\":[4],\"wrapContent\":[4,\"wrap-content\"],\"width\":[1],\"slidesPerPage\":[8,\"slides-per-page\"],\"disablePagination\":[8,\"disable-pagination\"],\"pagination\":[8],\"aria\":[1],\"intl\":[1],\"theme\":[1],\"activeSlideIndex\":[2,\"active-slide-index\"],\"skipLinkTarget\":[1,\"skip-link-target\"],\"focusOnCenterSlide\":[4,\"focus-on-center-slide\"],\"gradientColor\":[1,\"gradient-color\"],\"trimSpace\":[4,\"trim-space\"],\"amountOfPages\":[32]},null,{\"activeSlideIndex\":[\"activeSlideHandler\"]}]]],[\"p-checkbox.cjs\",[[81,\"p-checkbox\",{\"name\":[513],\"required\":[4],\"disabled\":[4],\"indeterminate\":[4],\"checked\":[1028],\"form\":[513],\"value\":[1],\"label\":[1],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"loading\":[4],\"compact\":[4],\"theme\":[1]},[[0,\"keydown\",\"onKeydown\"]],{\"value\":[\"onValueChange\"],\"indeterminate\":[\"onIndeterminateChange\"],\"checked\":[\"onCheckedChange\"]}]]],[\"p-checkbox-wrapper.cjs\",[[1,\"p-checkbox-wrapper\",{\"label\":[1],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"loading\":[4],\"theme\":[1]},[[0,\"keydown\",\"onKeydown\"]]]]],[\"p-content-wrapper.cjs\",[[1,\"p-content-wrapper\",{\"width\":[1],\"backgroundColor\":[1,\"background-color\"],\"theme\":[1]}]]],[\"p-crest.cjs\",[[17,\"p-crest\",{\"href\":[1],\"target\":[1],\"aria\":[1]}]]],[\"p-display.cjs\",[[1,\"p-display\",{\"tag\":[1],\"size\":[1],\"align\":[1],\"color\":[1],\"ellipsis\":[4],\"theme\":[1]}]]],[\"p-divider.cjs\",[[1,\"p-divider\",{\"color\":[1],\"orientation\":[1],\"direction\":[1],\"theme\":[1]}]]],[\"p-fieldset.cjs\",[[1,\"p-fieldset\",{\"label\":[1],\"labelSize\":[1,\"label-size\"],\"required\":[4],\"state\":[1],\"message\":[1],\"theme\":[1]}]]],[\"p-fieldset-wrapper.cjs\",[[1,\"p-fieldset-wrapper\",{\"label\":[1],\"labelSize\":[1,\"label-size\"],\"required\":[4],\"state\":[1],\"message\":[1],\"theme\":[1]}]]],[\"p-flyout.cjs\",[[1,\"p-flyout\",{\"open\":[4],\"position\":[1],\"disableBackdropClick\":[4,\"disable-backdrop-click\"],\"footerBehavior\":[1,\"footer-behavior\"],\"theme\":[1],\"aria\":[1]}]]],[\"p-heading.cjs\",[[1,\"p-heading\",{\"tag\":[1],\"size\":[1],\"align\":[1],\"color\":[1],\"ellipsis\":[4],\"theme\":[1]}]]],[\"p-headline.cjs\",[[1,\"p-headline\",{\"variant\":[1],\"tag\":[1],\"align\":[1],\"color\":[1],\"ellipsis\":[4],\"theme\":[1]}]]],[\"p-icon.cjs\",[[1,\"p-icon\",{\"name\":[1],\"source\":[1],\"color\":[1],\"size\":[1],\"lazy\":[4],\"theme\":[1],\"aria\":[1]}]]],[\"p-inline-notification.cjs\",[[1,\"p-inline-notification\",{\"heading\":[1],\"headingTag\":[1,\"heading-tag\"],\"description\":[1],\"state\":[1],\"dismissButton\":[4,\"dismiss-button\"],\"persistent\":[4],\"actionLabel\":[1,\"action-label\"],\"actionLoading\":[4,\"action-loading\"],\"actionIcon\":[1,\"action-icon\"],\"theme\":[1]}]]],[\"p-link.cjs\",[[17,\"p-link\",{\"variant\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"href\":[1],\"target\":[1],\"download\":[1],\"rel\":[1],\"hideLabel\":[8,\"hide-label\"],\"compact\":[8],\"theme\":[1],\"aria\":[1]}]]],[\"p-link-pure.cjs\",[[17,\"p-link-pure\",{\"alignLabel\":[1,\"align-label\"],\"stretch\":[8],\"size\":[1],\"weight\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"underline\":[4],\"href\":[1],\"active\":[4],\"hideLabel\":[8,\"hide-label\"],\"theme\":[1],\"target\":[1],\"download\":[1],\"rel\":[1],\"aria\":[1]}]]],[\"p-link-social.cjs\",[[17,\"p-link-social\",{\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"href\":[1],\"target\":[1],\"rel\":[1],\"hideLabel\":[8,\"hide-label\"],\"compact\":[4],\"theme\":[1]}]]],[\"p-link-tile.cjs\",[[17,\"p-link-tile\",{\"size\":[1],\"weight\":[1],\"background\":[1],\"aspectRatio\":[1,\"aspect-ratio\"],\"label\":[1],\"description\":[1],\"align\":[1],\"gradient\":[4],\"compact\":[8],\"href\":[1],\"target\":[1],\"download\":[1],\"rel\":[1],\"aria\":[1]}]]],[\"p-link-tile-model-signature.cjs\",[[1,\"p-link-tile-model-signature\",{\"model\":[1],\"weight\":[1],\"aspectRatio\":[1,\"aspect-ratio\"],\"heading\":[1],\"description\":[1],\"linkDirection\":[1,\"link-direction\"],\"headingTag\":[1,\"heading-tag\"]}]]],[\"p-link-tile-product.cjs\",[[17,\"p-link-tile-product\",{\"heading\":[1],\"price\":[1],\"priceOriginal\":[1,\"price-original\"],\"description\":[1],\"likeButton\":[4,\"like-button\"],\"liked\":[4],\"href\":[1],\"aspectRatio\":[1,\"aspect-ratio\"],\"target\":[1],\"rel\":[1],\"theme\":[1]}]]],[\"p-marque.cjs\",[[17,\"p-marque\",{\"trademark\":[4],\"variant\":[1],\"size\":[1],\"href\":[1],\"target\":[1],\"aria\":[1]}]]],[\"p-modal.cjs\",[[1,\"p-modal\",{\"open\":[4],\"disableCloseButton\":[4,\"disable-close-button\"],\"dismissButton\":[4,\"dismiss-button\"],\"disableBackdropClick\":[4,\"disable-backdrop-click\"],\"heading\":[1],\"backdrop\":[1],\"fullscreen\":[8],\"aria\":[1],\"theme\":[1]}]]],[\"p-model-signature.cjs\",[[1,\"p-model-signature\",{\"model\":[1],\"safeZone\":[4,\"safe-zone\"],\"fetchPriority\":[1,\"fetch-priority\"],\"lazy\":[4],\"size\":[1],\"color\":[1],\"theme\":[1]}]]],[\"p-optgroup.cjs\",[[1,\"p-optgroup\",{\"label\":[1],\"disabled\":[4]},null,{\"disabled\":[\"handleDisabledChange\"]}]]],[\"p-pagination.cjs\",[[17,\"p-pagination\",{\"totalItemsCount\":[2,\"total-items-count\"],\"itemsPerPage\":[2,\"items-per-page\"],\"activePage\":[1026,\"active-page\"],\"maxNumberOfPageLinks\":[8,\"max-number-of-page-links\"],\"showLastPage\":[4,\"show-last-page\"],\"allyLabel\":[1,\"ally-label\"],\"allyLabelPrev\":[1,\"ally-label-prev\"],\"allyLabelPage\":[1,\"ally-label-page\"],\"allyLabelNext\":[1,\"ally-label-next\"],\"intl\":[1],\"theme\":[1]}]]],[\"p-pin-code.cjs\",[[81,\"p-pin-code\",{\"label\":[1],\"description\":[1],\"name\":[513],\"length\":[2],\"hideLabel\":[8,\"hide-label\"],\"state\":[1],\"disabled\":[4],\"loading\":[4],\"required\":[4],\"message\":[1],\"type\":[1],\"value\":[1025],\"theme\":[1],\"form\":[513]}]]],[\"p-popover.cjs\",[[1,\"p-popover\",{\"direction\":[1],\"description\":[1],\"aria\":[1],\"theme\":[1],\"isOpen\":[32]}]]],[\"p-radio-button-wrapper.cjs\",[[1,\"p-radio-button-wrapper\",{\"label\":[1],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"loading\":[4],\"theme\":[1]}]]],[\"p-scroller.cjs\",[[1,\"p-scroller\",{\"gradientColorScheme\":[1,\"gradient-color-scheme\"],\"gradientColor\":[1,\"gradient-color\"],\"scrollToPosition\":[1025,\"scroll-to-position\"],\"scrollIndicatorPosition\":[1,\"scroll-indicator-position\"],\"alignScrollIndicator\":[1,\"align-scroll-indicator\"],\"theme\":[1],\"scrollbar\":[4],\"aria\":[1],\"isPrevHidden\":[32],\"isNextHidden\":[32]},null,{\"scrollToPosition\":[\"scrollToPositionHandler\"]}]]],[\"p-sheet.cjs\",[[1,\"p-sheet\",{\"open\":[4],\"dismissButton\":[4,\"dismiss-button\"],\"disableBackdropClick\":[4,\"disable-backdrop-click\"],\"aria\":[1],\"theme\":[1]}]]],[\"p-spinner.cjs\",[[1,\"p-spinner\",{\"size\":[1],\"theme\":[1],\"aria\":[1]}]]],[\"p-switch.cjs\",[[17,\"p-switch\",{\"alignLabel\":[1,\"align-label\"],\"hideLabel\":[8,\"hide-label\"],\"stretch\":[8],\"checked\":[4],\"disabled\":[4],\"loading\":[4],\"compact\":[4],\"theme\":[1]},[[2,\"click\",\"onClick\"]]]]],[\"p-tabs-bar.cjs\",[[1,\"p-tabs-bar\",{\"size\":[1],\"weight\":[1],\"theme\":[1],\"gradientColorScheme\":[1,\"gradient-color-scheme\"],\"gradientColor\":[1,\"gradient-color\"],\"activeTabIndex\":[2,\"active-tab-index\"],\"tabElements\":[32]},null,{\"activeTabIndex\":[\"activeTabIndexHandler\"]}]]],[\"p-tag.cjs\",[[1,\"p-tag\",{\"theme\":[1],\"color\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"compact\":[4]}]]],[\"p-tag-dismissible.cjs\",[[17,\"p-tag-dismissible\",{\"color\":[1],\"theme\":[1],\"label\":[1],\"aria\":[1]}]]],[\"p-text.cjs\",[[1,\"p-text\",{\"tag\":[1],\"size\":[1],\"weight\":[1],\"align\":[1],\"color\":[1],\"ellipsis\":[4],\"theme\":[1]}]]],[\"p-text-field-wrapper.cjs\",[[1,\"p-text-field-wrapper\",{\"label\":[1],\"unit\":[1],\"unitPosition\":[1,\"unit-position\"],\"description\":[1],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"showCharacterCount\":[4,\"show-character-count\"],\"showCounter\":[4,\"show-counter\"],\"actionIcon\":[1,\"action-icon\"],\"actionLoading\":[4,\"action-loading\"],\"submitButton\":[4,\"submit-button\"],\"showPasswordToggle\":[4,\"show-password-toggle\"],\"theme\":[1],\"showPassword\":[32],\"isClearable\":[32]},null,{\"showCounter\":[\"onShowCounterChange\"]}]]],[\"p-textarea.cjs\",[[81,\"p-textarea\",{\"label\":[1],\"description\":[1],\"name\":[513],\"value\":[1025],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"showCounter\":[4,\"show-counter\"],\"placeholder\":[1],\"required\":[4],\"disabled\":[4],\"maxLength\":[2,\"max-length\"],\"minLength\":[2,\"min-length\"],\"form\":[513],\"rows\":[2],\"autoComplete\":[1,\"auto-complete\"],\"spellCheck\":[4,\"spell-check\"],\"wrap\":[1],\"resize\":[1],\"readOnly\":[4,\"read-only\"],\"theme\":[1]},null,{\"value\":[\"onValueChange\"],\"maxLength\":[\"onMaxLengthChange\"],\"showCounter\":[\"onShowCounterChange\"]}]]],[\"p-textarea-wrapper.cjs\",[[1,\"p-textarea-wrapper\",{\"label\":[1],\"description\":[1],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"showCharacterCount\":[4,\"show-character-count\"],\"showCounter\":[4,\"show-counter\"],\"theme\":[1]},null,{\"showCounter\":[\"onShowCounterChange\"]}]]],[\"p-wordmark.cjs\",[[17,\"p-wordmark\",{\"size\":[1],\"theme\":[1],\"href\":[1],\"target\":[1],\"aria\":[1]}]]]]"), options);
	};

	loader_cjs.setNonce = validateProps.setNonce;
	loader_cjs.defineCustomElements = defineCustomElements;

	
	return loader_cjs;
}

var hasRequiredSrc;

function requireSrc () {
	if (hasRequiredSrc) return src;
	hasRequiredSrc = 1;
	// polyfills for features used by our components but unsupported within jest (jsdom)
	requireAdoptedStyleSheets();
	requireIntersectionObserver();
	requireMatchMedia();
	requireMatchMedia_addListener();
	requireDist();
	requirePopover();
	const ro = require$$6;

	commonjsGlobal.ResizeObserver = ro;

	if (!navigator.userAgent.includes('Node.js') && !navigator.userAgent.includes('jsdom')) {
	  throw new Error(
	    '[Porsche Design System] the jsdom-polyfill sub package should only be used in node and jsdom environments'
	  );
	}

	// skip initial stylesheet fetch
	window.PDS_SKIP_FETCH = true;

	// Since DSR conversion does not work in jsdom render client side markup instead
	process.browser = true;

	// jsdom polyfill build does not load anything from CDN and also does not use our web components manager
	// therefore, we have to setup the document.porscheDesignSystem ourselves here
	// '3.27.1' is replaced during build
	document.porscheDesignSystem = {
	  cdn: {
	    url: 'https://cdn.ui.porsche.com', // needs to be set because we're not initializing via components-js load() method which would normally set this
	    prefixes: [],
	  },
	  ['3.27.1']: {
	    readyResolve: () => {},
	    isReady: () => Promise.resolve(),
	  },
	};

	// workaround for WebComponentManager not working in jsdom because of missing <script type="module"> support
	// see: https://github.com/jsdom/jsdom/issues/2475
	requireLoader_cjs().defineCustomElements(); // this is executed synchronous since stencil v4

	window.PDS_SKIP_FETCH = false;
	return src;
}

var srcExports = requireSrc();
var index = /*@__PURE__*/getDefaultExportFromCjs(srcExports);

module.exports = index;
