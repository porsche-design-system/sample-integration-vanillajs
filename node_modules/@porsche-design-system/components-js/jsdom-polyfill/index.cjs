'use strict';

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var src = {};

var adoptedStyleSheets = {};

var hasRequiredAdoptedStyleSheets;

function requireAdoptedStyleSheets () {
	if (hasRequiredAdoptedStyleSheets) return adoptedStyleSheets;
	hasRequiredAdoptedStyleSheets = 1;
	(function () {

	    if (typeof document === 'undefined' || 'adoptedStyleSheets' in document) { return; }

	    var hasShadyCss = 'ShadyCSS' in window && !ShadyCSS.nativeShadow;
	    var bootstrapper = document.implementation.createHTMLDocument('');
	    var closedShadowRootRegistry = new WeakMap();
	    var _DOMException = typeof DOMException === 'object' ? Error : DOMException;
	    var defineProperty = Object.defineProperty;
	    var forEach = Array.prototype.forEach;

	    var importPattern = /@import.+?;?$/gm;
	    function rejectImports(contents) {
	        var _contents = contents.replace(importPattern, '');
	        if (_contents !== contents) {
	            console.warn('@import rules are not allowed here. See https://github.com/WICG/construct-stylesheets/issues/119#issuecomment-588352418');
	        }
	        return _contents.trim();
	    }
	    function isElementConnected(element) {
	        return 'isConnected' in element
	            ? element.isConnected
	            : document.contains(element);
	    }
	    function unique(arr) {
	        return arr.filter(function (value, index) { return arr.indexOf(value) === index; });
	    }
	    function diff(arr1, arr2) {
	        return arr1.filter(function (value) { return arr2.indexOf(value) === -1; });
	    }
	    function removeNode(node) {
	        node.parentNode.removeChild(node);
	    }
	    function getShadowRoot(element) {
	        return element.shadowRoot || closedShadowRootRegistry.get(element);
	    }

	    var cssStyleSheetMethods = [
	        'addRule',
	        'deleteRule',
	        'insertRule',
	        'removeRule',
	    ];
	    var NonConstructedStyleSheet = CSSStyleSheet;
	    var nonConstructedProto = NonConstructedStyleSheet.prototype;
	    nonConstructedProto.replace = function () {
	        return Promise.reject(new _DOMException("Can't call replace on non-constructed CSSStyleSheets."));
	    };
	    nonConstructedProto.replaceSync = function () {
	        throw new _DOMException("Failed to execute 'replaceSync' on 'CSSStyleSheet': Can't call replaceSync on non-constructed CSSStyleSheets.");
	    };
	    function isCSSStyleSheetInstance(instance) {
	        return typeof instance === 'object'
	            ? proto$1.isPrototypeOf(instance) ||
	                nonConstructedProto.isPrototypeOf(instance)
	            : false;
	    }
	    function isNonConstructedStyleSheetInstance(instance) {
	        return typeof instance === 'object'
	            ? nonConstructedProto.isPrototypeOf(instance)
	            : false;
	    }
	    var $basicStyleElement = new WeakMap();
	    var $locations = new WeakMap();
	    var $adoptersByLocation = new WeakMap();
	    var $appliedMethods = new WeakMap();
	    function addAdopterLocation(sheet, location) {
	        var adopter = document.createElement('style');
	        $adoptersByLocation.get(sheet).set(location, adopter);
	        $locations.get(sheet).push(location);
	        return adopter;
	    }
	    function getAdopterByLocation(sheet, location) {
	        return $adoptersByLocation.get(sheet).get(location);
	    }
	    function removeAdopterLocation(sheet, location) {
	        $adoptersByLocation.get(sheet).delete(location);
	        $locations.set(sheet, $locations.get(sheet).filter(function (_location) { return _location !== location; }));
	    }
	    function restyleAdopter(sheet, adopter) {
	        requestAnimationFrame(function () {
	            adopter.textContent = $basicStyleElement.get(sheet).textContent;
	            $appliedMethods
	                .get(sheet)
	                .forEach(function (command) {
	                return adopter.sheet[command.method].apply(adopter.sheet, command.args);
	            });
	        });
	    }
	    function checkInvocationCorrectness(self) {
	        if (!$basicStyleElement.has(self)) {
	            throw new TypeError('Illegal invocation');
	        }
	    }
	    function ConstructedStyleSheet() {
	        var self = this;
	        var style = document.createElement('style');
	        bootstrapper.body.appendChild(style);
	        $basicStyleElement.set(self, style);
	        $locations.set(self, []);
	        $adoptersByLocation.set(self, new WeakMap());
	        $appliedMethods.set(self, []);
	    }
	    var proto$1 = ConstructedStyleSheet.prototype;
	    proto$1.replace = function replace(contents) {
	        try {
	            this.replaceSync(contents);
	            return Promise.resolve(this);
	        }
	        catch (e) {
	            return Promise.reject(e);
	        }
	    };
	    proto$1.replaceSync = function replaceSync(contents) {
	        checkInvocationCorrectness(this);
	        if (typeof contents === 'string') {
	            var self_1 = this;
	            $basicStyleElement.get(self_1).textContent = rejectImports(contents);
	            $appliedMethods.set(self_1, []);
	            $locations.get(self_1).forEach(function (location) {
	                if (location.isConnected()) {
	                    restyleAdopter(self_1, getAdopterByLocation(self_1, location));
	                }
	            });
	        }
	    };
	    defineProperty(proto$1, 'cssRules', {
	        configurable: true,
	        enumerable: true,
	        get: function cssRules() {
	            checkInvocationCorrectness(this);
	            return $basicStyleElement.get(this).sheet.cssRules;
	        },
	    });
	    defineProperty(proto$1, 'media', {
	        configurable: true,
	        enumerable: true,
	        get: function media() {
	            checkInvocationCorrectness(this);
	            return $basicStyleElement.get(this).sheet.media;
	        },
	    });
	    cssStyleSheetMethods.forEach(function (method) {
	        proto$1[method] = function () {
	            var self = this;
	            checkInvocationCorrectness(self);
	            var args = arguments;
	            $appliedMethods.get(self).push({ method: method, args: args });
	            $locations.get(self).forEach(function (location) {
	                if (location.isConnected()) {
	                    var sheet = getAdopterByLocation(self, location).sheet;
	                    sheet[method].apply(sheet, args);
	                }
	            });
	            var basicSheet = $basicStyleElement.get(self).sheet;
	            return basicSheet[method].apply(basicSheet, args);
	        };
	    });
	    defineProperty(ConstructedStyleSheet, Symbol.hasInstance, {
	        configurable: true,
	        value: isCSSStyleSheetInstance,
	    });

	    var defaultObserverOptions = {
	        childList: true,
	        subtree: true,
	    };
	    var locations = new WeakMap();
	    function getAssociatedLocation(element) {
	        var location = locations.get(element);
	        if (!location) {
	            location = new Location(element);
	            locations.set(element, location);
	        }
	        return location;
	    }
	    function attachAdoptedStyleSheetProperty(constructor) {
	        defineProperty(constructor.prototype, 'adoptedStyleSheets', {
	            configurable: true,
	            enumerable: true,
	            get: function () {
	                return getAssociatedLocation(this).sheets;
	            },
	            set: function (sheets) {
	                getAssociatedLocation(this).update(sheets);
	            },
	        });
	    }
	    function traverseWebComponents(node, callback) {
	        var iter = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT, function (foundNode) {
	            return getShadowRoot(foundNode)
	                ? NodeFilter.FILTER_ACCEPT
	                : NodeFilter.FILTER_REJECT;
	        },
	        null, false);
	        for (var next = void 0; (next = iter.nextNode());) {
	            callback(getShadowRoot(next));
	        }
	    }
	    var $element = new WeakMap();
	    var $uniqueSheets = new WeakMap();
	    var $observer = new WeakMap();
	    function isExistingAdopter(self, element) {
	        return (element instanceof HTMLStyleElement &&
	            $uniqueSheets.get(self).some(function (sheet) { return getAdopterByLocation(sheet, self); }));
	    }
	    function getAdopterContainer(self) {
	        var element = $element.get(self);
	        return element instanceof Document ? element.body : element;
	    }
	    function adopt(self) {
	        var styleList = document.createDocumentFragment();
	        var sheets = $uniqueSheets.get(self);
	        var observer = $observer.get(self);
	        var container = getAdopterContainer(self);
	        observer.disconnect();
	        sheets.forEach(function (sheet) {
	            styleList.appendChild(getAdopterByLocation(sheet, self) || addAdopterLocation(sheet, self));
	        });
	        container.insertBefore(styleList, null);
	        observer.observe(container, defaultObserverOptions);
	        sheets.forEach(function (sheet) {
	            restyleAdopter(sheet, getAdopterByLocation(sheet, self));
	        });
	    }
	    function Location(element) {
	        var self = this;
	        self.sheets = [];
	        $element.set(self, element);
	        $uniqueSheets.set(self, []);
	        $observer.set(self, new MutationObserver(function (mutations, observer) {
	            if (!document) {
	                observer.disconnect();
	                return;
	            }
	            mutations.forEach(function (mutation) {
	                if (!hasShadyCss) {
	                    forEach.call(mutation.addedNodes, function (node) {
	                        if (!(node instanceof Element)) {
	                            return;
	                        }
	                        traverseWebComponents(node, function (root) {
	                            getAssociatedLocation(root).connect();
	                        });
	                    });
	                }
	                forEach.call(mutation.removedNodes, function (node) {
	                    if (!(node instanceof Element)) {
	                        return;
	                    }
	                    if (isExistingAdopter(self, node)) {
	                        adopt(self);
	                    }
	                    if (!hasShadyCss) {
	                        traverseWebComponents(node, function (root) {
	                            getAssociatedLocation(root).disconnect();
	                        });
	                    }
	                });
	            });
	        }));
	    }
	    Location.prototype = {
	        isConnected: function () {
	            var element = $element.get(this);
	            return element instanceof Document
	                ? element.readyState !== 'loading'
	                : isElementConnected(element.host);
	        },
	        connect: function () {
	            var container = getAdopterContainer(this);
	            $observer.get(this).observe(container, defaultObserverOptions);
	            if ($uniqueSheets.get(this).length > 0) {
	                adopt(this);
	            }
	            traverseWebComponents(container, function (root) {
	                getAssociatedLocation(root).connect();
	            });
	        },
	        disconnect: function () {
	            $observer.get(this).disconnect();
	        },
	        update: function (sheets) {
	            var self = this;
	            var locationType = $element.get(self) === document ? 'Document' : 'ShadowRoot';
	            if (!Array.isArray(sheets)) {
	                throw new TypeError("Failed to set the 'adoptedStyleSheets' property on " + locationType + ": Iterator getter is not callable.");
	            }
	            if (!sheets.every(isCSSStyleSheetInstance)) {
	                throw new TypeError("Failed to set the 'adoptedStyleSheets' property on " + locationType + ": Failed to convert value to 'CSSStyleSheet'");
	            }
	            if (sheets.some(isNonConstructedStyleSheetInstance)) {
	                throw new TypeError("Failed to set the 'adoptedStyleSheets' property on " + locationType + ": Can't adopt non-constructed stylesheets");
	            }
	            self.sheets = sheets;
	            var oldUniqueSheets = $uniqueSheets.get(self);
	            var uniqueSheets = unique(sheets);
	            var removedSheets = diff(oldUniqueSheets, uniqueSheets);
	            removedSheets.forEach(function (sheet) {
	                removeNode(getAdopterByLocation(sheet, self));
	                removeAdopterLocation(sheet, self);
	            });
	            $uniqueSheets.set(self, uniqueSheets);
	            if (self.isConnected() && uniqueSheets.length > 0) {
	                adopt(self);
	            }
	        },
	    };

	    window.CSSStyleSheet = ConstructedStyleSheet;
	    attachAdoptedStyleSheetProperty(Document);
	    if ('ShadowRoot' in window) {
	        attachAdoptedStyleSheetProperty(ShadowRoot);
	        var proto = Element.prototype;
	        var attach_1 = proto.attachShadow;
	        proto.attachShadow = function attachShadow(init) {
	            var root = attach_1.call(this, init);
	            if (init.mode === 'closed') {
	                closedShadowRootRegistry.set(this, root);
	            }
	            return root;
	        };
	    }
	    var documentLocation = getAssociatedLocation(document);
	    if (documentLocation.isConnected()) {
	        documentLocation.connect();
	    }
	    else {
	        document.addEventListener('DOMContentLoaded', documentLocation.connect.bind(documentLocation));
	    }

	}());
	return adoptedStyleSheets;
}

var intersectionObserver = {};

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.
 *
 *  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 *
 */

var hasRequiredIntersectionObserver;

function requireIntersectionObserver () {
	if (hasRequiredIntersectionObserver) return intersectionObserver;
	hasRequiredIntersectionObserver = 1;
	(function() {

	// Exit early if we're not running in a browser.
	if (typeof window !== 'object') {
	  return;
	}

	// Exit early if all IntersectionObserver and IntersectionObserverEntry
	// features are natively supported.
	if ('IntersectionObserver' in window &&
	    'IntersectionObserverEntry' in window &&
	    'intersectionRatio' in window.IntersectionObserverEntry.prototype) {

	  // Minimal polyfill for Edge 15's lack of `isIntersecting`
	  // See: https://github.com/w3c/IntersectionObserver/issues/211
	  if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {
	    Object.defineProperty(window.IntersectionObserverEntry.prototype,
	      'isIntersecting', {
	      get: function () {
	        return this.intersectionRatio > 0;
	      }
	    });
	  }
	  return;
	}

	/**
	 * Returns the embedding frame element, if any.
	 * @param {!Document} doc
	 * @return {!Element}
	 */
	function getFrameElement(doc) {
	  try {
	    return doc.defaultView && doc.defaultView.frameElement || null;
	  } catch (e) {
	    // Ignore the error.
	    return null;
	  }
	}

	/**
	 * A local reference to the root document.
	 */
	var document = (function(startDoc) {
	  var doc = startDoc;
	  var frame = getFrameElement(doc);
	  while (frame) {
	    doc = frame.ownerDocument;
	    frame = getFrameElement(doc);
	  }
	  return doc;
	})(window.document);

	/**
	 * An IntersectionObserver registry. This registry exists to hold a strong
	 * reference to IntersectionObserver instances currently observing a target
	 * element. Without this registry, instances without another reference may be
	 * garbage collected.
	 */
	var registry = [];

	/**
	 * The signal updater for cross-origin intersection. When not null, it means
	 * that the polyfill is configured to work in a cross-origin mode.
	 * @type {function(DOMRect|ClientRect, DOMRect|ClientRect)}
	 */
	var crossOriginUpdater = null;

	/**
	 * The current cross-origin intersection. Only used in the cross-origin mode.
	 * @type {DOMRect|ClientRect}
	 */
	var crossOriginRect = null;


	/**
	 * Creates the global IntersectionObserverEntry constructor.
	 * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry
	 * @param {Object} entry A dictionary of instance properties.
	 * @constructor
	 */
	function IntersectionObserverEntry(entry) {
	  this.time = entry.time;
	  this.target = entry.target;
	  this.rootBounds = ensureDOMRect(entry.rootBounds);
	  this.boundingClientRect = ensureDOMRect(entry.boundingClientRect);
	  this.intersectionRect = ensureDOMRect(entry.intersectionRect || getEmptyRect());
	  this.isIntersecting = !!entry.intersectionRect;

	  // Calculates the intersection ratio.
	  var targetRect = this.boundingClientRect;
	  var targetArea = targetRect.width * targetRect.height;
	  var intersectionRect = this.intersectionRect;
	  var intersectionArea = intersectionRect.width * intersectionRect.height;

	  // Sets intersection ratio.
	  if (targetArea) {
	    // Round the intersection ratio to avoid floating point math issues:
	    // https://github.com/w3c/IntersectionObserver/issues/324
	    this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4));
	  } else {
	    // If area is zero and is intersecting, sets to 1, otherwise to 0
	    this.intersectionRatio = this.isIntersecting ? 1 : 0;
	  }
	}


	/**
	 * Creates the global IntersectionObserver constructor.
	 * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface
	 * @param {Function} callback The function to be invoked after intersection
	 *     changes have queued. The function is not invoked if the queue has
	 *     been emptied by calling the `takeRecords` method.
	 * @param {Object=} opt_options Optional configuration options.
	 * @constructor
	 */
	function IntersectionObserver(callback, opt_options) {

	  var options = opt_options || {};

	  if (typeof callback != 'function') {
	    throw new Error('callback must be a function');
	  }

	  if (
	    options.root &&
	    options.root.nodeType != 1 &&
	    options.root.nodeType != 9
	  ) {
	    throw new Error('root must be a Document or Element');
	  }

	  // Binds and throttles `this._checkForIntersections`.
	  this._checkForIntersections = throttle(
	      this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);

	  // Private properties.
	  this._callback = callback;
	  this._observationTargets = [];
	  this._queuedEntries = [];
	  this._rootMarginValues = this._parseRootMargin(options.rootMargin);

	  // Public properties.
	  this.thresholds = this._initThresholds(options.threshold);
	  this.root = options.root || null;
	  this.rootMargin = this._rootMarginValues.map(function(margin) {
	    return margin.value + margin.unit;
	  }).join(' ');

	  /** @private @const {!Array<!Document>} */
	  this._monitoringDocuments = [];
	  /** @private @const {!Array<function()>} */
	  this._monitoringUnsubscribes = [];
	}


	/**
	 * The minimum interval within which the document will be checked for
	 * intersection changes.
	 */
	IntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;


	/**
	 * The frequency in which the polyfill polls for intersection changes.
	 * this can be updated on a per instance basis and must be set prior to
	 * calling `observe` on the first target.
	 */
	IntersectionObserver.prototype.POLL_INTERVAL = null;

	/**
	 * Use a mutation observer on the root element
	 * to detect intersection changes.
	 */
	IntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;


	/**
	 * Sets up the polyfill in the cross-origin mode. The result is the
	 * updater function that accepts two arguments: `boundingClientRect` and
	 * `intersectionRect` - just as these fields would be available to the
	 * parent via `IntersectionObserverEntry`. This function should be called
	 * each time the iframe receives intersection information from the parent
	 * window, e.g. via messaging.
	 * @return {function(DOMRect|ClientRect, DOMRect|ClientRect)}
	 */
	IntersectionObserver._setupCrossOriginUpdater = function() {
	  if (!crossOriginUpdater) {
	    /**
	     * @param {DOMRect|ClientRect} boundingClientRect
	     * @param {DOMRect|ClientRect} intersectionRect
	     */
	    crossOriginUpdater = function(boundingClientRect, intersectionRect) {
	      if (!boundingClientRect || !intersectionRect) {
	        crossOriginRect = getEmptyRect();
	      } else {
	        crossOriginRect = convertFromParentRect(boundingClientRect, intersectionRect);
	      }
	      registry.forEach(function(observer) {
	        observer._checkForIntersections();
	      });
	    };
	  }
	  return crossOriginUpdater;
	};


	/**
	 * Resets the cross-origin mode.
	 */
	IntersectionObserver._resetCrossOriginUpdater = function() {
	  crossOriginUpdater = null;
	  crossOriginRect = null;
	};


	/**
	 * Starts observing a target element for intersection changes based on
	 * the thresholds values.
	 * @param {Element} target The DOM element to observe.
	 */
	IntersectionObserver.prototype.observe = function(target) {
	  var isTargetAlreadyObserved = this._observationTargets.some(function(item) {
	    return item.element == target;
	  });

	  if (isTargetAlreadyObserved) {
	    return;
	  }

	  if (!(target && target.nodeType == 1)) {
	    throw new Error('target must be an Element');
	  }

	  this._registerInstance();
	  this._observationTargets.push({element: target, entry: null});
	  this._monitorIntersections(target.ownerDocument);
	  this._checkForIntersections();
	};


	/**
	 * Stops observing a target element for intersection changes.
	 * @param {Element} target The DOM element to observe.
	 */
	IntersectionObserver.prototype.unobserve = function(target) {
	  this._observationTargets =
	      this._observationTargets.filter(function(item) {
	        return item.element != target;
	      });
	  this._unmonitorIntersections(target.ownerDocument);
	  if (this._observationTargets.length == 0) {
	    this._unregisterInstance();
	  }
	};


	/**
	 * Stops observing all target elements for intersection changes.
	 */
	IntersectionObserver.prototype.disconnect = function() {
	  this._observationTargets = [];
	  this._unmonitorAllIntersections();
	  this._unregisterInstance();
	};


	/**
	 * Returns any queue entries that have not yet been reported to the
	 * callback and clears the queue. This can be used in conjunction with the
	 * callback to obtain the absolute most up-to-date intersection information.
	 * @return {Array} The currently queued entries.
	 */
	IntersectionObserver.prototype.takeRecords = function() {
	  var records = this._queuedEntries.slice();
	  this._queuedEntries = [];
	  return records;
	};


	/**
	 * Accepts the threshold value from the user configuration object and
	 * returns a sorted array of unique threshold values. If a value is not
	 * between 0 and 1 and error is thrown.
	 * @private
	 * @param {Array|number=} opt_threshold An optional threshold value or
	 *     a list of threshold values, defaulting to [0].
	 * @return {Array} A sorted list of unique and valid threshold values.
	 */
	IntersectionObserver.prototype._initThresholds = function(opt_threshold) {
	  var threshold = opt_threshold || [0];
	  if (!Array.isArray(threshold)) threshold = [threshold];

	  return threshold.sort().filter(function(t, i, a) {
	    if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {
	      throw new Error('threshold must be a number between 0 and 1 inclusively');
	    }
	    return t !== a[i - 1];
	  });
	};


	/**
	 * Accepts the rootMargin value from the user configuration object
	 * and returns an array of the four margin values as an object containing
	 * the value and unit properties. If any of the values are not properly
	 * formatted or use a unit other than px or %, and error is thrown.
	 * @private
	 * @param {string=} opt_rootMargin An optional rootMargin value,
	 *     defaulting to '0px'.
	 * @return {Array<Object>} An array of margin objects with the keys
	 *     value and unit.
	 */
	IntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {
	  var marginString = opt_rootMargin || '0px';
	  var margins = marginString.split(/\s+/).map(function(margin) {
	    var parts = /^(-?\d*\.?\d+)(px|%)$/.exec(margin);
	    if (!parts) {
	      throw new Error('rootMargin must be specified in pixels or percent');
	    }
	    return {value: parseFloat(parts[1]), unit: parts[2]};
	  });

	  // Handles shorthand.
	  margins[1] = margins[1] || margins[0];
	  margins[2] = margins[2] || margins[0];
	  margins[3] = margins[3] || margins[1];

	  return margins;
	};


	/**
	 * Starts polling for intersection changes if the polling is not already
	 * happening, and if the page's visibility state is visible.
	 * @param {!Document} doc
	 * @private
	 */
	IntersectionObserver.prototype._monitorIntersections = function(doc) {
	  var win = doc.defaultView;
	  if (!win) {
	    // Already destroyed.
	    return;
	  }
	  if (this._monitoringDocuments.indexOf(doc) != -1) {
	    // Already monitoring.
	    return;
	  }

	  // Private state for monitoring.
	  var callback = this._checkForIntersections;
	  var monitoringInterval = null;
	  var domObserver = null;

	  // If a poll interval is set, use polling instead of listening to
	  // resize and scroll events or DOM mutations.
	  if (this.POLL_INTERVAL) {
	    monitoringInterval = win.setInterval(callback, this.POLL_INTERVAL);
	  } else {
	    addEvent(win, 'resize', callback, true);
	    addEvent(doc, 'scroll', callback, true);
	    if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in win) {
	      domObserver = new win.MutationObserver(callback);
	      domObserver.observe(doc, {
	        attributes: true,
	        childList: true,
	        characterData: true,
	        subtree: true
	      });
	    }
	  }

	  this._monitoringDocuments.push(doc);
	  this._monitoringUnsubscribes.push(function() {
	    // Get the window object again. When a friendly iframe is destroyed, it
	    // will be null.
	    var win = doc.defaultView;

	    if (win) {
	      if (monitoringInterval) {
	        win.clearInterval(monitoringInterval);
	      }
	      removeEvent(win, 'resize', callback, true);
	    }

	    removeEvent(doc, 'scroll', callback, true);
	    if (domObserver) {
	      domObserver.disconnect();
	    }
	  });

	  // Also monitor the parent.
	  var rootDoc =
	    (this.root && (this.root.ownerDocument || this.root)) || document;
	  if (doc != rootDoc) {
	    var frame = getFrameElement(doc);
	    if (frame) {
	      this._monitorIntersections(frame.ownerDocument);
	    }
	  }
	};


	/**
	 * Stops polling for intersection changes.
	 * @param {!Document} doc
	 * @private
	 */
	IntersectionObserver.prototype._unmonitorIntersections = function(doc) {
	  var index = this._monitoringDocuments.indexOf(doc);
	  if (index == -1) {
	    return;
	  }

	  var rootDoc =
	    (this.root && (this.root.ownerDocument || this.root)) || document;

	  // Check if any dependent targets are still remaining.
	  var hasDependentTargets =
	      this._observationTargets.some(function(item) {
	        var itemDoc = item.element.ownerDocument;
	        // Target is in this context.
	        if (itemDoc == doc) {
	          return true;
	        }
	        // Target is nested in this context.
	        while (itemDoc && itemDoc != rootDoc) {
	          var frame = getFrameElement(itemDoc);
	          itemDoc = frame && frame.ownerDocument;
	          if (itemDoc == doc) {
	            return true;
	          }
	        }
	        return false;
	      });
	  if (hasDependentTargets) {
	    return;
	  }

	  // Unsubscribe.
	  var unsubscribe = this._monitoringUnsubscribes[index];
	  this._monitoringDocuments.splice(index, 1);
	  this._monitoringUnsubscribes.splice(index, 1);
	  unsubscribe();

	  // Also unmonitor the parent.
	  if (doc != rootDoc) {
	    var frame = getFrameElement(doc);
	    if (frame) {
	      this._unmonitorIntersections(frame.ownerDocument);
	    }
	  }
	};


	/**
	 * Stops polling for intersection changes.
	 * @param {!Document} doc
	 * @private
	 */
	IntersectionObserver.prototype._unmonitorAllIntersections = function() {
	  var unsubscribes = this._monitoringUnsubscribes.slice(0);
	  this._monitoringDocuments.length = 0;
	  this._monitoringUnsubscribes.length = 0;
	  for (var i = 0; i < unsubscribes.length; i++) {
	    unsubscribes[i]();
	  }
	};


	/**
	 * Scans each observation target for intersection changes and adds them
	 * to the internal entries queue. If new entries are found, it
	 * schedules the callback to be invoked.
	 * @private
	 */
	IntersectionObserver.prototype._checkForIntersections = function() {
	  if (!this.root && crossOriginUpdater && !crossOriginRect) {
	    // Cross origin monitoring, but no initial data available yet.
	    return;
	  }

	  var rootIsInDom = this._rootIsInDom();
	  var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();

	  this._observationTargets.forEach(function(item) {
	    var target = item.element;
	    var targetRect = getBoundingClientRect(target);
	    var rootContainsTarget = this._rootContainsTarget(target);
	    var oldEntry = item.entry;
	    var intersectionRect = rootIsInDom && rootContainsTarget &&
	        this._computeTargetAndRootIntersection(target, targetRect, rootRect);

	    var rootBounds = null;
	    if (!this._rootContainsTarget(target)) {
	      rootBounds = getEmptyRect();
	    } else if (!crossOriginUpdater || this.root) {
	      rootBounds = rootRect;
	    }

	    var newEntry = item.entry = new IntersectionObserverEntry({
	      time: now(),
	      target: target,
	      boundingClientRect: targetRect,
	      rootBounds: rootBounds,
	      intersectionRect: intersectionRect
	    });

	    if (!oldEntry) {
	      this._queuedEntries.push(newEntry);
	    } else if (rootIsInDom && rootContainsTarget) {
	      // If the new entry intersection ratio has crossed any of the
	      // thresholds, add a new entry.
	      if (this._hasCrossedThreshold(oldEntry, newEntry)) {
	        this._queuedEntries.push(newEntry);
	      }
	    } else {
	      // If the root is not in the DOM or target is not contained within
	      // root but the previous entry for this target had an intersection,
	      // add a new record indicating removal.
	      if (oldEntry && oldEntry.isIntersecting) {
	        this._queuedEntries.push(newEntry);
	      }
	    }
	  }, this);

	  if (this._queuedEntries.length) {
	    this._callback(this.takeRecords(), this);
	  }
	};


	/**
	 * Accepts a target and root rect computes the intersection between then
	 * following the algorithm in the spec.
	 * TODO(philipwalton): at this time clip-path is not considered.
	 * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo
	 * @param {Element} target The target DOM element
	 * @param {Object} targetRect The bounding rect of the target.
	 * @param {Object} rootRect The bounding rect of the root after being
	 *     expanded by the rootMargin value.
	 * @return {?Object} The final intersection rect object or undefined if no
	 *     intersection is found.
	 * @private
	 */
	IntersectionObserver.prototype._computeTargetAndRootIntersection =
	    function(target, targetRect, rootRect) {
	  // If the element isn't displayed, an intersection can't happen.
	  if (window.getComputedStyle(target).display == 'none') return;

	  var intersectionRect = targetRect;
	  var parent = getParentNode(target);
	  var atRoot = false;

	  while (!atRoot && parent) {
	    var parentRect = null;
	    var parentComputedStyle = parent.nodeType == 1 ?
	        window.getComputedStyle(parent) : {};

	    // If the parent isn't displayed, an intersection can't happen.
	    if (parentComputedStyle.display == 'none') return null;

	    if (parent == this.root || parent.nodeType == /* DOCUMENT */ 9) {
	      atRoot = true;
	      if (parent == this.root || parent == document) {
	        if (crossOriginUpdater && !this.root) {
	          if (!crossOriginRect ||
	              crossOriginRect.width == 0 && crossOriginRect.height == 0) {
	            // A 0-size cross-origin intersection means no-intersection.
	            parent = null;
	            parentRect = null;
	            intersectionRect = null;
	          } else {
	            parentRect = crossOriginRect;
	          }
	        } else {
	          parentRect = rootRect;
	        }
	      } else {
	        // Check if there's a frame that can be navigated to.
	        var frame = getParentNode(parent);
	        var frameRect = frame && getBoundingClientRect(frame);
	        var frameIntersect =
	            frame &&
	            this._computeTargetAndRootIntersection(frame, frameRect, rootRect);
	        if (frameRect && frameIntersect) {
	          parent = frame;
	          parentRect = convertFromParentRect(frameRect, frameIntersect);
	        } else {
	          parent = null;
	          intersectionRect = null;
	        }
	      }
	    } else {
	      // If the element has a non-visible overflow, and it's not the <body>
	      // or <html> element, update the intersection rect.
	      // Note: <body> and <html> cannot be clipped to a rect that's not also
	      // the document rect, so no need to compute a new intersection.
	      var doc = parent.ownerDocument;
	      if (parent != doc.body &&
	          parent != doc.documentElement &&
	          parentComputedStyle.overflow != 'visible') {
	        parentRect = getBoundingClientRect(parent);
	      }
	    }

	    // If either of the above conditionals set a new parentRect,
	    // calculate new intersection data.
	    if (parentRect) {
	      intersectionRect = computeRectIntersection(parentRect, intersectionRect);
	    }
	    if (!intersectionRect) break;
	    parent = parent && getParentNode(parent);
	  }
	  return intersectionRect;
	};


	/**
	 * Returns the root rect after being expanded by the rootMargin value.
	 * @return {ClientRect} The expanded root rect.
	 * @private
	 */
	IntersectionObserver.prototype._getRootRect = function() {
	  var rootRect;
	  if (this.root && !isDoc(this.root)) {
	    rootRect = getBoundingClientRect(this.root);
	  } else {
	    // Use <html>/<body> instead of window since scroll bars affect size.
	    var doc = isDoc(this.root) ? this.root : document;
	    var html = doc.documentElement;
	    var body = doc.body;
	    rootRect = {
	      top: 0,
	      left: 0,
	      right: html.clientWidth || body.clientWidth,
	      width: html.clientWidth || body.clientWidth,
	      bottom: html.clientHeight || body.clientHeight,
	      height: html.clientHeight || body.clientHeight
	    };
	  }
	  return this._expandRectByRootMargin(rootRect);
	};


	/**
	 * Accepts a rect and expands it by the rootMargin value.
	 * @param {DOMRect|ClientRect} rect The rect object to expand.
	 * @return {ClientRect} The expanded rect.
	 * @private
	 */
	IntersectionObserver.prototype._expandRectByRootMargin = function(rect) {
	  var margins = this._rootMarginValues.map(function(margin, i) {
	    return margin.unit == 'px' ? margin.value :
	        margin.value * (i % 2 ? rect.width : rect.height) / 100;
	  });
	  var newRect = {
	    top: rect.top - margins[0],
	    right: rect.right + margins[1],
	    bottom: rect.bottom + margins[2],
	    left: rect.left - margins[3]
	  };
	  newRect.width = newRect.right - newRect.left;
	  newRect.height = newRect.bottom - newRect.top;

	  return newRect;
	};


	/**
	 * Accepts an old and new entry and returns true if at least one of the
	 * threshold values has been crossed.
	 * @param {?IntersectionObserverEntry} oldEntry The previous entry for a
	 *    particular target element or null if no previous entry exists.
	 * @param {IntersectionObserverEntry} newEntry The current entry for a
	 *    particular target element.
	 * @return {boolean} Returns true if a any threshold has been crossed.
	 * @private
	 */
	IntersectionObserver.prototype._hasCrossedThreshold =
	    function(oldEntry, newEntry) {

	  // To make comparing easier, an entry that has a ratio of 0
	  // but does not actually intersect is given a value of -1
	  var oldRatio = oldEntry && oldEntry.isIntersecting ?
	      oldEntry.intersectionRatio || 0 : -1;
	  var newRatio = newEntry.isIntersecting ?
	      newEntry.intersectionRatio || 0 : -1;

	  // Ignore unchanged ratios
	  if (oldRatio === newRatio) return;

	  for (var i = 0; i < this.thresholds.length; i++) {
	    var threshold = this.thresholds[i];

	    // Return true if an entry matches a threshold or if the new ratio
	    // and the old ratio are on the opposite sides of a threshold.
	    if (threshold == oldRatio || threshold == newRatio ||
	        threshold < oldRatio !== threshold < newRatio) {
	      return true;
	    }
	  }
	};


	/**
	 * Returns whether or not the root element is an element and is in the DOM.
	 * @return {boolean} True if the root element is an element and is in the DOM.
	 * @private
	 */
	IntersectionObserver.prototype._rootIsInDom = function() {
	  return !this.root || containsDeep(document, this.root);
	};


	/**
	 * Returns whether or not the target element is a child of root.
	 * @param {Element} target The target element to check.
	 * @return {boolean} True if the target element is a child of root.
	 * @private
	 */
	IntersectionObserver.prototype._rootContainsTarget = function(target) {
	  var rootDoc =
	    (this.root && (this.root.ownerDocument || this.root)) || document;
	  return (
	    containsDeep(rootDoc, target) &&
	    (!this.root || rootDoc == target.ownerDocument)
	  );
	};


	/**
	 * Adds the instance to the global IntersectionObserver registry if it isn't
	 * already present.
	 * @private
	 */
	IntersectionObserver.prototype._registerInstance = function() {
	  if (registry.indexOf(this) < 0) {
	    registry.push(this);
	  }
	};


	/**
	 * Removes the instance from the global IntersectionObserver registry.
	 * @private
	 */
	IntersectionObserver.prototype._unregisterInstance = function() {
	  var index = registry.indexOf(this);
	  if (index != -1) registry.splice(index, 1);
	};


	/**
	 * Returns the result of the performance.now() method or null in browsers
	 * that don't support the API.
	 * @return {number} The elapsed time since the page was requested.
	 */
	function now() {
	  return window.performance && performance.now && performance.now();
	}


	/**
	 * Throttles a function and delays its execution, so it's only called at most
	 * once within a given time period.
	 * @param {Function} fn The function to throttle.
	 * @param {number} timeout The amount of time that must pass before the
	 *     function can be called again.
	 * @return {Function} The throttled function.
	 */
	function throttle(fn, timeout) {
	  var timer = null;
	  return function () {
	    if (!timer) {
	      timer = setTimeout(function() {
	        fn();
	        timer = null;
	      }, timeout);
	    }
	  };
	}


	/**
	 * Adds an event handler to a DOM node ensuring cross-browser compatibility.
	 * @param {Node} node The DOM node to add the event handler to.
	 * @param {string} event The event name.
	 * @param {Function} fn The event handler to add.
	 * @param {boolean} opt_useCapture Optionally adds the even to the capture
	 *     phase. Note: this only works in modern browsers.
	 */
	function addEvent(node, event, fn, opt_useCapture) {
	  if (typeof node.addEventListener == 'function') {
	    node.addEventListener(event, fn, opt_useCapture || false);
	  }
	  else if (typeof node.attachEvent == 'function') {
	    node.attachEvent('on' + event, fn);
	  }
	}


	/**
	 * Removes a previously added event handler from a DOM node.
	 * @param {Node} node The DOM node to remove the event handler from.
	 * @param {string} event The event name.
	 * @param {Function} fn The event handler to remove.
	 * @param {boolean} opt_useCapture If the event handler was added with this
	 *     flag set to true, it should be set to true here in order to remove it.
	 */
	function removeEvent(node, event, fn, opt_useCapture) {
	  if (typeof node.removeEventListener == 'function') {
	    node.removeEventListener(event, fn, opt_useCapture || false);
	  }
	  else if (typeof node.detachEvent == 'function') {
	    node.detachEvent('on' + event, fn);
	  }
	}


	/**
	 * Returns the intersection between two rect objects.
	 * @param {Object} rect1 The first rect.
	 * @param {Object} rect2 The second rect.
	 * @return {?Object|?ClientRect} The intersection rect or undefined if no
	 *     intersection is found.
	 */
	function computeRectIntersection(rect1, rect2) {
	  var top = Math.max(rect1.top, rect2.top);
	  var bottom = Math.min(rect1.bottom, rect2.bottom);
	  var left = Math.max(rect1.left, rect2.left);
	  var right = Math.min(rect1.right, rect2.right);
	  var width = right - left;
	  var height = bottom - top;

	  return (width >= 0 && height >= 0) && {
	    top: top,
	    bottom: bottom,
	    left: left,
	    right: right,
	    width: width,
	    height: height
	  } || null;
	}


	/**
	 * Shims the native getBoundingClientRect for compatibility with older IE.
	 * @param {Element} el The element whose bounding rect to get.
	 * @return {DOMRect|ClientRect} The (possibly shimmed) rect of the element.
	 */
	function getBoundingClientRect(el) {
	  var rect;

	  try {
	    rect = el.getBoundingClientRect();
	  } catch (err) {
	    // Ignore Windows 7 IE11 "Unspecified error"
	    // https://github.com/w3c/IntersectionObserver/pull/205
	  }

	  if (!rect) return getEmptyRect();

	  // Older IE
	  if (!(rect.width && rect.height)) {
	    rect = {
	      top: rect.top,
	      right: rect.right,
	      bottom: rect.bottom,
	      left: rect.left,
	      width: rect.right - rect.left,
	      height: rect.bottom - rect.top
	    };
	  }
	  return rect;
	}


	/**
	 * Returns an empty rect object. An empty rect is returned when an element
	 * is not in the DOM.
	 * @return {ClientRect} The empty rect.
	 */
	function getEmptyRect() {
	  return {
	    top: 0,
	    bottom: 0,
	    left: 0,
	    right: 0,
	    width: 0,
	    height: 0
	  };
	}


	/**
	 * Ensure that the result has all of the necessary fields of the DOMRect.
	 * Specifically this ensures that `x` and `y` fields are set.
	 *
	 * @param {?DOMRect|?ClientRect} rect
	 * @return {?DOMRect}
	 */
	function ensureDOMRect(rect) {
	  // A `DOMRect` object has `x` and `y` fields.
	  if (!rect || 'x' in rect) {
	    return rect;
	  }
	  // A IE's `ClientRect` type does not have `x` and `y`. The same is the case
	  // for internally calculated Rect objects. For the purposes of
	  // `IntersectionObserver`, it's sufficient to simply mirror `left` and `top`
	  // for these fields.
	  return {
	    top: rect.top,
	    y: rect.top,
	    bottom: rect.bottom,
	    left: rect.left,
	    x: rect.left,
	    right: rect.right,
	    width: rect.width,
	    height: rect.height
	  };
	}


	/**
	 * Inverts the intersection and bounding rect from the parent (frame) BCR to
	 * the local BCR space.
	 * @param {DOMRect|ClientRect} parentBoundingRect The parent's bound client rect.
	 * @param {DOMRect|ClientRect} parentIntersectionRect The parent's own intersection rect.
	 * @return {ClientRect} The local root bounding rect for the parent's children.
	 */
	function convertFromParentRect(parentBoundingRect, parentIntersectionRect) {
	  var top = parentIntersectionRect.top - parentBoundingRect.top;
	  var left = parentIntersectionRect.left - parentBoundingRect.left;
	  return {
	    top: top,
	    left: left,
	    height: parentIntersectionRect.height,
	    width: parentIntersectionRect.width,
	    bottom: top + parentIntersectionRect.height,
	    right: left + parentIntersectionRect.width
	  };
	}


	/**
	 * Checks to see if a parent element contains a child element (including inside
	 * shadow DOM).
	 * @param {Node} parent The parent element.
	 * @param {Node} child The child element.
	 * @return {boolean} True if the parent node contains the child node.
	 */
	function containsDeep(parent, child) {
	  var node = child;
	  while (node) {
	    if (node == parent) return true;

	    node = getParentNode(node);
	  }
	  return false;
	}


	/**
	 * Gets the parent node of an element or its host element if the parent node
	 * is a shadow root.
	 * @param {Node} node The node whose parent to get.
	 * @return {Node|null} The parent node or null if no parent exists.
	 */
	function getParentNode(node) {
	  var parent = node.parentNode;

	  if (node.nodeType == /* DOCUMENT */ 9 && node != document) {
	    // If this node is a document node, look for the embedding frame.
	    return getFrameElement(node);
	  }

	  // If the parent has element that is assigned through shadow root slot
	  if (parent && parent.assignedSlot) {
	    parent = parent.assignedSlot.parentNode;
	  }

	  if (parent && parent.nodeType == 11 && parent.host) {
	    // If the parent is a shadow root, return the host element.
	    return parent.host;
	  }

	  return parent;
	}

	/**
	 * Returns true if `node` is a Document.
	 * @param {!Node} node
	 * @returns {boolean}
	 */
	function isDoc(node) {
	  return node && node.nodeType === 9;
	}


	// Exposes the constructors globally.
	window.IntersectionObserver = IntersectionObserver;
	window.IntersectionObserverEntry = IntersectionObserverEntry;

	}());
	return intersectionObserver;
}

var matchMedia$1 = {};

/*! matchMedia() polyfill - Test a CSS media type/query in JS. Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. MIT license */

var hasRequiredMatchMedia;

function requireMatchMedia () {
	if (hasRequiredMatchMedia) return matchMedia$1;
	hasRequiredMatchMedia = 1;
	window.matchMedia || (window.matchMedia = function() {

	    // For browsers that support matchMedium api such as IE 9 and webkit
	    var styleMedia = (window.styleMedia || window.media);

	    // For those that don't support matchMedium
	    if (!styleMedia) {
	        var style       = document.createElement('style'),
	            script      = document.getElementsByTagName('script')[0],
	            info        = null;

	        style.type  = 'text/css';
	        style.id    = 'matchmediajs-test';

	        if (!script) {
	          document.head.appendChild(style);
	        } else {
	          script.parentNode.insertBefore(style, script);
	        }

	        // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers
	        info = ('getComputedStyle' in window) && window.getComputedStyle(style, null) || style.currentStyle;

	        styleMedia = {
	            matchMedium: function(media) {
	                var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';

	                // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers
	                if (style.styleSheet) {
	                    style.styleSheet.cssText = text;
	                } else {
	                    style.textContent = text;
	                }

	                // Test if media query is true or false
	                return info.width === '1px';
	            }
	        };
	    }

	    return function(media) {
	        return {
	            matches: styleMedia.matchMedium(media || 'all'),
	            media: media || 'all'
	        };
	    };
	}());
	return matchMedia$1;
}

var matchMedia_addListener = {};

/*! matchMedia() polyfill addListener/removeListener extension. Author & copyright (c) 2012: Scott Jehl. MIT license */

var hasRequiredMatchMedia_addListener;

function requireMatchMedia_addListener () {
	if (hasRequiredMatchMedia_addListener) return matchMedia_addListener;
	hasRequiredMatchMedia_addListener = 1;
	(function(){
	    // Bail out for browsers that have addListener support
	    if (window.matchMedia && window.matchMedia('all').addListener) {
	        return false;
	    }

	    var localMatchMedia = window.matchMedia,
	        hasMediaQueries = localMatchMedia('only all').matches,
	        isListening     = false,
	        timeoutID       = 0,    // setTimeout for debouncing 'handleChange'
	        queries         = [],   // Contains each 'mql' and associated 'listeners' if 'addListener' is used
	        handleChange    = function(evt) {
	            // Debounce
	            clearTimeout(timeoutID);

	            timeoutID = setTimeout(function() {
	                for (var i = 0, il = queries.length; i < il; i++) {
	                    var mql         = queries[i].mql,
	                        listeners   = queries[i].listeners || [],
	                        matches     = localMatchMedia(mql.media).matches;

	                    // Update mql.matches value and call listeners
	                    // Fire listeners only if transitioning to or from matched state
	                    if (matches !== mql.matches) {
	                        mql.matches = matches;

	                        for (var j = 0, jl = listeners.length; j < jl; j++) {
	                            listeners[j].call(window, mql);
	                        }
	                    }
	                }
	            }, 30);
	        };

	    window.matchMedia = function(media) {
	        var mql         = localMatchMedia(media),
	            listeners   = [],
	            index       = 0;

	        mql.addListener = function(listener) {
	            // Changes would not occur to css media type so return now (Affects IE <= 8)
	            if (!hasMediaQueries) {
	                return;
	            }

	            // Set up 'resize' listener for browsers that support CSS3 media queries (Not for IE <= 8)
	            // There should only ever be 1 resize listener running for performance
	            if (!isListening) {
	                isListening = true;
	                window.addEventListener('resize', handleChange, true);
	            }

	            // Push object only if it has not been pushed already
	            if (index === 0) {
	                index = queries.push({
	                    mql         : mql,
	                    listeners   : listeners
	                });
	            }

	            listeners.push(listener);
	        };

	        mql.removeListener = function(listener) {
	            for (var i = 0, il = listeners.length; i < il; i++){
	                if (listeners[i] === listener){
	                    listeners.splice(i, 1);
	                }
	            }
	        };

	        return mql;
	    };
	}());
	return matchMedia_addListener;
}

var dist = {};

var hasRequiredDist;

function requireDist () {
	if (hasRequiredDist) return dist;
	hasRequiredDist = 1;
	(function () {

	    var UNSUPPORTED_ENVIRONMENT = typeof window === "undefined";

	    /**
	     * Is true if the browser natively supports the 'scroll-behavior' CSS-property.
	     * @type {boolean}
	     */
	    var SUPPORTS_SCROLL_BEHAVIOR = UNSUPPORTED_ENVIRONMENT ? false : "scrollBehavior" in document.documentElement.style;

	    

	    /*! *****************************************************************************
	    Copyright (c) Microsoft Corporation. All rights reserved.
	    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	    this file except in compliance with the License. You may obtain a copy of the
	    License at http://www.apache.org/licenses/LICENSE-2.0

	    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	    MERCHANTABLITY OR NON-INFRINGEMENT.

	    See the Apache Version 2.0 License for specific language governing permissions
	    and limitations under the License.
	    ***************************************************************************** */

	    var __assign = function() {
	        __assign = Object.assign || function __assign(t) {
	            for (var s, i = 1, n = arguments.length; i < n; i++) {
	                s = arguments[i];
	                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	            }
	            return t;
	        };
	        return __assign.apply(this, arguments);
	    };

	    function __read(o, n) {
	        var m = typeof Symbol === "function" && o[Symbol.iterator];
	        if (!m) return o;
	        var i = m.call(o), r, ar = [], e;
	        try {
	            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	        }
	        catch (error) { e = { error: error }; }
	        finally {
	            try {
	                if (r && !r.done && (m = i["return"])) m.call(i);
	            }
	            finally { if (e) throw e.error; }
	        }
	        return ar;
	    }

	    function getScrollingElement() {
	        if (document.scrollingElement != null) {
	            return document.scrollingElement;
	        }
	        else {
	            return document.documentElement;
	        }
	    }

	    var STYLE_ATTRIBUTE_PROPERTY_NAME = "scroll-behavior";
	    var STYLE_ATTRIBUTE_PROPERTY_REGEXP = new RegExp(STYLE_ATTRIBUTE_PROPERTY_NAME + ":\\s*([^;]*)");
	    /**
	     * Given an Element, this function appends the given ScrollBehavior CSS property value to the elements' 'style' attribute.
	     * If it doesnt already have one, it will add it.
	     * @param {Element} element
	     * @param {ScrollBehavior} behavior
	     */
	    function appendScrollBehaviorToStyleAttribute(element, behavior) {
	        var addition = STYLE_ATTRIBUTE_PROPERTY_NAME + ":" + behavior;
	        var attributeValue = element.getAttribute("style");
	        if (attributeValue == null || attributeValue === "") {
	            element.setAttribute("style", addition);
	            return;
	        }
	        // The style attribute may already include a 'scroll-behavior:<something>' in which case that should be replaced
	        var existingValueForProperty = parseScrollBehaviorFromStyleAttribute(element);
	        if (existingValueForProperty != null) {
	            var replacementProperty = STYLE_ATTRIBUTE_PROPERTY_NAME + ":" + existingValueForProperty;
	            // Replace the variant that ends with a semi-colon which it may
	            attributeValue = attributeValue.replace(replacementProperty + ";", "");
	            // Replace the variant that *doesn't* end with a semi-colon
	            attributeValue = attributeValue.replace(replacementProperty, "");
	        }
	        // Now, append the behavior to the string.
	        element.setAttribute("style", attributeValue.endsWith(";") ? "" + attributeValue + addition : ";" + attributeValue + addition);
	    }
	    /**
	     * Given an Element, this function attempts to parse its 'style' attribute (if it has one)' to extract
	     * a value for the 'scroll-behavior' CSS property (if it is given within that style attribute)
	     * @param {Element} element
	     * @returns {ScrollBehavior?}
	     */
	    function parseScrollBehaviorFromStyleAttribute(element) {
	        var styleAttributeValue = element.getAttribute("style");
	        if (styleAttributeValue != null && styleAttributeValue.includes(STYLE_ATTRIBUTE_PROPERTY_NAME)) {
	            var match = styleAttributeValue.match(STYLE_ATTRIBUTE_PROPERTY_REGEXP);
	            if (match != null) {
	                var _a = __read(match, 2), behavior = _a[1];
	                if (behavior != null && behavior !== "") {
	                    return behavior;
	                }
	            }
	        }
	        return undefined;
	    }

	    var styleDeclarationPropertyName = "scrollBehavior";
	    /**
	     * Determines the scroll behavior to use, depending on the given ScrollOptions and the position of the Element
	     * within the DOM
	     * @param {Element|HTMLElement|Window} inputTarget
	     * @param {ScrollOptions} [options]
	     * @returns {ScrollBehavior}
	     */
	    function getScrollBehavior(inputTarget, options) {
	        // If the given 'behavior' is 'smooth', apply smooth scrolling no matter what
	        if (options != null && options.behavior === "smooth")
	            return "smooth";
	        var target = "style" in inputTarget ? inputTarget : getScrollingElement();
	        var value;
	        if ("style" in target) {
	            // Check if scroll-behavior is set as a property on the CSSStyleDeclaration
	            var scrollBehaviorPropertyValue = target.style[styleDeclarationPropertyName];
	            // Return it if it is given and has a proper value
	            if (scrollBehaviorPropertyValue != null && scrollBehaviorPropertyValue !== "") {
	                value = scrollBehaviorPropertyValue;
	            }
	        }
	        if (value == null) {
	            var attributeValue = target.getAttribute("scroll-behavior");
	            if (attributeValue != null && attributeValue !== "") {
	                value = attributeValue;
	            }
	        }
	        if (value == null) {
	            // Otherwise, check if it is set as an inline style
	            value = parseScrollBehaviorFromStyleAttribute(target);
	        }
	        if (value == null) {
	            // Take the computed style for the element and see if it contains a specific 'scroll-behavior' value
	            var computedStyle = getComputedStyle(target);
	            var computedStyleValue = computedStyle.getPropertyValue("scrollBehavior");
	            if (computedStyleValue != null && computedStyleValue !== "") {
	                value = computedStyleValue;
	            }
	        }
	        // In all other cases, use the value from the CSSOM
	        return value;
	    }

	    

	    

	    var HALF = 0.5;
	    /**
	     * The easing function to use when applying the smooth scrolling
	     * @param {number} k
	     * @returns {number}
	     */
	    function ease(k) {
	        return HALF * (1 - Math.cos(Math.PI * k));
	    }

	    var NOOP = {
	        reset: function () { }
	    };
	    var map = typeof WeakMap === "undefined" ? undefined : new WeakMap();
	    function disableScrollSnap(scroller) {
	        // If scroll-behavior is natively supported, or if there is no native WeakMap support, there's no need for this fix
	        if (SUPPORTS_SCROLL_BEHAVIOR || map == null) {
	            return NOOP;
	        }
	        var scrollingElement = getScrollingElement();
	        var cachedScrollSnapValue;
	        var cachedScrollBehaviorStyleAttributeValue;
	        var secondaryScroller;
	        var secondaryScrollerCachedScrollSnapValue;
	        var secondaryScrollerCachedScrollBehaviorStyleAttributeValue;
	        var existingResult = map.get(scroller);
	        if (existingResult != null) {
	            cachedScrollSnapValue = existingResult.cachedScrollSnapValue;
	            cachedScrollBehaviorStyleAttributeValue = existingResult.cachedScrollBehaviorStyleAttributeValue;
	            secondaryScroller = existingResult.secondaryScroller;
	            secondaryScrollerCachedScrollSnapValue = existingResult.secondaryScrollerCachedScrollSnapValue;
	            secondaryScrollerCachedScrollBehaviorStyleAttributeValue = existingResult.secondaryScrollerCachedScrollBehaviorStyleAttributeValue;
	            existingResult.release();
	        }
	        else {
	            cachedScrollSnapValue = scroller.style.scrollSnapType === "" ? null : scroller.style.scrollSnapType;
	            cachedScrollBehaviorStyleAttributeValue = parseScrollBehaviorFromStyleAttribute(scroller);
	            secondaryScroller = scroller === scrollingElement && scrollingElement !== document.body ? document.body : undefined;
	            secondaryScrollerCachedScrollSnapValue =
	                secondaryScroller == null ? undefined : secondaryScroller.style.scrollSnapType === "" ? null : secondaryScroller.style.scrollSnapType;
	            secondaryScrollerCachedScrollBehaviorStyleAttributeValue =
	                secondaryScroller == null ? undefined : parseScrollBehaviorFromStyleAttribute(secondaryScroller);
	            var cachedComputedScrollSnapValue = getComputedStyle(scroller).getPropertyValue("scroll-snap-type");
	            var secondaryScrollerCachedComputedScrollSnapValue = secondaryScroller == null ? undefined : getComputedStyle(secondaryScroller).getPropertyValue("scroll-snap-type");
	            // If it just so happens that there actually isn't any scroll snapping going on, there's no point in performing any additional work here.
	            if (cachedComputedScrollSnapValue === "none" && secondaryScrollerCachedComputedScrollSnapValue === "none") {
	                return NOOP;
	            }
	        }
	        scroller.style.scrollSnapType = "none";
	        if (secondaryScroller !== undefined) {
	            secondaryScroller.style.scrollSnapType = "none";
	        }
	        if (cachedScrollBehaviorStyleAttributeValue !== undefined) {
	            appendScrollBehaviorToStyleAttribute(scroller, cachedScrollBehaviorStyleAttributeValue);
	        }
	        if (secondaryScroller !== undefined && secondaryScrollerCachedScrollBehaviorStyleAttributeValue !== undefined) {
	            appendScrollBehaviorToStyleAttribute(secondaryScroller, secondaryScrollerCachedScrollBehaviorStyleAttributeValue);
	        }
	        var hasReleased = false;
	        var eventTarget = scroller === scrollingElement ? window : scroller;
	        function release() {
	            eventTarget.removeEventListener("scroll", resetHandler);
	            if (map != null) {
	                map["delete"](scroller);
	            }
	            hasReleased = true;
	        }
	        function resetHandler() {
	            scroller.style.scrollSnapType = cachedScrollSnapValue;
	            if (secondaryScroller != null && secondaryScrollerCachedScrollSnapValue !== undefined) {
	                secondaryScroller.style.scrollSnapType = secondaryScrollerCachedScrollSnapValue;
	            }
	            if (cachedScrollBehaviorStyleAttributeValue !== undefined) {
	                appendScrollBehaviorToStyleAttribute(scroller, cachedScrollBehaviorStyleAttributeValue);
	            }
	            if (secondaryScroller !== undefined && secondaryScrollerCachedScrollBehaviorStyleAttributeValue !== undefined) {
	                appendScrollBehaviorToStyleAttribute(secondaryScroller, secondaryScrollerCachedScrollBehaviorStyleAttributeValue);
	            }
	            release();
	        }
	        function reset() {
	            setTimeout(function () {
	                if (hasReleased)
	                    return;
	                eventTarget.addEventListener("scroll", resetHandler);
	            });
	        }
	        map.set(scroller, {
	            release: release,
	            cachedScrollSnapValue: cachedScrollSnapValue,
	            cachedScrollBehaviorStyleAttributeValue: cachedScrollBehaviorStyleAttributeValue,
	            secondaryScroller: secondaryScroller,
	            secondaryScrollerCachedScrollSnapValue: secondaryScrollerCachedScrollSnapValue,
	            secondaryScrollerCachedScrollBehaviorStyleAttributeValue: secondaryScrollerCachedScrollBehaviorStyleAttributeValue
	        });
	        return {
	            reset: reset
	        };
	    }

	    /**
	     * The duration of a smooth scroll
	     * @type {number}
	     */
	    var SCROLL_TIME = 15000;
	    /**
	     * Performs a smooth repositioning of the scroll
	     * @param {ISmoothScrollOptions} options
	     */
	    function smoothScroll(options) {
	        var startTime = options.startTime, startX = options.startX, startY = options.startY, endX = options.endX, endY = options.endY, method = options.method, scroller = options.scroller;
	        var timeLapsed = 0;
	        var distanceX = endX - startX;
	        var distanceY = endY - startY;
	        var speed = Math.max(Math.abs((distanceX / 1000) * SCROLL_TIME), Math.abs((distanceY / 1000) * SCROLL_TIME));
	        // Temporarily disables any scroll snapping that may be active since it fights for control over the scroller with this polyfill
	        var scrollSnapFix = disableScrollSnap(scroller);
	        requestAnimationFrame(function animate(timestamp) {
	            timeLapsed += timestamp - startTime;
	            var percentage = Math.max(0, Math.min(1, speed === 0 ? 0 : timeLapsed / speed));
	            var positionX = Math.floor(startX + distanceX * ease(percentage));
	            var positionY = Math.floor(startY + distanceY * ease(percentage));
	            method(positionX, positionY);
	            if (positionX !== endX || positionY !== endY) {
	                requestAnimationFrame(animate);
	            }
	            else {
	                if (scrollSnapFix != null) {
	                    scrollSnapFix.reset();
	                    scrollSnapFix = undefined;
	                }
	            }
	        });
	    }

	    /**
	     * Returns a High Resolution timestamp if possible, otherwise fallbacks to Date.now()
	     * @returns {number}
	     */
	    function now() {
	        if ("performance" in window)
	            return performance.now();
	        return Date.now();
	    }

	    

	    var ELEMENT_ORIGINAL_SCROLL = UNSUPPORTED_ENVIRONMENT ? undefined : Element.prototype.scroll;

	    var WINDOW_ORIGINAL_SCROLL = UNSUPPORTED_ENVIRONMENT ? undefined : window.scroll;

	    var ELEMENT_ORIGINAL_SCROLL_BY = UNSUPPORTED_ENVIRONMENT ? undefined : Element.prototype.scrollBy;

	    var WINDOW_ORIGINAL_SCROLL_BY = UNSUPPORTED_ENVIRONMENT ? undefined : window.scrollBy;

	    var ELEMENT_ORIGINAL_SCROLL_TO = UNSUPPORTED_ENVIRONMENT ? undefined : Element.prototype.scrollTo;

	    var WINDOW_ORIGINAL_SCROLL_TO = UNSUPPORTED_ENVIRONMENT ? undefined : window.scrollTo;

	    /**
	     * A fallback if Element.prototype.scroll is not defined
	     * @param {number} x
	     * @param {number} y
	     */
	    function elementPrototypeScrollFallback(x, y) {
	        this.__adjustingScrollPosition = true;
	        this.scrollLeft = x;
	        this.scrollTop = y;
	        delete this.__adjustingScrollPosition;
	    }
	    /**
	     * A fallback if Element.prototype.scrollTo is not defined
	     * @param {number} x
	     * @param {number} y
	     */
	    function elementPrototypeScrollToFallback(x, y) {
	        return elementPrototypeScrollFallback.call(this, x, y);
	    }
	    /**
	     * A fallback if Element.prototype.scrollBy is not defined
	     * @param {number} x
	     * @param {number} y
	     */
	    function elementPrototypeScrollByFallback(x, y) {
	        this.__adjustingScrollPosition = true;
	        this.scrollLeft += x;
	        this.scrollTop += y;
	        delete this.__adjustingScrollPosition;
	    }
	    /**
	     * Gets the original non-patched prototype method for the given kind
	     * @param {ScrollMethodName} kind
	     * @param {Element|Window} element
	     * @return {Function}
	     */
	    function getOriginalScrollMethodForKind(kind, element) {
	        switch (kind) {
	            case "scroll":
	                if (element instanceof Element) {
	                    if (ELEMENT_ORIGINAL_SCROLL != null) {
	                        return ELEMENT_ORIGINAL_SCROLL;
	                    }
	                    else {
	                        return elementPrototypeScrollFallback;
	                    }
	                }
	                else {
	                    return WINDOW_ORIGINAL_SCROLL;
	                }
	            case "scrollBy":
	                if (element instanceof Element) {
	                    if (ELEMENT_ORIGINAL_SCROLL_BY != null) {
	                        return ELEMENT_ORIGINAL_SCROLL_BY;
	                    }
	                    else {
	                        return elementPrototypeScrollByFallback;
	                    }
	                }
	                else {
	                    return WINDOW_ORIGINAL_SCROLL_BY;
	                }
	            case "scrollTo":
	                if (element instanceof Element) {
	                    if (ELEMENT_ORIGINAL_SCROLL_TO != null) {
	                        return ELEMENT_ORIGINAL_SCROLL_TO;
	                    }
	                    else {
	                        return elementPrototypeScrollToFallback;
	                    }
	                }
	                else {
	                    return WINDOW_ORIGINAL_SCROLL_TO;
	                }
	        }
	    }

	    /**
	     * Gets the Smooth Scroll Options to use for the step function
	     * @param {Element|Window} element
	     * @param {number} x
	     * @param {number} y
	     * @param {ScrollMethodName} kind
	     * @returns {ISmoothScrollOptions}
	     */
	    function getSmoothScrollOptions(element, x, y, kind) {
	        var startTime = now();
	        if (!(element instanceof Element)) {
	            // Use window as the scroll container
	            var scrollX_1 = window.scrollX, pageXOffset_1 = window.pageXOffset, scrollY_1 = window.scrollY, pageYOffset_1 = window.pageYOffset;
	            var startX = scrollX_1 == null || scrollX_1 === 0 ? pageXOffset_1 : scrollX_1;
	            var startY = scrollY_1 == null || scrollY_1 === 0 ? pageYOffset_1 : scrollY_1;
	            return {
	                startTime: startTime,
	                startX: startX,
	                startY: startY,
	                endX: Math.floor(kind === "scrollBy" ? startX + x : x),
	                endY: Math.floor(kind === "scrollBy" ? startY + y : y),
	                method: getOriginalScrollMethodForKind("scrollTo", window).bind(window),
	                scroller: getScrollingElement()
	            };
	        }
	        else {
	            var scrollLeft = element.scrollLeft, scrollTop = element.scrollTop;
	            var startX = scrollLeft;
	            var startY = scrollTop;
	            return {
	                startTime: startTime,
	                startX: startX,
	                startY: startY,
	                endX: Math.floor(kind === "scrollBy" ? startX + x : x),
	                endY: Math.floor(kind === "scrollBy" ? startY + y : y),
	                method: getOriginalScrollMethodForKind("scrollTo", element).bind(element),
	                scroller: element
	            };
	        }
	    }

	    /**
	     * Ensures that the given value is numeric
	     * @param {number} value
	     * @return {number}
	     */
	    function ensureNumeric(value) {
	        if (value == null)
	            return 0;
	        else if (typeof value === "number") {
	            return value;
	        }
	        else if (typeof value === "string") {
	            return parseFloat(value);
	        }
	        else {
	            return 0;
	        }
	    }

	    /**
	     * Returns true if the given value is some ScrollToOptions
	     * @param {number | ScrollToOptions} value
	     * @return {value is ScrollToOptions}
	     */
	    function isScrollToOptions(value) {
	        return value != null && typeof value === "object";
	    }

	    /**
	     * Handles a scroll method
	     * @param {Element|Window} element
	     * @param {ScrollMethodName} kind
	     * @param {number | ScrollToOptions} optionsOrX
	     * @param {number} y
	     */
	    function handleScrollMethod(element, kind, optionsOrX, y) {
	        onScrollWithOptions(getScrollToOptionsWithValidation(optionsOrX, y), element, kind);
	    }
	    /**
	     * Invoked when a 'ScrollToOptions' dict is provided to 'scroll()' as the first argument
	     * @param {ScrollToOptions} options
	     * @param {Element|Window} element
	     * @param {ScrollMethodName} kind
	     */
	    function onScrollWithOptions(options, element, kind) {
	        var behavior = getScrollBehavior(element, options);
	        // If the behavior is 'auto' apply instantaneous scrolling
	        if (behavior == null || behavior === "auto") {
	            getOriginalScrollMethodForKind(kind, element).call(element, options.left, options.top);
	        }
	        else {
	            smoothScroll(getSmoothScrollOptions(element, options.left, options.top, kind));
	        }
	    }
	    /**
	     * Normalizes the given scroll coordinates
	     * @param {number?} x
	     * @param {number?} y
	     * @return {Required<Pick<ScrollToOptions, "top" | "left">>}
	     */
	    function normalizeScrollCoordinates(x, y) {
	        return {
	            left: ensureNumeric(x),
	            top: ensureNumeric(y)
	        };
	    }
	    /**
	     * Gets ScrollToOptions based on the given arguments. Will throw if validation fails
	     * @param {number | ScrollToOptions} optionsOrX
	     * @param {number} y
	     * @return {Required<ScrollToOptions>}
	     */
	    function getScrollToOptionsWithValidation(optionsOrX, y) {
	        // If only one argument is given, and it isn't an options object, throw a TypeError
	        if (y === undefined && !isScrollToOptions(optionsOrX)) {
	            throw new TypeError("Failed to execute 'scroll' on 'Element': parameter 1 ('options') is not an object.");
	        }
	        // Scroll based on the primitive values given as arguments
	        if (!isScrollToOptions(optionsOrX)) {
	            return __assign(__assign({}, normalizeScrollCoordinates(optionsOrX, y)), { behavior: "auto" });
	        }
	        // Scroll based on the received options object
	        else {
	            return __assign(__assign({}, normalizeScrollCoordinates(optionsOrX.left, optionsOrX.top)), { behavior: optionsOrX.behavior == null ? "auto" : optionsOrX.behavior });
	        }
	    }

	    /**
	     * Patches the 'scroll' method on the Element prototype
	     */
	    function patchElementScroll() {
	        Element.prototype.scroll = function (optionsOrX, y) {
	            handleScrollMethod(this, "scroll", optionsOrX, y);
	        };
	    }

	    /**
	     * Patches the 'scrollBy' method on the Element prototype
	     */
	    function patchElementScrollBy() {
	        Element.prototype.scrollBy = function (optionsOrX, y) {
	            handleScrollMethod(this, "scrollBy", optionsOrX, y);
	        };
	    }

	    /**
	     * Patches the 'scrollTo' method on the Element prototype
	     */
	    function patchElementScrollTo() {
	        Element.prototype.scrollTo = function (optionsOrX, y) {
	            handleScrollMethod(this, "scrollTo", optionsOrX, y);
	        };
	    }

	    /**
	     * Patches the 'scroll' method on the Window prototype
	     */
	    function patchWindowScroll() {
	        window.scroll = function (optionsOrX, y) {
	            handleScrollMethod(this, "scroll", optionsOrX, y);
	        };
	    }

	    /**
	     * Patches the 'scrollBy' method on the Window prototype
	     */
	    function patchWindowScrollBy() {
	        window.scrollBy = function (optionsOrX, y) {
	            handleScrollMethod(this, "scrollBy", optionsOrX, y);
	        };
	    }

	    /**
	     * Patches the 'scrollTo' method on the Window prototype
	     */
	    function patchWindowScrollTo() {
	        window.scrollTo = function (optionsOrX, y) {
	            handleScrollMethod(this, "scrollTo", optionsOrX, y);
	        };
	    }

	    // tslint:disable:no-any
	    /**
	     * Gets the parent of an element, taking into account DocumentFragments, ShadowRoots, as well as the root context (window)
	     * @param {EventTarget} currentElement
	     * @returns {EventTarget | null}
	     */
	    function getParent(currentElement) {
	        if ("nodeType" in currentElement && currentElement.nodeType === 1) {
	            return currentElement.parentNode;
	        }
	        if ("ShadowRoot" in window && currentElement instanceof window.ShadowRoot) {
	            return currentElement.host;
	        }
	        else if (currentElement === document) {
	            return window;
	        }
	        else if (currentElement instanceof Node)
	            return currentElement.parentNode;
	        return null;
	    }

	    /**
	     * Returns true if the given overflow property represents a scrollable overflow value
	     * @param {string | null} overflow
	     * @return {boolean}
	     */
	    function canOverflow(overflow) {
	        return overflow !== "visible" && overflow !== "clip";
	    }
	    /**
	     * Returns true if the given element is scrollable
	     * @param {Element} element
	     * @return {boolean}
	     */
	    function isScrollable(element) {
	        if (element.clientHeight < element.scrollHeight || element.clientWidth < element.scrollWidth) {
	            var style = getComputedStyle(element, null);
	            return canOverflow(style.overflowY) || canOverflow(style.overflowX);
	        }
	        return false;
	    }
	    /**
	     * Finds the nearest ancestor of an element that can scroll
	     * @param {Element} target
	     * @returns {Element|Window?}
	     */
	    function findNearestAncestorsWithScrollBehavior(target) {
	        var currentElement = target;
	        var scrollingElement = getScrollingElement();
	        while (currentElement != null) {
	            var behavior = getScrollBehavior(currentElement);
	            if (behavior != null && (currentElement === scrollingElement || isScrollable(currentElement))) {
	                return [currentElement, behavior];
	            }
	            var parent_1 = getParent(currentElement);
	            currentElement = parent_1;
	        }
	        // No such element could be found. Start over, but this time find the nearest ancestor that can simply scroll
	        currentElement = target;
	        while (currentElement != null) {
	            if (currentElement === scrollingElement || isScrollable(currentElement)) {
	                return [currentElement, "auto"];
	            }
	            var parent_2 = getParent(currentElement);
	            currentElement = parent_2;
	        }
	        // Default to the scrolling element
	        return [scrollingElement, "auto"];
	    }

	    // tslint:disable:no-any
	    /**
	     * Finds the nearest root from an element
	     * @param {Element} target
	     * @returns {Document|ShadowRoot}
	     */
	    function findNearestRoot(target) {
	        var currentElement = target;
	        while (currentElement != null) {
	            if ("ShadowRoot" in window && currentElement instanceof window.ShadowRoot) {
	                // Assume this is a ShadowRoot
	                return currentElement;
	            }
	            var parent_1 = getParent(currentElement);
	            if (parent_1 === currentElement) {
	                return document;
	            }
	            currentElement = parent_1;
	        }
	        return document;
	    }

	    /**
	     * Gets the origin of the given Location or HTMLAnchorElement if available in the runtime, and otherwise shims it. (it's a one-liner)
	     * @returns {string}
	     */
	    function getLocationOrigin(locationLike) {
	        if (locationLike === void 0) { locationLike = location; }
	        if ("origin" in locationLike && locationLike.origin != null) {
	            return locationLike.origin;
	        }
	        var port = locationLike.port != null && locationLike.port.length > 0 ? ":" + locationLike.port : "";
	        if (locationLike.protocol === "http:" && port === ":80") {
	            port = "";
	        }
	        else if (locationLike.protocol === "https:" && port === ":443") {
	            port = "";
	        }
	        return locationLike.protocol + "//" + locationLike.hostname + port;
	    }

	    /**
	     * A Regular expression that matches id's of the form "#[digit]"
	     * @type {RegExp}
	     */
	    var ID_WITH_LEADING_DIGIT_REGEXP = /^#\d/;
	    /**
	     * Catches anchor navigation to IDs within the same root and ensures that they can be smooth-scrolled
	     * if the scroll behavior is smooth in the first rooter within that context
	     */
	    function catchNavigation() {
	        // Listen for 'click' events globally
	        window.addEventListener("click", function (e) {
	            // Only work with trusted events on HTMLAnchorElements
	            if (!e.isTrusted || !(e.target instanceof HTMLAnchorElement))
	                return;
	            var _a = e.target, pathname = _a.pathname, search = _a.search, hash = _a.hash;
	            var pointsToCurrentPage = getLocationOrigin(e.target) === getLocationOrigin(location) && pathname === location.pathname && search === location.search;
	            // Only work with HTMLAnchorElements that navigates to a specific ID on the current page
	            if (!pointsToCurrentPage || hash == null || hash.length < 1) {
	                return;
	            }
	            // Find the nearest root, whether it be a ShadowRoot or the document itself
	            var root = findNearestRoot(e.target);
	            // Attempt to match the selector from that root. querySelector' doesn't support IDs that start with a digit, so work around that limitation
	            var elementMatch = hash.match(ID_WITH_LEADING_DIGIT_REGEXP) != null ? root.getElementById(hash.slice(1)) : root.querySelector(hash);
	            // If no selector could be found, don't proceed
	            if (elementMatch == null)
	                return;
	            // Find the nearest ancestor that can be scrolled
	            var _b = __read(findNearestAncestorsWithScrollBehavior(elementMatch), 2), behavior = _b[1];
	            // If the behavior isn't smooth, don't proceed
	            if (behavior !== "smooth")
	                return;
	            // Otherwise, first prevent the default action.
	            e.preventDefault();
	            // Now, scroll to the element with that ID
	            elementMatch.scrollIntoView({
	                behavior: behavior
	            });
	        });
	    }

	    var ELEMENT_ORIGINAL_SCROLL_INTO_VIEW = UNSUPPORTED_ENVIRONMENT ? undefined : Element.prototype.scrollIntoView;

	    /**
	     * The majority of this file is based on https://github.com/stipsan/compute-scroll-into-view (MIT license),
	     * but has been rewritten to accept a scroller as an argument.
	     */
	    /**
	     * Find out which edge to align against when logical scroll position is "nearest"
	     * Interesting fact: "nearest" works similarly to "if-needed", if the element is fully visible it will not scroll it
	     *
	     * Legends:
	     * ┌────────┐ ┏ ━ ━ ━ ┓
	     * │ target │   frame
	     * └────────┘ ┗ ━ ━ ━ ┛
	     */
	    function alignNearest(scrollingEdgeStart, scrollingEdgeEnd, scrollingSize, scrollingBorderStart, scrollingBorderEnd, elementEdgeStart, elementEdgeEnd, elementSize) {
	        /**
	         * If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B
	         *
	         *          ┌──┐
	         *        ┏━│━━│━┓
	         *          │  │
	         *        ┃ │  │ ┃        do nothing
	         *          │  │
	         *        ┗━│━━│━┛
	         *          └──┘
	         *
	         *  If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D
	         *
	         *    ┏ ━ ━ ━ ━ ┓
	         *   ┌───────────┐
	         *   │┃         ┃│        do nothing
	         *   └───────────┘
	         *    ┗ ━ ━ ━ ━ ┛
	         */
	        if ((elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd) ||
	            (elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd)) {
	            return 0;
	        }
	        /**
	         * If element edge A is outside scrolling box edge A and element height is less than scrolling box height
	         *
	         *          ┌──┐
	         *        ┏━│━━│━┓         ┏━┌━━┐━┓
	         *          └──┘             │  │
	         *  from  ┃      ┃     to  ┃ └──┘ ┃
	         *
	         *        ┗━ ━━ ━┛         ┗━ ━━ ━┛
	         *
	         * If element edge B is outside scrolling box edge B and element height is greater than scrolling box height
	         *
	         *        ┏━ ━━ ━┓         ┏━┌━━┐━┓
	         *                           │  │
	         *  from  ┃ ┌──┐ ┃     to  ┃ │  │ ┃
	         *          │  │             │  │
	         *        ┗━│━━│━┛         ┗━│━━│━┛
	         *          │  │             └──┘
	         *          │  │
	         *          └──┘
	         *
	         * If element edge C is outside scrolling box edge C and element width is less than scrolling box width
	         *
	         *       from                 to
	         *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓
	         *  ┌───┐                 ┌───┐
	         *  │ ┃ │       ┃         ┃   │     ┃
	         *  └───┘                 └───┘
	         *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛
	         *
	         * If element edge D is outside scrolling box edge D and element width is greater than scrolling box width
	         *
	         *       from                 to
	         *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓
	         *        ┌───────────┐   ┌───────────┐
	         *    ┃   │     ┃     │   ┃         ┃ │
	         *        └───────────┘   └───────────┘
	         *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛
	         */
	        if ((elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize) ||
	            (elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize)) {
	            return elementEdgeStart - scrollingEdgeStart - scrollingBorderStart;
	        }
	        /**
	         * If element edge B is outside scrolling box edge B and element height is less than scrolling box height
	         *
	         *        ┏━ ━━ ━┓         ┏━ ━━ ━┓
	         *
	         *  from  ┃      ┃     to  ┃ ┌──┐ ┃
	         *          ┌──┐             │  │
	         *        ┗━│━━│━┛         ┗━└━━┘━┛
	         *          └──┘
	         *
	         * If element edge A is outside scrolling box edge A and element height is greater than scrolling box height
	         *
	         *          ┌──┐
	         *          │  │
	         *          │  │             ┌──┐
	         *        ┏━│━━│━┓         ┏━│━━│━┓
	         *          │  │             │  │
	         *  from  ┃ └──┘ ┃     to  ┃ │  │ ┃
	         *                           │  │
	         *        ┗━ ━━ ━┛         ┗━└━━┘━┛
	         *
	         * If element edge C is outside scrolling box edge C and element width is greater than scrolling box width
	         *
	         *           from                 to
	         *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓
	         *  ┌───────────┐           ┌───────────┐
	         *  │     ┃     │   ┃       │ ┃         ┃
	         *  └───────────┘           └───────────┘
	         *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛
	         *
	         * If element edge D is outside scrolling box edge D and element width is less than scrolling box width
	         *
	         *           from                 to
	         *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓
	         *                ┌───┐             ┌───┐
	         *        ┃       │ ┃ │       ┃     │   ┃
	         *                └───┘             └───┘
	         *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛
	         *
	         */
	        if ((elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize) || (elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize)) {
	            return elementEdgeEnd - scrollingEdgeEnd + scrollingBorderEnd;
	        }
	        return 0;
	    }
	    function computeScrollIntoView(target, scroller, options) {
	        var block = options.block, inline = options.inline;
	        // Used to handle the top most element that can be scrolled
	        var scrollingElement = getScrollingElement();
	        // Support pinch-zooming properly, making sure elements scroll into the visual viewport
	        // Browsers that don't support visualViewport will report the layout viewport dimensions on document.documentElement.clientWidth/Height
	        // and viewport dimensions on window.innerWidth/Height
	        // https://www.quirksmode.org/mobile/viewports2.html
	        // https://bokand.github.io/viewport/index.html
	        var viewportWidth = window.visualViewport != null ? visualViewport.width : innerWidth;
	        var viewportHeight = window.visualViewport != null ? visualViewport.height : innerHeight;
	        var viewportX = window.scrollX != null ? window.scrollX : window.pageXOffset;
	        var viewportY = window.scrollY != null ? window.scrollY : window.pageYOffset;
	        var _a = target.getBoundingClientRect(), targetHeight = _a.height, targetWidth = _a.width, targetTop = _a.top, targetRight = _a.right, targetBottom = _a.bottom, targetLeft = _a.left;
	        // These values mutate as we loop through and generate scroll coordinates
	        var targetBlock = block === "start" || block === "nearest" ? targetTop : block === "end" ? targetBottom : targetTop + targetHeight / 2; // block === 'center
	        var targetInline = inline === "center" ? targetLeft + targetWidth / 2 : inline === "end" ? targetRight : targetLeft; // inline === 'start || inline === 'nearest
	        var _b = scroller.getBoundingClientRect(), height = _b.height, width = _b.width, top = _b.top, right = _b.right, bottom = _b.bottom, left = _b.left;
	        var frameStyle = getComputedStyle(scroller);
	        var borderLeft = parseInt(frameStyle.borderLeftWidth, 10);
	        var borderTop = parseInt(frameStyle.borderTopWidth, 10);
	        var borderRight = parseInt(frameStyle.borderRightWidth, 10);
	        var borderBottom = parseInt(frameStyle.borderBottomWidth, 10);
	        var blockScroll = 0;
	        var inlineScroll = 0;
	        // The property existance checks for offset[Width|Height] is because only HTMLElement objects have them, but any Element might pass by here
	        // @TODO find out if the "as HTMLElement" overrides can be dropped
	        var scrollbarWidth = "offsetWidth" in scroller ? scroller.offsetWidth - scroller.clientWidth - borderLeft - borderRight : 0;
	        var scrollbarHeight = "offsetHeight" in scroller ? scroller.offsetHeight - scroller.clientHeight - borderTop - borderBottom : 0;
	        if (scrollingElement === scroller) {
	            // Handle viewport logic (document.documentElement or document.body)
	            if (block === "start") {
	                blockScroll = targetBlock;
	            }
	            else if (block === "end") {
	                blockScroll = targetBlock - viewportHeight;
	            }
	            else if (block === "nearest") {
	                blockScroll = alignNearest(viewportY, viewportY + viewportHeight, viewportHeight, borderTop, borderBottom, viewportY + targetBlock, viewportY + targetBlock + targetHeight, targetHeight);
	            }
	            else {
	                // block === 'center' is the default
	                blockScroll = targetBlock - viewportHeight / 2;
	            }
	            if (inline === "start") {
	                inlineScroll = targetInline;
	            }
	            else if (inline === "center") {
	                inlineScroll = targetInline - viewportWidth / 2;
	            }
	            else if (inline === "end") {
	                inlineScroll = targetInline - viewportWidth;
	            }
	            else {
	                // inline === 'nearest' is the default
	                inlineScroll = alignNearest(viewportX, viewportX + viewportWidth, viewportWidth, borderLeft, borderRight, viewportX + targetInline, viewportX + targetInline + targetWidth, targetWidth);
	            }
	            // Apply scroll position offsets and ensure they are within bounds
	            // @TODO add more test cases to cover this 100%
	            blockScroll = Math.max(0, blockScroll + viewportY);
	            inlineScroll = Math.max(0, inlineScroll + viewportX);
	        }
	        else {
	            // Handle each scrolling frame that might exist between the target and the viewport
	            if (block === "start") {
	                blockScroll = targetBlock - top - borderTop;
	            }
	            else if (block === "end") {
	                blockScroll = targetBlock - bottom + borderBottom + scrollbarHeight;
	            }
	            else if (block === "nearest") {
	                blockScroll = alignNearest(top, bottom, height, borderTop, borderBottom + scrollbarHeight, targetBlock, targetBlock + targetHeight, targetHeight);
	            }
	            else {
	                // block === 'center' is the default
	                blockScroll = targetBlock - (top + height / 2) + scrollbarHeight / 2;
	            }
	            if (inline === "start") {
	                inlineScroll = targetInline - left - borderLeft;
	            }
	            else if (inline === "center") {
	                inlineScroll = targetInline - (left + width / 2) + scrollbarWidth / 2;
	            }
	            else if (inline === "end") {
	                inlineScroll = targetInline - right + borderRight + scrollbarWidth;
	            }
	            else {
	                // inline === 'nearest' is the default
	                inlineScroll = alignNearest(left, right, width, borderLeft, borderRight + scrollbarWidth, targetInline, targetInline + targetWidth, targetWidth);
	            }
	            var scrollLeft = scroller.scrollLeft, scrollTop = scroller.scrollTop;
	            // Ensure scroll coordinates are not out of bounds while applying scroll offsets
	            blockScroll = Math.max(0, Math.min(scrollTop + blockScroll, scroller.scrollHeight - height + scrollbarHeight));
	            inlineScroll = Math.max(0, Math.min(scrollLeft + inlineScroll, scroller.scrollWidth - width + scrollbarWidth));
	        }
	        return {
	            top: blockScroll,
	            left: inlineScroll
	        };
	    }

	    /**
	     * Patches the 'scrollIntoView' method on the Element prototype
	     */
	    function patchElementScrollIntoView() {
	        Element.prototype.scrollIntoView = function (arg) {
	            var normalizedOptions = arg == null || arg === true
	                ? {
	                    block: "start",
	                    inline: "nearest"
	                }
	                : arg === false
	                    ? {
	                        block: "end",
	                        inline: "nearest"
	                    }
	                    : arg;
	            // Find the nearest ancestor that can be scrolled
	            var _a = __read(findNearestAncestorsWithScrollBehavior(this), 2), ancestorWithScroll = _a[0], ancestorWithScrollBehavior = _a[1];
	            var behavior = normalizedOptions.behavior != null ? normalizedOptions.behavior : ancestorWithScrollBehavior;
	            // If the behavior isn't smooth, simply invoke the original implementation and do no more
	            if (behavior !== "smooth") {
	                // Assert that 'scrollIntoView' is actually defined
	                if (ELEMENT_ORIGINAL_SCROLL_INTO_VIEW != null) {
	                    ELEMENT_ORIGINAL_SCROLL_INTO_VIEW.call(this, normalizedOptions);
	                }
	                // Otherwise, invoke 'scrollTo' instead and provide the scroll coordinates
	                else {
	                    var _b = computeScrollIntoView(this, ancestorWithScroll, normalizedOptions), top_1 = _b.top, left = _b.left;
	                    getOriginalScrollMethodForKind("scrollTo", this).call(this, left, top_1);
	                }
	                return;
	            }
	            ancestorWithScroll.scrollTo(__assign({ behavior: behavior }, computeScrollIntoView(this, ancestorWithScroll, normalizedOptions)));
	        };
	        // On IE11, HTMLElement has its own declaration of scrollIntoView and does not inherit this from the prototype chain, so we'll need to patch that one too.
	        if (HTMLElement.prototype.scrollIntoView != null && HTMLElement.prototype.scrollIntoView !== Element.prototype.scrollIntoView) {
	            HTMLElement.prototype.scrollIntoView = Element.prototype.scrollIntoView;
	        }
	    }

	    var ELEMENT_ORIGINAL_SCROLL_TOP_SET_DESCRIPTOR = UNSUPPORTED_ENVIRONMENT
	        ? undefined
	        : Object.getOwnPropertyDescriptor(Element.prototype, "scrollTop").set;

	    /**
	     * Patches the 'scrollTop' property descriptor on the Element prototype
	     */
	    function patchElementScrollTop() {
	        Object.defineProperty(Element.prototype, "scrollTop", {
	            set: function (scrollTop) {
	                if (this.__adjustingScrollPosition) {
	                    return ELEMENT_ORIGINAL_SCROLL_TOP_SET_DESCRIPTOR.call(this, scrollTop);
	                }
	                handleScrollMethod(this, "scrollTo", this.scrollLeft, scrollTop);
	                return scrollTop;
	            }
	        });
	    }

	    var ELEMENT_ORIGINAL_SCROLL_LEFT_SET_DESCRIPTOR = UNSUPPORTED_ENVIRONMENT
	        ? undefined
	        : Object.getOwnPropertyDescriptor(Element.prototype, "scrollLeft").set;

	    /**
	     * Patches the 'scrollLeft' property descriptor on the Element prototype
	     */
	    function patchElementScrollLeft() {
	        Object.defineProperty(Element.prototype, "scrollLeft", {
	            set: function (scrollLeft) {
	                if (this.__adjustingScrollPosition) {
	                    return ELEMENT_ORIGINAL_SCROLL_LEFT_SET_DESCRIPTOR.call(this, scrollLeft);
	                }
	                handleScrollMethod(this, "scrollTo", scrollLeft, this.scrollTop);
	                return scrollLeft;
	            }
	        });
	    }

	    /**
	     * Applies the polyfill
	     */
	    function patch() {
	        // Element.prototype methods
	        patchElementScroll();
	        patchElementScrollBy();
	        patchElementScrollTo();
	        patchElementScrollIntoView();
	        // Element.prototype descriptors
	        patchElementScrollLeft();
	        patchElementScrollTop();
	        // window methods
	        patchWindowScroll();
	        patchWindowScrollBy();
	        patchWindowScrollTo();
	        // Navigation
	        catchNavigation();
	    }

	    /**
	     * Is true if the browser natively supports the Element.prototype.[scroll|scrollTo|scrollBy|scrollIntoView] methods
	     * @type {boolean}
	     */
	    var SUPPORTS_ELEMENT_PROTOTYPE_SCROLL_METHODS = UNSUPPORTED_ENVIRONMENT
	        ? false
	        : "scroll" in Element.prototype && "scrollTo" in Element.prototype && "scrollBy" in Element.prototype && "scrollIntoView" in Element.prototype;

	    if (!UNSUPPORTED_ENVIRONMENT && (!SUPPORTS_SCROLL_BEHAVIOR || !SUPPORTS_ELEMENT_PROTOTYPE_SCROLL_METHODS)) {
	        patch();
	    }

	}());
	
	return dist;
}

var loader_cjs = {};

var alignLabelFc1cc093 = {};

var hasRequiredAlignLabelFc1cc093;

function requireAlignLabelFc1cc093 () {
	if (hasRequiredAlignLabelFc1cc093) return alignLabelFc1cc093;
	hasRequiredAlignLabelFc1cc093 = 1;

	const ALIGN_LABELS = ['left', 'right'];

	alignLabelFc1cc093.ALIGN_LABELS = ALIGN_LABELS;

	
	return alignLabelFc1cc093;
}

var appGlobalsBaf8fc74 = {};

var getCDNBaseURLE7722df3 = {};

var hasRequiredGetCDNBaseURLE7722df3;

function requireGetCDNBaseURLE7722df3 () {
	if (hasRequiredGetCDNBaseURLE7722df3) return getCDNBaseURLE7722df3;
	hasRequiredGetCDNBaseURLE7722df3 = 1;

	const getCDNBaseURL = () => document.porscheDesignSystem.cdn.url + "/porsche-design-system";

	getCDNBaseURLE7722df3.getCDNBaseURL = getCDNBaseURL;

	
	return getCDNBaseURLE7722df3;
}

var hasRequiredAppGlobalsBaf8fc74;

function requireAppGlobalsBaf8fc74 () {
	if (hasRequiredAppGlobalsBaf8fc74) return appGlobalsBaf8fc74;
	hasRequiredAppGlobalsBaf8fc74 = 1;

	const validateProps = requireValidatePropsC2afb75b();
	const getCDNBaseURL = requireGetCDNBaseURLE7722df3();

	const FONT_FACE_CDN_FILE_COM = 'font-face.min.02bef87be3cf3d34b4a5b63f52555cf5.css';
	const FONT_FACE_CDN_FILE_CN = 'font-face.min.cn.08c47df0d81611c0e3b64dcad53153af.css';

	const validatePartialUsage = () => {
	  validateGetInitialStylesUsage();
	  validateGetFontFaceStylesheetUsage();
	  validateGetFontLinksUsage();
	  // TODO: integration test (real world test) first, before rollout
	  // validateGetLoaderScriptUsage();
	  // validateGetComponentChunkLinksUsage();
	};
	const validateGetFontFaceStylesheetUsage = () => {
	  const baseUrl = getCDNBaseURL.getCDNBaseURL();
	  const styleUrl = `${baseUrl}/styles/${baseUrl.match(/\.cn\//) ? FONT_FACE_CDN_FILE_CN : FONT_FACE_CDN_FILE_COM}`
	    ;
	  if (!document.head.querySelector(`link[href="${styleUrl}"]`)) {
	    logPartialValidationWarning('getFontFaceStylesheet');
	  }
	};
	const validateGetFontLinksUsage = () => {
	  if (!document.head.querySelector('link[rel=preload][as=font][href*=porsche-next-w-la-regular]')) {
	    logPartialValidationWarning('getFontLinks');
	  }
	};
	const validateGetInitialStylesUsage = () => {
	  if (!document.head.querySelector('style[data-pds-initial-styles]')) {
	    throwPartialValidationError('getInitialStyles');
	  }
	};
	const logPartialValidationWarning = (partialName, prefix) => {
	  validateProps.consoleWarn(getValidatePartialErrorPrimaryText(partialName, prefix), getValidatePartialErrorSecondaryText(partialName));
	};
	const throwPartialValidationError = (partialName, prefix) => {
	  validateProps.throwException(getValidatePartialErrorPrimaryText(partialName, prefix) +
	    ' ' +
	    getValidatePartialErrorSecondaryText(partialName, true));
	};
	const getValidatePartialErrorPrimaryText = (partialName, prefix) => {
	  return `The Porsche Design System ${prefix ? `with prefix: '${prefix}' ` : ''}is used without using the ${partialName}() partial.`;
	};
	const getValidatePartialErrorSecondaryText = (partialName, required) => {
	  const partialUrl = partialName
	    .replace('get', '')
	    .replace(/([a-z])([A-Z])/g, '$1-$2') // camelCase to param-case
	    .toLowerCase();
	  return `The usage of the ${partialName}() partial is ${required ? 'required' : 'recommended'} as described at https://designsystem.porsche.com/v3/partials/${partialUrl} to enhance loading behavior.`;
	};

	// TODO: should be removed, instead consumers should be forced via validation to use the partial for preloading
	const injectGlobalStyle = () => {
	  if (typeof document !== 'undefined' && "production" === 'production') {
	    const baseUrl = getCDNBaseURL.getCDNBaseURL();
	    const styleUrl = `${baseUrl}/styles/${baseUrl.match(/\.cn\//) ? FONT_FACE_CDN_FILE_CN : FONT_FACE_CDN_FILE_COM}`;
	    const { head } = document;
	    if (!head.querySelector(`link[href='${styleUrl}']`)) {
	      const link = document.createElement('link');
	      link.href = styleUrl;
	      link.type = 'text/css';
	      link.rel = 'stylesheet';
	      head.appendChild(link);
	    }
	  }
	};

	const appGlobalScript = () => {
	  {
	    // not available during `yarn start` of components package
	    document.porscheDesignSystem["3.7.0-rc.2"].readyResolve(); // provided via load() of components-js package
	  }
	  injectGlobalStyle();
	  validatePartialUsage();
	};

	const globalScripts = appGlobalScript;

	appGlobalsBaf8fc74.globalScripts = globalScripts;

	
	return appGlobalsBaf8fc74;
}

var bannerUtils2cc83734 = {};

var hasRequiredBannerUtils2cc83734;

function requireBannerUtils2cc83734 () {
	if (hasRequiredBannerUtils2cc83734) return bannerUtils2cc83734;
	hasRequiredBannerUtils2cc83734 = 1;

	/** @deprecated */
	const BANNER_STATES_DEPRECATED = ['neutral'];
	const BANNER_STATES = ['info', 'warning', 'error', ...BANNER_STATES_DEPRECATED];

	bannerUtils2cc83734.BANNER_STATES = BANNER_STATES;

	
	return bannerUtils2cc83734;
}

var borderRadiusLargeA0aa3a01 = {};

var hasRequiredBorderRadiusLargeA0aa3a01;

function requireBorderRadiusLargeA0aa3a01 () {
	if (hasRequiredBorderRadiusLargeA0aa3a01) return borderRadiusLargeA0aa3a01;
	hasRequiredBorderRadiusLargeA0aa3a01 = 1;

	const borderRadiusLarge = '12px';

	borderRadiusLargeA0aa3a01.borderRadiusLarge = borderRadiusLarge;

	
	return borderRadiusLargeA0aa3a01;
}

var borderRadiusMedium758b9411 = {};

var hasRequiredBorderRadiusMedium758b9411;

function requireBorderRadiusMedium758b9411 () {
	if (hasRequiredBorderRadiusMedium758b9411) return borderRadiusMedium758b9411;
	hasRequiredBorderRadiusMedium758b9411 = 1;

	const borderRadiusMedium = '8px';

	borderRadiusMedium758b9411.borderRadiusMedium = borderRadiusMedium;

	
	return borderRadiusMedium758b9411;
}

var borderRadiusSmall5f37fc45 = {};

var hasRequiredBorderRadiusSmall5f37fc45;

function requireBorderRadiusSmall5f37fc45 () {
	if (hasRequiredBorderRadiusSmall5f37fc45) return borderRadiusSmall5f37fc45;
	hasRequiredBorderRadiusSmall5f37fc45 = 1;

	const borderRadiusSmall = '4px';

	borderRadiusSmall5f37fc45.borderRadiusSmall = borderRadiusSmall;

	
	return borderRadiusSmall5f37fc45;
}

var buttonHandlingA110f521 = {};

var getClosestHTMLElement0135bfd9 = {};

var hasRequiredGetClosestHTMLElement0135bfd9;

function requireGetClosestHTMLElement0135bfd9 () {
	if (hasRequiredGetClosestHTMLElement0135bfd9) return getClosestHTMLElement0135bfd9;
	hasRequiredGetClosestHTMLElement0135bfd9 = 1;

	/* eslint-disable prefer-arrow/prefer-arrow-functions */
	function getClosestHTMLElement(element, selector) {
	  return element?.closest(selector);
	}

	getClosestHTMLElement0135bfd9.getClosestHTMLElement = getClosestHTMLElement;

	
	return getClosestHTMLElement0135bfd9;
}

var hasRequiredButtonHandlingA110f521;

function requireButtonHandlingA110f521 () {
	if (hasRequiredButtonHandlingA110f521) return buttonHandlingA110f521;
	hasRequiredButtonHandlingA110f521 = 1;

	const getClosestHTMLElement = requireGetClosestHTMLElement0135bfd9();
	requireValidatePropsC2afb75b();

	const improveButtonHandlingForCustomElement = (element, getType, getDisabled) => {
	  element.addEventListener('click', (event) => handleButtonEvent(event, element, getType, getDisabled));
	};
	const handleButtonEvent = (event, element, getType, getDisabled) => {
	  // Why? That's why: https://www.hjorthhansen.dev/shadow-dom-and-forms/
	  const form = getClosestHTMLElement.getClosestHTMLElement(element, 'form');
	  if (form && !getDisabled()) {
	    /**
	     * we've to wait if someone calls preventDefault on the event
	     * then we shouldn't submit the form
	     */
	    window.setTimeout(() => {
	      if (!event.defaultPrevented) {
	        const fakeButton = document.createElement('button');
	        fakeButton.type = getType();
	        fakeButton.style.display = 'none';
	        form.appendChild(fakeButton);
	        fakeButton.addEventListener('click', (fakeButtonEvent) => {
	          fakeButtonEvent.stopPropagation();
	        });
	        fakeButton.click();
	        fakeButton.remove();
	      }
	    }, 1);
	  }
	};

	buttonHandlingA110f521.handleButtonEvent = handleButtonEvent;
	buttonHandlingA110f521.improveButtonHandlingForCustomElement = improveButtonHandlingForCustomElement;

	
	return buttonHandlingA110f521;
}

var buttonLinkPureUtils468dbe67 = {};

var isParentOfKindA9c351f2 = {};

var hasRequiredIsParentOfKindA9c351f2;

function requireIsParentOfKindA9c351f2 () {
	if (hasRequiredIsParentOfKindA9c351f2) return isParentOfKindA9c351f2;
	hasRequiredIsParentOfKindA9c351f2 = 1;

	const validateProps = requireValidatePropsC2afb75b();

	const isParentOfKind = (element, tagName) => {
	  const { parentElement } = element;
	  return parentElement && validateProps.getTagNameWithoutPrefix(parentElement) === tagName;
	};

	isParentOfKindA9c351f2.isParentOfKind = isParentOfKind;

	
	return isParentOfKindA9c351f2;
}

var hasRequiredButtonLinkPureUtils468dbe67;

function requireButtonLinkPureUtils468dbe67 () {
	if (hasRequiredButtonLinkPureUtils468dbe67) return buttonLinkPureUtils468dbe67;
	hasRequiredButtonLinkPureUtils468dbe67 = 1;

	const validateProps = requireValidatePropsC2afb75b();
	const isParentOfKind = requireIsParentOfKindA9c351f2();

	const hasVisibleIcon = (iconName, iconSource) => {
	  return iconName !== 'none' || !!iconSource;
	};
	const warnIfParentIsPTextAndIconIsNone = (host, iconName, iconSource) => {
	  if (!hasVisibleIcon(iconName, iconSource) && isParentOfKind.isParentOfKind(host, 'p-text')) {
	    validateProps.consoleWarn(`${validateProps.getTagNameWithoutPrefix(host)} should not be used inside p-text. Please use a <button> or <a> tag.`);
	  }
	};

	buttonLinkPureUtils468dbe67.hasVisibleIcon = hasVisibleIcon;
	buttonLinkPureUtils468dbe67.warnIfParentIsPTextAndIconIsNone = warnIfParentIsPTextAndIconIsNone;

	
	return buttonLinkPureUtils468dbe67;
}

var buttonTypeAe0c09db = {};

var hasRequiredButtonTypeAe0c09db;

function requireButtonTypeAe0c09db () {
	if (hasRequiredButtonTypeAe0c09db) return buttonTypeAe0c09db;
	hasRequiredButtonTypeAe0c09db = 1;

	const BUTTON_ARIA_ATTRIBUTES = ['aria-label', 'aria-expanded', 'aria-pressed', 'aria-haspopup'];

	const BUTTON_TYPES = ['button', 'submit', 'reset'];

	buttonTypeAe0c09db.BUTTON_ARIA_ATTRIBUTES = BUTTON_ARIA_ATTRIBUTES;
	buttonTypeAe0c09db.BUTTON_TYPES = BUTTON_TYPES;

	
	return buttonTypeAe0c09db;
}

var checkboxRadioStylesEabaca96 = {};

var isDisabledOrLoadingAd97a497 = {};

var hasRequiredIsDisabledOrLoadingAd97a497;

function requireIsDisabledOrLoadingAd97a497 () {
	if (hasRequiredIsDisabledOrLoadingAd97a497) return isDisabledOrLoadingAd97a497;
	hasRequiredIsDisabledOrLoadingAd97a497 = 1;

	const isDisabledOrLoading = (disabled, loading) => {
	  return disabled || loading;
	};

	isDisabledOrLoadingAd97a497.isDisabledOrLoading = isDisabledOrLoading;

	
	return isDisabledOrLoadingAd97a497;
}

var colorSchemeStyles81696be8 = {};

var hasRequiredColorSchemeStyles81696be8;

function requireColorSchemeStyles81696be8 () {
	if (hasRequiredColorSchemeStyles81696be8) return colorSchemeStyles81696be8;
	hasRequiredColorSchemeStyles81696be8 = 1;

	const hostHiddenStyles = {
	  '&([hidden])': {
	    display: 'none',
	  },
	};

	const colorSchemeStyles = {
	  colorScheme: 'light dark',
	};

	colorSchemeStyles81696be8.colorSchemeStyles = colorSchemeStyles;
	colorSchemeStyles81696be8.hostHiddenStyles = hostHiddenStyles;

	
	return colorSchemeStyles81696be8;
}

var hoverMediaQueryF2ccfc24 = {};

var hasRequiredHoverMediaQueryF2ccfc24;

function requireHoverMediaQueryF2ccfc24 () {
	if (hasRequiredHoverMediaQueryF2ccfc24) return hoverMediaQueryF2ccfc24;
	hasRequiredHoverMediaQueryF2ccfc24 = 1;

	/**
	 * utility to wrap jss styles parameter in `@media (hover: hover)`
	 * which is used to not have hover styles on touch devices
	 */
	const hoverMediaQuery = (style) => 
	// puppeteer/chromium does not support `@media (hover: hover)` in headless mode
	// see https://github.com/puppeteer/puppeteer/issues/5096 and https://github.com/puppeteer/puppeteer/issues/4820
	({ '@media(hover:hover)': style }) // used for prod build, yarn start and unit tests
	  ; // used for staging build in e2e and vrt tests

	hoverMediaQueryF2ccfc24.hoverMediaQuery = hoverMediaQuery;

	
	return hoverMediaQueryF2ccfc24;
}

var isThemeAutoC90cd35d = {};

var hasRequiredIsThemeAutoC90cd35d;

function requireIsThemeAutoC90cd35d () {
	if (hasRequiredIsThemeAutoC90cd35d) return isThemeAutoC90cd35d;
	hasRequiredIsThemeAutoC90cd35d = 1;

	requireValidatePropsC2afb75b();

	const prefersColorSchemeDarkMediaQuery = (theme, style) => {
	  return isThemeAuto(theme) && { '@media (prefers-color-scheme: dark)': style };
	};

	const isThemeAuto = (theme) => {
	  return theme === 'auto';
	};

	isThemeAutoC90cd35d.prefersColorSchemeDarkMediaQuery = prefersColorSchemeDarkMediaQuery;

	
	return isThemeAutoC90cd35d;
}

var requiredBc18b612 = {};

var hasNamedSlot28c6bca1 = {};

var getNamedSlotA433c432 = {};

var hasRequiredGetNamedSlotA433c432;

function requireGetNamedSlotA433c432 () {
	if (hasRequiredGetNamedSlotA433c432) return getNamedSlotA433c432;
	hasRequiredGetNamedSlotA433c432 = 1;

	const validateProps = requireValidatePropsC2afb75b();

	const getNamedSlot = (el, slotName) => validateProps.getHTMLElement(el, `[slot="${slotName}"]`);

	getNamedSlotA433c432.getNamedSlot = getNamedSlot;

	
	return getNamedSlotA433c432;
}

var hasRequiredHasNamedSlot28c6bca1;

function requireHasNamedSlot28c6bca1 () {
	if (hasRequiredHasNamedSlot28c6bca1) return hasNamedSlot28c6bca1;
	hasRequiredHasNamedSlot28c6bca1 = 1;

	const getNamedSlot = requireGetNamedSlotA433c432();

	const hasNamedSlot = (el, slotName) => !!getNamedSlot.getNamedSlot(el, slotName);

	hasNamedSlot28c6bca1.hasNamedSlot = hasNamedSlot;

	
	return hasNamedSlot28c6bca1;
}

var spacingStaticXSmallB7d708b8 = {};

var hasRequiredSpacingStaticXSmallB7d708b8;

function requireSpacingStaticXSmallB7d708b8 () {
	if (hasRequiredSpacingStaticXSmallB7d708b8) return spacingStaticXSmallB7d708b8;
	hasRequiredSpacingStaticXSmallB7d708b8 = 1;

	const spacingStaticXSmall = '4px';

	spacingStaticXSmallB7d708b8.spacingStaticXSmall = spacingStaticXSmall;

	
	return spacingStaticXSmallB7d708b8;
}

var textSmallStyle7246779a = {};

var textShared9135e2ef = {};

var fontLineHeight78b03658 = {};

var hasRequiredFontLineHeight78b03658;

function requireFontLineHeight78b03658 () {
	if (hasRequiredFontLineHeight78b03658) return fontLineHeight78b03658;
	hasRequiredFontLineHeight78b03658 = 1;

	const fontFamily = "'Porsche Next','Arial Narrow',Arial,'Heiti SC',SimHei,sans-serif";

	const fontLineHeight = 'calc(6px + 2.125ex)';

	fontLineHeight78b03658.fontFamily = fontFamily;
	fontLineHeight78b03658.fontLineHeight = fontLineHeight;

	
	return fontLineHeight78b03658;
}

var fontWeightRegularD0c768ac = {};

var hasRequiredFontWeightRegularD0c768ac;

function requireFontWeightRegularD0c768ac () {
	if (hasRequiredFontWeightRegularD0c768ac) return fontWeightRegularD0c768ac;
	hasRequiredFontWeightRegularD0c768ac = 1;

	const fontWeightRegular = 400;

	fontWeightRegularD0c768ac.fontWeightRegular = fontWeightRegular;

	
	return fontWeightRegularD0c768ac;
}

var fontVariant6ba3b7cb = {};

var hasRequiredFontVariant6ba3b7cb;

function requireFontVariant6ba3b7cb () {
	if (hasRequiredFontVariant6ba3b7cb) return fontVariant6ba3b7cb;
	hasRequiredFontVariant6ba3b7cb = 1;

	const fontStyleNormal = 'normal';

	const fontVariant = 'normal';

	fontVariant6ba3b7cb.fontStyleNormal = fontStyleNormal;
	fontVariant6ba3b7cb.fontVariant = fontVariant;

	
	return fontVariant6ba3b7cb;
}

var hasRequiredTextShared9135e2ef;

function requireTextShared9135e2ef () {
	if (hasRequiredTextShared9135e2ef) return textShared9135e2ef;
	hasRequiredTextShared9135e2ef = 1;

	const fontLineHeight = requireFontLineHeight78b03658();
	const fontWeightRegular = requireFontWeightRegularD0c768ac();
	const fontVariant = requireFontVariant6ba3b7cb();

	const fontHyphenationStyle = {
	    overflowWrap: 'break-word',
	    hyphens: 'auto',
	};

	const _textFontPartA = `${fontVariant.fontStyleNormal} ${fontVariant.fontVariant} ${fontWeightRegular.fontWeightRegular} `;
	const _textFontPartB = `/${fontLineHeight.fontLineHeight} ${fontLineHeight.fontFamily}`;

	textShared9135e2ef._textFontPartA = _textFontPartA;
	textShared9135e2ef._textFontPartB = _textFontPartB;
	textShared9135e2ef.fontHyphenationStyle = fontHyphenationStyle;

	
	return textShared9135e2ef;
}

var fontSizeTextSmall508930e5 = {};

var hasRequiredFontSizeTextSmall508930e5;

function requireFontSizeTextSmall508930e5 () {
	if (hasRequiredFontSizeTextSmall508930e5) return fontSizeTextSmall508930e5;
	hasRequiredFontSizeTextSmall508930e5 = 1;

	const fontSizeTextSmall = '1rem';

	fontSizeTextSmall508930e5.fontSizeTextSmall = fontSizeTextSmall;

	
	return fontSizeTextSmall508930e5;
}

var hasRequiredTextSmallStyle7246779a;

function requireTextSmallStyle7246779a () {
	if (hasRequiredTextSmallStyle7246779a) return textSmallStyle7246779a;
	hasRequiredTextSmallStyle7246779a = 1;

	const textShared = requireTextShared9135e2ef();
	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();

	const textSmallStyle = {
	    font: `${textShared._textFontPartA}${fontSizeTextSmall.fontSizeTextSmall}${textShared._textFontPartB}`,
	    ...textShared.fontHyphenationStyle,
	};

	textSmallStyle7246779a.textSmallStyle = textSmallStyle;

	
	return textSmallStyle7246779a;
}

var hasRequiredRequiredBc18b612;

function requireRequiredBc18b612 () {
	if (hasRequiredRequiredBc18b612) return requiredBc18b612;
	hasRequiredRequiredBc18b612 = 1;

	const hasNamedSlot = requireHasNamedSlot28c6bca1();
	const validateProps = requireValidatePropsC2afb75b();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const textSmallStyle = requireTextSmallStyle7246779a();

	const FORM_STATES = ['none', 'error', 'success'];

	const getRole = (state) => {
	  return state === 'error' ? 'alert' : state === 'success' ? 'status' : null;
	};

	const hasLabel = (element, label) => {
	  return !!label || hasNamedSlot.hasNamedSlot(element, 'label');
	};

	const hasMessage = (element, message, state) => {
	  return (message || hasNamedSlot.hasNamedSlot(element, 'message')) && ['success', 'error'].includes(state);
	};

	const getThemedFormStateColors = (theme, state) => {
	  const themedColors = validateProps.getThemedColors(theme);
	  return {
	    formStateColor: themedColors[`${state}Color`],
	    formStateHoverColor: themedColors[`${state}ColorDarken`],
	  };
	};

	const getFunctionalComponentRequiredStyles = () => {
	  return {
	    required: {
	      userSelect: 'none',
	    },
	  };
	};

	const getFunctionalComponentStateMessageStyles = (theme, state) => {
	  return {
	    message: {
	      display: 'flex',
	      gap: spacingStaticXSmall.spacingStaticXSmall,
	      marginTop: spacingStaticXSmall.spacingStaticXSmall,
	      ...textSmallStyle.textSmallStyle,
	      color: getThemedFormStateColors(theme, state).formStateColor,
	      ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	        color: getThemedFormStateColors('dark', state).formStateColor,
	      }),
	      transition: validateProps.getTransition('color'),
	    },
	  };
	};

	const StateMessage = ({ id, state, message, theme, host }) => {
	  const PrefixedTagNames = validateProps.getPrefixedTagNames(host);
	  const isErrorState = state === 'error';
	  return (validateProps.h("span", { id: id, class: "message", role: getRole(state) },
	    validateProps.h(PrefixedTagNames.pIcon, { name: isErrorState ? 'exclamation' : 'check', color: isErrorState ? 'notification-error' : 'notification-success', theme: theme, "aria-hidden": "true" }),
	    message || validateProps.h("slot", { name: "message" })));
	};

	const Required = () => {
	  return validateProps.h("span", { class: "required" }, " *");
	};

	requiredBc18b612.FORM_STATES = FORM_STATES;
	requiredBc18b612.Required = Required;
	requiredBc18b612.StateMessage = StateMessage;
	requiredBc18b612.getFunctionalComponentRequiredStyles = getFunctionalComponentRequiredStyles;
	requiredBc18b612.getFunctionalComponentStateMessageStyles = getFunctionalComponentStateMessageStyles;
	requiredBc18b612.getThemedFormStateColors = getThemedFormStateColors;
	requiredBc18b612.hasLabel = hasLabel;
	requiredBc18b612.hasMessage = hasMessage;

	
	return requiredBc18b612;
}

var spacingStaticSmall2130ed04 = {};

var hasRequiredSpacingStaticSmall2130ed04;

function requireSpacingStaticSmall2130ed04 () {
	if (hasRequiredSpacingStaticSmall2130ed04) return spacingStaticSmall2130ed04;
	hasRequiredSpacingStaticSmall2130ed04 = 1;

	const spacingStaticSmall = '8px';

	spacingStaticSmall2130ed04.spacingStaticSmall = spacingStaticSmall;

	
	return spacingStaticSmall2130ed04;
}

var hasRequiredCheckboxRadioStylesEabaca96;

function requireCheckboxRadioStylesEabaca96 () {
	if (hasRequiredCheckboxRadioStylesEabaca96) return checkboxRadioStylesEabaca96;
	hasRequiredCheckboxRadioStylesEabaca96 = 1;

	const validateProps = requireValidatePropsC2afb75b();
	const isDisabledOrLoading = requireIsDisabledOrLoadingAd97a497();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const hoverMediaQuery = requireHoverMediaQueryF2ccfc24();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const required = requireRequiredBc18b612();
	const fontLineHeight = requireFontLineHeight78b03658();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();

	const changeHandler = ({ target }) => {
	  // workaround for Safari >= 15.5 -> attribute 'checked' is only set as property and not as attribute, this leads to rendering issues with keyboard navigation
	  // name attribute must be wrapped in quotes to allow exotic name values
	  document.querySelectorAll(`input[type=${target.type}][name="${target.name}"]`).forEach((el) => {
	    el.style.display = 'none';
	    el.style.display = '';
	    // TODO: about the described safari issue from above, why not just set the attribute like this?
	    // el.toggleAttribute('checked', el === target);
	  });
	};
	const addChangeListener = (el) => {
	  el.addEventListener('change', changeHandler);
	};

	const getCheckboxRadioJssStyle = (hideLabel, state, isDisabled, isLoading, theme) => {
	  const { primaryColor, contrastMediumColor, contrastHighColor, disabledColor, focusColor } = validateProps.getThemedColors(theme);
	  const { primaryColor: primaryColorDark, contrastMediumColor: contrastMediumColorDark, contrastHighColor: contrastHighColorDark, disabledColor: disabledColorDark, focusColor: focusColorDark, } = validateProps.getThemedColors('dark');
	  const { formStateColor, formStateHoverColor } = required.getThemedFormStateColors(theme, state);
	  const { formStateColor: formStateColorDark, formStateHoverColor: formStateHoverColorDark } = required.getThemedFormStateColors('dark', state);
	  const { canvasTextColor } = validateProps.getHighContrastColors();
	  const disabledOrLoading = isDisabledOrLoading.isDisabledOrLoading(isDisabled, isLoading);
	  // TODO: needs to be extracted into a color function
	  const uncheckedColor = disabledOrLoading ? disabledColor : formStateColor || contrastMediumColor;
	  const uncheckedColorDark = disabledOrLoading ? disabledColorDark : formStateColorDark || contrastMediumColorDark;
	  const uncheckedHoverColor = formStateHoverColor || primaryColor;
	  const uncheckedHoverColorDark = formStateHoverColorDark || primaryColorDark;
	  const checkedColor = validateProps.isHighContrastMode
	    ? canvasTextColor
	    : disabledOrLoading
	      ? disabledColor
	      : formStateColor || primaryColor;
	  const checkedColorDark = validateProps.isHighContrastMode
	    ? canvasTextColor
	    : disabledOrLoading
	      ? disabledColorDark
	      : formStateColorDark || primaryColorDark;
	  const checkedHoverColor = formStateHoverColor || contrastHighColor;
	  const checkedHoverColorDark = formStateHoverColorDark || contrastHighColorDark;
	  return {
	    '@global': {
	      ':host': validateProps.addImportantToEachRule({
	        ...colorSchemeStyles.colorSchemeStyles,
	        ...colorSchemeStyles.hostHiddenStyles,
	        display: 'block',
	      }),
	      '::slotted': validateProps.addImportantToEachRule({
	        '&(input)': {
	          position: 'relative',
	          width: fontLineHeight.fontLineHeight,
	          height: fontLineHeight.fontLineHeight,
	          fontFamily: fontLineHeight.fontFamily,
	          fontSize: '1rem',
	          flexShrink: 0,
	          display: 'block',
	          margin: 0,
	          padding: 0,
	          WebkitAppearance: 'none',
	          appearance: 'none',
	          boxSizing: 'content-box',
	          background: `transparent 0% 0% / ${fontLineHeight.fontLineHeight}`,
	          transition: ['border-color', 'background-color'].map(validateProps.getTransition).join(),
	          border: `2px solid ${uncheckedColor}`,
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	            borderColor: uncheckedColorDark,
	          }),
	          outline: 0,
	          cursor: disabledOrLoading ? 'not-allowed' : 'pointer',
	        },
	        '&(input:checked)': {
	          // background-image is merged in later
	          borderColor: checkedColor,
	          backgroundColor: checkedColor,
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	            borderColor: checkedColorDark,
	            backgroundColor: checkedColorDark,
	          }),
	        },
	        ...(!disabledOrLoading && {
	          ...(!validateProps.isHighContrastMode &&
	            hoverMediaQuery.hoverMediaQuery({
	              '&(input:hover), .text:hover ~ &(input)': {
	                borderColor: uncheckedHoverColor,
	                ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	                  borderColor: uncheckedHoverColorDark,
	                }),
	              },
	              '&(input:checked:hover), .text:hover ~ &(input:checked)': {
	                borderColor: checkedHoverColor,
	                backgroundColor: checkedHoverColor,
	                ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	                  borderColor: checkedHoverColorDark,
	                  backgroundColor: checkedHoverColorDark,
	                }),
	              },
	            })),
	          ...(!isDisabled && {
	            '&(input:focus)::before': {
	              content: '""',
	              position: 'absolute',
	              ...validateProps.getInsetJssStyle(-6),
	              border: `${validateProps.borderWidthBase} solid ${focusColor}`,
	              ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	                borderColor: focusColorDark,
	              }),
	            },
	            '&(input:focus:not(:focus-visible))::before': {
	              borderColor: 'transparent',
	            },
	          }),
	        }),
	      }),
	      label: {
	        position: 'relative',
	        display: 'flex',
	        alignItems: 'flex-start',
	      },
	    },
	    text: {
	      order: 1,
	      cursor: disabledOrLoading ? 'default' : 'pointer',
	      ...textSmallStyle.textSmallStyle,
	      color: disabledOrLoading ? disabledColor : primaryColor,
	      ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	        color: disabledOrLoading ? disabledColorDark : primaryColorDark,
	      }),
	      transition: validateProps.getTransition('color'),
	      ...validateProps.buildResponsiveStyles(hideLabel, (isHidden) => validateProps.getHiddenTextJssStyle(isHidden, { padding: `2px 0 0 ${spacingStaticSmall.spacingStaticSmall}` })),
	    },
	    ...required.getFunctionalComponentRequiredStyles(),
	    ...required.getFunctionalComponentStateMessageStyles(theme, state),
	    ...(isLoading && {
	      spinner: {
	        position: 'absolute',
	        top: `calc(${fontLineHeight.fontLineHeight}/2 + 2px)`,
	        left: `calc(${fontLineHeight.fontLineHeight}/2 + 2px)`,
	        transform: 'translate(-50%, -50%)',
	        height: fontLineHeight.fontLineHeight,
	        width: fontLineHeight.fontLineHeight,
	        padding: '2px',
	        fontFamily: fontLineHeight.fontFamily,
	        fontSize: '1rem',
	        cursor: 'not-allowed',
	      },
	    }),
	  };
	};

	checkboxRadioStylesEabaca96.addChangeListener = addChangeListener;
	checkboxRadioStylesEabaca96.getCheckboxRadioJssStyle = getCheckboxRadioJssStyle;

	
	return checkboxRadioStylesEabaca96;
}

var constantsCa271244 = {};

var hasRequiredConstantsCa271244;

function requireConstantsCa271244 () {
	if (hasRequiredConstantsCa271244) return constantsCa271244;
	hasRequiredConstantsCa271244 = 1;

	const TOAST_Z_INDEX = 999999;
	const MODAL_Z_INDEX = 99999;
	const FLYOUT_Z_INDEX = 99998;
	const POPOVER_Z_INDEX = 9999;
	const BANNER_Z_INDEX = 99;

	constantsCa271244.BANNER_Z_INDEX = BANNER_Z_INDEX;
	constantsCa271244.FLYOUT_Z_INDEX = FLYOUT_Z_INDEX;
	constantsCa271244.MODAL_Z_INDEX = MODAL_Z_INDEX;
	constantsCa271244.POPOVER_Z_INDEX = POPOVER_Z_INDEX;
	constantsCa271244.TOAST_Z_INDEX = TOAST_Z_INDEX;

	
	return constantsCa271244;
}

var displayShared43dd15a5 = {};

var hasRequiredDisplayShared43dd15a5;

function requireDisplayShared43dd15a5 () {
	if (hasRequiredDisplayShared43dd15a5) return displayShared43dd15a5;
	hasRequiredDisplayShared43dd15a5 = 1;

	const fontLineHeight = requireFontLineHeight78b03658();
	const fontWeightRegular = requireFontWeightRegularD0c768ac();
	const fontVariant = requireFontVariant6ba3b7cb();

	const fontSizeDisplayMedium = 'clamp(2.03rem, 3.58vw + 1.31rem, 5.61rem)';

	const _displayFontPartA = `${fontVariant.fontStyleNormal} ${fontVariant.fontVariant} ${fontWeightRegular.fontWeightRegular} `;
	const _displayFontPartB = `/${fontLineHeight.fontLineHeight} ${fontLineHeight.fontFamily}`;

	displayShared43dd15a5._displayFontPartA = _displayFontPartA;
	displayShared43dd15a5._displayFontPartB = _displayFontPartB;
	displayShared43dd15a5.fontSizeDisplayMedium = fontSizeDisplayMedium;

	
	return displayShared43dd15a5;
}

var dropShadowHighStyle7edcadc6 = {};

var dropShadowShared6e50faf3 = {};

var hasRequiredDropShadowShared6e50faf3;

function requireDropShadowShared6e50faf3 () {
	if (hasRequiredDropShadowShared6e50faf3) return dropShadowShared6e50faf3;
	hasRequiredDropShadowShared6e50faf3 = 1;

	const _dropShadowBackgroundColor = 'rgba(0, 0, 0, 0.16)';

	dropShadowShared6e50faf3._dropShadowBackgroundColor = _dropShadowBackgroundColor;

	
	return dropShadowShared6e50faf3;
}

var hasRequiredDropShadowHighStyle7edcadc6;

function requireDropShadowHighStyle7edcadc6 () {
	if (hasRequiredDropShadowHighStyle7edcadc6) return dropShadowHighStyle7edcadc6;
	hasRequiredDropShadowHighStyle7edcadc6 = 1;

	const dropShadowShared = requireDropShadowShared6e50faf3();

	const dropShadowHighStyle = {
	    boxShadow: `0px 8px 40px ${dropShadowShared._dropShadowBackgroundColor}`, // filter: drop-shadow() causes visual glitches in Firefox in combination with frostedGlassStyle
	};

	dropShadowHighStyle7edcadc6.dropShadowHighStyle = dropShadowHighStyle;

	
	return dropShadowHighStyle7edcadc6;
}

var escapeHashCharacter072604c4 = {};

var hasRequiredEscapeHashCharacter072604c4;

function requireEscapeHashCharacter072604c4 () {
	if (hasRequiredEscapeHashCharacter072604c4) return escapeHashCharacter072604c4;
	hasRequiredEscapeHashCharacter072604c4 = 1;

	const getInlineSVGBackgroundImage = (path) => {
	  return `url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">${path}</svg>')`;
	};

	const escapeHashCharacter = (colorString) => {
	  return colorString.replace('#', '%23');
	};

	escapeHashCharacter072604c4.escapeHashCharacter = escapeHashCharacter;
	escapeHashCharacter072604c4.getInlineSVGBackgroundImage = getInlineSVGBackgroundImage;

	
	return escapeHashCharacter072604c4;
}

var fieldsetUtils1fdf9685 = {};

var headingSharedAa59e66d = {};

var fontWeightSemiBold4482c830 = {};

var hasRequiredFontWeightSemiBold4482c830;

function requireFontWeightSemiBold4482c830 () {
	if (hasRequiredFontWeightSemiBold4482c830) return fontWeightSemiBold4482c830;
	hasRequiredFontWeightSemiBold4482c830 = 1;

	const fontWeightSemiBold = 600;

	fontWeightSemiBold4482c830.fontWeightSemiBold = fontWeightSemiBold;

	
	return fontWeightSemiBold4482c830;
}

var hasRequiredHeadingSharedAa59e66d;

function requireHeadingSharedAa59e66d () {
	if (hasRequiredHeadingSharedAa59e66d) return headingSharedAa59e66d;
	hasRequiredHeadingSharedAa59e66d = 1;

	const fontLineHeight = requireFontLineHeight78b03658();
	const fontWeightSemiBold = requireFontWeightSemiBold4482c830();
	const fontVariant = requireFontVariant6ba3b7cb();

	const _headingFontPartA = `${fontVariant.fontStyleNormal} ${fontVariant.fontVariant} ${fontWeightSemiBold.fontWeightSemiBold} `;
	const _headingFontPartB = `/${fontLineHeight.fontLineHeight} ${fontLineHeight.fontFamily}`;

	headingSharedAa59e66d._headingFontPartA = _headingFontPartA;
	headingSharedAa59e66d._headingFontPartB = _headingFontPartB;

	
	return headingSharedAa59e66d;
}

var fontSizeHeadingMediumC49ab5a2 = {};

var fontSizeTextMedium88887ad8 = {};

var hasRequiredFontSizeTextMedium88887ad8;

function requireFontSizeTextMedium88887ad8 () {
	if (hasRequiredFontSizeTextMedium88887ad8) return fontSizeTextMedium88887ad8;
	hasRequiredFontSizeTextMedium88887ad8 = 1;

	const fontSizeTextMedium = 'clamp(1.13rem, 0.21vw + 1.08rem, 1.33rem)';

	fontSizeTextMedium88887ad8.fontSizeTextMedium = fontSizeTextMedium;

	
	return fontSizeTextMedium88887ad8;
}

var hasRequiredFontSizeHeadingMediumC49ab5a2;

function requireFontSizeHeadingMediumC49ab5a2 () {
	if (hasRequiredFontSizeHeadingMediumC49ab5a2) return fontSizeHeadingMediumC49ab5a2;
	hasRequiredFontSizeHeadingMediumC49ab5a2 = 1;

	const fontSizeTextMedium = requireFontSizeTextMedium88887ad8();

	const fontSizeHeadingMedium = fontSizeTextMedium.fontSizeTextMedium;

	fontSizeHeadingMediumC49ab5a2.fontSizeHeadingMedium = fontSizeHeadingMedium;

	
	return fontSizeHeadingMediumC49ab5a2;
}

var hasRequiredFieldsetUtils1fdf9685;

function requireFieldsetUtils1fdf9685 () {
	if (hasRequiredFieldsetUtils1fdf9685) return fieldsetUtils1fdf9685;
	hasRequiredFieldsetUtils1fdf9685 = 1;

	const headingShared = requireHeadingSharedAa59e66d();
	const fontSizeHeadingMedium = requireFontSizeHeadingMediumC49ab5a2();

	const headingMediumStyle = {
	    font: `${headingShared._headingFontPartA}${fontSizeHeadingMedium.fontSizeHeadingMedium}${headingShared._headingFontPartB}`,
	};

	const FIELDSET_LABEL_SIZES = ['small', 'medium'];

	fieldsetUtils1fdf9685.FIELDSET_LABEL_SIZES = FIELDSET_LABEL_SIZES;
	fieldsetUtils1fdf9685.headingMediumStyle = headingMediumStyle;

	
	return fieldsetUtils1fdf9685;
}

var filtersPrimary7e1fcfed = {};

var hasRequiredFiltersPrimary7e1fcfed;

function requireFiltersPrimary7e1fcfed () {
	if (hasRequiredFiltersPrimary7e1fcfed) return filtersPrimary7e1fcfed;
	hasRequiredFiltersPrimary7e1fcfed = 1;

	const toFilter = (values) => `invert(${values[0]}%) sepia(${values[1]}%) saturate(${values[2]}%) hue-rotate(${values[3]}deg) brightness(${values[4]}%) contrast(${values[5]}%)`;

	const filterLightContrastLow = toFilter([93, 11, 36, 201, 89, 102]);
	const filterLightContrastMedium = toFilter([45, 6, 235, 177, 91, 85]);
	const filterLightContrastHigh = toFilter([40, 2, 686, 187, 80, 94]);
	const filterDarkContrastLow = toFilter([20, 7, 421, 202, 97, 82]);
	const filterDarkContrastMedium = toFilter([66, 3, 333, 187, 82, 86]);
	const filterDarkContrastHigh = toFilter([68, 6, 108, 187, 104, 88]);

	const filterLightPrimary = toFilter([3, 7, 2930, 188, 91, 103]);
	const filterDarkPrimary = toFilter([100, 91, 38, 254, 110, 110]);

	filtersPrimary7e1fcfed.filterDarkContrastHigh = filterDarkContrastHigh;
	filtersPrimary7e1fcfed.filterDarkContrastLow = filterDarkContrastLow;
	filtersPrimary7e1fcfed.filterDarkContrastMedium = filterDarkContrastMedium;
	filtersPrimary7e1fcfed.filterDarkPrimary = filterDarkPrimary;
	filtersPrimary7e1fcfed.filterLightContrastHigh = filterLightContrastHigh;
	filtersPrimary7e1fcfed.filterLightContrastLow = filterLightContrastLow;
	filtersPrimary7e1fcfed.filterLightContrastMedium = filterLightContrastMedium;
	filtersPrimary7e1fcfed.filterLightPrimary = filterLightPrimary;
	filtersPrimary7e1fcfed.toFilter = toFilter;

	
	return filtersPrimary7e1fcfed;
}

var fontWeightStyles4b24ddd8 = {};

var hasRequiredFontWeightStyles4b24ddd8;

function requireFontWeightStyles4b24ddd8 () {
	if (hasRequiredFontWeightStyles4b24ddd8) return fontWeightStyles4b24ddd8;
	hasRequiredFontWeightStyles4b24ddd8 = 1;

	const fontWeightRegular = requireFontWeightRegularD0c768ac();
	const fontWeightSemiBold = requireFontWeightSemiBold4482c830();

	const fontWeightBold = 700;

	const fontWeightMap = {
	  regular: fontWeightRegular.fontWeightRegular,
	  'semi-bold': fontWeightSemiBold.fontWeightSemiBold,
	  bold: fontWeightBold,
	};
	const getFontWeight = (weight) => {
	  return fontWeightMap[weight];
	};

	fontWeightStyles4b24ddd8.getFontWeight = getFontWeight;

	
	return fontWeightStyles4b24ddd8;
}

var fontSizeHeadingLargeC355151d = {};

var fontSizeTextLarge05a4bc90 = {};

var hasRequiredFontSizeTextLarge05a4bc90;

function requireFontSizeTextLarge05a4bc90 () {
	if (hasRequiredFontSizeTextLarge05a4bc90) return fontSizeTextLarge05a4bc90;
	hasRequiredFontSizeTextLarge05a4bc90 = 1;

	const fontSizeTextLarge = 'clamp(1.27rem, 0.51vw + 1.16rem, 1.78rem)';

	fontSizeTextLarge05a4bc90.fontSizeTextLarge = fontSizeTextLarge;

	
	return fontSizeTextLarge05a4bc90;
}

var hasRequiredFontSizeHeadingLargeC355151d;

function requireFontSizeHeadingLargeC355151d () {
	if (hasRequiredFontSizeHeadingLargeC355151d) return fontSizeHeadingLargeC355151d;
	hasRequiredFontSizeHeadingLargeC355151d = 1;

	const fontSizeTextLarge = requireFontSizeTextLarge05a4bc90();

	const fontSizeHeadingLarge = fontSizeTextLarge.fontSizeTextLarge;

	fontSizeHeadingLargeC355151d.fontSizeHeadingLarge = fontSizeHeadingLarge;

	
	return fontSizeHeadingLargeC355151d;
}

var fontSizeHeadingSmallA15141a5 = {};

var hasRequiredFontSizeHeadingSmallA15141a5;

function requireFontSizeHeadingSmallA15141a5 () {
	if (hasRequiredFontSizeHeadingSmallA15141a5) return fontSizeHeadingSmallA15141a5;
	hasRequiredFontSizeHeadingSmallA15141a5 = 1;

	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();

	const fontSizeHeadingSmall = fontSizeTextSmall.fontSizeTextSmall;

	fontSizeHeadingSmallA15141a5.fontSizeHeadingSmall = fontSizeHeadingSmall;

	
	return fontSizeHeadingSmallA15141a5;
}

var fontSizeHeadingXLargeF33a0a84 = {};

var fontSizeTextXLarge0ecf9ef3 = {};

var hasRequiredFontSizeTextXLarge0ecf9ef3;

function requireFontSizeTextXLarge0ecf9ef3 () {
	if (hasRequiredFontSizeTextXLarge0ecf9ef3) return fontSizeTextXLarge0ecf9ef3;
	hasRequiredFontSizeTextXLarge0ecf9ef3 = 1;

	const fontSizeTextXLarge = 'clamp(1.42rem, 0.94vw + 1.23rem, 2.37rem)';

	fontSizeTextXLarge0ecf9ef3.fontSizeTextXLarge = fontSizeTextXLarge;

	
	return fontSizeTextXLarge0ecf9ef3;
}

var hasRequiredFontSizeHeadingXLargeF33a0a84;

function requireFontSizeHeadingXLargeF33a0a84 () {
	if (hasRequiredFontSizeHeadingXLargeF33a0a84) return fontSizeHeadingXLargeF33a0a84;
	hasRequiredFontSizeHeadingXLargeF33a0a84 = 1;

	const fontSizeTextXLarge = requireFontSizeTextXLarge0ecf9ef3();

	const fontSizeHeadingXLarge = fontSizeTextXLarge.fontSizeTextXLarge;

	fontSizeHeadingXLargeF33a0a84.fontSizeHeadingXLarge = fontSizeHeadingXLarge;

	
	return fontSizeHeadingXLargeF33a0a84;
}

var fontSizeText728b6387 = {};

var fontSizeTextXXSmallA02f9c40 = {};

var hasRequiredFontSizeTextXXSmallA02f9c40;

function requireFontSizeTextXXSmallA02f9c40 () {
	if (hasRequiredFontSizeTextXXSmallA02f9c40) return fontSizeTextXXSmallA02f9c40;
	hasRequiredFontSizeTextXXSmallA02f9c40 = 1;

	const fontSizeTextXXSmall = '.75rem';

	fontSizeTextXXSmallA02f9c40.fontSizeTextXXSmall = fontSizeTextXXSmall;

	
	return fontSizeTextXXSmallA02f9c40;
}

var fontSizeTextXSmallE59d35d7 = {};

var hasRequiredFontSizeTextXSmallE59d35d7;

function requireFontSizeTextXSmallE59d35d7 () {
	if (hasRequiredFontSizeTextXSmallE59d35d7) return fontSizeTextXSmallE59d35d7;
	hasRequiredFontSizeTextXSmallE59d35d7 = 1;

	const fontSizeTextXSmall = 'clamp(0.81rem, 0.23vw + 0.77rem, 0.88rem)';

	fontSizeTextXSmallE59d35d7.fontSizeTextXSmall = fontSizeTextXSmall;

	
	return fontSizeTextXSmallE59d35d7;
}

var hasRequiredFontSizeText728b6387;

function requireFontSizeText728b6387 () {
	if (hasRequiredFontSizeText728b6387) return fontSizeText728b6387;
	hasRequiredFontSizeText728b6387 = 1;

	const fontSizeTextXXSmall = requireFontSizeTextXXSmallA02f9c40();
	const fontSizeTextXSmall = requireFontSizeTextXSmallE59d35d7();
	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();
	const fontSizeTextMedium = requireFontSizeTextMedium88887ad8();
	const fontSizeTextLarge = requireFontSizeTextLarge05a4bc90();
	const fontSizeTextXLarge = requireFontSizeTextXLarge0ecf9ef3();

	const fontSizeText = {
	    xxSmall: fontSizeTextXXSmall.fontSizeTextXXSmall,
	    xSmall: fontSizeTextXSmall.fontSizeTextXSmall,
	    small: fontSizeTextSmall.fontSizeTextSmall,
	    medium: fontSizeTextMedium.fontSizeTextMedium,
	    large: fontSizeTextLarge.fontSizeTextLarge,
	    xLarge: fontSizeTextXLarge.fontSizeTextXLarge,
	};

	fontSizeText728b6387.fontSizeText = fontSizeText;

	
	return fontSizeText728b6387;
}

var formStyles97f2cdf7 = {};

var hasRequiredFormStyles97f2cdf7;

function requireFormStyles97f2cdf7 () {
	if (hasRequiredFormStyles97f2cdf7) return formStyles97f2cdf7;
	hasRequiredFormStyles97f2cdf7 = 1;

	const validateProps = requireValidatePropsC2afb75b();
	const hoverMediaQuery = requireHoverMediaQueryF2ccfc24();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const required = requireRequiredBc18b612();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const fontSizeTextXSmall = requireFontSizeTextXSmallE59d35d7();
	const fontLineHeight = requireFontLineHeight78b03658();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();

	// TODO: should be removed if possible?
	const INPUT_HEIGHT = 54;
	const getBaseChildStyles = (child, state, theme, additionalDefaultJssStyle) => {
	  const { primaryColor, contrastLowColor, contrastMediumColor, disabledColor } = validateProps.getThemedColors(theme);
	  const { primaryColor: primaryColorDark, contrastLowColor: contrastLowColorDark, contrastMediumColor: contrastMediumColorDark, disabledColor: disabledColorDark, } = validateProps.getThemedColors('dark');
	  const { formStateColor, formStateHoverColor } = required.getThemedFormStateColors(theme, state);
	  const { formStateColor: formStateColorDark, formStateHoverColor: formStateHoverColorDark } = required.getThemedFormStateColors('dark', state);
	  return {
	    [`::slotted(${child})`]: {
	      display: 'block',
	      width: '100%',
	      height: child !== 'textarea'
	        ? `calc(${fontLineHeight.fontLineHeight} + 10px + ${validateProps.borderWidthBase} * 2 + ${spacingStaticSmall.spacingStaticSmall} * 2)` // we need 10px additionally so input height becomes 54px
	        : 'auto',
	      margin: 0,
	      outline: 0,
	      WebkitAppearance: 'none',
	      appearance: 'none',
	      boxSizing: 'border-box',
	      border: `${validateProps.borderWidthBase} solid ${formStateColor || contrastMediumColor}`,
	      borderRadius: borderRadiusSmall.borderRadiusSmall,
	      background: 'transparent',
	      font: textSmallStyle.textSmallStyle.font.replace('ex', 'ex + 6px'),
	      textIndent: 0,
	      color: primaryColor,
	      transition: ['color', 'border-color', 'background-color'].map(validateProps.getTransition).join(),
	      ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	        borderColor: formStateColorDark || contrastMediumColorDark,
	        color: primaryColorDark,
	      }),
	      ...additionalDefaultJssStyle,
	    },
	    ...hoverMediaQuery.hoverMediaQuery({
	      // with the media query the selector has higher priority and overrides disabled styles
	      [`::slotted(${child}:not(:disabled):not(:focus):not([readonly]):hover)`]: {
	        borderColor: formStateHoverColor || primaryColor,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          borderColor: formStateHoverColorDark || primaryColorDark,
	        }),
	      },
	    }),
	    [`::slotted(${child}:focus)`]: {
	      borderColor: primaryColor,
	      ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	        borderColor: primaryColorDark,
	      }),
	    },
	    [`::slotted(${child}:disabled)`]: {
	      cursor: 'not-allowed',
	      color: disabledColor,
	      borderColor: disabledColor,
	      WebkitTextFillColor: disabledColor,
	      ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	        color: disabledColorDark,
	        borderColor: disabledColorDark,
	        WebkitTextFillColor: disabledColorDark,
	      }),
	    },
	    ...(child !== 'select' && {
	      [`::slotted(${child}[readonly])`]: {
	        borderColor: contrastLowColor,
	        background: contrastLowColor,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          borderColor: contrastLowColorDark,
	          background: contrastLowColorDark,
	        }),
	      },
	    }),
	  };
	};
	const getLabelStyles = (child, isDisabled, hideLabel, state, theme, counterOrUnitOrIconStyles, additionalLabelJssStyle) => {
	  const { primaryColor, disabledColor, contrastHighColor } = validateProps.getThemedColors(theme);
	  const { primaryColor: primaryColorDark, disabledColor: disabledColorDark, contrastHighColor: contrastHighColorDark, } = validateProps.getThemedColors('dark');
	  const { formStateHoverColor } = required.getThemedFormStateColors(theme, state);
	  const { formStateHoverColor: formStateHoverColorDark } = required.getThemedFormStateColors('dark', state);
	  const counterOrUnitOrIconStylesKey = counterOrUnitOrIconStyles && Object.keys(counterOrUnitOrIconStyles)[0];
	  return {
	    label: {
	      display: 'flex',
	      flexDirection: 'column',
	      gap: spacingStaticXSmall.spacingStaticXSmall,
	      position: 'relative',
	      '&__text': {
	        display: 'block',
	        ...validateProps.buildResponsiveStyles(hideLabel, (isHidden) => validateProps.getHiddenTextJssStyle(isHidden, { width: 'fit-content' })),
	        ...textSmallStyle.textSmallStyle,
	        color: isDisabled ? disabledColor : primaryColor,
	        transition: validateProps.getTransition('color'),
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          color: isDisabled ? disabledColorDark : primaryColorDark,
	        }),
	        '&+&': {
	          marginTop: `-${spacingStaticXSmall.spacingStaticXSmall}`,
	          fontSize: fontSizeTextXSmall.fontSizeTextXSmall,
	          ...(!isDisabled && {
	            color: contrastHighColor,
	            ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	              color: contrastHighColorDark,
	            }),
	          }),
	        },
	        ...hoverMediaQuery.hoverMediaQuery({
	          '&:hover': {
	            [`&~::slotted(${child}:not(:disabled):not(:focus):not([readonly]))`]: {
	              borderColor: validateProps.addImportantToRule(formStateHoverColor || primaryColor),
	              ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	                borderColor: validateProps.addImportantToRule(formStateHoverColorDark || primaryColorDark),
	              }),
	            },
	          },
	        }),
	      },
	      ...additionalLabelJssStyle,
	    },
	    ...(counterOrUnitOrIconStyles && {
	      [counterOrUnitOrIconStylesKey]: {
	        ...counterOrUnitOrIconStyles[counterOrUnitOrIconStylesKey],
	        pointerEvents: 'none',
	        ...(isDisabled && {
	          color: disabledColor,
	          cursor: 'not-allowed',
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	            color: disabledColorDark,
	          }),
	        }),
	      },
	    }),
	  };
	};

	formStyles97f2cdf7.INPUT_HEIGHT = INPUT_HEIGHT;
	formStyles97f2cdf7.getBaseChildStyles = getBaseChildStyles;
	formStyles97f2cdf7.getLabelStyles = getLabelStyles;

	
	return formStyles97f2cdf7;
}

var getButtonBaseAriaAttributes51363b44 = {};

var hasRequiredGetButtonBaseAriaAttributes51363b44;

function requireGetButtonBaseAriaAttributes51363b44 () {
	if (hasRequiredGetButtonBaseAriaAttributes51363b44) return getButtonBaseAriaAttributes51363b44;
	hasRequiredGetButtonBaseAriaAttributes51363b44 = 1;

	const isDisabledOrLoading = requireIsDisabledOrLoadingAd97a497();
	requireValidatePropsC2afb75b();

	const getButtonBaseAriaAttributes = (isDisabled, isLoading) => {
	  return {
	    'aria-disabled': isDisabledOrLoading.isDisabledOrLoading(isDisabled, isLoading) ? 'true' : null,
	    'aria-busy': isLoading ? 'true' : null,
	  };
	};

	getButtonBaseAriaAttributes51363b44.getButtonBaseAriaAttributes = getButtonBaseAriaAttributes;

	
	return getButtonBaseAriaAttributes51363b44;
}

var getAttribute4e18832c = {};

var hasRequiredGetAttribute4e18832c;

function requireGetAttribute4e18832c () {
	if (hasRequiredGetAttribute4e18832c) return getAttribute4e18832c;
	hasRequiredGetAttribute4e18832c = 1;

	const getAttribute = (el, attributeName) => {
	  return el.getAttribute(attributeName);
	};

	getAttribute4e18832c.getAttribute = getAttribute;

	
	return getAttribute4e18832c;
}

var getClickedItemE7e5ae2c = {};

var hasRequiredGetClickedItemE7e5ae2c;

function requireGetClickedItemE7e5ae2c () {
	if (hasRequiredGetClickedItemE7e5ae2c) return getClickedItemE7e5ae2c;
	hasRequiredGetClickedItemE7e5ae2c = 1;

	const validateProps = requireValidatePropsC2afb75b();

	const getClickedItem = (host, tagName, targets) => {
	  const item = validateProps.getPrefixedTagNames(host)[validateProps.paramCaseToCamelCase(tagName)];
	  return targets.find((x) => x.tagName?.toLowerCase() === item);
	};

	getClickedItemE7e5ae2c.getClickedItem = getClickedItem;

	
	return getClickedItemE7e5ae2c;
}

var getDirectChildHTMLElements0adb2021 = {};

var getHTMLElements21fc87cc = {};

var hasRequiredGetHTMLElements21fc87cc;

function requireGetHTMLElements21fc87cc () {
	if (hasRequiredGetHTMLElements21fc87cc) return getHTMLElements21fc87cc;
	hasRequiredGetHTMLElements21fc87cc = 1;

	function getHTMLElements(element, selector) {
	  return element ? Array.from(element.querySelectorAll(selector)) : [];
	}

	getHTMLElements21fc87cc.getHTMLElements = getHTMLElements;

	
	return getHTMLElements21fc87cc;
}

var transformSelectorToDirectChildSelector08da8668 = {};

var hasRequiredTransformSelectorToDirectChildSelector08da8668;

function requireTransformSelectorToDirectChildSelector08da8668 () {
	if (hasRequiredTransformSelectorToDirectChildSelector08da8668) return transformSelectorToDirectChildSelector08da8668;
	hasRequiredTransformSelectorToDirectChildSelector08da8668 = 1;

	const transformSelectorToDirectChildSelector = (selector) => selector
	  .split(',')
	  .map((part) => ':scope>' + part)
	  .join();

	transformSelectorToDirectChildSelector08da8668.transformSelectorToDirectChildSelector = transformSelectorToDirectChildSelector;

	
	return transformSelectorToDirectChildSelector08da8668;
}

var hasRequiredGetDirectChildHTMLElements0adb2021;

function requireGetDirectChildHTMLElements0adb2021 () {
	if (hasRequiredGetDirectChildHTMLElements0adb2021) return getDirectChildHTMLElements0adb2021;
	hasRequiredGetDirectChildHTMLElements0adb2021 = 1;

	const getHTMLElements = requireGetHTMLElements21fc87cc();
	const transformSelectorToDirectChildSelector = requireTransformSelectorToDirectChildSelector08da8668();

	/* eslint-disable prefer-arrow/prefer-arrow-functions */
	function getDirectChildHTMLElements(element, selector) {
	  // querySelector(All) doesn't work with :scope pseudo class and comma separator in jsdom, yet
	  // https://github.com/jsdom/jsdom/issues/3141
	  // therefore we got a workaround so it works nicely when consumed from jsdom-polyfill package
	  return transformSelectorToDirectChildSelector.transformSelectorToDirectChildSelector(selector)
	    .split(',')
	    .map((sel) => getHTMLElements.getHTMLElements(element, sel))
	    .flat(); // might contain duplicates
	}

	getDirectChildHTMLElements0adb2021.getDirectChildHTMLElements = getDirectChildHTMLElements;

	
	return getDirectChildHTMLElements0adb2021;
}

var getMediaQueryMax2587ee0a = {};

var hasRequiredGetMediaQueryMax2587ee0a;

function requireGetMediaQueryMax2587ee0a () {
	if (hasRequiredGetMediaQueryMax2587ee0a) return getMediaQueryMax2587ee0a;
	hasRequiredGetMediaQueryMax2587ee0a = 1;

	const validateProps = requireValidatePropsC2afb75b();

	function getMediaQueryMax(max) {
	    return `@media(max-width:${validateProps.breakpoint[max] - 1}px)`;
	}

	getMediaQueryMax2587ee0a.getMediaQueryMax = getMediaQueryMax;

	
	return getMediaQueryMax2587ee0a;
}

var getOnlyChildOfKindHTMLElementOrThrowF6972c1c = {};

var hasRequiredGetOnlyChildOfKindHTMLElementOrThrowF6972c1c;

function requireGetOnlyChildOfKindHTMLElementOrThrowF6972c1c () {
	if (hasRequiredGetOnlyChildOfKindHTMLElementOrThrowF6972c1c) return getOnlyChildOfKindHTMLElementOrThrowF6972c1c;
	hasRequiredGetOnlyChildOfKindHTMLElementOrThrowF6972c1c = 1;

	const validateProps = requireValidatePropsC2afb75b();
	const getDirectChildHTMLElements = requireGetDirectChildHTMLElements0adb2021();

	/* eslint-disable prefer-arrow/prefer-arrow-functions */
	function getOnlyChildOfKindHTMLElementOrThrow(element, selector) {
	  // we need to support named slots for label/description or message, hence we can't verify element.children.length
	  const directChildren = getDirectChildHTMLElements.getDirectChildHTMLElements(element, selector);
	  if (directChildren.length !== 1) {
	    validateProps.throwException(`${validateProps.getTagNameWithoutPrefix(element)} has to contain a single direct child of: ${selector}`);
	  }
	  return directChildren[0];
	}

	getOnlyChildOfKindHTMLElementOrThrowF6972c1c.getOnlyChildOfKindHTMLElementOrThrow = getOnlyChildOfKindHTMLElementOrThrow;

	
	return getOnlyChildOfKindHTMLElementOrThrowF6972c1c;
}

var getSlotTextContent5379eb26 = {};

var hasRequiredGetSlotTextContent5379eb26;

function requireGetSlotTextContent5379eb26 () {
	if (hasRequiredGetSlotTextContent5379eb26) return getSlotTextContent5379eb26;
	hasRequiredGetSlotTextContent5379eb26 = 1;

	const validateProps = requireValidatePropsC2afb75b();

	const getSlotTextContent = (el, slotName) => validateProps.getHTMLElement(el, `[slot="${slotName}"]`)?.textContent;

	getSlotTextContent5379eb26.getSlotTextContent = getSlotTextContent;

	
	return getSlotTextContent5379eb26;
}

var gridBasicOffsetEafb13d6 = {};

var gridExtendedOffsetBaseFb9830f6 = {};

var hasRequiredGridExtendedOffsetBaseFb9830f6;

function requireGridExtendedOffsetBaseFb9830f6 () {
	if (hasRequiredGridExtendedOffsetBaseFb9830f6) return gridExtendedOffsetBaseFb9830f6;
	hasRequiredGridExtendedOffsetBaseFb9830f6 = 1;

	const _gridWidthMax = '2560px';
	// fluid sizing calculated by https://fluidtypography.com/#app-get-started
	const _gridSafeZoneBase = 'max(22px, 10.625vw - 12px)'; // viewport-width range = 320 - 760px / size range = 22 - 68.75px
	const _gridSafeZoneS = 'calc(5vw - 16px)'; // viewport-width range = 760 - 1920px / size range = 22(22.75) - 80(79.71)px
	const _gridSafeZoneXXL = 'min(50vw - 880px, 400px)'; // viewport-width range = 1920 - 2560px / size range = 80(79.71)px - 400(399.71)px

	const gridExtendedOffsetBase = _gridSafeZoneBase;

	gridExtendedOffsetBaseFb9830f6._gridSafeZoneBase = _gridSafeZoneBase;
	gridExtendedOffsetBaseFb9830f6._gridSafeZoneS = _gridSafeZoneS;
	gridExtendedOffsetBaseFb9830f6._gridSafeZoneXXL = _gridSafeZoneXXL;
	gridExtendedOffsetBaseFb9830f6._gridWidthMax = _gridWidthMax;
	gridExtendedOffsetBaseFb9830f6.gridExtendedOffsetBase = gridExtendedOffsetBase;

	
	return gridExtendedOffsetBaseFb9830f6;
}

var gridExtendedOffsetXXLC7a41e50 = {};

var gridGapB5b73e4a = {};

var spacingFluidMedium88ab712b = {};

var hasRequiredSpacingFluidMedium88ab712b;

function requireSpacingFluidMedium88ab712b () {
	if (hasRequiredSpacingFluidMedium88ab712b) return spacingFluidMedium88ab712b;
	hasRequiredSpacingFluidMedium88ab712b = 1;

	const spacingFluidMedium = 'clamp(16px, 1.25vw + 12px, 36px)';

	spacingFluidMedium88ab712b.spacingFluidMedium = spacingFluidMedium;

	
	return spacingFluidMedium88ab712b;
}

var hasRequiredGridGapB5b73e4a;

function requireGridGapB5b73e4a () {
	if (hasRequiredGridGapB5b73e4a) return gridGapB5b73e4a;
	hasRequiredGridGapB5b73e4a = 1;

	const spacingFluidMedium = requireSpacingFluidMedium88ab712b();

	const gridGap = spacingFluidMedium.spacingFluidMedium;

	gridGapB5b73e4a.gridGap = gridGap;

	
	return gridGapB5b73e4a;
}

var hasRequiredGridExtendedOffsetXXLC7a41e50;

function requireGridExtendedOffsetXXLC7a41e50 () {
	if (hasRequiredGridExtendedOffsetXXLC7a41e50) return gridExtendedOffsetXXLC7a41e50;
	hasRequiredGridExtendedOffsetXXLC7a41e50 = 1;

	const gridExtendedOffsetBase = requireGridExtendedOffsetBaseFb9830f6();
	const gridGap = requireGridGapB5b73e4a();

	const columnMap = {
	    narrow: 4,
	    basic: 2,
	    extended: 1,
	};
	const gridColumnWidthS = `calc((100vw - ${gridExtendedOffsetBase._gridSafeZoneS} * 2 - ${gridGap.gridGap} * 15) / 16)`;
	const gridColumnWidthXXL = `calc((min(100vw, ${gridExtendedOffsetBase._gridWidthMax}) - ${gridExtendedOffsetBase._gridSafeZoneXXL} * 2 - ${gridGap.gridGap} * 15) / 16)`;
	const _gridPadding = `max(0px, 50vw - ${gridExtendedOffsetBase._gridWidthMax} / 2)`;
	const _getGridOffsetS = (width) => `calc(${gridExtendedOffsetBase._gridSafeZoneS} + (${gridGap.gridGap} + ${gridColumnWidthS}) * ${columnMap[width]})`;
	const _getGridOffsetXXL = (width) => `calc(${_gridPadding} + ${gridExtendedOffsetBase._gridSafeZoneXXL} + (${gridGap.gridGap} + ${gridColumnWidthXXL}) * ${columnMap[width]})`;

	const gridExtendedOffsetS = _getGridOffsetS('extended');

	const gridExtendedOffsetXXL = _getGridOffsetXXL('extended');

	gridExtendedOffsetXXLC7a41e50._getGridOffsetS = _getGridOffsetS;
	gridExtendedOffsetXXLC7a41e50._getGridOffsetXXL = _getGridOffsetXXL;
	gridExtendedOffsetXXLC7a41e50._gridPadding = _gridPadding;
	gridExtendedOffsetXXLC7a41e50.gridExtendedOffsetS = gridExtendedOffsetS;
	gridExtendedOffsetXXLC7a41e50.gridExtendedOffsetXXL = gridExtendedOffsetXXL;

	
	return gridExtendedOffsetXXLC7a41e50;
}

var hasRequiredGridBasicOffsetEafb13d6;

function requireGridBasicOffsetEafb13d6 () {
	if (hasRequiredGridBasicOffsetEafb13d6) return gridBasicOffsetEafb13d6;
	hasRequiredGridBasicOffsetEafb13d6 = 1;

	const gridExtendedOffsetBase = requireGridExtendedOffsetBaseFb9830f6();
	const gridExtendedOffsetXXL = requireGridExtendedOffsetXXLC7a41e50();

	const gridExtendedOffset = {
	    base: gridExtendedOffsetBase.gridExtendedOffsetBase,
	    s: gridExtendedOffsetXXL.gridExtendedOffsetS,
	    xxl: gridExtendedOffsetXXL.gridExtendedOffsetXXL,
	};

	const gridBasicOffsetBase = gridExtendedOffsetBase._gridSafeZoneBase;

	const gridBasicOffsetS = gridExtendedOffsetXXL._getGridOffsetS('basic');

	const gridBasicOffsetXXL = gridExtendedOffsetXXL._getGridOffsetXXL('basic');

	const gridBasicOffset = {
	    base: gridBasicOffsetBase,
	    s: gridBasicOffsetS,
	    xxl: gridBasicOffsetXXL,
	};

	gridBasicOffsetEafb13d6.gridBasicOffset = gridBasicOffset;
	gridBasicOffsetEafb13d6.gridBasicOffsetBase = gridBasicOffsetBase;
	gridBasicOffsetEafb13d6.gridExtendedOffset = gridExtendedOffset;

	
	return gridBasicOffsetEafb13d6;
}

var groupDirectionStyles27ae72d0 = {};

var hasRequiredGroupDirectionStyles27ae72d0;

function requireGroupDirectionStyles27ae72d0 () {
	if (hasRequiredGroupDirectionStyles27ae72d0) return groupDirectionStyles27ae72d0;
	hasRequiredGroupDirectionStyles27ae72d0 = 1;

	const GROUP_DIRECTIONS = ['row', 'column'];
	const groupDirectionJssStyles = {
	  column: {
	    flexFlow: 'column nowrap',
	    alignItems: 'stretch',
	  },
	  row: {
	    flexFlow: 'row wrap',
	    alignItems: 'center',
	  },
	};
	const getGroupDirectionJssStyles = (direction) => {
	  return groupDirectionJssStyles[direction];
	};

	groupDirectionStyles27ae72d0.GROUP_DIRECTIONS = GROUP_DIRECTIONS;
	groupDirectionStyles27ae72d0.getGroupDirectionJssStyles = getGroupDirectionJssStyles;

	
	return groupDirectionStyles27ae72d0;
}

var hasDocument079654e6 = {};

var hasRequiredHasDocument079654e6;

function requireHasDocument079654e6 () {
	if (hasRequiredHasDocument079654e6) return hasDocument079654e6;
	hasRequiredHasDocument079654e6 = 1;

	const hasDocument = typeof document !== 'undefined';

	hasDocument079654e6.hasDocument = hasDocument;

	
	return hasDocument079654e6;
}

var hasAttribute868c282d = {};

var hasRequiredHasAttribute868c282d;

function requireHasAttribute868c282d () {
	if (hasRequiredHasAttribute868c282d) return hasAttribute868c282d;
	hasRequiredHasAttribute868c282d = 1;

	const hasAttribute = (el, attributeName) => {
	  return el.hasAttribute(attributeName);
	};

	hasAttribute868c282d.hasAttribute = hasAttribute;

	
	return hasAttribute868c282d;
}

var hasDescriptionA19e4bdc = {};

var hasRequiredHasDescriptionA19e4bdc;

function requireHasDescriptionA19e4bdc () {
	if (hasRequiredHasDescriptionA19e4bdc) return hasDescriptionA19e4bdc;
	hasRequiredHasDescriptionA19e4bdc = 1;

	const hasNamedSlot = requireHasNamedSlot28c6bca1();
	requireValidatePropsC2afb75b();

	const hasDescription = (element, description) => {
	  return !!description || hasNamedSlot.hasNamedSlot(element, 'description');
	};

	hasDescriptionA19e4bdc.hasDescription = hasDescription;

	
	return hasDescriptionA19e4bdc;
}

var headingTag0acc4c21 = {};

var hasRequiredHeadingTag0acc4c21;

function requireHeadingTag0acc4c21 () {
	if (hasRequiredHeadingTag0acc4c21) return headingTag0acc4c21;
	hasRequiredHeadingTag0acc4c21 = 1;

	const HEADING_TAGS = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];

	headingTag0acc4c21.HEADING_TAGS = HEADING_TAGS;

	
	return headingTag0acc4c21;
}

var headingSmallStyle0707b97f = {};

var hasRequiredHeadingSmallStyle0707b97f;

function requireHeadingSmallStyle0707b97f () {
	if (hasRequiredHeadingSmallStyle0707b97f) return headingSmallStyle0707b97f;
	hasRequiredHeadingSmallStyle0707b97f = 1;

	const headingShared = requireHeadingSharedAa59e66d();
	const fontSizeHeadingSmall = requireFontSizeHeadingSmallA15141a5();

	const headingSmallStyle = {
	    font: `${headingShared._headingFontPartA}${fontSizeHeadingSmall.fontSizeHeadingSmall}${headingShared._headingFontPartB}`,
	};

	headingSmallStyle0707b97f.headingSmallStyle = headingSmallStyle;

	
	return headingSmallStyle0707b97f;
}

var headingXXLargeStyleDb047d95 = {};

var hasRequiredHeadingXXLargeStyleDb047d95;

function requireHeadingXXLargeStyleDb047d95 () {
	if (hasRequiredHeadingXXLargeStyleDb047d95) return headingXXLargeStyleDb047d95;
	hasRequiredHeadingXXLargeStyleDb047d95 = 1;

	const headingShared = requireHeadingSharedAa59e66d();

	const fontSizeHeadingXXLarge = 'clamp(1.6rem, 1.56vw + 1.29rem, 3.16rem)';

	const headingXXLargeStyle = {
	    font: `${headingShared._headingFontPartA}${fontSizeHeadingXXLarge}${headingShared._headingFontPartB}`,
	};

	headingXXLargeStyleDb047d95.fontSizeHeadingXXLarge = fontSizeHeadingXXLarge;
	headingXXLargeStyleDb047d95.headingXXLargeStyle = headingXXLargeStyle;

	
	return headingXXLargeStyleDb047d95;
}

var helperE5c4e0db = {};

var hasRequiredHelperE5c4e0db;

function requireHelperE5c4e0db () {
	if (hasRequiredHelperE5c4e0db) return helperE5c4e0db;
	hasRequiredHelperE5c4e0db = 1;

	const validateProps = requireValidatePropsC2afb75b();

	const getDeprecatedPropOrSlotWarningMessage = (host, propOrSlot) => `${propOrSlot} is deprecated for component ${validateProps.getTagNameWithoutPrefix(host)} and will be removed with next major release.`;

	helperE5c4e0db.getDeprecatedPropOrSlotWarningMessage = getDeprecatedPropOrSlotWarningMessage;

	
	return helperE5c4e0db;
}

var index_cjs = {};

var hasRequiredIndex_cjs;

function requireIndex_cjs () {
	if (hasRequiredIndex_cjs) return index_cjs;
	hasRequiredIndex_cjs = 1;


	
	return index_cjs;
}

var inlineNotificationUtilsAc1154ad = {};

var spacingStaticMedium94812711 = {};

var hasRequiredSpacingStaticMedium94812711;

function requireSpacingStaticMedium94812711 () {
	if (hasRequiredSpacingStaticMedium94812711) return spacingStaticMedium94812711;
	hasRequiredSpacingStaticMedium94812711 = 1;

	const spacingStaticMedium = '16px';

	spacingStaticMedium94812711.spacingStaticMedium = spacingStaticMedium;

	
	return spacingStaticMedium94812711;
}

var hasRequiredInlineNotificationUtilsAc1154ad;

function requireInlineNotificationUtilsAc1154ad () {
	if (hasRequiredInlineNotificationUtilsAc1154ad) return inlineNotificationUtilsAc1154ad;
	hasRequiredInlineNotificationUtilsAc1154ad = 1;

	const validateProps = requireValidatePropsC2afb75b();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const getMediaQueryMax = requireGetMediaQueryMax2587ee0a();
	const bannerUtils = requireBannerUtils2cc83734();

	const mediaQueryMinS = validateProps.getMediaQueryMin('s');
	const mediaQueryMaxS = getMediaQueryMax.getMediaQueryMax('s');
	const getBackgroundColor = (state, theme) => {
	  const { infoSoftColor, successSoftColor, errorSoftColor, warningSoftColor } = validateProps.getThemedColors(theme);
	  const colorMap = {
	    neutral: infoSoftColor,
	    info: infoSoftColor,
	    warning: warningSoftColor,
	    success: successSoftColor,
	    error: errorSoftColor,
	  };
	  return colorMap[state];
	};
	const getNotificationRootJssStyle = (state, hasAction, hasClose, theme) => {
	  return {
	    display: 'grid',
	    // 2 columns for content and optional close button
	    gridTemplateColumns: `minmax(auto, 1fr)${hasClose ? ' auto' : ''}`,
	    gap: spacingStaticMedium.spacingStaticMedium,
	    placeItems: 'start',
	    padding: spacingStaticMedium.spacingStaticMedium,
	    background: getBackgroundColor(state, theme),
	    ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	      background: getBackgroundColor(state, 'dark'),
	    }),
	    borderRadius: borderRadiusSmall.borderRadiusSmall,
	    ...(validateProps.isHighContrastMode && {
	      outline: '1px solid transparent',
	    }),
	    [mediaQueryMinS]: {
	      // 4 columns are for icon, content, optional action button and optional close button
	      gridTemplateColumns: `auto minmax(auto, 1fr)${hasAction ? ' auto' : ''}${hasClose ? ' auto' : ''}`,
	    },
	  };
	};
	const getNotificationIconJssStyle = () => ({
	  [mediaQueryMaxS]: {
	    display: 'none',
	  },
	});
	const getNotificationContentJssStyle = () => ({
	  display: 'grid',
	  gap: spacingStaticXSmall.spacingStaticXSmall,
	  maxWidth: '50rem',
	  [mediaQueryMinS]: {
	    marginLeft: `-${spacingStaticSmall.spacingStaticSmall}`,
	  },
	});

	const INLINE_NOTIFICATION_STATES = ['success', ...bannerUtils.BANNER_STATES];
	const getInlineNotificationIconName = (state) => {
	  const stateToIconMap = {
	    neutral: 'information-filled',
	    info: 'information-filled',
	    warning: 'warning-filled',
	    success: 'success-filled',
	    error: 'error-filled',
	  };
	  return stateToIconMap[state];
	};
	const getContentAriaAttributes = (state, labelId, descriptionId) => {
	  const isAlert = state === 'warning' || state === 'error';
	  return {
	    role: isAlert ? 'alert' : 'status',
	    'aria-live': isAlert ? 'assertive' : 'polite',
	    'aria-labelledby': labelId,
	    'aria-describedby': descriptionId,
	  };
	};

	inlineNotificationUtilsAc1154ad.INLINE_NOTIFICATION_STATES = INLINE_NOTIFICATION_STATES;
	inlineNotificationUtilsAc1154ad.getContentAriaAttributes = getContentAriaAttributes;
	inlineNotificationUtilsAc1154ad.getInlineNotificationIconName = getInlineNotificationIconName;
	inlineNotificationUtilsAc1154ad.getNotificationContentJssStyle = getNotificationContentJssStyle;
	inlineNotificationUtilsAc1154ad.getNotificationIconJssStyle = getNotificationIconJssStyle;
	inlineNotificationUtilsAc1154ad.getNotificationRootJssStyle = getNotificationRootJssStyle;

	
	return inlineNotificationUtilsAc1154ad;
}

var isClickOutside07c79402 = {};

var hasRequiredIsClickOutside07c79402;

function requireIsClickOutside07c79402 () {
	if (hasRequiredIsClickOutside07c79402) return isClickOutside07c79402;
	hasRequiredIsClickOutside07c79402 = 1;

	/**
	 * Checks if a click event occurred outside the specified element.
	 *
	 * @param {Event} e - The click event object.
	 * @param {HTMLElement} host - The host element to compare against.
	 * @returns {boolean} - Returns true if the click event occurred outside the host element, otherwise false.
	 */
	const isClickOutside = (e, host) => !e.composedPath().includes(host);

	isClickOutside07c79402.isClickOutside = isClickOutside;

	
	return isClickOutside07c79402;
}

var isSsrHydration9278b79b = {};

var hasRequiredIsSsrHydration9278b79b;

function requireIsSsrHydration9278b79b () {
	if (hasRequiredIsSsrHydration9278b79b) return isSsrHydration9278b79b;
	hasRequiredIsSsrHydration9278b79b = 1;

	const isSsrHydration = (host) => host.classList.contains('ssr');

	isSsrHydration9278b79b.isSsrHydration = isSsrHydration;

	
	return isSsrHydration9278b79b;
}

var isParentFieldsetRequired6f3a68ad = {};

var hasRequiredIsParentFieldsetRequired6f3a68ad;

function requireIsParentFieldsetRequired6f3a68ad () {
	if (hasRequiredIsParentFieldsetRequired6f3a68ad) return isParentFieldsetRequired6f3a68ad;
	hasRequiredIsParentFieldsetRequired6f3a68ad = 1;

	const isParentOfKind = requireIsParentOfKindA9c351f2();
	requireValidatePropsC2afb75b();

	const isRequired = (el) => !!el?.required;

	const isParentFieldsetRequired = (element) => {
	  return ((isParentOfKind.isParentOfKind(element, 'p-fieldset') || isParentOfKind.isParentOfKind(element, 'p-fieldset-wrapper')) &&
	    isRequired(element.parentElement));
	};

	isParentFieldsetRequired6f3a68ad.isParentFieldsetRequired = isParentFieldsetRequired;
	isParentFieldsetRequired6f3a68ad.isRequired = isRequired;

	
	return isParentFieldsetRequired6f3a68ad;
}

var isRequiredAndParentNotRequired0b84c8cc = {};

var hasRequiredIsRequiredAndParentNotRequired0b84c8cc;

function requireIsRequiredAndParentNotRequired0b84c8cc () {
	if (hasRequiredIsRequiredAndParentNotRequired0b84c8cc) return isRequiredAndParentNotRequired0b84c8cc;
	hasRequiredIsRequiredAndParentNotRequired0b84c8cc = 1;

	const isParentFieldsetRequired = requireIsParentFieldsetRequired6f3a68ad();

	const isRequiredAndParentNotRequired = (element, child) => {
	  return isParentFieldsetRequired.isRequired(child) && !isParentFieldsetRequired.isParentFieldsetRequired(element);
	};

	isRequiredAndParentNotRequired0b84c8cc.isRequiredAndParentNotRequired = isRequiredAndParentNotRequired;

	
	return isRequiredAndParentNotRequired0b84c8cc;
}

var isWithinFormA677dade = {};

var hasRequiredIsWithinFormA677dade;

function requireIsWithinFormA677dade () {
	if (hasRequiredIsWithinFormA677dade) return isWithinFormA677dade;
	hasRequiredIsWithinFormA677dade = 1;

	const getClosestHTMLElement = requireGetClosestHTMLElement0135bfd9();
	requireValidatePropsC2afb75b();

	const isWithinForm = (host) => !!getClosestHTMLElement.getClosestHTMLElement(host, 'form');

	isWithinFormA677dade.isWithinForm = isWithinForm;

	
	return isWithinFormA677dade;
}

var linkAriaAttribute5de11e89 = {};

var hasRequiredLinkAriaAttribute5de11e89;

function requireLinkAriaAttribute5de11e89 () {
	if (hasRequiredLinkAriaAttribute5de11e89) return linkAriaAttribute5de11e89;
	hasRequiredLinkAriaAttribute5de11e89 = 1;

	const LINK_ARIA_ATTRIBUTES = ['aria-label', 'aria-current'];

	linkAriaAttribute5de11e89.LINK_ARIA_ATTRIBUTES = LINK_ARIA_ATTRIBUTES;

	
	return linkAriaAttribute5de11e89;
}

var linkButtonPureStyles1e533bc9 = {};

var hasRequiredLinkButtonPureStyles1e533bc9;

function requireLinkButtonPureStyles1e533bc9 () {
	if (hasRequiredLinkButtonPureStyles1e533bc9) return linkButtonPureStyles1e533bc9;
	hasRequiredLinkButtonPureStyles1e533bc9 = 1;

	const validateProps = requireValidatePropsC2afb75b();
	const buttonLinkPureUtils = requireButtonLinkPureUtils468dbe67();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const hoverMediaQuery = requireHoverMediaQueryF2ccfc24();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const fontSizeTextXXSmall = requireFontSizeTextXXSmallA02f9c40();
	const fontSizeTextXSmall = requireFontSizeTextXSmallE59d35d7();
	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();
	const fontSizeTextMedium = requireFontSizeTextMedium88887ad8();
	const fontSizeTextLarge = requireFontSizeTextLarge05a4bc90();
	const fontSizeTextXLarge = requireFontSizeTextXLarge0ecf9ef3();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const fontLineHeight = requireFontLineHeight78b03658();

	const fontSizeTextMap = {
	  'xx-small': fontSizeTextXXSmall.fontSizeTextXXSmall,
	  'x-small': fontSizeTextXSmall.fontSizeTextXSmall,
	  small: fontSizeTextSmall.fontSizeTextSmall,
	  medium: fontSizeTextMedium.fontSizeTextMedium,
	  large: fontSizeTextLarge.fontSizeTextLarge,
	  'x-large': fontSizeTextXLarge.fontSizeTextXLarge,
	  inherit: 'inherit',
	};
	const getFontSizeText = (size) => {
	  return fontSizeTextMap[size];
	};

	// Needed for slotted anchor and hidden label, which then enlarges the hidden label to equal host size and indents the text to be visually hidden.
	const getVisibilityJssStyle = (hideLabel) => {
	  return hideLabel
	    ? {
	      position: 'absolute',
	      ...validateProps.getInsetJssStyle(),
	      whiteSpace: 'nowrap',
	      textIndent: '-999999px',
	    }
	    : {
	      position: 'relative',
	      ...validateProps.getInsetJssStyle('auto'),
	      whiteSpace: 'inherit',
	      textIndent: 0,
	      zIndex: 1, // fix Firefox bug on :hover (#2583)
	    };
	};
	const offsetVertical = '-2px';
	const offsetHorizontal = '-4px';
	const getLinkButtonPureStyles = (icon, iconSource, active, isDisabledOrLoading, stretch, size, hideLabel, alignLabel, hasSlottedAnchor, theme) => {
	  const { primaryColor, disabledColor, hoverColor, focusColor } = validateProps.getThemedColors(theme);
	  const { primaryColor: primaryColorDark, disabledColor: disabledColorDark, hoverColor: hoverColorDark, focusColor: focusColorDark, } = validateProps.getThemedColors('dark');
	  const hasIcon = buttonLinkPureUtils.hasVisibleIcon(icon, iconSource);
	  return {
	    '@global': {
	      ':host': {
	        ...validateProps.addImportantToEachRule({
	          transform: 'translate3d(0,0,0)',
	          outline: 0,
	          ...colorSchemeStyles.colorSchemeStyles,
	          ...colorSchemeStyles.hostHiddenStyles,
	        }),
	        ...validateProps.buildResponsiveStyles(stretch, (responsiveStretch) => ({
	          display: responsiveStretch ? 'block' : 'inline-block',
	          width: responsiveStretch ? '100%' : 'auto',
	          ...(!responsiveStretch && { verticalAlign: 'top' }),
	        })),
	      },
	    },
	    root: {
	      display: 'flex',
	      gap: spacingStaticXSmall.spacingStaticXSmall,
	      width: '100%',
	      margin: 0,
	      padding: 0,
	      color: isDisabledOrLoading ? disabledColor : primaryColor,
	      ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	        color: isDisabledOrLoading ? disabledColorDark : primaryColorDark,
	      }),
	      outline: 0,
	      ...textSmallStyle.textSmallStyle,
	      ...validateProps.mergeDeep(validateProps.buildResponsiveStyles(stretch, (stretchValue) => ({
	        justifyContent: stretchValue ? 'space-between' : 'flex-start',
	        alignItems: stretchValue ? 'center' : 'flex-start',
	      })), validateProps.buildResponsiveStyles(size, (sizeValue) => ({
	        fontSize: getFontSizeText(sizeValue),
	      }))),
	      '&::before': {
	        content: '""',
	        position: 'absolute',
	        top: offsetVertical,
	        bottom: offsetVertical,
	        ...validateProps.buildResponsiveStyles(hideLabel, (hideLabelValue) => ({
	          right: hideLabelValue ? offsetVertical : offsetHorizontal,
	          left: hideLabelValue ? offsetVertical : offsetHorizontal,
	        })),
	        borderRadius: borderRadiusSmall.borderRadiusSmall,
	        transition: validateProps.getTransition('background-color'),
	        ...(active && {
	          ...validateProps.frostedGlassStyle,
	          backgroundColor: hoverColor,
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	            backgroundColor: hoverColorDark,
	          }),
	        }),
	      },
	      ...(!isDisabledOrLoading &&
	        hoverMediaQuery.hoverMediaQuery({
	          '&:hover::before': {
	            ...validateProps.frostedGlassStyle,
	            backgroundColor: hoverColor,
	            ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	              backgroundColor: hoverColorDark,
	            }),
	          },
	        })),
	      ...(!hasSlottedAnchor && {
	        '&:focus::before': {
	          border: `${validateProps.borderWidthBase} solid ${focusColor}`,
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	            borderColor: focusColorDark,
	          }),
	        },
	        '&:not(:focus-visible)::before': {
	          border: 0,
	        },
	      }),
	    },
	    label: {
	      position: 'relative', // needed for hover state when icon="none" is set
	    },
	    ...(hasIcon && {
	      icon: {
	        position: 'relative',
	        flexShrink: '0',
	        width: fontLineHeight.fontLineHeight,
	        height: fontLineHeight.fontLineHeight,
	        // workaround for Safari to optimize vertical alignment of icons
	        // TODO: check if this is still needed after optimized icons are included
	        '@supports (width: round(down, 1px, 1px))': {
	          width: `round(down, ${fontLineHeight.fontLineHeight}, 1px)`,
	          height: `round(down, ${fontLineHeight.fontLineHeight}, 1px)`,
	        },
	      },
	      label: validateProps.mergeDeep(validateProps.buildResponsiveStyles(hideLabel, getVisibilityJssStyle), validateProps.buildResponsiveStyles(alignLabel, (alignLabelValue) => ({
	        order: alignLabelValue === 'left' ? -1 : 0,
	      }))),
	    }),
	  };
	};

	linkButtonPureStyles1e533bc9.getLinkButtonPureStyles = getLinkButtonPureStyles;
	linkButtonPureStyles1e533bc9.offsetHorizontal = offsetHorizontal;
	linkButtonPureStyles1e533bc9.offsetVertical = offsetVertical;

	
	return linkButtonPureStyles1e533bc9;
}

var linkButtonStylesE68cc0c9 = {};

var hasRequiredLinkButtonStylesE68cc0c9;

function requireLinkButtonStylesE68cc0c9 () {
	if (hasRequiredLinkButtonStylesE68cc0c9) return linkButtonStylesE68cc0c9;
	hasRequiredLinkButtonStylesE68cc0c9 = 1;

	const validateProps = requireValidatePropsC2afb75b();
	const buttonLinkPureUtils = requireButtonLinkPureUtils468dbe67();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const hoverMediaQuery = requireHoverMediaQueryF2ccfc24();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const borderRadiusMedium = requireBorderRadiusMedium758b9411();
	const fontLineHeight = requireFontLineHeight78b03658();

	const { primaryColor: darkThemePrimaryColor } = validateProps.getThemedColors('dark');
	const { primaryColor: lightThemePrimaryColor } = validateProps.getThemedColors('light');
	const getVariantColors = (variant, theme) => {
	  const { primaryColor, contrastHighColor, contrastMediumColor, hoverColor } = validateProps.getThemedColors(theme);
	  const { canvasColor } = validateProps.getHighContrastColors();
	  const colors = {
	    primary: {
	      textColor: theme === 'dark' ? lightThemePrimaryColor : darkThemePrimaryColor,
	      borderColor: primaryColor,
	      borderColorHover: contrastHighColor,
	      backgroundColor: primaryColor,
	      backgroundColorHover: contrastHighColor,
	    },
	    secondary: {
	      textColor: primaryColor,
	      borderColor: primaryColor,
	      borderColorHover: contrastMediumColor,
	      backgroundColor: validateProps.isHighContrastMode ? canvasColor : 'transparent',
	      backgroundColorHover: hoverColor,
	    },
	  };
	  return colors[variant === 'tertiary' ? 'secondary' : variant];
	};
	const getLinkButtonStyles = (icon, iconSource, variant, hideLabel, isDisabledOrLoading, hasSlottedAnchor, theme) => {
	  const isPrimary = variant === 'primary';
	  const { textColor, borderColor, borderColorHover, backgroundColor, backgroundColorHover } = getVariantColors(variant, theme);
	  const { textColor: textColorDark, borderColor: borderColorDark, borderColorHover: borderColorHoverDark, backgroundColor: backgroundColorDark, backgroundColorHover: backgroundColorHoverDark, } = getVariantColors(variant, 'dark');
	  const { focusColor } = validateProps.getThemedColors(theme);
	  const hasIcon = buttonLinkPureUtils.hasVisibleIcon(icon, iconSource) || hideLabel;
	  return {
	    '@global': {
	      ':host': {
	        display: 'inline-block',
	        ...validateProps.addImportantToEachRule({
	          verticalAlign: 'top',
	          outline: 0,
	          ...colorSchemeStyles.colorSchemeStyles,
	          ...colorSchemeStyles.hostHiddenStyles,
	        }),
	      },
	    },
	    root: {
	      display: 'flex',
	      alignItems: 'flex-start',
	      justifyContent: 'center',
	      width: '100%',
	      minWidth: '54px',
	      minHeight: '54px',
	      boxSizing: 'border-box',
	      outline: 0,
	      textAlign: 'left',
	      appearance: 'none',
	      textDecoration: 'none',
	      border: `2px solid ${borderColor}`,
	      borderRadius: borderRadiusSmall.borderRadiusSmall,
	      transform: 'translate3d(0,0,0)',
	      backgroundColor,
	      color: textColor,
	      ...textSmallStyle.textSmallStyle,
	      transition: ['background-color', 'border-color', 'color'].map(validateProps.getTransition).join(),
	      ...validateProps.buildResponsiveStyles(hideLabel, (hideLabelValue) => ({
	        padding: hideLabelValue ? '13px' : hasIcon ? '13px 26px 13px 18px' : '13px 26px',
	        gap: hideLabelValue ? 0 : spacingStaticSmall.spacingStaticSmall,
	      })),
	      ...(!hasSlottedAnchor && {
	        '&:focus::before': {
	          content: '""',
	          position: 'fixed',
	          border: `${validateProps.borderWidthBase} solid ${focusColor}`,
	          borderRadius: borderRadiusMedium.borderRadiusMedium,
	          ...validateProps.getInsetJssStyle(-6),
	        },
	        '&:not(:focus-visible)::before': {
	          border: 0,
	        },
	      }),
	      ...(!isDisabledOrLoading &&
	        hoverMediaQuery.hoverMediaQuery({
	          '&:hover': {
	            backgroundColor: backgroundColorHover,
	            borderColor: validateProps.isHighContrastMode ? focusColor : borderColorHover,
	            ...(!isPrimary && validateProps.frostedGlassStyle),
	            ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	              backgroundColor: backgroundColorHoverDark,
	              borderColor: borderColorHoverDark,
	            }),
	          },
	        })),
	      ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	        borderColor: borderColorDark,
	        backgroundColor: backgroundColorDark,
	        color: textColorDark,
	      }),
	    },
	    label: validateProps.buildResponsiveStyles(hideLabel, validateProps.getHiddenTextJssStyle),
	    ...(hasIcon && {
	      icon: {
	        width: fontLineHeight.fontLineHeight,
	        height: fontLineHeight.fontLineHeight,
	      },
	    }),
	  };
	};

	linkButtonStylesE68cc0c9.getLinkButtonStyles = getLinkButtonStyles;

	
	return linkButtonStylesE68cc0c9;
}

var linkButtonVariant3104b925 = {};

var hasRequiredLinkButtonVariant3104b925;

function requireLinkButtonVariant3104b925 () {
	if (hasRequiredLinkButtonVariant3104b925) return linkButtonVariant3104b925;
	hasRequiredLinkButtonVariant3104b925 = 1;

	const LINK_BUTTON_VARIANTS = ['primary', 'secondary', 'tertiary'];

	linkButtonVariant3104b925.LINK_BUTTON_VARIANTS = LINK_BUTTON_VARIANTS;

	
	return linkButtonVariant3104b925;
}

var linkStyles60ad2b7b = {};

var hasRequiredLinkStyles60ad2b7b;

function requireLinkStyles60ad2b7b () {
	if (hasRequiredLinkStyles60ad2b7b) return linkStyles60ad2b7b;
	hasRequiredLinkStyles60ad2b7b = 1;

	const validateProps = requireValidatePropsC2afb75b();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const linkButtonStyles = requireLinkButtonStylesE68cc0c9();
	const borderRadiusMedium = requireBorderRadiusMedium758b9411();

	const getComponentCss = (icon, iconSource, variant, hideLabel, hasSlottedAnchor, theme) => {
	  const { focusColor } = validateProps.getThemedColors(theme);
	  const { focusColor: focusColorDark } = validateProps.getThemedColors('dark');
	  const { linkColor } = validateProps.getHighContrastColors();
	  const isPrimary = variant === 'primary';
	  return validateProps.getCss(validateProps.mergeDeep(linkButtonStyles.getLinkButtonStyles(icon, iconSource, variant, hideLabel, false, hasSlottedAnchor, theme), {
	    icon: {
	      ...(isPrimary &&
	        !validateProps.isHighContrastMode && {
	        filter: 'invert(1)',
	      }),
	    },
	  }, hasSlottedAnchor && {
	    ...(validateProps.isHighContrastMode && {
	      root: {
	        borderColor: linkColor,
	      },
	    }),
	    '@global': validateProps.addImportantToEachRule({
	      '::slotted': {
	        '&(a)': {
	          ...validateProps.getResetInitialStylesForSlottedAnchor,
	          textDecoration: 'none',
	          font: 'inherit',
	          color: 'inherit',
	        },
	        // The clickable area for Safari < ~15 (<= release date: 2021-10-28) is reduced to the slotted anchor itself,
	        // since Safari prior to this major release does not support pseudo-elements in the slotted context
	        // (https://bugs.webkit.org/show_bug.cgi?id=178237)
	        '&(a)::before': {
	          content: '""',
	          position: 'fixed',
	          borderRadius: borderRadiusMedium.borderRadiusMedium,
	          ...validateProps.getInsetJssStyle(-6),
	        },
	        // TODO: combine link-social-styles with link-button-styles and tabs-bar-styles
	        '&(a::-moz-focus-inner)': {
	          border: 0,
	        },
	        '&(a:focus)::before': {
	          border: `${validateProps.borderWidthBase} solid ${focusColor}`,
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	            borderColor: focusColorDark,
	          }),
	        },
	        '&(a:focus:not(:focus-visible))::before': {
	          border: 0,
	        },
	      },
	    }),
	  }));
	};

	linkStyles60ad2b7b.getComponentCss = getComponentCss;

	
	return linkStyles60ad2b7b;
}

var linkTileUtils98dcc629 = {};

var tileBaseStylesBc82297d = {};

var textIconStylesDeb3ffbc = {};

var hasRequiredTextIconStylesDeb3ffbc;

function requireTextIconStylesDeb3ffbc () {
	if (hasRequiredTextIconStylesDeb3ffbc) return textIconStylesDeb3ffbc;
	hasRequiredTextIconStylesDeb3ffbc = 1;

	const validateProps = requireValidatePropsC2afb75b();

	const getThemedTypographyColor = (theme, textColor // eslint-disable-line @typescript-eslint/no-duplicate-type-constituents
	) => {
	  // TODO: don't destructure for better minification
	  const { primaryColor, contrastHighColor, contrastMediumColor, contrastLowColor, successColor, errorColor, warningColor, infoColor, } = validateProps.getThemedColors(theme);
	  const colorMap = {
	    primary: primaryColor,
	    default: primaryColor,
	    'contrast-low': contrastLowColor,
	    'contrast-medium': contrastMediumColor,
	    'contrast-high': contrastHighColor,
	    'notification-success': successColor,
	    'notification-warning': warningColor,
	    'notification-error': errorColor,
	    'notification-info': infoColor,
	    inherit: 'currentColor',
	  };
	  return colorMap[textColor];
	};

	textIconStylesDeb3ffbc.getThemedTypographyColor = getThemedTypographyColor;

	
	return textIconStylesDeb3ffbc;
}

var hasRequiredTileBaseStylesBc82297d;

function requireTileBaseStylesBc82297d () {
	if (hasRequiredTileBaseStylesBc82297d) return tileBaseStylesBc82297d;
	hasRequiredTileBaseStylesBc82297d = 1;

	const textShared = requireTextShared9135e2ef();
	const fontSizeTextLarge = requireFontSizeTextLarge05a4bc90();
	const validateProps = requireValidatePropsC2afb75b();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const hoverMediaQuery = requireHoverMediaQueryF2ccfc24();
	const textIconStyles = requireTextIconStylesDeb3ffbc();
	const borderRadiusLarge = requireBorderRadiusLargeA0aa3a01();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();

	const _gradient = 'rgba(31,31,31,0.9) 0%,' +
	    'rgba(31,31,31,0.9) 20%,' +
	    'rgba(31,31,31,0.852589) 26.67%,' +
	    'rgba(32,32,32,0.768225) 33.33%,' +
	    'rgba(33,33,33,0.668116) 40%,' +
	    'rgba(34,34,34,0.557309) 46.67%,' +
	    'rgba(35,35,35,0.442691) 53.33%,' +
	    'rgba(36,36,36,0.331884) 60%,' +
	    'rgba(37,37,37,0.231775) 66.67%,' +
	    'rgba(38,38,38,0.147411) 73.33%,' +
	    'rgba(39,39,39,0.0816599) 80%,' +
	    'rgba(39,39,39,0.03551) 86.67%,' +
	    'rgba(39,39,39,0.0086472) 93.33%,' +
	    'rgba(39,39,39,0)';

	const gradientToTopStyle = {
	    background: `linear-gradient(to top, ${_gradient} 100%);`,
	};

	const textLargeStyle = {
	    font: `${textShared._textFontPartA}${fontSizeTextLarge.fontSizeTextLarge}${textShared._textFontPartB}`,
	    ...textShared.fontHyphenationStyle,
	};

	const TILE_ASPECT_RATIOS = ['1:1', '4:3', '3:4', '16:9', '9:16'];
	const TILE_SIZES = ['default', 'inherit'];
	const TILE_WEIGHTS = ['regular', 'semi-bold'];
	const TILE_ALIGNS = ['top', 'bottom'];

	const aspectRatioPaddingMap = {
	  '1:1': '100%',
	  '4:3': '75%',
	  '3:4': '133.33%',
	  '16:9': '56.25%',
	  '9:16': '177.75%',
	};
	const getTileBaseStyles = (aspectRatio, isDisabled) => {
	  return {
	    '@global': {
	      ':host': {
	        display: 'block',
	        hyphens: 'auto',
	        ...validateProps.addImportantToEachRule({
	          ...colorSchemeStyles.colorSchemeStyles,
	          ...colorSchemeStyles.hostHiddenStyles,
	        }),
	      },
	      ...validateProps.addImportantToEachRule({
	        '::slotted': {
	          '&(picture)': {
	            position: 'absolute',
	            ...validateProps.getInsetJssStyle(),
	          },
	          '&(img)': {
	            height: '100%',
	            width: '100%',
	            objectFit: 'cover',
	          },
	        },
	      }),
	    },
	    root: {
	      position: 'relative',
	      overflow: 'hidden',
	      transform: 'translate3d(0,0,0)',
	      borderRadius: borderRadiusLarge.borderRadiusLarge,
	      color: textIconStyles.getThemedTypographyColor('dark', 'primary'),
	      ...validateProps.buildResponsiveStyles(aspectRatio, (ratio) => ({
	        paddingTop: aspectRatioPaddingMap[ratio],
	      })),
	      ...(!isDisabled &&
	        hoverMediaQuery.hoverMediaQuery({
	          '&:hover .image-container': {
	            transform: 'scale3d(1.05,1.05,1.05)',
	          },
	        })),
	    },
	    'image-container': {
	      position: 'absolute',
	      transition: validateProps.getTransition('transform'),
	      ...validateProps.getInsetJssStyle(),
	    },
	    content: {
	      position: 'absolute',
	      left: 0,
	      right: 0,
	      display: 'flex',
	      justifyItems: 'start',
	      gap: spacingStaticMedium.spacingStaticMedium,
	      borderRadius: borderRadiusLarge.borderRadiusLarge,
	      '@media (forced-colors: active)': {
	        background: 'rgba(0,0,0,0.7)',
	      },
	    },
	  };
	};

	tileBaseStylesBc82297d.TILE_ALIGNS = TILE_ALIGNS;
	tileBaseStylesBc82297d.TILE_ASPECT_RATIOS = TILE_ASPECT_RATIOS;
	tileBaseStylesBc82297d.TILE_SIZES = TILE_SIZES;
	tileBaseStylesBc82297d.TILE_WEIGHTS = TILE_WEIGHTS;
	tileBaseStylesBc82297d._gradient = _gradient;
	tileBaseStylesBc82297d.getTileBaseStyles = getTileBaseStyles;
	tileBaseStylesBc82297d.gradientToTopStyle = gradientToTopStyle;
	tileBaseStylesBc82297d.textLargeStyle = textLargeStyle;

	
	return tileBaseStylesBc82297d;
}

var spacingFluidLarge6087a0f7 = {};

var hasRequiredSpacingFluidLarge6087a0f7;

function requireSpacingFluidLarge6087a0f7 () {
	if (hasRequiredSpacingFluidLarge6087a0f7) return spacingFluidLarge6087a0f7;
	hasRequiredSpacingFluidLarge6087a0f7 = 1;

	const spacingFluidLarge = 'clamp(32px, 2.75vw + 23px, 76px)';

	spacingFluidLarge6087a0f7.spacingFluidLarge = spacingFluidLarge;

	
	return spacingFluidLarge6087a0f7;
}

var themeBfc10573 = {};

var hasRequiredThemeBfc10573;

function requireThemeBfc10573 () {
	if (hasRequiredThemeBfc10573) return themeBfc10573;
	hasRequiredThemeBfc10573 = 1;

	const THEMES = ['light', 'dark', 'auto'];

	themeBfc10573.THEMES = THEMES;

	
	return themeBfc10573;
}

var hasRequiredLinkTileUtils98dcc629;

function requireLinkTileUtils98dcc629 () {
	if (hasRequiredLinkTileUtils98dcc629) return linkTileUtils98dcc629;
	hasRequiredLinkTileUtils98dcc629 = 1;

	const validateProps = requireValidatePropsC2afb75b();
	const fontWeightStyles = requireFontWeightStyles4b24ddd8();
	const tileBaseStyles = requireTileBaseStylesBc82297d();
	const spacingFluidMedium = requireSpacingFluidMedium88ab712b();
	const spacingFluidLarge = requireSpacingFluidLarge6087a0f7();
	const fontSizeTextMedium = requireFontSizeTextMedium88887ad8();
	const theme = requireThemeBfc10573();

	const gradientToBottomStyle = {
	    background: `linear-gradient(to bottom, ${tileBaseStyles._gradient} 100%);`,
	};

	// does not take care of breakpoint customizable
	const throwIfAlignTopAndNotCompact = (host, align, compact) => {
	  if (align === 'top' && (!compact || (typeof compact === 'string' && compact === 'false'))) {
	    validateProps.throwException(`usage of ${validateProps.getTagNameWithoutPrefix(host)} is not valid. align='top' is only possible with compact='true'.`);
	  }
	};

	const sizeMap = {
	  inherit: { fontSize: 'inherit' },
	  default: { fontSize: fontSizeTextMedium.fontSizeTextMedium },
	};
	const getButtonLinkTileStyles = (aspectRatio, size, weight, // to get deprecated semibold typed
	background, align, compact, hasGradient, isDisabled) => {
	  const isTopAligned = align === 'top';
	  return validateProps.mergeDeep(tileBaseStyles.getTileBaseStyles(aspectRatio, isDisabled), {
	    '@global': {
	      p: {
	        maxWidth: validateProps.pxToRemWithUnit(550),
	        margin: 0,
	        ...tileBaseStyles.textLargeStyle,
	        hyphens: 'inherit',
	        ...validateProps.mergeDeep(validateProps.buildResponsiveStyles(size, (s) => sizeMap[s]), validateProps.buildResponsiveStyles(weight, (w) => ({
	          fontWeight: fontWeightStyles.getFontWeight(w === 'semibold' ? 'semi-bold' : w), // mapping of the deprecated weight semibold
	        }))),
	        ...validateProps.buildResponsiveStyles(background, (b) => ({
	          color: validateProps.getThemedColors(b).primaryColor,
	        })),
	      },
	    },
	    content: {
	      display: 'grid',
	      ...(isTopAligned ? { top: 0 } : { bottom: 0 }),
	      padding: isTopAligned
	        ? `${spacingFluidMedium.spacingFluidMedium} ${spacingFluidMedium.spacingFluidMedium} ${spacingFluidLarge.spacingFluidLarge}`
	        : `${spacingFluidLarge.spacingFluidLarge} ${spacingFluidMedium.spacingFluidMedium} ${spacingFluidMedium.spacingFluidMedium}`,
	      ...validateProps.mergeDeep(hasGradient &&
	        validateProps.isThemeDark(background) &&
	        validateProps.buildResponsiveStyles(compact, (isCompact) => isCompact && isTopAligned ? gradientToBottomStyle : tileBaseStyles.gradientToTopStyle), validateProps.buildResponsiveStyles(compact, (isCompact) => isCompact // TODO: use flex
	        ? {
	          alignItems: 'center',
	          gridTemplateColumns: 'auto 24px',
	          gridTemplateRows: 'auto',
	          ...(isTopAligned ? { top: 0 } : { bottom: 0 }),
	        }
	        : {
	          gridTemplateRows: 'auto auto',
	          gridTemplateColumns: 'auto',
	        })),
	    },
	    'link-or-button-pure': validateProps.buildResponsiveStyles(compact, (isCompact) => ({
	      display: isCompact ? 'inline-block' : 'none',
	    })),
	    'link-or-button': {
	      minHeight: '54px',
	      ...validateProps.buildResponsiveStyles(compact, (isCompact) => ({
	        display: isCompact ? 'none' : 'inline-block',
	      })),
	    },
	  });
	};

	const LINK_TILE_WEIGHTS = [...tileBaseStyles.TILE_WEIGHTS, 'semibold'];
	const sharedTilePropTypes = {
	  size: validateProps.AllowedTypes.breakpoint(tileBaseStyles.TILE_SIZES),
	  background: validateProps.AllowedTypes.oneOf(theme.THEMES),
	  aspectRatio: validateProps.AllowedTypes.breakpoint(tileBaseStyles.TILE_ASPECT_RATIOS),
	  label: validateProps.AllowedTypes.string,
	  description: validateProps.AllowedTypes.string,
	  align: validateProps.AllowedTypes.oneOf(tileBaseStyles.TILE_ALIGNS),
	  gradient: validateProps.AllowedTypes.boolean,
	  compact: validateProps.AllowedTypes.breakpoint('boolean'),
	};

	linkTileUtils98dcc629.LINK_TILE_WEIGHTS = LINK_TILE_WEIGHTS;
	linkTileUtils98dcc629.getButtonLinkTileStyles = getButtonLinkTileStyles;
	linkTileUtils98dcc629.sharedTilePropTypes = sharedTilePropTypes;
	linkTileUtils98dcc629.throwIfAlignTopAndNotCompact = throwIfAlignTopAndNotCompact;

	
	return linkTileUtils98dcc629;
}

var modalUtils9e25e7f9 = {};

var hasRequiredModalUtils9e25e7f9;

function requireModalUtils9e25e7f9 () {
	if (hasRequiredModalUtils9e25e7f9) return modalUtils9e25e7f9;
	hasRequiredModalUtils9e25e7f9 = 1;

	const validateProps = requireValidatePropsC2afb75b();

	const unpackChildren = (el) => {
	  return Array.from(el.children, (child) => child.children ? [child].concat(unpackChildren(child)) : child)
	    .flat()
	    .map((child) => (child.shadowRoot ? [child].concat(unpackChildren(child.shadowRoot)) : child))
	    .flat();
	};
	// TODO: could be extended by audio[controls], video[controls], [contenteditable]:not([contenteditable="false"]) or iframe
	const isFocusableElement = (el) => {
	  const { nodeName } = el;
	  return (((nodeName === 'INPUT' && el.type !== 'hidden') ||
	    nodeName === 'TEXTAREA' ||
	    nodeName === 'SELECT' ||
	    nodeName === 'BUTTON' ||
	    (nodeName === 'A' && !!el.href)) &&
	    el.tabIndex >= 0 &&
	    !el.disabled);
	};
	const getFirstAndLastFocusableElement = (host, closeButton) => {
	  const focusableElements = (closeButton ? [closeButton] : []).concat(unpackChildren(host).filter(isFocusableElement));
	  return [focusableElements[0], focusableElements.pop()];
	};
	let documentKeydownListener;
	const setFocusTrap = (host, isOpen, closeBtn, // irrelevant for disconnectedCallback
	closeFn // irrelevant for disconnectedCallback
	) => {
	  let focusableElements = [];
	  document.removeEventListener('keydown', documentKeydownListener);
	  if (isOpen) {
	    focusableElements = getFirstAndLastFocusableElement(host, closeBtn);
	    documentKeydownListener = (e) => {
	      const { key, shiftKey } = e;
	      const { activeElement, firstElementChild } = host.shadowRoot;
	      if (key === 'Escape') {
	        closeFn();
	      }
	      else if (key === 'Tab') {
	        if (shiftKey && activeElement === firstElementChild) {
	          // when component is opened initially, the dialog is focused and shift + tab would break out of cycle
	          e.preventDefault();
	          focusableElements[1]?.focus();
	        }
	        else if (!focusableElements.filter((x) => x).length) {
	          // if we don't have any focusableElements we need to prevent Tab here
	          e.preventDefault();
	        }
	        // all other cases respect the natural tab order
	        // the cycle itself is accomplished within setFirstAndLastFocusableElementKeydownListener
	      }
	    };
	    document.addEventListener('keydown', documentKeydownListener);
	  }
	  setFirstAndLastFocusableElementKeydownListener(focusableElements);
	};
	/** cache of previous first and last focusable element so we are able to remove them again */
	let FOCUSABLE_ELEMENT_CACHE = [];
	/** cache of previous event handler pair so we are able to remove them again */
	let KEYDOWN_EVENT_HANDLER_CACHE = [];
	const setFirstAndLastFocusableElementKeydownListener = (focusableElements) => {
	  // remove previous handlers if there are any
	  if (FOCUSABLE_ELEMENT_CACHE.length) {
	    FOCUSABLE_ELEMENT_CACHE.forEach((el, idx) => el.removeEventListener('keydown', KEYDOWN_EVENT_HANDLER_CACHE[idx]));
	  }
	  // create, apply and save new handlers for future removal
	  if (focusableElements.filter((x) => x).length) {
	    FOCUSABLE_ELEMENT_CACHE = [...focusableElements]; // prevent mutation
	    KEYDOWN_EVENT_HANDLER_CACHE = focusableElements.map((el, idx) => {
	      const handler = (e) => {
	        if (e.key === 'Tab' && ((idx === 0 && e.shiftKey) || (idx === 1 && !e.shiftKey))) {
	          e.preventDefault();
	          focusableElements[idx === 0 ? 1 : 0].focus();
	        }
	      };
	      el.addEventListener('keydown', handler);
	      return handler;
	    });
	  }
	};

	const scrollShadowColor = 'rgba(204, 204, 204, 0.35)';
	const scrollShadowColorDark = 'rgba(0, 0, 0, 0.6)';

	const setScrollLock = (isOpen) => {
	  document.body.style.overflow = isOpen ? 'hidden' : '';
	};

	const warnIfAriaAndHeadingPropsAreUndefined = (host, heading, aria) => {
	  // TODO: slotted heading doesn't count?
	  if (!heading && !aria) {
	    validateProps.consoleWarn(`heading or aria has to be set via property for component ${validateProps.getTagNameWithoutPrefix(host)} in order to ensure accessibility.`);
	  }
	};
	const MODAL_ARIA_ATTRIBUTES = ['aria-label'];
	const clickStartedInScrollbarTrack = (host, e) => {
	  const hasScrollbars = host.scrollHeight > host.offsetHeight;
	  if (!hasScrollbars) {
	    return false;
	  }
	  else {
	    const hasOverlayScrollbars = host.scrollWidth === host.offsetWidth;
	    return e.clientX > host.clientWidth - (hasOverlayScrollbars ? 17 : 0);
	  }
	};

	modalUtils9e25e7f9.MODAL_ARIA_ATTRIBUTES = MODAL_ARIA_ATTRIBUTES;
	modalUtils9e25e7f9.clickStartedInScrollbarTrack = clickStartedInScrollbarTrack;
	modalUtils9e25e7f9.scrollShadowColor = scrollShadowColor;
	modalUtils9e25e7f9.scrollShadowColorDark = scrollShadowColorDark;
	modalUtils9e25e7f9.setFocusTrap = setFocusTrap;
	modalUtils9e25e7f9.setScrollLock = setScrollLock;
	modalUtils9e25e7f9.warnIfAriaAndHeadingPropsAreUndefined = warnIfAriaAndHeadingPropsAreUndefined;

	
	return modalUtils9e25e7f9;
}

var pAccordion_cjs_entry = {};

var hasRequiredPAccordion_cjs_entry;

function requirePAccordion_cjs_entry () {
	if (hasRequiredPAccordion_cjs_entry) return pAccordion_cjs_entry;
	hasRequiredPAccordion_cjs_entry = 1;

	Object.defineProperty(pAccordion_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const theme = requireThemeBfc10573();
	const headingTag = requireHeadingTag0acc4c21();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const hoverMediaQuery = requireHoverMediaQueryF2ccfc24();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const fontWeightSemiBold = requireFontWeightSemiBold4482c830();
	const fontSizeTextMedium = requireFontSizeTextMedium88887ad8();
	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const fontLineHeight = requireFontLineHeight78b03658();
	const fontSizeTextXXSmall = requireFontSizeTextXXSmallA02f9c40();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();

	const ACCORDION_SIZES = ['small', 'medium'];

	const getComponentCss = (size, compact, open, theme) => {
	  const { primaryColor, hoverColor, focusColor, contrastLowColor } = validateProps.getThemedColors(theme);
	  const { primaryColor: primaryColorDark, hoverColor: hoverColorDark, focusColor: focusColorDark, contrastLowColor: contrastLowColorDark, } = validateProps.getThemedColors('dark');
	  return validateProps.getCss({
	    '@global': {
	      ':host': validateProps.addImportantToEachRule({
	        display: 'block',
	        ...(!compact && {
	          borderBottom: `1px solid ${contrastLowColor}`,
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	            borderColor: contrastLowColorDark,
	          }),
	        }),
	        ...colorSchemeStyles.colorSchemeStyles,
	        ...colorSchemeStyles.hostHiddenStyles,
	      }),
	      button: {
	        display: 'flex',
	        position: 'relative',
	        justifyContent: 'space-between',
	        width: '100%',
	        textDecoration: 'none',
	        border: 0,
	        outline: 0,
	        gap: '24px',
	        background: 'transparent',
	        cursor: 'pointer',
	        textAlign: 'left',
	        color: primaryColor,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          color: primaryColorDark,
	        }),
	        ...textSmallStyle.textSmallStyle,
	        fontWeight: fontWeightSemiBold.fontWeightSemiBold,
	        ...validateProps.buildResponsiveStyles(size, (s) => ({
	          fontSize: s === 'medium' ? fontSizeTextMedium.fontSizeTextMedium : fontSizeTextSmall.fontSizeTextSmall,
	          padding: `${compact ? '4px' : s === 'medium' ? '20px' : '15px'} 0`,
	        })),
	        // mergeDeep needed because of hoverMediaQuery in certain modes not wrapping keys and therefore overriding "&::before" key
	        ...validateProps.mergeDeep({
	          '&::before': {
	            content: '""',
	            position: 'absolute',
	            borderRadius: borderRadiusSmall.borderRadiusSmall,
	            left: '-4px',
	            right: '-4px',
	            ...(compact
	              ? {
	                top: '2px',
	                bottom: '2px',
	              }
	              : {
	                top: '6px',
	                bottom: '6px',
	              }),
	          },
	        }, hoverMediaQuery.hoverMediaQuery({
	          '&::before': {
	            transition: validateProps.getTransition('background-color'),
	          },
	          '&:hover::before': {
	            background: hoverColor,
	            ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	              background: hoverColorDark,
	            }),
	          },
	        })),
	        '&:focus::before': {
	          border: `${validateProps.borderWidthBase} solid ${focusColor}`,
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	            borderColor: focusColorDark,
	          }),
	        },
	        '&:not(:focus-visible)::before': {
	          border: 0,
	        },
	      },
	    },
	    heading: {
	      margin: 0,
	    },
	    'icon-container': {
	      height: fontLineHeight.fontLineHeight,
	      width: fontLineHeight.fontLineHeight,
	      display: 'flex',
	      alignItems: 'center',
	      justifyContent: 'center',
	    },
	    icon: {
	      width: fontLineHeight.fontLineHeight,
	      height: fontLineHeight.fontLineHeight,
	      fontSize: fontSizeTextXXSmall.fontSizeTextXXSmall,
	      transform: open ? 'rotate3d(0)' : 'rotate3d(0,0,1,90deg)',
	      transition: validateProps.getTransition('transform'),
	    },
	    collapsible: {
	      color: primaryColor,
	      ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	        color: primaryColorDark,
	      }),
	      display: 'grid',
	      ...(open
	        ? {
	          gridTemplateRows: '1fr',
	          visibility: 'visible',
	          transition: `grid-template-rows ${validateProps.transitionDuration} ease-out`,
	          paddingBottom: compact ? spacingStaticSmall.spacingStaticSmall : '24px',
	        }
	        : {
	          gridTemplateRows: '0fr',
	          visibility: 'hidden',
	          transition: `grid-template-rows ${validateProps.transitionDuration} ease-out, visibility 0s linear ${validateProps.transitionDuration}`,
	        }),
	      '& div': {
	        overflow: open ? 'visible' : 'hidden',
	        // Fix overflow issues for overlapping content (e.g. select dropdown)
	        animation: open ? `$overflow ${validateProps.transitionDuration}` : 'none',
	        // Necessary to make focus outlines fully visible
	        padding: '4px',
	        margin: '-4px',
	      },
	    },
	    '@keyframes overflow': {
	      from: { overflow: 'hidden' },
	      to: { overflow: 'hidden' },
	    },
	  });
	};

	const propTypes = {
	  size: validateProps.AllowedTypes.breakpoint(ACCORDION_SIZES),
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	  heading: validateProps.AllowedTypes.string,
	  tag: validateProps.AllowedTypes.oneOf(headingTag.HEADING_TAGS),
	  open: validateProps.AllowedTypes.boolean,
	  compact: validateProps.AllowedTypes.boolean,
	};
	const Accordion = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.accordionChange = validateProps.createEvent(this, "accordionChange", 3);
	    this.update = validateProps.createEvent(this, "update", 3);
	    this.onButtonClick = () => {
	      this.update.emit({ open: !this.open });
	      this.accordionChange.emit({ open: !this.open });
	    };
	    this.size = 'small';
	    this.theme = 'light';
	    this.heading = undefined;
	    this.tag = 'h2';
	    this.open = undefined;
	    this.compact = undefined;
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    validateProps.attachComponentCss(this.host, getComponentCss, this.size, this.compact, this.open, this.theme);
	    const buttonId = 'accordion-control';
	    const contentId = 'accordion-panel';
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    const Heading = this.tag;
	    return (validateProps.h(validateProps.Host, null, validateProps.h(Heading, { class: "heading" }, validateProps.h("button", { id: buttonId, type: "button", "aria-expanded": this.open ? 'true' : 'false', "aria-controls": contentId, onClick: this.onButtonClick }, this.heading || validateProps.h("slot", { name: "heading" }), validateProps.h("span", { class: "icon-container" }, validateProps.h(PrefixedTagNames.pIcon, { class: "icon", name: this.open ? 'minus' : 'plus', theme: this.theme, size: "xx-small", "aria-hidden": "true" })))), validateProps.h("div", { id: contentId, class: "collapsible", role: "region", "aria-labelledby": buttonId }, validateProps.h("div", null, validateProps.h("slot", null)))));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	pAccordion_cjs_entry.p_accordion = Accordion;

	
	return pAccordion_cjs_entry;
}

var pBanner_cjs_entry = {};

var warnIfDeprecatedPropValueIsUsedDa5fe664 = {};

var hasRequiredWarnIfDeprecatedPropValueIsUsedDa5fe664;

function requireWarnIfDeprecatedPropValueIsUsedDa5fe664 () {
	if (hasRequiredWarnIfDeprecatedPropValueIsUsedDa5fe664) return warnIfDeprecatedPropValueIsUsedDa5fe664;
	hasRequiredWarnIfDeprecatedPropValueIsUsedDa5fe664 = 1;

	const helper = requireHelperE5c4e0db();
	const validateProps = requireValidatePropsC2afb75b();

	// TODO: add missing unit test
	const warnIfDeprecatedPropValueIsUsed = (instance, prop, deprecationMap) => {
	  const value = instance[prop];
	  if (deprecationMap[value]) {
	    const deprecatedPropWarningMessage = helper.getDeprecatedPropOrSlotWarningMessage(instance.host, `${prop}='${value}'`);
	    validateProps.consoleWarn(deprecatedPropWarningMessage, `Please use ${prop}='${deprecationMap[value]}' instead.`);
	  }
	};

	warnIfDeprecatedPropValueIsUsedDa5fe664.warnIfDeprecatedPropValueIsUsed = warnIfDeprecatedPropValueIsUsed;

	
	return warnIfDeprecatedPropValueIsUsedDa5fe664;
}

var warnIfDeprecatedPropIsUsed3a5c494c = {};

var hasRequiredWarnIfDeprecatedPropIsUsed3a5c494c;

function requireWarnIfDeprecatedPropIsUsed3a5c494c () {
	if (hasRequiredWarnIfDeprecatedPropIsUsed3a5c494c) return warnIfDeprecatedPropIsUsed3a5c494c;
	hasRequiredWarnIfDeprecatedPropIsUsed3a5c494c = 1;

	const helper = requireHelperE5c4e0db();
	const validateProps = requireValidatePropsC2afb75b();

	const warnIfDeprecatedPropIsUsed = (instance, prop, additionalText) => {
	  const propValue = instance[prop];
	  if (propValue !== undefined && propValue !== null) {
	    validateProps.consoleWarn(helper.getDeprecatedPropOrSlotWarningMessage(instance.host, prop), additionalText || '');
	  }
	};

	warnIfDeprecatedPropIsUsed3a5c494c.warnIfDeprecatedPropIsUsed = warnIfDeprecatedPropIsUsed;

	
	return warnIfDeprecatedPropIsUsed3a5c494c;
}

var hasRequiredPBanner_cjs_entry;

function requirePBanner_cjs_entry () {
	if (hasRequiredPBanner_cjs_entry) return pBanner_cjs_entry;
	hasRequiredPBanner_cjs_entry = 1;

	Object.defineProperty(pBanner_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const bannerUtils = requireBannerUtils2cc83734();
	const hasNamedSlot = requireHasNamedSlot28c6bca1();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsedDa5fe664();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed3a5c494c();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const constants = requireConstantsCa271244();
	const gridExtendedOffsetBase = requireGridExtendedOffsetBaseFb9830f6();
	const dropShadowHighStyle = requireDropShadowHighStyle7edcadc6();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const gridExtendedOffsetXXL = requireGridExtendedOffsetXXLC7a41e50();
	const helper = requireHelperE5c4e0db();
	requireGetNamedSlotA433c432();
	requireDropShadowShared6e50faf3();
	requireGridGapB5b73e4a();
	requireSpacingFluidMedium88ab712b();

	const cssVariableTop = '--p-banner-position-top';
	const cssVariableBottom = '--p-banner-position-bottom';
	const cssVariableAnimationDuration = '--p-animation-duration';
	const cssVariableZIndex = '--p-internal-banner-z-index';
	const ANIMATION_DURATION = 600;
	const duration = `var(${cssVariableAnimationDuration},${ANIMATION_DURATION}ms)`;
	const easeInQuad = 'cubic-bezier(0.45,0,0.55,1)';
	const easeOutQuad = 'cubic-bezier(0.5,1,0.89,1)';
	const topBottomFallback = '56px';
	const getComponentCss = (isOpen) => {
	  return validateProps.getCss({
	    '@global': {
	      ':host': validateProps.addImportantToEachRule({
	        position: 'fixed',
	        bottom: `var(${cssVariableBottom},${topBottomFallback})`,
	        left: gridExtendedOffsetBase.gridExtendedOffsetBase,
	        right: gridExtendedOffsetBase.gridExtendedOffsetBase,
	        margin: 0,
	        padding: 0,
	        width: 'auto',
	        maxWidth: '100%',
	        zIndex: `var(${cssVariableZIndex},${constants.BANNER_Z_INDEX})`,
	        ...dropShadowHighStyle.dropShadowHighStyle,
	        borderRadius: borderRadiusSmall.borderRadiusSmall,
	        ...(isOpen
	          ? {
	            opacity: 1,
	            visibility: 'inherit',
	            transform: 'translate3d(0,0,0)',
	            transition: `opacity ${duration} ${easeInQuad},transform ${duration} ${easeInQuad}`,
	          }
	          : {
	            opacity: 0,
	            visibility: 'hidden',
	            transform: `translate3d(0,calc(var(${cssVariableBottom},${topBottomFallback}) + 100%),0)`,
	            '&(.hydrated),&(.ssr)': {
	              transition: `visibility 0s linear ${duration},opacity ${duration} ${easeOutQuad},transform ${duration} ${easeOutQuad}`,
	            },
	          }),
	        [validateProps.getMediaQueryMin('s')]: {
	          top: `var(${cssVariableTop},${topBottomFallback})`,
	          bottom: 'auto',
	          left: gridExtendedOffsetXXL.gridExtendedOffsetS,
	          right: gridExtendedOffsetXXL.gridExtendedOffsetS,
	          // space before and after "-" is crucial)
	          ...(!isOpen && { transform: `translate3d(0,calc(-100% - var(${cssVariableTop},${topBottomFallback})),0)` }),
	        },
	        [validateProps.getMediaQueryMin('xxl')]: {
	          left: gridExtendedOffsetXXL.gridExtendedOffsetXXL,
	          right: gridExtendedOffsetXXL.gridExtendedOffsetXXL,
	        },
	        ...colorSchemeStyles.colorSchemeStyles,
	        ...colorSchemeStyles.hostHiddenStyles,
	      }),
	    },
	  });
	};

	const propTypes = {
	  open: validateProps.AllowedTypes.boolean,
	  heading: validateProps.AllowedTypes.string,
	  description: validateProps.AllowedTypes.string,
	  state: validateProps.AllowedTypes.oneOf(bannerUtils.BANNER_STATES),
	  dismissButton: validateProps.AllowedTypes.boolean,
	  persistent: validateProps.AllowedTypes.boolean,
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Banner = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.dismiss = validateProps.createEvent(this, "dismiss", 3);
	    this.onKeyboardEvent = (e) => {
	      if (e.key === 'Escape') {
	        this.removeBanner();
	      }
	    };
	    this.removeBanner = (e) => {
	      if (this.hasDismissButton) {
	        e?.stopPropagation(); // prevent double event emission because of identical name
	        this.dismiss.emit();
	      }
	    };
	    this.open = false;
	    this.heading = '';
	    this.description = '';
	    this.state = 'info';
	    this.dismissButton = true;
	    this.persistent = undefined;
	    this.width = undefined;
	    this.theme = 'light';
	  }
	  get hasDismissButton() {
	    return this.persistent ? false : this.dismissButton;
	  }
	  openChangeHandler(isOpen) {
	    if (this.hasDismissButton) {
	      if (isOpen) {
	        this.closeBtn?.focus();
	        document.addEventListener('keydown', this.onKeyboardEvent);
	      }
	      else {
	        document.removeEventListener('keydown', this.onKeyboardEvent);
	      }
	    }
	  }
	  connectedCallback() {
	    if (this.open && this.hasDismissButton) {
	      document.addEventListener('keydown', this.onKeyboardEvent);
	    }
	  }
	  componentDidLoad() {
	    if (this.hasDismissButton) {
	      // messy… optional chaining is needed in case child component is unmounted too early
	      this.closeBtn = validateProps.getShadowRootHTMLElement(this.inlineNotificationElement, '.close');
	      this.closeBtn?.focus();
	    }
	  }
	  disconnectedCallback() {
	    if (this.hasDismissButton) {
	      document.removeEventListener('keydown', this.onKeyboardEvent);
	    }
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'state', {
	      neutral: 'info',
	    });
	    warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'persistent', 'Please use dismissButton prop instead.');
	    warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'width', 'The component is aligned with Porsche Grid "extended" by default.');
	    const hasTitleSlot = hasNamedSlot.hasNamedSlot(this.host, 'title');
	    if (hasTitleSlot) {
	      validateProps.consoleWarn(helper.getDeprecatedPropOrSlotWarningMessage(this.host, 'slot="title"'), 'Please use the heading prop or slot="heading" instead.');
	    }
	    validateProps.attachComponentCss(this.host, getComponentCss, this.open);
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    return (validateProps.h(PrefixedTagNames.pInlineNotification, { ref: (el) => (this.inlineNotificationElement = el), heading: this.heading, description: this.description, state: this.state, dismissButton: this.hasDismissButton, theme: this.theme, onDismiss: this.removeBanner, "aria-hidden": !this.open ? 'true' : 'false' }, hasNamedSlot.hasNamedSlot(this.host, 'heading') ? (validateProps.h("slot", { name: "heading", slot: "heading" })) : (hasTitleSlot && validateProps.h("slot", { name: "title", slot: "heading" })), hasNamedSlot.hasNamedSlot(this.host, 'description') && validateProps.h("slot", { name: "description" })));
	  }
	  get host() { return validateProps.getElement(this); }
	  static get watchers() { return {
	    "open": ["openChangeHandler"]
	  }; }
	};

	pBanner_cjs_entry.p_banner = Banner;

	
	return pBanner_cjs_entry;
}

var pButtonGroup_cjs_entry = {};

var spacingFluidSmall2c6caae7 = {};

var hasRequiredSpacingFluidSmall2c6caae7;

function requireSpacingFluidSmall2c6caae7 () {
	if (hasRequiredSpacingFluidSmall2c6caae7) return spacingFluidSmall2c6caae7;
	hasRequiredSpacingFluidSmall2c6caae7 = 1;

	const spacingFluidSmall = 'clamp(8px, 0.5vw + 6px, 16px)';

	spacingFluidSmall2c6caae7.spacingFluidSmall = spacingFluidSmall;

	
	return spacingFluidSmall2c6caae7;
}

var hasRequiredPButtonGroup_cjs_entry;

function requirePButtonGroup_cjs_entry () {
	if (hasRequiredPButtonGroup_cjs_entry) return pButtonGroup_cjs_entry;
	hasRequiredPButtonGroup_cjs_entry = 1;

	Object.defineProperty(pButtonGroup_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const groupDirectionStyles = requireGroupDirectionStyles27ae72d0();
	const spacingFluidSmall = requireSpacingFluidSmall2c6caae7();

	const getComponentCss = (direction) => {
	  return validateProps.getCss({
	    '@global': {
	      ':host': {
	        display: 'block',
	        ...validateProps.addImportantToEachRule({
	          ...colorSchemeStyles.colorSchemeStyles,
	          ...colorSchemeStyles.hostHiddenStyles,
	        }),
	      },
	      div: {
	        display: 'flex',
	        gap: spacingFluidSmall.spacingFluidSmall,
	        ...validateProps.buildResponsiveStyles(direction, groupDirectionStyles.getGroupDirectionJssStyles),
	      },
	    },
	  });
	};

	const propTypes = {
	  direction: validateProps.AllowedTypes.breakpoint(groupDirectionStyles.GROUP_DIRECTIONS),
	};
	const ButtonGroup = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.direction = { base: 'column', xs: 'row' };
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    validateProps.attachComponentCss(this.host, getComponentCss, this.direction);
	    return (validateProps.h("div", { role: "group" }, validateProps.h("slot", null)));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	pButtonGroup_cjs_entry.p_button_group = ButtonGroup;

	
	return pButtonGroup_cjs_entry;
}

var pButtonPure_cjs_entry = {};

var textSize3b156bcb = {};

var hasRequiredTextSize3b156bcb;

function requireTextSize3b156bcb () {
	if (hasRequiredTextSize3b156bcb) return textSize3b156bcb;
	hasRequiredTextSize3b156bcb = 1;

	const TEXT_SIZES = ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'inherit'];

	textSize3b156bcb.TEXT_SIZES = TEXT_SIZES;

	
	return textSize3b156bcb;
}

var textWeight8f0d791a = {};

var hasRequiredTextWeight8f0d791a;

function requireTextWeight8f0d791a () {
	if (hasRequiredTextWeight8f0d791a) return textWeight8f0d791a;
	hasRequiredTextWeight8f0d791a = 1;

	// 'thin' is deprecated and will be mapped to 'regular'
	// 'semibold' is deprecated and will be mapped to 'semi-bold'
	/** @deprecated */
	const TEXT_WEIGHTS_DEPRECATED = ['thin', 'semibold'];
	const TEXT_WEIGHTS = ['regular', 'semi-bold', 'bold', ...TEXT_WEIGHTS_DEPRECATED];

	textWeight8f0d791a.TEXT_WEIGHTS = TEXT_WEIGHTS;

	
	return textWeight8f0d791a;
}

var hasRequiredPButtonPure_cjs_entry;

function requirePButtonPure_cjs_entry () {
	if (hasRequiredPButtonPure_cjs_entry) return pButtonPure_cjs_entry;
	hasRequiredPButtonPure_cjs_entry = 1;

	Object.defineProperty(pButtonPure_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const buttonType = requireButtonTypeAe0c09db();
	const isDisabledOrLoading = requireIsDisabledOrLoadingAd97a497();
	const buttonHandling = requireButtonHandlingA110f521();
	const buttonLinkPureUtils = requireButtonLinkPureUtils468dbe67();
	const theme = requireThemeBfc10573();
	const alignLabel = requireAlignLabelFc1cc093();
	const textSize = requireTextSize3b156bcb();
	const textWeight = requireTextWeight8f0d791a();
	const getButtonBaseAriaAttributes = requireGetButtonBaseAriaAttributes51363b44();
	const linkButtonPureStyles = requireLinkButtonPureStyles1e533bc9();
	const fontLineHeight = requireFontLineHeight78b03658();
	requireGetClosestHTMLElement0135bfd9();
	requireIsParentOfKindA9c351f2();
	requireColorSchemeStyles81696be8();
	requireHoverMediaQueryF2ccfc24();
	requireIsThemeAutoC90cd35d();
	requireFontSizeTextXXSmallA02f9c40();
	requireFontSizeTextXSmallE59d35d7();
	requireFontSizeTextSmall508930e5();
	requireFontSizeTextMedium88887ad8();
	requireFontSizeTextLarge05a4bc90();
	requireFontSizeTextXLarge0ecf9ef3();
	requireSpacingStaticXSmallB7d708b8();
	requireTextSmallStyle7246779a();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireBorderRadiusSmall5f37fc45();

	const warnIfIsLoadingAndIconIsNone = (host, loading, iconName, iconSource) => {
	  if (loading && !buttonLinkPureUtils.hasVisibleIcon(iconName, iconSource)) {
	    validateProps.consoleWarn(`combination of properties icon='${iconName}' and loading='${loading}' for component ${validateProps.getTagNameWithoutPrefix(host)} is not supported.`);
	  }
	};
	const getButtonPureAriaAttributes = (isDisabled, isLoading, aria) => {
	  return {
	    ...validateProps.parseAndGetAriaAttributes(aria),
	    ...getButtonBaseAriaAttributes.getButtonBaseAriaAttributes(isDisabled, isLoading),
	  };
	};

	const getComponentCss = (icon, iconSource, active, isLoading, isDisabledOrLoading, stretch, size, hideLabel, alignLabel, theme) => {
	  const hasIcon = buttonLinkPureUtils.hasVisibleIcon(icon, iconSource);
	  return validateProps.getCss(validateProps.mergeDeep(linkButtonPureStyles.getLinkButtonPureStyles(icon, iconSource, active, isDisabledOrLoading, stretch, size, hideLabel, alignLabel, false, theme), {
	    root: {
	      appearance: 'none',
	      background: 'transparent',
	      textAlign: 'left',
	      border: 0,
	      cursor: isDisabledOrLoading ? 'not-allowed' : 'pointer',
	    },
	    ...(!hasIcon &&
	      isLoading && {
	      label: {
	        visibility: 'hidden',
	      },
	      icon: {
	        position: 'absolute',
	        top: 0,
	        left: `calc(50% - ${fontLineHeight.fontLineHeight} / 2)`,
	        width: fontLineHeight.fontLineHeight,
	        height: fontLineHeight.fontLineHeight,
	      },
	    }),
	  }));
	};

	const propTypes = {
	  type: validateProps.AllowedTypes.oneOf(buttonType.BUTTON_TYPES),
	  disabled: validateProps.AllowedTypes.boolean,
	  loading: validateProps.AllowedTypes.boolean,
	  size: validateProps.AllowedTypes.breakpoint(textSize.TEXT_SIZES),
	  weight: validateProps.AllowedTypes.oneOf(textWeight.TEXT_WEIGHTS),
	  icon: validateProps.AllowedTypes.string,
	  iconSource: validateProps.AllowedTypes.string,
	  active: validateProps.AllowedTypes.boolean,
	  hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	  alignLabel: validateProps.AllowedTypes.breakpoint(alignLabel.ALIGN_LABELS),
	  stretch: validateProps.AllowedTypes.breakpoint('boolean'),
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	  aria: validateProps.AllowedTypes.aria(buttonType.BUTTON_ARIA_ATTRIBUTES),
	};
	const ButtonPure = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.type = 'submit';
	    this.disabled = false;
	    this.loading = false;
	    this.size = 'small';
	    this.weight = 'regular';
	    this.icon = 'arrow-right';
	    this.iconSource = undefined;
	    this.active = false;
	    this.hideLabel = false;
	    this.alignLabel = 'right';
	    this.stretch = false;
	    this.theme = 'light';
	    this.aria = undefined;
	  }
	  get isDisabledOrLoading() {
	    return isDisabledOrLoading.isDisabledOrLoading(this.disabled, this.loading);
	  }
	  // this stops click events when button is disabled
	  onClick(e) {
	    if (this.isDisabledOrLoading) {
	      e.stopPropagation();
	    }
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  componentDidLoad() {
	    buttonHandling.improveButtonHandlingForCustomElement(this.host, () => this.type, () => this.isDisabledOrLoading);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    warnIfIsLoadingAndIconIsNone(this.host, this.loading, this.icon, this.iconSource);
	    buttonLinkPureUtils.warnIfParentIsPTextAndIconIsNone(this.host, this.icon, this.iconSource);
	    validateProps.attachComponentCss(this.host, getComponentCss, this.icon, this.iconSource, this.active, this.loading, this.isDisabledOrLoading, this.stretch, this.size, this.hideLabel, this.alignLabel, this.theme);
	    const hasIcon = buttonLinkPureUtils.hasVisibleIcon(this.icon, this.iconSource);
	    const iconProps = {
	      class: 'icon',
	      size: 'inherit',
	      theme: this.theme,
	    };
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    return (validateProps.h("button", { ...getButtonPureAriaAttributes(this.disabled, this.loading, this.aria), class: "root", type: this.type }, this.loading ? (validateProps.h(PrefixedTagNames.pSpinner, { aria: { 'aria-label': 'Loading state' }, ...iconProps })) : (hasIcon && (validateProps.h(PrefixedTagNames.pIcon, { ...iconProps, name: this.icon, source: this.iconSource, color: this.isDisabledOrLoading ? 'state-disabled' : 'primary', theme: this.theme, "aria-hidden": "true" }))), validateProps.h("span", { class: "label" }, validateProps.h("slot", null))));
	  }
	  static get delegatesFocus() { return true; }
	  get host() { return validateProps.getElement(this); }
	};

	pButtonPure_cjs_entry.p_button_pure = ButtonPure;

	
	return pButtonPure_cjs_entry;
}

var pButtonTile_cjs_entry = {};

var hasRequiredPButtonTile_cjs_entry;

function requirePButtonTile_cjs_entry () {
	if (hasRequiredPButtonTile_cjs_entry) return pButtonTile_cjs_entry;
	hasRequiredPButtonTile_cjs_entry = 1;

	Object.defineProperty(pButtonTile_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const buttonType = requireButtonTypeAe0c09db();
	const isDisabledOrLoading = requireIsDisabledOrLoadingAd97a497();
	const linkTileUtils = requireLinkTileUtils98dcc629();
	const tileBaseStyles = requireTileBaseStylesBc82297d();
	requireFontWeightStyles4b24ddd8();
	requireFontWeightRegularD0c768ac();
	requireFontWeightSemiBold4482c830();
	requireSpacingFluidMedium88ab712b();
	requireSpacingFluidLarge6087a0f7();
	requireFontSizeTextMedium88887ad8();
	requireThemeBfc10573();
	requireTextShared9135e2ef();
	requireFontLineHeight78b03658();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextLarge05a4bc90();
	requireColorSchemeStyles81696be8();
	requireHoverMediaQueryF2ccfc24();
	requireTextIconStylesDeb3ffbc();
	requireBorderRadiusLargeA0aa3a01();
	requireSpacingStaticMedium94812711();

	const getComponentCss = (isDisabledOrLoading, ...args) => {
	  const buttonLinkTileStyles = linkTileUtils.getButtonLinkTileStyles(...args);
	  return validateProps.getCss({
	    ...buttonLinkTileStyles,
	    root: {
	      ...buttonLinkTileStyles.root,
	      cursor: isDisabledOrLoading ? 'not-allowed' : 'pointer',
	    },
	  });
	};

	const propTypes = {
	  ...linkTileUtils.sharedTilePropTypes,
	  weight: validateProps.AllowedTypes.breakpoint(tileBaseStyles.TILE_WEIGHTS),
	  type: validateProps.AllowedTypes.oneOf(buttonType.BUTTON_TYPES),
	  disabled: validateProps.AllowedTypes.boolean,
	  loading: validateProps.AllowedTypes.boolean,
	  icon: validateProps.AllowedTypes.string,
	  iconSource: validateProps.AllowedTypes.string,
	  aria: validateProps.AllowedTypes.aria(buttonType.BUTTON_ARIA_ATTRIBUTES),
	};
	const ButtonTile = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.size = 'default';
	    this.weight = 'semi-bold';
	    this.background = 'dark';
	    this.aspectRatio = '4:3';
	    this.label = undefined;
	    this.description = undefined;
	    this.align = 'bottom';
	    this.gradient = true;
	    this.compact = false;
	    this.type = 'submit';
	    this.disabled = false;
	    this.loading = false;
	    this.icon = 'none';
	    this.iconSource = undefined;
	    this.aria = undefined;
	  }
	  onClick(e) {
	    if (isDisabledOrLoading.isDisabledOrLoading(this.disabled, this.loading)) {
	      e.stopPropagation();
	    }
	  }
	  componentWillLoad() {
	    linkTileUtils.throwIfAlignTopAndNotCompact(this.host, this.align, this.compact);
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  render() {
	    this.compact = validateProps.parseJSON(this.compact); // parsing the value just once per lifecycle
	    validateProps.validateProps(this, propTypes);
	    validateProps.attachComponentCss(this.host, getComponentCss, isDisabledOrLoading.isDisabledOrLoading(this.disabled, this.loading), this.aspectRatio, this.size, this.weight, this.background, this.align, this.compact, this.gradient, this.disabled);
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    const buttonProps = {
	      theme: this.background,
	      variant: 'secondary',
	      iconSource: this.iconSource,
	      type: this.type,
	      disabled: this.disabled,
	      loading: this.loading,
	      aria: this.aria,
	    };
	    const button = (validateProps.h(PrefixedTagNames.pButton, { ...buttonProps, icon: this.icon, key: "link-or-button", class: "link-or-button" }, this.label));
	    const buttonPure = (validateProps.h(PrefixedTagNames.pButtonPure, { ...buttonProps, key: "link-or-button-pure", class: "link-or-button-pure", hideLabel: true, icon: this.icon === 'none' ? 'arrow-right' : this.icon }, this.label));
	    return (validateProps.h("div", { class: "root" }, validateProps.h("div", { class: "image-container" }, validateProps.h("slot", null)), validateProps.h("div", { class: "content" }, validateProps.h("p", null, this.description), typeof this.compact === 'boolean' ? (this.compact ? buttonPure : button) : [buttonPure, button])));
	  }
	  static get delegatesFocus() { return true; }
	  get host() { return validateProps.getElement(this); }
	};

	pButtonTile_cjs_entry.p_button_tile = ButtonTile;

	
	return pButtonTile_cjs_entry;
}

var pButton_cjs_entry = {};

var hasRequiredPButton_cjs_entry;

function requirePButton_cjs_entry () {
	if (hasRequiredPButton_cjs_entry) return pButton_cjs_entry;
	hasRequiredPButton_cjs_entry = 1;

	Object.defineProperty(pButton_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const buttonType = requireButtonTypeAe0c09db();
	const isDisabledOrLoading = requireIsDisabledOrLoadingAd97a497();
	const buttonHandling = requireButtonHandlingA110f521();
	const buttonLinkPureUtils = requireButtonLinkPureUtils468dbe67();
	const theme = requireThemeBfc10573();
	const linkButtonVariant = requireLinkButtonVariant3104b925();
	const getButtonBaseAriaAttributes = requireGetButtonBaseAriaAttributes51363b44();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const linkButtonStyles = requireLinkButtonStylesE68cc0c9();
	const fontLineHeight = requireFontLineHeight78b03658();
	requireGetClosestHTMLElement0135bfd9();
	requireIsParentOfKindA9c351f2();
	requireColorSchemeStyles81696be8();
	requireHoverMediaQueryF2ccfc24();
	requireBorderRadiusSmall5f37fc45();
	requireTextSmallStyle7246779a();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireSpacingStaticSmall2130ed04();
	requireBorderRadiusMedium758b9411();

	const getButtonAriaAttributes = (isDisabled, isLoading, aria) => {
	  return {
	    ...validateProps.parseAndGetAriaAttributes(aria),
	    ...getButtonBaseAriaAttributes.getButtonBaseAriaAttributes(isDisabled, isLoading),
	  };
	};

	const getDisabledColors = (variant, loading, theme) => {
	  const { contrastMediumColor, contrastHighColor, disabledColor, hoverColor } = validateProps.getThemedColors(theme);
	  const { canvasColor } = validateProps.getHighContrastColors();
	  const colors = {
	    primary: {
	      textColor: validateProps.isHighContrastMode ? disabledColor : contrastHighColor,
	      borderColor: validateProps.isHighContrastMode ? disabledColor : loading ? contrastHighColor : disabledColor,
	      backgroundColor: validateProps.isHighContrastMode ? canvasColor : loading ? contrastHighColor : disabledColor,
	    },
	    secondary: {
	      textColor: disabledColor,
	      borderColor: validateProps.isHighContrastMode ? disabledColor : loading ? contrastMediumColor : disabledColor,
	      backgroundColor: validateProps.isHighContrastMode ? canvasColor : loading ? hoverColor : 'transparent',
	    },
	  };
	  return colors[variant === 'tertiary' ? 'secondary' : variant];
	};
	const getComponentCss = (icon, iconSource, variant, hideLabel, disabled, loading, theme) => {
	  const disabledOrLoading = isDisabledOrLoading.isDisabledOrLoading(disabled, loading);
	  const { textColor, borderColor, backgroundColor } = getDisabledColors(variant, loading, theme);
	  const { textColor: textColorDark, borderColor: borderColorDark, backgroundColor: backgroundColorDark, } = getDisabledColors(variant, loading, 'dark');
	  const isPrimary = variant === 'primary';
	  return validateProps.getCss(validateProps.mergeDeep(linkButtonStyles.getLinkButtonStyles(icon, iconSource, variant, hideLabel, disabledOrLoading, false, theme), {
	    root: {
	      cursor: disabledOrLoading ? 'not-allowed' : 'pointer',
	      ...(disabledOrLoading && {
	        backgroundColor,
	        borderColor,
	        color: textColor,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          backgroundColor: backgroundColorDark,
	          borderColor: borderColorDark,
	          color: textColorDark,
	        }),
	      }),
	      ...(loading && !isPrimary && validateProps.frostedGlassStyle),
	    },
	    ...(loading && {
	      spinner: {
	        width: fontLineHeight.fontLineHeight,
	        height: fontLineHeight.fontLineHeight,
	        pointerEvents: 'none',
	        position: 'absolute',
	        top: '50%',
	        left: '50%',
	        transform: 'translate(-50%, -50%)',
	        ...(isPrimary && !validateProps.isHighContrastMode && { filter: 'invert(1)' }),
	      },
	    }),
	    label: {
	      transition: validateProps.getTransition('opacity'),
	      ...(loading && {
	        opacity: 0, // use opacity for smooth transition between states
	      }),
	    },
	    icon: {
	      transition: validateProps.getTransition('opacity'),
	      ...(!disabled &&
	        isPrimary &&
	        !validateProps.isHighContrastMode && {
	        filter: 'invert(1)',
	      }),
	      ...(loading && {
	        opacity: 0, // use opacity for smooth transition between states
	      }),
	    },
	  }));
	};

	const propTypes = {
	  type: validateProps.AllowedTypes.oneOf(buttonType.BUTTON_TYPES),
	  variant: validateProps.AllowedTypes.oneOf(linkButtonVariant.LINK_BUTTON_VARIANTS),
	  disabled: validateProps.AllowedTypes.boolean,
	  loading: validateProps.AllowedTypes.boolean,
	  icon: validateProps.AllowedTypes.string,
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	  iconSource: validateProps.AllowedTypes.string,
	  hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	  aria: validateProps.AllowedTypes.aria(buttonType.BUTTON_ARIA_ATTRIBUTES),
	};
	const Button = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.type = 'submit';
	    this.disabled = false;
	    this.loading = false;
	    this.variant = 'primary';
	    this.icon = 'none';
	    this.iconSource = undefined;
	    this.hideLabel = false;
	    this.theme = 'light';
	    this.aria = undefined;
	  }
	  onClick(e) {
	    if (isDisabledOrLoading.isDisabledOrLoading(this.disabled, this.loading)) {
	      e.stopPropagation();
	    }
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  componentDidLoad() {
	    buttonHandling.improveButtonHandlingForCustomElement(this.host, () => this.type, () => isDisabledOrLoading.isDisabledOrLoading(this.disabled, this.loading));
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    validateProps.attachComponentCss(this.host, getComponentCss, this.icon, this.iconSource, this.variant, this.hideLabel, this.disabled, this.loading, this.theme);
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    return (validateProps.h("button", { ...getButtonAriaAttributes(this.disabled, this.loading, this.aria), class: "root", type: this.type }, this.loading && (validateProps.h(PrefixedTagNames.pSpinner, { class: "spinner", size: "inherit", theme: this.theme, aria: { 'aria-label': 'Loading state' } })), buttonLinkPureUtils.hasVisibleIcon(this.icon, this.iconSource) && (validateProps.h(PrefixedTagNames.pIcon, { class: "icon", size: "inherit", name: this.iconSource ? undefined : this.icon, source: this.iconSource, color: this.disabled ? (this.variant === 'primary' ? 'contrast-high' : 'state-disabled') : 'primary', theme: this.theme, "aria-hidden": "true" })), validateProps.h("span", { class: "label" }, validateProps.h("slot", null))));
	  }
	  static get delegatesFocus() { return true; }
	  get host() { return validateProps.getElement(this); }
	};

	pButton_cjs_entry.p_button = Button;

	
	return pButton_cjs_entry;
}

var pCarousel_cjs_entry = {};

var spacingFluidXSmall0dd753ae = {};

var hasRequiredSpacingFluidXSmall0dd753ae;

function requireSpacingFluidXSmall0dd753ae () {
	if (hasRequiredSpacingFluidXSmall0dd753ae) return spacingFluidXSmall0dd753ae;
	hasRequiredSpacingFluidXSmall0dd753ae = 1;

	const spacingFluidXSmall = 'clamp(4px, 0.25vw + 3px, 8px)';

	spacingFluidXSmall0dd753ae.spacingFluidXSmall = spacingFluidXSmall;

	
	return spacingFluidXSmall0dd753ae;
}

var hasRequiredPCarousel_cjs_entry;

function requirePCarousel_cjs_entry () {
	if (hasRequiredPCarousel_cjs_entry) return pCarousel_cjs_entry;
	hasRequiredPCarousel_cjs_entry = 1;

	Object.defineProperty(pCarousel_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const hasNamedSlot = requireHasNamedSlot28c6bca1();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const spacingFluidMedium = requireSpacingFluidMedium88ab712b();
	const borderRadiusLarge = requireBorderRadiusLargeA0aa3a01();
	const headingShared = requireHeadingSharedAa59e66d();
	const fontSizeHeadingXLarge = requireFontSizeHeadingXLargeF33a0a84();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const spacingFluidXSmall = requireSpacingFluidXSmall0dd753ae();
	const fontLineHeight = requireFontLineHeight78b03658();
	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const getMediaQueryMax = requireGetMediaQueryMax2587ee0a();
	const gridBasicOffset = requireGridBasicOffsetEafb13d6();
	const gridGap = requireGridGapB5b73e4a();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const getSlotTextContent = requireGetSlotTextContent5379eb26();
	const hasDescription = requireHasDescriptionA19e4bdc();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed3a5c494c();
	const theme = requireThemeBfc10573();
	requireGetNamedSlotA433c432();
	requireFontWeightSemiBold4482c830();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextXLarge0ecf9ef3();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireGridExtendedOffsetBaseFb9830f6();
	requireGridExtendedOffsetXXLC7a41e50();
	requireHelperE5c4e0db();

	const headingXLargeStyle = {
	    font: `${headingShared._headingFontPartA}${fontSizeHeadingXLarge.fontSizeHeadingXLarge}${headingShared._headingFontPartB}`,
	};

	const carouselTransitionDuration = 400;
	const bulletActiveClass = 'bullet--active';
	const paginationInfiniteStartCaseClass = 'pagination--infinite';
	const bulletInfiniteClass = 'bullet--infinite';
	const paginationBulletSize = '8px';
	const paginationInfiniteBulletSize = '4px';
	const paginationActiveBulletSize = '20px';
	const selectorHeading = 'h2,::slotted([slot=heading])';
	const selectorDescription = 'p,::slotted([slot=description])';
	const mediaQueryS = validateProps.getMediaQueryMin('s');
	const mediaQueryXXL = validateProps.getMediaQueryMin('xxl');
	// we need an explicit grid template, therefor we need to calculate the button group width
	const buttonSize = `calc(${spacingStaticSmall.spacingStaticSmall} * 2 + ${fontLineHeight.fontLineHeight})`;
	// + 2px, compensates hover offset of button-pure
	const buttonGroupWidth = `calc(${buttonSize} * 3 + ${spacingStaticXSmall.spacingStaticXSmall} + 2px)`;
	const spacingMap = {
	  basic: gridBasicOffset.gridBasicOffset,
	  extended: gridBasicOffset.gridExtendedOffset,
	};
	const getComponentCss = (width, hasPagination, isInfinitePagination, alignHeader, theme) => {
	  const { primaryColor, contrastMediumColor, focusColor } = validateProps.getThemedColors(theme);
	  const { primaryColor: primaryColorDark, contrastMediumColor: contrastMediumColorDark, focusColor: focusColorDark, } = validateProps.getThemedColors('dark');
	  const { canvasTextColor } = validateProps.getHighContrastColors();
	  const isHeaderAlignCenter = alignHeader === 'center';
	  return validateProps.getCss({
	    '@global': {
	      ':host': validateProps.addImportantToEachRule({
	        display: 'flex',
	        gap: spacingFluidMedium.spacingFluidMedium,
	        flexDirection: 'column',
	        boxSizing: 'content-box',
	        ...colorSchemeStyles.colorSchemeStyles,
	        ...colorSchemeStyles.hostHiddenStyles,
	      }),
	      '::slotted(*)': {
	        borderRadius: validateProps.addImportantToRule(`var(--p-carousel-border-radius, ${borderRadiusLarge.borderRadiusLarge})`),
	      },
	      '::slotted(*:focus-visible)': validateProps.addImportantToEachRule({
	        outline: `${validateProps.borderWidthBase} solid ${focusColor}`,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          outlineColor: focusColorDark,
	        }),
	        outlineOffset: '2px',
	      }),
	      [selectorHeading]: validateProps.addImportantToEachRule({
	        ...headingXLargeStyle,
	        maxWidth: '56.25rem',
	        margin: 0,
	      }),
	      [selectorDescription]: validateProps.addImportantToEachRule({
	        ...textSmallStyle.textSmallStyle,
	        maxWidth: '34.375rem',
	        margin: `${spacingFluidXSmall.spacingFluidXSmall} 0 0`,
	      }),
	      [`${selectorHeading},${selectorDescription}`]: validateProps.addImportantToEachRule({
	        color: primaryColor,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          color: primaryColorDark,
	        }),
	        [mediaQueryS]: isHeaderAlignCenter
	          ? {
	            gridColumn: 2,
	          }
	          : {
	            gridColumn: '1 / 3',
	          },
	      }),
	    },
	    header: {
	      display: 'grid',
	      padding: `0 ${spacingMap[width].base}`,
	      ...(isHeaderAlignCenter && {
	        textAlign: 'center',
	      }),
	      [mediaQueryS]: {
	        fontFamily: fontLineHeight.fontFamily,
	        fontSize: fontSizeTextSmall.fontSizeTextSmall,
	        columnGap: spacingStaticMedium.spacingStaticMedium,
	        gridTemplateColumns: `${buttonGroupWidth} minmax(0px, 1fr) ${buttonGroupWidth}`,
	        ...(isHeaderAlignCenter && {
	          justifyItems: 'center', // relevant when max-width of heading or description is reached
	        }),
	        padding: `0 ${spacingMap[width].s}`,
	      },
	      [mediaQueryXXL]: {
	        padding: `0 ${spacingMap[width].xxl}`,
	      },
	    },
	    nav: {
	      display: 'none',
	      [mediaQueryS]: {
	        display: 'flex',
	        gap: spacingStaticXSmall.spacingStaticXSmall,
	        gridArea: '1 / 3 / 3 / auto',
	        alignItems: 'end',
	        justifyContent: 'end',
	        justifySelf: 'end',
	      },
	    },
	    btn: {
	      padding: spacingStaticSmall.spacingStaticSmall,
	    },
	    'skip-link': {
	      opacity: 0,
	      pointerEvents: 'none',
	      '&:focus': {
	        opacity: 1,
	        pointerEvents: 'all',
	      },
	    },
	    splide: {
	      overflow: 'hidden',
	      padding: '4px 0',
	      margin: '-4px 0',
	      '&__track': {
	        // !important is necessary to override inline styles set by splide library
	        ...validateProps.addImportantToEachRule({
	          padding: `0 ${spacingMap[width].base}`,
	          [getMediaQueryMax.getMediaQueryMax('xs')]: {
	            paddingRight: `calc(${gridBasicOffset.gridBasicOffsetBase} + ${gridGap.gridGap})`, // we need to give cut off slides a bit more space on mobile views
	          },
	          [mediaQueryS]: {
	            padding: `0 ${spacingMap[width].s}`,
	          },
	          [mediaQueryXXL]: {
	            padding: `0 ${spacingMap[width].xxl}`,
	          },
	        }),
	        '&--draggable': {
	          cursor: 'grab',
	          userSelect: 'none',
	          WebkitUserSelect: 'none',
	          WebkitTouchCallout: 'none',
	        },
	      },
	      '&__list': {
	        display: 'flex',
	        ...validateProps.getBackfaceVisibilityJssStyle(),
	      },
	      '&__slide': {
	        flexShrink: 0,
	        ...validateProps.getBackfaceVisibilityJssStyle(),
	        transform: 'translateZ(0)', // fixes mobile safari flickering, https://github.com/nolimits4web/swiper/issues/3527#issuecomment-609088939
	      },
	      '&__sr': validateProps.getHiddenTextJssStyle(), // appears in the DOM when sliding
	    },
	    ...(hasPagination && {
	      'pagination-container': {
	        ...validateProps.buildResponsiveStyles(hasPagination, (hasPaginationValue) => ({
	          display: hasPaginationValue ? 'flex' : 'none',
	        })),
	        position: 'relative',
	        justifyContent: isInfinitePagination ? 'flex-start' : 'center',
	        width: `calc(${paginationActiveBulletSize} + ${paginationBulletSize} * 4 + ${spacingStaticSmall.spacingStaticSmall} * 4)`,
	        left: 'calc(50% - 42px)',
	        overflowX: 'hidden',
	      },
	      pagination: {
	        display: 'flex',
	        alignItems: 'center',
	        width: 'fit-content',
	        height: paginationBulletSize,
	        gap: spacingStaticSmall.spacingStaticSmall,
	        transition: `transform ${carouselTransitionDuration}ms`,
	      },
	      bullet: {
	        borderRadius: borderRadiusSmall.borderRadiusSmall,
	        ...(validateProps.isHighContrastMode
	          ? {
	            background: canvasTextColor,
	          }
	          : {
	            background: contrastMediumColor,
	            ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	              background: contrastMediumColorDark,
	            }),
	          }),
	        ...(isInfinitePagination
	          ? {
	            width: '0px',
	            height: '0px',
	            transition: `background-color ${carouselTransitionDuration}ms, width ${carouselTransitionDuration}ms, height ${carouselTransitionDuration}ms`,
	          }
	          : {
	            width: paginationBulletSize,
	            height: paginationBulletSize,
	            transition: `background-color ${carouselTransitionDuration}ms, width ${carouselTransitionDuration}ms`,
	          }),
	      },
	      ...(isInfinitePagination && {
	        [paginationInfiniteStartCaseClass]: {
	          '& > .bullet:nth-child(-n+4)': {
	            width: paginationBulletSize,
	            height: paginationBulletSize,
	          },
	        },
	        [bulletInfiniteClass]: {
	          // Necessary to override the bulletActiveClass sibling selector
	          ...validateProps.addImportantToEachRule({
	            width: paginationInfiniteBulletSize,
	            height: paginationInfiniteBulletSize,
	          }),
	          '& ~ span': {
	            width: paginationBulletSize,
	            height: paginationBulletSize,
	          },
	          [`& ~ .${bulletInfiniteClass} ~ span`]: {
	            width: '0px',
	            height: '0px',
	          },
	        },
	      }),
	      [bulletActiveClass]: {
	        ...(validateProps.isHighContrastMode
	          ? {
	            background: canvasTextColor,
	          }
	          : {
	            background: primaryColor,
	            ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	              background: primaryColorDark,
	            }),
	          }),
	        height: paginationBulletSize,
	        width: validateProps.addImportantToRule(paginationActiveBulletSize),
	        ...(isInfinitePagination && {
	          '& ~ span': {
	            width: paginationBulletSize,
	            height: paginationBulletSize,
	          },
	          [`& ~ .${bulletInfiniteClass} ~ span`]: {
	            width: '0px',
	            height: '0px',
	          },
	        }),
	      },
	    }),
	  });
	};

	const CAROUSEL_WIDTHS = ['basic', 'extended'];
	const CAROUSEL_ALIGN_HEADERS = ['left', 'center'];
	// The offset value used for calculating the number of infinite bullets
	const INFINITE_BULLET_OFFSET = 2;
	// The total number of infinite bullets including the center bullet
	const INFINITE_BULLET_AMOUNT = INFINITE_BULLET_OFFSET * 2 + 1;
	// Infinite bullets will be shown if the total number of bullets is greater than this value
	const INFINITE_BULLET_THRESHOLD = 5;
	const getSplideBreakpoints = (perPage) => {
	  return typeof perPage === 'object'
	    ? Object.entries(perPage).reduce((result, [key, val]) => ({
	      ...result,
	      [validateProps.breakpoint[key]]: {
	        // round to sanitize floating numbers
	        perPage: Math.round(val),
	      },
	    }), {})
	    : {
	      0: {
	        // round to sanitize floating numbers
	        perPage: perPage === 'auto' ? 1 : Math.round(perPage),
	      },
	    };
	};
	const warnIfHeadingIsMissing = (host, heading) => {
	  if (!heading && !hasNamedSlot.hasNamedSlot(host, 'heading')) {
	    validateProps.consoleWarn(`heading has to be set via property or named slot for component ${validateProps.getTagNameWithoutPrefix(host)} in order to ensure accessibility.`);
	  }
	};
	const getSlidesAndAddAttributes = (host) => {
	  const slides = Array.from(host.children).filter(({ slot }) => slot !== 'heading' && slot !== 'description');
	  slides.forEach((el, i) => {
	    el.setAttribute('slot', `slide-${i}`);
	    el.setAttribute('tabindex', '0');
	  });
	  return slides;
	};
	const getAmountOfPages = (amountOfSlides, slidesPerPage) => {
	  return amountOfSlides === 0 ? 0 : amountOfSlides < slidesPerPage ? 1 : amountOfSlides - slidesPerPage + 1;
	};
	const isFirstPage = (splide) => splide.index === 0;
	const isLastPage = (splide, amountOfPages) => splide.index >= amountOfPages - 1; // catch removal of slide
	const slidePrev = (splide, amountOfPages) => {
	  // sanitize in case of removal of slide since splide.index seems to be from before splide.refresh()
	  const prevSlide = splide.index === amountOfPages ? splide.index - 2 : '<';
	  splide.go(isFirstPage(splide) ? amountOfPages - 1 : prevSlide);
	};
	const slideNext = (splide, amountOfPages) => {
	  splide.go(isLastPage(splide, amountOfPages) ? 0 : '>');
	};
	const updatePrevNextButtons = (btnPrev, btnNext, splide) => {
	  const { i18n, rewind } = splide.options;
	  const isFirst = isFirstPage(splide);
	  btnPrev.disabled = isFirst && !rewind;
	  btnPrev.aria = { 'aria-label': i18n[isFirst ? 'last' : 'prev'] };
	  const isLast = isLastPage(splide, getAmountOfPages(splide.length, splide.options.perPage));
	  btnNext.disabled = isLast && !rewind;
	  btnNext.aria = {
	    'aria-label': i18n[isLast ? 'first' : 'next'],
	  };
	};
	const isInfinitePagination = (amountOfPages) => {
	  return amountOfPages > INFINITE_BULLET_THRESHOLD;
	};
	const renderPagination = (paginationEl, amountOfPages, activeIndex) => {
	  if (paginationEl) {
	    // sanitize in case of removal of slide since activeIndex is from before splide.refresh()
	    activeIndex = activeIndex > amountOfPages - 1 ? amountOfPages - 1 : activeIndex;
	    paginationEl.innerHTML = Array.from(Array(amountOfPages), (_, i) => `<span class="bullet${i === activeIndex ? ' ' + bulletActiveClass : ''}"></span>`).join('');
	    if (isInfinitePagination(amountOfPages)) {
	      updateBulletState(paginationEl, amountOfPages, activeIndex);
	    }
	  }
	};
	const updateBulletState = (paginationEl, amountOfPages, newIndex) => {
	  const isStartCase = newIndex < INFINITE_BULLET_OFFSET;
	  const isEndCase = newIndex > amountOfPages - 1 - INFINITE_BULLET_OFFSET;
	  const infiniteBulletRightIndex = newIndex + INFINITE_BULLET_OFFSET;
	  const infiniteBulletLeftIndex = newIndex - INFINITE_BULLET_OFFSET;
	  const endCaseInfiniteBulletIndex = amountOfPages - INFINITE_BULLET_AMOUNT;
	  const startCaseInfiniteBulletIndex = INFINITE_BULLET_AMOUNT - 1;
	  const isInfiniteBulletLeft = (bulletIndex) => isEndCase ? bulletIndex === endCaseInfiniteBulletIndex : bulletIndex === infiniteBulletLeftIndex;
	  const isInfiniteBulletRight = (bulletIndex) => isStartCase ? bulletIndex === startCaseInfiniteBulletIndex : bulletIndex === infiniteBulletRightIndex;
	  const transformValue = isEndCase ? endCaseInfiniteBulletIndex : Math.max(infiniteBulletLeftIndex, 0);
	  paginationEl.style.transform = `translateX(calc(-${transformValue} * ${paginationBulletSize}))`;
	  // Only update bullets around newIndex
	  for (let i = newIndex - INFINITE_BULLET_AMOUNT - 1; i < newIndex + INFINITE_BULLET_AMOUNT + 1; i++) {
	    const index = (i + amountOfPages) % amountOfPages;
	    paginationEl.children[index].classList.toggle(bulletInfiniteClass, isInfiniteBulletLeft(index) || isInfiniteBulletRight(index));
	  }
	  // Add/Remove class to pagination in order to style the first bullets when the index is in isStartCase
	  paginationEl.classList.toggle(paginationInfiniteStartCaseClass, isStartCase);
	};
	const updatePagination = (paginationEl, amountOfPages, newIndex) => {
	  if (paginationEl) {
	    paginationEl.querySelector('.' + bulletActiveClass).classList.remove(bulletActiveClass);
	    paginationEl.children[newIndex].classList.add(bulletActiveClass);
	    if (isInfinitePagination(amountOfPages)) {
	      updateBulletState(paginationEl, amountOfPages, newIndex);
	    }
	  }
	};

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

	/*!
	 * Splide.js
	 * Version  : 4.1.4
	 * License  : MIT
	 * Copyright: 2022 Naotoshi Fujita
	 */
	var MEDIA_PREFERS_REDUCED_MOTION = "(prefers-reduced-motion: reduce)";
	var CREATED = 1;
	var MOUNTED = 2;
	var IDLE = 3;
	var MOVING = 4;
	var SCROLLING = 5;
	var DRAGGING = 6;
	var DESTROYED = 7;
	var STATES = {
	  CREATED: CREATED,
	  MOUNTED: MOUNTED,
	  IDLE: IDLE,
	  MOVING: MOVING,
	  SCROLLING: SCROLLING,
	  DRAGGING: DRAGGING,
	  DESTROYED: DESTROYED
	};

	function empty(array) {
	  array.length = 0;
	}

	function slice(arrayLike, start, end) {
	  return Array.prototype.slice.call(arrayLike, start, end);
	}

	function apply(func) {
	  return func.bind.apply(func, [null].concat(slice(arguments, 1)));
	}

	var nextTick = setTimeout;

	var noop = function noop() {};

	function raf(func) {
	  return requestAnimationFrame(func);
	}

	function typeOf(type, subject) {
	  return typeof subject === type;
	}

	function isObject(subject) {
	  return !isNull(subject) && typeOf("object", subject);
	}

	var isArray = Array.isArray;
	var isFunction = apply(typeOf, "function");
	var isString = apply(typeOf, "string");
	var isUndefined = apply(typeOf, "undefined");

	function isNull(subject) {
	  return subject === null;
	}

	function isHTMLElement(subject) {
	  try {
	    return subject instanceof (subject.ownerDocument.defaultView || window).HTMLElement;
	  } catch (e) {
	    return false;
	  }
	}

	function toArray(value) {
	  return isArray(value) ? value : [value];
	}

	function forEach(values, iteratee) {
	  toArray(values).forEach(iteratee);
	}

	function includes(array, value) {
	  return array.indexOf(value) > -1;
	}

	function push(array, items) {
	  array.push.apply(array, toArray(items));
	  return array;
	}

	function toggleClass(elm, classes, add) {
	  if (elm) {
	    forEach(classes, function (name) {
	      if (name) {
	        elm.classList[add ? "add" : "remove"](name);
	      }
	    });
	  }
	}

	function addClass(elm, classes) {
	  toggleClass(elm, isString(classes) ? classes.split(" ") : classes, true);
	}

	function append(parent, children) {
	  forEach(children, parent.appendChild.bind(parent));
	}

	function before(nodes, ref) {
	  forEach(nodes, function (node) {
	    var parent = (ref || node).parentNode;

	    if (parent) {
	      parent.insertBefore(node, ref);
	    }
	  });
	}

	function matches(elm, selector) {
	  return isHTMLElement(elm) && (elm["msMatchesSelector"] || elm.matches).call(elm, selector);
	}

	function children(parent, selector) {
	  var children2 = parent ? slice(parent.children) : [];
	  return selector ? children2.filter(function (child) {
	    return matches(child, selector);
	  }) : children2;
	}

	function child(parent, selector) {
	  return selector ? children(parent, selector)[0] : parent.firstElementChild;
	}

	var ownKeys = Object.keys;

	function forOwn(object, iteratee, right) {
	  if (object) {
	    (right ? ownKeys(object).reverse() : ownKeys(object)).forEach(function (key) {
	      key !== "__proto__" && iteratee(object[key], key);
	    });
	  }

	  return object;
	}

	function assign(object) {
	  slice(arguments, 1).forEach(function (source) {
	    forOwn(source, function (value, key) {
	      object[key] = source[key];
	    });
	  });
	  return object;
	}

	function merge(object) {
	  slice(arguments, 1).forEach(function (source) {
	    forOwn(source, function (value, key) {
	      if (isArray(value)) {
	        object[key] = value.slice();
	      } else if (isObject(value)) {
	        object[key] = merge({}, isObject(object[key]) ? object[key] : {}, value);
	      } else {
	        object[key] = value;
	      }
	    });
	  });
	  return object;
	}

	function omit(object, keys) {
	  forEach(keys || ownKeys(object), function (key) {
	    delete object[key];
	  });
	}

	function removeAttribute(elms, attrs) {
	  forEach(elms, function (elm) {
	    forEach(attrs, function (attr) {
	      elm && elm.removeAttribute(attr);
	    });
	  });
	}

	function setAttribute(elms, attrs, value) {
	  if (isObject(attrs)) {
	    forOwn(attrs, function (value2, name) {
	      setAttribute(elms, name, value2);
	    });
	  } else {
	    forEach(elms, function (elm) {
	      isNull(value) || value === "" ? removeAttribute(elm, attrs) : elm.setAttribute(attrs, String(value));
	    });
	  }
	}

	function create(tag, attrs, parent) {
	  var elm = document.createElement(tag);

	  if (attrs) {
	    isString(attrs) ? addClass(elm, attrs) : setAttribute(elm, attrs);
	  }

	  parent && append(parent, elm);
	  return elm;
	}

	function style(elm, prop, value) {
	  if (isUndefined(value)) {
	    return getComputedStyle(elm)[prop];
	  }

	  if (!isNull(value)) {
	    elm.style[prop] = "" + value;
	  }
	}

	function display(elm, display2) {
	  style(elm, "display", display2);
	}

	function focus(elm) {
	  elm["setActive"] && elm["setActive"]() || elm.focus({
	    preventScroll: true
	  });
	}

	function getAttribute(elm, attr) {
	  return elm.getAttribute(attr);
	}

	function hasClass(elm, className) {
	  return elm && elm.classList.contains(className);
	}

	function rect(target) {
	  return target.getBoundingClientRect();
	}

	function remove(nodes) {
	  forEach(nodes, function (node) {
	    if (node && node.parentNode) {
	      node.parentNode.removeChild(node);
	    }
	  });
	}

	function parseHtml(html) {
	  return child(new DOMParser().parseFromString(html, "text/html").body);
	}

	function prevent(e, stopPropagation) {
	  e.preventDefault();

	  if (stopPropagation) {
	    e.stopPropagation();
	    e.stopImmediatePropagation();
	  }
	}

	function query(parent, selector) {
	  return parent && parent.querySelector(selector);
	}

	function queryAll(parent, selector) {
	  return selector ? slice(parent.querySelectorAll(selector)) : [];
	}

	function removeClass(elm, classes) {
	  toggleClass(elm, classes, false);
	}

	function timeOf(e) {
	  return e.timeStamp;
	}

	function unit(value) {
	  return isString(value) ? value : value ? value + "px" : "";
	}

	var PROJECT_CODE = "splide";
	var DATA_ATTRIBUTE = "data-" + PROJECT_CODE;

	function assert(condition, message) {
	  if (!condition) {
	    throw new Error("[" + PROJECT_CODE + "] " + (message || ""));
	  }
	}

	var min = Math.min,
	    max = Math.max,
	    floor = Math.floor,
	    ceil = Math.ceil,
	    abs = Math.abs;

	function approximatelyEqual(x, y, epsilon) {
	  return abs(x - y) < epsilon;
	}

	function between(number, x, y, exclusive) {
	  var minimum = min(x, y);
	  var maximum = max(x, y);
	  return exclusive ? minimum < number && number < maximum : minimum <= number && number <= maximum;
	}

	function clamp(number, x, y) {
	  var minimum = min(x, y);
	  var maximum = max(x, y);
	  return min(max(minimum, number), maximum);
	}

	function sign(x) {
	  return +(x > 0) - +(x < 0);
	}

	function format(string, replacements) {
	  forEach(replacements, function (replacement) {
	    string = string.replace("%s", "" + replacement);
	  });
	  return string;
	}

	function pad(number) {
	  return number < 10 ? "0" + number : "" + number;
	}

	var ids = {};

	function uniqueId(prefix) {
	  return "" + prefix + pad(ids[prefix] = (ids[prefix] || 0) + 1);
	}

	function EventBinder() {
	  var listeners = [];

	  function bind(targets, events, callback, options) {
	    forEachEvent(targets, events, function (target, event, namespace) {
	      var isEventTarget = ("addEventListener" in target);
	      var remover = isEventTarget ? target.removeEventListener.bind(target, event, callback, options) : target["removeListener"].bind(target, callback);
	      isEventTarget ? target.addEventListener(event, callback, options) : target["addListener"](callback);
	      listeners.push([target, event, namespace, callback, remover]);
	    });
	  }

	  function unbind(targets, events, callback) {
	    forEachEvent(targets, events, function (target, event, namespace) {
	      listeners = listeners.filter(function (listener) {
	        if (listener[0] === target && listener[1] === event && listener[2] === namespace && (!callback || listener[3] === callback)) {
	          listener[4]();
	          return false;
	        }

	        return true;
	      });
	    });
	  }

	  function dispatch(target, type, detail) {
	    var e;
	    var bubbles = true;

	    if (typeof CustomEvent === "function") {
	      e = new CustomEvent(type, {
	        bubbles: bubbles,
	        detail: detail
	      });
	    } else {
	      e = document.createEvent("CustomEvent");
	      e.initCustomEvent(type, bubbles, false, detail);
	    }

	    target.dispatchEvent(e);
	    return e;
	  }

	  function forEachEvent(targets, events, iteratee) {
	    forEach(targets, function (target) {
	      target && forEach(events, function (events2) {
	        events2.split(" ").forEach(function (eventNS) {
	          var fragment = eventNS.split(".");
	          iteratee(target, fragment[0], fragment[1]);
	        });
	      });
	    });
	  }

	  function destroy() {
	    listeners.forEach(function (data) {
	      data[4]();
	    });
	    empty(listeners);
	  }

	  return {
	    bind: bind,
	    unbind: unbind,
	    dispatch: dispatch,
	    destroy: destroy
	  };
	}

	var EVENT_MOUNTED = "mounted";
	var EVENT_READY = "ready";
	var EVENT_MOVE = "move";
	var EVENT_MOVED = "moved";
	var EVENT_CLICK = "click";
	var EVENT_ACTIVE = "active";
	var EVENT_INACTIVE = "inactive";
	var EVENT_VISIBLE = "visible";
	var EVENT_HIDDEN = "hidden";
	var EVENT_REFRESH = "refresh";
	var EVENT_UPDATED = "updated";
	var EVENT_RESIZE = "resize";
	var EVENT_RESIZED = "resized";
	var EVENT_DRAG = "drag";
	var EVENT_DRAGGING = "dragging";
	var EVENT_DRAGGED = "dragged";
	var EVENT_SCROLL = "scroll";
	var EVENT_SCROLLED = "scrolled";
	var EVENT_OVERFLOW = "overflow";
	var EVENT_DESTROY = "destroy";
	var EVENT_ARROWS_MOUNTED = "arrows:mounted";
	var EVENT_ARROWS_UPDATED = "arrows:updated";
	var EVENT_PAGINATION_MOUNTED = "pagination:mounted";
	var EVENT_PAGINATION_UPDATED = "pagination:updated";
	var EVENT_NAVIGATION_MOUNTED = "navigation:mounted";
	var EVENT_AUTOPLAY_PLAY = "autoplay:play";
	var EVENT_AUTOPLAY_PLAYING = "autoplay:playing";
	var EVENT_AUTOPLAY_PAUSE = "autoplay:pause";
	var EVENT_LAZYLOAD_LOADED = "lazyload:loaded";
	var EVENT_SLIDE_KEYDOWN = "sk";
	var EVENT_SHIFTED = "sh";
	var EVENT_END_INDEX_CHANGED = "ei";

	function EventInterface(Splide2) {
	  var bus = Splide2 ? Splide2.event.bus : document.createDocumentFragment();
	  var binder = EventBinder();

	  function on(events, callback) {
	    binder.bind(bus, toArray(events).join(" "), function (e) {
	      callback.apply(callback, isArray(e.detail) ? e.detail : []);
	    });
	  }

	  function emit(event) {
	    binder.dispatch(bus, event, slice(arguments, 1));
	  }

	  if (Splide2) {
	    Splide2.event.on(EVENT_DESTROY, binder.destroy);
	  }

	  return assign(binder, {
	    bus: bus,
	    on: on,
	    off: apply(binder.unbind, bus),
	    emit: emit
	  });
	}

	function RequestInterval(interval, onInterval, onUpdate, limit) {
	  var now = Date.now;
	  var startTime;
	  var rate = 0;
	  var id;
	  var paused = true;
	  var count = 0;

	  function update() {
	    if (!paused) {
	      rate = interval ? min((now() - startTime) / interval, 1) : 1;
	      onUpdate && onUpdate(rate);

	      if (rate >= 1) {
	        onInterval();
	        startTime = now();

	        if (limit && ++count >= limit) {
	          return pause();
	        }
	      }

	      id = raf(update);
	    }
	  }

	  function start(resume) {
	    resume || cancel();
	    startTime = now() - (resume ? rate * interval : 0);
	    paused = false;
	    id = raf(update);
	  }

	  function pause() {
	    paused = true;
	  }

	  function rewind() {
	    startTime = now();
	    rate = 0;

	    if (onUpdate) {
	      onUpdate(rate);
	    }
	  }

	  function cancel() {
	    id && cancelAnimationFrame(id);
	    rate = 0;
	    id = 0;
	    paused = true;
	  }

	  function set(time) {
	    interval = time;
	  }

	  function isPaused() {
	    return paused;
	  }

	  return {
	    start: start,
	    rewind: rewind,
	    pause: pause,
	    cancel: cancel,
	    set: set,
	    isPaused: isPaused
	  };
	}

	function State(initialState) {
	  var state = initialState;

	  function set(value) {
	    state = value;
	  }

	  function is(states) {
	    return includes(toArray(states), state);
	  }

	  return {
	    set: set,
	    is: is
	  };
	}

	function Throttle(func, duration) {
	  var interval = RequestInterval(duration || 0, func, null, 1);
	  return function () {
	    interval.isPaused() && interval.start();
	  };
	}

	function Media(Splide2, Components2, options) {
	  var state = Splide2.state;
	  var breakpoints = options.breakpoints || {};
	  var reducedMotion = options.reducedMotion || {};
	  var binder = EventBinder();
	  var queries = [];

	  function setup() {
	    var isMin = options.mediaQuery === "min";
	    ownKeys(breakpoints).sort(function (n, m) {
	      return isMin ? +n - +m : +m - +n;
	    }).forEach(function (key) {
	      register(breakpoints[key], "(" + (isMin ? "min" : "max") + "-width:" + key + "px)");
	    });
	    register(reducedMotion, MEDIA_PREFERS_REDUCED_MOTION);
	    update();
	  }

	  function destroy(completely) {
	    if (completely) {
	      binder.destroy();
	    }
	  }

	  function register(options2, query) {
	    var queryList = matchMedia(query);
	    binder.bind(queryList, "change", update);
	    queries.push([options2, queryList]);
	  }

	  function update() {
	    var destroyed = state.is(DESTROYED);
	    var direction = options.direction;
	    var merged = queries.reduce(function (merged2, entry) {
	      return merge(merged2, entry[1].matches ? entry[0] : {});
	    }, {});
	    omit(options);
	    set(merged);

	    if (options.destroy) {
	      Splide2.destroy(options.destroy === "completely");
	    } else if (destroyed) {
	      destroy(true);
	      Splide2.mount();
	    } else {
	      direction !== options.direction && Splide2.refresh();
	    }
	  }

	  function reduce(enable) {
	    if (matchMedia(MEDIA_PREFERS_REDUCED_MOTION).matches) {
	      enable ? merge(options, reducedMotion) : omit(options, ownKeys(reducedMotion));
	    }
	  }

	  function set(opts, base, notify) {
	    merge(options, opts);
	    base && merge(Object.getPrototypeOf(options), opts);

	    if (notify || !state.is(CREATED)) {
	      Splide2.emit(EVENT_UPDATED, options);
	    }
	  }

	  return {
	    setup: setup,
	    destroy: destroy,
	    reduce: reduce,
	    set: set
	  };
	}

	var ARROW = "Arrow";
	var ARROW_LEFT = ARROW + "Left";
	var ARROW_RIGHT = ARROW + "Right";
	var ARROW_UP = ARROW + "Up";
	var ARROW_DOWN = ARROW + "Down";
	var RTL = "rtl";
	var TTB = "ttb";
	var ORIENTATION_MAP = {
	  width: ["height"],
	  left: ["top", "right"],
	  right: ["bottom", "left"],
	  x: ["y"],
	  X: ["Y"],
	  Y: ["X"],
	  ArrowLeft: [ARROW_UP, ARROW_RIGHT],
	  ArrowRight: [ARROW_DOWN, ARROW_LEFT]
	};

	function Direction(Splide2, Components2, options) {
	  function resolve(prop, axisOnly, direction) {
	    direction = direction || options.direction;
	    var index = direction === RTL && !axisOnly ? 1 : direction === TTB ? 0 : -1;
	    return ORIENTATION_MAP[prop] && ORIENTATION_MAP[prop][index] || prop.replace(/width|left|right/i, function (match, offset) {
	      var replacement = ORIENTATION_MAP[match.toLowerCase()][index] || match;
	      return offset > 0 ? replacement.charAt(0).toUpperCase() + replacement.slice(1) : replacement;
	    });
	  }

	  function orient(value) {
	    return value * (options.direction === RTL ? 1 : -1);
	  }

	  return {
	    resolve: resolve,
	    orient: orient
	  };
	}

	var ROLE = "role";
	var TAB_INDEX = "tabindex";
	var DISABLED = "disabled";
	var ARIA_PREFIX = "aria-";
	var ARIA_CONTROLS = ARIA_PREFIX + "controls";
	var ARIA_CURRENT = ARIA_PREFIX + "current";
	var ARIA_SELECTED = ARIA_PREFIX + "selected";
	var ARIA_LABEL = ARIA_PREFIX + "label";
	var ARIA_LABELLEDBY = ARIA_PREFIX + "labelledby";
	var ARIA_HIDDEN = ARIA_PREFIX + "hidden";
	var ARIA_ORIENTATION = ARIA_PREFIX + "orientation";
	var ARIA_ROLEDESCRIPTION = ARIA_PREFIX + "roledescription";
	var ARIA_LIVE = ARIA_PREFIX + "live";
	var ARIA_BUSY = ARIA_PREFIX + "busy";
	var ARIA_ATOMIC = ARIA_PREFIX + "atomic";
	var ALL_ATTRIBUTES = [ROLE, TAB_INDEX, DISABLED, ARIA_CONTROLS, ARIA_CURRENT, ARIA_LABEL, ARIA_LABELLEDBY, ARIA_HIDDEN, ARIA_ORIENTATION, ARIA_ROLEDESCRIPTION];
	var CLASS_PREFIX = PROJECT_CODE + "__";
	var STATUS_CLASS_PREFIX = "is-";
	var CLASS_ROOT = PROJECT_CODE;
	var CLASS_TRACK = CLASS_PREFIX + "track";
	var CLASS_LIST = CLASS_PREFIX + "list";
	var CLASS_SLIDE = CLASS_PREFIX + "slide";
	var CLASS_CLONE = CLASS_SLIDE + "--clone";
	var CLASS_CONTAINER = CLASS_SLIDE + "__container";
	var CLASS_ARROWS = CLASS_PREFIX + "arrows";
	var CLASS_ARROW = CLASS_PREFIX + "arrow";
	var CLASS_ARROW_PREV = CLASS_ARROW + "--prev";
	var CLASS_ARROW_NEXT = CLASS_ARROW + "--next";
	var CLASS_PAGINATION = CLASS_PREFIX + "pagination";
	var CLASS_PAGINATION_PAGE = CLASS_PAGINATION + "__page";
	var CLASS_PROGRESS = CLASS_PREFIX + "progress";
	var CLASS_PROGRESS_BAR = CLASS_PROGRESS + "__bar";
	var CLASS_TOGGLE = CLASS_PREFIX + "toggle";
	var CLASS_SPINNER = CLASS_PREFIX + "spinner";
	var CLASS_SR = CLASS_PREFIX + "sr";
	var CLASS_INITIALIZED = STATUS_CLASS_PREFIX + "initialized";
	var CLASS_ACTIVE = STATUS_CLASS_PREFIX + "active";
	var CLASS_PREV = STATUS_CLASS_PREFIX + "prev";
	var CLASS_NEXT = STATUS_CLASS_PREFIX + "next";
	var CLASS_VISIBLE = STATUS_CLASS_PREFIX + "visible";
	var CLASS_LOADING = STATUS_CLASS_PREFIX + "loading";
	var CLASS_FOCUS_IN = STATUS_CLASS_PREFIX + "focus-in";
	var CLASS_OVERFLOW = STATUS_CLASS_PREFIX + "overflow";
	var STATUS_CLASSES = [CLASS_ACTIVE, CLASS_VISIBLE, CLASS_PREV, CLASS_NEXT, CLASS_LOADING, CLASS_FOCUS_IN, CLASS_OVERFLOW];
	var CLASSES = {
	  slide: CLASS_SLIDE,
	  clone: CLASS_CLONE,
	  arrows: CLASS_ARROWS,
	  arrow: CLASS_ARROW,
	  prev: CLASS_ARROW_PREV,
	  next: CLASS_ARROW_NEXT,
	  pagination: CLASS_PAGINATION,
	  page: CLASS_PAGINATION_PAGE,
	  spinner: CLASS_SPINNER
	};

	function closest(from, selector) {
	  if (isFunction(from.closest)) {
	    return from.closest(selector);
	  }

	  var elm = from;

	  while (elm && elm.nodeType === 1) {
	    if (matches(elm, selector)) {
	      break;
	    }

	    elm = elm.parentElement;
	  }

	  return elm;
	}

	var FRICTION = 5;
	var LOG_INTERVAL = 200;
	var POINTER_DOWN_EVENTS = "touchstart mousedown";
	var POINTER_MOVE_EVENTS = "touchmove mousemove";
	var POINTER_UP_EVENTS = "touchend touchcancel mouseup click";

	function Elements(Splide2, Components2, options) {
	  var _EventInterface = EventInterface(Splide2),
	      on = _EventInterface.on,
	      bind = _EventInterface.bind;

	  var root = Splide2.root;
	  var i18n = options.i18n;
	  var elements = {};
	  var slides = [];
	  var rootClasses = [];
	  var trackClasses = [];
	  var track;
	  var list;
	  var isUsingKey;

	  function setup() {
	    collect();
	    init();
	    update();
	  }

	  function mount() {
	    on(EVENT_REFRESH, destroy);
	    on(EVENT_REFRESH, setup);
	    on(EVENT_UPDATED, update);
	    bind(document, POINTER_DOWN_EVENTS + " keydown", function (e) {
	      isUsingKey = e.type === "keydown";
	    }, {
	      capture: true
	    });
	    bind(root, "focusin", function () {
	      toggleClass(root, CLASS_FOCUS_IN, !!isUsingKey);
	    });
	  }

	  function destroy(completely) {
	    var attrs = ALL_ATTRIBUTES.concat("style");
	    empty(slides);
	    removeClass(root, rootClasses);
	    removeClass(track, trackClasses);
	    removeAttribute([track, list], attrs);
	    removeAttribute(root, completely ? attrs : ["style", ARIA_ROLEDESCRIPTION]);
	  }

	  function update() {
	    removeClass(root, rootClasses);
	    removeClass(track, trackClasses);
	    rootClasses = getClasses(CLASS_ROOT);
	    trackClasses = getClasses(CLASS_TRACK);
	    addClass(root, rootClasses);
	    addClass(track, trackClasses);
	    setAttribute(root, ARIA_LABEL, options.label);
	    setAttribute(root, ARIA_LABELLEDBY, options.labelledby);
	  }

	  function collect() {
	    track = find("." + CLASS_TRACK);
	    list = child(track, "." + CLASS_LIST);
	    assert(track && list, "A track/list element is missing.");
	    push(slides, children(list, "." + CLASS_SLIDE + ":not(." + CLASS_CLONE + ")"));
	    forOwn({
	      arrows: CLASS_ARROWS,
	      pagination: CLASS_PAGINATION,
	      prev: CLASS_ARROW_PREV,
	      next: CLASS_ARROW_NEXT,
	      bar: CLASS_PROGRESS_BAR,
	      toggle: CLASS_TOGGLE
	    }, function (className, key) {
	      elements[key] = find("." + className);
	    });
	    assign(elements, {
	      root: root,
	      track: track,
	      list: list,
	      slides: slides
	    });
	  }

	  function init() {
	    var id = root.id || uniqueId(PROJECT_CODE);
	    var role = options.role;
	    root.id = id;
	    track.id = track.id || id + "-track";
	    list.id = list.id || id + "-list";

	    if (!getAttribute(root, ROLE) && root.tagName !== "SECTION" && role) {
	      setAttribute(root, ROLE, role);
	    }

	    setAttribute(root, ARIA_ROLEDESCRIPTION, i18n.carousel);
	    setAttribute(list, ROLE, "presentation");
	  }

	  function find(selector) {
	    var elm = query(root, selector);
	    return elm && closest(elm, "." + CLASS_ROOT) === root ? elm : void 0;
	  }

	  function getClasses(base) {
	    return [base + "--" + options.type, base + "--" + options.direction, options.drag && base + "--draggable", options.isNavigation && base + "--nav", base === CLASS_ROOT && CLASS_ACTIVE];
	  }

	  return assign(elements, {
	    setup: setup,
	    mount: mount,
	    destroy: destroy
	  });
	}

	var SLIDE = "slide";
	var LOOP = "loop";
	var FADE = "fade";

	function Slide$1(Splide2, index, slideIndex, slide) {
	  var event = EventInterface(Splide2);
	  var on = event.on,
	      emit = event.emit,
	      bind = event.bind;
	  var Components = Splide2.Components,
	      root = Splide2.root,
	      options = Splide2.options;
	  var isNavigation = options.isNavigation,
	      updateOnMove = options.updateOnMove,
	      i18n = options.i18n,
	      pagination = options.pagination,
	      slideFocus = options.slideFocus;
	  var resolve = Components.Direction.resolve;
	  var styles = getAttribute(slide, "style");
	  var label = getAttribute(slide, ARIA_LABEL);
	  var isClone = slideIndex > -1;
	  var container = child(slide, "." + CLASS_CONTAINER);
	  var destroyed;

	  function mount() {
	    if (!isClone) {
	      slide.id = root.id + "-slide" + pad(index + 1);
	      setAttribute(slide, ROLE, pagination ? "tabpanel" : "group");
	      setAttribute(slide, ARIA_ROLEDESCRIPTION, i18n.slide);
	      setAttribute(slide, ARIA_LABEL, label || format(i18n.slideLabel, [index + 1, Splide2.length]));
	    }

	    listen();
	  }

	  function listen() {
	    bind(slide, "click", apply(emit, EVENT_CLICK, self));
	    bind(slide, "keydown", apply(emit, EVENT_SLIDE_KEYDOWN, self));
	    on([EVENT_MOVED, EVENT_SHIFTED, EVENT_SCROLLED], update);
	    on(EVENT_NAVIGATION_MOUNTED, initNavigation);

	    if (updateOnMove) {
	      on(EVENT_MOVE, onMove);
	    }
	  }

	  function destroy() {
	    destroyed = true;
	    event.destroy();
	    removeClass(slide, STATUS_CLASSES);
	    removeAttribute(slide, ALL_ATTRIBUTES);
	    setAttribute(slide, "style", styles);
	    setAttribute(slide, ARIA_LABEL, label || "");
	  }

	  function initNavigation() {
	    var controls = Splide2.splides.map(function (target) {
	      var Slide2 = target.splide.Components.Slides.getAt(index);
	      return Slide2 ? Slide2.slide.id : "";
	    }).join(" ");
	    setAttribute(slide, ARIA_LABEL, format(i18n.slideX, (isClone ? slideIndex : index) + 1));
	    setAttribute(slide, ARIA_CONTROLS, controls);
	    setAttribute(slide, ROLE, slideFocus ? "button" : "");
	    slideFocus && removeAttribute(slide, ARIA_ROLEDESCRIPTION);
	  }

	  function onMove() {
	    if (!destroyed) {
	      update();
	    }
	  }

	  function update() {
	    if (!destroyed) {
	      var curr = Splide2.index;
	      updateActivity();
	      updateVisibility();
	      toggleClass(slide, CLASS_PREV, index === curr - 1);
	      toggleClass(slide, CLASS_NEXT, index === curr + 1);
	    }
	  }

	  function updateActivity() {
	    var active = isActive();

	    if (active !== hasClass(slide, CLASS_ACTIVE)) {
	      toggleClass(slide, CLASS_ACTIVE, active);
	      setAttribute(slide, ARIA_CURRENT, isNavigation && active || "");
	      emit(active ? EVENT_ACTIVE : EVENT_INACTIVE, self);
	    }
	  }

	  function updateVisibility() {
	    var visible = isVisible();
	    var hidden = !visible && (!isActive() || isClone);

	    if (!Splide2.state.is([MOVING, SCROLLING])) {
	      setAttribute(slide, ARIA_HIDDEN, hidden || "");
	    }

	    setAttribute(queryAll(slide, options.focusableNodes || ""), TAB_INDEX, hidden ? -1 : "");

	    if (slideFocus) {
	      setAttribute(slide, TAB_INDEX, hidden ? -1 : 0);
	    }

	    if (visible !== hasClass(slide, CLASS_VISIBLE)) {
	      toggleClass(slide, CLASS_VISIBLE, visible);
	      emit(visible ? EVENT_VISIBLE : EVENT_HIDDEN, self);
	    }

	    if (!visible && document.activeElement === slide) {
	      var Slide2 = Components.Slides.getAt(Splide2.index);
	      Slide2 && focus(Slide2.slide);
	    }
	  }

	  function style$1(prop, value, useContainer) {
	    style(useContainer && container || slide, prop, value);
	  }

	  function isActive() {
	    var curr = Splide2.index;
	    return curr === index || options.cloneStatus && curr === slideIndex;
	  }

	  function isVisible() {
	    if (Splide2.is(FADE)) {
	      return isActive();
	    }

	    var trackRect = rect(Components.Elements.track);
	    var slideRect = rect(slide);
	    var left = resolve("left", true);
	    var right = resolve("right", true);
	    return floor(trackRect[left]) <= ceil(slideRect[left]) && floor(slideRect[right]) <= ceil(trackRect[right]);
	  }

	  function isWithin(from, distance) {
	    var diff = abs(from - index);

	    if (!isClone && (options.rewind || Splide2.is(LOOP))) {
	      diff = min(diff, Splide2.length - diff);
	    }

	    return diff <= distance;
	  }

	  var self = {
	    index: index,
	    slideIndex: slideIndex,
	    slide: slide,
	    container: container,
	    isClone: isClone,
	    mount: mount,
	    destroy: destroy,
	    update: update,
	    style: style$1,
	    isWithin: isWithin
	  };
	  return self;
	}

	function Slides(Splide2, Components2, options) {
	  var _EventInterface2 = EventInterface(Splide2),
	      on = _EventInterface2.on,
	      emit = _EventInterface2.emit,
	      bind = _EventInterface2.bind;

	  var _Components2$Elements = Components2.Elements,
	      slides = _Components2$Elements.slides,
	      list = _Components2$Elements.list;
	  var Slides2 = [];

	  function mount() {
	    init();
	    on(EVENT_REFRESH, destroy);
	    on(EVENT_REFRESH, init);
	  }

	  function init() {
	    slides.forEach(function (slide, index) {
	      register(slide, index, -1);
	    });
	  }

	  function destroy() {
	    forEach$1(function (Slide2) {
	      Slide2.destroy();
	    });
	    empty(Slides2);
	  }

	  function update() {
	    forEach$1(function (Slide2) {
	      Slide2.update();
	    });
	  }

	  function register(slide, index, slideIndex) {
	    var object = Slide$1(Splide2, index, slideIndex, slide);
	    object.mount();
	    Slides2.push(object);
	    Slides2.sort(function (Slide1, Slide2) {
	      return Slide1.index - Slide2.index;
	    });
	  }

	  function get(excludeClones) {
	    return excludeClones ? filter(function (Slide2) {
	      return !Slide2.isClone;
	    }) : Slides2;
	  }

	  function getIn(page) {
	    var Controller = Components2.Controller;
	    var index = Controller.toIndex(page);
	    var max = Controller.hasFocus() ? 1 : options.perPage;
	    return filter(function (Slide2) {
	      return between(Slide2.index, index, index + max - 1);
	    });
	  }

	  function getAt(index) {
	    return filter(index)[0];
	  }

	  function add(items, index) {
	    forEach(items, function (slide) {
	      if (isString(slide)) {
	        slide = parseHtml(slide);
	      }

	      if (isHTMLElement(slide)) {
	        var ref = slides[index];
	        ref ? before(slide, ref) : append(list, slide);
	        addClass(slide, options.classes.slide);
	        observeImages(slide, apply(emit, EVENT_RESIZE));
	      }
	    });
	    emit(EVENT_REFRESH);
	  }

	  function remove$1(matcher) {
	    remove(filter(matcher).map(function (Slide2) {
	      return Slide2.slide;
	    }));
	    emit(EVENT_REFRESH);
	  }

	  function forEach$1(iteratee, excludeClones) {
	    get(excludeClones).forEach(iteratee);
	  }

	  function filter(matcher) {
	    return Slides2.filter(isFunction(matcher) ? matcher : function (Slide2) {
	      return isString(matcher) ? matches(Slide2.slide, matcher) : includes(toArray(matcher), Slide2.index);
	    });
	  }

	  function style(prop, value, useContainer) {
	    forEach$1(function (Slide2) {
	      Slide2.style(prop, value, useContainer);
	    });
	  }

	  function observeImages(elm, callback) {
	    var images = queryAll(elm, "img");
	    var length = images.length;

	    if (length) {
	      images.forEach(function (img) {
	        bind(img, "load error", function () {
	          if (! --length) {
	            callback();
	          }
	        });
	      });
	    } else {
	      callback();
	    }
	  }

	  function getLength(excludeClones) {
	    return excludeClones ? slides.length : Slides2.length;
	  }

	  function isEnough() {
	    return Slides2.length > options.perPage;
	  }

	  return {
	    mount: mount,
	    destroy: destroy,
	    update: update,
	    register: register,
	    get: get,
	    getIn: getIn,
	    getAt: getAt,
	    add: add,
	    remove: remove$1,
	    forEach: forEach$1,
	    filter: filter,
	    style: style,
	    getLength: getLength,
	    isEnough: isEnough
	  };
	}

	function Layout(Splide2, Components2, options) {
	  var _EventInterface3 = EventInterface(Splide2),
	      on = _EventInterface3.on,
	      bind = _EventInterface3.bind,
	      emit = _EventInterface3.emit;

	  var Slides = Components2.Slides;
	  var resolve = Components2.Direction.resolve;
	  var _Components2$Elements2 = Components2.Elements,
	      root = _Components2$Elements2.root,
	      track = _Components2$Elements2.track,
	      list = _Components2$Elements2.list;
	  var getAt = Slides.getAt,
	      styleSlides = Slides.style;
	  var vertical;
	  var rootRect;
	  var overflow;

	  function mount() {
	    init();
	    bind(window, "resize load", Throttle(apply(emit, EVENT_RESIZE)));
	    on([EVENT_UPDATED, EVENT_REFRESH], init);
	    on(EVENT_RESIZE, resize);
	  }

	  function init() {
	    vertical = options.direction === TTB;
	    style(root, "maxWidth", unit(options.width));
	    style(track, resolve("paddingLeft"), cssPadding(false));
	    style(track, resolve("paddingRight"), cssPadding(true));
	    resize(true);
	  }

	  function resize(force) {
	    var newRect = rect(root);

	    if (force || rootRect.width !== newRect.width || rootRect.height !== newRect.height) {
	      style(track, "height", cssTrackHeight());
	      styleSlides(resolve("marginRight"), unit(options.gap));
	      styleSlides("width", cssSlideWidth());
	      styleSlides("height", cssSlideHeight(), true);
	      rootRect = newRect;
	      emit(EVENT_RESIZED);

	      if (overflow !== (overflow = isOverflow())) {
	        toggleClass(root, CLASS_OVERFLOW, overflow);
	        emit(EVENT_OVERFLOW, overflow);
	      }
	    }
	  }

	  function cssPadding(right) {
	    var padding = options.padding;
	    var prop = resolve(right ? "right" : "left");
	    return padding && unit(padding[prop] || (isObject(padding) ? 0 : padding)) || "0px";
	  }

	  function cssTrackHeight() {
	    var height = "";

	    if (vertical) {
	      height = cssHeight();
	      assert(height, "height or heightRatio is missing.");
	      height = "calc(" + height + " - " + cssPadding(false) + " - " + cssPadding(true) + ")";
	    }

	    return height;
	  }

	  function cssHeight() {
	    return unit(options.height || rect(list).width * options.heightRatio);
	  }

	  function cssSlideWidth() {
	    return options.autoWidth ? null : unit(options.fixedWidth) || (vertical ? "" : cssSlideSize());
	  }

	  function cssSlideHeight() {
	    return unit(options.fixedHeight) || (vertical ? options.autoHeight ? null : cssSlideSize() : cssHeight());
	  }

	  function cssSlideSize() {
	    var gap = unit(options.gap);
	    return "calc((100%" + (gap && " + " + gap) + ")/" + (options.perPage || 1) + (gap && " - " + gap) + ")";
	  }

	  function listSize() {
	    return rect(list)[resolve("width")];
	  }

	  function slideSize(index, withoutGap) {
	    var Slide = getAt(index || 0);
	    return Slide ? rect(Slide.slide)[resolve("width")] + (withoutGap ? 0 : getGap()) : 0;
	  }

	  function totalSize(index, withoutGap) {
	    var Slide = getAt(index);

	    if (Slide) {
	      var right = rect(Slide.slide)[resolve("right")];
	      var left = rect(list)[resolve("left")];
	      return abs(right - left) + (withoutGap ? 0 : getGap());
	    }

	    return 0;
	  }

	  function sliderSize(withoutGap) {
	    return totalSize(Splide2.length - 1) - totalSize(0) + slideSize(0, withoutGap);
	  }

	  function getGap() {
	    var Slide = getAt(0);
	    return Slide && parseFloat(style(Slide.slide, resolve("marginRight"))) || 0;
	  }

	  function getPadding(right) {
	    return parseFloat(style(track, resolve("padding" + (right ? "Right" : "Left")))) || 0;
	  }

	  function isOverflow() {
	    return Splide2.is(FADE) || sliderSize(true) > listSize();
	  }

	  return {
	    mount: mount,
	    resize: resize,
	    listSize: listSize,
	    slideSize: slideSize,
	    sliderSize: sliderSize,
	    totalSize: totalSize,
	    getPadding: getPadding,
	    isOverflow: isOverflow
	  };
	}

	var MULTIPLIER = 2;

	function Clones(Splide2, Components2, options) {
	  var event = EventInterface(Splide2);
	  var on = event.on;
	  var Elements = Components2.Elements,
	      Slides = Components2.Slides;
	  var resolve = Components2.Direction.resolve;
	  var clones = [];
	  var cloneCount;

	  function mount() {
	    on(EVENT_REFRESH, remount);
	    on([EVENT_UPDATED, EVENT_RESIZE], observe);

	    if (cloneCount = computeCloneCount()) {
	      generate(cloneCount);
	      Components2.Layout.resize(true);
	    }
	  }

	  function remount() {
	    destroy();
	    mount();
	  }

	  function destroy() {
	    remove(clones);
	    empty(clones);
	    event.destroy();
	  }

	  function observe() {
	    var count = computeCloneCount();

	    if (cloneCount !== count) {
	      if (cloneCount < count || !count) {
	        event.emit(EVENT_REFRESH);
	      }
	    }
	  }

	  function generate(count) {
	    var slides = Slides.get().slice();
	    var length = slides.length;

	    if (length) {
	      while (slides.length < count) {
	        push(slides, slides);
	      }

	      push(slides.slice(-count), slides.slice(0, count)).forEach(function (Slide, index) {
	        var isHead = index < count;
	        var clone = cloneDeep(Slide.slide, index);
	        isHead ? before(clone, slides[0].slide) : append(Elements.list, clone);
	        push(clones, clone);
	        Slides.register(clone, index - count + (isHead ? 0 : length), Slide.index);
	      });
	    }
	  }

	  function cloneDeep(elm, index) {
	    var clone = elm.cloneNode(true);
	    addClass(clone, options.classes.clone);
	    clone.id = Splide2.root.id + "-clone" + pad(index + 1);
	    return clone;
	  }

	  function computeCloneCount() {
	    var clones2 = options.clones;

	    if (!Splide2.is(LOOP)) {
	      clones2 = 0;
	    } else if (isUndefined(clones2)) {
	      var fixedSize = options[resolve("fixedWidth")] && Components2.Layout.slideSize(0);
	      var fixedCount = fixedSize && ceil(rect(Elements.track)[resolve("width")] / fixedSize);
	      clones2 = fixedCount || options[resolve("autoWidth")] && Splide2.length || options.perPage * MULTIPLIER;
	    }

	    return clones2;
	  }

	  return {
	    mount: mount,
	    destroy: destroy
	  };
	}

	function Move(Splide2, Components2, options) {
	  var _EventInterface4 = EventInterface(Splide2),
	      on = _EventInterface4.on,
	      emit = _EventInterface4.emit;

	  var set = Splide2.state.set;
	  var _Components2$Layout = Components2.Layout,
	      slideSize = _Components2$Layout.slideSize,
	      getPadding = _Components2$Layout.getPadding,
	      totalSize = _Components2$Layout.totalSize,
	      listSize = _Components2$Layout.listSize,
	      sliderSize = _Components2$Layout.sliderSize;
	  var _Components2$Directio = Components2.Direction,
	      resolve = _Components2$Directio.resolve,
	      orient = _Components2$Directio.orient;
	  var _Components2$Elements3 = Components2.Elements,
	      list = _Components2$Elements3.list,
	      track = _Components2$Elements3.track;
	  var Transition;

	  function mount() {
	    Transition = Components2.Transition;
	    on([EVENT_MOUNTED, EVENT_RESIZED, EVENT_UPDATED, EVENT_REFRESH], reposition);
	  }

	  function reposition() {
	    if (!Components2.Controller.isBusy()) {
	      Components2.Scroll.cancel();
	      jump(Splide2.index);
	      Components2.Slides.update();
	    }
	  }

	  function move(dest, index, prev, callback) {
	    if (dest !== index && canShift(dest > prev)) {
	      cancel();
	      translate(shift(getPosition(), dest > prev), true);
	    }

	    set(MOVING);
	    emit(EVENT_MOVE, index, prev, dest);
	    Transition.start(index, function () {
	      set(IDLE);
	      emit(EVENT_MOVED, index, prev, dest);
	      callback && callback();
	    });
	  }

	  function jump(index) {
	    translate(toPosition(index, true));
	  }

	  function translate(position, preventLoop) {
	    if (!Splide2.is(FADE)) {
	      var destination = preventLoop ? position : loop(position);
	      style(list, "transform", "translate" + resolve("X") + "(" + destination + "px)");
	      position !== destination && emit(EVENT_SHIFTED);
	    }
	  }

	  function loop(position) {
	    if (Splide2.is(LOOP)) {
	      var index = toIndex(position);
	      var exceededMax = index > Components2.Controller.getEnd();
	      var exceededMin = index < 0;

	      if (exceededMin || exceededMax) {
	        position = shift(position, exceededMax);
	      }
	    }

	    return position;
	  }

	  function shift(position, backwards) {
	    var excess = position - getLimit(backwards);
	    var size = sliderSize();
	    position -= orient(size * (ceil(abs(excess) / size) || 1)) * (backwards ? 1 : -1);
	    return position;
	  }

	  function cancel() {
	    translate(getPosition(), true);
	    Transition.cancel();
	  }

	  function toIndex(position) {
	    var Slides = Components2.Slides.get();
	    var index = 0;
	    var minDistance = Infinity;

	    for (var i = 0; i < Slides.length; i++) {
	      var slideIndex = Slides[i].index;
	      var distance = abs(toPosition(slideIndex, true) - position);

	      if (distance <= minDistance) {
	        minDistance = distance;
	        index = slideIndex;
	      } else {
	        break;
	      }
	    }

	    return index;
	  }

	  function toPosition(index, trimming) {
	    var position = orient(totalSize(index - 1) - offset(index));
	    return trimming ? trim(position) : position;
	  }

	  function getPosition() {
	    var left = resolve("left");
	    return rect(list)[left] - rect(track)[left] + orient(getPadding(false));
	  }

	  function trim(position) {
	    if (options.trimSpace && Splide2.is(SLIDE)) {
	      position = clamp(position, 0, orient(sliderSize(true) - listSize()));
	    }

	    return position;
	  }

	  function offset(index) {
	    var focus = options.focus;
	    return focus === "center" ? (listSize() - slideSize(index, true)) / 2 : +focus * slideSize(index) || 0;
	  }

	  function getLimit(max) {
	    return toPosition(max ? Components2.Controller.getEnd() : 0, !!options.trimSpace);
	  }

	  function canShift(backwards) {
	    var shifted = orient(shift(getPosition(), backwards));
	    return backwards ? shifted >= 0 : shifted <= list[resolve("scrollWidth")] - rect(track)[resolve("width")];
	  }

	  function exceededLimit(max, position) {
	    position = isUndefined(position) ? getPosition() : position;
	    var exceededMin = max !== true && orient(position) < orient(getLimit(false));
	    var exceededMax = max !== false && orient(position) > orient(getLimit(true));
	    return exceededMin || exceededMax;
	  }

	  return {
	    mount: mount,
	    move: move,
	    jump: jump,
	    translate: translate,
	    shift: shift,
	    cancel: cancel,
	    toIndex: toIndex,
	    toPosition: toPosition,
	    getPosition: getPosition,
	    getLimit: getLimit,
	    exceededLimit: exceededLimit,
	    reposition: reposition
	  };
	}

	function Controller(Splide2, Components2, options) {
	  var _EventInterface5 = EventInterface(Splide2),
	      on = _EventInterface5.on,
	      emit = _EventInterface5.emit;

	  var Move = Components2.Move;
	  var getPosition = Move.getPosition,
	      getLimit = Move.getLimit,
	      toPosition = Move.toPosition;
	  var _Components2$Slides = Components2.Slides,
	      isEnough = _Components2$Slides.isEnough,
	      getLength = _Components2$Slides.getLength;
	  var omitEnd = options.omitEnd;
	  var isLoop = Splide2.is(LOOP);
	  var isSlide = Splide2.is(SLIDE);
	  var getNext = apply(getAdjacent, false);
	  var getPrev = apply(getAdjacent, true);
	  var currIndex = options.start || 0;
	  var endIndex;
	  var prevIndex = currIndex;
	  var slideCount;
	  var perMove;
	  var perPage;

	  function mount() {
	    init();
	    on([EVENT_UPDATED, EVENT_REFRESH, EVENT_END_INDEX_CHANGED], init);
	    on(EVENT_RESIZED, onResized);
	  }

	  function init() {
	    slideCount = getLength(true);
	    perMove = options.perMove;
	    perPage = options.perPage;
	    endIndex = getEnd();
	    var index = clamp(currIndex, 0, omitEnd ? endIndex : slideCount - 1);

	    if (index !== currIndex) {
	      currIndex = index;
	      Move.reposition();
	    }
	  }

	  function onResized() {
	    if (endIndex !== getEnd()) {
	      emit(EVENT_END_INDEX_CHANGED);
	    }
	  }

	  function go(control, allowSameIndex, callback) {
	    if (!isBusy()) {
	      var dest = parse(control);
	      var index = loop(dest);

	      if (index > -1 && (allowSameIndex || index !== currIndex)) {
	        setIndex(index);
	        Move.move(dest, index, prevIndex, callback);
	      }
	    }
	  }

	  function scroll(destination, duration, snap, callback) {
	    Components2.Scroll.scroll(destination, duration, snap, function () {
	      var index = loop(Move.toIndex(getPosition()));
	      setIndex(omitEnd ? min(index, endIndex) : index);
	      callback && callback();
	    });
	  }

	  function parse(control) {
	    var index = currIndex;

	    if (isString(control)) {
	      var _ref = control.match(/([+\-<>])(\d+)?/) || [],
	          indicator = _ref[1],
	          number = _ref[2];

	      if (indicator === "+" || indicator === "-") {
	        index = computeDestIndex(currIndex + +("" + indicator + (+number || 1)), currIndex);
	      } else if (indicator === ">") {
	        index = number ? toIndex(+number) : getNext(true);
	      } else if (indicator === "<") {
	        index = getPrev(true);
	      }
	    } else {
	      index = isLoop ? control : clamp(control, 0, endIndex);
	    }

	    return index;
	  }

	  function getAdjacent(prev, destination) {
	    var number = perMove || (hasFocus() ? 1 : perPage);
	    var dest = computeDestIndex(currIndex + number * (prev ? -1 : 1), currIndex, !(perMove || hasFocus()));

	    if (dest === -1 && isSlide) {
	      if (!approximatelyEqual(getPosition(), getLimit(!prev), 1)) {
	        return prev ? 0 : endIndex;
	      }
	    }

	    return destination ? dest : loop(dest);
	  }

	  function computeDestIndex(dest, from, snapPage) {
	    if (isEnough() || hasFocus()) {
	      var index = computeMovableDestIndex(dest);

	      if (index !== dest) {
	        from = dest;
	        dest = index;
	        snapPage = false;
	      }

	      if (dest < 0 || dest > endIndex) {
	        if (!perMove && (between(0, dest, from, true) || between(endIndex, from, dest, true))) {
	          dest = toIndex(toPage(dest));
	        } else {
	          if (isLoop) {
	            dest = snapPage ? dest < 0 ? -(slideCount % perPage || perPage) : slideCount : dest;
	          } else if (options.rewind) {
	            dest = dest < 0 ? endIndex : 0;
	          } else {
	            dest = -1;
	          }
	        }
	      } else {
	        if (snapPage && dest !== from) {
	          dest = toIndex(toPage(from) + (dest < from ? -1 : 1));
	        }
	      }
	    } else {
	      dest = -1;
	    }

	    return dest;
	  }

	  function computeMovableDestIndex(dest) {
	    if (isSlide && options.trimSpace === "move" && dest !== currIndex) {
	      var position = getPosition();

	      while (position === toPosition(dest, true) && between(dest, 0, Splide2.length - 1, !options.rewind)) {
	        dest < currIndex ? --dest : ++dest;
	      }
	    }

	    return dest;
	  }

	  function loop(index) {
	    return isLoop ? (index + slideCount) % slideCount || 0 : index;
	  }

	  function getEnd() {
	    var end = slideCount - (hasFocus() || isLoop && perMove ? 1 : perPage);

	    while (omitEnd && end-- > 0) {
	      if (toPosition(slideCount - 1, true) !== toPosition(end, true)) {
	        end++;
	        break;
	      }
	    }

	    return clamp(end, 0, slideCount - 1);
	  }

	  function toIndex(page) {
	    return clamp(hasFocus() ? page : perPage * page, 0, endIndex);
	  }

	  function toPage(index) {
	    return hasFocus() ? min(index, endIndex) : floor((index >= endIndex ? slideCount - 1 : index) / perPage);
	  }

	  function toDest(destination) {
	    var closest = Move.toIndex(destination);
	    return isSlide ? clamp(closest, 0, endIndex) : closest;
	  }

	  function setIndex(index) {
	    if (index !== currIndex) {
	      prevIndex = currIndex;
	      currIndex = index;
	    }
	  }

	  function getIndex(prev) {
	    return prev ? prevIndex : currIndex;
	  }

	  function hasFocus() {
	    return !isUndefined(options.focus) || options.isNavigation;
	  }

	  function isBusy() {
	    return Splide2.state.is([MOVING, SCROLLING]) && !!options.waitForTransition;
	  }

	  return {
	    mount: mount,
	    go: go,
	    scroll: scroll,
	    getNext: getNext,
	    getPrev: getPrev,
	    getAdjacent: getAdjacent,
	    getEnd: getEnd,
	    setIndex: setIndex,
	    getIndex: getIndex,
	    toIndex: toIndex,
	    toPage: toPage,
	    toDest: toDest,
	    hasFocus: hasFocus,
	    isBusy: isBusy
	  };
	}

	var XML_NAME_SPACE = "http://www.w3.org/2000/svg";
	var PATH = "m15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z";
	var SIZE = 40;

	function Arrows(Splide2, Components2, options) {
	  var event = EventInterface(Splide2);
	  var on = event.on,
	      bind = event.bind,
	      emit = event.emit;
	  var classes = options.classes,
	      i18n = options.i18n;
	  var Elements = Components2.Elements,
	      Controller = Components2.Controller;
	  var placeholder = Elements.arrows,
	      track = Elements.track;
	  var wrapper = placeholder;
	  var prev = Elements.prev;
	  var next = Elements.next;
	  var created;
	  var wrapperClasses;
	  var arrows = {};

	  function mount() {
	    init();
	    on(EVENT_UPDATED, remount);
	  }

	  function remount() {
	    destroy();
	    mount();
	  }

	  function init() {
	    var enabled = options.arrows;

	    if (enabled && !(prev && next)) {
	      createArrows();
	    }

	    if (prev && next) {
	      assign(arrows, {
	        prev: prev,
	        next: next
	      });
	      display(wrapper, enabled ? "" : "none");
	      addClass(wrapper, wrapperClasses = CLASS_ARROWS + "--" + options.direction);

	      if (enabled) {
	        listen();
	        update();
	        setAttribute([prev, next], ARIA_CONTROLS, track.id);
	        emit(EVENT_ARROWS_MOUNTED, prev, next);
	      }
	    }
	  }

	  function destroy() {
	    event.destroy();
	    removeClass(wrapper, wrapperClasses);

	    if (created) {
	      remove(placeholder ? [prev, next] : wrapper);
	      prev = next = null;
	    } else {
	      removeAttribute([prev, next], ALL_ATTRIBUTES);
	    }
	  }

	  function listen() {
	    on([EVENT_MOUNTED, EVENT_MOVED, EVENT_REFRESH, EVENT_SCROLLED, EVENT_END_INDEX_CHANGED], update);
	    bind(next, "click", apply(go, ">"));
	    bind(prev, "click", apply(go, "<"));
	  }

	  function go(control) {
	    Controller.go(control, true);
	  }

	  function createArrows() {
	    wrapper = placeholder || create("div", classes.arrows);
	    prev = createArrow(true);
	    next = createArrow(false);
	    created = true;
	    append(wrapper, [prev, next]);
	    !placeholder && before(wrapper, track);
	  }

	  function createArrow(prev2) {
	    var arrow = "<button class=\"" + classes.arrow + " " + (prev2 ? classes.prev : classes.next) + "\" type=\"button\"><svg xmlns=\"" + XML_NAME_SPACE + "\" viewBox=\"0 0 " + SIZE + " " + SIZE + "\" width=\"" + SIZE + "\" height=\"" + SIZE + "\" focusable=\"false\"><path d=\"" + (options.arrowPath || PATH) + "\" />";
	    return parseHtml(arrow);
	  }

	  function update() {
	    if (prev && next) {
	      var index = Splide2.index;
	      var prevIndex = Controller.getPrev();
	      var nextIndex = Controller.getNext();
	      var prevLabel = prevIndex > -1 && index < prevIndex ? i18n.last : i18n.prev;
	      var nextLabel = nextIndex > -1 && index > nextIndex ? i18n.first : i18n.next;
	      prev.disabled = prevIndex < 0;
	      next.disabled = nextIndex < 0;
	      setAttribute(prev, ARIA_LABEL, prevLabel);
	      setAttribute(next, ARIA_LABEL, nextLabel);
	      emit(EVENT_ARROWS_UPDATED, prev, next, prevIndex, nextIndex);
	    }
	  }

	  return {
	    arrows: arrows,
	    mount: mount,
	    destroy: destroy,
	    update: update
	  };
	}

	var INTERVAL_DATA_ATTRIBUTE = DATA_ATTRIBUTE + "-interval";

	function Autoplay(Splide2, Components2, options) {
	  var _EventInterface6 = EventInterface(Splide2),
	      on = _EventInterface6.on,
	      bind = _EventInterface6.bind,
	      emit = _EventInterface6.emit;

	  var interval = RequestInterval(options.interval, Splide2.go.bind(Splide2, ">"), onAnimationFrame);
	  var isPaused = interval.isPaused;
	  var Elements = Components2.Elements,
	      _Components2$Elements4 = Components2.Elements,
	      root = _Components2$Elements4.root,
	      toggle = _Components2$Elements4.toggle;
	  var autoplay = options.autoplay;
	  var hovered;
	  var focused;
	  var stopped = autoplay === "pause";

	  function mount() {
	    if (autoplay) {
	      listen();
	      toggle && setAttribute(toggle, ARIA_CONTROLS, Elements.track.id);
	      stopped || play();
	      update();
	    }
	  }

	  function listen() {
	    if (options.pauseOnHover) {
	      bind(root, "mouseenter mouseleave", function (e) {
	        hovered = e.type === "mouseenter";
	        autoToggle();
	      });
	    }

	    if (options.pauseOnFocus) {
	      bind(root, "focusin focusout", function (e) {
	        focused = e.type === "focusin";
	        autoToggle();
	      });
	    }

	    if (toggle) {
	      bind(toggle, "click", function () {
	        stopped ? play() : pause(true);
	      });
	    }

	    on([EVENT_MOVE, EVENT_SCROLL, EVENT_REFRESH], interval.rewind);
	    on(EVENT_MOVE, onMove);
	  }

	  function play() {
	    if (isPaused() && Components2.Slides.isEnough()) {
	      interval.start(!options.resetProgress);
	      focused = hovered = stopped = false;
	      update();
	      emit(EVENT_AUTOPLAY_PLAY);
	    }
	  }

	  function pause(stop) {
	    if (stop === void 0) {
	      stop = true;
	    }

	    stopped = !!stop;
	    update();

	    if (!isPaused()) {
	      interval.pause();
	      emit(EVENT_AUTOPLAY_PAUSE);
	    }
	  }

	  function autoToggle() {
	    if (!stopped) {
	      hovered || focused ? pause(false) : play();
	    }
	  }

	  function update() {
	    if (toggle) {
	      toggleClass(toggle, CLASS_ACTIVE, !stopped);
	      setAttribute(toggle, ARIA_LABEL, options.i18n[stopped ? "play" : "pause"]);
	    }
	  }

	  function onAnimationFrame(rate) {
	    var bar = Elements.bar;
	    bar && style(bar, "width", rate * 100 + "%");
	    emit(EVENT_AUTOPLAY_PLAYING, rate);
	  }

	  function onMove(index) {
	    var Slide = Components2.Slides.getAt(index);
	    interval.set(Slide && +getAttribute(Slide.slide, INTERVAL_DATA_ATTRIBUTE) || options.interval);
	  }

	  return {
	    mount: mount,
	    destroy: interval.cancel,
	    play: play,
	    pause: pause,
	    isPaused: isPaused
	  };
	}

	function Cover(Splide2, Components2, options) {
	  var _EventInterface7 = EventInterface(Splide2),
	      on = _EventInterface7.on;

	  function mount() {
	    if (options.cover) {
	      on(EVENT_LAZYLOAD_LOADED, apply(toggle, true));
	      on([EVENT_MOUNTED, EVENT_UPDATED, EVENT_REFRESH], apply(cover, true));
	    }
	  }

	  function cover(cover2) {
	    Components2.Slides.forEach(function (Slide) {
	      var img = child(Slide.container || Slide.slide, "img");

	      if (img && img.src) {
	        toggle(cover2, img, Slide);
	      }
	    });
	  }

	  function toggle(cover2, img, Slide) {
	    Slide.style("background", cover2 ? "center/cover no-repeat url(\"" + img.src + "\")" : "", true);
	    display(img, cover2 ? "none" : "");
	  }

	  return {
	    mount: mount,
	    destroy: apply(cover, false)
	  };
	}

	var BOUNCE_DIFF_THRESHOLD = 10;
	var BOUNCE_DURATION = 600;
	var FRICTION_FACTOR = 0.6;
	var BASE_VELOCITY = 1.5;
	var MIN_DURATION = 800;

	function Scroll(Splide2, Components2, options) {
	  var _EventInterface8 = EventInterface(Splide2),
	      on = _EventInterface8.on,
	      emit = _EventInterface8.emit;

	  var set = Splide2.state.set;
	  var Move = Components2.Move;
	  var getPosition = Move.getPosition,
	      getLimit = Move.getLimit,
	      exceededLimit = Move.exceededLimit,
	      translate = Move.translate;
	  var isSlide = Splide2.is(SLIDE);
	  var interval;
	  var callback;
	  var friction = 1;

	  function mount() {
	    on(EVENT_MOVE, clear);
	    on([EVENT_UPDATED, EVENT_REFRESH], cancel);
	  }

	  function scroll(destination, duration, snap, onScrolled, noConstrain) {
	    var from = getPosition();
	    clear();

	    if (snap && (!isSlide || !exceededLimit())) {
	      var size = Components2.Layout.sliderSize();
	      var offset = sign(destination) * size * floor(abs(destination) / size) || 0;
	      destination = Move.toPosition(Components2.Controller.toDest(destination % size)) + offset;
	    }

	    var noDistance = approximatelyEqual(from, destination, 1);
	    friction = 1;
	    duration = noDistance ? 0 : duration || max(abs(destination - from) / BASE_VELOCITY, MIN_DURATION);
	    callback = onScrolled;
	    interval = RequestInterval(duration, onEnd, apply(update, from, destination, noConstrain), 1);
	    set(SCROLLING);
	    emit(EVENT_SCROLL);
	    interval.start();
	  }

	  function onEnd() {
	    set(IDLE);
	    callback && callback();
	    emit(EVENT_SCROLLED);
	  }

	  function update(from, to, noConstrain, rate) {
	    var position = getPosition();
	    var target = from + (to - from) * easing(rate);
	    var diff = (target - position) * friction;
	    translate(position + diff);

	    if (isSlide && !noConstrain && exceededLimit()) {
	      friction *= FRICTION_FACTOR;

	      if (abs(diff) < BOUNCE_DIFF_THRESHOLD) {
	        scroll(getLimit(exceededLimit(true)), BOUNCE_DURATION, false, callback, true);
	      }
	    }
	  }

	  function clear() {
	    if (interval) {
	      interval.cancel();
	    }
	  }

	  function cancel() {
	    if (interval && !interval.isPaused()) {
	      clear();
	      onEnd();
	    }
	  }

	  function easing(t) {
	    var easingFunc = options.easingFunc;
	    return easingFunc ? easingFunc(t) : 1 - Math.pow(1 - t, 4);
	  }

	  return {
	    mount: mount,
	    destroy: clear,
	    scroll: scroll,
	    cancel: cancel
	  };
	}

	var SCROLL_LISTENER_OPTIONS = {
	  passive: false,
	  capture: true
	};

	function Drag(Splide2, Components2, options) {
	  var _EventInterface9 = EventInterface(Splide2),
	      on = _EventInterface9.on,
	      emit = _EventInterface9.emit,
	      bind = _EventInterface9.bind,
	      unbind = _EventInterface9.unbind;

	  var state = Splide2.state;
	  var Move = Components2.Move,
	      Scroll = Components2.Scroll,
	      Controller = Components2.Controller,
	      track = Components2.Elements.track,
	      reduce = Components2.Media.reduce;
	  var _Components2$Directio2 = Components2.Direction,
	      resolve = _Components2$Directio2.resolve,
	      orient = _Components2$Directio2.orient;
	  var getPosition = Move.getPosition,
	      exceededLimit = Move.exceededLimit;
	  var basePosition;
	  var baseEvent;
	  var prevBaseEvent;
	  var isFree;
	  var dragging;
	  var exceeded = false;
	  var clickPrevented;
	  var disabled;
	  var target;

	  function mount() {
	    bind(track, POINTER_MOVE_EVENTS, noop, SCROLL_LISTENER_OPTIONS);
	    bind(track, POINTER_UP_EVENTS, noop, SCROLL_LISTENER_OPTIONS);
	    bind(track, POINTER_DOWN_EVENTS, onPointerDown, SCROLL_LISTENER_OPTIONS);
	    bind(track, "click", onClick, {
	      capture: true
	    });
	    bind(track, "dragstart", prevent);
	    on([EVENT_MOUNTED, EVENT_UPDATED], init);
	  }

	  function init() {
	    var drag = options.drag;
	    disable(!drag);
	    isFree = drag === "free";
	  }

	  function onPointerDown(e) {
	    clickPrevented = false;

	    if (!disabled) {
	      var isTouch = isTouchEvent(e);

	      if (isDraggable(e.target) && (isTouch || !e.button)) {
	        if (!Controller.isBusy()) {
	          target = isTouch ? track : window;
	          dragging = state.is([MOVING, SCROLLING]);
	          prevBaseEvent = null;
	          bind(target, POINTER_MOVE_EVENTS, onPointerMove, SCROLL_LISTENER_OPTIONS);
	          bind(target, POINTER_UP_EVENTS, onPointerUp, SCROLL_LISTENER_OPTIONS);
	          Move.cancel();
	          Scroll.cancel();
	          save(e);
	        } else {
	          prevent(e, true);
	        }
	      }
	    }
	  }

	  function onPointerMove(e) {
	    if (!state.is(DRAGGING)) {
	      state.set(DRAGGING);
	      emit(EVENT_DRAG);
	    }

	    if (e.cancelable) {
	      if (dragging) {
	        Move.translate(basePosition + constrain(diffCoord(e)));
	        var expired = diffTime(e) > LOG_INTERVAL;
	        var hasExceeded = exceeded !== (exceeded = exceededLimit());

	        if (expired || hasExceeded) {
	          save(e);
	        }

	        clickPrevented = true;
	        emit(EVENT_DRAGGING);
	        prevent(e);
	      } else if (isSliderDirection(e)) {
	        dragging = shouldStart(e);
	        prevent(e);
	      }
	    }
	  }

	  function onPointerUp(e) {
	    if (state.is(DRAGGING)) {
	      state.set(IDLE);
	      emit(EVENT_DRAGGED);
	    }

	    if (dragging) {
	      move(e);
	      prevent(e);
	    }

	    unbind(target, POINTER_MOVE_EVENTS, onPointerMove);
	    unbind(target, POINTER_UP_EVENTS, onPointerUp);
	    dragging = false;
	  }

	  function onClick(e) {
	    if (!disabled && clickPrevented) {
	      prevent(e, true);
	    }
	  }

	  function save(e) {
	    prevBaseEvent = baseEvent;
	    baseEvent = e;
	    basePosition = getPosition();
	  }

	  function move(e) {
	    var velocity = computeVelocity(e);
	    var destination = computeDestination(velocity);
	    var rewind = options.rewind && options.rewindByDrag;
	    reduce(false);

	    if (isFree) {
	      Controller.scroll(destination, 0, options.snap);
	    } else if (Splide2.is(FADE)) {
	      Controller.go(orient(sign(velocity)) < 0 ? rewind ? "<" : "-" : rewind ? ">" : "+");
	    } else if (Splide2.is(SLIDE) && exceeded && rewind) {
	      Controller.go(exceededLimit(true) ? ">" : "<");
	    } else {
	      Controller.go(Controller.toDest(destination), true);
	    }

	    reduce(true);
	  }

	  function shouldStart(e) {
	    var thresholds = options.dragMinThreshold;
	    var isObj = isObject(thresholds);
	    var mouse = isObj && thresholds.mouse || 0;
	    var touch = (isObj ? thresholds.touch : +thresholds) || 10;
	    return abs(diffCoord(e)) > (isTouchEvent(e) ? touch : mouse);
	  }

	  function isSliderDirection(e) {
	    return abs(diffCoord(e)) > abs(diffCoord(e, true));
	  }

	  function computeVelocity(e) {
	    if (Splide2.is(LOOP) || !exceeded) {
	      var time = diffTime(e);

	      if (time && time < LOG_INTERVAL) {
	        return diffCoord(e) / time;
	      }
	    }

	    return 0;
	  }

	  function computeDestination(velocity) {
	    return getPosition() + sign(velocity) * min(abs(velocity) * (options.flickPower || 600), isFree ? Infinity : Components2.Layout.listSize() * (options.flickMaxPages || 1));
	  }

	  function diffCoord(e, orthogonal) {
	    return coordOf(e, orthogonal) - coordOf(getBaseEvent(e), orthogonal);
	  }

	  function diffTime(e) {
	    return timeOf(e) - timeOf(getBaseEvent(e));
	  }

	  function getBaseEvent(e) {
	    return baseEvent === e && prevBaseEvent || baseEvent;
	  }

	  function coordOf(e, orthogonal) {
	    return (isTouchEvent(e) ? e.changedTouches[0] : e)["page" + resolve(orthogonal ? "Y" : "X")];
	  }

	  function constrain(diff) {
	    return diff / (exceeded && Splide2.is(SLIDE) ? FRICTION : 1);
	  }

	  function isDraggable(target2) {
	    var noDrag = options.noDrag;
	    return !matches(target2, "." + CLASS_PAGINATION_PAGE + ", ." + CLASS_ARROW) && (!noDrag || !matches(target2, noDrag));
	  }

	  function isTouchEvent(e) {
	    return typeof TouchEvent !== "undefined" && e instanceof TouchEvent;
	  }

	  function isDragging() {
	    return dragging;
	  }

	  function disable(value) {
	    disabled = value;
	  }

	  return {
	    mount: mount,
	    disable: disable,
	    isDragging: isDragging
	  };
	}

	var NORMALIZATION_MAP = {
	  Spacebar: " ",
	  Right: ARROW_RIGHT,
	  Left: ARROW_LEFT,
	  Up: ARROW_UP,
	  Down: ARROW_DOWN
	};

	function normalizeKey(key) {
	  key = isString(key) ? key : key.key;
	  return NORMALIZATION_MAP[key] || key;
	}

	var KEYBOARD_EVENT = "keydown";

	function Keyboard(Splide2, Components2, options) {
	  var _EventInterface10 = EventInterface(Splide2),
	      on = _EventInterface10.on,
	      bind = _EventInterface10.bind,
	      unbind = _EventInterface10.unbind;

	  var root = Splide2.root;
	  var resolve = Components2.Direction.resolve;
	  var target;
	  var disabled;

	  function mount() {
	    init();
	    on(EVENT_UPDATED, destroy);
	    on(EVENT_UPDATED, init);
	    on(EVENT_MOVE, onMove);
	  }

	  function init() {
	    var keyboard = options.keyboard;

	    if (keyboard) {
	      target = keyboard === "global" ? window : root;
	      bind(target, KEYBOARD_EVENT, onKeydown);
	    }
	  }

	  function destroy() {
	    unbind(target, KEYBOARD_EVENT);
	  }

	  function disable(value) {
	    disabled = value;
	  }

	  function onMove() {
	    var _disabled = disabled;
	    disabled = true;
	    nextTick(function () {
	      disabled = _disabled;
	    });
	  }

	  function onKeydown(e) {
	    if (!disabled) {
	      var key = normalizeKey(e);

	      if (key === resolve(ARROW_LEFT)) {
	        Splide2.go("<");
	      } else if (key === resolve(ARROW_RIGHT)) {
	        Splide2.go(">");
	      }
	    }
	  }

	  return {
	    mount: mount,
	    destroy: destroy,
	    disable: disable
	  };
	}

	var SRC_DATA_ATTRIBUTE = DATA_ATTRIBUTE + "-lazy";
	var SRCSET_DATA_ATTRIBUTE = SRC_DATA_ATTRIBUTE + "-srcset";
	var IMAGE_SELECTOR = "[" + SRC_DATA_ATTRIBUTE + "], [" + SRCSET_DATA_ATTRIBUTE + "]";

	function LazyLoad(Splide2, Components2, options) {
	  var _EventInterface11 = EventInterface(Splide2),
	      on = _EventInterface11.on,
	      off = _EventInterface11.off,
	      bind = _EventInterface11.bind,
	      emit = _EventInterface11.emit;

	  var isSequential = options.lazyLoad === "sequential";
	  var events = [EVENT_MOVED, EVENT_SCROLLED];
	  var entries = [];

	  function mount() {
	    if (options.lazyLoad) {
	      init();
	      on(EVENT_REFRESH, init);
	    }
	  }

	  function init() {
	    empty(entries);
	    register();

	    if (isSequential) {
	      loadNext();
	    } else {
	      off(events);
	      on(events, check);
	      check();
	    }
	  }

	  function register() {
	    Components2.Slides.forEach(function (Slide) {
	      queryAll(Slide.slide, IMAGE_SELECTOR).forEach(function (img) {
	        var src = getAttribute(img, SRC_DATA_ATTRIBUTE);
	        var srcset = getAttribute(img, SRCSET_DATA_ATTRIBUTE);

	        if (src !== img.src || srcset !== img.srcset) {
	          var className = options.classes.spinner;
	          var parent = img.parentElement;
	          var spinner = child(parent, "." + className) || create("span", className, parent);
	          entries.push([img, Slide, spinner]);
	          img.src || display(img, "none");
	        }
	      });
	    });
	  }

	  function check() {
	    entries = entries.filter(function (data) {
	      var distance = options.perPage * ((options.preloadPages || 1) + 1) - 1;
	      return data[1].isWithin(Splide2.index, distance) ? load(data) : true;
	    });
	    entries.length || off(events);
	  }

	  function load(data) {
	    var img = data[0];
	    addClass(data[1].slide, CLASS_LOADING);
	    bind(img, "load error", apply(onLoad, data));
	    setAttribute(img, "src", getAttribute(img, SRC_DATA_ATTRIBUTE));
	    setAttribute(img, "srcset", getAttribute(img, SRCSET_DATA_ATTRIBUTE));
	    removeAttribute(img, SRC_DATA_ATTRIBUTE);
	    removeAttribute(img, SRCSET_DATA_ATTRIBUTE);
	  }

	  function onLoad(data, e) {
	    var img = data[0],
	        Slide = data[1];
	    removeClass(Slide.slide, CLASS_LOADING);

	    if (e.type !== "error") {
	      remove(data[2]);
	      display(img, "");
	      emit(EVENT_LAZYLOAD_LOADED, img, Slide);
	      emit(EVENT_RESIZE);
	    }

	    isSequential && loadNext();
	  }

	  function loadNext() {
	    entries.length && load(entries.shift());
	  }

	  return {
	    mount: mount,
	    destroy: apply(empty, entries),
	    check: check
	  };
	}

	function Pagination(Splide2, Components2, options) {
	  var event = EventInterface(Splide2);
	  var on = event.on,
	      emit = event.emit,
	      bind = event.bind;
	  var Slides = Components2.Slides,
	      Elements = Components2.Elements,
	      Controller = Components2.Controller;
	  var hasFocus = Controller.hasFocus,
	      getIndex = Controller.getIndex,
	      go = Controller.go;
	  var resolve = Components2.Direction.resolve;
	  var placeholder = Elements.pagination;
	  var items = [];
	  var list;
	  var paginationClasses;

	  function mount() {
	    destroy();
	    on([EVENT_UPDATED, EVENT_REFRESH, EVENT_END_INDEX_CHANGED], mount);
	    var enabled = options.pagination;
	    placeholder && display(placeholder, enabled ? "" : "none");

	    if (enabled) {
	      on([EVENT_MOVE, EVENT_SCROLL, EVENT_SCROLLED], update);
	      createPagination();
	      update();
	      emit(EVENT_PAGINATION_MOUNTED, {
	        list: list,
	        items: items
	      }, getAt(Splide2.index));
	    }
	  }

	  function destroy() {
	    if (list) {
	      remove(placeholder ? slice(list.children) : list);
	      removeClass(list, paginationClasses);
	      empty(items);
	      list = null;
	    }

	    event.destroy();
	  }

	  function createPagination() {
	    var length = Splide2.length;
	    var classes = options.classes,
	        i18n = options.i18n,
	        perPage = options.perPage;
	    var max = hasFocus() ? Controller.getEnd() + 1 : ceil(length / perPage);
	    list = placeholder || create("ul", classes.pagination, Elements.track.parentElement);
	    addClass(list, paginationClasses = CLASS_PAGINATION + "--" + getDirection());
	    setAttribute(list, ROLE, "tablist");
	    setAttribute(list, ARIA_LABEL, i18n.select);
	    setAttribute(list, ARIA_ORIENTATION, getDirection() === TTB ? "vertical" : "");

	    for (var i = 0; i < max; i++) {
	      var li = create("li", null, list);
	      var button = create("button", {
	        class: classes.page,
	        type: "button"
	      }, li);
	      var controls = Slides.getIn(i).map(function (Slide) {
	        return Slide.slide.id;
	      });
	      var text = !hasFocus() && perPage > 1 ? i18n.pageX : i18n.slideX;
	      bind(button, "click", apply(onClick, i));

	      if (options.paginationKeyboard) {
	        bind(button, "keydown", apply(onKeydown, i));
	      }

	      setAttribute(li, ROLE, "presentation");
	      setAttribute(button, ROLE, "tab");
	      setAttribute(button, ARIA_CONTROLS, controls.join(" "));
	      setAttribute(button, ARIA_LABEL, format(text, i + 1));
	      setAttribute(button, TAB_INDEX, -1);
	      items.push({
	        li: li,
	        button: button,
	        page: i
	      });
	    }
	  }

	  function onClick(page) {
	    go(">" + page, true);
	  }

	  function onKeydown(page, e) {
	    var length = items.length;
	    var key = normalizeKey(e);
	    var dir = getDirection();
	    var nextPage = -1;

	    if (key === resolve(ARROW_RIGHT, false, dir)) {
	      nextPage = ++page % length;
	    } else if (key === resolve(ARROW_LEFT, false, dir)) {
	      nextPage = (--page + length) % length;
	    } else if (key === "Home") {
	      nextPage = 0;
	    } else if (key === "End") {
	      nextPage = length - 1;
	    }

	    var item = items[nextPage];

	    if (item) {
	      focus(item.button);
	      go(">" + nextPage);
	      prevent(e, true);
	    }
	  }

	  function getDirection() {
	    return options.paginationDirection || options.direction;
	  }

	  function getAt(index) {
	    return items[Controller.toPage(index)];
	  }

	  function update() {
	    var prev = getAt(getIndex(true));
	    var curr = getAt(getIndex());

	    if (prev) {
	      var button = prev.button;
	      removeClass(button, CLASS_ACTIVE);
	      removeAttribute(button, ARIA_SELECTED);
	      setAttribute(button, TAB_INDEX, -1);
	    }

	    if (curr) {
	      var _button = curr.button;
	      addClass(_button, CLASS_ACTIVE);
	      setAttribute(_button, ARIA_SELECTED, true);
	      setAttribute(_button, TAB_INDEX, "");
	    }

	    emit(EVENT_PAGINATION_UPDATED, {
	      list: list,
	      items: items
	    }, prev, curr);
	  }

	  return {
	    items: items,
	    mount: mount,
	    destroy: destroy,
	    getAt: getAt,
	    update: update
	  };
	}

	var TRIGGER_KEYS = [" ", "Enter"];

	function Sync(Splide2, Components2, options) {
	  var isNavigation = options.isNavigation,
	      slideFocus = options.slideFocus;
	  var events = [];

	  function mount() {
	    Splide2.splides.forEach(function (target) {
	      if (!target.isParent) {
	        sync(Splide2, target.splide);
	        sync(target.splide, Splide2);
	      }
	    });

	    if (isNavigation) {
	      navigate();
	    }
	  }

	  function destroy() {
	    events.forEach(function (event) {
	      event.destroy();
	    });
	    empty(events);
	  }

	  function remount() {
	    destroy();
	    mount();
	  }

	  function sync(splide, target) {
	    var event = EventInterface(splide);
	    event.on(EVENT_MOVE, function (index, prev, dest) {
	      target.go(target.is(LOOP) ? dest : index);
	    });
	    events.push(event);
	  }

	  function navigate() {
	    var event = EventInterface(Splide2);
	    var on = event.on;
	    on(EVENT_CLICK, onClick);
	    on(EVENT_SLIDE_KEYDOWN, onKeydown);
	    on([EVENT_MOUNTED, EVENT_UPDATED], update);
	    events.push(event);
	    event.emit(EVENT_NAVIGATION_MOUNTED, Splide2.splides);
	  }

	  function update() {
	    setAttribute(Components2.Elements.list, ARIA_ORIENTATION, options.direction === TTB ? "vertical" : "");
	  }

	  function onClick(Slide) {
	    Splide2.go(Slide.index);
	  }

	  function onKeydown(Slide, e) {
	    if (includes(TRIGGER_KEYS, normalizeKey(e))) {
	      onClick(Slide);
	      prevent(e);
	    }
	  }

	  return {
	    setup: apply(Components2.Media.set, {
	      slideFocus: isUndefined(slideFocus) ? isNavigation : slideFocus
	    }, true),
	    mount: mount,
	    destroy: destroy,
	    remount: remount
	  };
	}

	function Wheel(Splide2, Components2, options) {
	  var _EventInterface12 = EventInterface(Splide2),
	      bind = _EventInterface12.bind;

	  var lastTime = 0;

	  function mount() {
	    if (options.wheel) {
	      bind(Components2.Elements.track, "wheel", onWheel, SCROLL_LISTENER_OPTIONS);
	    }
	  }

	  function onWheel(e) {
	    if (e.cancelable) {
	      var deltaY = e.deltaY;
	      var backwards = deltaY < 0;
	      var timeStamp = timeOf(e);

	      var _min = options.wheelMinThreshold || 0;

	      var sleep = options.wheelSleep || 0;

	      if (abs(deltaY) > _min && timeStamp - lastTime > sleep) {
	        Splide2.go(backwards ? "<" : ">");
	        lastTime = timeStamp;
	      }

	      shouldPrevent(backwards) && prevent(e);
	    }
	  }

	  function shouldPrevent(backwards) {
	    return !options.releaseWheel || Splide2.state.is(MOVING) || Components2.Controller.getAdjacent(backwards) !== -1;
	  }

	  return {
	    mount: mount
	  };
	}

	var SR_REMOVAL_DELAY = 90;

	function Live(Splide2, Components2, options) {
	  var _EventInterface13 = EventInterface(Splide2),
	      on = _EventInterface13.on;

	  var track = Components2.Elements.track;
	  var enabled = options.live && !options.isNavigation;
	  var sr = create("span", CLASS_SR);
	  var interval = RequestInterval(SR_REMOVAL_DELAY, apply(toggle, false));

	  function mount() {
	    if (enabled) {
	      disable(!Components2.Autoplay.isPaused());
	      setAttribute(track, ARIA_ATOMIC, true);
	      sr.textContent = "\u2026";
	      on(EVENT_AUTOPLAY_PLAY, apply(disable, true));
	      on(EVENT_AUTOPLAY_PAUSE, apply(disable, false));
	      on([EVENT_MOVED, EVENT_SCROLLED], apply(toggle, true));
	    }
	  }

	  function toggle(active) {
	    setAttribute(track, ARIA_BUSY, active);

	    if (active) {
	      append(track, sr);
	      interval.start();
	    } else {
	      remove(sr);
	      interval.cancel();
	    }
	  }

	  function destroy() {
	    removeAttribute(track, [ARIA_LIVE, ARIA_ATOMIC, ARIA_BUSY]);
	    remove(sr);
	  }

	  function disable(disabled) {
	    if (enabled) {
	      setAttribute(track, ARIA_LIVE, disabled ? "off" : "polite");
	    }
	  }

	  return {
	    mount: mount,
	    disable: disable,
	    destroy: destroy
	  };
	}

	var ComponentConstructors = /*#__PURE__*/Object.freeze({
	  __proto__: null,
	  Media: Media,
	  Direction: Direction,
	  Elements: Elements,
	  Slides: Slides,
	  Layout: Layout,
	  Clones: Clones,
	  Move: Move,
	  Controller: Controller,
	  Arrows: Arrows,
	  Autoplay: Autoplay,
	  Cover: Cover,
	  Scroll: Scroll,
	  Drag: Drag,
	  Keyboard: Keyboard,
	  LazyLoad: LazyLoad,
	  Pagination: Pagination,
	  Sync: Sync,
	  Wheel: Wheel,
	  Live: Live
	});
	var I18N = {
	  prev: "Previous slide",
	  next: "Next slide",
	  first: "Go to first slide",
	  last: "Go to last slide",
	  slideX: "Go to slide %s",
	  pageX: "Go to page %s",
	  play: "Start autoplay",
	  pause: "Pause autoplay",
	  carousel: "carousel",
	  slide: "slide",
	  select: "Select a slide to show",
	  slideLabel: "%s of %s"
	};
	var DEFAULTS = {
	  type: "slide",
	  role: "region",
	  speed: 400,
	  perPage: 1,
	  cloneStatus: true,
	  arrows: true,
	  pagination: true,
	  paginationKeyboard: true,
	  interval: 5e3,
	  pauseOnHover: true,
	  pauseOnFocus: true,
	  resetProgress: true,
	  easing: "cubic-bezier(0.25, 1, 0.5, 1)",
	  drag: true,
	  direction: "ltr",
	  trimSpace: true,
	  focusableNodes: "a, button, textarea, input, select, iframe",
	  live: true,
	  classes: CLASSES,
	  i18n: I18N,
	  reducedMotion: {
	    speed: 0,
	    rewindSpeed: 0,
	    autoplay: "pause"
	  }
	};

	function Fade(Splide2, Components2, options) {
	  var Slides = Components2.Slides;

	  function mount() {
	    EventInterface(Splide2).on([EVENT_MOUNTED, EVENT_REFRESH], init);
	  }

	  function init() {
	    Slides.forEach(function (Slide) {
	      Slide.style("transform", "translateX(-" + 100 * Slide.index + "%)");
	    });
	  }

	  function start(index, done) {
	    Slides.style("transition", "opacity " + options.speed + "ms " + options.easing);
	    nextTick(done);
	  }

	  return {
	    mount: mount,
	    start: start,
	    cancel: noop
	  };
	}

	function Slide(Splide2, Components2, options) {
	  var Move = Components2.Move,
	      Controller = Components2.Controller,
	      Scroll = Components2.Scroll;
	  var list = Components2.Elements.list;
	  var transition = apply(style, list, "transition");
	  var endCallback;

	  function mount() {
	    EventInterface(Splide2).bind(list, "transitionend", function (e) {
	      if (e.target === list && endCallback) {
	        cancel();
	        endCallback();
	      }
	    });
	  }

	  function start(index, done) {
	    var destination = Move.toPosition(index, true);
	    var position = Move.getPosition();
	    var speed = getSpeed(index);

	    if (abs(destination - position) >= 1 && speed >= 1) {
	      if (options.useScroll) {
	        Scroll.scroll(destination, speed, false, done);
	      } else {
	        transition("transform " + speed + "ms " + options.easing);
	        Move.translate(destination, true);
	        endCallback = done;
	      }
	    } else {
	      Move.jump(index);
	      done();
	    }
	  }

	  function cancel() {
	    transition("");
	    Scroll.cancel();
	  }

	  function getSpeed(index) {
	    var rewindSpeed = options.rewindSpeed;

	    if (Splide2.is(SLIDE) && rewindSpeed) {
	      var prev = Controller.getIndex(true);
	      var end = Controller.getEnd();

	      if (prev === 0 && index >= end || prev >= end && index === 0) {
	        return rewindSpeed;
	      }
	    }

	    return options.speed;
	  }

	  return {
	    mount: mount,
	    start: start,
	    cancel: cancel
	  };
	}

	var _Splide = /*#__PURE__*/function () {
	  function _Splide(target, options) {
	    this.event = EventInterface();
	    this.Components = {};
	    this.state = State(CREATED);
	    this.splides = [];
	    this._o = {};
	    this._E = {};
	    var root = isString(target) ? query(document, target) : target;
	    assert(root, root + " is invalid.");
	    this.root = root;
	    options = merge({
	      label: getAttribute(root, ARIA_LABEL) || "",
	      labelledby: getAttribute(root, ARIA_LABELLEDBY) || ""
	    }, DEFAULTS, _Splide.defaults, options || {});

	    try {
	      merge(options, JSON.parse(getAttribute(root, DATA_ATTRIBUTE)));
	    } catch (e) {
	      assert(false, "Invalid JSON");
	    }

	    this._o = Object.create(merge({}, options));
	  }

	  var _proto = _Splide.prototype;

	  _proto.mount = function mount(Extensions, Transition) {
	    var _this = this;

	    var state = this.state,
	        Components2 = this.Components;
	    assert(state.is([CREATED, DESTROYED]), "Already mounted!");
	    state.set(CREATED);
	    this._C = Components2;
	    this._T = Transition || this._T || (this.is(FADE) ? Fade : Slide);
	    this._E = Extensions || this._E;
	    var Constructors = assign({}, ComponentConstructors, this._E, {
	      Transition: this._T
	    });
	    forOwn(Constructors, function (Component, key) {
	      var component = Component(_this, Components2, _this._o);
	      Components2[key] = component;
	      component.setup && component.setup();
	    });
	    forOwn(Components2, function (component) {
	      component.mount && component.mount();
	    });
	    this.emit(EVENT_MOUNTED);
	    addClass(this.root, CLASS_INITIALIZED);
	    state.set(IDLE);
	    this.emit(EVENT_READY);
	    return this;
	  };

	  _proto.sync = function sync(splide) {
	    this.splides.push({
	      splide: splide
	    });
	    splide.splides.push({
	      splide: this,
	      isParent: true
	    });

	    if (this.state.is(IDLE)) {
	      this._C.Sync.remount();

	      splide.Components.Sync.remount();
	    }

	    return this;
	  };

	  _proto.go = function go(control) {
	    this._C.Controller.go(control);

	    return this;
	  };

	  _proto.on = function on(events, callback) {
	    this.event.on(events, callback);
	    return this;
	  };

	  _proto.off = function off(events) {
	    this.event.off(events);
	    return this;
	  };

	  _proto.emit = function emit(event) {
	    var _this$event;

	    (_this$event = this.event).emit.apply(_this$event, [event].concat(slice(arguments, 1)));

	    return this;
	  };

	  _proto.add = function add(slides, index) {
	    this._C.Slides.add(slides, index);

	    return this;
	  };

	  _proto.remove = function remove(matcher) {
	    this._C.Slides.remove(matcher);

	    return this;
	  };

	  _proto.is = function is(type) {
	    return this._o.type === type;
	  };

	  _proto.refresh = function refresh() {
	    this.emit(EVENT_REFRESH);
	    return this;
	  };

	  _proto.destroy = function destroy(completely) {
	    if (completely === void 0) {
	      completely = true;
	    }

	    var event = this.event,
	        state = this.state;

	    if (state.is(CREATED)) {
	      EventInterface(this).on(EVENT_READY, this.destroy.bind(this, completely));
	    } else {
	      forOwn(this._C, function (component) {
	        component.destroy && component.destroy(completely);
	      }, true);
	      event.emit(EVENT_DESTROY);
	      event.destroy();
	      completely && empty(this.splides);
	      state.set(DESTROYED);
	    }

	    return this;
	  };

	  _createClass(_Splide, [{
	    key: "options",
	    get: function get() {
	      return this._o;
	    },
	    set: function set(options) {
	      this._C.Media.set(options, true, true);
	    }
	  }, {
	    key: "length",
	    get: function get() {
	      return this._C.Slides.getLength(true);
	    }
	  }, {
	    key: "index",
	    get: function get() {
	      return this._C.Controller.getIndex();
	    }
	  }]);

	  return _Splide;
	}();

	var Splide = _Splide;
	Splide.defaults = {};
	Splide.STATES = STATES;

	const propTypes = {
	  heading: validateProps.AllowedTypes.string,
	  description: validateProps.AllowedTypes.string,
	  alignHeader: validateProps.AllowedTypes.oneOf(CAROUSEL_ALIGN_HEADERS),
	  rewind: validateProps.AllowedTypes.boolean,
	  wrapContent: validateProps.AllowedTypes.boolean,
	  width: validateProps.AllowedTypes.oneOf(CAROUSEL_WIDTHS),
	  slidesPerPage: validateProps.AllowedTypes.oneOf([
	    validateProps.AllowedTypes.breakpoint('number'),
	    validateProps.AllowedTypes.oneOf(['auto']),
	  ]),
	  disablePagination: validateProps.AllowedTypes.breakpoint('boolean'),
	  pagination: validateProps.AllowedTypes.breakpoint('boolean'),
	  intl: validateProps.AllowedTypes.shape({
	    prev: validateProps.AllowedTypes.string,
	    next: validateProps.AllowedTypes.string,
	    first: validateProps.AllowedTypes.string,
	    last: validateProps.AllowedTypes.string,
	    slideLabel: validateProps.AllowedTypes.string,
	    slide: validateProps.AllowedTypes.string,
	  }),
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	  activeSlideIndex: validateProps.AllowedTypes.number,
	  skipLinkTarget: validateProps.AllowedTypes.string,
	};
	const Carousel = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.carouselChange = validateProps.createEvent(this, "carouselChange", 3);
	    this.update = validateProps.createEvent(this, "update", 3);
	    this.slides = [];
	    this.updateSlidesAndPagination = () => {
	      this.slides = getSlidesAndAddAttributes(this.host);
	      this.updateAmountOfPages();
	    };
	    this.updateAmountOfPages = () => {
	      this.amountOfPages = getAmountOfPages(this.slides.length, 
	      // round to sanitize floating numbers
	      this.slidesPerPage === 'auto' ? 1 : Math.round(validateProps.getCurrentMatchingBreakpointValue(this.slidesPerPage)));
	      renderPagination(this.paginationEl, this.amountOfPages, this.splide?.index || 0);
	    };
	    this.onNextKeyDown = (e) => {
	      if (e.key === 'Tab' && !e.shiftKey) {
	        const activeSlide = this.slides.at(this.splide.index);
	        activeSlide.focus();
	        e.preventDefault();
	      }
	    };
	    this.onSplideFocusIn = (e) => {
	      const { target } = e;
	      const { index: splideIndex } = this.splide;
	      const slideIndexOfFocusedElement = this.slides.findIndex((slide) => slide.contains(target)); // focussed element is slot or within slide, e.g. link or button
	      const slideIsVisible = this.splide.Components.Elements.slides[slideIndexOfFocusedElement].classList.contains('is-visible');
	      if (splideIndex !== slideIndexOfFocusedElement) {
	        if (slideIndexOfFocusedElement > splideIndex && !slideIsVisible) {
	          slideNext(this.splide, this.amountOfPages);
	        }
	        else if (slideIndexOfFocusedElement < splideIndex) {
	          slidePrev(this.splide, this.amountOfPages);
	        }
	      }
	    };
	    this.heading = undefined;
	    this.description = undefined;
	    this.alignHeader = 'left';
	    this.rewind = true;
	    this.wrapContent = undefined;
	    this.width = 'basic';
	    this.slidesPerPage = 1;
	    this.disablePagination = undefined;
	    this.pagination = true;
	    this.intl = undefined;
	    this.theme = 'light';
	    this.activeSlideIndex = 0;
	    this.skipLinkTarget = undefined;
	    this.amountOfPages = undefined;
	  }
	  get hasNavigation() {
	    return this.slidesPerPage === 'auto' || this.amountOfPages > 1;
	  }
	  activeSlideHandler(newValue) {
	    this.splide.go(newValue); // change event is emitted via splide.on('move')
	  }
	  connectedCallback() {
	    validateProps.observeChildren(this.host, this.updateSlidesAndPagination);
	    this.observeBreakpointChange();
	    if (this.splide) {
	      this.observeSlides(); // on reconnect, adjust aria attributes on slides
	      // on reconnect we can reuse the splide instance
	      this.updateSlidesAndPagination();
	      this.registerSplideHandlers(this.splide);
	    }
	  }
	  componentWillLoad() {
	    this.slidesPerPage = validateProps.parseJSON(this.slidesPerPage); // dynamic change is not supported right now
	    this.updateSlidesAndPagination();
	    this.observeBreakpointChange();
	  }
	  componentShouldUpdate(newVal, oldVal, propName) {
	    return propName !== 'activeSlideIndex' && validateProps.hasPropValueChanged(newVal, oldVal); // we need to prevent splide reinitialization via splide.refresh() when activeSlideIndex is changed from outside
	  }
	  componentDidLoad() {
	    this.observeSlides(); // initial, adjust tabindex and aria attributes on slides
	    this.splide = new Splide(this.container, {
	      start: this.activeSlideIndex,
	      autoWidth: this.slidesPerPage === 'auto',
	      arrows: false,
	      pagination: false,
	      rewind: this.rewind,
	      rewindByDrag: true,
	      drag: this.hasNavigation,
	      perMove: 1,
	      mediaQuery: 'min',
	      speed: carouselTransitionDuration,
	      gap: gridGap.gridGap,
	      // TODO: this uses matchMedia internally, since we also use it, there is some redundancy
	      breakpoints: getSplideBreakpoints(this.slidesPerPage),
	      // https://splidejs.com/guides/i18n/#default-texts
	      i18n: validateProps.parseJSONAttribute(this.intl || {}), // can only be applied initially atm
	    });
	    this.registerSplideHandlers(this.splide);
	  }
	  componentDidUpdate() {
	    this.splide.options = { drag: this.hasNavigation };
	    this.splide.refresh(); // needs to happen after render to detect new and removed slides
	    if (this.hasNavigation) {
	      renderPagination(this.paginationEl, this.amountOfPages, this.splide?.index || 0); // update pagination in case the carousel was not draggable before
	      updatePrevNextButtons(this.btnPrev, this.btnNext, this.splide); // go to last/first slide aria might be wrong
	    }
	  }
	  disconnectedCallback() {
	    validateProps.unobserveChildren(this.host);
	    validateProps.unobserveChildren(this.container); // adjust tabindex and aria attributes on slides
	    validateProps.unobserveBreakpointChange(this.host);
	    this.splide.destroy();
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'wrapContent');
	    warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'disablePagination', 'Please use pagination prop instead.');
	    warnIfHeadingIsMissing(this.host, this.heading);
	    this.disablePagination = validateProps.parseJSON(this.disablePagination); // parsing the value just once per lifecycle
	    this.pagination = validateProps.parseJSON(this.pagination); // parsing the value just once per lifecycle
	    validateProps.attachComponentCss(this.host, getComponentCss, this.width, 
	    // flip boolean values of disablePagination since it is the inverse of pagination
	    this.disablePagination
	      ? typeof this.disablePagination === 'object'
	        ? Object.fromEntries(Object.entries(this.disablePagination).map(([key, value]) => [key, !value]))
	        : !this.disablePagination
	      : this.pagination, isInfinitePagination(this.amountOfPages), this.alignHeader, this.theme);
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    const btnProps = {
	      class: 'btn',
	      type: 'button',
	      hideLabel: true,
	      theme: this.theme,
	      // 'aria-controls': 'splide-track', // TODO: cross shadow dom? use native button tag instead of p-button-pure?
	    };
	    return (validateProps.h(validateProps.Host, null, validateProps.h("div", { class: "header" }, this.heading ? validateProps.h("h2", { id: "heading" }, this.heading) : validateProps.h("slot", { name: "heading" }), hasDescription.hasDescription(this.host, this.description) &&
	      ((this.description && validateProps.h("p", null, this.description)) || validateProps.h("slot", { name: "description" })), validateProps.h("div", { class: "nav" }, this.skipLinkTarget && (validateProps.h(PrefixedTagNames.pLinkPure, { href: this.skipLinkTarget, theme: this.theme, icon: "arrow-last", class: "btn skip-link", alignLabel: "left", hideLabel: true, "aria-describedby": this.heading ? 'heading' : null }, "Skip carousel entries")), this.hasNavigation && [
	      validateProps.h(PrefixedTagNames.pButtonPure, { ...btnProps, icon: "arrow-left", ref: (ref) => (this.btnPrev = ref), onClick: () => slidePrev(this.splide, this.amountOfPages) }),
	      validateProps.h(PrefixedTagNames.pButtonPure, { ...btnProps, icon: "arrow-right", ref: (ref) => (this.btnNext = ref), onClick: () => slideNext(this.splide, this.amountOfPages), onKeyDown: this.onNextKeyDown }),
	    ])), validateProps.h("div", { id: "splide", class: "splide", "aria-label": this.heading || getSlotTextContent.getSlotTextContent(this.host, 'heading'), ref: (ref) => (this.container = ref), onMouseDown: (e) => e.preventDefault(), onFocusin: this.onSplideFocusIn }, validateProps.h("div", { class: "splide__track" }, validateProps.h("div", { class: "splide__list" }, this.slides.map((_, i) => (validateProps.h("div", { key: i, class: "splide__slide" }, validateProps.h("slot", { name: `slide-${i}` }))))))), (this.disablePagination ? this.disablePagination !== true : this.pagination) && this.hasNavigation && (validateProps.h("div", { class: "pagination-container" }, validateProps.h("div", { class: "pagination", ref: (ref) => (this.paginationEl = ref) })))));
	  }
	  registerSplideHandlers(splide) {
	    splide.on('mounted', () => {
	      if (this.splide.options.drag) {
	        updatePrevNextButtons(this.btnPrev, this.btnNext, splide);
	        renderPagination(this.paginationEl, this.amountOfPages, this.activeSlideIndex); // initial pagination
	      }
	    });
	    splide.on('move', (activeIndex, previousIndex) => {
	      updatePrevNextButtons(this.btnPrev, this.btnNext, splide);
	      updatePagination(this.paginationEl, this.amountOfPages, activeIndex);
	      this.update.emit({ activeIndex, previousIndex });
	      this.carouselChange.emit({ activeIndex, previousIndex });
	    });
	    splide.mount();
	  }
	  observeBreakpointChange() {
	    if (typeof this.slidesPerPage === 'object') {
	      validateProps.observeBreakpointChange(this.host, this.updateAmountOfPages);
	    }
	  }
	  observeSlides() {
	    // splide sets attributes everytime it slides or slides are added, which we need to adjust after wards
	    validateProps.observeChildren(this.container, () => this.splide.Components.Elements.slides.forEach((el) => {
	      el.removeAttribute('aria-hidden');
	    }), ['aria-hidden']);
	  }
	  get host() { return validateProps.getElement(this); }
	  static get watchers() { return {
	    "activeSlideIndex": ["activeSlideHandler"]
	  }; }
	};

	pCarousel_cjs_entry.p_carousel = Carousel;

	
	return pCarousel_cjs_entry;
}

var pCheckboxWrapper_cjs_entry = {};

var hasRequiredPCheckboxWrapper_cjs_entry;

function requirePCheckboxWrapper_cjs_entry () {
	if (hasRequiredPCheckboxWrapper_cjs_entry) return pCheckboxWrapper_cjs_entry;
	hasRequiredPCheckboxWrapper_cjs_entry = 1;

	Object.defineProperty(pCheckboxWrapper_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const getClosestHTMLElement = requireGetClosestHTMLElement0135bfd9();
	const isDisabledOrLoading = requireIsDisabledOrLoadingAd97a497();
	const checkboxRadioStyles = requireCheckboxRadioStylesEabaca96();
	const required = requireRequiredBc18b612();
	const isRequiredAndParentNotRequired = requireIsRequiredAndParentNotRequired0b84c8cc();
	const theme = requireThemeBfc10573();
	const getOnlyChildOfKindHTMLElementOrThrow = requireGetOnlyChildOfKindHTMLElementOrThrowF6972c1c();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const escapeHashCharacter = requireEscapeHashCharacter072604c4();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const borderRadiusMedium = requireBorderRadiusMedium758b9411();
	requireColorSchemeStyles81696be8();
	requireHoverMediaQueryF2ccfc24();
	requireFontLineHeight78b03658();
	requireTextSmallStyle7246779a();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireSpacingStaticSmall2130ed04();
	requireHasNamedSlot28c6bca1();
	requireGetNamedSlotA433c432();
	requireSpacingStaticXSmallB7d708b8();
	requireIsParentFieldsetRequired6f3a68ad();
	requireIsParentOfKindA9c351f2();
	requireGetDirectChildHTMLElements0adb2021();
	requireGetHTMLElements21fc87cc();
	requireTransformSelectorToDirectChildSelector08da8668();

	const getCheckedSVGBackgroundImage = (fill) => {
	  return escapeHashCharacter.getInlineSVGBackgroundImage(`<path fill="${fill}" d="m20.22,7.47l-1.47-1.42-9.26,9.02-4.24-4.15-1.47,1.42,5.71,5.6,10.73-10.47Z"/>`);
	};
	const getIndeterminateSVGBackgroundImage = (fill) => {
	  return escapeHashCharacter.getInlineSVGBackgroundImage(`<path fill="${fill}" d="m20,11v2H4v-2h16Z"/>`);
	};
	const getComponentCss = (hideLabel, state, isDisabled, isLoading, theme) => {
	  const { canvasColor } = validateProps.getHighContrastColors();
	  const checkedIconColor = validateProps.isHighContrastMode
	    ? canvasColor
	    : escapeHashCharacter.escapeHashCharacter(validateProps.getInvertedThemedColors(theme).primaryColor);
	  const checkedIconColorDark = validateProps.isHighContrastMode
	    ? canvasColor
	    : escapeHashCharacter.escapeHashCharacter(validateProps.getInvertedThemedColors('dark').primaryColor);
	  const indeterminateIconColor = validateProps.isHighContrastMode
	    ? canvasColor
	    : escapeHashCharacter.escapeHashCharacter(validateProps.getThemedColors(theme).primaryColor);
	  const indeterminateIconColorDark = validateProps.isHighContrastMode
	    ? canvasColor
	    : escapeHashCharacter.escapeHashCharacter(validateProps.getThemedColors('dark').primaryColor);
	  return validateProps.getCss(validateProps.mergeDeep(checkboxRadioStyles.getCheckboxRadioJssStyle(hideLabel, state, isDisabled, isLoading, theme), {
	    '@global': {
	      '::slotted': validateProps.addImportantToEachRule({
	        '&(input)': {
	          borderRadius: borderRadiusSmall.borderRadiusSmall,
	        },
	        ...(!isLoading && {
	          '&(input:checked)': {
	            backgroundImage: getCheckedSVGBackgroundImage(checkedIconColor),
	            ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	              backgroundImage: getCheckedSVGBackgroundImage(checkedIconColorDark),
	            }),
	          },
	        }),
	        '&(input:indeterminate)': {
	          backgroundImage: getIndeterminateSVGBackgroundImage(indeterminateIconColor),
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	            backgroundImage: getIndeterminateSVGBackgroundImage(indeterminateIconColorDark),
	          }),
	        },
	        ...(!isDisabled && {
	          '&(input:focus)::before': {
	            borderRadius: borderRadiusMedium.borderRadiusMedium,
	          },
	        }),
	      }),
	    },
	  }));
	};

	const propTypes = {
	  label: validateProps.AllowedTypes.string,
	  state: validateProps.AllowedTypes.oneOf(required.FORM_STATES),
	  message: validateProps.AllowedTypes.string,
	  hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	  loading: validateProps.AllowedTypes.boolean,
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const CheckboxWrapper = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.onLabelClick = (event) => {
	      /**
	       * we only want to simulate the input click by label click
	       * also we don't want to click to the input, if a link is clicked.
	       */
	      if (getClosestHTMLElement.getClosestHTMLElement(event.target, 'a') === null) {
	        this.input.click();
	      }
	    };
	    this.observeAttributes = () => {
	      validateProps.observeAttributes(this.input, ['disabled', 'required'], () => validateProps.forceUpdate(this.host));
	    };
	    this.label = '';
	    this.state = 'none';
	    this.message = '';
	    this.hideLabel = false;
	    this.loading = false;
	    this.theme = 'light';
	  }
	  onKeydown(e) {
	    const { key } = e;
	    if ((key === ' ' || key === 'Spacebar') && isDisabledOrLoading.isDisabledOrLoading(this.input.disabled, this.loading)) {
	      e.preventDefault();
	    }
	  }
	  connectedCallback() {
	    this.observeAttributes(); // on every reconnect
	  }
	  componentWillLoad() {
	    this.input = getOnlyChildOfKindHTMLElementOrThrow.getOnlyChildOfKindHTMLElementOrThrow(this.host, 'input[type=checkbox]');
	    checkboxRadioStyles.addChangeListener(this.input);
	    this.observeAttributes(); // once initially
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  componentDidRender() {
	    /*
	     * This is a workaround to improve accessibility because the input and the label/description/message text are placed in different DOM.
	     * Referencing ID's from outside the component is impossible because the web component’s DOM is separate.
	     * We have to wait for full support of the Accessibility Object Model (AOM) to provide the relationship between shadow DOM and slots
	     */
	    validateProps.setAriaAttributes(this.input, {
	      label: this.label,
	      message: this.message,
	      state: this.state,
	    });
	  }
	  disconnectedCallback() {
	    validateProps.unobserveAttributes(this.input);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    validateProps.attachComponentCss(this.host, getComponentCss, this.hideLabel, this.state, this.input.disabled, this.loading, this.theme);
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    return (validateProps.h(validateProps.Host, null, validateProps.h("label", { "aria-disabled": this.loading ? 'true' : null }, required.hasLabel(this.host, this.label) && (validateProps.h("span", { class: "text", onClick: !this.loading && this.onLabelClick }, this.label || validateProps.h("slot", { name: "label" }), isRequiredAndParentNotRequired.isRequiredAndParentNotRequired(this.host, this.input) && validateProps.h(required.Required, null))), validateProps.h("slot", null), this.loading && (validateProps.h(PrefixedTagNames.pSpinner, { class: "spinner", size: "inherit", theme: this.theme, aria: { 'aria-label': `Loading state of ${this.label}` } }))), required.hasMessage(this.host, this.message, this.state) && (validateProps.h(required.StateMessage, { state: this.state, message: this.message, theme: this.theme, host: this.host }))));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	pCheckboxWrapper_cjs_entry.p_checkbox_wrapper = CheckboxWrapper;

	
	return pCheckboxWrapper_cjs_entry;
}

var pContentWrapper_cjs_entry = {};

var warnIfDeprecatedComponentIsUsed80115a1d = {};

var hasRequiredWarnIfDeprecatedComponentIsUsed80115a1d;

function requireWarnIfDeprecatedComponentIsUsed80115a1d () {
	if (hasRequiredWarnIfDeprecatedComponentIsUsed80115a1d) return warnIfDeprecatedComponentIsUsed80115a1d;
	hasRequiredWarnIfDeprecatedComponentIsUsed80115a1d = 1;

	const validateProps = requireValidatePropsC2afb75b();

	const warnIfDeprecatedComponentIsUsed = (host, message) => {
	  validateProps.consoleWarn(`component ${validateProps.getTagNameWithoutPrefix(host)} is deprecated and will be removed with next major release.`, message);
	};

	warnIfDeprecatedComponentIsUsed80115a1d.warnIfDeprecatedComponentIsUsed = warnIfDeprecatedComponentIsUsed;

	
	return warnIfDeprecatedComponentIsUsed80115a1d;
}

var hasRequiredPContentWrapper_cjs_entry;

function requirePContentWrapper_cjs_entry () {
	if (hasRequiredPContentWrapper_cjs_entry) return pContentWrapper_cjs_entry;
	hasRequiredPContentWrapper_cjs_entry = 1;

	Object.defineProperty(pContentWrapper_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const warnIfDeprecatedComponentIsUsed = requireWarnIfDeprecatedComponentIsUsed80115a1d();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const gridExtendedOffsetXXL = requireGridExtendedOffsetXXLC7a41e50();
	const gridExtendedOffsetBase = requireGridExtendedOffsetBaseFb9830f6();
	const gridBasicOffset = requireGridBasicOffsetEafb13d6();
	requireGridGapB5b73e4a();
	requireSpacingFluidMedium88ab712b();

	const gridFullOffset = gridExtendedOffsetXXL._gridPadding;

	const gridNarrowOffsetBase = gridExtendedOffsetBase._gridSafeZoneBase;

	const gridNarrowOffsetS = gridExtendedOffsetXXL._getGridOffsetS('narrow');

	const gridNarrowOffsetXXL = gridExtendedOffsetXXL._getGridOffsetXXL('narrow');

	const gridNarrowOffset = {
	    base: gridNarrowOffsetBase,
	    s: gridNarrowOffsetS,
	    xxl: gridNarrowOffsetXXL,
	};

	const CONTENT_WRAPPER_BACKGROUND_COLORS = ['transparent', 'default'];
	// fluid is deprecated and will be mapped to full
	const CONTENT_WRAPPER_WIDTHS = ['narrow', 'basic', 'extended', 'fluid', 'full'];
	const deprecatedContentWrapperComponentMessage = 'Please use native CSS Grid (https://css-tricks.com/snippets/css/complete-guide-grid) instead in combination with the Porsche Grid utility based on CSS Grid.';

	const widthMap = {
	  narrow: gridNarrowOffset,
	  basic: gridBasicOffset.gridBasicOffset,
	  extended: gridBasicOffset.gridExtendedOffset,
	};
	const getComponentCss = (width) => {
	  return validateProps.getCss({
	    '@global': {
	      ':host': {
	        display: 'block',
	        ...validateProps.addImportantToEachRule({
	          ...colorSchemeStyles.colorSchemeStyles,
	          ...colorSchemeStyles.hostHiddenStyles,
	        }),
	      },
	    },
	    root: {
	      minWidth: 0,
	      ...(['full', 'fluid'].includes(width)
	        ? {
	          padding: `0 ${gridFullOffset}`,
	        }
	        : {
	          padding: `0 ${widthMap[width].base}`,
	          [validateProps.getMediaQueryMin('s')]: {
	            padding: `0 ${widthMap[width].s}`,
	          },
	          [validateProps.getMediaQueryMin('xxl')]: {
	            padding: `0 ${widthMap[width].xxl}`,
	          },
	        }),
	    },
	  });
	};

	const propTypes = {
	  width: validateProps.AllowedTypes.oneOf(CONTENT_WRAPPER_WIDTHS),
	  backgroundColor: validateProps.AllowedTypes.oneOf(CONTENT_WRAPPER_BACKGROUND_COLORS),
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const ContentWrapper = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.width = 'extended';
	    this.backgroundColor = 'transparent';
	    this.theme = 'light';
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    warnIfDeprecatedComponentIsUsed.warnIfDeprecatedComponentIsUsed(this.host, deprecatedContentWrapperComponentMessage);
	    validateProps.attachComponentCss(this.host, getComponentCss, this.width);
	    return (validateProps.h("div", { class: "root" }, validateProps.h("slot", null)));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	pContentWrapper_cjs_entry.p_content_wrapper = ContentWrapper;

	
	return pContentWrapper_cjs_entry;
}

var pCrest_cjs_entry = {};

var hasRequiredPCrest_cjs_entry;

function requirePCrest_cjs_entry () {
	if (hasRequiredPCrest_cjs_entry) return pCrest_cjs_entry;
	hasRequiredPCrest_cjs_entry = 1;

	Object.defineProperty(pCrest_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const getCDNBaseURL = requireGetCDNBaseURLE7722df3();
	const linkAriaAttribute = requireLinkAriaAttribute5de11e89();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();

	const CRESTS_MANIFEST = { "porscheCrest": { "1x": { "png": "porsche-crest.min.d76137cf8cf94822b7aedb534ba88418@1x.png", "webp": "porsche-crest.min.0d0cc89ae5ee57c4c15bd0dbbcbfe5d0@1x.webp" }, "2x": { "png": "porsche-crest.min.8a292fbd35a5155789ddd011585e05c4@2x.png", "webp": "porsche-crest.min.2245c45e99be5a46b4b56e73c43d5c63@2x.webp" }, "3x": { "png": "porsche-crest.min.18d6f02003b0829bac939fade88fd4e6@3x.png", "webp": "porsche-crest.min.19b429278b158b5cb5aa6ce80751e3fe@3x.webp" } } };

	const buildCrestSrcSet = (format) => {
	  return Object.entries(CRESTS_MANIFEST.porscheCrest)
	    .map(([resolution, fileName]) => `${getCDNBaseURL.getCDNBaseURL()}/crest/${fileName[format]} ${resolution}`)
	    .join();
	};
	const buildCrestImgSrc = () => {
	  return `${getCDNBaseURL.getCDNBaseURL()}/crest/${CRESTS_MANIFEST.porscheCrest['2x'].png}`;
	};
	const crestSize = {
	  width: 30,
	  height: 40,
	};

	const { width: width$1, height: height$1 } = crestSize;
	const getDimensionStyle = {
	  maxWidth: `${width$1}px`,
	  maxHeight: `${height$1}px`,
	  width: 'inherit',
	  height: 'inherit',
	};
	const getComponentCss = () => {
	  return validateProps.getCss({
	    '@global': {
	      ':host': {
	        position: 'relative',
	        display: 'inline-block',
	        verticalAlign: 'top',
	        ...validateProps.addImportantToEachRule({
	          outline: 0,
	          boxSizing: 'content-box',
	          ...getDimensionStyle,
	          ...colorSchemeStyles.colorSchemeStyles,
	          ...colorSchemeStyles.hostHiddenStyles,
	        }),
	      },
	      a: {
	        display: 'block',
	        textDecoration: 'none',
	        ...getDimensionStyle,
	        ...validateProps.focusPseudoJssStyle,
	      },
	      picture: {
	        display: 'block',
	        width: `min(${width$1}px, 100%)`,
	        height: `min(${height$1}px, 100%)`,
	      },
	      img: {
	        display: 'block',
	        maxWidth: '100%',
	        maxHeight: '100%',
	        width: 'auto',
	        height: 'auto',
	      },
	    },
	  });
	};

	const propTypes = {
	  href: validateProps.AllowedTypes.string,
	  target: validateProps.AllowedTypes.string,
	  aria: validateProps.AllowedTypes.aria(linkAriaAttribute.LINK_ARIA_ATTRIBUTES),
	};
	const { width, height } = crestSize;
	const Crest = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.href = undefined;
	    this.target = '_self';
	    this.aria = undefined;
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    validateProps.attachComponentCss(this.host, getComponentCss);
	    const picture = window.PDS_SKIP_FETCH ? undefined :  (validateProps.h("picture", null, validateProps.h("source", { key: "webp", srcSet: buildCrestSrcSet('webp'), type: "image/webp" }), validateProps.h("source", { key: "png", srcSet: buildCrestSrcSet('png'), type: "image/png" }), validateProps.h("img", { src: buildCrestImgSrc(), width: width, height: height, alt: "Porsche" })));
	    return (validateProps.h(validateProps.Host, null, this.href === undefined ? (picture) : (validateProps.h("a", { href: this.href, target: this.target, ...validateProps.parseAndGetAriaAttributes(this.aria) }, picture))));
	  }
	  static get delegatesFocus() { return true; }
	  get host() { return validateProps.getElement(this); }
	};

	pCrest_cjs_entry.p_crest = Crest;

	
	return pCrest_cjs_entry;
}

var pDisplay_cjs_entry = {};

var typographyStyles136a56f3 = {};

var hasRequiredTypographyStyles136a56f3;

function requireTypographyStyles136a56f3 () {
	if (hasRequiredTypographyStyles136a56f3) return typographyStyles136a56f3;
	hasRequiredTypographyStyles136a56f3 = 1;

	const validateProps = requireValidatePropsC2afb75b();
	const textIconStyles = requireTextIconStylesDeb3ffbc();
	const isThemeAuto = requireIsThemeAutoC90cd35d();

	// TODO: unit test is missing
	const hasSpecificSlottedTag = (host, tags) => {
	  // TODO: needs to be direct and only child
	  const el = validateProps.getHTMLElement(host, ':first-child');
	  return el?.matches(tags);
	};

	const TEXT_ALIGNS = ['left', 'center', 'right'];

	const getTypographyRootJssStyle = (baseTextStyle, responsiveStyle, align, // eslint-disable-line @typescript-eslint/no-duplicate-type-constituents
	color, // eslint-disable-line @typescript-eslint/no-duplicate-type-constituents
	ellipsis, theme) => {
	  return {
	    margin: 0,
	    padding: 0,
	    ...baseTextStyle,
	    color: textIconStyles.getThemedTypographyColor(theme, color),
	    ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	      color: textIconStyles.getThemedTypographyColor('dark', color),
	    }),
	    textAlign: align,
	    letterSpacing: 'normal',
	    listStyleType: 'none',
	    whiteSpace: 'inherit',
	    ...(ellipsis && {
	      maxWidth: '100%',
	      overflow: 'hidden',
	      textOverflow: 'ellipsis',
	      whiteSpace: 'nowrap',
	    }),
	    ...responsiveStyle,
	  };
	};
	const getTypographySlottedJssStyle = () => {
	  return {
	    margin: 'inherit',
	    padding: 'inherit',
	    fontFamily: 'inherit',
	    fontWeight: 'inherit',
	    fontSize: 'inherit',
	    lineHeight: 'inherit',
	    fontStyle: 'inherit',
	    fontVariant: 'inherit',
	    color: 'inherit',
	    textAlign: 'inherit',
	    overflowWrap: 'inherit',
	    wordWrap: 'inherit',
	    hyphens: 'inherit',
	    whiteSpace: 'inherit',
	    letterSpacing: 'inherit',
	  };
	};

	typographyStyles136a56f3.TEXT_ALIGNS = TEXT_ALIGNS;
	typographyStyles136a56f3.getTypographyRootJssStyle = getTypographyRootJssStyle;
	typographyStyles136a56f3.getTypographySlottedJssStyle = getTypographySlottedJssStyle;
	typographyStyles136a56f3.hasSpecificSlottedTag = hasSpecificSlottedTag;

	
	return typographyStyles136a56f3;
}

var hasRequiredPDisplay_cjs_entry;

function requirePDisplay_cjs_entry () {
	if (hasRequiredPDisplay_cjs_entry) return pDisplay_cjs_entry;
	hasRequiredPDisplay_cjs_entry = 1;

	Object.defineProperty(pDisplay_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const typographyStyles = requireTypographyStyles136a56f3();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const displayShared = requireDisplayShared43dd15a5();
	requireTextIconStylesDeb3ffbc();
	requireIsThemeAutoC90cd35d();
	requireFontLineHeight78b03658();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();

	const fontSizeDisplaySmall = 'clamp(1.8rem, 2.41vw + 1.32rem, 4.21rem)';

	const fontSizeDisplayLarge = 'clamp(2.28rem, 5.2vw + 1.24rem, 7.48rem)';

	const displayLargeStyle = {
	    font: `${displayShared._displayFontPartA}${fontSizeDisplayLarge}${displayShared._displayFontPartB}`,
	};

	const DISPLAY_TAGS = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
	const DISPLAY_SIZES = ['small', 'medium', 'large', 'inherit'];
	const DISPLAY_COLORS = ['primary', 'inherit'];
	const displaySizeToTagMap = {
	  small: 'h3',
	  medium: 'h2',
	  large: 'h1',
	  inherit: 'h1',
	};
	const getDisplayTagType = (host, size, tag) => {
	  if (typographyStyles.hasSpecificSlottedTag(host, DISPLAY_TAGS.join())) {
	    return 'div';
	  }
	  else if (tag) {
	    return tag;
	  }
	  else {
	    return displaySizeToTagMap[size] || 'h1';
	  }
	};

	const sizeMap = {
	  small: fontSizeDisplaySmall,
	  medium: displayShared.fontSizeDisplayMedium,
	  large: fontSizeDisplayLarge,
	};
	const getComponentCss = (size, align, color, ellipsis, theme) => {
	  return validateProps.getCss({
	    '@global': {
	      ':host': {
	        display: 'block',
	        ...validateProps.addImportantToEachRule({
	          ...colorSchemeStyles.colorSchemeStyles,
	          ...colorSchemeStyles.hostHiddenStyles,
	        }),
	      },
	      '::slotted': {
	        [DISPLAY_TAGS.map((i) => `&(${i})`).join()]: validateProps.addImportantToEachRule(typographyStyles.getTypographySlottedJssStyle()),
	      },
	    },
	    root: typographyStyles.getTypographyRootJssStyle(displayLargeStyle, validateProps.buildResponsiveStyles(size, (sizeValue) => ({
	      fontSize: sizeValue === 'inherit' ? sizeValue : sizeMap[sizeValue],
	    })), align, color, ellipsis, theme),
	  });
	};

	const propTypes = {
	  tag: validateProps.AllowedTypes.oneOf([undefined, ...DISPLAY_TAGS]),
	  size: validateProps.AllowedTypes.breakpoint(DISPLAY_SIZES),
	  align: validateProps.AllowedTypes.oneOf(typographyStyles.TEXT_ALIGNS),
	  color: validateProps.AllowedTypes.oneOf(DISPLAY_COLORS),
	  ellipsis: validateProps.AllowedTypes.boolean,
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Display = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.tag = undefined;
	    this.size = 'large';
	    this.align = 'left';
	    this.color = 'primary';
	    this.ellipsis = false;
	    this.theme = 'light';
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    validateProps.attachComponentCss(this.host, getComponentCss, this.size, this.align, this.color, this.ellipsis, this.theme);
	    const TagType = getDisplayTagType(this.host, this.size, this.tag);
	    return (validateProps.h(TagType, { class: "root" }, validateProps.h("slot", null)));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	pDisplay_cjs_entry.p_display = Display;

	
	return pDisplay_cjs_entry;
}

var pDivider_cjs_entry = {};

var hasRequiredPDivider_cjs_entry;

function requirePDivider_cjs_entry () {
	if (hasRequiredPDivider_cjs_entry) return pDivider_cjs_entry;
	hasRequiredPDivider_cjs_entry = 1;

	Object.defineProperty(pDivider_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsedDa5fe664();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed3a5c494c();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	requireHelperE5c4e0db();

	/** @deprecated */
	const DIVIDER_COLORS_DEPRECATED = [
	  'neutral-contrast-high',
	  'neutral-contrast-medium',
	  'neutral-contrast-low',
	];
	const DIVIDER_COLORS = [
	  'contrast-low',
	  'contrast-medium',
	  'contrast-high',
	  ...DIVIDER_COLORS_DEPRECATED,
	];
	const DIVIDER_DIRECTIONS = ['vertical', 'horizontal'];

	const getComponentCss = (color, orientation, theme) => {
	  const { contrastLowColor, contrastMediumColor, contrastHighColor } = validateProps.getThemedColors(theme);
	  const { contrastLowColor: contrastLowColorDark, contrastMediumColor: contrastMediumColorDark, contrastHighColor: contrastHighColorDark, } = validateProps.getThemedColors('dark');
	  const colorMap = {
	    'contrast-low': contrastLowColor,
	    'contrast-medium': contrastMediumColor,
	    'contrast-high': contrastHighColor,
	  };
	  const colorMapDark = {
	    'contrast-low': contrastLowColorDark,
	    'contrast-medium': contrastMediumColorDark,
	    'contrast-high': contrastHighColorDark,
	  };
	  return validateProps.getCss({
	    '@global': {
	      ':host': {
	        display: 'block',
	        ...validateProps.addImportantToEachRule({
	          ...colorSchemeStyles.colorSchemeStyles,
	          ...colorSchemeStyles.hostHiddenStyles,
	        }),
	      },
	      hr: {
	        margin: 0,
	        padding: 0,
	        border: 'none',
	        textAlign: 'left',
	        ...(validateProps.isHighContrastMode
	          ? {
	            background: validateProps.getHighContrastColors().canvasTextColor,
	          }
	          : {
	            background: colorMap[color],
	            ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	              background: colorMapDark[color],
	            }),
	          }),
	        ...validateProps.buildResponsiveStyles(orientation, (o) => o === 'horizontal' ? { height: '1px', width: '100%' } : { height: '100%', width: '1px' }),
	      },
	    },
	  });
	};

	const propTypes = {
	  color: validateProps.AllowedTypes.oneOf(DIVIDER_COLORS),
	  orientation: validateProps.AllowedTypes.breakpoint([undefined, ...DIVIDER_DIRECTIONS]),
	  direction: validateProps.AllowedTypes.breakpoint(DIVIDER_DIRECTIONS),
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Divider = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.color = 'contrast-low';
	    this.orientation = undefined;
	    this.direction = 'horizontal';
	    this.theme = 'light';
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    const deprecationMap = {
	      'neutral-contrast-low': 'contrast-low',
	      'neutral-contrast-medium': 'contrast-medium',
	      'neutral-contrast-high': 'contrast-high',
	    };
	    warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'color', deprecationMap);
	    warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'orientation', 'Please use direction prop instead.');
	    validateProps.attachComponentCss(this.host, getComponentCss, (deprecationMap[this.color] || this.color), this.orientation || this.direction, this.theme);
	    return validateProps.h("hr", null);
	  }
	  get host() { return validateProps.getElement(this); }
	};

	pDivider_cjs_entry.p_divider = Divider;

	
	return pDivider_cjs_entry;
}

var pFieldsetWrapper_cjs_entry = {};

var hasRequiredPFieldsetWrapper_cjs_entry;

function requirePFieldsetWrapper_cjs_entry () {
	if (hasRequiredPFieldsetWrapper_cjs_entry) return pFieldsetWrapper_cjs_entry;
	hasRequiredPFieldsetWrapper_cjs_entry = 1;

	Object.defineProperty(pFieldsetWrapper_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const required = requireRequiredBc18b612();
	const warnIfDeprecatedComponentIsUsed = requireWarnIfDeprecatedComponentIsUsed80115a1d();
	const theme = requireThemeBfc10573();
	const fieldsetUtils = requireFieldsetUtils1fdf9685();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();
	const headingSmallStyle = requireHeadingSmallStyle0707b97f();
	requireHasNamedSlot28c6bca1();
	requireGetNamedSlotA433c432();
	requireSpacingStaticXSmallB7d708b8();
	requireTextSmallStyle7246779a();
	requireTextShared9135e2ef();
	requireFontLineHeight78b03658();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireHeadingSharedAa59e66d();
	requireFontWeightSemiBold4482c830();
	requireFontSizeHeadingMediumC49ab5a2();
	requireFontSizeTextMedium88887ad8();
	requireFontSizeHeadingSmallA15141a5();

	const getComponentCss = (state, labelSize, hasLabel, theme) => {
	  return validateProps.getCss({
	    '@global': {
	      ':host': validateProps.addImportantToEachRule({
	        display: 'block',
	        ...colorSchemeStyles.colorSchemeStyles,
	        ...colorSchemeStyles.hostHiddenStyles,
	      }),
	      fieldset: {
	        margin: 0,
	        padding: 0,
	        border: 'none',
	      },
	      ...(hasLabel && {
	        legend: {
	          margin: `0 0 ${spacingStaticMedium.spacingStaticMedium}`,
	          padding: 0,
	          color: validateProps.getThemedColors(theme).primaryColor,
	          ...(labelSize === 'small' ? headingSmallStyle.headingSmallStyle : fieldsetUtils.headingMediumStyle),
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	            color: validateProps.getThemedColors('dark').primaryColor,
	          }),
	        },
	      }),
	    },
	    ...required.getFunctionalComponentRequiredStyles(),
	    ...validateProps.mergeDeep(required.getFunctionalComponentStateMessageStyles(theme, state), {
	      message: {
	        marginTop: spacingStaticMedium.spacingStaticMedium,
	      },
	    }),
	  });
	};

	const propTypes = {
	  label: validateProps.AllowedTypes.string,
	  labelSize: validateProps.AllowedTypes.oneOf(fieldsetUtils.FIELDSET_LABEL_SIZES),
	  required: validateProps.AllowedTypes.boolean,
	  state: validateProps.AllowedTypes.oneOf(required.FORM_STATES),
	  message: validateProps.AllowedTypes.string,
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const FieldsetWrapper = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.label = '';
	    this.labelSize = 'medium';
	    this.required = false;
	    this.state = 'none';
	    this.message = '';
	    this.theme = 'light';
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    warnIfDeprecatedComponentIsUsed.warnIfDeprecatedComponentIsUsed(this.host, 'Please use new p-fieldset component instead.');
	    validateProps.attachComponentCss(this.host, getComponentCss, this.state, this.labelSize, required.hasLabel(this.host, this.label), this.theme);
	    const messageId = 'message';
	    const hasMessageValue = required.hasMessage(this.host, this.message, this.state);
	    return (validateProps.h("fieldset", { "aria-describedby": hasMessageValue ? messageId : null }, required.hasLabel(this.host, this.label) && (validateProps.h("legend", null, this.label || validateProps.h("slot", { name: "label" }), this.required && validateProps.h(required.Required, null))), validateProps.h("slot", null), hasMessageValue && (validateProps.h(required.StateMessage, { id: messageId, state: this.state, message: this.message, theme: this.theme, host: this.host }))));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	pFieldsetWrapper_cjs_entry.p_fieldset_wrapper = FieldsetWrapper;

	
	return pFieldsetWrapper_cjs_entry;
}

var pFieldset_cjs_entry = {};

var hasRequiredPFieldset_cjs_entry;

function requirePFieldset_cjs_entry () {
	if (hasRequiredPFieldset_cjs_entry) return pFieldset_cjs_entry;
	hasRequiredPFieldset_cjs_entry = 1;

	Object.defineProperty(pFieldset_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const required = requireRequiredBc18b612();
	const theme = requireThemeBfc10573();
	const fieldsetUtils = requireFieldsetUtils1fdf9685();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();
	const headingSmallStyle = requireHeadingSmallStyle0707b97f();
	requireHasNamedSlot28c6bca1();
	requireGetNamedSlotA433c432();
	requireSpacingStaticXSmallB7d708b8();
	requireTextSmallStyle7246779a();
	requireTextShared9135e2ef();
	requireFontLineHeight78b03658();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireHeadingSharedAa59e66d();
	requireFontWeightSemiBold4482c830();
	requireFontSizeHeadingMediumC49ab5a2();
	requireFontSizeTextMedium88887ad8();
	requireFontSizeHeadingSmallA15141a5();

	const getComponentCss = (state, labelSize, hasLabel, theme) => {
	  return validateProps.getCss({
	    '@global': {
	      ':host': validateProps.addImportantToEachRule({
	        display: 'block',
	        ...colorSchemeStyles.colorSchemeStyles,
	        ...colorSchemeStyles.hostHiddenStyles,
	      }),
	      fieldset: {
	        margin: 0,
	        padding: 0,
	        border: 'none',
	      },
	      ...(hasLabel && {
	        legend: {
	          margin: `0 0 ${spacingStaticMedium.spacingStaticMedium}`,
	          padding: 0,
	          color: validateProps.getThemedColors(theme).primaryColor,
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	            color: validateProps.getThemedColors('dark').primaryColor,
	          }),
	          ...(labelSize === 'small' ? headingSmallStyle.headingSmallStyle : fieldsetUtils.headingMediumStyle),
	        },
	      }),
	    },
	    ...required.getFunctionalComponentRequiredStyles(),
	    ...validateProps.mergeDeep(required.getFunctionalComponentStateMessageStyles(theme, state), {
	      message: {
	        marginTop: spacingStaticMedium.spacingStaticMedium,
	      },
	    }),
	  });
	};

	const propTypes = {
	  label: validateProps.AllowedTypes.string,
	  labelSize: validateProps.AllowedTypes.oneOf(fieldsetUtils.FIELDSET_LABEL_SIZES),
	  required: validateProps.AllowedTypes.boolean,
	  state: validateProps.AllowedTypes.oneOf(required.FORM_STATES),
	  message: validateProps.AllowedTypes.string,
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Fieldset = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.label = '';
	    this.labelSize = 'medium';
	    this.required = false;
	    this.state = 'none';
	    this.message = '';
	    this.theme = 'light';
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    validateProps.attachComponentCss(this.host, getComponentCss, this.state, this.labelSize, required.hasLabel(this.host, this.label), this.theme);
	    const messageId = 'message';
	    const hasMessageValue = required.hasMessage(this.host, this.message, this.state);
	    return (validateProps.h("fieldset", { "aria-describedby": hasMessageValue ? messageId : null }, required.hasLabel(this.host, this.label) && (validateProps.h("legend", null, this.label || validateProps.h("slot", { name: "label" }), this.required && validateProps.h(required.Required, null))), validateProps.h("slot", null), hasMessageValue && (validateProps.h(required.StateMessage, { id: messageId, state: this.state, message: this.message, theme: this.theme, host: this.host }))));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	pFieldset_cjs_entry.p_fieldset = Fieldset;

	
	return pFieldset_cjs_entry;
}

var pFlex_2_cjs_entry = {};

var throwIfParentIsNotOfKind99386afd = {};

var hasRequiredThrowIfParentIsNotOfKind99386afd;

function requireThrowIfParentIsNotOfKind99386afd () {
	if (hasRequiredThrowIfParentIsNotOfKind99386afd) return throwIfParentIsNotOfKind99386afd;
	hasRequiredThrowIfParentIsNotOfKind99386afd = 1;

	const validateProps = requireValidatePropsC2afb75b();
	const isParentOfKind = requireIsParentOfKindA9c351f2();

	const throwIfParentIsNotOfKind = (element, tagName) => {
	  if (element.parentElement && !isParentOfKind.isParentOfKind(element, tagName)) {
	    const allowedTagName = validateProps.getPrefixedTagNames(element)[tagName];
	    const actualTagName = validateProps.getTagName(element.parentElement);
	    validateProps.throwException(`parent HTMLElement of ${validateProps.getTagName(element)} should be of kind ${allowedTagName} but got ${actualTagName}.`);
	  }
	};

	throwIfParentIsNotOfKind99386afd.throwIfParentIsNotOfKind = throwIfParentIsNotOfKind;

	
	return throwIfParentIsNotOfKind99386afd;
}

var hasRequiredPFlex_2_cjs_entry;

function requirePFlex_2_cjs_entry () {
	if (hasRequiredPFlex_2_cjs_entry) return pFlex_2_cjs_entry;
	hasRequiredPFlex_2_cjs_entry = 1;

	Object.defineProperty(pFlex_2_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const warnIfDeprecatedComponentIsUsed = requireWarnIfDeprecatedComponentIsUsed80115a1d();
	const throwIfParentIsNotOfKind = requireThrowIfParentIsNotOfKind99386afd();
	requireIsParentOfKindA9c351f2();

	const FLEX_WRAPS = ['nowrap', 'wrap', 'wrap-reverse'];
	const FLEX_DIRECTIONS = ['row', 'row-reverse', 'column', 'column-reverse'];
	const FLEX_JUSTIFY_CONTENTS = [
	  'flex-start',
	  'flex-end',
	  'center',
	  'space-between',
	  'space-around',
	  'space-evenly',
	];
	const FLEX_ALIGN_ITEMS = ['stretch', 'flex-start', 'flex-end', 'center', 'baseline'];
	const FLEX_ALIGN_CONTENTS = [
	  'stretch',
	  'flex-start',
	  'flex-end',
	  'center',
	  'space-between',
	  'space-around',
	  'space-evenly',
	];
	const deprecatedFlexComponentMessage = 'Please use native CSS Flex (https://css-tricks.com/snippets/css/a-guide-to-flexbox) instead for better performance and more standardized layout technique.';

	const getComponentCss$1 = (inline, wrap, direction, justifyContent, alignItems, alignContent) => {
	  return validateProps.getCss({
	    '@global': {
	      ':host': validateProps.addImportantToEachRule(validateProps.mergeDeep(colorSchemeStyles.colorSchemeStyles, colorSchemeStyles.hostHiddenStyles, validateProps.buildResponsiveStyles(inline, (inlineResponsive) => ({
	        display: inlineResponsive ? 'inline-flex' : 'flex',
	      })), validateProps.buildResponsiveStyles(wrap, (flexWrapResponsive) => ({ flexWrap: flexWrapResponsive })), validateProps.buildResponsiveStyles(direction, (flexDirectionResponsive) => ({
	        flexDirection: flexDirectionResponsive,
	      })), validateProps.buildResponsiveStyles(justifyContent, (justifyContentResponsive) => ({
	        justifyContent: justifyContentResponsive,
	      })), validateProps.buildResponsiveStyles(alignItems, (alignItemsResponsive) => ({
	        alignItems: alignItemsResponsive,
	      })), validateProps.buildResponsiveStyles(alignContent, (alignContentResponsive) => ({
	        alignContent: alignContentResponsive,
	      })))),
	    },
	  });
	};

	const propTypes$1 = {
	  inline: validateProps.AllowedTypes.breakpoint('boolean'),
	  wrap: validateProps.AllowedTypes.breakpoint(FLEX_WRAPS),
	  direction: validateProps.AllowedTypes.breakpoint(FLEX_DIRECTIONS),
	  justifyContent: validateProps.AllowedTypes.breakpoint(FLEX_JUSTIFY_CONTENTS),
	  alignItems: validateProps.AllowedTypes.breakpoint(FLEX_ALIGN_ITEMS),
	  alignContent: validateProps.AllowedTypes.breakpoint(FLEX_ALIGN_CONTENTS),
	};
	const Flex = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.inline = false;
	    this.wrap = 'nowrap';
	    this.direction = 'row';
	    this.justifyContent = 'flex-start';
	    this.alignItems = 'stretch';
	    this.alignContent = 'stretch';
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes$1);
	    warnIfDeprecatedComponentIsUsed.warnIfDeprecatedComponentIsUsed(this.host, deprecatedFlexComponentMessage);
	    validateProps.attachComponentCss(this.host, getComponentCss$1, this.inline, this.wrap, this.direction, this.justifyContent, this.alignItems, this.alignContent);
	    return validateProps.h("slot", null);
	  }
	  get host() { return validateProps.getElement(this); }
	};

	const flexItemWidths = {
	  none: 0,
	  'one-quarter': 25,
	  'one-third': 33.333333,
	  half: 50,
	  'two-thirds': 66.666667,
	  'three-quarters': 75,
	  full: 100,
	  auto: 'auto',
	};
	const getComponentCss = (width, offset, alignSelf, grow, shrink, flex) => {
	  return validateProps.getCss({
	    '@global': {
	      ':host': validateProps.addImportantToEachRule({
	        boxSizing: 'border-box',
	        ...colorSchemeStyles.hostHiddenStyles,
	        ...validateProps.mergeDeep(validateProps.buildResponsiveStyles(width, (widthResponsive) => ({
	          width: `${flexItemWidths[widthResponsive]}%`,
	        })), validateProps.buildResponsiveStyles(offset, (offsetResponsive) => ({
	          marginLeft: `${flexItemWidths[offsetResponsive]}%`,
	        })), validateProps.buildResponsiveStyles(alignSelf, (alignSelfResponsive) => ({
	          alignSelf: alignSelfResponsive,
	        })), flex !== 'initial' // flex shorthand conflicts with grow and shrink, which means even default grow or shrink props would override flex
	          ? validateProps.buildResponsiveStyles(flex, (flexResponsive) => ({
	            flex: flexResponsive === 'equal' ? '1 1 0' : flexResponsive,
	          }))
	          : validateProps.mergeDeep(validateProps.buildResponsiveStyles(grow, (flexGrow) => ({ flexGrow })), validateProps.buildResponsiveStyles(shrink, (flexShrink) => ({ flexShrink })))),
	      }),
	    },
	  });
	};

	const FLEX_ITEM_WIDTHS = [
	  'auto',
	  'one-quarter',
	  'one-third',
	  'half',
	  'two-thirds',
	  'three-quarters',
	  'full',
	];
	const FLEX_ITEM_OFFSETS = ['none', 'one-quarter', 'one-third', 'half', 'two-thirds', 'three-quarters'];
	const FLEX_ITEM_ALIGN_SELFS = ['auto', 'flex-start', 'flex-end', 'center', 'baseline', 'stretch'];
	const FLEX_ITEM_GROWS = [0, 1];
	const FLEX_ITEM_SHRINKS = [0, 1];
	const FLEX_ITEM_FLEXS = ['initial', 'auto', 'none', 'equal'];

	const propTypes = {
	  width: validateProps.AllowedTypes.breakpoint(FLEX_ITEM_WIDTHS),
	  offset: validateProps.AllowedTypes.breakpoint(FLEX_ITEM_OFFSETS),
	  alignSelf: validateProps.AllowedTypes.breakpoint(FLEX_ITEM_ALIGN_SELFS),
	  grow: validateProps.AllowedTypes.breakpoint(FLEX_ITEM_GROWS),
	  shrink: validateProps.AllowedTypes.breakpoint(FLEX_ITEM_SHRINKS),
	  flex: validateProps.AllowedTypes.breakpoint(FLEX_ITEM_FLEXS),
	};
	const FlexItem = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.width = 'auto';
	    this.offset = 'none';
	    this.alignSelf = 'auto';
	    this.grow = 0;
	    this.shrink = 1;
	    this.flex = 'initial';
	  }
	  connectedCallback() {
	    throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-flex');
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    warnIfDeprecatedComponentIsUsed.warnIfDeprecatedComponentIsUsed(this.host, deprecatedFlexComponentMessage);
	    validateProps.attachComponentCss(this.host, getComponentCss, this.width, this.offset, this.alignSelf, this.grow, this.shrink, this.flex);
	    return validateProps.h("slot", null);
	  }
	  get host() { return validateProps.getElement(this); }
	};

	pFlex_2_cjs_entry.p_flex = Flex;
	pFlex_2_cjs_entry.p_flex_item = FlexItem;

	
	return pFlex_2_cjs_entry;
}

var pFlyout_cjs_entry = {};

var hasRequiredPFlyout_cjs_entry;

function requirePFlyout_cjs_entry () {
	if (hasRequiredPFlyout_cjs_entry) return pFlyout_cjs_entry;
	hasRequiredPFlyout_cjs_entry = 1;

	Object.defineProperty(pFlyout_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const modalUtils = requireModalUtils9e25e7f9();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const hoverMediaQuery = requireHoverMediaQueryF2ccfc24();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const constants = requireConstantsCa271244();
	const spacingFluidLarge = requireSpacingFluidLarge6087a0f7();
	const gridGap = requireGridGapB5b73e4a();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();
	const hasNamedSlot = requireHasNamedSlot28c6bca1();
	const theme = requireThemeBfc10573();
	requireSpacingFluidMedium88ab712b();
	requireGetNamedSlotA433c432();

	const FLYOUT_POSITIONS = ['left', 'right'];
	const FLYOUT_ARIA_ATTRIBUTES = ['aria-label'];
	// Threshold value to determine the scroll offset at which the shadow should be visible in the flyout
	const FLYOUT_SCROLL_SHADOW_THRESHOLD = 10;

	const headerShadowClass = 'header--shadow';
	const footerShadowClass = 'footer--shadow';
	const flyoutTransitionDuration = '0.5s';
	const flyoutTransitionTimingFunction = 'cubic-bezier(0.77, 0, 0.175, 1)';
	const cssVariableWidth = '--p-flyout-width';
	const cssVariableMaxWidth = '--p-flyout-max-width';
	const maxWidthDefault = '1180px';
	const minWidthDefault = '320px';
	const getComponentCss = (isOpen, position, hasHeader, hasFooter, hasSubFooter, theme) => {
	  const { primaryColor, backgroundColor } = validateProps.getThemedColors(theme);
	  const { primaryColor: primaryColorDark, backgroundColor: backgroundColorDark } = validateProps.getThemedColors('dark');
	  const { contrastHighColor: darkThemeContrastHighColor } = validateProps.getThemedColors('dark');
	  const isPositionLeft = position === 'left';
	  const contentPadding = `${spacingStaticMedium.spacingStaticMedium} ${spacingFluidLarge.spacingFluidLarge}`;
	  const isDark = validateProps.isThemeDark(theme);
	  const shadowColor = isDark ? modalUtils.scrollShadowColorDark : modalUtils.scrollShadowColor;
	  const transparentColorDark = 'rgba(14, 14, 18, 0)';
	  const transparentColor = isDark ? transparentColorDark : 'rgba(255, 255, 255, 0)';
	  return validateProps.getCss({
	    '@global': validateProps.addImportantToEachRule({
	      ':host': {
	        // needed for correct alignment of the Porsche Grid within the Flyout
	        '--pds-internal-grid-outer-column': `calc(${spacingFluidLarge.spacingFluidLarge} - ${gridGap.gridGap})`,
	        '--pds-internal-grid-margin': `calc(${spacingFluidLarge.spacingFluidLarge} * -1)`,
	        display: 'flex',
	        position: 'fixed',
	        zIndex: constants.FLYOUT_Z_INDEX,
	        ...(isOpen
	          ? {
	            visibility: 'inherit',
	          }
	          : {
	            visibility: 'hidden',
	            transition: `visibility 0s linear ${flyoutTransitionDuration}`,
	          }),
	        ...validateProps.getInsetJssStyle(),
	        ...validateProps.getFrostedGlassBackgroundJssStyles(isOpen, flyoutTransitionDuration),
	        ...colorSchemeStyles.colorSchemeStyles,
	        ...colorSchemeStyles.hostHiddenStyles,
	      },
	    }),
	    header: {
	      display: 'flex',
	      ...(hasHeader && {
	        flexDirection: 'row-reverse',
	      }),
	      justifyContent: 'flex-end',
	      background: backgroundColor,
	      ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	        background: backgroundColorDark,
	      }),
	      position: 'sticky',
	      top: 0,
	      zIndex: 2,
	    },
	    [headerShadowClass]: {
	      boxShadow: `${isDark ? modalUtils.scrollShadowColorDark : modalUtils.scrollShadowColor} 0px 5px 10px`,
	      ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	        boxShadow: `${modalUtils.scrollShadowColorDark} 0px 5px 10px`,
	      }),
	    },
	    ...(hasHeader && {
	      'header-content': {
	        flex: 'auto',
	        padding: `${spacingStaticMedium.spacingStaticMedium} 0 ${spacingStaticMedium.spacingStaticMedium} ${spacingFluidLarge.spacingFluidLarge}`,
	      },
	    }),
	    dismiss: {
	      margin: spacingStaticMedium.spacingStaticMedium,
	      height: 'fit-content',
	      border: `2px solid ${backgroundColor}`,
	      borderRadius: '4px',
	      background: backgroundColor,
	      ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	        borderColor: backgroundColorDark,
	        background: backgroundColorDark,
	      }),
	      ...hoverMediaQuery.hoverMediaQuery({
	        '&:hover': {
	          background: darkThemeContrastHighColor,
	          borderColor: darkThemeContrastHighColor,
	        },
	      }),
	    },
	    root: {
	      color: primaryColor,
	      display: 'flex',
	      flexDirection: 'column',
	      position: 'relative',
	      [isPositionLeft ? 'marginRight' : 'marginLeft']: 'auto',
	      boxSizing: 'border-box',
	      ...(hasSubFooter && {
	        overflowY: 'auto',
	        overscrollBehaviorY: 'none',
	      }),
	      width: `var(${cssVariableWidth}, auto)`,
	      height: '100%',
	      minWidth: minWidthDefault,
	      maxWidth: `var(${cssVariableMaxWidth}, ${maxWidthDefault})`,
	      background: backgroundColor,
	      opacity: isOpen ? 1 : 0,
	      transform: isOpen ? 'initial' : `translate3d(${isPositionLeft ? '-100%' : '100%'}, 0, 0)`,
	      transition: `opacity ${flyoutTransitionDuration} ${flyoutTransitionTimingFunction} ${isOpen ? '0s' : flyoutTransitionDuration}, transform ${flyoutTransitionDuration} ${flyoutTransitionTimingFunction}`,
	      boxShadow: `${isPositionLeft ? '3px' : '-3px'} 0px 30px rgba(0, 0, 0, 0.25)`,
	      ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	        color: primaryColorDark,
	        background: backgroundColorDark,
	      }),
	    },
	    content: {
	      padding: contentPadding,
	      position: 'relative',
	      zIndex: 0,
	      // If sub-footer is used scroll shadows have to be done via JS
	      ...(!hasSubFooter && {
	        overflowY: 'auto',
	        WebkitOverflowScrolling: 'touch',
	        backgroundImage: `linear-gradient(to top, ${backgroundColor}, ${backgroundColor}), linear-gradient(to top, ${backgroundColor}, ${backgroundColor}), linear-gradient(to top, ${shadowColor}, ${transparentColor}), linear-gradient(to bottom, ${shadowColor}, ${transparentColor})`,
	        backgroundPosition: 'bottom center, top center, bottom center, top center',
	        backgroundRepeat: 'no-repeat',
	        backgroundSize: '100% 20px, 100% 20px, 100% 10px, 100% 10px',
	        backgroundAttachment: 'local, local, scroll, scroll',
	        overscrollBehaviorY: 'none',
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          backgroundImage: `linear-gradient(to top, ${backgroundColorDark}, ${backgroundColorDark}), linear-gradient(to top, ${backgroundColorDark}, ${backgroundColorDark}), linear-gradient(to top, ${modalUtils.scrollShadowColorDark}, ${transparentColorDark}), linear-gradient(to bottom, ${modalUtils.scrollShadowColorDark}, ${transparentColorDark})`,
	        }),
	      }),
	    },
	    ...(hasFooter && {
	      footer: {
	        background: backgroundColor,
	        padding: contentPadding,
	        position: 'sticky',
	        zIndex: 1,
	        bottom: 0,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          background: backgroundColorDark,
	        }),
	      },
	      [footerShadowClass]: {
	        boxShadow: `${isDark ? modalUtils.scrollShadowColorDark : modalUtils.scrollShadowColor} 0px -5px 10px`,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          boxShadow: `${modalUtils.scrollShadowColorDark} 0px -5px 10px`,
	        }),
	      },
	    }),
	    ...(hasSubFooter && {
	      'sub-footer': {
	        padding: contentPadding,
	      },
	    }),
	  });
	};

	const propTypes = {
	  open: validateProps.AllowedTypes.boolean,
	  position: validateProps.AllowedTypes.oneOf(FLYOUT_POSITIONS),
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	  aria: validateProps.AllowedTypes.aria(FLYOUT_ARIA_ATTRIBUTES),
	};
	const Flyout = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.dismiss = validateProps.createEvent(this, "dismiss", 3);
	    this.onMouseDown = (e) => {
	      if (e.composedPath()[0] === this.host && !modalUtils.clickStartedInScrollbarTrack(this.host, e)) {
	        this.dismissFlyout();
	      }
	    };
	    this.updateFocusTrap = (isOpen) => {
	      modalUtils.setFocusTrap(this.host, isOpen, this.dismissBtn, this.dismissFlyout);
	    };
	    // eslint-disable-next-line @typescript-eslint/member-ordering
	    this.onScroll = validateProps.throttle(100, () => {
	      if (this.dialog.scrollHeight > this.dialog.clientHeight) {
	        this.updateHeaderShadow();
	        if (this.hasFooter) {
	          this.updateFooterShadow();
	        }
	      }
	    });
	    this.updateHeaderShadow = () => {
	      const shouldApplyShadow = this.dialog.scrollTop > FLYOUT_SCROLL_SHADOW_THRESHOLD;
	      this.header.classList.toggle(headerShadowClass, shouldApplyShadow);
	    };
	    this.updateFooterShadow = () => {
	      const shouldApplyShadow = this.subFooter.offsetTop > this.dialog.clientHeight + this.dialog.scrollTop;
	      this.footer.classList.toggle(footerShadowClass, shouldApplyShadow);
	    };
	    this.dismissFlyout = () => {
	      this.dismiss.emit();
	    };
	    this.open = false;
	    this.position = 'right';
	    this.theme = 'light';
	    this.aria = undefined;
	  }
	  openChangeHandler(isOpen) {
	    modalUtils.setScrollLock(isOpen);
	    this.updateFocusTrap(isOpen);
	    if (isOpen) {
	      if (this.hasSubFooter) {
	        this.onScroll();
	      }
	      this.focusedElBeforeOpen = document.activeElement;
	    }
	    else {
	      this.focusedElBeforeOpen?.focus();
	    }
	  }
	  componentDidLoad() {
	    // in case flyout is rendered with open prop
	    if (this.open) {
	      modalUtils.setScrollLock(true);
	      this.updateFocusTrap(true);
	    }
	    // TODO: would be great to use this in jsx but that doesn't work reliable and causes focus e2e test to fail
	    validateProps.getShadowRootHTMLElement(this.host, 'slot').addEventListener('slotchange', () => {
	      if (this.open) {
	        // 1 tick delay is needed so that web components can be bootstrapped
	        setTimeout(() => {
	          this.updateFocusTrap(true);
	          validateProps.getShadowRootHTMLElement(this.dismissBtn, 'button').focus(); // set initial focus
	        });
	      }
	    });
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  componentDidRender() {
	    if (this.open) {
	      if (this.hasSubFooter) {
	        this.onScroll();
	      }
	      // Necessary to select button to make :focus-visible work
	      validateProps.getShadowRootHTMLElement(this.dismissBtn, 'button').focus();
	    }
	  }
	  disconnectedCallback() {
	    modalUtils.setFocusTrap(this.host, false);
	    modalUtils.setScrollLock(false);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    this.hasHeader = hasNamedSlot.hasNamedSlot(this.host, 'header');
	    this.hasFooter = hasNamedSlot.hasNamedSlot(this.host, 'footer');
	    this.hasSubFooter = hasNamedSlot.hasNamedSlot(this.host, 'sub-footer');
	    validateProps.attachComponentCss(this.host, getComponentCss, this.open, this.position, this.hasHeader, this.hasFooter, this.hasSubFooter, this.theme);
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    const dismissBtn = (validateProps.h(PrefixedTagNames.pButtonPure, { class: "dismiss", type: "button", hideLabel: true, icon: "close", theme: this.theme, onClick: this.dismissFlyout, ref: (el) => (this.dismissBtn = el) }, "Dismiss flyout"));
	    return (validateProps.h(validateProps.Host, { onMouseDown: this.onMouseDown }, validateProps.h("div", { class: "root", role: "dialog", ...validateProps.parseAndGetAriaAttributes({
	        'aria-modal': true,
	        'aria-hidden': !this.open,
	        ...validateProps.parseAndGetAriaAttributes(this.aria),
	      }), tabIndex: -1, ref: (el) => (this.dialog = el), ...(this.hasSubFooter && { onScroll: this.onScroll }) }, validateProps.h("div", { class: "header", ref: (el) => (this.header = el) }, dismissBtn, this.hasHeader && (validateProps.h("div", { class: "header-content" }, validateProps.h("slot", { name: "header" })))), validateProps.h("div", { class: "content" }, validateProps.h("slot", null)), this.hasFooter && (validateProps.h("div", { class: "footer", ref: (el) => (this.footer = el) }, validateProps.h("slot", { name: "footer" }))), this.hasSubFooter && (validateProps.h("div", { class: "sub-footer", ref: (el) => (this.subFooter = el) }, validateProps.h("slot", { name: "sub-footer" }))))));
	  }
	  get host() { return validateProps.getElement(this); }
	  static get watchers() { return {
	    "open": ["openChangeHandler"]
	  }; }
	};

	pFlyout_cjs_entry.p_flyout = Flyout;

	
	return pFlyout_cjs_entry;
}

var pGrid_2_cjs_entry = {};

var hasRequiredPGrid_2_cjs_entry;

function requirePGrid_2_cjs_entry () {
	if (hasRequiredPGrid_2_cjs_entry) return pGrid_2_cjs_entry;
	hasRequiredPGrid_2_cjs_entry = 1;

	Object.defineProperty(pGrid_2_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const gridGap = requireGridGapB5b73e4a();
	const warnIfDeprecatedComponentIsUsed = requireWarnIfDeprecatedComponentIsUsed80115a1d();
	const throwIfParentIsNotOfKind = requireThrowIfParentIsNotOfKind99386afd();
	requireSpacingFluidMedium88ab712b();
	requireIsParentOfKindA9c351f2();

	const GRID_DIRECTIONS = ['row', 'row-reverse', 'column', 'column-reverse'];
	const GRID_WRAPS = ['nowrap', 'wrap'];
	const GRID_GUTTERS = [16, 24, 36];
	const deprecatedGridComponentMessage = 'Please use native CSS Grid (https://css-tricks.com/snippets/css/complete-guide-grid) instead in combination with the Porsche Grid utility based on CSS Grid.';

	const gutter$1 = `calc(${gridGap.gridGap} / -2)`;
	const getComponentCss$1 = (direction, wrap) => {
	  return validateProps.getCss({
	    '@global': {
	      ':host': validateProps.addImportantToEachRule({
	        display: 'flex',
	        flex: 'auto',
	        width: 'auto',
	        marginLeft: gutter$1,
	        marginRight: gutter$1,
	        ...colorSchemeStyles.colorSchemeStyles,
	        ...colorSchemeStyles.hostHiddenStyles,
	        ...validateProps.mergeDeep(validateProps.buildResponsiveStyles(direction, (flexDirection) => ({ flexDirection })), validateProps.buildResponsiveStyles(wrap, (flexWrap) => ({ flexWrap }))),
	      }),
	    },
	  });
	};

	const propTypes$1 = {
	  direction: validateProps.AllowedTypes.breakpoint(GRID_DIRECTIONS),
	  wrap: validateProps.AllowedTypes.breakpoint(GRID_WRAPS),
	  gutter: validateProps.AllowedTypes.breakpoint(GRID_GUTTERS),
	};
	const Grid = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.direction = 'row';
	    this.wrap = 'wrap';
	    this.gutter = { base: 16, s: 24, m: 36 };
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes$1);
	    warnIfDeprecatedComponentIsUsed.warnIfDeprecatedComponentIsUsed(this.host, deprecatedGridComponentMessage);
	    validateProps.attachComponentCss(this.host, getComponentCss$1, this.direction, this.wrap);
	    return validateProps.h("slot", null);
	  }
	  get host() { return validateProps.getElement(this); }
	};

	const GRID_ITEM_SIZES = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
	const GRID_ITEM_OFFSETS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];

	const gutter = `calc(${gridGap.gridGap} / 2)`;
	const gridItemWidths = [
	  0, 8.333333, 16.666667, 25, 33.333333, 41.666667, 50, 58.333333, 66.666667, 75, 83.333333, 91.666667, 100,
	];
	const getComponentCss = (size, offset) => {
	  return validateProps.getCss({
	    '@global': {
	      ':host': validateProps.addImportantToEachRule({
	        paddingLeft: gutter,
	        paddingRight: gutter,
	        boxSizing: 'border-box',
	        ...colorSchemeStyles.hostHiddenStyles,
	        ...validateProps.mergeDeep(validateProps.buildResponsiveStyles(size, (sizeResponsive) => ({
	          width: `${gridItemWidths[sizeResponsive]}%`,
	          minWidth: `${gridItemWidths[sizeResponsive]}%`,
	        })), validateProps.buildResponsiveStyles(offset, (offsetResponsive) => ({
	          marginLeft: `${gridItemWidths[offsetResponsive]}%`,
	        }))),
	      }),
	    },
	  });
	};

	const propTypes = {
	  size: validateProps.AllowedTypes.breakpoint(GRID_ITEM_SIZES),
	  offset: validateProps.AllowedTypes.breakpoint(GRID_ITEM_OFFSETS),
	};
	const GridItem = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.size = 1;
	    this.offset = 0;
	  }
	  connectedCallback() {
	    throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-grid');
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    warnIfDeprecatedComponentIsUsed.warnIfDeprecatedComponentIsUsed(this.host, deprecatedGridComponentMessage);
	    validateProps.attachComponentCss(this.host, getComponentCss, this.size, this.offset);
	    return validateProps.h("slot", null);
	  }
	  get host() { return validateProps.getElement(this); }
	};

	pGrid_2_cjs_entry.p_grid = Grid;
	pGrid_2_cjs_entry.p_grid_item = GridItem;

	
	return pGrid_2_cjs_entry;
}

var pHeading_cjs_entry = {};

var hasRequiredPHeading_cjs_entry;

function requirePHeading_cjs_entry () {
	if (hasRequiredPHeading_cjs_entry) return pHeading_cjs_entry;
	hasRequiredPHeading_cjs_entry = 1;

	Object.defineProperty(pHeading_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const headingTag = requireHeadingTag0acc4c21();
	const typographyStyles = requireTypographyStyles136a56f3();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const headingXXLargeStyle = requireHeadingXXLargeStyleDb047d95();
	const fontSizeHeadingSmall = requireFontSizeHeadingSmallA15141a5();
	const fontSizeHeadingMedium = requireFontSizeHeadingMediumC49ab5a2();
	const fontSizeHeadingLarge = requireFontSizeHeadingLargeC355151d();
	const fontSizeHeadingXLarge = requireFontSizeHeadingXLargeF33a0a84();
	requireTextIconStylesDeb3ffbc();
	requireIsThemeAutoC90cd35d();
	requireHeadingSharedAa59e66d();
	requireFontLineHeight78b03658();
	requireFontWeightSemiBold4482c830();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireFontSizeTextMedium88887ad8();
	requireFontSizeTextLarge05a4bc90();
	requireFontSizeTextXLarge0ecf9ef3();

	const HEADING_SIZES = ['small', 'medium', 'large', 'x-large', 'xx-large', 'inherit'];
	const HEADING_COLORS = ['primary', 'inherit'];
	const headingSizeToTagMap = {
	  small: 'h6',
	  medium: 'h5',
	  large: 'h4',
	  'x-large': 'h3',
	  'xx-large': 'h2',
	  inherit: 'h2',
	};
	const getHeadingTagType = (host, size, tag) => {
	  if (typographyStyles.hasSpecificSlottedTag(host, headingTag.HEADING_TAGS.join())) {
	    return 'div';
	  }
	  else if (tag) {
	    return tag;
	  }
	  else {
	    return headingSizeToTagMap[size] || 'h2';
	  }
	};

	const sizeMap = {
	  small: fontSizeHeadingSmall.fontSizeHeadingSmall,
	  medium: fontSizeHeadingMedium.fontSizeHeadingMedium,
	  large: fontSizeHeadingLarge.fontSizeHeadingLarge,
	  'x-large': fontSizeHeadingXLarge.fontSizeHeadingXLarge,
	  'xx-large': headingXXLargeStyle.fontSizeHeadingXXLarge,
	};
	const getComponentCss = (size, align, color, ellipsis, theme) => {
	  return validateProps.getCss({
	    '@global': {
	      ':host': {
	        display: 'block',
	        ...validateProps.addImportantToEachRule({
	          ...colorSchemeStyles.colorSchemeStyles,
	          ...colorSchemeStyles.hostHiddenStyles,
	        }),
	      },
	      '::slotted': {
	        [headingTag.HEADING_TAGS.map((i) => `&(${i})`).join()]: validateProps.addImportantToEachRule(typographyStyles.getTypographySlottedJssStyle()),
	      },
	    },
	    root: typographyStyles.getTypographyRootJssStyle(headingXXLargeStyle.headingXXLargeStyle, validateProps.buildResponsiveStyles(size, (sizeValue) => ({
	      fontSize: sizeValue === 'inherit' ? sizeValue : sizeMap[sizeValue],
	    })), align, color, ellipsis, theme),
	  });
	};

	const propTypes = {
	  tag: validateProps.AllowedTypes.oneOf([undefined, ...headingTag.HEADING_TAGS]),
	  size: validateProps.AllowedTypes.breakpoint(HEADING_SIZES),
	  align: validateProps.AllowedTypes.oneOf(typographyStyles.TEXT_ALIGNS),
	  color: validateProps.AllowedTypes.oneOf(HEADING_COLORS),
	  ellipsis: validateProps.AllowedTypes.boolean,
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Heading = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.tag = undefined;
	    this.size = 'xx-large';
	    this.align = 'left';
	    this.color = 'primary';
	    this.ellipsis = false;
	    this.theme = 'light';
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    validateProps.attachComponentCss(this.host, getComponentCss, this.size, this.align, this.color, this.ellipsis, this.theme);
	    const TagType = getHeadingTagType(this.host, this.size, this.tag);
	    return (validateProps.h(TagType, { class: "root" }, validateProps.h("slot", null)));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	pHeading_cjs_entry.p_heading = Heading;

	
	return pHeading_cjs_entry;
}

var pHeadline_cjs_entry = {};

var hasRequiredPHeadline_cjs_entry;

function requirePHeadline_cjs_entry () {
	if (hasRequiredPHeadline_cjs_entry) return pHeadline_cjs_entry;
	hasRequiredPHeadline_cjs_entry = 1;

	Object.defineProperty(pHeadline_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const typographyStyles = requireTypographyStyles136a56f3();
	const warnIfDeprecatedComponentIsUsed = requireWarnIfDeprecatedComponentIsUsed80115a1d();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const displayShared = requireDisplayShared43dd15a5();
	const headingXXLargeStyle = requireHeadingXXLargeStyleDb047d95();
	const fontSizeHeadingXLarge = requireFontSizeHeadingXLargeF33a0a84();
	const fontSizeHeadingLarge = requireFontSizeHeadingLargeC355151d();
	const fontSizeHeadingMedium = requireFontSizeHeadingMediumC49ab5a2();
	const fontSizeHeadingSmall = requireFontSizeHeadingSmallA15141a5();
	const fontSizeTextXXSmall = requireFontSizeTextXXSmallA02f9c40();
	const fontSizeTextXSmall = requireFontSizeTextXSmallE59d35d7();
	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();
	const fontSizeTextMedium = requireFontSizeTextMedium88887ad8();
	const fontSizeTextLarge = requireFontSizeTextLarge05a4bc90();
	const fontSizeTextXLarge = requireFontSizeTextXLarge0ecf9ef3();
	requireTextIconStylesDeb3ffbc();
	requireIsThemeAutoC90cd35d();
	requireFontLineHeight78b03658();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireHeadingSharedAa59e66d();
	requireFontWeightSemiBold4482c830();

	const displayMediumStyle = {
	    font: `${displayShared._displayFontPartA}${displayShared.fontSizeDisplayMedium}${displayShared._displayFontPartB}`,
	};

	const HEADLINE_VARIANTS = [
	  'large-title',
	  'headline-1',
	  'headline-2',
	  'headline-3',
	  'headline-4',
	  'headline-5',
	];
	const HEADLINE_TAGS = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
	const HEADLINE_COLORS = ['primary', 'default', 'inherit'];
	const isValidVariantType = (variant) => {
	  return HEADLINE_VARIANTS.includes(variant);
	};
	const variantToTagMap = {
	  'large-title': 'h1',
	  'headline-1': 'h1',
	  'headline-2': 'h2',
	  'headline-3': 'h3',
	  'headline-4': 'h4',
	  'headline-5': 'h5',
	};
	const getHeadlineTagType = (host, variant, tag) => {
	  if (typographyStyles.hasSpecificSlottedTag(host, HEADLINE_TAGS.join())) {
	    return 'div';
	  }
	  else if (tag) {
	    return tag;
	  }
	  else {
	    return variantToTagMap[variant] || 'h1';
	  }
	};

	const headlineSizeMap = {
	  'headline-1': headingXXLargeStyle.fontSizeHeadingXXLarge,
	  'headline-2': fontSizeHeadingXLarge.fontSizeHeadingXLarge,
	  'headline-3': fontSizeHeadingLarge.fontSizeHeadingLarge,
	  'headline-4': fontSizeHeadingMedium.fontSizeHeadingMedium,
	  'headline-5': fontSizeHeadingSmall.fontSizeHeadingSmall,
	};
	const getHeadlineVariantJssStyle = (variant) => {
	  return {
	    ...(variant === 'large-title'
	      ? displayMediumStyle
	      : {
	        fontSize: headlineSizeMap[variant],
	      }),
	  };
	};
	const textSizeMap = {
	  'xx-small': fontSizeTextXXSmall.fontSizeTextXXSmall,
	  'x-small': fontSizeTextXSmall.fontSizeTextXSmall,
	  small: fontSizeTextSmall.fontSizeTextSmall,
	  medium: fontSizeTextMedium.fontSizeTextMedium,
	  large: fontSizeTextLarge.fontSizeTextLarge,
	  'x-large': fontSizeTextXLarge.fontSizeTextXLarge,
	};
	const getTextSizeJssStyle = (textSize) => {
	  return {
	    fontSize: textSize === 'inherit' ? textSize : textSizeMap[textSize],
	  };
	};
	const getComponentCss = (variant, align, color, ellipsis, theme) => {
	  return validateProps.getCss({
	    '@global': {
	      ':host': {
	        display: 'block',
	        ...validateProps.addImportantToEachRule({
	          ...colorSchemeStyles.colorSchemeStyles,
	          ...colorSchemeStyles.hostHiddenStyles,
	        }),
	      },
	      '::slotted': {
	        [HEADLINE_TAGS.map((i) => `&(${i})`).join()]: validateProps.addImportantToEachRule(typographyStyles.getTypographySlottedJssStyle()),
	      },
	    },
	    root: typographyStyles.getTypographyRootJssStyle(headingXXLargeStyle.headingXXLargeStyle, isValidVariantType(variant)
	      ? getHeadlineVariantJssStyle(variant)
	      : validateProps.buildResponsiveStyles(variant, getTextSizeJssStyle), align, color, ellipsis, theme),
	  });
	};

	const propTypes = {
	  // variant: AllowedTypes.string, // TODO: with all the different values this can't easily be validated
	  tag: validateProps.AllowedTypes.oneOf([undefined, ...HEADLINE_TAGS]),
	  align: validateProps.AllowedTypes.oneOf(typographyStyles.TEXT_ALIGNS),
	  color: validateProps.AllowedTypes.oneOf(HEADLINE_COLORS),
	  ellipsis: validateProps.AllowedTypes.boolean,
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Headline = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.variant = 'headline-1';
	    this.tag = undefined;
	    this.align = 'left';
	    this.color = 'primary';
	    this.ellipsis = false;
	    this.theme = 'light';
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    warnIfDeprecatedComponentIsUsed.warnIfDeprecatedComponentIsUsed(this.host, 'Please use new p-heading component instead.');
	    validateProps.attachComponentCss(this.host, getComponentCss, this.variant, this.align, this.color, this.ellipsis, this.theme);
	    const TagType = getHeadlineTagType(this.host, this.variant, this.tag);
	    return (validateProps.h(TagType, { class: "root" }, validateProps.h("slot", null)));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	pHeadline_cjs_entry.p_headline = Headline;

	
	return pHeadline_cjs_entry;
}

var pIcon_cjs_entry = {};

var textColor99ae680c = {};

var hasRequiredTextColor99ae680c;

function requireTextColor99ae680c () {
	if (hasRequiredTextColor99ae680c) return textColor99ae680c;
	hasRequiredTextColor99ae680c = 1;

	/** @deprecated */
	const TEXT_COLORS_DEPRECATED = [
	  'brand',
	  'default',
	  'neutral-contrast-low',
	  'neutral-contrast-medium',
	  'neutral-contrast-high',
	  'notification-neutral', // deprecated
	];
	const TEXT_COLORS = [
	  'primary',
	  'contrast-low',
	  'contrast-medium',
	  'contrast-high',
	  'notification-success',
	  'notification-warning',
	  'notification-error',
	  'notification-info',
	  'inherit',
	  ...TEXT_COLORS_DEPRECATED,
	];

	textColor99ae680c.TEXT_COLORS = TEXT_COLORS;

	
	return textColor99ae680c;
}

var schemedHighContrastMediaQuery5956ba22 = {};

var hasRequiredSchemedHighContrastMediaQuery5956ba22;

function requireSchemedHighContrastMediaQuery5956ba22 () {
	if (hasRequiredSchemedHighContrastMediaQuery5956ba22) return schemedHighContrastMediaQuery5956ba22;
	hasRequiredSchemedHighContrastMediaQuery5956ba22 = 1;

	const getSchemedHighContrastMediaQuery = (light, dark) => {
	  return {
	    '@media (forced-colors: active) and (prefers-color-scheme: light)': light,
	    '@media (forced-colors: active) and (prefers-color-scheme: dark)': dark,
	  };
	};

	schemedHighContrastMediaQuery5956ba22.getSchemedHighContrastMediaQuery = getSchemedHighContrastMediaQuery;

	
	return schemedHighContrastMediaQuery5956ba22;
}

var hasRequiredPIcon_cjs_entry;

function requirePIcon_cjs_entry () {
	if (hasRequiredPIcon_cjs_entry) return pIcon_cjs_entry;
	hasRequiredPIcon_cjs_entry = 1;

	Object.defineProperty(pIcon_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const textColor = requireTextColor99ae680c();
	const getCDNBaseURL = requireGetCDNBaseURLE7722df3();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsedDa5fe664();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed3a5c494c();
	const theme = requireThemeBfc10573();
	const textSize = requireTextSize3b156bcb();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const schemedHighContrastMediaQuery = requireSchemedHighContrastMediaQuery5956ba22();
	const filtersPrimary = requireFiltersPrimary7e1fcfed();
	const fontLineHeight = requireFontLineHeight78b03658();
	const fontSizeTextXXSmall = requireFontSizeTextXXSmallA02f9c40();
	const fontSizeTextXSmall = requireFontSizeTextXSmallE59d35d7();
	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();
	const fontSizeTextMedium = requireFontSizeTextMedium88887ad8();
	const fontSizeTextLarge = requireFontSizeTextLarge05a4bc90();
	const fontSizeTextXLarge = requireFontSizeTextXLarge0ecf9ef3();
	requireHelperE5c4e0db();

	const ICONS_MANIFEST = { "360": "360.min.5f2fcac02969bc425484fe8d80e5a1c9.svg", "accessibility": "accessibility.min.295a9d53a11c42212b8cce594982dfd2.svg", "active-cabin-ventilation": "active-cabin-ventilation.min.030c46def7a7397091d920b65bc0da3c.svg", "add": "add.min.8578a2d10c79a78e398e963b506b6cb5.svg", "adjust": "adjust.min.cdb89f5c161a4c82328fe60e72a88c59.svg", "arrow-double-down": "arrow-double-down.min.3b17923187ef2114d1f17da042fc97ca.svg", "arrow-double-left": "arrow-double-left.min.bba22e26f025c439b600bf74f0566465.svg", "arrow-double-right": "arrow-double-right.min.14f743d4adb5467fc0e95ac7f6426e1f.svg", "arrow-double-up": "arrow-double-up.min.8e3b3e31d227366f916c91dcb6e1b466.svg", "arrow-down": "arrow-down.min.84e69acc6554637cc373b8a4f50ba991.svg", "arrow-first": "arrow-first.min.bc51317ecf4953a664870ebab5059775.svg", "arrow-head-down": "arrow-head-down.min.454c189f4914925447670d0ae9bd2043.svg", "arrow-head-left": "arrow-head-left.min.aa2da7b4dbbb8a28c046592290054e94.svg", "arrow-head-right": "arrow-head-right.min.fb602ae5cb51970770570a70287e77e9.svg", "arrow-head-up": "arrow-head-up.min.2c282619214e4f998e1ac64a61b5545b.svg", "arrow-last": "arrow-last.min.72553c4284717d4961f8bcf8d51e0303.svg", "arrow-left": "arrow-left.min.24e8467ef0f8f206f228a3d8d443d70b.svg", "arrow-right": "arrow-right.min.8fb7b42d2d08d60f918602aa28475c0b.svg", "arrow-up": "arrow-up.min.0bc737f7f2cc56ef65c5d33472e014b0.svg", "augmented-reality": "augmented-reality.min.290ff033e35774fd093e1ab8ed07e10f.svg", "battery-empty": "battery-empty.min.8594e37d3e67a95b85eb9935f02e69cf.svg", "battery-full": "battery-full.min.4c75acb5a64a6dd3116ede7b1859a6d6.svg", "bell": "bell.min.d69dc9a220dec323e758ccbff756b5b5.svg", "bookmark": "bookmark.min.0cb177c79674593133f6d3d384c5df4b.svg", "broadcast": "broadcast.min.edbfac03d4afdc964d350f54df79c6f3.svg", "calculator": "calculator.min.2518729352d3709e488e71dcbf449247.svg", "calendar": "calendar.min.588fabe880634ece974291f5adfee50d.svg", "camera": "camera.min.10af3a4fac8c289775390534a50606d0.svg", "car": "car.min.4eeec04c87a14bb5d3d316eeeee0185b.svg", "car-battery": "car-battery.min.2a619bbd456ad531c922bf8f51b70977.svg", "card": "card.min.06394222c7ca5d6c7e783d6f86f030a6.svg", "charging-active": "charging-active.min.915410d626a52a3a76b6bf498491c255.svg", "charging-state": "charging-state.min.c5cb87ef2808f824f352a6ebd9b9d4a9.svg", "charging-station": "charging-station.min.211fcf0f9a9bb50b6e83482ee588dda9.svg", "chart": "chart.min.267e23c07f47784c186c5119b870df76.svg", "chat": "chat.min.a8a52d1b8b463ee0e5a3b0d812c9a40c.svg", "check": "check.min.0cb26d9a5ee1d217e5054f1ad60ae3b4.svg", "city": "city.min.a99b88b51adda8244a2c72953a2f4ab4.svg", "climate": "climate.min.5d52b2880552275d9032afc0fa2b7296.svg", "climate-control": "climate-control.min.152235d2bf2b7ec6e1a3c40e6971c446.svg", "clock": "clock.min.bcea9f182e1fe861ea6e765650f79b38.svg", "close": "close.min.eefab6ef191882058f9ed548bd5a467e.svg", "closed-caption": "closed-caption.min.b93ac43c07223fda14249d2279823f6a.svg", "co2-emission": "co2-emission.min.788590454baa0f6c52dfc99a55fe0b85.svg", "compare": "compare.min.657a924ca48bf93d200d2e6539fa8050.svg", "configurate": "configurate.min.2d137bc6f43ee03587188b571c97aacd.svg", "copy": "copy.min.b47f2ffbfefd05782509bb83951c6577.svg", "country-road": "country-road.min.3ee2c1be9d063f5d7c5772fcc7ae2568.svg", "cubic-capacity": "cubic-capacity.min.b5df863671bdf059bce19eddc2990698.svg", "delete": "delete.min.fd9788c3a0842a7bb1d737c6de1969d1.svg", "disable": "disable.min.c3d85d4ed9738c077d19e524775dbd56.svg", "document": "document.min.d2db26d7049ab2180361c7ce40f52d57.svg", "download": "download.min.d7c63bcbadf4dd5b14c3c79a438d93f3.svg", "duration": "duration.min.9405be759f64c8253076f7e55c80c336.svg", "edit": "edit.min.06bde2175fafb58233fa1ce6d3d00f83.svg", "email": "email.min.eb8ff02812a48c5098d3c40614e8d9d7.svg", "error-filled": "error-filled.min.35d7da7cb866bcfd3a25859f8cd2246b.svg", "exclamation": "exclamation.min.6ca46945978bd4eb2a40dc29766b1882.svg", "external": "external.min.b804bef35446f6b3cb379c121de3f13d.svg", "filter": "filter.min.60f168332c7550dfdf714ed0507877b0.svg", "fingerprint": "fingerprint.min.edc52a4b691f8495ef0ca66184f62544.svg", "flash": "flash.min.e5a6de1239300a6104076ee67aec42ca.svg", "fuel-station": "fuel-station.min.0155159076984cccdbfe854eb4da3720.svg", "garage": "garage.min.463577e6a1ffac592b5aa7bec9a82d39.svg", "gift": "gift.min.eeb1a5871a4008bcafd9495fe11ec9bc.svg", "globe": "globe.min.50fd2c886a822673902bd106efc73c3f.svg", "grid": "grid.min.c36c5015115005dcb9c948f07af0be80.svg", "heart": "heart.min.132eca7a5d16b091f23340b3ae359294.svg", "heart-filled": "heart-filled.min.4d48b6bb07a6a2159e765d0c621543a0.svg", "highway": "highway.min.ea773dcf33a43fa8e82beae96c1222b7.svg", "home": "home.min.2bdc01bb7c9b39fa5ef5a81c8c3f9f49.svg", "horn": "horn.min.77105eb430a033a3ffdf21f9fecd32de.svg", "image": "image.min.851c64681e1950312a934a723ca04a85.svg", "increase": "increase.min.45bfe421e86192da37c8cca4917c10c2.svg", "information": "information.min.d387e44cc786ca3df3702f429518a1d9.svg", "information-filled": "information-filled.min.1055e842bb7d89c061ff1b5f47ed6169.svg", "key": "key.min.37b5e8ff9fda430f855f4b82bfd03485.svg", "leaf": "leaf.min.ea91b1d04ade4c49640e89ade35c9d90.svg", "leather": "leather.min.ef9e664d2fc3c28171fbd3d93b079503.svg", "light": "light.min.5fa3dd77ee9c63e28614c4c7c4a6d39c.svg", "list": "list.min.ecaeee96ec6cf2f8c9028ea404113a9e.svg", "locate": "locate.min.c28bdf292bbf297eb8109a272e2ffb91.svg", "lock": "lock.min.d258c21c7217cd1342307c45ecd5176e.svg", "lock-open": "lock-open.min.2ef427e273635e3aab7601b0fe92e86e.svg", "logo-apple-podcast": "logo-apple-podcast.min.af7a1f162ae9d6dba90fe155d8688b9c.svg", "logo-baidu": "logo-baidu.min.a8eb57b32e616b21820d86882835fe20.svg", "logo-delicious": "logo-delicious.min.fc2927d4979ffaed1f23160091e0975e.svg", "logo-digg": "logo-digg.min.d7340b3f22cf4a22a8ac3b472c16e0e2.svg", "logo-facebook": "logo-facebook.min.0c2e020d0b61d37e76e6bab67e4d149e.svg", "logo-foursquare": "logo-foursquare.min.b2699d993d9d731892ba01874c0e023d.svg", "logo-gmail": "logo-gmail.min.0c14069d86c2ba0a42c726d96f0cae9c.svg", "logo-google": "logo-google.min.c1f3931d74e40e5cdc875236b7e674a1.svg", "logo-hatena": "logo-hatena.min.021834899da6e6f6a9dd963f4fc3337c.svg", "logo-instagram": "logo-instagram.min.2f8c578e2472dc13b2f0ec8d1b936442.svg", "logo-kaixin": "logo-kaixin.min.8fb995689a3442669df37b5f375922fc.svg", "logo-kakaotalk": "logo-kakaotalk.min.988146b4cd8bced103fd8b5a9be064d8.svg", "logo-linkedin": "logo-linkedin.min.e4848fd4b74404e504fd1a4d5a25b960.svg", "logo-naver": "logo-naver.min.13f97e4c3ad4898d169904caa609f2d0.svg", "logo-pinterest": "logo-pinterest.min.101284bac1d7cf468719fccf416069df.svg", "logo-qq": "logo-qq.min.5d89ab35e4e00e81deadaa2fe0d51a5d.svg", "logo-qq-share": "logo-qq-share.min.01da8f9d6665f4529f349f88b4fb0cfc.svg", "logo-reddit": "logo-reddit.min.40dd42ee1368dbc74611afee4d3c9850.svg", "logo-skyrock": "logo-skyrock.min.9440a0e4a088cdfbfcc99bc91010768a.svg", "logo-sohu": "logo-sohu.min.d7a030336d712a2b44982e65071cd2bc.svg", "logo-spotify": "logo-spotify.min.48fb45730d66998420f8760b6d2f7fcc.svg", "logo-tecent": "logo-tecent.min.fd1ec329327f4cbf5706c393df66af9d.svg", "logo-telegram": "logo-telegram.min.624fca36dd6f6c5b64bce6e617372d77.svg", "logo-tiktok": "logo-tiktok.min.9c5ffad4c76353afaa99feca9e4f2f0a.svg", "logo-tumblr": "logo-tumblr.min.9b77d06b659cee9d5f45015c33c23967.svg", "logo-twitter": "logo-twitter.min.a6a1098cf290c07051a53f14a4efe1b0.svg", "logo-viber": "logo-viber.min.330fbae7d2683b7910d828cbe864f738.svg", "logo-vk": "logo-vk.min.727ba204a194c8cf1b7fc389ac1db14b.svg", "logo-wechat": "logo-wechat.min.0392ff30f188aa9f52480e965142474a.svg", "logo-weibo": "logo-weibo.min.3ded49004baea42d85fa6fcb9d79ccb1.svg", "logo-whatsapp": "logo-whatsapp.min.02c83d3cbde89763eee8fc3bcab02257.svg", "logo-xing": "logo-xing.min.6a5f5fde119a841823d0ef05293b3454.svg", "logo-yahoo": "logo-yahoo.min.622e886e777c08cf80c31dc99ca13f1a.svg", "logo-youku": "logo-youku.min.d35a5283c6d3094748f565c729f56d9f.svg", "logo-youtube": "logo-youtube.min.59c939904cbec0c7793289eb5e68cb99.svg", "logout": "logout.min.aa54756e3aec12f347fdec0a2905a232.svg", "map": "map.min.643551801bfc27a93438c30ebe1d1387.svg", "menu-dots-horizontal": "menu-dots-horizontal.min.94e0804e3a5a30a577cab6296ad8d15d.svg", "menu-dots-vertical": "menu-dots-vertical.min.7ec3f5be33dd3459d7a9bed9fdbe22d3.svg", "menu-lines": "menu-lines.min.30ff09f6e2ce846286dd136279636097.svg", "minus": "minus.min.00cca11ec9ce4bd913abba2059c3f10b.svg", "mobile": "mobile.min.71d3c0d7fb4349383562cc233478f7fb.svg", "moon": "moon.min.5c447b4013210e7c7723ca4b6fdbfa9f.svg", "oil-can": "oil-can.min.31978141ee5529f97833027b1e03294a.svg", "parking-brake": "parking-brake.min.f03105e84898f1db02c6fcbdd008bfcf.svg", "parking-light": "parking-light.min.968af68684df1220b15cff6616e8376e.svg", "pause": "pause.min.dd29b256b73311abf1549ed16fe7a47b.svg", "phone": "phone.min.e1a58c454ffe074b30a5bb16c75ff23f.svg", "pin": "pin.min.c6ce5ea394fd9cf9dca80a592e2aeae4.svg", "pin-filled": "pin-filled.min.e47cf748ce9a27ced935c6b6cf4c59f1.svg", "play": "play.min.703fb2dbebac16ea91a6524914626ae2.svg", "plug": "plug.min.02d79b2702ac5c41020b54bd9eedf523.svg", "plus": "plus.min.dd34f71292a547080b9247a72c1adda2.svg", "preheating": "preheating.min.96ccdd3d24b0634ca820dc894894a34d.svg", "printer": "printer.min.bcd50214772a8fcc1d0f0ae1205610bf.svg", "purchase": "purchase.min.70535cff1a085154ab49ab958fe91aae.svg", "push-pin": "push-pin.min.7cec1084d78eb838957424d8ed62ecf5.svg", "push-pin-off": "push-pin-off.min.de81e394f6d02de580d4408070986097.svg", "qr": "qr.min.1facfc2c9b70057552904fe123674746.svg", "question": "question.min.df469b72598d2dbfb458c46430c0690a.svg", "racing-flag": "racing-flag.min.1aee1d177d44aaaca113a8b7a81db573.svg", "refresh": "refresh.min.36ced59c8e8d06980d6ac20cca8a9057.svg", "replay": "replay.min.d4f212bf3d5f8fe166d78dba57eeacde.svg", "reset": "reset.min.e1ce71f684b6e83b9ed8182389bd407f.svg", "roof-closed": "roof-closed.min.99006124d26ea3014b9169900bc266e1.svg", "roof-open": "roof-open.min.c0322e148f7071f2cb8f6b5d8ef15337.svg", "route": "route.min.49f1935d2a563b150bb382eb56a04972.svg", "rss": "rss.min.eaf3873673fcbff72833e7a77f9510f8.svg", "save": "save.min.6506e50ad89aee223e85fe52242c232e.svg", "screen": "screen.min.c17978f44a7bf9f7d80f178fd2b7d116.svg", "search": "search.min.f2755d61c24b6ad037f51d65588be308.svg", "send": "send.min.544f2b90e562b8582808f735846b1351.svg", "share": "share.min.b7b59aa7085cc865735acfd940480234.svg", "shopping-bag": "shopping-bag.min.9d99682e614f5bbb9760c1a0272bd1e0.svg", "shopping-bag-filled": "shopping-bag-filled.min.566efdc835446512c426a9ef5e3badb0.svg", "shopping-cart": "shopping-cart.min.05a6c651afb21246daba2e941e8366cc.svg", "shopping-cart-filled": "shopping-cart-filled.min.c166601be618e0aadd596b54785f18f2.svg", "sidelights": "sidelights.min.996d591ee87247eae32968bf0b588d1e.svg", "snowflake": "snowflake.min.cf85d1b3c62e223ffb80d8c838d4f0b8.svg", "sort": "sort.min.d90a6657569305b9b09b0c6997b5b915.svg", "stack": "stack.min.d36295767f8e2540bbbf60278114ca09.svg", "star": "star.min.d7445429f599f915661e6c57841ae339.svg", "steering-wheel": "steering-wheel.min.c632bf7d06f41d68f0a95d76615f3981.svg", "stopwatch": "stopwatch.min.c90f1fde0961349fe79c0b077f7b0d41.svg", "subtract": "subtract.min.bb9f2dcb0c81ac7f216f6fe2ba916c09.svg", "success": "success.min.4401a4715549bd7dfaaa4f54684b2088.svg", "success-filled": "success-filled.min.c9cb3c66aebf9c4f40b897064f901335.svg", "sun": "sun.min.a68eb6225965558e4498d3d38c33d52a.svg", "switch": "switch.min.ab6c8b55ab119d9bd5170a1893a75ed2.svg", "tablet": "tablet.min.60e7c4ef821bf610d2b2d5b06c7e88b7.svg", "tachometer": "tachometer.min.348f8c5eed7c61993a864ebcffee98bd.svg", "tire": "tire.min.2094760dbaee1d169fa86f2113a5ca40.svg", "truck": "truck.min.43f91b0320003695d8804cf6a8a86da4.svg", "upload": "upload.min.cf3aaf8fb27e339d26133cbd6a5332ca.svg", "user": "user.min.0f8dcfbe34322e7968b4b23e11d963f0.svg", "user-filled": "user-filled.min.aa7b4c61ce78e08ba35fb513ff9e19dd.svg", "user-group": "user-group.min.87f6ca16e7174b9a8d1894283a8ff1d4.svg", "user-manual": "user-manual.min.0b87e500e3d747e67be964c47a3ae312.svg", "video": "video.min.107dfd64c6fd7398dd48b94d61b2fe11.svg", "view": "view.min.cd78cae7309f44d941e9264047e3efa0.svg", "view-off": "view-off.min.e27746517bdb4c2c9ae5f025c7e74991.svg", "volume-off": "volume-off.min.711d24824df04d61c3129bbdcdbfa083.svg", "volume-up": "volume-up.min.0a2ebc984c6b9d2f53c747f9ba2028f1.svg", "warning": "warning.min.04529c502dddce98f0ae2eec0bfb3432.svg", "warning-filled": "warning-filled.min.ee8effcdc653f660043f909b6f0c938b.svg", "weight": "weight.min.47ef0b98ca8ed590dd7d6e6c3f1bcd46.svg", "wifi": "wifi.min.14540859e9241374bd9d0c89eb85667b.svg", "work": "work.min.d17986d8fcff6a5fcd5e9925e838fade.svg", "wrench": "wrench.min.90e402dc170fe83de23e2c11588ba037.svg", "wrenches": "wrenches.min.990b074555825a218e86fd35397fc88c.svg", "zoom-in": "zoom-in.min.22fa9d7ee8748debc801fe910f2d3d01.svg", "zoom-out": "zoom-out.min.9408a4dc5786ed5a783a729e58ab3d6d.svg" };

	const ICON_ARIA_ATTRIBUTES = ['aria-label'];
	const ICON_COLORS = [...textColor.TEXT_COLORS, 'state-disabled'];
	const isUrl = (str) => str?.length > 0 && /(\/)/.test(str);
	const DEFAULT_ICON_NAME = 'arrow-right';
	// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
	const buildIconUrl = (iconNameOrSource = DEFAULT_ICON_NAME) => {
	  if (iconNameOrSource === null) {
	    return buildIconUrl(DEFAULT_ICON_NAME);
	  }
	  else if (isUrl(iconNameOrSource)) {
	    return iconNameOrSource;
	  }
	  else if (ICONS_MANIFEST[iconNameOrSource]) {
	    return `${getCDNBaseURL.getCDNBaseURL()}/icons/${ICONS_MANIFEST[iconNameOrSource]}`;
	  }
	  return buildIconUrl(DEFAULT_ICON_NAME);
	};

	const filterLightDisabled = filtersPrimary.toFilter([63, 8, 108, 188, 94, 86]);
	const filterDarkDisabled = filtersPrimary.toFilter([52, 6, 135, 187, 94, 89]);

	const filterLightNotificationSuccess = filtersPrimary.toFilter([28, 89, 572, 71, 111, 98]);
	const filterLightNotificationWarning = filtersPrimary.toFilter([58, 53, 820, 12, 112, 103]);
	const filterLightNotificationError = filtersPrimary.toFilter([14, 75, 4140, 347, 100, 97]);
	const filterLightNotificationInfo = filtersPrimary.toFilter([44, 100, 492, 195, 86, 221]);
	const filterDarkNotificationSuccess = filtersPrimary.toFilter([60, 71, 512, 106, 91, 97]);
	const filterDarkNotificationWarning = filtersPrimary.toFilter([75, 39, 759, 350, 109, 94]);
	const filterDarkNotificationError = filtersPrimary.toFilter([64, 91, 5857, 336, 98, 102]);
	const filterDarkNotificationInfo = filtersPrimary.toFilter([56, 77, 4175, 198, 104, 98]);

	const sizeMap = {
	  'xx-small': fontSizeTextXXSmall.fontSizeTextXXSmall,
	  'x-small': fontSizeTextXSmall.fontSizeTextXSmall,
	  small: fontSizeTextSmall.fontSizeTextSmall,
	  medium: fontSizeTextMedium.fontSizeTextMedium,
	  large: fontSizeTextLarge.fontSizeTextLarge,
	  'x-large': fontSizeTextXLarge.fontSizeTextXLarge,
	};
	const filterLight = {
	  primary: filtersPrimary.filterLightPrimary,
	  'state-disabled': filterLightDisabled,
	  'contrast-low': filtersPrimary.filterLightContrastLow,
	  'contrast-medium': filtersPrimary.filterLightContrastMedium,
	  'contrast-high': filtersPrimary.filterLightContrastHigh,
	  'notification-success': filterLightNotificationSuccess,
	  'notification-warning': filterLightNotificationWarning,
	  'notification-error': filterLightNotificationError,
	  'notification-info': filterLightNotificationInfo,
	};
	const filterDark = {
	  primary: filtersPrimary.filterDarkPrimary,
	  'state-disabled': filterDarkDisabled,
	  'contrast-low': filtersPrimary.filterDarkContrastLow,
	  'contrast-medium': filtersPrimary.filterDarkContrastMedium,
	  'contrast-high': filtersPrimary.filterDarkContrastHigh,
	  'notification-success': filterDarkNotificationSuccess,
	  'notification-warning': filterDarkNotificationWarning,
	  'notification-error': filterDarkNotificationError,
	  'notification-info': filterDarkNotificationInfo,
	};
	const filterMap = {
	  auto: filterLight,
	  light: filterLight,
	  dark: filterDark,
	};
	const forceRerenderAnimationStyle = {
	  '0%': {
	    transform: 'rotateZ(0)',
	  },
	  '100%': {
	    transform: 'rotateZ(0)',
	  },
	};
	const keyFramesLight = 'rerender-light';
	const keyFramesDark = 'rerender-dark';
	const getComponentCss = (color, size, theme) => {
	  const isColorInherit = color === 'inherit';
	  const isSizeInherit = size === 'inherit';
	  const isDark = validateProps.isThemeDark(theme);
	  return validateProps.getCss({
	    '@global': {
	      ':host': {
	        display: 'inline-block',
	        verticalAlign: 'top',
	        ...validateProps.addImportantToEachRule({
	          ...colorSchemeStyles.colorSchemeStyles,
	          ...colorSchemeStyles.hostHiddenStyles,
	        }),
	      },
	      img: {
	        display: 'block',
	        margin: 0,
	        padding: 0,
	        pointerEvents: 'none',
	        ...(!isColorInherit && {
	          filter: filterMap[theme][color],
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	            filter: filterMap.dark[color],
	          }),
	          ...(validateProps.isHighContrastMode &&
	            schemedHighContrastMediaQuery.getSchemedHighContrastMediaQuery({
	              filter: filterMap.light[color],
	            }, {
	              filter: filterMap.dark[color],
	            })),
	          WebkitAnimation: `${isDark ? `${keyFramesDark}-${color}` : `${keyFramesLight}-${color}`} 1ms`, // needed to enforce repaint in Safari if theme is switched programmatically.
	        }),
	        ...(isSizeInherit
	          ? {
	            width: size,
	            height: size,
	          }
	          : {
	            width: fontLineHeight.fontLineHeight,
	            height: fontLineHeight.fontLineHeight,
	            font: `${sizeMap[size]} ${fontLineHeight.fontFamily}`,
	          }),
	      },
	      ...(!isColorInherit && {
	        [`@keyframes ${isDark ? `${keyFramesDark}-${color}` : `${keyFramesLight}-${color}`}`]: forceRerenderAnimationStyle,
	      }),
	    },
	  });
	};

	const propTypes = {
	  name: validateProps.AllowedTypes.oneOf(Object.keys(ICONS_MANIFEST)),
	  source: validateProps.AllowedTypes.string,
	  color: validateProps.AllowedTypes.oneOf(ICON_COLORS),
	  size: validateProps.AllowedTypes.oneOf(textSize.TEXT_SIZES),
	  lazy: validateProps.AllowedTypes.boolean,
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	  aria: validateProps.AllowedTypes.aria(ICON_ARIA_ATTRIBUTES),
	};
	const Icon = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.name = 'arrow-right';
	    this.source = undefined;
	    this.color = 'primary';
	    this.size = 'small';
	    this.lazy = undefined;
	    this.theme = 'light';
	    this.aria = undefined;
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'lazy');
	    const deprecationMap = {
	      brand: 'primary',
	      default: 'primary',
	      'neutral-contrast-low': 'contrast-low',
	      'neutral-contrast-medium': 'contrast-medium',
	      'neutral-contrast-high': 'contrast-high',
	      'notification-neutral': 'notification-info',
	    };
	    warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'color', deprecationMap);
	    validateProps.attachComponentCss(this.host, getComponentCss, (deprecationMap[this.color] || this.color), this.size, this.theme);
	    return (validateProps.h("img", { src: window.PDS_SKIP_FETCH ? undefined : buildIconUrl(this.source || this.name), width: 24, height: 24, loading: "lazy", alt: validateProps.parseAndGetAriaAttributes(this.aria)?.['aria-label'] ?? '' }));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	pIcon_cjs_entry.p_icon = Icon;

	
	return pIcon_cjs_entry;
}

var pInlineNotification_cjs_entry = {};

var hasRequiredPInlineNotification_cjs_entry;

function requirePInlineNotification_cjs_entry () {
	if (hasRequiredPInlineNotification_cjs_entry) return pInlineNotification_cjs_entry;
	hasRequiredPInlineNotification_cjs_entry = 1;

	Object.defineProperty(pInlineNotification_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const hasNamedSlot = requireHasNamedSlot28c6bca1();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsedDa5fe664();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed3a5c494c();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const inlineNotificationUtils = requireInlineNotificationUtilsAc1154ad();
	const headingSmallStyle = requireHeadingSmallStyle0707b97f();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const getMediaQueryMax = requireGetMediaQueryMax2587ee0a();
	requireGetNamedSlotA433c432();
	requireHelperE5c4e0db();
	requireSpacingStaticMedium94812711();
	requireBorderRadiusSmall5f37fc45();
	requireSpacingStaticXSmallB7d708b8();
	requireSpacingStaticSmall2130ed04();
	requireBannerUtils2cc83734();
	requireHeadingSharedAa59e66d();
	requireFontLineHeight78b03658();
	requireFontWeightSemiBold4482c830();
	requireFontVariant6ba3b7cb();
	requireFontSizeHeadingSmallA15141a5();
	requireFontSizeTextSmall508930e5();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();

	const hasHeading = (element, heading) => {
	  return !!heading || hasNamedSlot.hasNamedSlot(element, 'heading');
	};

	const mediaQueryMaxS = getMediaQueryMax.getMediaQueryMax('s');
	const getComponentCss = (state, hasAction, hasClose, theme) => {
	  return validateProps.getCss({
	    '@global': {
	      ':host': validateProps.addImportantToEachRule({
	        ...inlineNotificationUtils.getNotificationRootJssStyle(state, hasAction, hasClose, theme),
	        ...colorSchemeStyles.colorSchemeStyles,
	        ...colorSchemeStyles.hostHiddenStyles,
	      }),
	      h5: headingSmallStyle.headingSmallStyle,
	      p: textSmallStyle.textSmallStyle,
	      'h5,p': {
	        margin: 0,
	        color: validateProps.getThemedColors(theme).primaryColor,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          color: validateProps.getThemedColors('dark').primaryColor,
	        }),
	      },
	    },
	    icon: inlineNotificationUtils.getNotificationIconJssStyle(),
	    content: inlineNotificationUtils.getNotificationContentJssStyle(),
	    ...(hasAction && {
	      action: {
	        [mediaQueryMaxS]: {
	          gridRowStart: 2,
	        },
	      },
	    }),
	  });
	};

	const propTypes = {
	  heading: validateProps.AllowedTypes.string,
	  description: validateProps.AllowedTypes.string,
	  state: validateProps.AllowedTypes.oneOf(inlineNotificationUtils.INLINE_NOTIFICATION_STATES),
	  dismissButton: validateProps.AllowedTypes.boolean,
	  persistent: validateProps.AllowedTypes.boolean,
	  actionLabel: validateProps.AllowedTypes.string,
	  actionLoading: validateProps.AllowedTypes.boolean,
	  actionIcon: validateProps.AllowedTypes.string,
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const InlineNotification = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.dismiss = validateProps.createEvent(this, "dismiss", 3);
	    this.action = validateProps.createEvent(this, "action", 3);
	    this.heading = '';
	    this.description = '';
	    this.state = 'info';
	    this.dismissButton = true;
	    this.persistent = undefined;
	    this.actionLabel = undefined;
	    this.actionLoading = false;
	    this.actionIcon = 'arrow-right';
	    this.theme = 'light';
	  }
	  get hasDismissButton() {
	    return this.persistent ? false : this.dismissButton;
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'state', {
	      neutral: 'info',
	    });
	    warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'persistent', 'Please use dismissButton prop instead.');
	    validateProps.attachComponentCss(this.host, getComponentCss, this.state, !!this.actionLabel, this.hasDismissButton, this.theme);
	    const bannerId = 'banner';
	    const labelId = 'label';
	    const descriptionId = 'description';
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    return (validateProps.h(validateProps.Host, null, validateProps.h(PrefixedTagNames.pIcon, { class: "icon", name: inlineNotificationUtils.getInlineNotificationIconName(this.state), color: `notification-${this.state}`, theme: this.theme, "aria-hidden": "true" }), validateProps.h("div", { id: bannerId, class: "content", ...inlineNotificationUtils.getContentAriaAttributes(this.state, labelId, descriptionId) }, hasHeading(this.host, this.heading) && validateProps.h("h5", { id: labelId }, this.heading || validateProps.h("slot", { name: "heading" })), validateProps.h("p", { id: descriptionId }, this.description || validateProps.h("slot", null))), this.actionLabel && (validateProps.h(PrefixedTagNames.pButtonPure, { class: "action", theme: this.theme, icon: this.actionIcon, loading: this.actionLoading, onClick: this.action.emit }, this.actionLabel)), this.hasDismissButton && (validateProps.h(PrefixedTagNames.pButtonPure, { class: "close", type: "button", icon: "close", theme: this.theme, hideLabel: true, "aria-controls": bannerId, onClick: this.dismiss.emit }, "Close notification"))));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	pInlineNotification_cjs_entry.p_inline_notification = InlineNotification;

	
	return pInlineNotification_cjs_entry;
}

var pLinkPure_cjs_entry = {};

var throwIfInvalidLinkUsage0b248592 = {};

var hasRequiredThrowIfInvalidLinkUsage0b248592;

function requireThrowIfInvalidLinkUsage0b248592 () {
	if (hasRequiredThrowIfInvalidLinkUsage0b248592) return throwIfInvalidLinkUsage0b248592;
	hasRequiredThrowIfInvalidLinkUsage0b248592 = 1;

	const validateProps = requireValidatePropsC2afb75b();
	const getOnlyChildOfKindHTMLElementOrThrow = requireGetOnlyChildOfKindHTMLElementOrThrowF6972c1c();

	const throwIfInvalidLinkUsage = (host, hrefValue) => {
	  let isInvalid = hrefValue && host.children.length > 0;
	  if (!isInvalid || !hrefValue) {
	    try {
	      if (!hrefValue) {
	        getOnlyChildOfKindHTMLElementOrThrow.getOnlyChildOfKindHTMLElementOrThrow(host, 'a');
	      }
	    }
	    catch {
	      isInvalid = true;
	    }
	  }
	  if (isInvalid) {
	    validateProps.throwException(`usage of ${validateProps.getTagNameWithoutPrefix(host)} is not valid. Please provide a href property or a single and direct <a> child element.`);
	  }
	};

	throwIfInvalidLinkUsage0b248592.throwIfInvalidLinkUsage = throwIfInvalidLinkUsage;

	
	return throwIfInvalidLinkUsage0b248592;
}

var hasRequiredPLinkPure_cjs_entry;

function requirePLinkPure_cjs_entry () {
	if (hasRequiredPLinkPure_cjs_entry) return pLinkPure_cjs_entry;
	hasRequiredPLinkPure_cjs_entry = 1;

	Object.defineProperty(pLinkPure_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const linkAriaAttribute = requireLinkAriaAttribute5de11e89();
	const buttonLinkPureUtils = requireButtonLinkPureUtils468dbe67();
	const isSsrHydration = requireIsSsrHydration9278b79b();
	const theme = requireThemeBfc10573();
	const throwIfInvalidLinkUsage = requireThrowIfInvalidLinkUsage0b248592();
	const alignLabel = requireAlignLabelFc1cc093();
	const textSize = requireTextSize3b156bcb();
	const textWeight = requireTextWeight8f0d791a();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const linkButtonPureStyles = requireLinkButtonPureStyles1e533bc9();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	requireIsParentOfKindA9c351f2();
	requireGetOnlyChildOfKindHTMLElementOrThrowF6972c1c();
	requireGetDirectChildHTMLElements0adb2021();
	requireGetHTMLElements21fc87cc();
	requireTransformSelectorToDirectChildSelector08da8668();
	requireColorSchemeStyles81696be8();
	requireHoverMediaQueryF2ccfc24();
	requireFontSizeTextXXSmallA02f9c40();
	requireFontSizeTextXSmallE59d35d7();
	requireFontSizeTextSmall508930e5();
	requireFontSizeTextMedium88887ad8();
	requireFontSizeTextLarge05a4bc90();
	requireFontSizeTextXLarge0ecf9ef3();
	requireSpacingStaticXSmallB7d708b8();
	requireTextSmallStyle7246779a();
	requireTextShared9135e2ef();
	requireFontLineHeight78b03658();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();

	const getComponentCss = (icon, iconSource, active, stretch, size, hideLabel, alignLabel, underline, hasSlottedAnchor, theme) => {
	  const { focusColor } = validateProps.getThemedColors(theme);
	  const { focusColor: focusColorDark } = validateProps.getThemedColors('dark');
	  return validateProps.getCss(validateProps.mergeDeep(linkButtonPureStyles.getLinkButtonPureStyles(icon, iconSource, active, false, stretch, size, hideLabel, alignLabel, hasSlottedAnchor, theme), {
	    root: {
	      textDecoration: underline ? 'underline' : 'none',
	    },
	  }, hasSlottedAnchor && {
	    '@global': validateProps.addImportantToEachRule({
	      '::slotted': {
	        '&(a)': {
	          ...validateProps.getResetInitialStylesForSlottedAnchor,
	          textDecoration: underline ? 'underline' : 'none',
	          font: 'inherit',
	          color: 'inherit',
	        },
	        // The clickable area for Safari < ~15 (<= release date: 2021-10-28) is reduced to the slotted anchor itself,
	        // since Safari prior to this major release does not support pseudo-elements in the slotted context
	        // (https://bugs.webkit.org/show_bug.cgi?id=178237)
	        '&(a)::before': {
	          content: '""',
	          position: 'fixed',
	          top: linkButtonPureStyles.offsetVertical,
	          bottom: linkButtonPureStyles.offsetVertical,
	          borderRadius: borderRadiusSmall.borderRadiusSmall,
	          ...validateProps.buildResponsiveStyles(hideLabel, (hideLabelValue) => ({
	            right: hideLabelValue ? linkButtonPureStyles.offsetVertical : linkButtonPureStyles.offsetHorizontal,
	            left: hideLabelValue ? linkButtonPureStyles.offsetVertical : linkButtonPureStyles.offsetHorizontal,
	          })),
	        },
	        '&(a:focus)::before': {
	          border: `${validateProps.borderWidthBase} solid ${focusColor}`,
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	            borderColor: focusColorDark,
	          }),
	        },
	        '&(a:focus:not(:focus-visible))::before': {
	          border: 0,
	        },
	      },
	    }),
	  }));
	};

	const propTypes = {
	  alignLabel: validateProps.AllowedTypes.breakpoint(alignLabel.ALIGN_LABELS),
	  stretch: validateProps.AllowedTypes.breakpoint('boolean'),
	  size: validateProps.AllowedTypes.breakpoint(textSize.TEXT_SIZES),
	  weight: validateProps.AllowedTypes.oneOf(textWeight.TEXT_WEIGHTS),
	  icon: validateProps.AllowedTypes.string,
	  iconSource: validateProps.AllowedTypes.string,
	  underline: validateProps.AllowedTypes.boolean,
	  href: validateProps.AllowedTypes.string,
	  active: validateProps.AllowedTypes.boolean,
	  hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	  target: validateProps.AllowedTypes.string,
	  download: validateProps.AllowedTypes.string,
	  rel: validateProps.AllowedTypes.string,
	  aria: validateProps.AllowedTypes.aria(linkAriaAttribute.LINK_ARIA_ATTRIBUTES),
	};
	const LinkPure = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.alignLabel = 'right';
	    this.stretch = false;
	    this.size = 'small';
	    this.weight = 'regular';
	    this.icon = 'arrow-right';
	    this.iconSource = undefined;
	    this.underline = false;
	    this.href = undefined;
	    this.active = false;
	    this.hideLabel = false;
	    this.theme = 'light';
	    this.target = '_self';
	    this.download = undefined;
	    this.rel = undefined;
	    this.aria = undefined;
	  }
	  componentWillLoad() {
	    if (!isSsrHydration.isSsrHydration(this.host)) {
	      // when ssr rendered component is partially hydrated before being rerendered by its parent (e.g. link-tile)
	      // it has no href prop and no slotted anchor, so validation fails
	      throwIfInvalidLinkUsage.throwIfInvalidLinkUsage(this.host, this.href);
	    }
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    buttonLinkPureUtils.warnIfParentIsPTextAndIconIsNone(this.host, this.icon, this.iconSource);
	    validateProps.attachComponentCss(this.host, getComponentCss, this.icon, this.iconSource, this.active, this.stretch, this.size, this.hideLabel, this.alignLabel, this.underline, !this.href, this.theme);
	    const TagType = this.href === undefined ? 'span' : 'a';
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    const hasIcon = buttonLinkPureUtils.hasVisibleIcon(this.icon, this.iconSource);
	    return (validateProps.h(TagType, { class: "root", ...(TagType === 'a' && {
	        href: this.href,
	        target: this.target,
	        download: this.download,
	        rel: this.rel,
	        ...validateProps.parseAndGetAriaAttributes(this.aria),
	      }) }, hasIcon && (validateProps.h(PrefixedTagNames.pIcon, { class: "icon", size: "inherit", name: this.icon, source: this.iconSource, theme: this.theme, "aria-hidden": "true" })), validateProps.h("span", { class: "label" }, validateProps.h("slot", null))));
	  }
	  static get delegatesFocus() { return true; }
	  get host() { return validateProps.getElement(this); }
	};

	pLinkPure_cjs_entry.p_link_pure = LinkPure;

	
	return pLinkPure_cjs_entry;
}

var pLinkSocial_cjs_entry = {};

var hasRequiredPLinkSocial_cjs_entry;

function requirePLinkSocial_cjs_entry () {
	if (hasRequiredPLinkSocial_cjs_entry) return pLinkSocial_cjs_entry;
	hasRequiredPLinkSocial_cjs_entry = 1;

	Object.defineProperty(pLinkSocial_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const warnIfDeprecatedComponentIsUsed = requireWarnIfDeprecatedComponentIsUsed80115a1d();
	const theme = requireThemeBfc10573();
	const throwIfInvalidLinkUsage = requireThrowIfInvalidLinkUsage0b248592();
	const linkStyles = requireLinkStyles60ad2b7b();
	requireGetOnlyChildOfKindHTMLElementOrThrowF6972c1c();
	requireGetDirectChildHTMLElements0adb2021();
	requireGetHTMLElements21fc87cc();
	requireTransformSelectorToDirectChildSelector08da8668();
	requireIsThemeAutoC90cd35d();
	requireLinkButtonStylesE68cc0c9();
	requireButtonLinkPureUtils468dbe67();
	requireIsParentOfKindA9c351f2();
	requireColorSchemeStyles81696be8();
	requireHoverMediaQueryF2ccfc24();
	requireBorderRadiusSmall5f37fc45();
	requireTextSmallStyle7246779a();
	requireTextShared9135e2ef();
	requireFontLineHeight78b03658();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireSpacingStaticSmall2130ed04();
	requireBorderRadiusMedium758b9411();

	const propTypes = {
	  icon: validateProps.AllowedTypes.string,
	  iconSource: validateProps.AllowedTypes.string,
	  href: validateProps.AllowedTypes.string,
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	  target: validateProps.AllowedTypes.string,
	  rel: validateProps.AllowedTypes.string,
	  hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	};
	const LinkSocial = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.icon = undefined;
	    this.iconSource = undefined;
	    this.href = undefined;
	    this.theme = 'light';
	    this.target = '_self';
	    this.rel = undefined;
	    this.hideLabel = false;
	  }
	  componentWillLoad() {
	    throwIfInvalidLinkUsage.throwIfInvalidLinkUsage(this.host, this.href);
	    warnIfDeprecatedComponentIsUsed.warnIfDeprecatedComponentIsUsed(this.host, 'Use p-link component with corresponding social icon instead.');
	    validateProps.doNothing(); // TODO: this function does nothing but treats for unknowns reasons e.g. getThemedColors to be bundled into main chunk
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    validateProps.attachComponentCss(this.host, linkStyles.getComponentCss, this.icon, this.iconSource, 'primary', this.hideLabel, !this.href, this.theme);
	    const TagType = this.href === undefined ? 'span' : 'a';
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    return (validateProps.h(TagType, { class: "root", ...(TagType === 'a' && {
	        href: this.href,
	        target: this.target,
	        rel: this.rel,
	      }) }, validateProps.h(PrefixedTagNames.pIcon, { class: "icon", size: "inherit", name: this.icon, source: this.iconSource, theme: this.theme, "aria-hidden": "true" }), validateProps.h("span", { class: "label" }, validateProps.h("slot", null))));
	  }
	  static get delegatesFocus() { return true; }
	  get host() { return validateProps.getElement(this); }
	};

	pLinkSocial_cjs_entry.p_link_social = LinkSocial;

	
	return pLinkSocial_cjs_entry;
}

var pLinkTileModelSignature_cjs_entry = {};

var throwIfElementIsNotOfKindAad4cb3e = {};

var hasRequiredThrowIfElementIsNotOfKindAad4cb3e;

function requireThrowIfElementIsNotOfKindAad4cb3e () {
	if (hasRequiredThrowIfElementIsNotOfKindAad4cb3e) return throwIfElementIsNotOfKindAad4cb3e;
	hasRequiredThrowIfElementIsNotOfKindAad4cb3e = 1;

	const validateProps = requireValidatePropsC2afb75b();

	const throwIfElementIsNotOfKind = (host, element, tagName) => {
	  const prefixedTagName = validateProps.getPrefixedTagNames(host)[validateProps.paramCaseToCamelCase(tagName)];
	  const actualTagName = validateProps.getTagName(element);
	  if (actualTagName !== prefixedTagName) {
	    validateProps.throwException(`child ${actualTagName} of ${validateProps.getTagName(host)} has to be a ${prefixedTagName}.`);
	  }
	};

	throwIfElementIsNotOfKindAad4cb3e.throwIfElementIsNotOfKind = throwIfElementIsNotOfKind;

	
	return throwIfElementIsNotOfKindAad4cb3e;
}

var hasRequiredPLinkTileModelSignature_cjs_entry;

function requirePLinkTileModelSignature_cjs_entry () {
	if (hasRequiredPLinkTileModelSignature_cjs_entry) return pLinkTileModelSignature_cjs_entry;
	hasRequiredPLinkTileModelSignature_cjs_entry = 1;

	Object.defineProperty(pLinkTileModelSignature_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const groupDirectionStyles = requireGroupDirectionStyles27ae72d0();
	const tileBaseStyles = requireTileBaseStylesBc82297d();
	const getNamedSlot = requireGetNamedSlotA433c432();
	const throwIfElementIsNotOfKind = requireThrowIfElementIsNotOfKindAad4cb3e();
	const fontWeightStyles = requireFontWeightStyles4b24ddd8();
	const spacingFluidLarge = requireSpacingFluidLarge6087a0f7();
	const spacingFluidMedium = requireSpacingFluidMedium88ab712b();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const spacingFluidSmall = requireSpacingFluidSmall2c6caae7();
	requireTextShared9135e2ef();
	requireFontLineHeight78b03658();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextLarge05a4bc90();
	requireColorSchemeStyles81696be8();
	requireHoverMediaQueryF2ccfc24();
	requireTextIconStylesDeb3ffbc();
	requireBorderRadiusLargeA0aa3a01();
	requireSpacingStaticMedium94812711();
	requireFontWeightSemiBold4482c830();
	requireFontSizeTextSmall508930e5();

	const getNamedSlotOrThrow = (el, slotName) => {
	  return (getNamedSlot.getNamedSlot(el, slotName) ||
	    validateProps.throwException(`named slot='${slotName}' is missing for component ${validateProps.getTagNameWithoutPrefix(el)}.`));
	};

	// array is redefined instead of using the one from in model-signature
	// because it is created via Object.keys(MODEL_SIGNATURES_MANIFEST) would bundle the entire manifest into both chunks
	const LINK_TILE_MODEL_SIGNATURE_MODELS = [
	  '718',
	  '911',
	  'boxster',
	  'cayenne',
	  'cayman',
	  'macan',
	  'panamera',
	  'taycan',
	  'turbo-s',
	  'turbo',
	];
	const LINK_TILE_MODEL_SIGNATURE_HEADING_TAGS = ['h2', 'h3', 'h4', 'h5', 'h6'];
	const setRequiredPropsOfSlottedLinks = (linkElements) => {
	  linkElements.forEach((link) => {
	    link.theme = 'dark';
	    link.variant = link.slot;
	  });
	};
	const getLinkOrSlottedAnchorElement = (linkElement) => {
	  return linkElement.href ? linkElement : linkElement.querySelector('a');
	};

	const getComponentCss = (aspectRatio, weight, direction, hasDescription) => {
	  const tileBaseStyles$1 = tileBaseStyles.getTileBaseStyles(aspectRatio);
	  return validateProps.getCss({
	    ...tileBaseStyles$1,
	    '@global': {
	      ...tileBaseStyles$1['@global'],
	      [LINK_TILE_MODEL_SIGNATURE_HEADING_TAGS.join(',')]: {
	        margin: validateProps.addImportantToRule(0),
	      },
	    },
	    content: {
	      ...tileBaseStyles$1.content,
	      flexDirection: 'column',
	      bottom: 0,
	      padding: `${spacingFluidLarge.spacingFluidLarge} ${spacingFluidMedium.spacingFluidMedium} ${spacingFluidMedium.spacingFluidMedium}`,
	      ...tileBaseStyles.gradientToTopStyle,
	    },
	    model: {
	      position: 'absolute',
	      top: spacingFluidMedium.spacingFluidMedium,
	      left: spacingFluidMedium.spacingFluidMedium,
	    },
	    heading: {
	      margin: 0,
	      ...tileBaseStyles.textLargeStyle,
	      hyphens: 'inherit',
	      ...validateProps.buildResponsiveStyles(weight, (w) => ({ fontWeight: fontWeightStyles.getFontWeight(w) })),
	    },
	    ...(hasDescription && {
	      description: {
	        margin: '-12px 0 0 ',
	        ...textSmallStyle.textSmallStyle,
	        hyphens: 'inherit',
	      },
	    }),
	    'link-group': {
	      display: 'flex',
	      width: '100%',
	      gap: spacingFluidSmall.spacingFluidSmall,
	      ...validateProps.buildResponsiveStyles(direction, groupDirectionStyles.getGroupDirectionJssStyles),
	    },
	    'link-overlay': {
	      // covers entire tile, used for expanded click-area only
	      position: 'fixed',
	      ...validateProps.getInsetJssStyle(),
	    },
	  });
	};

	const propTypes = {
	  model: validateProps.AllowedTypes.oneOf(LINK_TILE_MODEL_SIGNATURE_MODELS),
	  weight: validateProps.AllowedTypes.breakpoint(tileBaseStyles.TILE_WEIGHTS),
	  aspectRatio: validateProps.AllowedTypes.breakpoint(tileBaseStyles.TILE_ASPECT_RATIOS),
	  heading: validateProps.AllowedTypes.string,
	  description: validateProps.AllowedTypes.string,
	  linkDirection: validateProps.AllowedTypes.breakpoint(groupDirectionStyles.GROUP_DIRECTIONS),
	  headingTag: validateProps.AllowedTypes.oneOf(LINK_TILE_MODEL_SIGNATURE_HEADING_TAGS),
	};
	const LinkTileModelSignature = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.model = '911';
	    this.weight = 'semi-bold';
	    this.aspectRatio = '3:4';
	    this.heading = undefined;
	    this.description = undefined;
	    this.linkDirection = { base: 'column', xs: 'row' };
	    this.headingTag = 'h2';
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    // If we do this earlier than render, there are cases where primaryLink.href is undefined
	    // TODO: Here and in other components, validation happens only on initial render. We could extend this to watch props of the required slots.
	    const primaryLink = getNamedSlotOrThrow(this.host, 'primary');
	    const secondaryLink = getNamedSlotOrThrow(this.host, 'secondary');
	    throwIfElementIsNotOfKind.throwIfElementIsNotOfKind(this.host, primaryLink, 'p-link');
	    throwIfElementIsNotOfKind.throwIfElementIsNotOfKind(this.host, secondaryLink, 'p-link');
	    setRequiredPropsOfSlottedLinks([primaryLink, secondaryLink]);
	    const linkEl = getLinkOrSlottedAnchorElement(primaryLink); // support for slotted a tag within p-link
	    validateProps.attachComponentCss(this.host, getComponentCss, this.aspectRatio, this.weight, this.linkDirection, !!this.description);
	    const overlayLinkProps = {
	      class: 'link-overlay',
	      href: linkEl.href,
	      target: linkEl.target || '_self',
	      download: linkEl.download,
	      rel: linkEl.rel,
	      tabIndex: -1,
	      'aria-hidden': 'true',
	    };
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    return (validateProps.h("div", { class: "root" }, validateProps.h("div", { class: "image-container" }, validateProps.h("slot", null)), validateProps.h(PrefixedTagNames.pModelSignature, { class: "model", theme: "dark", model: this.model }), validateProps.h("div", { class: "content" }, validateProps.h("a", { ...overlayLinkProps }), validateProps.h(this.headingTag, { class: "heading" }, this.heading), this.description && validateProps.h("p", { class: "description" }, this.description), validateProps.h("div", { class: "link-group", role: "group" }, validateProps.h("slot", { name: "primary" }), validateProps.h("slot", { name: "secondary" })))));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	pLinkTileModelSignature_cjs_entry.p_link_tile_model_signature = LinkTileModelSignature;

	
	return pLinkTileModelSignature_cjs_entry;
}

var pLinkTile_cjs_entry = {};

var hasRequiredPLinkTile_cjs_entry;

function requirePLinkTile_cjs_entry () {
	if (hasRequiredPLinkTile_cjs_entry) return pLinkTile_cjs_entry;
	hasRequiredPLinkTile_cjs_entry = 1;

	Object.defineProperty(pLinkTile_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const linkAriaAttribute = requireLinkAriaAttribute5de11e89();
	const linkTileUtils = requireLinkTileUtils98dcc629();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsedDa5fe664();
	requireFontWeightStyles4b24ddd8();
	requireFontWeightRegularD0c768ac();
	requireFontWeightSemiBold4482c830();
	requireTileBaseStylesBc82297d();
	requireTextShared9135e2ef();
	requireFontLineHeight78b03658();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextLarge05a4bc90();
	requireColorSchemeStyles81696be8();
	requireHoverMediaQueryF2ccfc24();
	requireTextIconStylesDeb3ffbc();
	requireBorderRadiusLargeA0aa3a01();
	requireSpacingStaticMedium94812711();
	requireSpacingFluidMedium88ab712b();
	requireSpacingFluidLarge6087a0f7();
	requireFontSizeTextMedium88887ad8();
	requireThemeBfc10573();
	requireHelperE5c4e0db();

	const getComponentCss = (...args) => {
	  return validateProps.getCss({
	    ...linkTileUtils.getButtonLinkTileStyles(...args),
	    'link-overlay': {
	      // covers entire tile, used for expanded click-area only
	      position: 'fixed',
	      ...validateProps.getInsetJssStyle(),
	    },
	  });
	};

	const propTypes = {
	  ...linkTileUtils.sharedTilePropTypes,
	  weight: validateProps.AllowedTypes.breakpoint(linkTileUtils.LINK_TILE_WEIGHTS),
	  href: validateProps.AllowedTypes.string,
	  target: validateProps.AllowedTypes.string,
	  download: validateProps.AllowedTypes.string,
	  rel: validateProps.AllowedTypes.string,
	  aria: validateProps.AllowedTypes.aria(linkAriaAttribute.LINK_ARIA_ATTRIBUTES),
	};
	const LinkTile = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.size = 'default';
	    this.weight = 'semi-bold';
	    this.background = 'dark';
	    this.aspectRatio = '4:3';
	    this.label = undefined;
	    this.description = undefined;
	    this.align = 'bottom';
	    this.gradient = true;
	    this.compact = false;
	    this.href = undefined;
	    this.target = '_self';
	    this.download = undefined;
	    this.rel = undefined;
	    this.aria = undefined;
	  }
	  componentWillLoad() {
	    linkTileUtils.throwIfAlignTopAndNotCompact(this.host, this.align, this.compact);
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  render() {
	    this.compact = validateProps.parseJSON(this.compact); // parsing the value just once per lifecycle
	    validateProps.validateProps(this, propTypes);
	    warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'weight', {
	      semibold: 'semi-bold',
	    });
	    validateProps.attachComponentCss(this.host, getComponentCss, this.aspectRatio, this.size, this.weight, // potentially breakpoint customizable, so we can't easily access the deprecation map
	    this.background, this.align, this.compact, this.gradient);
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    const linkProps = {
	      theme: this.background,
	      variant: 'secondary',
	      aria: this.aria,
	    };
	    const sharedLinkProps = {
	      href: this.href,
	      target: this.target,
	      download: this.download,
	      rel: this.rel,
	    };
	    const link = (validateProps.h(PrefixedTagNames.pLink, { ...sharedLinkProps, ...linkProps, key: "link-or-button", class: "link-or-button" }, this.label));
	    const linkPure = (validateProps.h(PrefixedTagNames.pLinkPure, { ...sharedLinkProps, ...linkProps, key: "link-or-button-pure", class: "link-or-button-pure", hideLabel: true, icon: "arrow-right" }, this.label));
	    return (validateProps.h("div", { class: "root" }, validateProps.h("div", { class: "image-container" }, validateProps.h("slot", null)), validateProps.h("div", { class: "content" }, validateProps.h("a", { ...sharedLinkProps, class: "link-overlay", tabIndex: -1, "aria-hidden": "true" }), validateProps.h("p", null, this.description), typeof this.compact === 'boolean' ? (this.compact ? linkPure : link) : [linkPure, link])));
	  }
	  static get delegatesFocus() { return true; }
	  get host() { return validateProps.getElement(this); }
	};

	pLinkTile_cjs_entry.p_link_tile = LinkTile;

	
	return pLinkTile_cjs_entry;
}

var pLink_cjs_entry = {};

var hasRequiredPLink_cjs_entry;

function requirePLink_cjs_entry () {
	if (hasRequiredPLink_cjs_entry) return pLink_cjs_entry;
	hasRequiredPLink_cjs_entry = 1;

	Object.defineProperty(pLink_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const linkAriaAttribute = requireLinkAriaAttribute5de11e89();
	const buttonLinkPureUtils = requireButtonLinkPureUtils468dbe67();
	const isSsrHydration = requireIsSsrHydration9278b79b();
	const theme = requireThemeBfc10573();
	const throwIfInvalidLinkUsage = requireThrowIfInvalidLinkUsage0b248592();
	const linkButtonVariant = requireLinkButtonVariant3104b925();
	const linkStyles = requireLinkStyles60ad2b7b();
	requireIsParentOfKindA9c351f2();
	requireGetOnlyChildOfKindHTMLElementOrThrowF6972c1c();
	requireGetDirectChildHTMLElements0adb2021();
	requireGetHTMLElements21fc87cc();
	requireTransformSelectorToDirectChildSelector08da8668();
	requireIsThemeAutoC90cd35d();
	requireLinkButtonStylesE68cc0c9();
	requireColorSchemeStyles81696be8();
	requireHoverMediaQueryF2ccfc24();
	requireBorderRadiusSmall5f37fc45();
	requireTextSmallStyle7246779a();
	requireTextShared9135e2ef();
	requireFontLineHeight78b03658();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireSpacingStaticSmall2130ed04();
	requireBorderRadiusMedium758b9411();

	const propTypes = {
	  variant: validateProps.AllowedTypes.oneOf(linkButtonVariant.LINK_BUTTON_VARIANTS),
	  icon: validateProps.AllowedTypes.string,
	  iconSource: validateProps.AllowedTypes.string,
	  href: validateProps.AllowedTypes.string,
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	  target: validateProps.AllowedTypes.string,
	  download: validateProps.AllowedTypes.string,
	  rel: validateProps.AllowedTypes.string,
	  hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	  aria: validateProps.AllowedTypes.aria(linkAriaAttribute.LINK_ARIA_ATTRIBUTES),
	};
	const Link = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.variant = 'primary';
	    this.icon = 'none';
	    this.iconSource = undefined;
	    this.href = undefined;
	    this.theme = 'light';
	    this.target = '_self';
	    this.download = undefined;
	    this.rel = undefined;
	    this.hideLabel = false;
	    this.aria = undefined;
	  }
	  componentWillLoad() {
	    if (!isSsrHydration.isSsrHydration(this.host)) {
	      // when ssr rendered component is partially hydrated before being rerendered by its parent (e.g. link-tile)
	      // it has no href prop and no slotted anchor, so validation fails
	      throwIfInvalidLinkUsage.throwIfInvalidLinkUsage(this.host, this.href);
	    }
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    validateProps.attachComponentCss(this.host, linkStyles.getComponentCss, this.icon, this.iconSource, this.variant, this.hideLabel, !this.href, this.theme);
	    const TagType = this.href === undefined ? 'span' : 'a';
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    return (validateProps.h(TagType, { class: "root", ...(TagType === 'a' && {
	        href: this.href,
	        target: this.target,
	        download: this.download,
	        rel: this.rel,
	        ...validateProps.parseAndGetAriaAttributes(this.aria),
	      }) }, buttonLinkPureUtils.hasVisibleIcon(this.icon, this.iconSource) && (validateProps.h(PrefixedTagNames.pIcon, { class: "icon", size: "inherit", name: this.iconSource ? undefined : this.icon, source: this.iconSource, theme: this.theme, "aria-hidden": "true" })), validateProps.h("span", { class: "label" }, validateProps.h("slot", null))));
	  }
	  static get delegatesFocus() { return true; }
	  get host() { return validateProps.getElement(this); }
	};

	pLink_cjs_entry.p_link = Link;

	
	return pLink_cjs_entry;
}

var pMarque_cjs_entry = {};

var hasRequiredPMarque_cjs_entry;

function requirePMarque_cjs_entry () {
	if (hasRequiredPMarque_cjs_entry) return pMarque_cjs_entry;
	hasRequiredPMarque_cjs_entry = 1;

	Object.defineProperty(pMarque_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const getCDNBaseURL = requireGetCDNBaseURLE7722df3();
	const linkAriaAttribute = requireLinkAriaAttribute5de11e89();
	const warnIfDeprecatedComponentIsUsed = requireWarnIfDeprecatedComponentIsUsed80115a1d();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();

	const MARQUES_MANIFEST = { "porscheMarqueTrademark": { "medium": { "1x": { "png": "porsche-marque-trademark.medium.min.da075315857e239ff46bf4c150648ff0@1x.png", "webp": "porsche-marque-trademark.medium.min.5c6af9aa7946fea34f60c8f8c95d0188@1x.webp" }, "2x": { "png": "porsche-marque-trademark.medium.min.aa801f42028b1c385a5e26ae115da598@2x.png", "webp": "porsche-marque-trademark.medium.min.fff6e9b91481cc5b1fc6c9b62987ccaf@2x.webp" }, "3x": { "png": "porsche-marque-trademark.medium.min.824818d15eaf445f50e0a2391613f214@3x.png", "webp": "porsche-marque-trademark.medium.min.f67092ff6b5f4ecb4add73d6ae153db0@3x.webp" } }, "small": { "1x": { "png": "porsche-marque-trademark.small.min.020244b41a29323e2a7932a264514cdf@1x.png", "webp": "porsche-marque-trademark.small.min.783639706bead66b2d56e3b8b64bd61f@1x.webp" }, "2x": { "png": "porsche-marque-trademark.small.min.92184fae44511ceda8320443c17110b1@2x.png", "webp": "porsche-marque-trademark.small.min.760a57efa93d4e7e16e26128ec7ead46@2x.webp" }, "3x": { "png": "porsche-marque-trademark.small.min.fd545cea4298f5d797246d5805711646@3x.png", "webp": "porsche-marque-trademark.small.min.1726036a7829347e1e24d1eb54fc0d64@3x.webp" } } }, "porscheMarque": { "medium": { "1x": { "png": "porsche-marque.medium.min.a98627440b05154565f9f9dfc1ad6187@1x.png", "webp": "porsche-marque.medium.min.fa908e4dfdc5536b0e933e1670d20e1f@1x.webp" }, "2x": { "png": "porsche-marque.medium.min.089d6dd560fff7a2bf613ae6d528990e@2x.png", "webp": "porsche-marque.medium.min.7f0893dc57f2607a2cb0b817d96cb985@2x.webp" }, "3x": { "png": "porsche-marque.medium.min.2cb874345ef290831c929f6caabfeef8@3x.png", "webp": "porsche-marque.medium.min.3534cf066b4e2e737dca62de495f9616@3x.webp" } }, "small": { "1x": { "png": "porsche-marque.small.min.ac2042736af5512cf547c89fa7924c4f@1x.png", "webp": "porsche-marque.small.min.005debed5bf72cf0a9a791b1521f5e1d@1x.webp" }, "2x": { "png": "porsche-marque.small.min.22f1e9dc90399d9a5287eda689b60dba@2x.png", "webp": "porsche-marque.small.min.df4317325d04ffef28c7839aa6d499a0@2x.webp" }, "3x": { "png": "porsche-marque.small.min.49209245f04eadef8817b9bbae80d3e1@3x.png", "webp": "porsche-marque.small.min.cfd6149aaa3bc5b3b522538e5f650890@3x.webp" } } }, "porscheMarque75": { "medium": { "1x": { "png": "porsche-marque75.medium.min.0a02e2256062de963f2fef2c02d20200@1x.png", "webp": "porsche-marque75.medium.min.99b2d657558f0531d639782974e8fd06@1x.webp" }, "2x": { "png": "porsche-marque75.medium.min.1d41ecfb8f5277d3f4bd65d25d22eea3@2x.png", "webp": "porsche-marque75.medium.min.e32580cd1ac179e354ed8fcb31694168@2x.webp" }, "3x": { "png": "porsche-marque75.medium.min.373bcb5f89d31c8b6084e66e902b9f4c@3x.png", "webp": "porsche-marque75.medium.min.4a003d1e5e81db062bf92d52ba797087@3x.webp" } }, "small": { "1x": { "png": "porsche-marque75.small.min.f5b37fe12cd4487432ff77fdd8469f7d@1x.png", "webp": "porsche-marque75.small.min.146b06cffe2b11c07f3113a51f337b98@1x.webp" }, "2x": { "png": "porsche-marque75.small.min.20d86908f2190640a6f24fce1ee49035@2x.png", "webp": "porsche-marque75.small.min.025770f8db54857874c130999b370ed8@2x.webp" }, "3x": { "png": "porsche-marque75.small.min.e89b13e14a088a273107bf1057f7f67d@3x.png", "webp": "porsche-marque75.small.min.a725d2ec7bd07be17afd8feb2589b156@3x.webp" } } } };

	const MARQUE_VARIANTS = ['75-years', 'default'];
	const getInnerManifest = (variant, trademark) => MARQUES_MANIFEST[variant === '75-years' ? 'porscheMarque75' : `porscheMarque${trademark ? 'Trademark' : ''}`];
	const buildSrcSet = (innerManifest, size, format) => 
	// eslint-disable-next-line @typescript-eslint/no-unsafe-argument
	Object.entries(innerManifest[size])
	  .map(([resolution, fileName]) => `${getCDNBaseURL.getCDNBaseURL()}/marque/${fileName[format]} ${resolution}`)
	  .join();
	const buildImgSrc = (innerManifest) => `${getCDNBaseURL.getCDNBaseURL()}/marque/${innerManifest.medium['2x'].png}`;

	const baseSizes = {
	  small: {
	    width: '100px',
	    height: '60px',
	  },
	  medium: {
	    width: '120px',
	    height: '72px',
	  },
	};
	const getComponentCss = (size) => {
	  return validateProps.getCss({
	    '@global': {
	      ':host': {
	        position: 'relative',
	        display: 'inline-flex',
	        verticalAlign: 'top',
	        ...validateProps.addImportantToEachRule({
	          outline: 0,
	          ...colorSchemeStyles.colorSchemeStyles,
	          ...colorSchemeStyles.hostHiddenStyles,
	        }),
	      },
	      a: {
	        display: 'block',
	        textDecoration: 'none',
	        ...validateProps.focusPseudoJssStyle,
	      },
	      picture: {
	        display: 'block',
	        ...(size === 'responsive'
	          ? {
	            ...baseSizes.small,
	            [validateProps.getMediaQueryMin('l')]: baseSizes.medium,
	          }
	          : baseSizes[size]),
	      },
	      img: {
	        display: 'block',
	        width: '100%',
	        height: 'auto',
	      },
	    },
	  });
	};

	const MARQUE_SIZES = ['responsive', 'small', 'medium'];

	const propTypes = {
	  trademark: validateProps.AllowedTypes.boolean,
	  variant: validateProps.AllowedTypes.oneOf(MARQUE_VARIANTS),
	  size: validateProps.AllowedTypes.oneOf(MARQUE_SIZES),
	  href: validateProps.AllowedTypes.string,
	  target: validateProps.AllowedTypes.string,
	  aria: validateProps.AllowedTypes.aria(linkAriaAttribute.LINK_ARIA_ATTRIBUTES),
	};
	const Marque = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.trademark = true;
	    this.variant = 'default';
	    this.size = 'responsive';
	    this.href = undefined;
	    this.target = '_self';
	    this.aria = undefined;
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    warnIfDeprecatedComponentIsUsed.warnIfDeprecatedComponentIsUsed(this.host, 'Please use new p-wordmark component instead.');
	    validateProps.attachComponentCss(this.host, getComponentCss, this.size);
	    const innerManifest = getInnerManifest(this.variant, this.trademark);
	    const mediumMedia = `(min-width: ${validateProps.breakpoint.l}px)`;
	    const picture = window.PDS_SKIP_FETCH ? undefined :  (validateProps.h("picture", null, this.size === 'responsive'
	      ? [
	        validateProps.h("source", { key: "medium-webp", srcSet: buildSrcSet(innerManifest, 'medium', 'webp'), media: mediumMedia, type: "image/webp" }),
	        validateProps.h("source", { key: "medium-png", srcSet: buildSrcSet(innerManifest, 'medium', 'png'), media: mediumMedia, type: "image/png" }),
	        validateProps.h("source", { key: "small-webp", srcSet: buildSrcSet(innerManifest, 'small', 'webp'), type: "image/webp" }),
	        validateProps.h("source", { key: "small-png", srcSet: buildSrcSet(innerManifest, 'small', 'png'), type: "image/png" }),
	      ]
	      : [
	        validateProps.h("source", { key: "webp", srcSet: buildSrcSet(innerManifest, this.size, 'webp'), type: "image/webp" }),
	        validateProps.h("source", { key: "png", srcSet: buildSrcSet(innerManifest, this.size, 'png'), type: "image/png" }),
	      ], validateProps.h("img", { src: buildImgSrc(innerManifest), alt: "Porsche" })));
	    return (validateProps.h(validateProps.Host, null, this.href === undefined ? (picture) : (validateProps.h("a", { href: this.href, target: this.target, ...validateProps.parseAndGetAriaAttributes(this.aria) }, picture))));
	  }
	  static get delegatesFocus() { return true; }
	  get host() { return validateProps.getElement(this); }
	};

	pMarque_cjs_entry.p_marque = Marque;

	
	return pMarque_cjs_entry;
}

var pModal_cjs_entry = {};

var hasRequiredPModal_cjs_entry;

function requirePModal_cjs_entry () {
	if (hasRequiredPModal_cjs_entry) return pModal_cjs_entry;
	hasRequiredPModal_cjs_entry = 1;

	Object.defineProperty(pModal_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const hasNamedSlot = requireHasNamedSlot28c6bca1();
	const modalUtils = requireModalUtils9e25e7f9();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed3a5c494c();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const hoverMediaQuery = requireHoverMediaQueryF2ccfc24();
	const constants = requireConstantsCa271244();
	const headingShared = requireHeadingSharedAa59e66d();
	const fontSizeHeadingLarge = requireFontSizeHeadingLargeC355151d();
	const gridExtendedOffsetBase = requireGridExtendedOffsetBaseFb9830f6();
	const borderRadiusMedium = requireBorderRadiusMedium758b9411();
	requireGetNamedSlotA433c432();
	requireHelperE5c4e0db();
	requireFontLineHeight78b03658();
	requireFontWeightSemiBold4482c830();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextLarge05a4bc90();

	const headingLargeStyle = {
	    font: `${headingShared._headingFontPartA}${fontSizeHeadingLarge.fontSizeHeadingLarge}${headingShared._headingFontPartB}`,
	};

	const mediaQueryXl = validateProps.getMediaQueryMin('xl');
	const { backgroundColor, primaryColor: lightThemePrimaryColor } = validateProps.getThemedColors('light');
	const { primaryColor: darkThemePrimaryColor, contrastHighColor: darkThemeContrastHighColor } = validateProps.getThemedColors('dark');
	const transitionTimingFunction = 'cubic-bezier(.16,1,.3,1)';
	const stretchToFullModalWidthClassName = 'stretch-to-full-modal-width';
	const marginTopBottom = 'clamp(16px, 7vh, 192px)';
	const footerShadowClass = 'footer--shadow';
	const getFullscreenJssStyles = (fullscreen) => {
	  return fullscreen
	    ? {
	      minWidth: '100%',
	      maxWidth: 'none',
	      minHeight: '100%',
	      margin: 0,
	      borderRadius: 0,
	    }
	    : {
	      minWidth: '276px',
	      maxWidth: '1535.5px',
	      minHeight: 'auto',
	      margin: `${marginTopBottom} ${gridExtendedOffsetBase.gridExtendedOffsetBase}`,
	      borderRadius: borderRadiusMedium.borderRadiusMedium,
	    };
	};
	const isFullscreenForXl = (fullscreen) => {
	  const fullscreenParsed = validateProps.parseJSON(fullscreen);
	  if (typeof fullscreenParsed === 'boolean') {
	    return fullscreenParsed;
	  }
	  else {
	    const entries = Object.entries(fullscreenParsed);
	    const [lastTrueBreakpoint] = entries.filter(([, val]) => val).pop() || [];
	    const [lastFalseBreakpoint] = entries.filter(([, val]) => !val).pop() || [];
	    return validateProps.breakpoints.indexOf(lastTrueBreakpoint) > validateProps.breakpoints.indexOf(lastFalseBreakpoint);
	  }
	};
	const getSlottedJssStyle = (marginValue, hasHeader, hasDismissButton) => {
	  const marginPx = `${-marginValue}px`;
	  return {
	    [`&(.${stretchToFullModalWidthClassName})`]: {
	      width: `calc(100% + ${marginValue * 2}px)`,
	      margin: `0 ${marginPx}`,
	    },
	    ...(!hasHeader && {
	      [`&(.${stretchToFullModalWidthClassName}:first-child)`]: {
	        marginTop: hasDismissButton ? validateProps.pxToRemWithUnit(-marginValue) : marginPx,
	      },
	    }),
	    [`&(.${stretchToFullModalWidthClassName}:last-child)`]: {
	      marginBottom: marginPx,
	    },
	  };
	};
	const getComponentCss = (isOpen, isFullscreen, hasDismissButton, hasHeader, hasFooter) => {
	  const isFullscreenForXlAndXxl = isFullscreenForXl(isFullscreen);
	  const duration = isOpen ? '.6s' : '.2s';
	  const contentPadding = '32px';
	  return validateProps.getCss({
	    '@global': {
	      ':host': {
	        ...validateProps.addImportantToEachRule({
	          position: 'fixed',
	          ...validateProps.getInsetJssStyle(),
	          zIndex: constants.MODAL_Z_INDEX,
	          display: 'flex',
	          alignItems: 'center',
	          justifyContent: 'center',
	          flexWrap: 'wrap',
	          ...(isOpen
	            ? {
	              visibility: 'inherit',
	            }
	            : {
	              visibility: 'hidden',
	              transition: 'visibility 0s linear .2s',
	            }),
	          ...colorSchemeStyles.colorSchemeStyles,
	          ...colorSchemeStyles.hostHiddenStyles,
	          ...validateProps.getFrostedGlassBackgroundJssStyles(isOpen, duration),
	        }),
	        overflowY: 'auto', // overrideable
	      },
	      '::slotted': validateProps.addImportantToEachRule(validateProps.mergeDeep(getSlottedJssStyle(32, hasHeader, hasDismissButton), validateProps.buildResponsiveStyles(isFullscreen, (fullscreenValue) => ({
	        [`&(.${stretchToFullModalWidthClassName}`]: {
	          '&:first-child)': {
	            borderRadius: fullscreenValue ? 0 : '8px 8px 0 0',
	          },
	          '&:last-child)': {
	            borderRadius: fullscreenValue ? 0 : '0 0 8px 8px',
	          },
	        },
	      })))),
	      h2: {
	        ...headingLargeStyle,
	        margin: 0,
	        color: lightThemePrimaryColor,
	      },
	    },
	    root: validateProps.mergeDeep({
	      position: 'relative',
	      boxSizing: 'border-box',
	      transform: isOpen ? 'scale3d(1,1,1)' : 'scale3d(.9,.9,1)',
	      opacity: isOpen ? 1 : 0,
	      transition: `opacity ${duration} ${transitionTimingFunction},transform ${duration} ${transitionTimingFunction}`,
	      paddingTop: hasDismissButton ? validateProps.pxToRemWithUnit(32) : contentPadding,
	      ...(!hasFooter && { paddingBottom: contentPadding }),
	      background: backgroundColor,
	      outline: validateProps.isHighContrastMode ? '1px solid transparent' : 0,
	      // ::after to be above sticky footer without z-index games
	      '&:focus::after': {
	        content: '""',
	        position: 'fixed',
	        border: `${validateProps.borderWidthBase} solid`,
	        pointerEvents: 'none',
	        ...validateProps.buildResponsiveStyles(isFullscreen, (fullscreenValue) => ({
	          borderRadius: fullscreenValue ? 0 : '12px',
	          borderColor: fullscreenValue ? lightThemePrimaryColor : darkThemePrimaryColor,
	          ...validateProps.getInsetJssStyle(fullscreenValue ? 0 : -4),
	        })),
	      },
	      '&:not(:focus-visible)::before': {
	        border: 0,
	      },
	      [mediaQueryXl]: {
	        margin: isFullscreenForXlAndXxl ? 0 : `min(192px, 10vh) ${gridExtendedOffsetBase.gridExtendedOffsetBase}`,
	      },
	    }, validateProps.buildResponsiveStyles(isFullscreen, getFullscreenJssStyles) // potentially needs to be merged with mediaQueryXl
	    ),
	    ...(hasHeader && {
	      header: {
	        padding: `0 ${contentPadding} 8px`,
	      },
	    }),
	    content: {
	      ...(hasFooter && {
	        position: 'relative',
	        zIndex: 0,
	      }),
	      padding: `0 ${contentPadding}`,
	    },
	    ...(hasFooter && {
	      footer: {
	        position: 'sticky',
	        background: backgroundColor,
	        padding: contentPadding,
	        bottom: 0,
	        borderBottomLeftRadius: borderRadiusMedium.borderRadiusMedium,
	        borderBottomRightRadius: borderRadiusMedium.borderRadiusMedium,
	      },
	      [footerShadowClass]: {
	        boxShadow: `${modalUtils.scrollShadowColor} 0 -5px 10px`,
	        clipPath: 'inset(-20px 0 0 0)', // crop leaking box-shadow on left and right side
	      },
	    }),
	    ...(hasDismissButton && {
	      dismiss: {
	        position: 'absolute',
	        top: '8px',
	        right: '8px',
	        border: `2px solid ${backgroundColor}`,
	        borderRadius: '4px',
	        background: backgroundColor,
	        ...hoverMediaQuery.hoverMediaQuery({
	          '&:hover': {
	            background: darkThemeContrastHighColor,
	            borderColor: darkThemeContrastHighColor,
	          },
	        }),
	      },
	    }),
	  });
	};

	const propTypes = {
	  open: validateProps.AllowedTypes.boolean,
	  disableCloseButton: validateProps.AllowedTypes.boolean,
	  dismissButton: validateProps.AllowedTypes.boolean,
	  disableBackdropClick: validateProps.AllowedTypes.boolean,
	  heading: validateProps.AllowedTypes.string,
	  fullscreen: validateProps.AllowedTypes.breakpoint('boolean'),
	  aria: validateProps.AllowedTypes.aria(modalUtils.MODAL_ARIA_ATTRIBUTES),
	};
	const Modal = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.close = validateProps.createEvent(this, "close", 3);
	    this.dismiss = validateProps.createEvent(this, "dismiss", 3);
	    this.onSlotChange = () => {
	      if (this.open) {
	        // 1 tick delay is needed so that web components can be bootstrapped
	        setTimeout(() => {
	          this.updateFocusTrap(true);
	          this.dialog.focus(); // set initial focus
	        });
	      }
	    };
	    // eslint-disable-next-line @typescript-eslint/member-ordering
	    this.onScroll = validateProps.throttle(100, () => {
	      // using an intersection observer would be so much easier but very tricky with the current layout
	      // also transform scale3d has an impact on the intersection observer, causing it to trigger
	      // initially and after the transition which makes the shadow appear later
	      // using an invisible element after the dialog div would work
	      // but layout with position: fixed and flex for vertical/horizontal centering scrollable content
	      // causes tons of problems, also considering fullscreen mode, etc.
	      // see https://stackoverflow.com/questions/33454533/cant-scroll-to-top-of-flex-item-that-is-overflowing-container
	      const { scrollHeight, clientHeight, scrollTop } = this.host;
	      if (scrollHeight > clientHeight) {
	        const shouldApplyShadow = scrollHeight - clientHeight > scrollTop + parseInt(getComputedStyle(this.dialog).marginBottom, 10);
	        this.footer.classList.toggle(footerShadowClass, shouldApplyShadow);
	      }
	    });
	    this.onMouseDown = (e) => {
	      if (e.composedPath()[0] === this.host && !modalUtils.clickStartedInScrollbarTrack(this.host, e)) {
	        this.dismissModal();
	      }
	    };
	    this.dismissModal = () => {
	      if (this.hasDismissButton) {
	        this.dismiss.emit();
	        this.close.emit();
	      }
	    };
	    this.open = false;
	    this.disableCloseButton = undefined;
	    this.dismissButton = true;
	    this.disableBackdropClick = false;
	    this.heading = undefined;
	    this.fullscreen = false;
	    this.aria = undefined;
	  }
	  get hasDismissButton() {
	    return this.disableCloseButton ? false : this.dismissButton;
	  }
	  openChangeHandler(isOpen) {
	    this.updateFocusTrap(isOpen);
	    if (isOpen) {
	      this.focusedElBeforeOpen = document.activeElement;
	    }
	    else {
	      this.focusedElBeforeOpen?.focus();
	    }
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  componentDidLoad() {
	    // in case modal is rendered with open prop
	    if (this.open) {
	      this.updateFocusTrap(true);
	    }
	  }
	  componentDidRender() {
	    if (this.open) {
	      // reset scroll top to zero in case content is longer than viewport height, - some timeout is needed although it shouldn't
	      for (let i = 0; i < 4; i++) {
	        setTimeout(() => (this.host.scrollTop = 0), i * 5);
	      }
	      if (this.hasFooter) {
	        this.onScroll();
	      }
	      this.dialog.focus(); // needs to happen after render
	    }
	  }
	  disconnectedCallback() {
	    this.updateFocusTrap(false);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'disableCloseButton', 'Please use dismissButton prop instead.');
	    if (this.open) {
	      modalUtils.warnIfAriaAndHeadingPropsAreUndefined(this.host, this.heading, this.aria);
	    }
	    this.hasHeader = !!this.heading || hasNamedSlot.hasNamedSlot(this.host, 'heading');
	    this.hasFooter = hasNamedSlot.hasNamedSlot(this.host, 'footer');
	    validateProps.attachComponentCss(this.host, getComponentCss, this.open, this.fullscreen, this.hasDismissButton, this.hasHeader, this.hasFooter);
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    return (validateProps.h(validateProps.Host, { onMouseDown: !this.disableBackdropClick && this.onMouseDown, onScroll: this.hasFooter && this.onScroll }, validateProps.h("div", { class: "root", role: "dialog", ...validateProps.parseAndGetAriaAttributes({
	        'aria-modal': true,
	        'aria-label': this.heading,
	        'aria-hidden': !this.open,
	        ...validateProps.parseAndGetAriaAttributes(this.aria),
	      }), tabIndex: -1, ref: (el) => (this.dialog = el) }, this.hasDismissButton && (validateProps.h(PrefixedTagNames.pButtonPure, { class: "dismiss", type: "button", ref: (el) => (this.dismissBtn = el), hideLabel: true, icon: "close", onClick: this.dismissModal }, "Dismiss modal")), this.hasHeader && (validateProps.h("div", { class: "header" }, this.heading ? validateProps.h("h2", null, this.heading) : validateProps.h("slot", { name: "heading" }))), validateProps.h("div", { class: "content" }, validateProps.h("slot", { onSlotchange: this.onSlotChange })), this.hasFooter && (validateProps.h("div", { class: "footer", ref: (el) => (this.footer = el) }, validateProps.h("slot", { name: "footer" }))))));
	  }
	  updateFocusTrap(isOpen) {
	    modalUtils.setFocusTrap(this.host, isOpen, !this.disableCloseButton && this.dismissBtn, this.dismissModal);
	    modalUtils.setScrollLock(isOpen);
	  }
	  get host() { return validateProps.getElement(this); }
	  static get watchers() { return {
	    "open": ["openChangeHandler"]
	  }; }
	};

	pModal_cjs_entry.p_modal = Modal;

	
	return pModal_cjs_entry;
}

var pModelSignature_cjs_entry = {};

var hasRequiredPModelSignature_cjs_entry;

function requirePModelSignature_cjs_entry () {
	if (hasRequiredPModelSignature_cjs_entry) return pModelSignature_cjs_entry;
	hasRequiredPModelSignature_cjs_entry = 1;

	Object.defineProperty(pModelSignature_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const schemedHighContrastMediaQuery = requireSchemedHighContrastMediaQuery5956ba22();
	const filtersPrimary = requireFiltersPrimary7e1fcfed();
	const getCDNBaseURL = requireGetCDNBaseURLE7722df3();

	const MODEL_SIGNATURES_MANIFEST = { "718": "718.min.d92dc0fe91e67bd51120d91c5cd1eb2f.svg", "911": "911.min.5c462658f9d472e90a139173414e8fdd.svg", "boxster": "boxster.min.5e7b22a1fa25004a4f97807d57f32b21.svg", "cayenne": "cayenne.min.4026ba6b335cc98e10592f900cf731e1.svg", "cayman": "cayman.min.c634f6f3de1d67610b2e4230e60337fb.svg", "macan": "macan.min.e38fbf34ed4f00066620901babd99af0.svg", "panamera": "panamera.min.d35913b252657f7c5cfcae74cfd61b26.svg", "taycan": "taycan.min.ba4e7c3cb86a78d626d4463b81be0f23.svg", "turbo-s": "turbo-s.min.8201d60c1b5e00daf9e23784fd199111.svg", "turbo": "turbo.min.cfde5de85fdc84be597dfad4402c5f6f.svg" };

	const MODEL_SIGNATURE_SIZES = ['small', 'inherit'];
	const MODEL_SIGNATURE_MODELS = Object.keys(MODEL_SIGNATURES_MANIFEST);
	const MODEL_SIGNATURE_COLORS = [
	  'primary',
	  'contrast-low',
	  'contrast-medium',
	  'contrast-high',
	  'inherit',
	];
	const getSvgUrl = (model) => {
	  return `${getCDNBaseURL.getCDNBaseURL()}/model-signatures/${MODEL_SIGNATURES_MANIFEST[model]}`;
	};
	const modelSignatureHeight = 36;

	const colorToFilterLight = {
	  primary: filtersPrimary.filterLightPrimary,
	  'contrast-low': filtersPrimary.filterLightContrastLow,
	  'contrast-medium': filtersPrimary.filterLightContrastMedium,
	  'contrast-high': filtersPrimary.filterLightContrastHigh,
	};
	const colorToFilterDark = {
	  primary: filtersPrimary.filterDarkPrimary,
	  'contrast-low': filtersPrimary.filterDarkContrastLow,
	  'contrast-medium': filtersPrimary.filterDarkContrastMedium,
	  'contrast-high': filtersPrimary.filterDarkContrastHigh,
	};
	const colorToFilterMap = {
	  auto: colorToFilterLight,
	  light: colorToFilterLight,
	  dark: colorToFilterDark,
	};
	const getComponentCss = (size, color, theme) => {
	  const isSizeInherit = size === 'inherit';
	  const isColorInherit = color === 'inherit';
	  return validateProps.getCss({
	    '@global': {
	      ':host': {
	        display: 'inline-block',
	        verticalAlign: 'top',
	        ...validateProps.addImportantToEachRule({
	          maxWidth: '100%',
	          maxHeight: '100%',
	          ...(!isSizeInherit && {
	            width: 'inherit',
	            height: 'inherit',
	            // TODO: we need a width map of all signatures to ensure same fluid behavior like implemented fro crest + wordmark
	            maxHeight: `${modelSignatureHeight}px`,
	          }),
	          ...colorSchemeStyles.colorSchemeStyles,
	          ...colorSchemeStyles.hostHiddenStyles,
	        }),
	      },
	      img: {
	        display: 'block',
	        maxWidth: '100%',
	        maxHeight: '100%',
	        pointerEvents: 'none',
	        ...(!isColorInherit && {
	          filter: colorToFilterMap[theme][color],
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	            filter: colorToFilterMap.dark[color],
	          }),
	          ...(validateProps.isHighContrastMode &&
	            schemedHighContrastMediaQuery.getSchemedHighContrastMediaQuery({
	              filter: colorToFilterMap.light[color],
	            }, {
	              filter: colorToFilterMap.dark[color],
	            })),
	        }),
	        ...(isSizeInherit && { height: size }),
	      },
	    },
	  });
	};

	const propTypes = {
	  model: validateProps.AllowedTypes.oneOf(MODEL_SIGNATURE_MODELS),
	  size: validateProps.AllowedTypes.oneOf(MODEL_SIGNATURE_SIZES),
	  color: validateProps.AllowedTypes.oneOf(MODEL_SIGNATURE_COLORS),
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const ModelSignature = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.model = '911';
	    this.size = 'small';
	    this.color = 'primary';
	    this.theme = 'light';
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    validateProps.attachComponentCss(this.host, getComponentCss, this.size, this.color, this.theme);
	    return validateProps.h("img", { src: getSvgUrl(this.model), height: modelSignatureHeight, alt: this.model });
	  }
	  get host() { return validateProps.getElement(this); }
	};

	pModelSignature_cjs_entry.p_model_signature = ModelSignature;

	
	return pModelSignature_cjs_entry;
}

var pMultiSelect_2_cjs_entry = {};

var setAttributes642a7e67 = {};

var hasRequiredSetAttributes642a7e67;

function requireSetAttributes642a7e67 () {
	if (hasRequiredSetAttributes642a7e67) return setAttributes642a7e67;
	hasRequiredSetAttributes642a7e67 = 1;

	/**
	 * Sets attributes on an HTMLElement.
	 *
	 * @param {HTMLElement} host - The target HTMLElement to set attributes on.
	 * @param {{ [x: string]: string }} attributes - An object of attribute names and their corresponding values.
	 * @returns {void}
	 */
	const setAttributes = (host, attributes) => Object.entries(attributes).forEach((args) => host.setAttribute(...args));

	setAttributes642a7e67.setAttributes = setAttributes;

	
	return setAttributes642a7e67;
}

var selectDropdown5f011c9b = {};

var hasRequiredSelectDropdown5f011c9b;

function requireSelectDropdown5f011c9b () {
	if (hasRequiredSelectDropdown5f011c9b) return selectDropdown5f011c9b;
	hasRequiredSelectDropdown5f011c9b = 1;

	const formStyles = requireFormStyles97f2cdf7();
	const validateProps = requireValidatePropsC2afb75b();

	const getFilterInputAriaAttributes = (isOpen, isRequired, labelId, descriptionId, dropdownId, activeDescendantId) => {
	  return {
	    ...getSelectDropdownButtonAriaAttributes(isOpen, labelId, descriptionId, dropdownId, activeDescendantId),
	    'aria-autocomplete': 'list',
	    ...(isRequired && {
	      'aria-required': 'true',
	    }),
	  };
	};
	const getSelectDropdownButtonAriaAttributes = (isOpen, labelId, descriptionId, dropdownId, activeDescendantId) => {
	  return {
	    'aria-labelledby': labelId || null,
	    'aria-describedby': descriptionId || null,
	    'aria-haspopup': 'listbox',
	    'aria-expanded': isOpen ? 'true' : 'false',
	    'aria-controls': dropdownId,
	    ...(isOpen &&
	      activeDescendantId !== undefined && {
	      'aria-activedescendant': `option-${activeDescendantId}`,
	    }),
	  };
	};
	const getListAriaAttributes = (label, isRequired, hasFilter, isOpen, multiple = false) => {
	  return {
	    role: 'listbox',
	    'aria-label': label,
	    ...(isRequired &&
	      !hasFilter && {
	      'aria-required': 'true',
	    }),
	    ...(!isOpen && {
	      'aria-hidden': 'true',
	    }),
	    ...(multiple && {
	      'aria-multiselectable': 'true',
	    }),
	  };
	};
	const getOptionAriaAttributes = (isSelected, isDisabled, isHidden, hasValue) => ({
	  ...(!isHidden && { 'aria-selected': isSelected ? 'true' : 'false' }),
	  'aria-disabled': isDisabled ? 'true' : null,
	  'aria-hidden': isHidden ? 'true' : null,
	  'aria-label': hasValue ? null : 'Empty value',
	});

	const OPTION_HEIGHT = 40; // optgroups are higher and ignored
	const MULTI_SELECT_OPTION_HEIGHT = 44;
	const getNoResultsOptionJssStyle = () => ({
	  '&[role=status]': {
	    cursor: 'not-allowed',
	  },
	  '&__sr': validateProps.getHiddenTextJssStyle(),
	});

	const SELECT_DROPDOWN_DIRECTIONS_INTERNAL = ['down', 'up'];
	const SELECT_DROPDOWN_DIRECTIONS = [...SELECT_DROPDOWN_DIRECTIONS_INTERNAL, 'auto'];
	const MAX_CHILDREN = 9;
	const determineDropdownDirection = (host, visibleOptionLength) => {
	  const { top } = host.getBoundingClientRect();
	  const listHeight = OPTION_HEIGHT * (visibleOptionLength > MAX_CHILDREN ? MAX_CHILDREN : visibleOptionLength) + 64; // 64 = 2 x 6px padding + 2px border + 50px combobox height
	  const spaceBottom = window.innerHeight - top - formStyles.INPUT_HEIGHT;
	  return spaceBottom <= listHeight && top >= listHeight ? 'up' : 'down';
	};

	selectDropdown5f011c9b.MULTI_SELECT_OPTION_HEIGHT = MULTI_SELECT_OPTION_HEIGHT;
	selectDropdown5f011c9b.OPTION_HEIGHT = OPTION_HEIGHT;
	selectDropdown5f011c9b.SELECT_DROPDOWN_DIRECTIONS = SELECT_DROPDOWN_DIRECTIONS;
	selectDropdown5f011c9b.determineDropdownDirection = determineDropdownDirection;
	selectDropdown5f011c9b.getFilterInputAriaAttributes = getFilterInputAriaAttributes;
	selectDropdown5f011c9b.getListAriaAttributes = getListAriaAttributes;
	selectDropdown5f011c9b.getNoResultsOptionJssStyle = getNoResultsOptionJssStyle;
	selectDropdown5f011c9b.getOptionAriaAttributes = getOptionAriaAttributes;
	selectDropdown5f011c9b.getSelectDropdownButtonAriaAttributes = getSelectDropdownButtonAriaAttributes;

	
	return selectDropdown5f011c9b;
}

var hasRequiredPMultiSelect_2_cjs_entry;

function requirePMultiSelect_2_cjs_entry () {
	if (hasRequiredPMultiSelect_2_cjs_entry) return pMultiSelect_2_cjs_entry;
	hasRequiredPMultiSelect_2_cjs_entry = 1;

	Object.defineProperty(pMultiSelect_2_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const setAttributes = requireSetAttributes642a7e67();
	const selectDropdown = requireSelectDropdown5f011c9b();
	const getClosestHTMLElement = requireGetClosestHTMLElement0135bfd9();
	const buttonHandling = requireButtonHandlingA110f521();
	const required = requireRequiredBc18b612();
	const hasDescription = requireHasDescriptionA19e4bdc();
	const isRequiredAndParentNotRequired = requireIsRequiredAndParentNotRequired0b84c8cc();
	const isClickOutside = requireIsClickOutside07c79402();
	const theme = requireThemeBfc10573();
	const throwIfElementIsNotOfKind = requireThrowIfElementIsNotOfKindAad4cb3e();
	const formStyles = requireFormStyles97f2cdf7();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const hoverMediaQuery = requireHoverMediaQueryF2ccfc24();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const fontLineHeight = requireFontLineHeight78b03658();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	requireHasNamedSlot28c6bca1();
	requireGetNamedSlotA433c432();
	requireIsParentFieldsetRequired6f3a68ad();
	requireIsParentOfKindA9c351f2();
	requireFontSizeTextXSmallE59d35d7();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();

	const syncMultiSelectOptionProps = (options, theme) => {
	  options
	    .filter((option) => option.theme !== theme)
	    .forEach((option) => {
	    option.theme = theme;
	    validateProps.forceUpdate(option);
	  });
	};
	const initNativeSelect = (host, name, disabled, required) => {
	  const nativeSelect = document.createElement('select');
	  setAttributes.setAttributes(nativeSelect, {
	    multiple: 'true',
	    'aria-hidden': 'true',
	    tabindex: '-1',
	    slot: 'select',
	  });
	  syncNativeSelect(nativeSelect, name, disabled, required);
	  host.prepend(nativeSelect);
	  return nativeSelect;
	};
	const syncNativeSelect = (nativeSelect, name, disabled, required) => {
	  validateProps.setAttribute(nativeSelect, 'name', name);
	  nativeSelect.toggleAttribute('disabled', disabled);
	  nativeSelect.toggleAttribute('required', required);
	};
	const updateNativeOptions = (nativeSelect, multiSelectOptions) => {
	  nativeSelect.innerHTML = getSelectedOptions(multiSelectOptions)
	    .map((option) => `<option value="${option.value}" selected="${option.selected}">${option.textContent}</option>`)
	    .join('');
	};
	const updateOptionsFilterState = (searchString, options) => {
	  options.forEach((option) => (option.hidden = !option.textContent.toLowerCase().includes(searchString.toLowerCase())));
	};
	const hasFilterOptionResults = (options) => options.some((option) => !option.hidden);
	const resetFilteredOptions = (options) => options.forEach((option) => (option.hidden = false));
	const getSelectedOptions = (options) => options.filter((option) => option.selected);
	const getSelectedOptionValues = (options) => options.filter((option) => option.selected).map((option) => option.value);
	const getSelectedOptionsString = (options) => getSelectedOptions(options)
	  .map((option) => option.textContent)
	  .join(', ');
	const getUsableOptions = (options) => options.filter((option) => !option.hidden && !option.disabled);
	const getHighlightedOption = (options) => options.find((option) => option.highlighted);
	const setSelectedOptions = (options, value) => {
	  const selectedValues = new Set(value);
	  options.forEach((option) => {
	    const shouldBeSelected = selectedValues.has(option.value);
	    if ((option.selected ?? false) !== shouldBeSelected) {
	      option.selected = shouldBeSelected;
	      validateProps.forceUpdate(option);
	    }
	  });
	  const valuesNotIncluded = value.filter((val) => !options.some((option) => option.value === val));
	  if (valuesNotIncluded.length > 0) {
	    validateProps.consoleWarn('The following values are not included in the options of the p-multi-select:', valuesNotIncluded.join(', '));
	  }
	};
	const setHighlightedOption = (option, highlighted) => {
	  option.highlighted = highlighted;
	  validateProps.forceUpdate(option);
	};
	const getHighlightedOptionIndex = (options) => options.indexOf(getHighlightedOption(options));
	const setNextOptionHighlighted = (host, options, newIndex) => {
	  const oldIndex = getHighlightedOptionIndex(options);
	  if (oldIndex !== -1) {
	    setHighlightedOption(options[oldIndex], false);
	  }
	  setHighlightedOption(options[newIndex], true);
	  handleDropdownScroll(host, options[newIndex]);
	};
	const setFirstOptionHighlighted = (host, options) => {
	  const validOptions = getUsableOptions(options);
	  setNextOptionHighlighted(host, options, options.indexOf(validOptions[0]));
	};
	const setLastOptionHighlighted = (host, options) => {
	  const validOptions = getUsableOptions(options);
	  setNextOptionHighlighted(host, options, options.indexOf(validOptions.at(-1)));
	};
	const resetHighlightedOptions = (options) => options.forEach((option) => setHighlightedOption(option, false));
	const resetSelectedOptions = (options) => options.forEach((option) => {
	  if (option.selected) {
	    option.selected = false;
	    validateProps.forceUpdate(option);
	  }
	});
	const getNewOptionIndex = (options, direction) => {
	  const validItems = getUsableOptions(options);
	  const validMax = validItems.length - 1;
	  if (validMax < 0) {
	    return;
	  }
	  const oldIndex = getHighlightedOptionIndex(validItems);
	  let newIndex = oldIndex;
	  if (direction === 'down') {
	    newIndex = oldIndex < validMax ? oldIndex + 1 : 0;
	  }
	  else if (direction === 'up') {
	    newIndex = oldIndex > 0 ? oldIndex - 1 : validMax;
	  }
	  return options.indexOf(validItems[newIndex]);
	};
	const updateHighlightedOption = (host, options, direction) => {
	  const newIndex = getNewOptionIndex(options, direction);
	  setNextOptionHighlighted(host, options, newIndex);
	};
	/**
	 * Handles scrolling within the list to ensure that the highlighted item is always visible.
	 * @param {HTMLElement} scrollElement - The HTML element to be scrolled.
	 * @param {HTMLElement} element - The element to scroll to.
	 * @returns {void}
	 */
	const handleDropdownScroll = (scrollElement, element) => {
	  const { maxHeight } = getComputedStyle(scrollElement);
	  const hostElementHeight = parseInt(maxHeight, 10);
	  if (scrollElement.scrollHeight > hostElementHeight) {
	    element.scrollIntoView();
	  }
	};
	const getDropdownDirection = (direction, host, options) => {
	  if (direction !== 'auto') {
	    return direction;
	  }
	  else if (host) {
	    const visibleOptionsLength = options.filter((option) => !option.hidden).length;
	    return selectDropdown.determineDropdownDirection(host, visibleOptionsLength);
	  }
	  else {
	    return 'down';
	  }
	};

	/**
	 * Generates placeholder styles for an input element.
	 *
	 * @param {JssStyle} styles - The styles to apply to the placeholder.
	 * @returns {JssStyle} - The generated placeholder styles.
	 */
	const getPlaceholderJssStyle = (styles) => ({
	  '&::placeholder': styles,
	  '&::-webkit-input-placeholder': styles /* Chrome/Opera/Safari */,
	  '&::-moz-placeholder': styles /* Firefox 19+ */,
	  '&:-moz-placeholder': styles /* Firefox 18- */,
	});

	const inputYPadding = '13px';
	const selectorNativeSelect = '::slotted([slot=select])';
	const INPUT_HEIGHT_CALC = `${fontLineHeight.fontLineHeight} + 6px + ${validateProps.borderWidthBase} * 2 + ${spacingStaticSmall.spacingStaticSmall} * 2`;
	const getComponentCss$1 = (direction, isOpen, isDisabled, hideLabel, state, isWithinForm, hasLabel, theme) => {
	  const { primaryColor, contrastMediumColor, contrastHighColor, backgroundColor, disabledColor } = validateProps.getThemedColors(theme);
	  const { primaryColor: primaryColorDark, contrastMediumColor: contrastMediumColorDark, contrastHighColor: contrastHighColorDark, backgroundColor: backgroundColorDark, disabledColor: disabledColorDark, } = validateProps.getThemedColors('dark');
	  const { formStateColor, formStateHoverColor } = required.getThemedFormStateColors(theme, state);
	  const { formStateColor: formStateColorDark, formStateHoverColor: formStateHoverColorDark } = required.getThemedFormStateColors('dark', state);
	  const isDirectionDown = direction === 'down';
	  return validateProps.getCss({
	    '@global': {
	      ...validateProps.addImportantToEachRule({
	        ':host': {
	          display: 'block',
	          position: 'relative',
	          ...colorSchemeStyles.colorSchemeStyles,
	          ...colorSchemeStyles.hostHiddenStyles,
	        },
	        ...(isWithinForm && {
	          [selectorNativeSelect]: {
	            position: 'absolute',
	            opacity: 0,
	            height: '0px',
	          },
	        }),
	      }),
	      ...getInputStyles(isDisabled, theme),
	    },
	    root: {
	      position: 'relative',
	    },
	    ...getListStyles(isOpen, direction, theme),
	    'input-container': {
	      display: 'flex',
	      transition: ['color', 'border-color', 'background-color'].map(validateProps.getTransition).join(),
	      cursor: 'text',
	      ...hoverMediaQuery.hoverMediaQuery({
	        '&:hover:not(.disabled)': {
	          borderColor: isOpen ? primaryColor : formStateHoverColor || primaryColor,
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	            borderColor: isOpen ? primaryColorDark : formStateHoverColorDark || primaryColorDark,
	          }),
	        },
	      }),
	      ...(!isDisabled && {
	        '&:focus-within': {
	          borderColor: primaryColor,
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	            borderColor: primaryColorDark,
	          }),
	        },
	      }),
	      background: backgroundColor,
	      border: `${validateProps.borderWidthBase} solid ${isOpen ? primaryColor : formStateColor || contrastMediumColor}`,
	      borderRadius: borderRadiusSmall.borderRadiusSmall,
	      ...(isOpen && {
	        [isDirectionDown ? 'paddingBottom' : 'paddingTop']: '1px',
	        [isDirectionDown ? 'borderBottom' : 'borderTop']: validateProps.addImportantToRule(`1px solid ${contrastMediumColor}`),
	        [isDirectionDown ? 'borderBottomLeftRadius' : 'borderTopLeftRadius']: 0,
	        [isDirectionDown ? 'borderBottomRightRadius' : 'borderTopRightRadius']: 0,
	      }),
	      ...(isDisabled && {
	        cursor: 'not-allowed',
	        color: disabledColor,
	        borderColor: disabledColor,
	        WebkitTextFillColor: disabledColor,
	      }),
	      ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	        background: backgroundColorDark,
	        border: `${validateProps.borderWidthBase} solid ${isOpen ? primaryColorDark : formStateColorDark || contrastMediumColorDark}`,
	        ...(isOpen && {
	          [isDirectionDown ? 'borderBottom' : 'borderTop']: validateProps.addImportantToRule(`1px solid ${contrastMediumColorDark}`),
	        }),
	        ...(isDisabled && {
	          color: disabledColorDark,
	          borderColor: disabledColorDark,
	          WebkitTextFillColor: disabledColorDark,
	        }),
	      }),
	    },
	    ...validateProps.buildResponsiveStyles(hideLabel, (isHidden) => isHidden
	      ? {
	        label: {
	          display: 'none',
	        },
	      }
	      : hasLabel &&
	        formStyles.getLabelStyles('select', isDisabled, hideLabel, state, theme, undefined, {
	          marginBottom: spacingStaticXSmall.spacingStaticXSmall,
	        })),
	    icon: {
	      padding: `${inputYPadding} 15px`,
	      cursor: isDisabled ? 'not-allowed' : 'pointer',
	      ...(isDisabled && { pointerEvents: 'none' }),
	    },
	    'reset-icon': {
	      padding: '4px',
	      margin: 'auto',
	    },
	    'toggle-icon': {
	      transform: 'rotate3d(0,0,1,0.0001deg)',
	      transition: validateProps.getTransition('transform'),
	      '&--open': {
	        transform: 'rotate3d(0,0,1,180deg)',
	      },
	    },
	    'no-results': {
	      padding: `${spacingStaticSmall.spacingStaticSmall} 12px`,
	      color: contrastHighColor,
	      ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	        color: contrastHighColorDark,
	      }),
	      boxSizing: 'border-box',
	      ...selectDropdown.getNoResultsOptionJssStyle(),
	    },
	    ...required.getFunctionalComponentRequiredStyles(),
	    ...required.getFunctionalComponentStateMessageStyles(theme, state),
	    'sr-text': validateProps.getHiddenTextJssStyle(),
	  });
	};
	const getInputStyles = (isDisabled, theme) => {
	  const { primaryColor, disabledColor } = validateProps.getThemedColors(theme);
	  const { primaryColor: primaryColorDark, disabledColor: disabledColorDark } = validateProps.getThemedColors('dark');
	  return {
	    input: {
	      flex: 1,
	      minWidth: 0,
	      height: `calc(${INPUT_HEIGHT_CALC})`,
	      font: textSmallStyle.textSmallStyle.font.replace('ex', 'ex + 6px'),
	      padding: `${inputYPadding} ${spacingStaticMedium.spacingStaticMedium}`,
	      boxSizing: 'border-box',
	      border: 0,
	      outline: 0,
	      appearance: 'none',
	      background: 'transparent',
	      ...textSmallStyle.textSmallStyle,
	      textOverflow: 'ellipsis',
	      '&:disabled': {
	        cursor: 'not-allowed',
	      },
	      color: primaryColor,
	      ...(isDisabled && getPlaceholderJssStyle({ color: disabledColor })),
	      ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	        color: primaryColorDark,
	        ...(isDisabled && getPlaceholderJssStyle({ color: disabledColorDark })),
	      }),
	      '&:not(:focus)': {
	        ...getPlaceholderJssStyle({ color: primaryColor, opacity: 1 }),
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, getPlaceholderJssStyle({ color: primaryColorDark, opacity: 1 })),
	      }, // Opacity fixes placeholder being shown lighter in firefox
	    },
	  };
	};
	const getListStyles = (isOpen, direction, theme) => {
	  const isDirectionDown = direction === 'down';
	  const { primaryColor, backgroundColor } = validateProps.getThemedColors(theme);
	  const { primaryColor: primaryColorDark, backgroundColor: backgroundColorDark } = validateProps.getThemedColors('dark');
	  return {
	    listbox: {
	      position: 'absolute',
	      margin: '0',
	      display: isOpen ? 'flex' : 'none',
	      flexDirection: 'column',
	      gap: spacingStaticSmall.spacingStaticSmall,
	      padding: '6px',
	      ...textSmallStyle.textSmallStyle,
	      zIndex: 10,
	      left: 0,
	      right: 0,
	      [isDirectionDown ? 'top' : 'bottom']: isDirectionDown
	        ? '100%'
	        : `calc((${INPUT_HEIGHT_CALC}) + 2 * ${validateProps.borderWidthBase})`,
	      boxSizing: 'border-box',
	      maxHeight: `${8.5 * (selectDropdown.MULTI_SELECT_OPTION_HEIGHT + 8) + 6 + 2}px`,
	      overflowY: 'auto',
	      WebkitOverflowScrolling: 'touch',
	      background: backgroundColor,
	      border: `2px solid ${primaryColor}`,
	      [isDirectionDown ? 'borderTop' : 'borderBottom']: 'none',
	      borderRadius: borderRadiusSmall.borderRadiusSmall,
	      [isDirectionDown ? 'borderTopLeftRadius' : 'borderBottomLeftRadius']: 0,
	      [isDirectionDown ? 'borderTopRightRadius' : 'borderBottomRightRadius']: 0,
	      scrollbarWidth: 'thin',
	      scrollbarColor: 'auto',
	      transition: validateProps.getTransition('border-color'),
	      transform: 'translate3d(0,0,0)',
	      ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	        background: backgroundColorDark,
	        borderColor: primaryColorDark,
	      }),
	    },
	  };
	};

	const propTypes$1 = {
	  label: validateProps.AllowedTypes.string,
	  description: validateProps.AllowedTypes.string,
	  name: validateProps.AllowedTypes.string,
	  value: validateProps.AllowedTypes.array(validateProps.AllowedTypes.string),
	  state: validateProps.AllowedTypes.oneOf(required.FORM_STATES),
	  message: validateProps.AllowedTypes.string,
	  hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	  disabled: validateProps.AllowedTypes.boolean,
	  required: validateProps.AllowedTypes.boolean,
	  dropdownDirection: validateProps.AllowedTypes.oneOf(selectDropdown.SELECT_DROPDOWN_DIRECTIONS),
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const MultiSelect = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.update = validateProps.createEvent(this, "update", 3);
	    this.multiSelectOptions = [];
	    this.preventOptionUpdate = false; // Used to prevent value watcher from updating options when options are already updated
	    this.onSlotchange = () => {
	      this.updateOptions();
	      setSelectedOptions(this.multiSelectOptions, this.value);
	      if (this.isWithinForm) {
	        updateNativeOptions(this.nativeSelect, this.multiSelectOptions);
	      }
	      // Necessary to update selected options in placeholder
	      validateProps.forceUpdate(this.host);
	    };
	    this.updateOptions = () => {
	      this.multiSelectOptions = Array.from(this.host.children).filter((el) => el.tagName !== 'SELECT' && el.slot !== 'label' && el.slot !== 'description' && el.slot !== 'message');
	      this.multiSelectOptions.forEach((child) => throwIfElementIsNotOfKind.throwIfElementIsNotOfKind(this.host, child, 'p-multi-select-option'));
	    };
	    this.onInputChange = (e) => {
	      if (e.target.value.startsWith(' ')) {
	        this.resetFilter();
	      }
	      else {
	        updateOptionsFilterState(e.target.value, this.multiSelectOptions);
	        this.hasFilterResults = hasFilterOptionResults(this.multiSelectOptions);
	      }
	      // in case input is focused via tab instead of click
	      this.isOpen = true;
	    };
	    this.onInputClick = () => {
	      this.isOpen = true;
	    };
	    this.onIconClick = () => {
	      this.isOpen = !this.isOpen;
	    };
	    this.onResetClick = () => {
	      resetSelectedOptions(this.multiSelectOptions);
	      this.value = this.currentValue;
	      this.inputElement.focus();
	      this.emitUpdateEvent();
	      validateProps.forceUpdate(this.host);
	    };
	    this.onClickOutside = (e) => {
	      if (this.isOpen && isClickOutside.isClickOutside(e, this.inputContainer) && isClickOutside.isClickOutside(e, this.listElement)) {
	        this.isOpen = false;
	        this.resetFilter();
	      }
	    };
	    this.resetFilter = () => {
	      this.inputElement.value = '';
	      resetFilteredOptions(this.multiSelectOptions);
	    };
	    this.onInputKeyDown = (e) => {
	      switch (e.key) {
	        case 'ArrowUp':
	        case 'Up':
	          e.preventDefault();
	          this.cycleDropdown('up');
	          break;
	        case 'ArrowDown':
	        case 'Down':
	          e.preventDefault();
	          this.cycleDropdown('down');
	          break;
	        case 'Enter':
	          const highlightedOption = getHighlightedOption(this.multiSelectOptions);
	          if (highlightedOption) {
	            highlightedOption.selected = !highlightedOption.selected;
	            this.value = this.currentValue;
	            this.emitUpdateEvent();
	            this.updateSrHighlightedOptionText();
	            validateProps.forceUpdate(highlightedOption);
	          }
	          else {
	            if (this.isWithinForm) {
	              buttonHandling.handleButtonEvent(e, this.host, () => 'submit', () => this.disabled);
	            }
	          }
	          break;
	        case 'Escape':
	          this.isOpen = false;
	          resetHighlightedOptions(this.multiSelectOptions);
	          break;
	        case 'Tab':
	          // If there is a value the reset button will be focused and the dropdown stays open
	          if (!this.currentValue.length) {
	            this.isOpen = false;
	          }
	          resetHighlightedOptions(this.multiSelectOptions);
	          break;
	        case 'PageUp':
	          if (this.isOpen) {
	            e.preventDefault();
	            setFirstOptionHighlighted(this.listElement, this.multiSelectOptions);
	          }
	          break;
	        case 'PageDown':
	          if (this.isOpen) {
	            e.preventDefault();
	            setLastOptionHighlighted(this.listElement, this.multiSelectOptions);
	          }
	          break;
	        // TODO: seems to be difficult to combine multiple keys as native select does
	      }
	    };
	    this.updateSrHighlightedOptionText = () => {
	      const highlightedOptionIndex = getHighlightedOptionIndex(this.multiSelectOptions);
	      const highlightedOption = this.multiSelectOptions[highlightedOptionIndex];
	      this.srHighlightedOptionText =
	        highlightedOption &&
	          `${highlightedOption.textContent}${highlightedOption.selected ? ', selected' : ' not selected'} (${highlightedOptionIndex + 1} of ${this.multiSelectOptions.length})`;
	    };
	    this.emitUpdateEvent = () => {
	      this.update.emit({
	        value: this.currentValue,
	        name: this.name,
	      });
	    };
	    this.label = '';
	    this.description = '';
	    this.name = undefined;
	    this.value = [];
	    this.state = 'none';
	    this.message = '';
	    this.hideLabel = false;
	    this.disabled = false;
	    this.required = false;
	    this.dropdownDirection = 'auto';
	    this.theme = 'light';
	    this.isOpen = false;
	    this.srHighlightedOptionText = '';
	    this.hasFilterResults = true;
	  }
	  get currentValue() {
	    return getSelectedOptionValues(this.multiSelectOptions);
	  }
	  updateOptionHandler(e) {
	    e.target.selected = !e.target.selected;
	    validateProps.forceUpdate(e.target);
	    this.preventOptionUpdate = true; // Avoid unnecessary looping over options in setSelectedOptions in value watcher
	    this.value = this.currentValue;
	    e.stopPropagation();
	    this.emitUpdateEvent();
	  }
	  onValueChange() {
	    // When setting initial value the watcher gets called before the options are defined
	    if (this.multiSelectOptions.length > 0) {
	      if (!this.preventOptionUpdate) {
	        setSelectedOptions(this.multiSelectOptions, this.value);
	      }
	      this.preventOptionUpdate = false;
	      if (this.isWithinForm) {
	        updateNativeOptions(this.nativeSelect, this.multiSelectOptions);
	      }
	    }
	  }
	  connectedCallback() {
	    document.addEventListener('mousedown', this.onClickOutside, true);
	    this.form = getClosestHTMLElement.getClosestHTMLElement(this.host, 'form');
	    this.isWithinForm = !!this.form;
	  }
	  componentWillLoad() {
	    this.updateOptions();
	    // Use initial value to set options
	    setSelectedOptions(this.multiSelectOptions, this.value);
	    if (this.isWithinForm) {
	      this.nativeSelect = initNativeSelect(this.host, this.name, this.disabled, this.required);
	      updateNativeOptions(this.nativeSelect, this.multiSelectOptions);
	    }
	  }
	  componentDidLoad() {
	    validateProps.getShadowRootHTMLElement(this.host, 'slot').addEventListener('slotchange', this.onSlotchange);
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  componentWillUpdate() {
	    if (this.isWithinForm) {
	      syncNativeSelect(this.nativeSelect, this.name, this.disabled, this.required);
	    }
	  }
	  disconnectedCallback() {
	    document.removeEventListener('mousedown', this.onClickOutside, true);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes$1);
	    validateProps.attachComponentCss(this.host, getComponentCss$1, getDropdownDirection(this.dropdownDirection, this.inputContainer, this.multiSelectOptions), this.isOpen, this.disabled, this.hideLabel, this.state, this.isWithinForm, required.hasLabel(this.host, this.label), this.theme);
	    syncMultiSelectOptionProps(this.multiSelectOptions, this.theme);
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    const labelId = 'label';
	    const messageId = 'message';
	    const descriptionId = 'description';
	    const optionsSelectedId = 'options-selected';
	    const dropdownId = 'list';
	    return (validateProps.h(validateProps.Host, null, validateProps.h("div", { class: "root" }, validateProps.h("label", { class: "label" }, required.hasLabel(this.host, this.label) && (validateProps.h("span", { id: labelId, class: "label__text", onClick: () => this.inputElement.focus() }, this.label || validateProps.h("slot", { name: "label" }), isRequiredAndParentNotRequired.isRequiredAndParentNotRequired(this.host, this.host) && validateProps.h(required.Required, null))), hasDescription.hasDescription(this.host, this.description) && (validateProps.h("span", { id: descriptionId, class: "label__text", onClick: () => this.inputElement.focus(), "aria-hidden": "true" }, this.description || validateProps.h("slot", { name: "description" }))), this.currentValue.length > 0 && (validateProps.h("span", { id: optionsSelectedId, class: "sr-text" }, getSelectedOptions(this.multiSelectOptions).length, " options selected"))), validateProps.h("div", { class: { 'input-container': true, disabled: this.disabled }, ref: (el) => (this.inputContainer = el) }, validateProps.h("input", { role: "combobox", placeholder: getSelectedOptionsString(this.multiSelectOptions) || null, autoComplete: "off", disabled: this.disabled, required: this.required, onInput: this.onInputChange, onClick: this.onInputClick, onKeyDown: this.onInputKeyDown, ref: (el) => (this.inputElement = el), "aria-invalid": this.state === 'error' ? 'true' : null, ...selectDropdown.getFilterInputAriaAttributes(this.isOpen, this.required, labelId, `${descriptionId} ${optionsSelectedId} ${messageId}`, dropdownId) }), this.currentValue.length > 0 && (validateProps.h(PrefixedTagNames.pButtonPure, { class: "icon reset-icon", icon: "close", hideLabel: "true", theme: this.theme, color: this.disabled ? 'state-disabled' : 'primary', onClick: this.onResetClick, onKeyDown: (e) => e.key === 'Tab' && (this.isOpen = false), disabled: this.disabled }, "Reset selection")), validateProps.h(PrefixedTagNames.pIcon, { class: { icon: true, 'toggle-icon': true, 'toggle-icon--open': this.isOpen }, name: "arrow-head-down", theme: this.theme, color: this.disabled ? 'state-disabled' : 'primary', onClick: this.onIconClick, "aria-hidden": "true" })), validateProps.h("div", { id: dropdownId, class: "listbox", ...selectDropdown.getListAriaAttributes(this.label, this.required, true, this.isOpen, true), ref: (el) => (this.listElement = el) }, !this.hasFilterResults && (validateProps.h("div", { class: "no-results", "aria-live": "polite", role: "status" }, validateProps.h("span", { "aria-hidden": "true" }, "---"), validateProps.h("span", { class: "no-results__sr" }, "No results found"))), validateProps.h("slot", null))), this.isWithinForm && validateProps.h("slot", { name: "select" }), required.hasMessage(this.host, this.message, this.state) && (validateProps.h(required.StateMessage, { id: messageId, state: this.state, message: this.message, theme: this.theme, host: this.host })), validateProps.h("span", { class: "sr-text", role: "status", "aria-live": "assertive", "aria-relevant": "additions text" }, this.srHighlightedOptionText)));
	  }
	  cycleDropdown(direction) {
	    this.isOpen = true;
	    updateHighlightedOption(this.listElement, this.multiSelectOptions, direction);
	    this.updateSrHighlightedOptionText();
	  }
	  get host() { return validateProps.getElement(this); }
	  static get watchers() { return {
	    "value": ["onValueChange"]
	  }; }
	};

	const getComponentCss = (theme) => {
	  const { primaryColor, contrastHighColor, backgroundSurfaceColor, disabledColor, contrastLowColor } = validateProps.getThemedColors(theme);
	  const { primaryColor: primaryColorDark, disabledColor: disabledColorDark, contrastHighColor: contrastHighColorDark, backgroundSurfaceColor: backgroundSurfaceColorDark, contrastLowColor: contrastLowColorDark, } = validateProps.getThemedColors('dark');
	  const { highlightColor } = validateProps.getHighContrastColors();
	  return validateProps.getCss({
	    '@global': {
	      ':host': validateProps.addImportantToEachRule({
	        scrollMarginTop: spacingStaticSmall.spacingStaticSmall,
	        ...colorSchemeStyles.hostHiddenStyles,
	      }),
	    },
	    option: {
	      display: 'flex',
	      justifyContent: 'space-between',
	      gap: '12px',
	      padding: `${spacingStaticSmall.spacingStaticSmall} 12px`,
	      flex: `1 0 calc(${fontLineHeight.fontLineHeight} + ${spacingStaticSmall.spacingStaticSmall} * 2)`,
	      color: contrastHighColor,
	      ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	        color: contrastHighColorDark,
	      }),
	      cursor: 'pointer',
	      textAlign: 'left',
	      wordBreak: 'break-word',
	      boxSizing: 'border-box',
	      borderRadius: borderRadiusSmall.borderRadiusSmall,
	      transition: ['background-color', 'color'].map(validateProps.getTransition).join(),
	      ...selectDropdown.getNoResultsOptionJssStyle(),
	      ...hoverMediaQuery.hoverMediaQuery({
	        '&:not([aria-disabled]):not(.option--disabled):not([role=status]):hover': {
	          color: validateProps.isHighContrastMode ? highlightColor : primaryColor,
	          background: contrastLowColor,
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	            color: validateProps.isHighContrastMode ? highlightColor : primaryColorDark,
	            background: contrastLowColorDark,
	          }),
	        },
	      }),
	      '&--selected': {
	        background: backgroundSurfaceColor,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          background: backgroundSurfaceColorDark,
	        }),
	      },
	      '&--highlighted': {
	        background: contrastLowColor,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          background: contrastLowColorDark,
	        }),
	      },
	      '&--highlighted, &--selected': {
	        color: validateProps.isHighContrastMode ? highlightColor : primaryColor,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          color: validateProps.isHighContrastMode ? highlightColor : primaryColorDark,
	        }),
	      },
	      '&--disabled': {
	        cursor: 'not-allowed',
	        color: disabledColor,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          color: disabledColorDark,
	        }),
	      },
	      '&--hidden': {
	        display: 'none',
	      },
	    },
	    checkbox: {
	      pointerEvents: 'none', // Avoid checkbox label click which updates input within p-checkbox-wrapper
	    },
	  });
	};

	const propTypes = {
	  value: validateProps.AllowedTypes.oneOf([validateProps.AllowedTypes.string, validateProps.AllowedTypes.number]),
	  disabled: validateProps.AllowedTypes.boolean,
	};
	const MultiSelectOption = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.onClick = () => {
	      this.host.dispatchEvent(new CustomEvent('internalOptionUpdate', {
	        bubbles: true,
	      }));
	    };
	    this.value = undefined;
	    this.disabled = false;
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    const { theme = 'light', selected, highlighted, hidden, textContent } = this.host;
	    validateProps.attachComponentCss(this.host, getComponentCss, theme);
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    return (validateProps.h(validateProps.Host, { onClick: !this.disabled && this.onClick }, validateProps.h("div", { class: {
	        option: true,
	        'option--selected': selected,
	        'option--highlighted': highlighted,
	        'option--disabled': this.disabled,
	      } }, validateProps.h(PrefixedTagNames.pCheckboxWrapper, { class: "checkbox", theme: theme }, validateProps.h("input", { role: "option", type: "checkbox", checked: selected, disabled: this.disabled, ...selectDropdown.getOptionAriaAttributes(selected, this.disabled, hidden, !!this.value), "aria-label": textContent, tabindex: "-1" }), validateProps.h("slot", { slot: "label" })))));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	pMultiSelect_2_cjs_entry.p_multi_select = MultiSelect;
	pMultiSelect_2_cjs_entry.p_multi_select_option = MultiSelectOption;

	
	return pMultiSelect_2_cjs_entry;
}

var pPagination_cjs_entry = {};

var hasRequiredPPagination_cjs_entry;

function requirePPagination_cjs_entry () {
	if (hasRequiredPPagination_cjs_entry) return pPagination_cjs_entry;
	hasRequiredPPagination_cjs_entry = 1;

	Object.defineProperty(pPagination_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed3a5c494c();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const hoverMediaQuery = requireHoverMediaQueryF2ccfc24();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const borderRadiusMedium = requireBorderRadiusMedium758b9411();
	const fontLineHeight = requireFontLineHeight78b03658();
	requireHelperE5c4e0db();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();

	/**
	 * Universal pagination model generation algorithm
	 *
	 * The idea behind this module is to move the logic of creating pagination out of the component
	 * and place it in a separate module.
	 *
	 * Adapted from ultimate-pagination
	 * https://github.com/ultimate-pagination/ultimate-pagination
	 */
	const PAGINATION_NUMBER_OF_PAGE_LINKS = [5, 7];
	var ItemType;
	(function (ItemType) {
	  ItemType[ItemType["PAGE"] = 0] = "PAGE";
	  ItemType[ItemType["ELLIPSIS"] = 1] = "ELLIPSIS";
	  ItemType[ItemType["PREVIOUS"] = 2] = "PREVIOUS";
	  ItemType[ItemType["NEXT"] = 3] = "NEXT";
	})(ItemType || (ItemType = {}));
	const ellipsisItem = {
	  type: ItemType.ELLIPSIS,
	  isActive: false,
	};
	const createPreviousPageLink = (options) => {
	  const { activePage } = options;
	  return {
	    type: ItemType.PREVIOUS,
	    value: Math.max(1, activePage - 1),
	    isActive: activePage > 1,
	  };
	};
	const createNextPageLink = (options) => {
	  const { activePage, pageTotal } = options;
	  return {
	    type: ItemType.NEXT,
	    value: Math.min(pageTotal, activePage + 1),
	    isActive: activePage < pageTotal,
	  };
	};
	const createPageFunctionFactory = (options) => {
	  return (pageNumber) => ({
	    type: ItemType.PAGE,
	    value: pageNumber,
	    isActive: pageNumber === options.activePage,
	  });
	};
	const createRange = (start, end) => Array.from(Array(end - start + 1), (_, i) => i + start);
	const createPaginationModel = (options) => {
	  const { pageTotal, activePage, pageRange, showLastPage } = options;
	  const boundaryPagesRange = 1;
	  const ellipsisSize = 1;
	  const paginationModel = [createPreviousPageLink(options)];
	  const createPage = createPageFunctionFactory(options);
	  // Simplify generation of pages if number of available items is equal or greater than total pages to show
	  if (1 + 2 * ellipsisSize + 2 * pageRange + 2 * boundaryPagesRange >= pageTotal) {
	    const allPages = createRange(1, pageTotal).map(createPage);
	    paginationModel.push(...allPages);
	  }
	  else {
	    // Add first page
	    paginationModel.push(createPage(1));
	    // Calculate group of middle pages
	    const middlePagesStart = Math.min(Math.max(activePage - pageRange, 2 + ellipsisSize), pageTotal - ellipsisSize - 2 * pageRange - (showLastPage ? 1 : 0));
	    const middlePagesEnd = middlePagesStart + 2 * pageRange;
	    const middlePages = createRange(middlePagesStart, middlePagesEnd).map(createPage);
	    // Calculate and add ellipsis before group of middle pages
	    const firstEllipsisPageNumber = middlePagesStart - 1;
	    const showPageInsteadOfFirstEllipsis = firstEllipsisPageNumber === 2;
	    const firstEllipsisOrPage = showPageInsteadOfFirstEllipsis ? createPage(firstEllipsisPageNumber) : ellipsisItem;
	    paginationModel.push(firstEllipsisOrPage);
	    // Add group of middle pages
	    paginationModel.push(...middlePages);
	    // Calculate and add ellipsis after group of middle pages
	    const lastEllipsisPageNumber = middlePagesEnd + 1;
	    const showPageInsteadOfLastEllipsis = lastEllipsisPageNumber === pageTotal - (showLastPage ? 1 : 0);
	    const lastEllipsisOrPage = showPageInsteadOfLastEllipsis ? createPage(lastEllipsisPageNumber) : ellipsisItem;
	    paginationModel.push(lastEllipsisOrPage);
	    // Add last page
	    if (showLastPage) {
	      paginationModel.push(createPage(pageTotal));
	    }
	  }
	  paginationModel.push(createNextPageLink(options));
	  return paginationModel;
	};
	const getCurrentActivePage = (activePage, totalPages) => {
	  // Obviously we can't be on a negative or 0 page.
	  if (activePage < 1) {
	    activePage = 1;
	  }
	  // If the user has done something like /page/99999 we want to clamp that back down.
	  if (activePage > totalPages) {
	    activePage = totalPages;
	  }
	  return activePage;
	};
	const getTotalPages = (totalItemsCount, itemsPerPage) => {
	  if (totalItemsCount < 1) {
	    totalItemsCount = 1;
	  }
	  if (itemsPerPage < 1) {
	    itemsPerPage = 1;
	  }
	  return Math.ceil(totalItemsCount / itemsPerPage);
	};
	// TODO: change this to a non js solution to support SSR
	const getCounterResetValue = (element) => {
	  const [, value] = getComputedStyle(element).counterReset.split(' ');
	  return parseInt(value, 10);
	};

	const mediaQueryMinS = validateProps.getMediaQueryMin('s');
	// button size needs to be fluid between 320px and 360px viewport width, so that the pagination fits into 320px viewport
	// and text scale 200% works (almost) on mobile viewports too
	const buttonSize = `clamp(36px, calc(${fontLineHeight.fontLineHeight} + 10vw - 20px), 40px)`;
	const disabledCursorStyle = {
	  cursor: 'default',
	  pointerEvents: 'none', // prevents :hover (has no effect when forced), maybe we can remove it since CSS selectors already cover desired behavior
	};
	const getComponentCss = (maxNumberOfPageLinks, theme) => {
	  const { primaryColor, disabledColor, hoverColor, focusColor } = validateProps.getThemedColors(theme);
	  const { primaryColor: primaryColorDark, disabledColor: disabledColorDark, hoverColor: hoverColorDark, focusColor: focusColorDark, } = validateProps.getThemedColors('dark');
	  return validateProps.getCss({
	    '@global': {
	      ':host': {
	        display: 'block',
	        ...validateProps.addImportantToEachRule({
	          ...colorSchemeStyles.colorSchemeStyles,
	          ...colorSchemeStyles.hostHiddenStyles,
	        }),
	      },
	      nav: {
	        display: 'flex',
	        justifyContent: 'center',
	        userSelect: 'none',
	        ...validateProps.buildResponsiveStyles(maxNumberOfPageLinks, (n) => ({
	          counterReset: `size ${n}`,
	        })),
	      },
	      ul: {
	        display: 'flex',
	        gap: spacingStaticXSmall.spacingStaticXSmall,
	        margin: 0,
	        padding: 0,
	        [mediaQueryMinS]: {
	          gap: spacingStaticSmall.spacingStaticSmall,
	        },
	      },
	      li: {
	        listStyleType: 'none',
	        [mediaQueryMinS]: {
	          '&:first-child': {
	            marginRight: spacingStaticSmall.spacingStaticSmall,
	          },
	          '&:last-child': {
	            marginLeft: spacingStaticSmall.spacingStaticSmall,
	          },
	        },
	      },
	      span: {
	        display: 'flex',
	        justifyContent: 'center',
	        alignItems: 'center',
	        transition: ['color', 'border-color', 'background-color'].map(validateProps.getTransition).join(),
	        position: 'relative',
	        width: buttonSize,
	        height: buttonSize,
	        boxSizing: 'border-box',
	        ...textSmallStyle.textSmallStyle,
	        whiteSpace: 'nowrap',
	        cursor: 'pointer',
	        color: primaryColor,
	        outline: 0,
	        borderRadius: borderRadiusSmall.borderRadiusSmall,
	        borderColor: 'transparent',
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          color: primaryColorDark,
	        }),
	        ...hoverMediaQuery.hoverMediaQuery({
	          '&:not([aria-disabled]):not(.ellipsis):hover': {
	            ...validateProps.frostedGlassStyle,
	            background: hoverColor,
	            ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	              background: hoverColorDark,
	            }),
	          },
	        }),
	        '&:not(.ellipsis):focus:focus-visible::before': {
	          content: '""',
	          position: 'absolute',
	          ...validateProps.getInsetJssStyle(-4),
	          border: `${validateProps.borderWidthBase} solid ${focusColor}`,
	          borderRadius: borderRadiusMedium.borderRadiusMedium,
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	            borderColor: focusColorDark,
	          }),
	        },
	        '&[aria-current]': {
	          ...disabledCursorStyle,
	          color: primaryColor,
	          border: `${validateProps.borderWidthBase} solid ${primaryColor}`,
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	            color: primaryColorDark,
	            borderColor: primaryColorDark,
	          }),
	          '&:not(.ellipsis):focus::before': validateProps.getInsetJssStyle(-6),
	        },
	        '&[aria-disabled]': {
	          ...disabledCursorStyle,
	          color: disabledColor,
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	            color: disabledColorDark,
	          }),
	        },
	      },
	    },
	    ellipsis: {
	      ...disabledCursorStyle,
	      '&::after': {
	        content: '"…"',
	      },
	    },
	  });
	};

	const propTypes = {
	  totalItemsCount: validateProps.AllowedTypes.number,
	  itemsPerPage: validateProps.AllowedTypes.number,
	  activePage: validateProps.AllowedTypes.number,
	  maxNumberOfPageLinks: validateProps.AllowedTypes.breakpoint(PAGINATION_NUMBER_OF_PAGE_LINKS),
	  showLastPage: validateProps.AllowedTypes.boolean,
	  allyLabel: validateProps.AllowedTypes.string,
	  allyLabelPrev: validateProps.AllowedTypes.string,
	  allyLabelPage: validateProps.AllowedTypes.string,
	  allyLabelNext: validateProps.AllowedTypes.string,
	  intl: validateProps.AllowedTypes.shape({
	    root: validateProps.AllowedTypes.string,
	    prev: validateProps.AllowedTypes.string,
	    next: validateProps.AllowedTypes.string,
	    page: validateProps.AllowedTypes.string,
	  }),
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Pagination = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.pageChange = validateProps.createEvent(this, "pageChange", 3);
	    this.update = validateProps.createEvent(this, "update", 3);
	    this.updateMaxNumberOfPageLinks = () => {
	      // TODO: change this to a non js solution to support SSR and prevent initial rerender
	      this.breakpointMaxNumberOfPageLinks = getCounterResetValue(this.navigationElement);
	    };
	    this.observeBreakpointChange = () => {
	      if (typeof validateProps.parseJSON(this.maxNumberOfPageLinks) === 'object') {
	        validateProps.observeBreakpointChange(this.host, this.updateMaxNumberOfPageLinks);
	      }
	    };
	    this.totalItemsCount = 1;
	    this.itemsPerPage = 1;
	    this.activePage = 1;
	    this.maxNumberOfPageLinks = {
	      base: 5,
	      xs: 7,
	    };
	    this.showLastPage = true;
	    this.allyLabel = undefined;
	    this.allyLabelPrev = undefined;
	    this.allyLabelPage = undefined;
	    this.allyLabelNext = undefined;
	    this.intl = {
	      root: 'Pagination',
	      prev: 'Previous page',
	      next: 'Next page',
	      page: 'Page',
	    };
	    this.theme = 'light';
	    this.breakpointMaxNumberOfPageLinks = 7;
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  connectedCallback() {
	    this.observeBreakpointChange(); // on reconnect
	  }
	  componentDidLoad() {
	    this.observeBreakpointChange(); // initially or slow prop binding
	    this.updateMaxNumberOfPageLinks(); // TODO: this causes initial rerender
	  }
	  disconnectedCallback() {
	    validateProps.unobserveBreakpointChange(this.host);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'allyLabel', 'Please use intl prop with intl.root instead.');
	    warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'allyLabelNext', 'Please use intl prop with intl.next instead.');
	    warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'allyLabelPrev', 'Please use intl prop with intl.prev instead.');
	    warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'allyLabelPage', 'Please use intl prop with intl.page instead.');
	    validateProps.attachComponentCss(this.host, getComponentCss, this.maxNumberOfPageLinks, this.theme);
	    const pageTotal = getTotalPages(this.totalItemsCount, this.itemsPerPage);
	    const paginationModel = createPaginationModel({
	      activePage: getCurrentActivePage(this.activePage, pageTotal),
	      pageTotal,
	      pageRange: this.breakpointMaxNumberOfPageLinks === 7 ? 1 : 0,
	      showLastPage: this.showLastPage,
	    });
	    const parsedIntl = validateProps.parseJSONAttribute(this.intl);
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    return (validateProps.h("nav", { role: "navigation", "aria-label": this.allyLabel || parsedIntl.root, ref: (el) => (this.navigationElement = el) }, validateProps.h("ul", null, paginationModel.map((pageModel) => {
	      const { type, isActive, value } = pageModel;
	      const spanProps = {
	        role: 'button',
	        tabIndex: isActive ? 0 : null,
	        onClick: () => this.onClick(value),
	        onKeyDown: (e) => this.onKeyDown(e, value),
	      };
	      const iconProps = {
	        theme: this.theme,
	        color: isActive ? 'primary' : 'state-disabled',
	        'aria-hidden': 'true',
	      };
	      switch (type) {
	        case ItemType.PREVIOUS:
	          return (validateProps.h("li", { key: "prev" }, validateProps.h("span", { ...spanProps, "aria-label": this.allyLabelPrev || parsedIntl.prev, "aria-disabled": isActive ? null : 'true' }, validateProps.h(PrefixedTagNames.pIcon, { name: "arrow-left", ...iconProps }))));
	        case ItemType.ELLIPSIS:
	          return (validateProps.h("li", { key: "ellipsis" }, validateProps.h("span", { class: "ellipsis" })));
	        case ItemType.PAGE:
	          return (validateProps.h("li", { key: value }, validateProps.h("span", { ...spanProps, tabIndex: 0, "aria-label": `${this.allyLabelPage || parsedIntl.page} ${value}`, "aria-current": isActive ? 'page' : null }, value)));
	        case ItemType.NEXT:
	          return (validateProps.h("li", { key: "next" }, validateProps.h("span", { ...spanProps, "aria-label": this.allyLabelNext || parsedIntl.next, "aria-disabled": isActive ? null : 'true' }, validateProps.h(PrefixedTagNames.pIcon, { name: "arrow-right", ...iconProps }))));
	      }
	    }))));
	  }
	  onKeyDown(event, page) {
	    // from https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/button_role
	    const { key } = event;
	    if (key === ' ' || key === 'Enter' || key === 'Spacebar') {
	      event.preventDefault(); // prevent the default action to stop scrolling when space is pressed
	      this.onClick(page);
	    }
	  }
	  onClick(page) {
	    if (page !== this.activePage) {
	      this.update.emit({ page, previousPage: this.activePage });
	      this.pageChange.emit({ page, previousPage: this.activePage });
	      this.activePage = page; // TODO: should become a controlled component
	    }
	  }
	  static get delegatesFocus() { return true; }
	  get host() { return validateProps.getElement(this); }
	};

	pPagination_cjs_entry.p_pagination = Pagination;

	
	return pPagination_cjs_entry;
}

var pPinCode_cjs_entry = {};

var hasRequiredPPinCode_cjs_entry;

function requirePPinCode_cjs_entry () {
	if (hasRequiredPPinCode_cjs_entry) return pPinCode_cjs_entry;
	hasRequiredPPinCode_cjs_entry = 1;

	Object.defineProperty(pPinCode_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const getClosestHTMLElement = requireGetClosestHTMLElement0135bfd9();
	const isDisabledOrLoading = requireIsDisabledOrLoadingAd97a497();
	const required = requireRequiredBc18b612();
	const hasDescription = requireHasDescriptionA19e4bdc();
	const isParentFieldsetRequired = requireIsParentFieldsetRequired6f3a68ad();
	const isWithinForm = requireIsWithinFormA677dade();
	const theme = requireThemeBfc10573();
	const formStyles = requireFormStyles97f2cdf7();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const setAttributes = requireSetAttributes642a7e67();
	const getMediaQueryMax = requireGetMediaQueryMax2587ee0a();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const fontLineHeight = requireFontLineHeight78b03658();
	requireHasNamedSlot28c6bca1();
	requireGetNamedSlotA433c432();
	requireIsThemeAutoC90cd35d();
	requireTextSmallStyle7246779a();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireIsParentOfKindA9c351f2();
	requireHoverMediaQueryF2ccfc24();
	requireFontSizeTextXSmallE59d35d7();
	requireBorderRadiusSmall5f37fc45();

	const PIN_CODE_TYPES = ['number', 'password'];
	const PIN_CODE_LENGTHS = [4, 6];
	const hiddenInputSlotName = 'hidden-input';
	const removeSlottedSelector = (styles) => Object.fromEntries(Object.entries(styles).map(([key, value]) => {
	  value = typeof value === 'object' ? removeSlottedSelector(value) : value;
	  return [key.replace(/::slotted\(([^,]+)\)/g, '$1'), value];
	}));
	const removeStyles = (selector, styles) => Object.fromEntries(Object.entries(styles)
	  .filter(([key]) => key !== selector)
	  .map(([key, value]) => {
	  value = typeof value === 'object' ? removeStyles(selector, value) : value;
	  return [key, value];
	}));
	const warnAboutTransformedValue = (host, length) => {
	  const warningPrefix = `Property value of component ${validateProps.getTagNameWithoutPrefix(host)}:`;
	  validateProps.consoleWarn(warningPrefix, length
	    ? `Provided value has too many characters and was truncated to the max length of ${length}.`
	    : 'Provided value contains characters that are not of type number, the value was therefore reset.');
	};
	const isInputSingleDigit = (input) => /^\d$/.test(input);
	const hasInputOnlyDigitsOrWhitespaces = (input) => /^[\d ]+$/.test(input);
	const getConcatenatedInputValues = (pinCodeElements) => pinCodeElements.map((el) => el.value || ' ').join('');
	// reset value if it contains invalid characters and cut string if pasted value is longer than pin code length
	const getSanitisedValue = (host, value, length) => {
	  if (value && !hasInputOnlyDigitsOrWhitespaces(value)) {
	    warnAboutTransformedValue(host);
	    return '';
	  }
	  else if (removeWhiteSpaces(value)?.length > length) {
	    warnAboutTransformedValue(host, length);
	    return value.slice(0, length);
	  }
	  else {
	    return value;
	  }
	};
	const removeWhiteSpaces = (value) => value.replace(/\s/g, '');
	const initHiddenInput = (host, name, value, disabled, required) => {
	  const hiddenInput = document.createElement('input');
	  setAttributes.setAttributes(hiddenInput, {
	    'aria-hidden': 'true',
	    slot: hiddenInputSlotName,
	    tabindex: '-1',
	  });
	  syncHiddenInput(hiddenInput, name, value, disabled, required);
	  host.prepend(hiddenInput);
	  return hiddenInput;
	};
	const syncHiddenInput = (hiddenInput, name, value, disabled, required) => {
	  setAttributes.setAttributes(hiddenInput, {
	    name,
	    value: removeWhiteSpaces(value),
	  });
	  hiddenInput.toggleAttribute('disabled', disabled);
	  hiddenInput.toggleAttribute('required', required);
	};
	const isFormSubmittable = (host, form) => {
	  const PrefixedTagNames = validateProps.getPrefixedTagNames(host);
	  return !!(form.querySelectorAll('input:not([type=submit]):not([type=hidden])').length === 1 || // other sibling form elements e.g. select, textarea do not prevent submission
	    Array.from(form.querySelectorAll(`${PrefixedTagNames.pButton},${PrefixedTagNames.pButtonPure},button[type=submit],input[type=submit]`)).some((el) => el.type === 'submit'));
	};

	const getComponentCss = (hideLabel, state, isDisabled, isLoading, isWithinForm, length, theme) => {
	  const inputSize = `calc(${fontLineHeight.fontLineHeight} + 10px + ${validateProps.borderWidthBase} * 2 + ${spacingStaticSmall.spacingStaticSmall} * 2)`; // equivalent to calculation of input height within form-styles
	  const labelStyles = removeStyles('@media(hover:hover)', removeSlottedSelector(formStyles.getLabelStyles('input', isDisabled, hideLabel, state, theme)));
	  const inputStyles = removeStyles('input[readonly]', removeSlottedSelector(formStyles.getBaseChildStyles('input', state, theme, {
	    textAlign: 'center',
	    width: inputSize,
	    ...(length === 6 && {
	      [getMediaQueryMax.getMediaQueryMax('xs')]: {
	        width: `calc((276px - (${spacingStaticSmall.spacingStaticSmall} * 5)) / 6)`, // calculate the max with of the inputs that fit into grid in viewport base (276px)
	      },
	    }),
	    ...(isLoading && {
	      opacity: 0.2,
	      cursor: 'not-allowed',
	    }),
	  })));
	  return validateProps.getCss({
	    '@global': {
	      ':host': validateProps.addImportantToEachRule({
	        display: 'block',
	        ...colorSchemeStyles.colorSchemeStyles,
	        ...colorSchemeStyles.hostHiddenStyles,
	      }),
	      ...inputStyles,
	      ...(isWithinForm &&
	        validateProps.addImportantToEachRule({
	          '::slotted(input)': {
	            position: 'absolute',
	            height: inputSize,
	            width: 0,
	            opacity: 0,
	          },
	        })),
	    },
	    ...(isLoading && {
	      spinner: {
	        width: '100%',
	        height: inputSize,
	        pointerEvents: 'none',
	        position: 'absolute',
	        top: '50%',
	        left: '50%',
	        transform: 'translate(-50%, -50%)',
	      },
	    }),
	    'input-container': {
	      display: 'flex',
	      position: 'relative',
	      gap: spacingStaticSmall.spacingStaticSmall,
	      flexWrap: 'wrap',
	      width: 'fit-content',
	    },
	    ...validateProps.mergeDeep(labelStyles, {
	      label: {
	        ...validateProps.buildResponsiveStyles(hideLabel, 
	        // workaround: since pin-code component is not wrapped into label tag it behaves differently
	        (isLabelHidden) => (isLabelHidden ? { display: 'none' } : { display: 'inline-flex' })),
	        marginBottom: spacingStaticXSmall.spacingStaticXSmall,
	      },
	    }),
	    ...required.getFunctionalComponentRequiredStyles(),
	    ...required.getFunctionalComponentStateMessageStyles(theme, state),
	  });
	};

	const propTypes = {
	  label: validateProps.AllowedTypes.string,
	  description: validateProps.AllowedTypes.string,
	  name: validateProps.AllowedTypes.string,
	  length: validateProps.AllowedTypes.oneOf(PIN_CODE_LENGTHS),
	  hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	  state: validateProps.AllowedTypes.oneOf(required.FORM_STATES),
	  disabled: validateProps.AllowedTypes.boolean,
	  loading: validateProps.AllowedTypes.boolean,
	  required: validateProps.AllowedTypes.boolean,
	  message: validateProps.AllowedTypes.string,
	  type: validateProps.AllowedTypes.oneOf(PIN_CODE_TYPES),
	  value: validateProps.AllowedTypes.string,
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const PinCode = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.update = validateProps.createEvent(this, "update", 3);
	    this.inputElements = [];
	    this.onInput = (e) => {
	      // needed to update value on auto-complete via keyboard suggestion
	      const { target } = e;
	      if (target.value.length >= this.length) {
	        const sanitisedValue = removeWhiteSpaces(getSanitisedValue(this.host, target.value, this.length));
	        this.updateValue(sanitisedValue);
	        this.focusFirstEmptyOrLastInput(sanitisedValue);
	      }
	    };
	    this.onKeyDown = (e) => {
	      const { key, target, target: { previousElementSibling, nextElementSibling }, } = e;
	      // prevent default for disabled or loading, but do not impede tab key
	      if (isDisabledOrLoading.isDisabledOrLoading(this.disabled, this.loading) && key !== 'Tab') {
	        e.preventDefault();
	      } // if input is valid overwrite old value
	      else if (isInputSingleDigit(key)) {
	        e.preventDefault();
	        target.value = key;
	        this.updateValue(getConcatenatedInputValues(this.inputElements));
	        nextElementSibling?.focus();
	      } // handle alphanumeric keys, allow copy/paste shortcut
	      else if (key.length === 1 && !(e.ctrlKey || e.metaKey)) {
	        e.preventDefault();
	      } // handle backspace and delete
	      else if (key === 'Backspace' || key === 'Delete') {
	        // transfer focus backward/forward, if the input value is empty
	        if (!target.value) {
	          e.preventDefault();
	          if (key === 'Backspace' && previousElementSibling) {
	            previousElementSibling.value = '';
	            previousElementSibling.focus();
	          }
	          else if (key === 'Delete' && nextElementSibling) {
	            nextElementSibling.value = '';
	            nextElementSibling.focus();
	          }
	        }
	        target.value = '';
	        this.updateValue(getConcatenatedInputValues(this.inputElements));
	      } // support native submit behavior
	      else if (key === 'Enter') {
	        if (isWithinForm.isWithinForm && isFormSubmittable(this.host, this.form)) {
	          this.form.requestSubmit();
	        }
	      } // workaround since 'Dead' key e.g. ^¨ can not be prevented with e.preventDefault()
	      // workaround for ^ in firefox key: 'Process'
	      else if (key === 'Dead' || key === 'Process') {
	        target.blur();
	        requestAnimationFrame(() => target.focus());
	      }
	    };
	    this.onPaste = (e) => {
	      const sanitisedPastedValue = removeWhiteSpaces(getSanitisedValue(this.host, e.clipboardData.getData('Text'), this.length));
	      if (sanitisedPastedValue !== this.value) {
	        this.updateValue(sanitisedPastedValue);
	        this.focusFirstEmptyOrLastInput(sanitisedPastedValue);
	      }
	      e.preventDefault();
	    };
	    this.updateValue = (newValue) => {
	      this.value = newValue;
	      this.update.emit({ value: newValue, isComplete: removeWhiteSpaces(newValue).length === this.length });
	    };
	    this.focusFirstEmptyOrLastInput = (sanitisedValue) => {
	      this.inputElements[sanitisedValue.length === this.length ? sanitisedValue.length - 1 : sanitisedValue.length]?.focus();
	    };
	    this.label = '';
	    this.description = '';
	    this.name = undefined;
	    this.length = 4;
	    this.hideLabel = false;
	    this.state = 'none';
	    this.disabled = false;
	    this.loading = false;
	    this.required = false;
	    this.message = '';
	    this.type = 'number';
	    this.value = '';
	    this.theme = 'light';
	  }
	  componentWillLoad() {
	    this.form = getClosestHTMLElement.getClosestHTMLElement(this.host, 'form');
	    this.isWithinForm = !!this.form;
	    if (this.isWithinForm) {
	      this.hiddenInput = initHiddenInput(this.host, this.name, this.value, this.disabled, this.required);
	    }
	    this.value = getSanitisedValue(this.host, this.value, this.length);
	  }
	  componentWillUpdate() {
	    if (this.isWithinForm) {
	      syncHiddenInput(this.hiddenInput, this.name, this.value, this.disabled, this.required);
	    }
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    validateProps.attachComponentCss(this.host, getComponentCss, this.hideLabel, this.state, this.disabled, this.loading, this.isWithinForm, this.length, this.theme);
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    // reset array of input elements
	    this.inputElements = [];
	    const currentInputId = 'current-input';
	    const labelId = 'label';
	    const descriptionId = 'description';
	    const messageId = 'message';
	    return (validateProps.h(validateProps.Host, null, validateProps.h("label", { class: "label", htmlFor: currentInputId }, required.hasLabel(this.host, this.label) && (validateProps.h("span", { id: labelId, class: "label__text" }, this.label || validateProps.h("slot", { name: "label" }), !isParentFieldsetRequired.isParentFieldsetRequired(this.host) && this.required && validateProps.h(required.Required, null))), hasDescription.hasDescription(this.host, this.description) && (validateProps.h("span", { id: descriptionId, class: "label__text" }, this.description || validateProps.h("slot", { name: "description" })))), validateProps.h("div", { class: "input-container", onKeyDown: this.onKeyDown, onPaste: this.onPaste, onInput: this.onInput }, this.loading && (validateProps.h(PrefixedTagNames.pSpinner, { class: "spinner", size: "inherit", theme: this.theme, aria: { 'aria-label': 'Loading state' } })), this.isWithinForm && validateProps.h("slot", { name: hiddenInputSlotName }), Array.from(Array(this.length), (_, index) => (validateProps.h("input", { id: index === this.value.length ? currentInputId : null, type: this.type === 'number' ? 'text' : this.type, "aria-label": `${index + 1}-${this.length}`, "aria-describedby": `${labelId} ${descriptionId} ${messageId}`, "aria-invalid": this.state === 'error' ? 'true' : null, "aria-busy": this.loading ? 'true' : null, autoComplete: "one-time-code", pattern: "\\d*", inputMode: "numeric" // get numeric keyboard on mobile
	      ,
	      value: this.value[index] === ' ' ? null : this.value[index], disabled: this.disabled, required: this.required, ref: (el) => this.inputElements.push(el) })))), required.hasMessage(this.host, this.message, this.state) && (validateProps.h(required.StateMessage, { id: messageId, state: this.state, message: this.message, theme: this.theme, host: this.host }))));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	pPinCode_cjs_entry.p_pin_code = PinCode;

	
	return pPinCode_cjs_entry;
}

var pPopover_cjs_entry = {};

var hasRequiredPPopover_cjs_entry;

function requirePPopover_cjs_entry () {
	if (hasRequiredPPopover_cjs_entry) return pPopover_cjs_entry;
	hasRequiredPPopover_cjs_entry = 1;

	Object.defineProperty(pPopover_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const isClickOutside = requireIsClickOutside07c79402();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const hoverMediaQuery = requireHoverMediaQueryF2ccfc24();
	const constants = requireConstantsCa271244();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const fontLineHeight = requireFontLineHeight78b03658();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const theme = requireThemeBfc10573();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();

	const { backgroundColor: backgroundColorThemeLight, primaryColor: primaryColorThemeLight } = validateProps.getThemedColors('light');
	const { canvasColor, canvasTextColor } = validateProps.getHighContrastColors();
	const directionPositionMap = {
	  top: {
	    bottom: '100%',
	    left: '50%',
	    transform: 'translate3d(-50%, 0, 0)', // translate3d used to fix Safari shadow bug
	  },
	  right: {
	    top: '50%',
	    left: '100%',
	    transform: 'translate3d(0, -50%, 0)',
	  },
	  bottom: {
	    top: '100%',
	    left: '50%',
	    transform: 'translate3d(-50%, 0, 0)',
	  },
	  left: {
	    top: '50%',
	    right: '100%',
	    transform: 'translate3d(0, -50%, 0)',
	  },
	};
	const borderWidth = '12px';
	const transparentColor = 'transparent';
	const join = (...arr) => arr.join(' ');
	const directionArrowMap = {
	  top: {
	    top: 0,
	    left: '50%',
	    transform: 'translateX(-50%)',
	    borderWidth: join(borderWidth, borderWidth, 0),
	    borderColor: validateProps.isHighContrastMode
	      ? join(canvasTextColor, canvasColor, canvasColor)
	      : join(backgroundColorThemeLight, transparentColor, transparentColor),
	  },
	  right: {
	    top: '50%',
	    right: 0,
	    transform: 'translateY(-50%)',
	    borderWidth: join(borderWidth, borderWidth, borderWidth, 0),
	    borderColor: validateProps.isHighContrastMode
	      ? join(canvasColor, canvasTextColor, canvasColor, canvasColor)
	      : join(transparentColor, backgroundColorThemeLight, transparentColor, transparentColor),
	  },
	  bottom: {
	    bottom: 0,
	    left: '50%',
	    transform: 'translateX(-50%)',
	    borderWidth: join(0, borderWidth, borderWidth),
	    borderColor: validateProps.isHighContrastMode
	      ? join(canvasColor, canvasColor, canvasTextColor)
	      : join(transparentColor, transparentColor, backgroundColorThemeLight),
	  },
	  left: {
	    top: '50%',
	    left: 0,
	    transform: 'translateY(-50%)',
	    borderWidth: join(borderWidth, 0, borderWidth, borderWidth),
	    borderColor: validateProps.isHighContrastMode
	      ? join(canvasColor, canvasColor, canvasColor, canvasTextColor)
	      : join(transparentColor, transparentColor, transparentColor, backgroundColorThemeLight),
	  },
	};
	const getComponentCss = (direction, theme) => {
	  const spacerBox = '-16px';
	  const { hoverColor, focusColor } = validateProps.getThemedColors(theme);
	  return validateProps.getCss({
	    '@global': {
	      ':host': {
	        ...validateProps.addImportantToEachRule({
	          position: 'relative',
	          display: 'inline-block',
	          ...colorSchemeStyles.colorSchemeStyles,
	          ...colorSchemeStyles.hostHiddenStyles,
	        }),
	        verticalAlign: 'top',
	      },
	      p: {
	        ...textSmallStyle.textSmallStyle,
	        margin: 0,
	      },
	      button: {
	        display: 'block',
	        position: 'relative',
	        appearance: 'none',
	        background: 'transparent',
	        border: 0,
	        padding: 0,
	        outline: 0,
	        cursor: 'pointer',
	        ...textSmallStyle.textSmallStyle,
	        width: fontLineHeight.fontLineHeight,
	        height: fontLineHeight.fontLineHeight,
	        borderRadius: '50%',
	        ...hoverMediaQuery.hoverMediaQuery({
	          transition: validateProps.getTransition('background-color'),
	          '&:hover': {
	            ...validateProps.frostedGlassStyle,
	            backgroundColor: hoverColor,
	          },
	        }),
	        '&::before': {
	          content: '""',
	          position: 'absolute',
	          ...validateProps.getInsetJssStyle(-2),
	          border: `${validateProps.borderWidthBase} solid transparent`,
	          borderRadius: '50%',
	        },
	        '&:focus::before': {
	          borderColor: focusColor,
	        },
	        '&:focus:not(:focus-visible)::before': {
	          borderColor: 'transparent',
	        },
	      },
	    },
	    label: validateProps.getHiddenTextJssStyle(),
	    icon: {
	      display: 'inline-block',
	      transform: 'translate3d(0,0,0)', // Fixes movement on hover in Safari
	    },
	    spacer: {
	      position: 'absolute',
	      zIndex: constants.POPOVER_Z_INDEX,
	      top: spacerBox,
	      left: spacerBox,
	      right: spacerBox,
	      bottom: spacerBox,
	      filter: 'drop-shadow(0 0 16px rgba(0,0,0,.3))',
	      backdropFilter: 'drop-shadow(0px 0px 0px transparent)',
	      pointerEvents: 'none',
	      animation: '240ms $fadeIn ease forwards'
	        ,
	      '&::before': {
	        content: '""',
	        position: 'absolute',
	        borderStyle: 'solid',
	        ...directionArrowMap[direction],
	      },
	    },
	    popover: {
	      position: 'absolute',
	      maxWidth: 'min(90vw, 27rem)',
	      width: 'max-content',
	      boxSizing: 'border-box',
	      background: backgroundColorThemeLight,
	      padding: '8px 16px',
	      pointerEvents: 'auto',
	      ...directionPositionMap[direction],
	      ...textSmallStyle.textSmallStyle,
	      listStyleType: 'none',
	      color: primaryColorThemeLight,
	      whiteSpace: 'inherit',
	      borderRadius: borderRadiusSmall.borderRadiusSmall,
	      ...(validateProps.isHighContrastMode && {
	        outline: `1px solid ${canvasTextColor}`,
	      }),
	    },
	    '@keyframes fadeIn': {
	      from: {
	        opacity: 0,
	      },
	      to: {
	        opacity: 1,
	      },
	    },
	  });
	};

	const POPOVER_DIRECTIONS = ['top', 'right', 'bottom', 'left'];
	const POPOVER_ARIA_ATTRIBUTES = ['aria-label'];
	const safeZonePx = 16;
	const updatePopoverStyles = (host, spacer, popover, direction, theme) => {
	  // Reset margin so that it can be recalculated correctly
	  popover.style.margin = '0';
	  if (!isElementWithinViewport(spacer, popover, direction)) {
	    direction = getAutoDirection(spacer, popover);
	    validateProps.attachComponentCss(host, getComponentCss, direction, theme);
	  }
	  // Set margin via inline style to make attachComponentCss cacheable
	  popover.style.margin = getPopoverMargin(spacer, popover, direction);
	};
	const getDocumentHeightWidthWithoutSafeZone = () => {
	  const { clientWidth, clientHeight } = document.documentElement;
	  return { clientWidth: clientWidth - safeZonePx, clientHeight: clientHeight - safeZonePx };
	};
	const isElementWithinViewport = (spacer, popover, direction) => {
	  const { clientWidth, clientHeight } = getDocumentHeightWidthWithoutSafeZone();
	  const spacerRect = spacer.getBoundingClientRect();
	  const popoverRect = popover.getBoundingClientRect();
	  const isWithinXAxis = spacerRect.left >= safeZonePx && spacerRect.right <= clientWidth;
	  const isWithinYAxis = spacerRect.top >= safeZonePx && spacerRect.bottom <= clientHeight;
	  switch (direction) {
	    case 'top':
	      return isWithinXAxis && popoverRect.top >= safeZonePx;
	    case 'right':
	      return isWithinYAxis && popoverRect.right <= clientWidth;
	    case 'bottom':
	      return isWithinXAxis && popoverRect.bottom <= clientHeight;
	    case 'left':
	      return isWithinYAxis && popoverRect.left >= safeZonePx;
	  }
	};
	const calcSpaceForDirections = (spacer, popover) => {
	  const { clientWidth, clientHeight } = document.documentElement;
	  const spacerRect = spacer.getBoundingClientRect();
	  const popoverRect = popover.getBoundingClientRect();
	  // determine the **theoretically** maximum available space in all directions within viewport
	  return {
	    top: spacerRect.top - popoverRect.height,
	    right: clientWidth - (spacerRect.right + popoverRect.width),
	    bottom: clientHeight - (spacerRect.bottom + popoverRect.height),
	    left: spacerRect.left - popoverRect.width,
	  };
	};
	const getAutoDirection = (spacer, popover) => {
	  const directionSpaces = calcSpaceForDirections(spacer, popover);
	  // Find direction with the most space
	  return Object.keys(directionSpaces).reduce((resultDirection, currentDirection) => directionSpaces[resultDirection] >= directionSpaces[currentDirection] ? resultDirection : currentDirection, 'bottom');
	};
	const getPopoverMargin = (spacer, popover, direction) => {
	  const { clientWidth, clientHeight } = getDocumentHeightWidthWithoutSafeZone();
	  const spacerRect = spacer.getBoundingClientRect();
	  const popoverRect = popover.getBoundingClientRect();
	  // check x-axis offset is relevant for popover
	  if (['top', 'bottom'].includes(direction) && popoverRect.width > spacerRect.width) {
	    // check if popover exceeds left side of viewport
	    if (popoverRect.left < safeZonePx) {
	      return `0 0 0 ${Math.min(safeZonePx - popoverRect.left, spacerRect.left - popoverRect.left)}px`;
	    }
	    // check if popover exceeds right side of viewport
	    else if (popoverRect.right > clientWidth) {
	      return `0 0 0 ${Math.max(clientWidth - popoverRect.right, spacerRect.right - popoverRect.right)}px`;
	    }
	  }
	  // check y-axis offset is relevant for popover
	  else if (['left', 'right'].includes(direction) && popoverRect.height > spacerRect.height) {
	    // check if popover exceeds top side of viewport
	    if (popoverRect.top < safeZonePx) {
	      return `${Math.min(safeZonePx - popoverRect.top, spacerRect.top - popoverRect.top)}px 0 0 0`;
	    }
	    // check if popover exceeds bottom side of viewport
	    else if (popoverRect.bottom > clientHeight) {
	      return `${Math.max(clientHeight - popoverRect.bottom, spacerRect.bottom - popoverRect.bottom)}px 0 0 0`;
	    }
	  }
	  else {
	    return '0';
	  }
	};
	const registeredPopovers = [];
	const addDocumentEventListener = (popover) => {
	  if (!registeredPopovers.includes(popover)) {
	    registeredPopovers.push(popover);
	    document.addEventListener('mousedown', onDocumentMousedown); // multiple calls don't add multiple listeners
	    document.addEventListener('keydown', onDocumentKeydown); // multiple calls don't add multiple listeners
	  }
	};
	const removeDocumentEventListener = (popover) => {
	  const index = registeredPopovers.indexOf(popover);
	  if (index > -1) {
	    registeredPopovers.splice(index, 1);
	  }
	  if (registeredPopovers.length === 0) {
	    document.removeEventListener('mousedown', onDocumentMousedown);
	    document.removeEventListener('keydown', onDocumentKeydown);
	  }
	};
	const onDocumentMousedown = (e) => {
	  const popover = registeredPopovers.find((popoverItem) => popoverItem.open && isClickOutside.isClickOutside(e, popoverItem.host));
	  if (popover) {
	    popover.open = false;
	  }
	};
	const onDocumentKeydown = (e) => {
	  const { key } = e;
	  const isEscape = key === 'Escape';
	  if (isEscape || key === 'Enter' || key === 'SpaceBar' || key === ' ') {
	    const popover = registeredPopovers.find((popoverItem) => popoverItem.open && (isEscape || isClickOutside.isClickOutside(e, popoverItem.host)));
	    if (popover) {
	      popover.open = false;
	    }
	  }
	};

	const propTypes = {
	  direction: validateProps.AllowedTypes.oneOf(POPOVER_DIRECTIONS),
	  description: validateProps.AllowedTypes.string,
	  aria: validateProps.AllowedTypes.aria(POPOVER_ARIA_ATTRIBUTES),
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Popover = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.onKeydown = (e) => {
	      if (e.key === 'Escape') {
	        this.button.focus();
	      }
	    };
	    this.direction = 'bottom';
	    this.description = undefined;
	    this.aria = undefined;
	    this.theme = 'light';
	    this.open = false;
	  }
	  connectedCallback() {
	    addDocumentEventListener(this);
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  componentDidRender() {
	    if (this.open) {
	      // calculate / update position only possible after render
	      updatePopoverStyles(this.host, this.spacer, this.popover, this.direction, this.theme);
	    }
	  }
	  disconnectedCallback() {
	    removeDocumentEventListener(this);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    validateProps.attachComponentCss(this.host, getComponentCss, this.direction, this.theme);
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    return (validateProps.h(validateProps.Host, { onKeydown: this.onKeydown }, validateProps.h("button", { type: "button", onClick: () => (this.open = !this.open), ...validateProps.parseAndGetAriaAttributes({
	        ...validateProps.parseAndGetAriaAttributes(this.aria),
	        'aria-expanded': this.open,
	      }), ref: (el) => (this.button = el) }, validateProps.h(PrefixedTagNames.pIcon, { class: "icon", name: "information", theme: this.theme }), validateProps.h("span", { class: "label" }, "More information")), this.open && (validateProps.h("div", { class: "spacer", ref: (el) => (this.spacer = el) }, validateProps.h("div", { class: "popover", ref: (el) => (this.popover = el) }, this.description ? validateProps.h("p", null, this.description) : validateProps.h("slot", null))))));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	pPopover_cjs_entry.p_popover = Popover;

	
	return pPopover_cjs_entry;
}

var pRadioButtonWrapper_cjs_entry = {};

var hasRequiredPRadioButtonWrapper_cjs_entry;

function requirePRadioButtonWrapper_cjs_entry () {
	if (hasRequiredPRadioButtonWrapper_cjs_entry) return pRadioButtonWrapper_cjs_entry;
	hasRequiredPRadioButtonWrapper_cjs_entry = 1;

	Object.defineProperty(pRadioButtonWrapper_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const getClosestHTMLElement = requireGetClosestHTMLElement0135bfd9();
	const checkboxRadioStyles = requireCheckboxRadioStylesEabaca96();
	const required = requireRequiredBc18b612();
	const isRequiredAndParentNotRequired = requireIsRequiredAndParentNotRequired0b84c8cc();
	const theme = requireThemeBfc10573();
	const getOnlyChildOfKindHTMLElementOrThrow = requireGetOnlyChildOfKindHTMLElementOrThrowF6972c1c();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const escapeHashCharacter = requireEscapeHashCharacter072604c4();
	requireIsDisabledOrLoadingAd97a497();
	requireColorSchemeStyles81696be8();
	requireHoverMediaQueryF2ccfc24();
	requireFontLineHeight78b03658();
	requireTextSmallStyle7246779a();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireSpacingStaticSmall2130ed04();
	requireHasNamedSlot28c6bca1();
	requireGetNamedSlotA433c432();
	requireSpacingStaticXSmallB7d708b8();
	requireIsParentFieldsetRequired6f3a68ad();
	requireIsParentOfKindA9c351f2();
	requireGetDirectChildHTMLElements0adb2021();
	requireGetHTMLElements21fc87cc();
	requireTransformSelectorToDirectChildSelector08da8668();

	const getCheckedSVGBackgroundImage = (fill) => {
	  return escapeHashCharacter.getInlineSVGBackgroundImage(`<circle fill="${fill}" cx="12" cy="12" r="6"/>`);
	};
	const getComponentCss = (hideLabel, state, isDisabled, isLoading, theme) => {
	  const checkedIconColor = validateProps.isHighContrastMode
	    ? validateProps.getHighContrastColors().canvasColor
	    : escapeHashCharacter.escapeHashCharacter(validateProps.getInvertedThemedColors(theme).primaryColor);
	  const checkedIconColorDark = validateProps.isHighContrastMode
	    ? validateProps.getHighContrastColors().canvasColor
	    : escapeHashCharacter.escapeHashCharacter(validateProps.getInvertedThemedColors('dark').primaryColor);
	  return validateProps.getCss(validateProps.mergeDeep(checkboxRadioStyles.getCheckboxRadioJssStyle(hideLabel, state, isDisabled, isLoading, theme), {
	    '@global': {
	      '::slotted': validateProps.addImportantToEachRule({
	        '&(input)': {
	          borderRadius: '50%',
	        },
	        ...(!isLoading && {
	          '&(input:checked)': {
	            backgroundImage: getCheckedSVGBackgroundImage(checkedIconColor),
	            ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	              backgroundImage: getCheckedSVGBackgroundImage(checkedIconColorDark),
	            }),
	          },
	        }),
	        ...(!isDisabled && {
	          '&(input:focus)::before': {
	            borderRadius: '50%',
	          },
	        }),
	      }),
	    },
	  }));
	};

	const propTypes = {
	  label: validateProps.AllowedTypes.string,
	  state: validateProps.AllowedTypes.oneOf(required.FORM_STATES),
	  message: validateProps.AllowedTypes.string,
	  hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	  loading: validateProps.AllowedTypes.boolean,
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const RadioButtonWrapper = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.onLabelClick = (event) => {
	      /**
	       * we only want to simulate the input click by label click
	       * also we don't want to click to the input, if a link is clicked.
	       */
	      if (getClosestHTMLElement.getClosestHTMLElement(event.target, 'a') === null) {
	        this.input.click();
	      }
	    };
	    this.observeAttributes = () => {
	      validateProps.observeAttributes(this.input, ['disabled', 'required'], () => validateProps.forceUpdate(this.host));
	    };
	    this.label = '';
	    this.state = 'none';
	    this.message = '';
	    this.hideLabel = false;
	    this.loading = false;
	    this.theme = 'light';
	  }
	  connectedCallback() {
	    this.observeAttributes(); // on every reconnect
	  }
	  componentWillLoad() {
	    this.input = getOnlyChildOfKindHTMLElementOrThrow.getOnlyChildOfKindHTMLElementOrThrow(this.host, 'input[type=radio]');
	    checkboxRadioStyles.addChangeListener(this.input);
	    this.observeAttributes(); // once initially
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  componentDidRender() {
	    /*
	     * This is a workaround to improve accessibility because the input and the label/description/message text are placed in different DOM.
	     * Referencing ID's from outside the component is impossible because the web component’s DOM is separate.
	     * We have to wait for full support of the Accessibility Object Model (AOM) to provide the relationship between shadow DOM and slots
	     */
	    validateProps.setAriaAttributes(this.input, {
	      label: this.label,
	      message: this.message,
	      state: this.state,
	    });
	  }
	  disconnectedCallback() {
	    validateProps.unobserveAttributes(this.input);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    // spinner is only displayed when radio is not checked already
	    const isLoading = this.loading && !this.input.checked;
	    validateProps.attachComponentCss(this.host, getComponentCss, this.hideLabel, this.state, this.input.disabled, isLoading, this.theme);
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    return (validateProps.h(validateProps.Host, null, validateProps.h("label", { "aria-disabled": isLoading ? 'true' : null }, required.hasLabel(this.host, this.label) && (validateProps.h("span", { class: "text", onClick: !isLoading && this.onLabelClick }, this.label || validateProps.h("slot", { name: "label" }), isRequiredAndParentNotRequired.isRequiredAndParentNotRequired(this.host, this.input) && validateProps.h(required.Required, null))), validateProps.h("slot", null), isLoading && (validateProps.h(PrefixedTagNames.pSpinner, { class: "spinner", size: "inherit", theme: this.theme, aria: { 'aria-label': `Loading state of ${this.label}` } }))), required.hasMessage(this.host, this.message, this.state) && (validateProps.h(required.StateMessage, { state: this.state, message: this.message, theme: this.theme, host: this.host }))));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	pRadioButtonWrapper_cjs_entry.p_radio_button_wrapper = RadioButtonWrapper;

	
	return pRadioButtonWrapper_cjs_entry;
}

var pScroller_cjs_entry = {};

var scrollingC37f1aeb = {};

var hasRequiredScrollingC37f1aeb;

function requireScrollingC37f1aeb () {
	if (hasRequiredScrollingC37f1aeb) return scrollingC37f1aeb;
	hasRequiredScrollingC37f1aeb = 1;

	requireValidatePropsC2afb75b();
	const getHTMLElements = requireGetHTMLElements21fc87cc();

	const SCROLLER_ARIA_ATTRIBUTES = ['role'];
	/** @deprecated */
	const GRADIENT_COLOR_SCHEMES = ['default', 'surface'];
	const GRADIENT_COLORS = ['background-base', 'background-surface'];
	const SCROLL_INDICATOR_POSITIONS = ['top', 'center'];
	const getScrollPositionAfterPrevNextClick = (scrollAreaElement, direction) => {
	  const { scrollLeft } = scrollAreaElement;
	  const scrollByX = getScrollByX(scrollAreaElement);
	  return direction === 'next' ? scrollLeft + scrollByX : scrollLeft - scrollByX;
	};
	const getScrollerElements = (scrollerElement) => {
	  return getHTMLElements.getHTMLElements(scrollerElement.shadowRoot, '.scroll-area,.action-prev');
	};
	const isScrollable = (isPrevHidden, isNextHidden) => {
	  return !(isPrevHidden && isNextHidden);
	};

	const scrollElementTo = (el, amount) => {
	  el.scrollTo({
	    left: amount,
	    behavior: 'smooth', // TODO: make conditional so we don't need to wait in e2e or vrt tests
	  });
	};
	const getScrollByX = (scrollAreaElement) => {
	  return Math.round(scrollAreaElement.offsetWidth * 0.2);
	};
	const FOCUS_PADDING_WIDTH = 4;
	const getScrollActivePosition = (elements, direction, activeElementIndex, scrollerElement) => {
	  const { offsetLeft: activeElementOffsetLeft, offsetWidth: activeElementOffsetWidth } = elements[activeElementIndex <= 0 ? 0 : activeElementIndex] || {}; // empty object fallback for tabs without children
	  // offsetLeft: is the number of pixels that the upper left corner of the current element is offset to the left within the offsetParent node
	  // offsetParent: is a reference to the element which is the closest (nearest in the containment hierarchy) positioned ancestor element
	  // which usually is an element with a non-static position
	  // - in chrome this seems to respect shadow DOM and therefore is the div.scroll-wrapper element in p-scroller
	  // - in firefox and safari this is not the case and some other parent element (up to the body element) is used
	  // this obviously leads to completely wrong calculations which are being corrected
	  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetLeft
	  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent
	  const correctedActiveElementOffsetLeft = elements[0]?.offsetLeft === 0 ? activeElementOffsetLeft : activeElementOffsetLeft - scrollerElement.offsetLeft;
	  const [scrollAreaElement, prevGradientElement] = getScrollerElements(scrollerElement);
	  let scrollPosition;
	  if (direction === 'next') {
	    if (activeElementIndex === elements.length - 1) {
	      // go to last element
	      scrollPosition = correctedActiveElementOffsetLeft - FOCUS_PADDING_WIDTH;
	    }
	    else {
	      // go to next element
	      scrollPosition = correctedActiveElementOffsetLeft - prevGradientElement.offsetWidth + FOCUS_PADDING_WIDTH * 2;
	    }
	  }
	  else {
	    if (activeElementIndex === 0) {
	      // go to first element
	      scrollPosition = 0;
	    }
	    else {
	      // go to prev element
	      scrollPosition =
	        correctedActiveElementOffsetLeft +
	          activeElementOffsetWidth +
	          prevGradientElement.offsetWidth -
	          scrollAreaElement.offsetWidth;
	    }
	  }
	  return scrollPosition;
	};

	scrollingC37f1aeb.GRADIENT_COLORS = GRADIENT_COLORS;
	scrollingC37f1aeb.GRADIENT_COLOR_SCHEMES = GRADIENT_COLOR_SCHEMES;
	scrollingC37f1aeb.SCROLLER_ARIA_ATTRIBUTES = SCROLLER_ARIA_ATTRIBUTES;
	scrollingC37f1aeb.SCROLL_INDICATOR_POSITIONS = SCROLL_INDICATOR_POSITIONS;
	scrollingC37f1aeb.getScrollActivePosition = getScrollActivePosition;
	scrollingC37f1aeb.getScrollPositionAfterPrevNextClick = getScrollPositionAfterPrevNextClick;
	scrollingC37f1aeb.isScrollable = isScrollable;
	scrollingC37f1aeb.scrollElementTo = scrollElementTo;

	
	return scrollingC37f1aeb;
}

var hasRequiredPScroller_cjs_entry;

function requirePScroller_cjs_entry () {
	if (hasRequiredPScroller_cjs_entry) return pScroller_cjs_entry;
	hasRequiredPScroller_cjs_entry = 1;

	Object.defineProperty(pScroller_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const getHTMLElements = requireGetHTMLElements21fc87cc();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsedDa5fe664();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed3a5c494c();
	const scrolling = requireScrollingC37f1aeb();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const hoverMediaQuery = requireHoverMediaQueryF2ccfc24();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const fontLineHeight = requireFontLineHeight78b03658();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const dropShadowShared = requireDropShadowShared6e50faf3();
	requireHelperE5c4e0db();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();

	const dropShadowLowStyle = {
	    boxShadow: `0px 3px 8px ${dropShadowShared._dropShadowBackgroundColor}`, // filter: drop-shadow() causes visual glitches in Firefox in combination with frostedGlassStyle
	};

	const gradientColorLight = {
	  'background-base': '255,255,255',
	  'background-surface': '238,239,242',
	};
	const gradientColorDark = {
	  'background-base': '14,14,18',
	  'background-surface': '33,34,37',
	};
	const gradientColorMap = {
	  auto: gradientColorLight,
	  light: gradientColorLight,
	  dark: gradientColorDark,
	};
	const getGradient = (theme, gradientColorTheme) => {
	  const gradientColor = gradientColorMap[theme][gradientColorTheme];
	  return (`rgba(${gradientColor},1) 20%,` +
	    `rgba(${gradientColor},0.6) 48%,` +
	    `rgba(${gradientColor},0.3) 68%,` +
	    `rgba(${gradientColor},0)`);
	};
	const getComponentCss = (gradientColor, isNextHidden, isPrevHidden, scrollIndicatorPosition, hasScrollbar, theme) => {
	  const { backgroundColor, backgroundSurfaceColor, focusColor, hoverColor } = validateProps.getThemedColors(theme);
	  const { backgroundColor: backgroundColorDark, backgroundSurfaceColor: backgroundSurfaceColorDark, focusColor: focusColorDark, hoverColor: hoverColorDark, } = validateProps.getThemedColors('dark');
	  const backgroundColorLight = {
	    'background-base': backgroundColor,
	    'background-surface': backgroundSurfaceColor,
	  };
	  const backgroundColorMap = {
	    auto: backgroundColorLight,
	    light: backgroundColorLight,
	    dark: {
	      'background-base': backgroundSurfaceColorDark,
	      'background-surface': backgroundColorDark,
	    },
	  };
	  const actionPrevNextStyles = {
	    position: 'relative',
	    padding: '4px 0',
	    pointerEvents: 'none',
	    display: 'flex',
	    alignItems: scrollIndicatorPosition === 'center' ? 'center' : 'flex-start',
	  };
	  return validateProps.getCss({
	    '@global': {
	      ':host': validateProps.addImportantToEachRule({
	        display: 'block',
	        height: 'inherit',
	        ...colorSchemeStyles.colorSchemeStyles,
	        ...colorSchemeStyles.hostHiddenStyles,
	      }),
	      button: {
	        display: 'flex',
	        pointerEvents: 'auto',
	        alignItems: 'center',
	        justifyContent: 'center',
	        ...textSmallStyle.textSmallStyle,
	        height: `calc(${fontLineHeight.fontLineHeight} + 4px)`,
	        width: `calc(${fontLineHeight.fontLineHeight} + 4px)`,
	        border: 0,
	        outline: 0,
	        cursor: 'pointer',
	        background: backgroundColorMap[theme][gradientColor],
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          background: backgroundColorMap.dark[gradientColor],
	        }),
	        borderRadius: borderRadiusSmall.borderRadiusSmall,
	        ...validateProps.frostedGlassStyle,
	        visibility: 'hidden',
	        ...(!validateProps.isThemeDark(theme) && dropShadowLowStyle),
	        ...hoverMediaQuery.hoverMediaQuery({
	          transition: validateProps.getTransition('background-color'),
	          '&:hover': {
	            ...validateProps.frostedGlassStyle,
	            background: hoverColor,
	            ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	              background: hoverColorDark,
	            }),
	          },
	        }),
	      },
	    },
	    root: {
	      display: 'grid',
	      gridTemplateColumns: `calc(${fontLineHeight.fontLineHeight} + 24px) minmax(0, 1fr) calc(${fontLineHeight.fontLineHeight} + 24px)`,
	      margin: '0 -4px',
	      height: 'inherit',
	    },
	    'scroll-area': {
	      gridArea: '1 / 1 / 1 / -1',
	      padding: '4px',
	      overflow: 'auto hidden',
	      ...(!hasScrollbar && {
	        // If scrollbar is disabled - hide scrollbar
	        msOverflowStyle: 'none' /* IE and Edge */,
	        scrollbarWidth: 'none' /* Firefox */,
	        '&::-webkit-scrollbar': {
	          display: 'none',
	        },
	      }),
	    },
	    // Extra wrapper needed to compensate different offset parent calculation depending on browser.
	    // Needed for position of status bar.
	    'scroll-wrapper': {
	      position: 'relative',
	      display: 'inline-flex',
	      minHeight: '28px',
	      minWidth: '100%',
	      verticalAlign: 'top',
	      outline: 0,
	      '&::before': {
	        content: '""',
	        position: 'absolute',
	        ...validateProps.getInsetJssStyle(-4),
	        border: `${validateProps.borderWidthBase} solid transparent`,
	        borderRadius: borderRadiusSmall.borderRadiusSmall,
	        pointerEvents: 'none', // Needed to enable clicks inside of slot
	      },
	      '&:focus::before': {
	        borderColor: focusColor,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          borderColor: focusColorDark,
	        }),
	      },
	      '&:focus:not(:focus-visible)::before': {
	        borderColor: 'transparent',
	      },
	    },
	    trigger: {
	      position: 'absolute',
	      top: 0,
	      bottom: 0,
	      width: '1px',
	      visibility: 'hidden',
	      '&:first-of-type': {
	        left: 0,
	      },
	      '&:last-of-type': {
	        right: 0,
	      },
	    },
	    'action-prev': {
	      ...actionPrevNextStyles,
	      marginLeft: '-1px',
	      gridArea: '1 / 1 / 1 / 1',
	      justifyContent: 'flex-start',
	      background: `linear-gradient(to right, ${getGradient(theme, gradientColor)} 100%)`,
	      ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	        background: `linear-gradient(to right, ${getGradient('dark', gradientColor)} 100%)`,
	      }),
	      visibility: isPrevHidden ? 'hidden' : 'visible',
	      '& button': {
	        marginLeft: '8px',
	        // hide buttons on mobile (actually devices not supporting hover)
	        ...hoverMediaQuery.hoverMediaQuery({
	          visibility: isPrevHidden ? 'hidden' : 'visible',
	        }),
	      },
	    },
	    'action-next': {
	      ...actionPrevNextStyles,
	      marginRight: '-1px',
	      gridArea: '1 / 3 / 1 / 3',
	      justifyContent: 'flex-end',
	      background: `linear-gradient(to left, ${getGradient(theme, gradientColor)} 100%)`,
	      ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	        background: `linear-gradient(to left, ${getGradient('dark', gradientColor)} 100%)`,
	      }),
	      visibility: isNextHidden ? 'hidden' : 'visible',
	      '& button': {
	        marginRight: '8px',
	        // hide buttons on mobile (actually devices not supporting hover)
	        ...hoverMediaQuery.hoverMediaQuery({
	          visibility: isNextHidden ? 'hidden' : 'visible',
	        }),
	      },
	    },
	  });
	};

	const propTypes = {
	  gradientColorScheme: validateProps.AllowedTypes.oneOf([undefined, ...scrolling.GRADIENT_COLOR_SCHEMES]),
	  gradientColor: validateProps.AllowedTypes.oneOf(scrolling.GRADIENT_COLORS),
	  scrollToPosition: validateProps.AllowedTypes.shape({
	    scrollPosition: validateProps.AllowedTypes.number,
	    isSmooth: validateProps.AllowedTypes.boolean,
	  }),
	  scrollIndicatorPosition: validateProps.AllowedTypes.oneOf([
	    undefined,
	    ...scrolling.SCROLL_INDICATOR_POSITIONS,
	  ]),
	  alignScrollIndicator: validateProps.AllowedTypes.oneOf(scrolling.SCROLL_INDICATOR_POSITIONS),
	  scrollbar: validateProps.AllowedTypes.boolean,
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	  aria: validateProps.AllowedTypes.aria(scrolling.SCROLLER_ARIA_ATTRIBUTES),
	};
	const Scroller = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.initIntersectionObserver = () => {
	      const [firstTrigger, lastTrigger] = getHTMLElements.getHTMLElements(this.host.shadowRoot, '.trigger');
	      this.intersectionObserver = new IntersectionObserver((entries) => {
	        for (const { target, isIntersecting } of entries) {
	          if (target === firstTrigger) {
	            this.isPrevHidden = isIntersecting;
	          }
	          else if (target === lastTrigger) {
	            this.isNextHidden = isIntersecting;
	          }
	        }
	      }, {
	        root: this.scrollAreaElement,
	        // Defines the percentage of how much of the target (trigger) is visible within the element specified (this.host).
	        // In this case 0.9px of the trigger have to be hidden to show the gradient
	        threshold: 0.1,
	      });
	      this.intersectionObserver.observe(firstTrigger);
	      this.intersectionObserver.observe(lastTrigger);
	    };
	    this.scrollOnPrevNextClick = (direction) => {
	      const scrollPosition = scrolling.getScrollPositionAfterPrevNextClick(this.scrollAreaElement, direction);
	      scrolling.scrollElementTo(this.scrollAreaElement, scrollPosition);
	    };
	    this.gradientColorScheme = undefined;
	    this.gradientColor = 'background-base';
	    this.scrollToPosition = undefined;
	    this.scrollIndicatorPosition = undefined;
	    this.alignScrollIndicator = 'center';
	    this.theme = 'light';
	    this.scrollbar = false;
	    this.aria = undefined;
	    this.isPrevHidden = true;
	    this.isNextHidden = true;
	  }
	  scrollToPositionHandler() {
	    // TODO: does this.scrollToPosition already have the new value? or why aren't we using the first parameter of this function
	    this.scrollToPosition = validateProps.parseJSONAttribute(this.scrollToPosition);
	    // watcher might trigger before ref is defined with ssr
	    if (this.scrollAreaElement) {
	      const { scrollPosition, isSmooth } = this.scrollToPosition;
	      if (isSmooth) {
	        scrolling.scrollElementTo(this.scrollAreaElement, scrollPosition);
	      }
	      else {
	        this.scrollAreaElement.scrollLeft = scrollPosition;
	      }
	    }
	  }
	  connectedCallback() {
	    if (this.scrollAreaElement) {
	      this.scrollToPosition = validateProps.parseJSONAttribute(this.scrollToPosition);
	    }
	  }
	  componentDidLoad() {
	    this.initIntersectionObserver();
	    if (this.scrollToPosition) {
	      this.scrollToPositionHandler();
	    }
	  }
	  componentShouldUpdate(newVal, oldVal, propName) {
	    return (!(propName === 'scrollToPosition' && !scrolling.isScrollable(this.isNextHidden, this.isPrevHidden)) && // should only update if scrollable
	      validateProps.hasPropValueChanged(newVal, oldVal));
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'gradientColorScheme', 'Please use gradientColor prop instead.');
	    warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'scrollIndicatorPosition', 'Please use alignScrollIndicator prop instead.');
	    const deprecationMap = {
	      default: 'background-base',
	      surface: 'background-surface',
	    };
	    warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'gradientColorScheme', deprecationMap);
	    validateProps.attachComponentCss(this.host, getComponentCss, deprecationMap[this.gradientColorScheme] || this.gradientColor, this.isNextHidden, this.isPrevHidden, this.scrollIndicatorPosition || this.alignScrollIndicator, this.scrollbar, this.theme);
	    const renderPrevNextButton = (direction) => {
	      const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	      // TODO: why not use p-button?
	      return (validateProps.h("div", { key: direction, class: direction === 'next' ? 'action-next' : 'action-prev' }, validateProps.h("button", { type: "button", tabIndex: -1, onClick: () => this.scrollOnPrevNextClick(direction), "aria-hidden": "true", "aria-label": direction }, validateProps.h(PrefixedTagNames.pIcon, { class: "icon", name: direction === 'next' ? 'arrow-head-right' : 'arrow-head-left', theme: this.theme }))));
	    };
	    return (validateProps.h("div", { class: "root" }, validateProps.h("div", { class: "scroll-area", ref: (el) => (this.scrollAreaElement = el) }, validateProps.h("div", { class: "scroll-wrapper", role: validateProps.parseAndGetAriaAttributes(this.aria)?.role || null, tabIndex: scrolling.isScrollable(this.isPrevHidden, this.isNextHidden) ? 0 : null }, validateProps.h("slot", null), validateProps.h("div", { class: "trigger" }), validateProps.h("div", { class: "trigger" }))), ['prev', 'next'].map(renderPrevNextButton)));
	  }
	  get host() { return validateProps.getElement(this); }
	  static get watchers() { return {
	    "scrollToPosition": ["scrollToPositionHandler"]
	  }; }
	};

	pScroller_cjs_entry.p_scroller = Scroller;

	
	return pScroller_cjs_entry;
}

var pSegmentedControl_2_cjs_entry = {};

var throwIfChildrenAreNotOfKind39ea431a = {};

var hasRequiredThrowIfChildrenAreNotOfKind39ea431a;

function requireThrowIfChildrenAreNotOfKind39ea431a () {
	if (hasRequiredThrowIfChildrenAreNotOfKind39ea431a) return throwIfChildrenAreNotOfKind39ea431a;
	hasRequiredThrowIfChildrenAreNotOfKind39ea431a = 1;

	const validateProps = requireValidatePropsC2afb75b();

	const updateParent = (host) => {
	  validateProps.forceUpdate(host.parentElement);
	};

	const areAllChildrenOfKind = (element, tagName) => {
	  const children = Array.from(element.children);
	  const prefixedElementTagName = validateProps.getPrefixedTagNames(element)[validateProps.paramCaseToCamelCase(tagName)];
	  return !children.some((child) => validateProps.getTagName(child) !== prefixedElementTagName);
	};

	const throwIfChildrenAreNotOfKind = (element, tagName) => {
	  if (!areAllChildrenOfKind(element, tagName)) {
	    const allowedTagName = validateProps.getPrefixedTagNames(element)[validateProps.paramCaseToCamelCase(tagName)];
	    const actualTagNames = Array.from(element.children, validateProps.getTagName)
	      .filter((actualTagName) => actualTagName !== allowedTagName)
	      .join(', ');
	    validateProps.throwException(`child HTMLElements of ${validateProps.getTagNameWithoutPrefix(element)} should be of kind ${allowedTagName} but got ${actualTagNames}.`);
	  }
	};

	throwIfChildrenAreNotOfKind39ea431a.throwIfChildrenAreNotOfKind = throwIfChildrenAreNotOfKind;
	throwIfChildrenAreNotOfKind39ea431a.updateParent = updateParent;

	
	return throwIfChildrenAreNotOfKind39ea431a;
}

var textXSmallStyle1145ee25 = {};

var hasRequiredTextXSmallStyle1145ee25;

function requireTextXSmallStyle1145ee25 () {
	if (hasRequiredTextXSmallStyle1145ee25) return textXSmallStyle1145ee25;
	hasRequiredTextXSmallStyle1145ee25 = 1;

	const textShared = requireTextShared9135e2ef();
	const fontSizeTextXSmall = requireFontSizeTextXSmallE59d35d7();

	const textXSmallStyle = {
	    font: `${textShared._textFontPartA}${fontSizeTextXSmall.fontSizeTextXSmall}${textShared._textFontPartB}`,
	    ...textShared.fontHyphenationStyle,
	};

	textXSmallStyle1145ee25.textXSmallStyle = textXSmallStyle;

	
	return textXSmallStyle1145ee25;
}

var hasRequiredPSegmentedControl_2_cjs_entry;

function requirePSegmentedControl_2_cjs_entry () {
	if (hasRequiredPSegmentedControl_2_cjs_entry) return pSegmentedControl_2_cjs_entry;
	hasRequiredPSegmentedControl_2_cjs_entry = 1;

	Object.defineProperty(pSegmentedControl_2_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed3a5c494c();
	const theme = requireThemeBfc10573();
	const throwIfChildrenAreNotOfKind = requireThrowIfChildrenAreNotOfKind39ea431a();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const hoverMediaQuery = requireHoverMediaQueryF2ccfc24();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const textXSmallStyle = requireTextXSmallStyle1145ee25();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const hasDocument = requireHasDocument079654e6();
	const fontLineHeight = requireFontLineHeight78b03658();
	const getClickedItem = requireGetClickedItemE7e5ae2c();
	const throwIfParentIsNotOfKind = requireThrowIfParentIsNotOfKind99386afd();
	const getButtonBaseAriaAttributes = requireGetButtonBaseAriaAttributes51363b44();
	requireHelperE5c4e0db();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireFontSizeTextXSmallE59d35d7();
	requireIsParentOfKindA9c351f2();
	requireIsDisabledOrLoadingAd97a497();

	const throwIfPropIsUndefined = (element, propName, value) => {
	  if (value === undefined) {
	    validateProps.throwException(`the required property '${propName}' is undefined on ${validateProps.getTagNameWithoutPrefix(element)}.`);
	  }
	};

	const MIN_ITEM_WIDTH = 46;
	const MAX_ITEM_WIDTH = 220;
	const getComponentCss$1 = (maxWidth, columns) => {
	  maxWidth = (maxWidth > MAX_ITEM_WIDTH && MAX_ITEM_WIDTH) || (maxWidth < MIN_ITEM_WIDTH && MIN_ITEM_WIDTH) || maxWidth;
	  return validateProps.getCss({
	    '@global': {
	      ':host': validateProps.addImportantToEachRule({
	        display: 'grid',
	        gridAutoRows: '1fr',
	        ...validateProps.buildResponsiveStyles(columns, (col) => ({
	          gridTemplateColumns: col === 'auto' ? `repeat(auto-fit, ${maxWidth}px)` : `repeat(${col}, minmax(0, 1fr))`,
	        })),
	        gap: '6px',
	        ...colorSchemeStyles.colorSchemeStyles,
	        ...colorSchemeStyles.hostHiddenStyles,
	      }),
	    },
	  });
	};

	const ITEM_PADDING = '17px';
	const { font: BUTTON_FONT } = textSmallStyle.textSmallStyle;
	const { font: LABEL_FONT } = textXSmallStyle.textXSmallStyle;
	const ICON_SIZE = validateProps.pxToRemWithUnit(24);
	const ICON_MARGIN = validateProps.pxToRemWithUnit(4);
	const getColors = (isDisabled, isSelected, theme) => {
	  const { primaryColor, contrastMediumColor, disabledColor, contrastLowColor } = validateProps.getThemedColors(theme);
	  const { highlightColor } = validateProps.getHighContrastColors();
	  return {
	    buttonColor: isDisabled ? disabledColor : primaryColor,
	    labelColor: isDisabled ? disabledColor : contrastMediumColor,
	    borderColor: isSelected ? (validateProps.isHighContrastMode ? highlightColor : primaryColor) : contrastLowColor,
	    hoverBorderColor: primaryColor,
	  };
	};
	const getItemPadding = (hasIconAndSlottedContent) => hasIconAndSlottedContent ? `13px ${ITEM_PADDING} 13px 13px` : `13px ${ITEM_PADDING}`;
	const getComponentCss = (isDisabled, isSelected, hasIcon, hasSlottedContent, theme) => {
	  const { focusColor } = validateProps.getThemedColors(theme);
	  const { focusColor: focusColorDark } = validateProps.getThemedColors('dark');
	  const { buttonColor, labelColor, borderColor, hoverBorderColor } = getColors(isDisabled, isSelected, theme);
	  const { buttonColor: buttonColorDark, labelColor: labelColorDark, borderColor: borderColorDark, hoverBorderColor: hoverBorderColorDark, } = getColors(isDisabled, isSelected, 'dark');
	  return validateProps.getCss({
	    '@global': {
	      ':host': validateProps.addImportantToEachRule({
	        display: 'block',
	        outline: 0,
	        ...colorSchemeStyles.hostHiddenStyles,
	      }),
	      // All width relevant styling has to be kept in sync with the tempDiv of the p-segmented-control utils
	      button: {
	        position: 'relative',
	        display: 'block',
	        height: '100%',
	        width: '100%',
	        padding: getItemPadding(hasIcon && hasSlottedContent),
	        margin: 0,
	        border: `${validateProps.borderWidthBase} solid ${borderColor}`,
	        borderRadius: borderRadiusSmall.borderRadiusSmall,
	        outline: 0,
	        background: 'transparent',
	        color: buttonColor,
	        ...textSmallStyle.textSmallStyle,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          borderColor: borderColorDark,
	          color: buttonColorDark,
	        }),
	        '&::before': {
	          content: '""',
	          position: 'absolute',
	          ...validateProps.getInsetJssStyle(-5),
	          border: `${validateProps.borderWidthBase} solid transparent`,
	          borderRadius: '7px',
	        },
	        '&:focus::before': {
	          borderColor: focusColor,
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	            borderColor: focusColorDark,
	          }),
	        },
	        '&:focus:not(:focus-visible)::before': {
	          borderColor: 'transparent',
	        },
	        ...(isDisabled
	          ? {
	            cursor: 'not-allowed',
	          }
	          : {
	            cursor: 'pointer',
	            ...(!isSelected &&
	              hoverMediaQuery.hoverMediaQuery({
	                transition: validateProps.getTransition('border-color'),
	                '&:hover': {
	                  borderColor: hoverBorderColor,
	                  ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	                    borderColor: hoverBorderColorDark,
	                  }),
	                },
	              })),
	          }),
	      },
	      // label
	      span: {
	        display: 'block',
	        ...textXSmallStyle.textXSmallStyle,
	        overflowWrap: 'normal',
	        color: labelColor,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          color: labelColorDark,
	        }),
	      },
	    },
	    ...(hasIcon && {
	      icon: {
	        height: ICON_SIZE,
	        width: ICON_SIZE,
	        ...(hasSlottedContent && {
	          marginRight: ICON_MARGIN,
	        }),
	      },
	    }),
	  });
	};

	const SEGMENTED_CONTROL_BACKGROUND_COLORS = ['background-surface', 'background-default']; // 'background-color' prop is deprecated
	const SEGMENTED_CONTROL_COLUMNS = ['auto', ...Array.from(Array(25), (_, i) => i + 1)];
	// Expect Porsche Next to be available and use sans-serif (wide font for safety buffer) as fallback
	const tempFont = 'Porsche Next, sans-serif';
	// temporary dom node to measure max-width of children content
	// All width relevant styling has to be kept in sync with the button of the p-segmented-control-item
	const tempDiv = hasDocument.hasDocument ? document.createElement('div') : undefined;
	if (tempDiv) {
	  tempDiv.style.position = 'absolute';
	  tempDiv.style.visibility = 'hidden';
	  tempDiv.style.padding = `0 ${ITEM_PADDING}`; // Uses the largest possible padding of the item
	  tempDiv.style.border = `${validateProps.borderWidthBase} solid`;
	  tempDiv.style.boxSizing = 'border-box';
	  tempDiv.style.font = BUTTON_FONT.replace(fontLineHeight.fontFamily, tempFont);
	}
	const tempLabel = hasDocument.hasDocument ? document.createElement('div') : undefined;
	if (tempLabel) {
	  tempLabel.style.font = LABEL_FONT.replace(fontLineHeight.fontFamily, tempFont);
	}
	const tempIcon = hasDocument.hasDocument ? document.createElement('div') : undefined;
	if (tempIcon) {
	  tempIcon.style.display = 'inline-block';
	  tempIcon.style.width = ICON_SIZE;
	  tempIcon.style.marginRight = ICON_MARGIN;
	}
	const getItemMaxWidth = (host) => {
	  tempDiv.innerHTML = '';
	  host.shadowRoot.append(tempDiv);
	  const widths = Array.from(host.children, (item) => {
	    tempDiv.innerHTML = item.innerHTML;
	    if (item.icon || item.iconSource) {
	      tempDiv.prepend(tempIcon);
	    }
	    if (item.label) {
	      tempLabel.innerHTML = item.label;
	      tempDiv.prepend(tempLabel);
	    }
	    return parseFloat(getComputedStyle(tempDiv).width);
	  });
	  tempDiv.remove();
	  return Math.max(...widths);
	};
	const syncSegmentedControlItemsProps = (host, value, theme) => {
	  Array.from(host.children).forEach((item) => {
	    item.selected = item.value === value;
	    item.theme = theme;
	    validateProps.forceUpdate(item);
	  });
	};

	const propTypes$1 = {
	  backgroundColor: validateProps.AllowedTypes.oneOf([
	    undefined,
	    ...SEGMENTED_CONTROL_BACKGROUND_COLORS,
	  ]),
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	  value: validateProps.AllowedTypes.oneOf([validateProps.AllowedTypes.string, validateProps.AllowedTypes.number]),
	  columns: validateProps.AllowedTypes.breakpoint(SEGMENTED_CONTROL_COLUMNS),
	};
	const SegmentedControl = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.segmentedControlChange = validateProps.createEvent(this, "segmentedControlChange", 3);
	    this.update = validateProps.createEvent(this, "update", 3);
	    this.updateValue = (item) => {
	      if (item) {
	        this.value = item.value; // causes rerender
	        this.update.emit({ value: this.value });
	        this.segmentedControlChange.emit({ value: this.value });
	        item.focus();
	      }
	    };
	    this.backgroundColor = undefined;
	    this.theme = 'light';
	    this.value = undefined;
	    this.columns = 'auto';
	  }
	  connectedCallback() {
	    throwIfChildrenAreNotOfKind.throwIfChildrenAreNotOfKind(this.host, 'p-segmented-control-item');
	    // child property changes to label or icon are detected via prop watchers within child
	    // here we take care of dom changes like adding/removing a child or changing its content
	    validateProps.observeChildren(this.host, () => {
	      throwIfChildrenAreNotOfKind.throwIfChildrenAreNotOfKind(this.host, 'p-segmented-control-item');
	      validateProps.forceUpdate(this.host);
	    });
	  }
	  componentDidLoad() {
	    this.host.addEventListener('click', (e) => this.updateValue(getClickedItem.getClickedItem(this.host, 'p-segmented-control-item', e.composedPath())));
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  disconnectedCallback() {
	    validateProps.unobserveChildren(this.host);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes$1);
	    warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'backgroundColor');
	    validateProps.attachComponentCss(this.host, getComponentCss$1, getItemMaxWidth(this.host), this.columns);
	    syncSegmentedControlItemsProps(this.host, this.value, this.theme);
	    return (validateProps.h(validateProps.Host, { role: "group" }, validateProps.h("slot", null)));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	const getButtonAttributes = (isSelected, isDisabled) => ({
	  ...getButtonBaseAriaAttributes.getButtonBaseAriaAttributes(isDisabled, false),
	  ...validateProps.parseAndGetAriaAttributes({ 'aria-pressed': isSelected }),
	});
	const getIconColor = (isDisabled) => {
	  return !isDisabled ? 'primary' : 'contrast-medium';
	};

	const propTypes = {
	  value: validateProps.AllowedTypes.oneOf([validateProps.AllowedTypes.string, validateProps.AllowedTypes.number]),
	  disabled: validateProps.AllowedTypes.boolean,
	  label: validateProps.AllowedTypes.string,
	  icon: validateProps.AllowedTypes.string,
	  iconSource: validateProps.AllowedTypes.string,
	};
	const SegmentedControlItem = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.value = undefined;
	    this.disabled = false;
	    this.label = undefined;
	    this.icon = undefined;
	    this.iconSource = undefined;
	  }
	  handleLabelChange() {
	    // when these props change, we inform the parent to recalculate the max width for all items
	    throwIfChildrenAreNotOfKind.updateParent(this.host);
	  }
	  onClick(e) {
	    if (this.disabled || this.host.selected) {
	      e.stopPropagation();
	    }
	  }
	  connectedCallback() {
	    throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-segmented-control');
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    // this additional validation is still needed because undefined is allowed with current propTypes
	    throwIfPropIsUndefined(this.host, 'value', this.value);
	    const hasIcon = !!this.icon || !!this.iconSource;
	    const hasSlottedContent = !!this.host.innerHTML;
	    validateProps.attachComponentCss(this.host, getComponentCss, this.disabled, this.host.selected, hasIcon, hasSlottedContent, this.host.theme || 'light' // default as fallback
	    );
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    return (validateProps.h("button", { type: "button", ...getButtonAttributes(this.host.selected, this.disabled) }, this.label && validateProps.h("span", null, this.label), hasIcon && (validateProps.h(PrefixedTagNames.pIcon, { class: "icon", size: "inherit", name: this.icon, source: this.iconSource, color: getIconColor(this.disabled), theme: this.host.theme || 'light', "aria-hidden": "true" })), validateProps.h("slot", null)));
	  }
	  static get delegatesFocus() { return true; }
	  get host() { return validateProps.getElement(this); }
	  static get watchers() { return {
	    "label": ["handleLabelChange"],
	    "icon": ["handleLabelChange"],
	    "iconSource": ["handleLabelChange"]
	  }; }
	};

	pSegmentedControl_2_cjs_entry.p_segmented_control = SegmentedControl;
	pSegmentedControl_2_cjs_entry.p_segmented_control_item = SegmentedControlItem;

	
	return pSegmentedControl_2_cjs_entry;
}

var pSelectWrapper_2_cjs_entry = {};

var propertyObserverBfc089d2 = {};

var hasRequiredPropertyObserverBfc089d2;

function requirePropertyObserverBfc089d2 () {
	if (hasRequiredPropertyObserverBfc089d2) return propertyObserverBfc089d2;
	hasRequiredPropertyObserverBfc089d2 = 1;

	// inspired by react
	// https://github.com/facebook/react/blob/c88fb49d37fd01024e0a254a37b7810d107bdd1d/packages/react-dom/src/client/inputValueTracking.js#L53
	const observeProperties = (node, props, callback) => {
	  const proto = Object.getPrototypeOf(node);
	  const properties = props.reduce((result, prop) => {
	    const descriptor = Object.getOwnPropertyDescriptor(proto, prop);
	    if (
	    // node.hasOwnProperty(prop) || // this condition breaks p-text-field-wrapper type="search" clear button functionality in react
	    typeof descriptor === 'undefined' ||
	      typeof descriptor.get !== 'function' ||
	      typeof descriptor.set !== 'function') {
	      return result;
	    }
	    else {
	      // eslint-disable-next-line @typescript-eslint/unbound-method
	      const { get, set } = descriptor;
	      return {
	        ...result,
	        [prop]: {
	          configurable: true,
	          get() {
	            return get.call(this);
	          },
	          set(val) {
	            set.call(this, val);
	            callback();
	          },
	        },
	      };
	    }
	  }, {});
	  Object.defineProperties(node, properties);
	};

	propertyObserverBfc089d2.observeProperties = observeProperties;

	
	return propertyObserverBfc089d2;
}

var throwIfRootNodeIsNotOneOfKindB4d3ea18 = {};

var hasRequiredThrowIfRootNodeIsNotOneOfKindB4d3ea18;

function requireThrowIfRootNodeIsNotOneOfKindB4d3ea18 () {
	if (hasRequiredThrowIfRootNodeIsNotOneOfKindB4d3ea18) return throwIfRootNodeIsNotOneOfKindB4d3ea18;
	hasRequiredThrowIfRootNodeIsNotOneOfKindB4d3ea18 = 1;

	const validateProps = requireValidatePropsC2afb75b();

	const throwIfRootNodeIsNotOneOfKind = (element, tagNames) => {
	  const shadowHost = element.getRootNode()?.host;
	  const actualTagName = shadowHost && validateProps.getTagName(shadowHost);
	  const prefixedTagNames = validateProps.getPrefixedTagNames(element);
	  const allowedTagNames = tagNames.map((tagName) => prefixedTagNames[validateProps.paramCaseToCamelCase(tagName)]);
	  if (!allowedTagNames.includes(actualTagName)) {
	    validateProps.throwException(`${validateProps.getTagNameWithoutPrefix(element)} can't be used like this.`);
	  }
	};

	throwIfRootNodeIsNotOneOfKindB4d3ea18.throwIfRootNodeIsNotOneOfKind = throwIfRootNodeIsNotOneOfKind;

	
	return throwIfRootNodeIsNotOneOfKindB4d3ea18;
}

var hasRequiredPSelectWrapper_2_cjs_entry;

function requirePSelectWrapper_2_cjs_entry () {
	if (hasRequiredPSelectWrapper_2_cjs_entry) return pSelectWrapper_2_cjs_entry;
	hasRequiredPSelectWrapper_2_cjs_entry = 1;

	Object.defineProperty(pSelectWrapper_2_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const getSlotTextContent = requireGetSlotTextContent5379eb26();
	const required = requireRequiredBc18b612();
	const hasDescription = requireHasDescriptionA19e4bdc();
	const isRequiredAndParentNotRequired = requireIsRequiredAndParentNotRequired0b84c8cc();
	const theme = requireThemeBfc10573();
	const getOnlyChildOfKindHTMLElementOrThrow = requireGetOnlyChildOfKindHTMLElementOrThrowF6972c1c();
	const formStyles = requireFormStyles97f2cdf7();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const fontLineHeight = requireFontLineHeight78b03658();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();
	const selectDropdown = requireSelectDropdown5f011c9b();
	const isClickOutside = requireIsClickOutside07c79402();
	const isSsrHydration = requireIsSsrHydration9278b79b();
	const propertyObserver = requirePropertyObserverBfc089d2();
	const throwIfRootNodeIsNotOneOfKind = requireThrowIfRootNodeIsNotOneOfKindB4d3ea18();
	const getHTMLElements = requireGetHTMLElements21fc87cc();
	const hasAttribute = requireHasAttribute868c282d();
	const hoverMediaQuery = requireHoverMediaQueryF2ccfc24();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const fontWeightSemiBold = requireFontWeightSemiBold4482c830();
	requireHasNamedSlot28c6bca1();
	requireGetNamedSlotA433c432();
	requireSpacingStaticXSmallB7d708b8();
	requireIsParentFieldsetRequired6f3a68ad();
	requireIsParentOfKindA9c351f2();
	requireGetDirectChildHTMLElements0adb2021();
	requireTransformSelectorToDirectChildSelector08da8668();
	requireFontSizeTextXSmallE59d35d7();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();

	const isTouchDevice = () => {
	  if (!validateProps.hasWindow) {
	    return;
	  }
	  return !!('ontouchstart' in window || window.navigator.maxTouchPoints > 0);
	};

	const DROPDOWN_DIRECTIONS_INTERNAL = ['down', 'up'];
	const DROPDOWN_DIRECTIONS = [...DROPDOWN_DIRECTIONS_INTERNAL, 'auto'];
	const isCustomDropdown = (filter, native) => {
	  if (filter) {
	    return true;
	  }
	  else if (native) {
	    return false;
	  }
	  else {
	    return !isTouchDevice();
	  }
	};

	const getComponentCss$1 = (isDisabled, hasCustomDropdown, hideLabel, state, theme) => {
	  return validateProps.getCss({
	    '@global': validateProps.addImportantToEachRule({
	      ':host': {
	        display: 'block',
	        ...colorSchemeStyles.colorSchemeStyles,
	        ...colorSchemeStyles.hostHiddenStyles,
	      },
	      ...formStyles.getBaseChildStyles('select', state, theme, {
	        position: 'static',
	        zIndex: 0,
	        cursor: 'pointer',
	        padding: `8px calc(${fontLineHeight.fontLineHeight} + 10px + ${validateProps.borderWidthBase} * 2 + ${spacingStaticSmall.spacingStaticSmall} * 2) 8px ${spacingStaticMedium.spacingStaticMedium}`,
	        ...(hasCustomDropdown && !isDisabled && { borderColor: 'transparent' }),
	      }),
	    }),
	    root: {
	      display: 'block',
	      position: 'relative',
	    },
	    ...formStyles.getLabelStyles('select', isDisabled, hideLabel, state, theme, {
	      icon: {
	        position: 'absolute',
	        bottom: '13px',
	        right: '15px',
	        transform: 'rotate3d(0,0,1,0.0001deg)',
	        transition: validateProps.getTransition('transform'),
	        '&--open': {
	          transform: 'rotate3d(0,0,1,180deg)',
	        },
	      },
	    }),
	    ...required.getFunctionalComponentRequiredStyles(),
	    ...required.getFunctionalComponentStateMessageStyles(theme, state),
	  });
	};

	const propTypes = {
	  label: validateProps.AllowedTypes.string,
	  description: validateProps.AllowedTypes.string,
	  state: validateProps.AllowedTypes.oneOf(required.FORM_STATES),
	  message: validateProps.AllowedTypes.string,
	  hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	  filter: validateProps.AllowedTypes.boolean,
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	  dropdownDirection: validateProps.AllowedTypes.oneOf(DROPDOWN_DIRECTIONS),
	  native: validateProps.AllowedTypes.boolean,
	};
	const SelectWrapper = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.label = '';
	    this.description = '';
	    this.state = 'none';
	    this.message = '';
	    this.hideLabel = false;
	    this.filter = false;
	    this.theme = 'light';
	    this.dropdownDirection = 'auto';
	    this.native = false;
	  }
	  connectedCallback() {
	    this.observeAttributes(); // on every reconnect
	  }
	  componentWillLoad() {
	    this.select = getOnlyChildOfKindHTMLElementOrThrow.getOnlyChildOfKindHTMLElementOrThrow(this.host, 'select');
	    this.observeAttributes(); // once initially
	    this.hasCustomDropdown = isCustomDropdown(this.filter, this.native);
	    if (this.hasCustomDropdown) {
	      validateProps.setAttribute(this.select, 'tabindex', '-1');
	      validateProps.setAttribute(this.select, 'aria-hidden', 'true');
	    }
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  componentDidRender() {
	    /*
	     * This is a workaround to improve accessibility because the select and the label/description/message text are placed in different DOM.
	     * Referencing ID's from outside the component is impossible because the web component’s DOM is separate.
	     * We have to wait for full support of the Accessibility Object Model (AOM) to provide the relationship between shadow DOM and slots.
	     */
	    if (!this.hasCustomDropdown) {
	      validateProps.setAriaAttributes(this.select, {
	        label: this.label,
	        message: this.message || this.description,
	        state: this.state,
	      });
	    }
	  }
	  disconnectedCallback() {
	    validateProps.unobserveAttributes(this.select);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    const { disabled } = this.select;
	    validateProps.attachComponentCss(this.host, getComponentCss$1, disabled, this.hasCustomDropdown, this.hideLabel, this.state, this.theme);
	    const labelProps = disabled
	      ? {}
	      : {
	        onClick: () => (this.hasCustomDropdown
	          ? this.dropdownElement.shadowRoot.children[0]
	          : this.select).focus(),
	      };
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    return (validateProps.h(validateProps.Host, null, validateProps.h("div", { class: "root" }, validateProps.h("label", { class: "label" }, required.hasLabel(this.host, this.label) && (validateProps.h("span", { class: "label__text", ...labelProps }, this.label || validateProps.h("slot", { name: "label" }), isRequiredAndParentNotRequired.isRequiredAndParentNotRequired(this.host, this.select) && validateProps.h(required.Required, null))), hasDescription.hasDescription(this.host, this.description) && (validateProps.h("span", { class: "label__text", ...labelProps }, this.description || validateProps.h("slot", { name: "description" }))), validateProps.h(PrefixedTagNames.pIcon, { class: "icon", name: "arrow-head-down", theme: this.theme, color: disabled ? 'state-disabled' : 'primary', "aria-hidden": "true", ref: (el) => (this.iconElement = el) }), validateProps.h("slot", null)), this.hasCustomDropdown && !disabled && (validateProps.h(PrefixedTagNames.pSelectWrapperDropdown, { ref: (el) => (this.dropdownElement = el), selectRef: this.select, label: this.label || getSlotTextContent.getSlotTextContent(this.host, 'label'), message: this.message || getSlotTextContent.getSlotTextContent(this.host, 'message'), description: this.description || getSlotTextContent.getSlotTextContent(this.host, 'description'), state: this.state, direction: this.dropdownDirection, filter: this.filter, theme: this.theme, required: isRequiredAndParentNotRequired.isRequiredAndParentNotRequired(this.host, this.select), disabled: disabled, onOpenChange: (isOpen) => this.iconElement.classList.toggle('icon--open', isOpen) }))), required.hasMessage(this.host, this.message, this.state) && (validateProps.h(required.StateMessage, { state: this.state, message: this.message, theme: this.theme, host: this.host }))));
	  }
	  observeAttributes() {
	    validateProps.observeAttributes(this.select, ['disabled', 'required'], () => validateProps.forceUpdate(this.host));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	/**
	 * Handles scrolling within the list to ensure that the highlighted item is always visible.
	 * @param {HTMLElement} ul - The HTML element to be scrolled.
	 * @param {number} highlightedIndex - The index of the currently highlighted item within the element.
	 * @returns {void}
	 */
	const handleScroll = (ul, highlightedIndex) => {
	  const { maxHeight, padding } = getComputedStyle(ul);
	  const hostElementHeight = parseInt(maxHeight, 10);
	  if (ul.scrollHeight > hostElementHeight) {
	    const highlightedNode = getHTMLElements.getHTMLElements(ul, 'li')[highlightedIndex];
	    if (highlightedNode) {
	      ul.scrollTo({ top: highlightedNode.offsetTop - parseInt(padding, 10), behavior: 'instant' });
	    }
	  }
	};
	const getOptionsElements = (select) => Array.from(select.options);
	const getOptionMaps = (options) => options.map((item) => {
	  const { selected, parentElement, previousElementSibling } = item;
	  const option = {
	    value: item.text,
	    disabled: hasAttribute.hasAttribute(item, 'disabled'),
	    hidden: false,
	    initiallyHidden: hasAttribute.hasAttribute(item, 'hidden'),
	    selected,
	    highlighted: selected,
	    ...(validateProps.getTagName(parentElement) === 'optgroup' &&
	      previousElementSibling === null && { title: parentElement.label }),
	  };
	  return option;
	});
	const setSelectedOptionMaps = (options, newIndex) => options.map((item, idx) => ({
	  ...item,
	  selected: idx === newIndex,
	  highlighted: idx === newIndex,
	  hidden: false,
	}));
	const setHighlightedOptionMaps = (options, newIndex) => options.map((item, idx) => ({
	  ...item,
	  highlighted: idx === newIndex,
	}));
	const resetHighlightedToSelectedOptionMaps = (options) => options.map((item) => ({ ...item, highlighted: item.selected }));
	const setFirstHighlightedOptionMaps = (options) => setHighlightedOptionMaps(options, 0);
	const setLastHighlightedOptionMaps = (options) => setHighlightedOptionMaps(options, options.length - 1);
	const getHighlightedOptionMapIndex = (arr) => arr.findIndex((item) => item.highlighted);
	const getSelectedOptionMap = (arr) => arr.find((item) => item.selected);
	const getValidOptions = (options) => options.filter((item) => !item.hidden && !item.initiallyHidden && !item.disabled);
	const getAmountOfVisibleOptionsAndOptgroups = (options) => {
	  return options.reduce((count, { hidden, initiallyHidden, title }) => {
	    count += !hidden && !initiallyHidden ? 1 : 0;
	    count += title ? 1 : 0;
	    return count;
	  }, 0);
	};
	const getMatchingOptionMaps = (options, searchString) => {
	  const lowerCaseSearchString = searchString.toLowerCase();
	  return lowerCaseSearchString && options.filter((item) => item.value.toLowerCase() === lowerCaseSearchString);
	};
	const getFirstMatchingOptionMapIndex = (options, key) => {
	  // TODO: what about other characters?
	  if ([...'abcdefghijklmnopqrstuvwxyzäöüß1234567890'].includes(key)) {
	    const lowerCaseSearchString = key.toLowerCase();
	    const firstMatchingIndex = lowerCaseSearchString && options.findIndex((item) => item.value.toLowerCase().startsWith(lowerCaseSearchString));
	    // jump to last item if no match is found
	    return firstMatchingIndex >= 0 ? firstMatchingIndex : options.length - 1;
	  }
	};
	const setHighlightedFirstMatchingOptionMaps = (options, key) => {
	  const targetIndex = getFirstMatchingOptionMapIndex(options, key);
	  return targetIndex >= 0 ? options.map((item, idx) => ({ ...item, highlighted: idx === targetIndex })) : options;
	};
	const setFilteredOptionMaps = (options, searchString) => {
	  const lowerCaseSearchString = searchString.toLowerCase();
	  return options.map((item) => ({
	    ...item,
	    hidden: !item.initiallyHidden && !item.value.toLowerCase().includes(lowerCaseSearchString),
	  }));
	};
	const resetFilteredOptionMaps = (options) => options.map((item) => ({
	  ...item,
	  hidden: false,
	}));
	const hasFilterResults = (options) => options.some((item) => !item.hidden && !item.initiallyHidden);
	const getNewOptionMapIndex = (options, direction) => {
	  const validItems = getValidOptions(options);
	  const validMax = validItems.length - 1;
	  // prob. needs to be <= 0
	  if (validMax < 0) {
	    return;
	  }
	  let i = getHighlightedOptionMapIndex(validItems);
	  if (direction === 'down') {
	    i = i < validMax ? i + 1 : 0;
	  }
	  else if (direction === 'up') {
	    i = i > 0 ? i - 1 : validMax;
	  }
	  return options.indexOf(validItems[i]);
	};
	const getDropdownVisibility = (isOpen, type, resetFilter) => {
	  if (isOpen && (type === 'hide' || type === 'toggle')) {
	    if (resetFilter) {
	      resetFilter();
	    }
	    return false;
	  }
	  else if (!isOpen && (type === 'show' || type === 'toggle')) {
	    return true;
	  }
	  else {
	    return isOpen;
	  }
	};

	const dropdownPositionVar = '--p-internal-dropdown-position';
	const getButtonStyles = (direction, isOpen, state, theme) => {
	  const { primaryColor, disabledColor, contrastMediumColor } = validateProps.getThemedColors(theme);
	  const { primaryColor: primaryColorDark, disabledColor: disabledColorDark, contrastMediumColor: contrastMediumColorDark, } = validateProps.getThemedColors('dark');
	  const { formStateHoverColor, formStateColor } = required.getThemedFormStateColors(theme, state);
	  const { formStateHoverColor: formStateHoverColorDark, formStateColor: formStateColorDark } = required.getThemedFormStateColors('dark', state);
	  const isDirectionDown = direction === 'down';
	  return {
	    '@global': {
	      button: {
	        position: 'absolute',
	        top: 0,
	        height: `calc(${fontLineHeight.fontLineHeight} + 10px + ${validateProps.borderWidthBase} * 2 + ${spacingStaticSmall.spacingStaticSmall} * 2)`,
	        width: '100%',
	        font: textSmallStyle.textSmallStyle.font.replace('ex', 'ex + 6px'),
	        padding: 0,
	        background: 'transparent',
	        border: `${validateProps.borderWidthBase} solid ${isOpen ? primaryColor : formStateColor || contrastMediumColor}`,
	        borderRadius: borderRadiusSmall.borderRadiusSmall,
	        outline: '0',
	        cursor: 'pointer',
	        transition: validateProps.getTransition('border-color'),
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          borderColor: isOpen ? primaryColorDark : formStateColorDark || contrastMediumColorDark,
	        }),
	        '&:focus, &:focus ~ ul': {
	          borderColor: primaryColor,
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	            borderColor: primaryColorDark,
	          }),
	        },
	        ...hoverMediaQuery.hoverMediaQuery({
	          '&:not(:disabled):not(:focus):hover': {
	            borderColor: isOpen ? primaryColor : formStateHoverColor || primaryColor,
	            ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	              borderColor: isOpen ? primaryColorDark : formStateHoverColorDark || primaryColorDark,
	            }),
	          },
	        }),
	        '&:disabled': {
	          cursor: 'not-allowed',
	          borderColor: disabledColor,
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	            borderColor: disabledColorDark,
	          }),
	        },
	        ...(isOpen && {
	          [isDirectionDown ? 'borderBottomLeftRadius' : 'borderTopLeftRadius']: 0,
	          [isDirectionDown ? 'borderBottomRightRadius' : 'borderTopRightRadius']: 0,
	        }),
	      },
	    },
	  };
	};
	const getFilterStyles = (direction, isOpen, state, disabled, theme) => {
	  const { primaryColor, backgroundColor, disabledColor, contrastMediumColor } = validateProps.getThemedColors(theme);
	  const { primaryColor: primaryColorDark, backgroundColor: backgroundColorDark, disabledColor: disabledColorDark, contrastMediumColor: contrastMediumColorDark, } = validateProps.getThemedColors('dark');
	  const { formStateHoverColor, formStateColor } = required.getThemedFormStateColors(theme, state);
	  const { formStateHoverColor: formStateHoverColorDark, formStateColor: formStateColorDark } = required.getThemedFormStateColors('dark', state);
	  const isDirectionDown = direction === 'down';
	  const placeHolderJssStyle = {
	    opacity: 1,
	    color: disabled ? disabledColor : primaryColor,
	  };
	  const placeHolderDarkJssStyle = {
	    opacity: 1,
	    color: disabled ? disabledColorDark : primaryColorDark,
	  };
	  return {
	    '@global': {
	      input: {
	        display: 'block',
	        position: 'absolute',
	        zIndex: 1,
	        bottom: '2px',
	        left: '2px',
	        width: `calc(100% - (${fontLineHeight.fontLineHeight} + 6px + ${validateProps.borderWidthBase} * 2 + ${spacingStaticSmall.spacingStaticSmall} * 2))`,
	        height: `calc(${fontLineHeight.fontLineHeight} + 6px + ${validateProps.borderWidthBase} * 2 + ${spacingStaticSmall.spacingStaticSmall} * 2)`,
	        font: textSmallStyle.textSmallStyle.font.replace('ex', 'ex + 6px'),
	        padding: `13px ${spacingStaticMedium.spacingStaticMedium}`,
	        outline: '0',
	        appearance: 'none',
	        boxSizing: 'border-box',
	        border: '0',
	        borderRadius: borderRadiusSmall.borderRadiusSmall,
	        opacity: 0,
	        ...textSmallStyle.textSmallStyle,
	        textIndent: 0,
	        cursor: disabled ? 'not-allowed' : 'text',
	        color: primaryColor,
	        background: backgroundColor,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          color: primaryColorDark,
	          background: backgroundColorDark,
	        }),
	        '&::placeholder': {
	          ...placeHolderJssStyle,
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, placeHolderDarkJssStyle),
	        },
	        '&::-webkit-input-placeholder': {
	          ...placeHolderJssStyle,
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, placeHolderDarkJssStyle),
	        },
	        '&::-moz-placeholder': {
	          ...placeHolderJssStyle,
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, placeHolderDarkJssStyle),
	        },
	        '&:not(:disabled):focus': {
	          opacity: 1,
	          '&+span, &~ ul': {
	            borderColor: primaryColor,
	            ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	              borderColor: primaryColorDark,
	            }),
	          },
	        },
	        ...hoverMediaQuery.hoverMediaQuery({
	          '&:not(:disabled)': {
	            '&+span:hover': {
	              borderColor: isOpen ? primaryColor : formStateHoverColor || primaryColor,
	              ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	                borderColor: isOpen ? primaryColorDark : formStateHoverColorDark || primaryColorDark,
	              }),
	            },
	            '&:hover': {
	              '&+span, &~ul': {
	                borderColor: isOpen ? primaryColor : formStateHoverColor || primaryColor,
	                ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	                  borderColor: isOpen ? primaryColorDark : formStateHoverColorDark || primaryColorDark,
	                }),
	              },
	            },
	          },
	        }),
	        '&+span': {
	          // for focus outline and clicking arrow since input ends left of the icon
	          position: 'absolute',
	          ...validateProps.getInsetJssStyle(),
	          transition: validateProps.getTransition('border-color'),
	          pointerEvents: 'all',
	          cursor: disabled ? 'not-allowed' : 'pointer',
	          border: `${validateProps.borderWidthBase} solid ${isOpen ? primaryColor : formStateColor || contrastMediumColor}`,
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	            borderColor: isOpen ? primaryColorDark : formStateColorDark || contrastMediumColorDark,
	          }),
	          borderRadius: borderRadiusSmall.borderRadiusSmall,
	          ...(isOpen && {
	            [isDirectionDown ? 'borderBottomLeftRadius' : 'borderTopLeftRadius']: 0,
	            [isDirectionDown ? 'borderBottomRightRadius' : 'borderTopRightRadius']: 0,
	          }),
	        },
	      },
	    },
	  };
	};
	const getListStyles = (direction, theme) => {
	  const isDirectionDown = direction === 'down';
	  const { primaryColor: primaryColorDark, backgroundColor: backgroundColorDark, contrastMediumColor: contrastMediumColorDark, disabledColor: disabledColorDark, contrastHighColor: contrastHighColorDark, backgroundSurfaceColor: backgroundSurfaceColorDark, contrastLowColor: contrastLowColorDark, } = validateProps.getThemedColors('dark');
	  const { primaryColor, backgroundColor, contrastMediumColor, contrastHighColor, backgroundSurfaceColor, disabledColor, contrastLowColor, } = validateProps.getThemedColors(theme);
	  const { highlightColor } = validateProps.getHighContrastColors();
	  return {
	    '@global': {
	      ul: {
	        display: 'flex',
	        flexDirection: 'column',
	        gap: spacingStaticSmall.spacingStaticSmall,
	        position: `var(${dropdownPositionVar})`,
	        padding: '6px',
	        margin: 0,
	        background: backgroundColor,
	        ...textSmallStyle.textSmallStyle,
	        zIndex: 10,
	        left: 0,
	        right: 0,
	        [isDirectionDown ? 'top' : 'bottom']: 'calc(100% - 2px)',
	        boxSizing: 'border-box',
	        maxHeight: `${8.5 * (selectDropdown.OPTION_HEIGHT + 8) + 6 + 2}px`,
	        overflowY: 'auto',
	        WebkitOverflowScrolling: 'touch',
	        scrollBehavior: 'smooth',
	        border: `2px solid ${primaryColor}`,
	        [isDirectionDown ? 'borderTop' : 'borderBottom']: validateProps.addImportantToRule(`1px solid ${contrastMediumColor}`),
	        ...(isDirectionDown
	          ? ['borderBottomLeftRadius', 'borderBottomRightRadius']
	          : ['borderTopLeftRadius', 'borderTopRightRadius']).reduce((result, curr) => ({ ...result, [curr]: borderRadiusSmall.borderRadiusSmall }), {}),
	        scrollbarWidth: 'thin',
	        scrollbarColor: 'auto',
	        transition: validateProps.getTransition('border-color'),
	        transform: 'translate3d(0,0,0)',
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          background: backgroundColorDark,
	          borderColor: primaryColorDark,
	          [isDirectionDown ? 'borderTopColor' : 'borderBottomColor']: validateProps.addImportantToRule(contrastMediumColorDark),
	        }),
	      },
	    },
	    option: {
	      display: 'flex',
	      justifyContent: 'space-between',
	      gap: '12px',
	      padding: `${spacingStaticSmall.spacingStaticSmall} 12px`,
	      flex: `1 0 calc(${fontLineHeight.fontLineHeight} + ${spacingStaticSmall.spacingStaticSmall} * 2)`,
	      color: contrastHighColor,
	      ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	        color: contrastHighColorDark,
	      }),
	      cursor: 'pointer',
	      textAlign: 'left',
	      wordBreak: 'break-word',
	      boxSizing: 'border-box',
	      borderRadius: borderRadiusSmall.borderRadiusSmall,
	      transition: ['background-color', 'color'].map(validateProps.getTransition).join(),
	      ...selectDropdown.getNoResultsOptionJssStyle(),
	      ...hoverMediaQuery.hoverMediaQuery({
	        '&:not([aria-disabled]):not(.option--disabled):not([role=status]):hover': {
	          color: validateProps.isHighContrastMode ? highlightColor : primaryColor,
	          background: contrastLowColor,
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	            color: validateProps.isHighContrastMode ? highlightColor : primaryColorDark,
	            background: contrastLowColorDark,
	          }),
	        },
	      }),
	      '&--selected': {
	        cursor: 'default',
	        pointerEvents: 'none',
	        background: backgroundSurfaceColor,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          background: backgroundSurfaceColorDark,
	        }),
	      },
	      '&--highlighted': {
	        background: contrastLowColor,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          background: contrastLowColorDark,
	        }),
	      },
	      '&--highlighted, &--selected': {
	        color: validateProps.isHighContrastMode ? highlightColor : primaryColor,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          color: validateProps.isHighContrastMode ? highlightColor : primaryColorDark,
	        }),
	      },
	      '&--disabled': {
	        cursor: 'not-allowed',
	        color: disabledColor,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          color: disabledColorDark,
	        }),
	      },
	      '&--hidden': {
	        display: 'none',
	      },
	    },
	    optgroup: {
	      display: 'block',
	      padding: '3px 14px',
	      fontWeight: fontWeightSemiBold.fontWeightSemiBold,
	      '&:not(:first-child)': {
	        marginTop: spacingStaticSmall.spacingStaticSmall,
	      },
	      '&~$option': {
	        paddingLeft: '24px',
	      },
	    },
	  };
	};
	const getComponentCss = (direction, isOpen, state, disabled, filter, theme) => {
	  const { primaryColor, contrastMediumColor, disabledColor } = validateProps.getThemedColors(theme);
	  const { primaryColor: primaryColorDark, contrastMediumColor: contrastMediumColorDark, disabledColor: disabledColorDark, } = validateProps.getThemedColors('dark');
	  const { formStateColor, formStateHoverColor } = required.getThemedFormStateColors(theme, state);
	  const { formStateColor: formStateColorDark, formStateHoverColor: formStateHoverColorDark } = required.getThemedFormStateColors('dark', state);
	  return validateProps.getCss(
	  // merge because of global styles
	  validateProps.mergeDeep({
	    '@global': {
	      ':host': {
	        [dropdownPositionVar]: 'absolute',
	        display: 'block',
	        position: `var(${dropdownPositionVar})`,
	        font: textSmallStyle.textSmallStyle.font.replace('ex', 'ex + 6px'),
	        marginTop: `calc(-1 * (${fontLineHeight.fontLineHeight} + 10px + ${validateProps.borderWidthBase} * 2 + ${spacingStaticSmall.spacingStaticSmall} * 2))`,
	        paddingTop: `calc(${fontLineHeight.fontLineHeight} + 10px + ${validateProps.borderWidthBase} * 2 + ${spacingStaticSmall.spacingStaticSmall} * 2)`,
	        left: 0,
	        right: 0,
	        color: disabled ? disabledColor : formStateColor || contrastMediumColor,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          color: disabled ? disabledColorDark : formStateColorDark || contrastMediumColorDark,
	        }),
	        ...(!disabled &&
	          !validateProps.isHighContrastMode &&
	          hoverMediaQuery.hoverMediaQuery({
	            '&(:hover)': {
	              color: formStateHoverColor || primaryColor,
	              ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	                color: formStateHoverColorDark || primaryColorDark,
	              }),
	            },
	          })),
	      },
	    },
	    'sr-text': {
	      display: 'none',
	    },
	  }, filter
	    ? getFilterStyles(direction, isOpen, state, disabled, theme)
	    : getButtonStyles(direction, isOpen, state, theme), isOpen && getListStyles(direction, theme)));
	};

	const SelectWrapperDropdown = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.onClickOutside = (e) => {
	      if (this.isOpen && isClickOutside.isClickOutside(e, this.host)) {
	        this.setDropdownVisibility('hide');
	      }
	    };
	    this.setDropdownVisibility = (type) => {
	      this.isOpen = getDropdownVisibility(this.isOpen, type, this.filter && this.resetFilter);
	      this.onOpenChange(this.isOpen);
	    };
	    this.onComboboxKeyDown = (e) => {
	      switch (e.key) {
	        case 'ArrowUp':
	        case 'Up':
	          e.preventDefault();
	          this.cycleDropdown('up');
	          break;
	        case 'ArrowDown':
	        case 'Down':
	          e.preventDefault();
	          this.cycleDropdown('down');
	          break;
	        case ' ':
	        case 'Spacebar':
	        case 'Enter':
	          if (this.filter) {
	            if (e.key === 'Enter') {
	              e.preventDefault();
	              const matchingOptions = getMatchingOptionMaps(this.optionMaps, this.searchString);
	              if (matchingOptions.length === 1) {
	                this.setOptionSelected(this.optionMaps.indexOf(matchingOptions[0]));
	              }
	              else {
	                this.setOptionSelected(getHighlightedOptionMapIndex(this.optionMaps));
	              }
	            }
	          }
	          else {
	            e.preventDefault();
	            if (this.isOpen) {
	              this.setOptionSelected(getHighlightedOptionMapIndex(this.optionMaps));
	            }
	            else {
	              this.setDropdownVisibility('show');
	            }
	          }
	          break;
	        case 'Escape':
	        case 'Tab':
	          this.setDropdownVisibility('hide');
	          this.resetHighlightedToSelectedOptionMaps();
	          break;
	        case 'PageUp':
	          if (this.isOpen) {
	            e.preventDefault();
	            this.optionMaps = setFirstHighlightedOptionMaps(this.optionMaps);
	          }
	          break;
	        case 'PageDown':
	          if (this.isOpen) {
	            e.preventDefault();
	            this.optionMaps = setLastHighlightedOptionMaps(this.optionMaps);
	          }
	          break;
	        default:
	          if (!this.filter) {
	            // TODO: seems to be difficult to combine multiple keys as native select does
	            this.optionMaps = setHighlightedFirstMatchingOptionMaps(this.optionMaps, e.key);
	          }
	      }
	    };
	    this.syncSelectedIndex = () => {
	      this.optionMaps = setSelectedOptionMaps(this.optionMaps, this.selectedIndex);
	    };
	    this.setOptionMaps = () => {
	      this.optionMaps = setSelectedOptionMaps(getOptionMaps(getOptionsElements(this.selectRef)), this.selectedIndex);
	    };
	    this.resetHighlightedToSelectedOptionMaps = () => {
	      this.optionMaps = resetHighlightedToSelectedOptionMaps(this.optionMaps);
	    };
	    this.setOptionSelected = (newIndex) => {
	      this.setDropdownVisibility('hide');
	      if (this.selectedIndex !== newIndex) {
	        this.selectRef.selectedIndex = newIndex;
	        this.selectRef.dispatchEvent(new Event('change', { bubbles: true }));
	      }
	      else {
	        this.resetHighlightedToSelectedOptionMaps();
	        this.resetFilter();
	      }
	    };
	    this.resetFilter = () => {
	      if (this.filter) {
	        this.searchString = '';
	        this.optionMaps = resetFilteredOptionMaps(this.optionMaps);
	        this.inputElement.value = '';
	      }
	    };
	    this.onFilterChange = (e) => {
	      this.searchString = e.target.value;
	      if (this.searchString.startsWith(' ')) {
	        this.resetFilter();
	      }
	      else {
	        this.optionMaps = setFilteredOptionMaps(this.optionMaps, this.searchString);
	      }
	      // in case input is focused via tab instead of click
	      this.setDropdownVisibility('show');
	    };
	    this.selectRef = undefined;
	    this.label = undefined;
	    this.description = undefined;
	    this.message = undefined;
	    this.state = undefined;
	    this.direction = 'auto';
	    this.theme = 'light';
	    this.filter = false;
	    this.required = false;
	    this.disabled = false;
	    this.onOpenChange = undefined;
	    this.isOpenOverride = false;
	    this.isOpen = this.isOpenOverride;
	    this.optionMaps = [];
	    this.searchString = '';
	  }
	  get selectedIndex() {
	    return this.selectRef.selectedIndex;
	  }
	  connectedCallback() {
	    throwIfRootNodeIsNotOneOfKind.throwIfRootNodeIsNotOneOfKind(this.host, ['p-select-wrapper']);
	    validateProps.observeChildren(this.selectRef, () => {
	      this.setOptionMaps();
	      this.observeOptions(); // new option might have been added
	    }, 
	    // unfortunately we can't observe hidden property of option elements via observeProperties
	    // therefore we do it here via attribute
	    ['hidden', 'disabled', 'selected']);
	  }
	  componentDidRender() {
	    if (this.isOpen) {
	      handleScroll(this.listElement, getHighlightedOptionMapIndex(this.optionMaps));
	    }
	  }
	  componentWillLoad() {
	    if (!isSsrHydration.isSsrHydration(this.host)) {
	      // when ssr rendered component is partially hydrated before being rerendered by its parent select-wrapper
	      // it has no select ref and options can't be accessed
	      this.observeProperties();
	      document.addEventListener('mousedown', this.onClickOutside, true);
	    }
	  }
	  disconnectedCallback() {
	    document.removeEventListener('mousedown', this.onClickOutside, true);
	    validateProps.unobserveChildren(this.host);
	  }
	  render() {
	    validateProps.attachComponentCss(this.host, getComponentCss, this.direction === 'auto'
	      ? selectDropdown.determineDropdownDirection(this.host, getAmountOfVisibleOptionsAndOptgroups(this.optionMaps))
	      : this.direction, this.isOpen, this.state, this.disabled, this.filter, this.theme);
	    const dropdownId = 'list';
	    const labelId = 'label';
	    const descriptionId = this.description && 'description';
	    const buttonId = 'value';
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    return (validateProps.h(validateProps.Host, null, this.filter ? ([
	      validateProps.h("input", { key: "input", type: "text", role: "combobox", disabled: this.disabled, placeholder: getSelectedOptionMap(this.optionMaps)?.value || null, autoComplete: "off", value: this.searchString, ...selectDropdown.getFilterInputAriaAttributes(this.isOpen, this.required, labelId, descriptionId, dropdownId, getHighlightedOptionMapIndex(this.optionMaps)), onKeyDown: this.onComboboxKeyDown, onInput: this.onFilterChange, onClick: () => this.setDropdownVisibility('show'), ref: (el) => (this.inputElement = el) }),
	      validateProps.h("span", { key: "span", onClick: this.disabled ? undefined : () => this.setDropdownVisibility('toggle') }),
	    ]) : (validateProps.h("button", { type: "button", role: "combobox", id: buttonId, disabled: this.disabled, ...selectDropdown.getSelectDropdownButtonAriaAttributes(this.isOpen, labelId, descriptionId, dropdownId, getHighlightedOptionMapIndex(this.optionMaps)), onClick: () => this.setDropdownVisibility('toggle'), onKeyDown: this.onComboboxKeyDown })), [
	      validateProps.h("div", { class: "sr-text", id: labelId }, getSelectedOptionMap(this.optionMaps)?.value, ", ", this.label, !!this.message && `. ${this.message}`),
	      this.description && (validateProps.h("div", { class: "sr-text", id: descriptionId }, this.description)),
	      this.isOpen && (validateProps.h("ul", { id: dropdownId, role: "listbox", tabIndex: -1, ...selectDropdown.getListAriaAttributes(this.label, this.required, this.filter, this.isOpen), ref: (el) => (this.listElement = el) }, this.filter && !hasFilterResults(this.optionMaps) ? (validateProps.h("li", { class: "option", "aria-live": "polite", role: "status" }, validateProps.h("span", { "aria-hidden": "true" }, "---"), validateProps.h("span", { class: "option__sr" }, "No results found"))) : (this.optionMaps.map((option, index) => {
	        const { value, disabled, hidden, initiallyHidden, selected, highlighted, title } = option;
	        return [
	          title && (validateProps.h("span", { class: "optgroup", role: "presentation" }, title)),
	          validateProps.h("li", { id: `option-${index}`, role: "option", class: {
	              option: true,
	              'option--selected': selected,
	              'option--highlighted': highlighted,
	              'option--disabled': disabled,
	              'option--hidden': hidden || initiallyHidden,
	            }, onClick: !selected && !disabled ? () => this.setOptionSelected(index) : undefined, ...selectDropdown.getOptionAriaAttributes(selected, disabled, hidden, !!value) }, value, selected && !disabled && (validateProps.h(PrefixedTagNames.pIcon, { "aria-hidden": "true", name: "check", color: disabled ? 'state-disabled' : 'primary', theme: this.theme }))),
	        ];
	      })))),
	    ]));
	  }
	  observeProperties() {
	    this.setOptionMaps(); // initial
	    this.observeOptions(); // initial
	    propertyObserver.observeProperties(this.selectRef, ['value', 'selectedIndex'], this.syncSelectedIndex);
	  }
	  observeOptions() {
	    getOptionsElements(this.selectRef).forEach((el) => propertyObserver.observeProperties(el, ['selected', 'disabled'], this.setOptionMaps));
	  }
	  cycleDropdown(direction) {
	    this.setDropdownVisibility('show');
	    const newIndex = getNewOptionMapIndex(this.optionMaps, direction);
	    this.optionMaps = setHighlightedOptionMaps(this.optionMaps, newIndex);
	  }
	  get host() { return validateProps.getElement(this); }
	};

	pSelectWrapper_2_cjs_entry.p_select_wrapper = SelectWrapper;
	pSelectWrapper_2_cjs_entry.p_select_wrapper_dropdown = SelectWrapperDropdown;

	
	return pSelectWrapper_2_cjs_entry;
}

var pSpinner_cjs_entry = {};

var hasRequiredPSpinner_cjs_entry;

function requirePSpinner_cjs_entry () {
	if (hasRequiredPSpinner_cjs_entry) return pSpinner_cjs_entry;
	hasRequiredPSpinner_cjs_entry = 1;

	Object.defineProperty(pSpinner_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const isThemeAuto = requireIsThemeAutoC90cd35d();

	const SPINNER_SIZES = ['small', 'medium', 'large', 'inherit'];
	const SPINNER_ARIA_ATTRIBUTES = ['aria-label'];

	const sizeSmall = '48px';
	const sizeMedium = '72px';
	const sizeLarge = '104px';
	const sizeMap = {
	  small: { height: sizeSmall, width: sizeSmall },
	  medium: { height: sizeMedium, width: sizeMedium },
	  large: { height: sizeLarge, width: sizeLarge },
	  inherit: { height: 'inherit', width: 'inherit' },
	};
	const getComponentCss = (size, theme) => {
	  const strokeDasharray = '57'; // C = 2πR
	  const animationDuration = 'var(--p-animation-duration, 2s)';
	  const { primaryColor, contrastMediumColor } = validateProps.getThemedColors(theme);
	  const { primaryColor: primaryColorDark, contrastMediumColor: contrastMediumColorDark } = validateProps.getThemedColors('dark');
	  const { canvasColor, canvasTextColor } = validateProps.getHighContrastColors();
	  return validateProps.getCss({
	    '@global': {
	      ':host': validateProps.addImportantToEachRule({
	        display: 'inline-flex',
	        verticalAlign: 'top',
	        ...colorSchemeStyles.colorSchemeStyles,
	        ...colorSchemeStyles.hostHiddenStyles,
	      }),
	      svg: {
	        display: 'block',
	        position: 'relative',
	        fill: 'none',
	        transform: 'translate3d(0,0,0)',
	        animation: `$rotate ${animationDuration} linear infinite`,
	      },
	      circle: {
	        '&:first-child': {
	          // TODO: High Contrast Mode should be handled within a local color helper function
	          stroke: validateProps.isHighContrastMode ? canvasTextColor : contrastMediumColor,
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	            stroke: validateProps.isHighContrastMode ? canvasTextColor : contrastMediumColorDark,
	          }),
	          animation: `$rotate ${animationDuration} linear infinite`, // needs to rotate to eliminate stutter in safari
	        },
	        '&:last-child': {
	          transformOrigin: '0 0',
	          animation: `$dash ${animationDuration} ease-in-out infinite`,
	          // TODO: High Contrast Mode should be handled within a local color helper function
	          stroke: validateProps.isHighContrastMode ? canvasColor : primaryColor,
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	            stroke: validateProps.isHighContrastMode ? canvasColor : primaryColorDark,
	          }),
	          strokeDasharray: strokeDasharray
	            ,
	          strokeLinecap: 'round',
	        },
	      },
	      '@keyframes rotate': {
	        '0%': {
	          transform: 'rotateZ(0deg)',
	        },
	        '100%': {
	          transform: 'rotateZ(360deg)',
	        },
	      },
	      '@keyframes dash': {
	        '0%': {
	          strokeDashoffset: 57,
	          transform: 'rotateZ(0)',
	        },
	        '50%, 75%': {
	          strokeDashoffset: 20,
	          transform: 'rotateZ(80deg)',
	        },
	        '100%': {
	          strokeDashoffset: 57,
	          transform: 'rotateZ(360deg)',
	        },
	      },
	    },
	    root: {
	      display: 'block',
	      ...validateProps.buildResponsiveStyles(size, (s) => sizeMap[s]),
	      margin: 0,
	      padding: 0,
	      boxSizing: 'border-box',
	      strokeWidth: 1.5,
	    },
	    'sr-only': validateProps.getHiddenTextJssStyle(),
	  });
	};

	const propTypes = {
	  size: validateProps.AllowedTypes.breakpoint(SPINNER_SIZES),
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	  aria: validateProps.AllowedTypes.aria(SPINNER_ARIA_ATTRIBUTES),
	};
	const Spinner = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.size = 'small';
	    this.theme = 'light';
	    this.aria = undefined;
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    validateProps.attachComponentCss(this.host, getComponentCss, this.size, this.theme);
	    return (validateProps.h("span", { class: "root", role: "alert", "aria-live": "assertive", ...validateProps.parseAndGetAriaAttributes(this.aria) }, validateProps.h("span", { class: "sr-only" }, "\u00A0"), validateProps.h("svg", { viewBox: "-16 -16 32 32", width: "100%", height: "100%", focusable: "false", "aria-hidden": "true" }, validateProps.h("circle", { r: "9" }), validateProps.h("circle", { r: "9" }))));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	pSpinner_cjs_entry.p_spinner = Spinner;

	
	return pSpinner_cjs_entry;
}

var pStepperHorizontal_2_cjs_entry = {};

var hasRequiredPStepperHorizontal_2_cjs_entry;

function requirePStepperHorizontal_2_cjs_entry () {
	if (hasRequiredPStepperHorizontal_2_cjs_entry) return pStepperHorizontal_2_cjs_entry;
	hasRequiredPStepperHorizontal_2_cjs_entry = 1;

	Object.defineProperty(pStepperHorizontal_2_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const scrolling = requireScrollingC37f1aeb();
	const theme = requireThemeBfc10573();
	const throwIfChildrenAreNotOfKind = requireThrowIfChildrenAreNotOfKind39ea431a();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const fontSizeText = requireFontSizeText728b6387();
	const getClickedItem = requireGetClickedItemE7e5ae2c();
	const throwIfParentIsNotOfKind = requireThrowIfParentIsNotOfKind99386afd();
	const hoverMediaQuery = requireHoverMediaQueryF2ccfc24();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const escapeHashCharacter = requireEscapeHashCharacter072604c4();
	const spacingFluidXSmall = requireSpacingFluidXSmall0dd753ae();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const fontLineHeight = requireFontLineHeight78b03658();
	requireGetHTMLElements21fc87cc();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireFontSizeTextXXSmallA02f9c40();
	requireFontSizeTextXSmallE59d35d7();
	requireFontSizeTextMedium88887ad8();
	requireFontSizeTextLarge05a4bc90();
	requireFontSizeTextXLarge0ecf9ef3();
	requireIsParentOfKindA9c351f2();

	const throwIfChildCountIsExceeded = (element, allowedAmount) => {
	  const childCount = element.children.length;
	  if (childCount > allowedAmount) {
	    validateProps.throwException(`only ${allowedAmount} children are allowed in ${validateProps.getTagNameWithoutPrefix(element)} but got ${childCount}.`);
	  }
	};

	const getComponentCss$1 = (size) => {
	  return validateProps.getCss({
	    '@global': {
	      ':host': {
	        display: 'block',
	        ...validateProps.addImportantToEachRule({
	          ...colorSchemeStyles.colorSchemeStyles,
	          ...colorSchemeStyles.hostHiddenStyles,
	        }),
	      },
	    },
	    scroller: {
	      ...textSmallStyle.textSmallStyle,
	      ...validateProps.buildResponsiveStyles(size, (s) => ({ fontSize: fontSizeText.fontSizeText[s] })),
	    },
	  });
	};

	const STEPPER_HORIZONTAL_SIZES = ['small', 'medium'];
	const getIndexOfStepWithStateCurrent = (stepperHorizontalItems) => {
	  return stepperHorizontalItems.findIndex((item) => item.state === 'current');
	};
	const throwIfMultipleCurrentStates = (host, stepperHorizontalItems) => {
	  const currentStateCount = stepperHorizontalItems.filter((item) => item.state === 'current').length;
	  if (currentStateCount > 1) {
	    validateProps.throwException(`only one child with current state is allowed in ${validateProps.getTagNameWithoutPrefix(host)} but got ${currentStateCount}.`);
	  }
	};
	const syncStepperHorizontalItemsProps = (host, theme) => {
	  Array.from(host.children).forEach((item) => {
	    item.theme = theme;
	    validateProps.forceUpdate(item);
	  });
	};

	const propTypes$1 = {
	  size: validateProps.AllowedTypes.breakpoint(STEPPER_HORIZONTAL_SIZES),
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const StepperHorizontal = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.stepChange = validateProps.createEvent(this, "stepChange", 3);
	    this.update = validateProps.createEvent(this, "update", 3);
	    this.stepperHorizontalItems = [];
	    this.onClickScroller = (e) => {
	      const target = getClickedItem.getClickedItem(this.host, 'p-stepper-horizontal-item', e.composedPath());
	      if (target) {
	        const clickedStepIndex = this.stepperHorizontalItems.indexOf(target);
	        this.update.emit({ activeStepIndex: clickedStepIndex });
	        this.stepChange.emit({ activeStepIndex: clickedStepIndex });
	      }
	    };
	    this.validateComponent = () => {
	      throwIfChildrenAreNotOfKind.throwIfChildrenAreNotOfKind(this.host, 'p-stepper-horizontal-item');
	      throwIfChildCountIsExceeded(this.host, 9);
	      this.stepperHorizontalItems = Array.from(this.host.children);
	      throwIfMultipleCurrentStates(this.host, this.stepperHorizontalItems);
	    };
	    this.scrollIntoView = () => {
	      const newStepIndex = getIndexOfStepWithStateCurrent(this.stepperHorizontalItems);
	      // If state is set to undefined index is -1
	      if (newStepIndex !== -1) {
	        const scrollActivePosition = scrolling.getScrollActivePosition(this.stepperHorizontalItems, newStepIndex > this.currentStepIndex ? 'next' : 'prev', newStepIndex, this.scrollerElement);
	        this.currentStepIndex = newStepIndex;
	        this.scrollerElement.scrollToPosition = {
	          scrollPosition: scrollActivePosition,
	          isSmooth: true,
	        };
	      }
	    };
	    this.observeBreakpointChange = () => {
	      if (typeof validateProps.parseJSON(this.size) === 'object') {
	        validateProps.observeBreakpointChange(this.host, this.scrollIntoView);
	      }
	    };
	    this.onSlotChange = () => {
	      this.validateComponent();
	      this.currentStepIndex = getIndexOfStepWithStateCurrent(this.stepperHorizontalItems);
	      this.scrollIntoView();
	    };
	    this.size = 'small';
	    this.theme = 'light';
	  }
	  connectedCallback() {
	    this.validateComponent(); // on every reconnect
	    this.observeBreakpointChange();
	  }
	  componentWillLoad() {
	    // Initial validation
	    this.validateComponent();
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  componentDidLoad() {
	    this.currentStepIndex = getIndexOfStepWithStateCurrent(this.stepperHorizontalItems);
	    this.observeBreakpointChange();
	    // Sometimes lifecycle gets called after disconnectedCallback()
	    if (this.scrollerElement) {
	      // Initial scroll current into view
	      this.scrollerElement.scrollToPosition = {
	        scrollPosition: scrolling.getScrollActivePosition(this.stepperHorizontalItems, 'next', this.currentStepIndex, this.scrollerElement),
	        isSmooth: false,
	      };
	    }
	    // TODO: would be great to use this in jsx but that doesn't work reliable and causes jsdom-polyfill unit test to fail
	    validateProps.getShadowRootHTMLElement(this.host, 'slot').addEventListener('slotchange', this.onSlotChange);
	  }
	  componentDidUpdate() {
	    throwIfMultipleCurrentStates(this.host, this.stepperHorizontalItems);
	    this.scrollIntoView();
	  }
	  disconnectedCallback() {
	    validateProps.unobserveBreakpointChange(this.host);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes$1);
	    validateProps.attachComponentCss(this.host, getComponentCss$1, this.size);
	    syncStepperHorizontalItemsProps(this.host, this.theme);
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    return (validateProps.h(validateProps.Host, null, validateProps.h(PrefixedTagNames.pScroller, { class: "scroller", aria: { role: 'list' }, theme: this.theme, onClick: this.onClickScroller, ref: (el) => (this.scrollerElement = el) }, validateProps.h("slot", null))));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	const STEPPER_ITEM_STATES = ['current', 'complete', 'warning'];
	const isStateCompleteOrWarning = (state) => {
	  return state === 'complete' || state === 'warning';
	};
	const getStepperHorizontalIconName = (state) => {
	  return state === 'complete' ? 'success' : 'warning';
	};
	const throwIfCurrentAndDisabled = (host) => {
	  if (host.state === 'current' &&
	    host.disabled) {
	    validateProps.throwException(`using state='current' and disabled='true' for ${validateProps.getTagNameWithoutPrefix(host)} is not allowed.`);
	  }
	};
	const isItemClickable = (state, disabled) => {
	  return !!state && isStateCompleteOrWarning(state) && !disabled;
	};

	const getSVGPath = (stepCount, numberedCircleColors, isStateCurrent) => {
	  // # of the hexcolor starts a fragment identifier in URLs, so we have to replace it with the escaped value of # = %23
	  numberedCircleColors = Object.entries(numberedCircleColors).reduce((result, [key, value]) => ({ ...result, [key]: escapeHashCharacter.escapeHashCharacter(value) }), {});
	  const { disabledColor, invertedBaseColor, primaryColor } = numberedCircleColors;
	  const fillColor = isStateCurrent ? invertedBaseColor : disabledColor;
	  const svgCirclePath = `<circle fill="${isStateCurrent ? primaryColor : 'none'}"${isStateCurrent ? '' : ` stroke="${fillColor}"`} stroke-width="1px" cx="12" cy="12" r="9"/>`;
	  // Full SVG is provided by design (./numbers_raw.svg), created with illustrator and optimized with ImageOptim.
	  // The optimized file can be found in ./numbers_optim.svg.
	  // TODO: could certainly be optimized size wise by exporting icons larger and having less decimals
	  const svgNumberedCirclePaths = [
	    `${svgCirclePath}<path fill="${fillColor}" d="m12.33 8.67-2.43.91v-.94l2.6-1.03h.85v8.78h-1.02z"/>`,
	    `${svgCirclePath}<path fill="${fillColor}" d="m9.46 15.58c0-1.35.73-2.07 1.7-2.72l.95-.63c.78-.52 1.57-1.05 1.57-2.24 0-1.12-.62-1.58-1.7-1.58s-1.68.48-1.78 1.97h-.96c.06-1.82.78-2.91 2.74-2.91s2.72.92 2.72 2.52-.92 2.23-1.79 2.8l-.95.63c-1.11.75-1.52 1.18-1.52 2.01v.16h4.17v.81h-5.15v-.81z"/>`,
	    `${svgCirclePath}<path fill="${fillColor}" d="m10.1 13.73c.1 1.43.63 2 1.92 2 1.2 0 1.8-.49 1.8-1.68 0-1.08-.51-1.66-1.8-1.66h-.89v-.9h.83c1.12 0 1.66-.56 1.66-1.53 0-1.08-.64-1.55-1.73-1.55s-1.69.49-1.79 1.97h-.97c.1-1.79.84-2.91 2.76-2.91s2.74.92 2.74 2.49c0 .79-.38 1.54-1.16 1.9.84.28 1.36.92 1.36 2.19 0 1.54-.97 2.49-2.81 2.49-1.96 0-2.8-.9-2.88-2.81z"/>`,
	    `${svgCirclePath}<path fill="${fillColor}" d="m8.87 13.6 3.54-5.99h1.43v5.89h1.25v.86h-1.25v2.02h-.99v-2.02h-3.98zm3.98-.1v-4.98l-2.91 4.98z"/>`,
	    `${svgCirclePath}<path fill="${fillColor}" d="m9.34 12.45.42-4.83h4.71v.94h-3.9l-.26 2.95c.38-.43 1-.68 1.79-.68 1.86 0 2.76.9 2.76 2.81 0 2.06-1.03 2.91-2.86 2.91s-2.74-.84-2.81-2.51h.97c.06 1.13.57 1.7 1.84 1.7 1.39 0 1.85-.68 1.85-2.06s-.48-2-1.85-2c-1.07 0-1.54.42-1.75 1.17h-.91v-.39z"/>`,
	    `${svgCirclePath}<path fill="${fillColor}" d="m9.97 11.02 2.22-3.4h1.1l-2.27 3.44c.33-.16.69-.23 1.1-.23 1.84 0 2.76.9 2.76 2.81 0 2.06-1.04 2.91-2.86 2.91s-2.87-.85-2.87-2.91c0-1.08.3-1.8.83-2.61zm2.05 4.71c1.38 0 1.84-.68 1.84-2.05s-.47-2.01-1.84-2.01-1.85.64-1.85 2.01.46 2.05 1.85 2.05z"/>`,
	    `${svgCirclePath}<path fill="${fillColor}" d="m9.21 7.61h5.57v.74l-3.58 8.04h-1.05l3.54-7.84h-4.49v-.94z"/>`,
	    `${svgCirclePath}<path fill="${fillColor}" d="m10.47 11.94c-.65-.33-1.13-.92-1.13-2.01 0-1.53.85-2.47 2.66-2.47s2.66.94 2.66 2.47c0 1.08-.47 1.68-1.15 2.01.92.35 1.34 1.07 1.34 2.11 0 1.73-.99 2.49-2.86 2.49s-2.86-.76-2.86-2.49c0-1.04.41-1.76 1.33-2.11zm1.53 3.78c1.27 0 1.85-.51 1.85-1.69 0-1.1-.58-1.61-1.85-1.61s-1.85.52-1.85 1.61c0 1.18.58 1.69 1.85 1.69zm1.65-5.76c0-1.1-.56-1.56-1.65-1.56s-1.65.47-1.65 1.56c0 1 .46 1.6 1.65 1.6s1.65-.6 1.65-1.6z"/>`,
	    `${svgCirclePath}<path fill="${fillColor}" d="m9.16 10.33c0-2.03 1.02-2.86 2.83-2.86s2.82.81 2.82 2.85c0 1.11-.3 1.82-.81 2.64l-2.18 3.44h-1.1l2.18-3.37c-.31.14-.65.2-1.01.2-1.82 0-2.74-.99-2.74-2.9zm4.65 0c0-1.23-.47-1.92-1.81-1.92s-1.81.69-1.81 1.92c0 1.37.49 2.05 1.81 2.05s1.81-.68 1.81-2.05z"/>`,
	  ];
	  return svgNumberedCirclePaths[stepCount];
	};
	const getComponentCss = (state, disabled, theme) => {
	  const { primaryColor, hoverColor, disabledColor, focusColor } = validateProps.getThemedColors(theme);
	  const { primaryColor: primaryColorDark, hoverColor: hoverColorDark, disabledColor: disabledColorDark, focusColor: focusColorDark, } = validateProps.getThemedColors('dark');
	  const isStateCurrent = state === 'current';
	  const isStateCurrentOrUndefined = !state || isStateCurrent;
	  const isDisabled = !state || disabled;
	  return validateProps.getCss({
	    '@global': {
	      ':host': {
	        ...(isStateCurrentOrUndefined &&
	          Array.from(Array(9)).reduce((result, _, i) => ({
	            ...result,
	            [`&(:nth-of-type(${i + 1})) $button::before`]: {
	              backgroundImage: escapeHashCharacter.getInlineSVGBackgroundImage(getSVGPath(i, {
	                primaryColor,
	                invertedBaseColor: validateProps.getInvertedThemedColors(theme).primaryColor,
	                disabledColor,
	              }, isStateCurrent)),
	              ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	                backgroundImage: escapeHashCharacter.getInlineSVGBackgroundImage(getSVGPath(i, {
	                  primaryColor: primaryColorDark,
	                  invertedBaseColor: validateProps.getInvertedThemedColors('dark').primaryColor,
	                  disabledColor: disabledColorDark,
	                }, isStateCurrent)),
	              }),
	            },
	          }), {})),
	        ...validateProps.addImportantToEachRule({
	          fontSize: 'inherit',
	          ...colorSchemeStyles.hostHiddenStyles,
	          '&(:not(:last-of-type))': {
	            margin: `0 ${spacingFluidXSmall.spacingFluidXSmall} 0 0`,
	          },
	        }),
	      },
	      button: {
	        display: 'flex',
	        position: 'relative',
	        gap: '3px',
	        color: isDisabled ? disabledColor : primaryColor,
	        padding: '4px 10px 4px 6px',
	        background: 0,
	        border: 0,
	        outline: 0,
	        ...textSmallStyle.textSmallStyle,
	        fontSize: 'inherit',
	        width: 'max-content',
	        cursor: isDisabled ? 'not-allowed' : 'pointer',
	        borderRadius: borderRadiusSmall.borderRadiusSmall,
	        ...(isStateCurrent && {
	          ...validateProps.frostedGlassStyle,
	          background: hoverColor,
	        }),
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          color: isDisabled ? disabledColorDark : primaryColorDark,
	          ...(isStateCurrent && {
	            background: hoverColorDark,
	          }),
	        }),
	        ...(!isDisabled &&
	          hoverMediaQuery.hoverMediaQuery({
	            transition: validateProps.getTransition('background-color'),
	            '&:hover': {
	              ...validateProps.frostedGlassStyle,
	              background: hoverColor,
	              ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	                background: hoverColorDark,
	              }),
	            },
	          })),
	        ...(isStateCurrentOrUndefined && {
	          // counter
	          // Pseudo element is needed to center the counter to the text, as it is not working optimal directly on the button
	          '&::before': {
	            content: '""',
	            height: fontLineHeight.fontLineHeight,
	            width: fontLineHeight.fontLineHeight,
	          },
	        }),
	        '&:focus::after': {
	          content: '""',
	          position: 'absolute',
	          ...validateProps.getInsetJssStyle(),
	          border: `${validateProps.borderWidthBase} solid ${focusColor}`,
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	            borderColor: focusColorDark,
	          }),
	          borderRadius: borderRadiusSmall.borderRadiusSmall,
	        },
	        '&:focus:not(:focus-visible)::after': {
	          borderColor: 'transparent',
	        },
	      },
	    },
	    ...(!isStateCurrentOrUndefined && {
	      // complete / warning icons via icon component
	      icon: {
	        height: fontLineHeight.fontLineHeight,
	        width: fontLineHeight.fontLineHeight,
	      },
	    }),
	    'sr-only': validateProps.getHiddenTextJssStyle(),
	  });
	};

	const propTypes = {
	  state: validateProps.AllowedTypes.oneOf([undefined, ...STEPPER_ITEM_STATES]),
	  disabled: validateProps.AllowedTypes.boolean,
	};
	const StepperHorizontalItem = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.state = undefined;
	    this.disabled = false;
	  }
	  onClick(e) {
	    if (!isItemClickable(this.state, this.disabled)) {
	      e.stopPropagation();
	    }
	  }
	  onStateChange() {
	    throwIfChildrenAreNotOfKind.updateParent(this.host);
	  }
	  connectedCallback() {
	    throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-stepper-horizontal');
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    throwIfCurrentAndDisabled(this.host);
	    validateProps.attachComponentCss(this.host, getComponentCss, this.state, this.disabled, this.host.theme || 'light');
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    return (validateProps.h(validateProps.Host, { role: "listitem" }, validateProps.h("button", { type: "button", "aria-disabled": !this.state || this.disabled ? 'true' : null, "aria-current": this.state === 'current' ? 'step' : null }, isStateCompleteOrWarning(this.state) && (validateProps.h(PrefixedTagNames.pIcon, { class: "icon", name: getStepperHorizontalIconName(this.state), size: "inherit", theme: this.host.theme || 'light', color: this.disabled ? 'state-disabled' : `notification-${getStepperHorizontalIconName(this.state)}`, "aria-hidden": "true" })), this.state && validateProps.h("span", { class: "sr-only" }, this.state, ": "), validateProps.h("slot", null))));
	  }
	  static get delegatesFocus() { return true; }
	  get host() { return validateProps.getElement(this); }
	  static get watchers() { return {
	    "state": ["onStateChange"]
	  }; }
	};

	pStepperHorizontal_2_cjs_entry.p_stepper_horizontal = StepperHorizontal;
	pStepperHorizontal_2_cjs_entry.p_stepper_horizontal_item = StepperHorizontalItem;

	
	return pStepperHorizontal_2_cjs_entry;
}

var pSwitch_cjs_entry = {};

var hasRequiredPSwitch_cjs_entry;

function requirePSwitch_cjs_entry () {
	if (hasRequiredPSwitch_cjs_entry) return pSwitch_cjs_entry;
	hasRequiredPSwitch_cjs_entry = 1;

	Object.defineProperty(pSwitch_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const isDisabledOrLoading = requireIsDisabledOrLoadingAd97a497();
	const buttonHandling = requireButtonHandlingA110f521();
	const theme = requireThemeBfc10573();
	const alignLabel = requireAlignLabelFc1cc093();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const hoverMediaQuery = requireHoverMediaQueryF2ccfc24();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const getButtonBaseAriaAttributes = requireGetButtonBaseAriaAttributes51363b44();
	requireGetClosestHTMLElement0135bfd9();
	requireTextShared9135e2ef();
	requireFontLineHeight78b03658();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();

	const getColors = (checked, disabled, loading, theme) => {
	  const { primaryColor, contrastMediumColor, successColor, successColorDarken, disabledColor } = validateProps.getThemedColors(theme);
	  const { backgroundColor: lightThemeBackgroundColor } = validateProps.getThemedColors('light');
	  const { canvasColor, canvasTextColor } = validateProps.getHighContrastColors();
	  const checkedColor = validateProps.isHighContrastMode ? canvasTextColor : successColor;
	  const disabledOrLoadingColor = isDisabledOrLoading.isDisabledOrLoading(disabled, loading) && disabledColor;
	  return {
	    buttonBorderColor: disabledOrLoadingColor || (checked ? checkedColor : contrastMediumColor),
	    buttonBorderColorHover: checked ? (validateProps.isHighContrastMode ? primaryColor : successColorDarken) : primaryColor,
	    buttonBackgroundColor: checked ? disabledOrLoadingColor || checkedColor : 'transparent',
	    buttonBackgroundColorHover: checked ? (validateProps.isHighContrastMode ? checkedColor : successColorDarken) : 'transparent',
	    toggleBackgroundColor: (loading && 'transparent') ||
	      (disabled && !checked && disabledColor) ||
	      (checked
	        ? validateProps.isHighContrastMode
	          ? canvasColor
	          : lightThemeBackgroundColor
	        : validateProps.isHighContrastMode
	          ? canvasTextColor
	          : primaryColor),
	    toggleBackgroundColorHover: checked
	      ? lightThemeBackgroundColor
	      : validateProps.isHighContrastMode
	        ? canvasTextColor
	        : primaryColor,
	    textColor: disabledOrLoadingColor || primaryColor,
	  };
	};
	const getComponentCss = (alignLabel, hideLabel, stretch, checked, disabled, loading, theme) => {
	  const { buttonBorderColor, buttonBorderColorHover, buttonBackgroundColor, buttonBackgroundColorHover, toggleBackgroundColor, toggleBackgroundColorHover, textColor, } = getColors(checked, disabled, loading, theme);
	  const { buttonBorderColor: buttonBorderColorDark, buttonBorderColorHover: buttonBorderColorHoverDark, buttonBackgroundColor: buttonBackgroundColorDark, buttonBackgroundColorHover: buttonBackgroundColorHoverDark, toggleBackgroundColor: toggleBackgroundColorDark, toggleBackgroundColorHover: toggleBackgroundColorHoverDark, textColor: textColorDark, } = getColors(checked, disabled, loading, 'dark');
	  const { focusColor } = validateProps.getThemedColors(theme);
	  const { focusColor: focusColorDark } = validateProps.getThemedColors('dark');
	  return validateProps.getCss({
	    '@global': {
	      ':host': validateProps.addImportantToEachRule({
	        outline: 0,
	        ...colorSchemeStyles.colorSchemeStyles,
	        ...colorSchemeStyles.hostHiddenStyles,
	        ...validateProps.buildResponsiveStyles(stretch, (stretchValue) => ({
	          display: stretchValue ? 'block' : 'inline-block',
	          width: stretchValue ? '100%' : 'auto',
	          ...(!stretchValue && { verticalAlign: 'top' }),
	        })),
	      }),
	    },
	    root: {
	      display: 'flex',
	      alignItems: 'flex-start',
	      gap: spacingStaticSmall.spacingStaticSmall,
	      width: '100%',
	      padding: 0,
	      outline: 0,
	      border: 0,
	      textAlign: 'left',
	      background: 'transparent',
	      appearance: 'none',
	      cursor: isDisabledOrLoading.isDisabledOrLoading(disabled, loading) ? 'auto' : 'pointer',
	      ...validateProps.buildResponsiveStyles(stretch, (stretchValue) => ({
	        justifyContent: stretchValue ? 'space-between' : 'flex-start',
	      })),
	      ...(!isDisabledOrLoading.isDisabledOrLoading(disabled, loading) &&
	        hoverMediaQuery.hoverMediaQuery({
	          '&:hover .switch': {
	            borderColor: buttonBorderColorHover,
	            backgroundColor: buttonBackgroundColorHover,
	            ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	              borderColor: buttonBorderColorHoverDark,
	              backgroundColor: buttonBackgroundColorHoverDark,
	            }),
	            '& .toggle': {
	              backgroundColor: toggleBackgroundColorHover,
	              ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	                backgroundColor: toggleBackgroundColorHoverDark,
	              }),
	            },
	          },
	        })),
	      '&:focus .switch::before': {
	        content: '""',
	        position: 'absolute',
	        ...validateProps.getInsetJssStyle(-6),
	        border: `${validateProps.borderWidthBase} solid ${focusColor}`,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          borderColor: focusColorDark,
	        }),
	        borderRadius: '18px',
	      },
	      '&:not(:focus-visible) .switch::before': {
	        borderColor: 'transparent',
	      },
	    },
	    switch: {
	      position: 'relative',
	      width: '48px',
	      height: '28px',
	      flexShrink: 0,
	      boxSizing: 'border-box',
	      border: `${validateProps.borderWidthBase} solid ${buttonBorderColor}`,
	      borderRadius: '14px',
	      backgroundColor: buttonBackgroundColor,
	      cursor: isDisabledOrLoading.isDisabledOrLoading(disabled, loading) ? 'not-allowed' : 'pointer',
	      transition: `${validateProps.getTransition('background-color')},${validateProps.getTransition('border-color')},${validateProps.getTransition('color')}`,
	      ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	        borderColor: buttonBorderColorDark,
	        backgroundColor: buttonBackgroundColorDark,
	      }),
	    },
	    toggle: {
	      position: 'absolute',
	      top: '2px',
	      left: '2px',
	      width: '20px',
	      height: '20px',
	      display: 'block',
	      borderRadius: '50%',
	      backgroundColor: toggleBackgroundColor,
	      ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	        backgroundColor: toggleBackgroundColorDark,
	      }),
	      transform: `translate3d(${checked ? '20px' : '0'}, 0, 0)`,
	      transition: `${validateProps.getTransition('background-color')},${validateProps.getTransition('transform')}`,
	    },
	    ...(loading && {
	      spinner: {
	        position: 'absolute',
	        top: '-4px',
	        left: '-4px',
	        width: '28px',
	        height: '28px',
	      },
	    }),
	    label: {
	      ...textSmallStyle.textSmallStyle,
	      paddingTop: '2px',
	      minWidth: 0,
	      minHeight: 0,
	      color: textColor,
	      ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	        color: textColorDark,
	      }),
	      ...validateProps.mergeDeep(validateProps.buildResponsiveStyles(alignLabel, (alignLabelValue) => ({
	        order: alignLabelValue === 'left' ? -1 : 0,
	      })), validateProps.buildResponsiveStyles(hideLabel, validateProps.getHiddenTextJssStyle)),
	    },
	  });
	};

	const getSwitchButtonAriaAttributes = (isDisabled, isLoading, isChecked) => {
	  return {
	    ...getButtonBaseAriaAttributes.getButtonBaseAriaAttributes(isDisabled, isLoading),
	    'aria-checked': isChecked ? 'true' : 'false',
	  };
	};

	const propTypes = {
	  alignLabel: validateProps.AllowedTypes.breakpoint(alignLabel.ALIGN_LABELS),
	  hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	  stretch: validateProps.AllowedTypes.breakpoint('boolean'),
	  checked: validateProps.AllowedTypes.boolean,
	  disabled: validateProps.AllowedTypes.boolean,
	  loading: validateProps.AllowedTypes.boolean,
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Switch = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.switchChange = validateProps.createEvent(this, "switchChange", 3);
	    this.update = validateProps.createEvent(this, "update", 3);
	    this.onSwitchClick = () => {
	      this.update.emit({ checked: !this.checked });
	      this.switchChange.emit({ checked: !this.checked });
	    };
	    this.alignLabel = 'right';
	    this.hideLabel = false;
	    this.stretch = false;
	    this.checked = false;
	    this.disabled = false;
	    this.loading = false;
	    this.theme = 'light';
	  }
	  onClick(e) {
	    if (isDisabledOrLoading.isDisabledOrLoading(this.disabled, this.loading)) {
	      e.stopPropagation();
	    }
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  componentDidLoad() {
	    buttonHandling.improveButtonHandlingForCustomElement(this.host, () => 'button', () => isDisabledOrLoading.isDisabledOrLoading(this.disabled, this.loading));
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    validateProps.attachComponentCss(this.host, getComponentCss, this.alignLabel, this.hideLabel, this.stretch, this.checked, this.disabled, this.loading, this.theme);
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    return (validateProps.h("button", { ...getSwitchButtonAriaAttributes(this.disabled, this.loading, this.checked), class: "root", type: "button", role: "switch", onClick: this.onSwitchClick }, validateProps.h("span", { class: "switch" }, validateProps.h("span", { class: "toggle" }, this.loading && (validateProps.h(PrefixedTagNames.pSpinner, { class: "spinner", size: "inherit", theme: this.theme, aria: { 'aria-label': 'Loading state' } })))), validateProps.h("span", { class: "label" }, validateProps.h("slot", null))));
	  }
	  static get delegatesFocus() { return true; }
	  get host() { return validateProps.getElement(this); }
	};

	pSwitch_cjs_entry.p_switch = Switch;

	
	return pSwitch_cjs_entry;
}

var pTable_7_cjs_entry = {};

var hasRequiredPTable_7_cjs_entry;

function requirePTable_7_cjs_entry () {
	if (hasRequiredPTable_7_cjs_entry) return pTable_7_cjs_entry;
	hasRequiredPTable_7_cjs_entry = 1;

	Object.defineProperty(pTable_7_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const hasNamedSlot = requireHasNamedSlot28c6bca1();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const schemedHighContrastMediaQuery = requireSchemedHighContrastMediaQuery5956ba22();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const spacingFluidMedium = requireSpacingFluidMedium88ab712b();
	const throwIfParentIsNotOfKind = requireThrowIfParentIsNotOfKind99386afd();
	const spacingFluidSmall = requireSpacingFluidSmall2c6caae7();
	const fontSizeTextXSmall = requireFontSizeTextXSmallE59d35d7();
	const fontLineHeight = requireFontLineHeight78b03658();
	const fontWeightSemiBold = requireFontWeightSemiBold4482c830();
	const getAttribute = requireGetAttribute4e18832c();
	const hasAttribute = requireHasAttribute868c282d();
	const hoverMediaQuery = requireHoverMediaQueryF2ccfc24();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	requireGetNamedSlotA433c432();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireIsParentOfKindA9c351f2();

	const throwIfElementHasAttribute = (el, name) => {
	  if (hasAttribute.hasAttribute(el, name)) {
	    validateProps.throwException(`attribute ${name}='${getAttribute.getAttribute(el, name)}' needs to be set as property.`);
	  }
	};

	const cssVariableTableHoverColor = '--p-internal-table-hover-color';
	const cssVariableTableBorderColor = '--p-internal-table-border-color';
	const cssVariableTableHeadCellIconFilter = '--p-internal-table-head-cell-icon-filter';
	const getComponentCss$6 = (theme) => {
	  const { primaryColor, hoverColor, contrastLowColor } = validateProps.doGetThemedColors(theme);
	  const { primaryColor: primaryColorDark, hoverColor: hoverColorDark, contrastLowColor: contrastLowColorDark, } = validateProps.doGetThemedColors('dark');
	  return validateProps.getCss({
	    '@global': {
	      ':host': validateProps.addImportantToEachRule({
	        display: 'block',
	        ...textSmallStyle.textSmallStyle,
	        color: primaryColor,
	        textAlign: 'left',
	        ...colorSchemeStyles.colorSchemeStyles,
	        ...colorSchemeStyles.hostHiddenStyles,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          color: primaryColorDark,
	        }),
	      }),
	      '::slotted(*)': validateProps.addImportantToEachRule({
	        [cssVariableTableHoverColor]: hoverColor,
	        [cssVariableTableBorderColor]: contrastLowColor,
	        [cssVariableTableHeadCellIconFilter]: validateProps.isThemeDark(theme) ? 'invert(100%)' : 'none',
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          [cssVariableTableHoverColor]: hoverColorDark,
	          [cssVariableTableBorderColor]: contrastLowColorDark,
	          [cssVariableTableHeadCellIconFilter]: 'invert(100%)',
	        }),
	        ...(validateProps.isHighContrastMode &&
	          schemedHighContrastMediaQuery.getSchemedHighContrastMediaQuery({
	            [cssVariableTableHeadCellIconFilter]: 'none',
	          }, {
	            [cssVariableTableHeadCellIconFilter]: 'invert(100%)',
	          })),
	      }),
	    },
	    caption: {
	      marginBottom: spacingFluidMedium.spacingFluidMedium,
	    },
	    table: {
	      display: 'table',
	      borderCollapse: 'collapse',
	      width: '100%',
	      whiteSpace: 'nowrap', // shouldn't be inherited for caption, that's why it's defined here
	    },
	  });
	};

	const warnIfCaptionIsMissing = (host, caption) => {
	  if (!caption && !hasNamedSlot.hasNamedSlot(host, 'caption')) {
	    validateProps.consoleWarn(`caption has to be set via property or named slot for component ${validateProps.getTagNameWithoutPrefix(host)} in order to ensure accessibility.`);
	  }
	};
	const SORT_EVENT_NAME = 'internalSortingChange';

	const propTypes$2 = {
	  caption: validateProps.AllowedTypes.string,
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Table = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.sortingChange = validateProps.createEvent(this, "sortingChange", 3);
	    this.update = validateProps.createEvent(this, "update", 3);
	    this.caption = undefined;
	    this.theme = 'light';
	  }
	  componentWillLoad() {
	    warnIfCaptionIsMissing(this.host, this.caption);
	    this.host.shadowRoot.addEventListener(SORT_EVENT_NAME, (e) => {
	      e.stopPropagation();
	      this.update.emit(e.detail);
	      this.sortingChange.emit(e.detail);
	    });
	  }
	  render() {
	    validateProps.validateProps(this, propTypes$2);
	    validateProps.attachComponentCss(this.host, getComponentCss$6, this.theme);
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    const hasSlottedCaption = hasNamedSlot.hasNamedSlot(this.host, 'caption');
	    const captionId = 'caption';
	    const tableAttr = this.caption
	      ? { 'aria-label': this.caption }
	      : hasSlottedCaption && { 'aria-labelledby': captionId };
	    return (validateProps.h(validateProps.Host, null, hasSlottedCaption && (validateProps.h("div", { id: captionId, class: "caption" }, validateProps.h("slot", { name: "caption" }))), validateProps.h(PrefixedTagNames.pScroller, { scrollbar: true, theme: this.theme }, validateProps.h("div", { class: "table", role: "table", ...tableAttr }, validateProps.h("slot", null)))));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	const getComponentCss$5 = () => {
	  return validateProps.getCss({
	    '@global': {
	      ':host': validateProps.addImportantToEachRule({
	        display: 'table-row-group',
	        ...colorSchemeStyles.hostHiddenStyles,
	      }),
	    },
	  });
	};

	const TableBody = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	  }
	  connectedCallback() {
	    throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-table');
	  }
	  render() {
	    validateProps.attachComponentCss(this.host, getComponentCss$5);
	    return (validateProps.h(validateProps.Host, { role: "rowgroup" }, validateProps.h("slot", null)));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	const getComponentCss$4 = (multiline) => {
	  return validateProps.getCss({
	    '@global': {
	      ':host': {
	        ...validateProps.addImportantToEachRule({
	          display: 'table-cell',
	          padding: spacingFluidSmall.spacingFluidSmall,
	          margin: 0,
	          whiteSpace: multiline ? 'normal' : 'nowrap',
	          ...colorSchemeStyles.hostHiddenStyles,
	        }),
	        verticalAlign: 'middle',
	      },
	    },
	  });
	};

	const propTypes$1 = {
	  multiline: validateProps.AllowedTypes.boolean,
	};
	const TableCell = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.multiline = false;
	  }
	  connectedCallback() {
	    throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-table-row');
	  }
	  render() {
	    validateProps.validateProps(this, propTypes$1);
	    validateProps.attachComponentCss(this.host, getComponentCss$4, this.multiline);
	    return (validateProps.h(validateProps.Host, { role: "cell" }, validateProps.h("slot", null)));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	const getComponentCss$3 = () => {
	  return validateProps.getCss({
	    '@global': {
	      ':host': validateProps.addImportantToEachRule({
	        display: 'table-header-group',
	        fontSize: fontSizeTextXSmall.fontSizeTextXSmall,
	        lineHeight: fontLineHeight.fontLineHeight,
	        fontWeight: fontWeightSemiBold.fontWeightSemiBold,
	        ...colorSchemeStyles.hostHiddenStyles,
	      }),
	    },
	  });
	};

	const TableHead = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	  }
	  connectedCallback() {
	    throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-table');
	  }
	  render() {
	    validateProps.attachComponentCss(this.host, getComponentCss$3);
	    return (validateProps.h(validateProps.Host, { role: "rowgroup" }, validateProps.h("slot", null)));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	const isDirectionAsc = (dir) => dir === 'asc';
	const getAriaSort = (sort) => {
	  return sort?.active ? (isDirectionAsc(sort.direction) ? 'ascending' : 'descending') : null;
	};
	const toggleDirection = (dir) => (isDirectionAsc(dir) ? 'desc' : 'asc');
	const createSortedEventInitDictDetail = (sort) => ({
	  bubbles: true,
	  detail: { ...sort, active: true, direction: sort.active ? toggleDirection(sort.direction) : sort.direction },
	});
	const isSortable = (active, direction) => {
	  return active !== undefined && direction !== undefined;
	};

	const { hoverColor, focusColor } = validateProps.getThemedColors('light'); // hover color and focus color are the same for light and dark
	const buttonBeforeOffsetVertical = '-2px';
	const buttonBeforeOffsetHorizontal = '-4px';
	const getComponentCss$2 = (active, direction, hideLabel, multiline) => {
	  const sortable = isSortable(active, direction);
	  return validateProps.getCss({
	    '@global': {
	      ':host': validateProps.addImportantToEachRule({
	        display: 'table-cell',
	        padding: `2px ${spacingFluidSmall.spacingFluidSmall} ${spacingFluidSmall.spacingFluidSmall}`,
	        verticalAlign: 'bottom',
	        whiteSpace: multiline ? 'normal' : 'nowrap',
	        ...colorSchemeStyles.hostHiddenStyles,
	      }),
	      ...(sortable
	        ? {
	          button: {
	            position: 'relative',
	            display: 'flex',
	            gap: spacingStaticXSmall.spacingStaticXSmall,
	            width: 'auto',
	            margin: 0,
	            padding: 0,
	            font: 'inherit',
	            color: 'inherit',
	            outline: 0,
	            alignItems: 'flex-end',
	            appearance: 'none',
	            background: 'transparent',
	            textAlign: 'left',
	            border: 0,
	            zIndex: 0,
	            cursor: 'pointer',
	            '&::before': {
	              content: '""',
	              position: 'absolute',
	              top: buttonBeforeOffsetVertical,
	              bottom: buttonBeforeOffsetVertical,
	              right: buttonBeforeOffsetHorizontal,
	              left: buttonBeforeOffsetHorizontal,
	              borderRadius: borderRadiusSmall.borderRadiusSmall,
	              zIndex: -1,
	              transition: validateProps.getTransition('background-color'),
	            },
	            ...hoverMediaQuery.hoverMediaQuery({
	              '&:hover, &:focus': {
	                '& .icon': {
	                  opacity: 1,
	                },
	              },
	              '&:hover::before': {
	                ...validateProps.frostedGlassStyle,
	                backgroundColor: hoverColor,
	              },
	            }),
	            '&:focus::before': {
	              border: `${validateProps.borderWidthBase} solid ${focusColor}`,
	            },
	            '&:not(:focus-visible)::before': {
	              border: 0,
	            },
	          },
	        }
	        : hideLabel && {
	          span: {
	            ...validateProps.getHiddenTextJssStyle(),
	            display: 'block',
	            border: 0,
	          },
	        }),
	    },
	    ...(sortable && {
	      icon: {
	        transition: validateProps.getTransition('opacity'),
	        opacity: active ? 1 : 0,
	        transform: `rotate3d(0,0,1,${isDirectionAsc(direction) ? 0 : 180}deg)`,
	        transformOrigin: '50% 50%',
	        filter: `var(${cssVariableTableHeadCellIconFilter})`,
	      },
	    }),
	  });
	};

	const propTypes = {
	  sort: validateProps.AllowedTypes.shape({
	    id: validateProps.AllowedTypes.string,
	    active: validateProps.AllowedTypes.boolean,
	    direction: validateProps.AllowedTypes.oneOf([undefined, 'asc', 'desc']),
	  }),
	  hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	  multiline: validateProps.AllowedTypes.boolean,
	};
	const TableHeadCell = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.onButtonClick = () => {
	      this.host.dispatchEvent(new CustomEvent(SORT_EVENT_NAME, createSortedEventInitDictDetail(this.sort)));
	    };
	    this.sort = undefined;
	    this.hideLabel = false;
	    this.multiline = false;
	  }
	  connectedCallback() {
	    throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-table-head-row');
	    throwIfElementHasAttribute(this.host, 'sort');
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    const { active, direction } = this.sort || {};
	    validateProps.attachComponentCss(this.host, getComponentCss$2, active, direction, this.hideLabel, this.multiline);
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    return (validateProps.h(validateProps.Host, { scope: "col", role: "columnheader", "aria-sort": getAriaSort(this.sort) }, isSortable(active, direction) ? (validateProps.h("button", { type: "button", onClick: this.onButtonClick }, validateProps.h("slot", null), validateProps.h(PrefixedTagNames.pIcon, { class: "icon", color: "inherit", size: "x-small", name: "arrow-up", "aria-hidden": "true" }))) : (validateProps.h("span", null, validateProps.h("slot", null)))));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	const getComponentCss$1 = () => {
	  return validateProps.getCss({
	    '@global': {
	      ':host': validateProps.addImportantToEachRule({
	        display: 'table-row',
	        ...colorSchemeStyles.hostHiddenStyles,
	      }),
	    },
	  });
	};

	const TableHeadRow = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	  }
	  connectedCallback() {
	    throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-table-head');
	  }
	  render() {
	    validateProps.attachComponentCss(this.host, getComponentCss$1);
	    return (validateProps.h(validateProps.Host, { role: "row" }, validateProps.h("slot", null)));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	const getComponentCss = () => {
	  return validateProps.getCss({
	    '@global': {
	      ':host': validateProps.addImportantToEachRule({
	        display: 'table-row',
	        borderTop: `1px solid var(${cssVariableTableBorderColor})`,
	        borderBottom: `1px solid var(${cssVariableTableBorderColor})`,
	        transition: validateProps.getTransition('background'),
	        ...colorSchemeStyles.hostHiddenStyles,
	        ...hoverMediaQuery.hoverMediaQuery({
	          '&(:hover)': {
	            // ...frostedGlassStyle, // will result in not smooth transition when applied
	            background: `var(${cssVariableTableHoverColor})`,
	          },
	        }),
	      }),
	    },
	  });
	};

	const TableRow = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	  }
	  connectedCallback() {
	    throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-table-body');
	  }
	  render() {
	    validateProps.attachComponentCss(this.host, getComponentCss);
	    return (validateProps.h(validateProps.Host, { role: "row" }, validateProps.h("slot", null)));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	pTable_7_cjs_entry.p_table = Table;
	pTable_7_cjs_entry.p_table_body = TableBody;
	pTable_7_cjs_entry.p_table_cell = TableCell;
	pTable_7_cjs_entry.p_table_head = TableHead;
	pTable_7_cjs_entry.p_table_head_cell = TableHeadCell;
	pTable_7_cjs_entry.p_table_head_row = TableHeadRow;
	pTable_7_cjs_entry.p_table_row = TableRow;

	
	return pTable_7_cjs_entry;
}

var pTabs_2_cjs_entry = {};

var tabsBarUtils7de019f3 = {};

var hasRequiredTabsBarUtils7de019f3;

function requireTabsBarUtils7de019f3 () {
	if (hasRequiredTabsBarUtils7de019f3) return tabsBarUtils7de019f3;
	hasRequiredTabsBarUtils7de019f3 = 1;

	const validateProps = requireValidatePropsC2afb75b();
	const getAttribute = requireGetAttribute4e18832c();

	const TABS_BAR_SIZES = ['small', 'medium'];
	/** @deprecated */
	const TABS_BAR_WEIGHTS_DEPRECATED = ['semibold'];
	const TABS_BAR_WEIGHTS = ['regular', 'semi-bold', ...TABS_BAR_WEIGHTS_DEPRECATED];
	const sanitizeActiveTabIndex = (index, tabElementsCount) => {
	  const maxIndex = tabElementsCount - 1; // can be -1 without children
	  if (index === undefined || index === null || maxIndex < 0 || index < 0 || index > maxIndex) {
	    return undefined;
	  }
	  else {
	    return index;
	  }
	};
	const getTransformation = (el = {}) => {
	  const rect = el.getBoundingClientRect();
	  return `transform: translate3d(${el.offsetLeft > 0 ? el.offsetLeft : 0}px,0,0);width: ${rect.width}px`;
	};
	const getPrevNextTabIndex = (direction, tabElementsLength, focusedTabIndex) => {
	  const newTabIndex = focusedTabIndex + (direction === 'next' ? 1 : -1);
	  return (newTabIndex + tabElementsLength) % tabElementsLength;
	};
	const getFocusedTabIndex = (tabElements) => {
	  const indexOfActiveElement = tabElements.indexOf(document.activeElement);
	  return indexOfActiveElement < 0 ? 0 : indexOfActiveElement;
	};
	const setBarStyle = (tabElements, activeTabIndex, barElement) => {
	  // in frameworks, when chunk is already loaded, the watcher for activeTabIndex can trigger
	  // before the component is rendered, therefore barElement is not defined, yet
	  if (barElement) {
	    // el.ariaSelected isn't supported in firefox, therefore we need to read the attribute
	    // https://caniuse.com/mdn-api_element_ariaselected
	    const currentActiveTabElement = tabElements.find((el) => getAttribute.getAttribute(el, 'aria-selected') === 'true' || getAttribute.getAttribute(el, 'aria-current') === 'true');
	    if (currentActiveTabElement) {
	      // for initial activeTabIndex > 0 and resized window with fluid font-size for size="medium"
	      // we need to adjust the starting point of the transition
	      validateProps.setAttribute(barElement, 'style', 'transition: none;' + getTransformation(currentActiveTabElement));
	    }
	    const newActiveTabElement = tabElements[activeTabIndex];
	    if (newActiveTabElement) {
	      validateProps.setAttribute(barElement, 'style', getTransformation(newActiveTabElement));
	    }
	    // when there was an active item before, we need to reset the animation
	    if (currentActiveTabElement) {
	      // reset animation that hides the bar after the transition
	      barElement.style.animation = 'none';
	      window.requestAnimationFrame(() => (barElement.style.animation = ''));
	    }
	  }
	};

	tabsBarUtils7de019f3.TABS_BAR_SIZES = TABS_BAR_SIZES;
	tabsBarUtils7de019f3.TABS_BAR_WEIGHTS = TABS_BAR_WEIGHTS;
	tabsBarUtils7de019f3.getFocusedTabIndex = getFocusedTabIndex;
	tabsBarUtils7de019f3.getPrevNextTabIndex = getPrevNextTabIndex;
	tabsBarUtils7de019f3.sanitizeActiveTabIndex = sanitizeActiveTabIndex;
	tabsBarUtils7de019f3.setBarStyle = setBarStyle;

	
	return tabsBarUtils7de019f3;
}

var hasRequiredPTabs_2_cjs_entry;

function requirePTabs_2_cjs_entry () {
	if (hasRequiredPTabs_2_cjs_entry) return pTabs_2_cjs_entry;
	hasRequiredPTabs_2_cjs_entry = 1;

	Object.defineProperty(pTabs_2_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed3a5c494c();
	const scrolling = requireScrollingC37f1aeb();
	const theme = requireThemeBfc10573();
	const throwIfChildrenAreNotOfKind = requireThrowIfChildrenAreNotOfKind39ea431a();
	const tabsBarUtils = requireTabsBarUtils7de019f3();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const throwIfParentIsNotOfKind = requireThrowIfParentIsNotOfKind99386afd();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	requireHelperE5c4e0db();
	requireGetHTMLElements21fc87cc();
	requireGetAttribute4e18832c();
	requireIsParentOfKindA9c351f2();

	const getComponentCss$1 = () => {
	  return validateProps.getCss({
	    '@global': {
	      ':host': {
	        display: 'block',
	        ...validateProps.addImportantToEachRule({
	          ...colorSchemeStyles.colorSchemeStyles,
	          ...colorSchemeStyles.hostHiddenStyles,
	        }),
	      },
	    },
	    root: {
	      marginBottom: '8px',
	    },
	  });
	};

	const syncTabsItemsProps = (items, theme) => {
	  items.forEach((item) => {
	    item.theme = theme;
	    validateProps.forceUpdate(item);
	  });
	};

	const propTypes$1 = {
	  size: validateProps.AllowedTypes.breakpoint(tabsBarUtils.TABS_BAR_SIZES),
	  weight: validateProps.AllowedTypes.oneOf(tabsBarUtils.TABS_BAR_WEIGHTS),
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	  gradientColorScheme: validateProps.AllowedTypes.oneOf([undefined, ...scrolling.GRADIENT_COLOR_SCHEMES]),
	  gradientColor: validateProps.AllowedTypes.oneOf(scrolling.GRADIENT_COLORS),
	  activeTabIndex: validateProps.AllowedTypes.number,
	};
	const Tabs = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.tabChange = validateProps.createEvent(this, "tabChange", 3);
	    this.update = validateProps.createEvent(this, "update", 3);
	    this.defineTabsItemElements = () => {
	      throwIfChildrenAreNotOfKind.throwIfChildrenAreNotOfKind(this.host, 'p-tabs-item');
	      this.tabsItemElements = Array.from(this.host.children);
	    };
	    this.setAccessibilityAttributes = () => {
	      for (const [index, tab] of Object.entries(this.tabsItemElements)) {
	        const attrs = {
	          role: 'tabpanel',
	          'aria-label': tab.label,
	        };
	        for (const [key, value] of Object.entries(attrs)) {
	          validateProps.setAttribute(tab, key, value);
	        }
	        if (+index === this.activeTabIndex) {
	          validateProps.removeAttribute(tab, 'hidden');
	          validateProps.setAttribute(tab, 'tabindex', '0');
	        }
	        else {
	          validateProps.setAttribute(tab, 'hidden');
	          validateProps.removeAttribute(tab, 'tabindex');
	        }
	      }
	    };
	    this.onTabsBarUpdate = (e) => {
	      e.stopPropagation(); // prevent double event emission because of identical name
	      this.activeTabIndex = e.detail.activeTabIndex;
	    };
	    this.size = 'small';
	    this.weight = 'regular';
	    this.theme = 'light';
	    this.gradientColorScheme = undefined;
	    this.gradientColor = 'background-base';
	    this.activeTabIndex = 0;
	    this.tabsItemElements = [];
	  }
	  activeTabHandler(newValue) {
	    this.setAccessibilityAttributes();
	    this.update.emit({ activeTabIndex: newValue });
	    this.tabChange.emit({ activeTabIndex: newValue });
	  }
	  componentWillLoad() {
	    this.defineTabsItemElements();
	  }
	  componentDidLoad() {
	    validateProps.getShadowRootHTMLElement(this.host, 'slot').addEventListener('slotchange', this.defineTabsItemElements);
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  componentDidRender() {
	    this.setAccessibilityAttributes();
	  }
	  render() {
	    validateProps.validateProps(this, propTypes$1);
	    warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'gradientColorScheme', 'Please use gradientColor prop instead.');
	    validateProps.attachComponentCss(this.host, getComponentCss$1);
	    syncTabsItemsProps(this.tabsItemElements, this.theme);
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    return (validateProps.h(validateProps.Host, null, validateProps.h(PrefixedTagNames.pTabsBar, { class: "root", size: this.size, weight: this.weight, theme: this.theme, gradientColorScheme: this.gradientColorScheme, gradientColor: this.gradientColor, activeTabIndex: this.activeTabIndex, onUpdate: this.onTabsBarUpdate, onTabChange: (e) => e.stopPropagation() }, this.tabsItemElements.map((tab, index) => (validateProps.h("button", { key: index, type: "button" }, tab.label)))), validateProps.h("slot", null)));
	  }
	  get host() { return validateProps.getElement(this); }
	  static get watchers() { return {
	    "activeTabIndex": ["activeTabHandler"]
	  }; }
	};

	const getComponentCss = (theme) => {
	  const { primaryColor, focusColor } = validateProps.getThemedColors(theme);
	  const { primaryColor: primaryColorDark, focusColor: focusColorDark } = validateProps.getThemedColors('dark');
	  return validateProps.getCss({
	    '@global': {
	      ':host': validateProps.addImportantToEachRule({
	        display: 'block',
	        position: 'relative',
	        color: primaryColor,
	        outline: 0,
	        ...colorSchemeStyles.hostHiddenStyles,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          color: primaryColorDark,
	        }),
	        '&(:focus:focus-visible)::before': {
	          content: '""',
	          position: 'absolute',
	          ...validateProps.getInsetJssStyle(-4),
	          border: `${validateProps.borderWidthBase} solid ${focusColor}`,
	          borderRadius: borderRadiusSmall.borderRadiusSmall,
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	            borderColor: focusColorDark,
	          }),
	        },
	      }),
	    },
	  });
	};

	const propTypes = {
	  label: validateProps.AllowedTypes.string,
	};
	const TabsItem = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.label = undefined;
	  }
	  handleLabelChange() {
	    throwIfChildrenAreNotOfKind.updateParent(this.host);
	  }
	  connectedCallback() {
	    throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-tabs');
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    validateProps.attachComponentCss(this.host, getComponentCss, this.host.theme || 'light' // default as fallback
	    );
	    return validateProps.h("slot", null);
	  }
	  get host() { return validateProps.getElement(this); }
	  static get watchers() { return {
	    "label": ["handleLabelChange"]
	  }; }
	};

	pTabs_2_cjs_entry.p_tabs = Tabs;
	pTabs_2_cjs_entry.p_tabs_item = TabsItem;

	
	return pTabs_2_cjs_entry;
}

var pTabsBar_cjs_entry = {};

var hasRequiredPTabsBar_cjs_entry;

function requirePTabsBar_cjs_entry () {
	if (hasRequiredPTabsBar_cjs_entry) return pTabsBar_cjs_entry;
	hasRequiredPTabsBar_cjs_entry = 1;

	Object.defineProperty(pTabsBar_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsedDa5fe664();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed3a5c494c();
	const scrolling = requireScrollingC37f1aeb();
	const theme = requireThemeBfc10573();
	const getDirectChildHTMLElements = requireGetDirectChildHTMLElements0adb2021();
	const tabsBarUtils = requireTabsBarUtils7de019f3();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const hoverMediaQuery = requireHoverMediaQueryF2ccfc24();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const fontWeightStyles = requireFontWeightStyles4b24ddd8();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const fontSizeText = requireFontSizeText728b6387();
	requireHelperE5c4e0db();
	requireGetHTMLElements21fc87cc();
	requireTransformSelectorToDirectChildSelector08da8668();
	requireGetAttribute4e18832c();
	requireFontWeightRegularD0c768ac();
	requireFontWeightSemiBold4482c830();
	requireTextShared9135e2ef();
	requireFontLineHeight78b03658();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireFontSizeTextXXSmallA02f9c40();
	requireFontSizeTextXSmallE59d35d7();
	requireFontSizeTextMedium88887ad8();
	requireFontSizeTextLarge05a4bc90();
	requireFontSizeTextXLarge0ecf9ef3();

	const isShadowRootParentOfKind = (element, tagName) => {
	  const parentElement = element.getRootNode().host;
	  return parentElement && validateProps.getTagName(parentElement) === validateProps.getPrefixedTagNames(element)[validateProps.paramCaseToCamelCase(tagName)];
	};

	/* eslint-disable prefer-arrow/prefer-arrow-functions */
	function getOnlyChildrenOfKindHTMLElementOrThrow(element, selector) {
	  const directChildren = getDirectChildHTMLElements.getDirectChildHTMLElements(element, selector);
	  const notValid = directChildren.some((child) => child.tagName !== directChildren[0].tagName);
	  if (notValid) {
	    validateProps.throwException(`child HTMLElements of ${validateProps.getTagNameWithoutPrefix(element)} are invalid. Expected all of: ${selector.replace(/,/g, ' or ')}.`);
	  }
	  return directChildren;
	}

	const barTransitionDuration = '.4s';
	const scrollerAnimatedCssClass = 'scroller--animated';
	const targetSelectors = ['a', 'button'];
	const transformSelector = (selector) => targetSelectors.map((tag) => selector.replace(/\[role]/g, tag)).join();
	const getComponentCss = (size, weight, theme) => {
	  const { primaryColor, hoverColor, focusColor } = validateProps.getThemedColors(theme);
	  const { primaryColor: primaryColorDark, hoverColor: hoverColorDark, focusColor: focusColorDark, } = validateProps.getThemedColors('dark');
	  const barJssStyle = {
	    position: 'absolute',
	    height: '2px',
	    left: 0,
	    ...(validateProps.isHighContrastMode
	      ? {
	        background: validateProps.getHighContrastColors().canvasTextColor,
	      }
	      : {
	        background: primaryColor,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          background: primaryColorDark,
	        }),
	      }),
	  };
	  return validateProps.getCss({
	    '@global': {
	      ':host': {
	        display: 'block',
	        ...validateProps.addImportantToEachRule({
	          position: 'relative',
	          ...colorSchemeStyles.colorSchemeStyles,
	          ...colorSchemeStyles.hostHiddenStyles,
	        }),
	      },
	      ...validateProps.addImportantToEachRule({
	        // would be nice to use shared selector like '::slotted([role])'
	        // but this doesn't work reliably when rendering in browser
	        [transformSelector('::slotted([role])')]: {
	          ...validateProps.getResetInitialStylesForSlottedAnchor,
	          display: 'inline-block',
	          position: 'relative',
	          margin: '0 0 4px 0',
	          verticalAlign: 'top',
	          fontFamily: 'inherit',
	          fontStyle: 'inherit',
	          fontVariant: 'inherit',
	          fontWeight: 'inherit',
	          fontSize: 'inherit',
	          lineHeight: 'inherit',
	          whiteSpace: 'nowrap',
	          boxSizing: 'border-box',
	          WebkitAppearance: 'none',
	          appearance: 'none',
	          outlineOffset: '1px',
	          textDecoration: 'none',
	          textAlign: 'left',
	          border: 0,
	          color: primaryColor,
	          cursor: 'pointer',
	          borderRadius: borderRadiusSmall.borderRadiusSmall,
	          zIndex: 0,
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	            color: primaryColorDark,
	          }),
	          ...hoverMediaQuery.hoverMediaQuery({
	            '&::before': {
	              content: '""',
	              position: 'absolute',
	              inset: '-2px -4px',
	              borderRadius: borderRadiusSmall.borderRadiusSmall,
	              zIndex: -1,
	              transition: validateProps.getTransition('background-color'),
	            },
	          }),
	        },
	        ...hoverMediaQuery.hoverMediaQuery({
	          [transformSelector('::slotted([role]:hover)::before')]: {
	            ...validateProps.frostedGlassStyle,
	            background: hoverColor,
	            ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	              background: hoverColorDark,
	            }),
	          },
	        }),
	        // basic invisible bar, that will be delayed via transition: visibility
	        [transformSelector('::slotted([role])::after')]: {
	          content: '""',
	          visibility: 'hidden',
	        },
	        // visible bar for selected tab
	        [transformSelector('::slotted([role][aria-selected="true"])::after, ::slotted([role][aria-current="true"])::after')]: {
	          ...barJssStyle,
	          right: '0px',
	          bottom: validateProps.isHighContrastMode ? '-4px' : '-6px',
	          visibility: 'visible',
	        },
	        // TODO: combine link-social-styles with link-button-styles and tabs-bar-styles
	        [transformSelector('::slotted([role]:focus:focus-visible)::before')]: {
	          border: `${validateProps.borderWidthBase} solid ${focusColor}`,
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	            borderColor: focusColorDark,
	          }),
	        },
	        [transformSelector('::slotted([role]:not(:last-child))')]: {
	          marginRight: spacingStaticMedium.spacingStaticMedium,
	        },
	      }),
	    },
	    scroller: {
	      ...textSmallStyle.textSmallStyle,
	      fontWeight: fontWeightStyles.getFontWeight(weight),
	      ...validateProps.buildResponsiveStyles(size, (s) => ({ fontSize: fontSizeText.fontSizeText[s] })),
	    },
	    // conditionally applied and removed based on if activeTabIndex exists
	    [scrollerAnimatedCssClass]: {
	      ['& ' +
	        transformSelector('::slotted([role][aria-selected="true"])::after, ::slotted([role][aria-current="true"])::after')]: {
	        transition: validateProps.addImportantToRule(`visibility 0s linear ${barTransitionDuration}`), // bar appears after transition
	      },
	    },
	    // moving bar
	    bar: {
	      ...barJssStyle,
	      width: 0,
	      bottom: validateProps.isHighContrastMode ? '0' : '-2px',
	      visibility: 'visible',
	      transition: `transform ${barTransitionDuration},width ${barTransitionDuration}`,
	      animation: '$hide 0s .5s forwards', // auto hide bar after transition, needs to be a little longer in Safari
	    },
	    '@keyframes hide': {
	      to: {
	        visibility: 'hidden',
	      },
	    },
	  });
	};

	const propTypes = {
	  size: validateProps.AllowedTypes.breakpoint(tabsBarUtils.TABS_BAR_SIZES),
	  weight: validateProps.AllowedTypes.oneOf(tabsBarUtils.TABS_BAR_WEIGHTS),
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	  gradientColorScheme: validateProps.AllowedTypes.oneOf([undefined, ...scrolling.GRADIENT_COLOR_SCHEMES]),
	  gradientColor: validateProps.AllowedTypes.oneOf(scrolling.GRADIENT_COLORS),
	  activeTabIndex: validateProps.AllowedTypes.number,
	};
	const TabsBar = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.tabChange = validateProps.createEvent(this, "tabChange", 3);
	    this.update = validateProps.createEvent(this, "update", 3);
	    this.direction = 'next';
	    this.setAccessibilityAttributes = () => {
	      this.tabElements.forEach((tab, index) => {
	        const attrs = this.areTabsButtons
	          ? {
	            role: 'tab',
	            tabindex: (this.activeTabIndex || 0) === index ? '0' : '-1',
	            'aria-selected': this.activeTabIndex === index ? 'true' : 'false',
	          }
	          : {
	            'aria-current': this.activeTabIndex === index ? 'true' : 'false',
	          };
	        /* eslint-disable-next-line guard-for-in */
	        for (const key in attrs) {
	          validateProps.setAttribute(tab, key, attrs[key]);
	        }
	      });
	    };
	    this.setTabElements = () => {
	      this.tabElements = getOnlyChildrenOfKindHTMLElementOrThrow(this.host, 'a,button');
	      this.areTabsButtons = this.tabElements[0]?.tagName === 'BUTTON';
	    };
	    this.onClick = (e) => {
	      const newTabIndex = this.tabElements.indexOf(e.target);
	      if (newTabIndex >= 0) {
	        this.onTabClick(newTabIndex);
	      }
	    };
	    this.onTabClick = (newTabIndex) => {
	      this.update.emit({ activeTabIndex: newTabIndex });
	      this.tabChange.emit({ activeTabIndex: newTabIndex });
	    };
	    this.onKeydown = (e) => {
	      let upcomingFocusedTabIndex;
	      const focusedTabIndex = this.hasPTabsParent ? this.activeTabIndex || 0 : tabsBarUtils.getFocusedTabIndex(this.tabElements);
	      switch (e.key) {
	        case 'ArrowLeft':
	        case 'Left':
	          upcomingFocusedTabIndex = tabsBarUtils.getPrevNextTabIndex('prev', this.tabElements.length, focusedTabIndex);
	          break;
	        case 'ArrowRight':
	        case 'Right':
	          upcomingFocusedTabIndex = tabsBarUtils.getPrevNextTabIndex('next', this.tabElements.length, focusedTabIndex);
	          break;
	        case 'Home':
	          upcomingFocusedTabIndex = 0;
	          break;
	        case 'End':
	          upcomingFocusedTabIndex = this.tabElements.length - 1;
	          break;
	        // the slotted buttons have a different tabbing sequence in chrome and safari and it appears that on hitting
	        // tab the first slotted one with tabindex=0 becomes focused instead of the one after,
	        // therefor the 'Tab' case needs to be handled
	        case 'Tab':
	          const { target } = e;
	          const { tabIndex } = target;
	          target.tabIndex = null;
	          setTimeout(() => {
	            target.tabIndex = tabIndex;
	          });
	          return;
	        default:
	          return;
	      }
	      if (this.hasPTabsParent) {
	        this.onTabClick(upcomingFocusedTabIndex);
	      }
	      this.tabElements[upcomingFocusedTabIndex].focus();
	      e.preventDefault();
	    };
	    this.scrollActiveTabIntoView = (isSmooth = true) => {
	      // scrollAreaElement might be undefined in certain scenarios with framework routing involved
	      // where the activeTabIndex watcher triggers this function before the scroller is rendered and the ref defined
	      if (this.scrollerElement && this.activeTabIndex !== undefined) {
	        const scrollActivePosition = scrolling.getScrollActivePosition(this.tabElements, this.direction, this.activeTabIndex, this.scrollerElement);
	        this.scrollerElement.scrollToPosition = {
	          scrollPosition: scrollActivePosition,
	          isSmooth,
	        };
	      }
	    };
	    this.setBarStyle = () => {
	      tabsBarUtils.setBarStyle(this.tabElements, this.activeTabIndex, this.barElement);
	    };
	    this.observeBreakpointChange = () => {
	      if (typeof validateProps.parseJSON(this.size) === 'object') {
	        validateProps.observeBreakpointChange(this.host, () => {
	          this.setBarStyle();
	          this.scrollActiveTabIntoView(false);
	        });
	      }
	    };
	    this.size = 'small';
	    this.weight = 'regular';
	    this.theme = 'light';
	    this.gradientColorScheme = undefined;
	    this.gradientColor = 'background-base';
	    this.activeTabIndex = undefined;
	    this.tabElements = [];
	  }
	  activeTabIndexHandler(newValue, oldValue) {
	    // in Angular, when chunk is already loaded and component is rendered almost identical after navigation
	    // (or with hot reloading in stackblitz) this watcher is called between `connectedCallback` and `componentDidLoad`
	    // this resets `this.activeTabIndex` to undefined when `this.tabElements = []`
	    // https://github.com/porsche-design-system/porsche-design-system/issues/2674
	    this.setTabElements();
	    this.activeTabIndex = tabsBarUtils.sanitizeActiveTabIndex(newValue, this.tabElements.length);
	    this.direction = this.activeTabIndex > oldValue || oldValue === undefined ? 'next' : 'prev';
	    this.setBarStyle();
	    this.scrollActiveTabIntoView();
	  }
	  connectedCallback() {
	    this.hasPTabsParent = isShadowRootParentOfKind(this.host, 'p-tabs');
	    this.observeBreakpointChange(); // on reconnect
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  componentWillLoad() {
	    this.setTabElements();
	    this.activeTabIndex = tabsBarUtils.sanitizeActiveTabIndex(this.activeTabIndex, this.tabElements.length); // since watcher doesn't trigger on first render
	  }
	  componentDidLoad() {
	    this.scrollActiveTabIntoView(false);
	    this.observeBreakpointChange(); // initially or slow prop binding
	    // TODO: would be great to use this in jsx but that doesn't work reliable or triggers initially when component is rendered via framework
	    validateProps.getShadowRootHTMLElement(this.host, 'slot').addEventListener('slotchange', () => {
	      this.setTabElements();
	      this.activeTabIndex = tabsBarUtils.sanitizeActiveTabIndex(this.activeTabIndex, this.tabElements.length);
	      this.setBarStyle();
	    });
	  }
	  disconnectedCallback() {
	    validateProps.unobserveBreakpointChange(this.host);
	  }
	  componentDidRender() {
	    // 1 tick delay to prevent transition
	    window.requestAnimationFrame(() => {
	      this.scrollerElement.classList.toggle(scrollerAnimatedCssClass, this.activeTabIndex !== undefined);
	    });
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'gradientColorScheme', 'Please use gradientColor prop instead.');
	    const deprecationMap = {
	      semibold: 'semi-bold',
	    };
	    warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'weight', deprecationMap);
	    validateProps.attachComponentCss(this.host, getComponentCss, this.size, (deprecationMap[this.weight] || this.weight), this.theme);
	    this.setAccessibilityAttributes();
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    return (validateProps.h(PrefixedTagNames.pScroller, { class: "scroller", ...(this.areTabsButtons && { aria: { role: 'tablist' } }), theme: this.theme, gradientColorScheme: this.gradientColorScheme, gradientColor: this.gradientColor, alignScrollIndicator: "top", ref: (el) => (this.scrollerElement = el), onClick: this.onClick, onKeyDown: this.onKeydown }, validateProps.h("slot", null), validateProps.h("span", { class: "bar", ref: (el) => (this.barElement = el) })));
	  }
	  get host() { return validateProps.getElement(this); }
	  static get watchers() { return {
	    "activeTabIndex": ["activeTabIndexHandler"]
	  }; }
	};

	pTabsBar_cjs_entry.p_tabs_bar = TabsBar;

	
	return pTabsBar_cjs_entry;
}

var pTagDismissible_cjs_entry = {};

var tagSharedUtils8232b651 = {};

var hasRequiredTagSharedUtils8232b651;

function requireTagSharedUtils8232b651 () {
	if (hasRequiredTagSharedUtils8232b651) return tagSharedUtils8232b651;
	hasRequiredTagSharedUtils8232b651 = 1;

	const validateProps = requireValidatePropsC2afb75b();
	const borderRadiusMedium = requireBorderRadiusMedium758b9411();

	/** @deprecated */
	const TAG_DISMISSIBLE_COLORS_DEPRECATED = ['background-default']; // 'background-default' is deprecated (replaced with 'background-base')
	const TAG_DISMISSIBLE_COLORS = [
	  'background-base',
	  'background-surface',
	  ...TAG_DISMISSIBLE_COLORS_DEPRECATED,
	];
	const TAG_DISMISSIBLE_ARIA_ATTRIBUTES = ['aria-label'];

	const getTagFocusJssStyle = (themedColors) => {
	  return {
	    '&:focus::before': {
	      content: '""',
	      position: 'absolute',
	      ...validateProps.getInsetJssStyle(-4),
	      border: `${validateProps.borderWidthBase} solid ${themedColors.focusColor}`,
	      borderRadius: borderRadiusMedium.borderRadiusMedium,
	    },
	    '&:focus:not(:focus-visible)::before': {
	      borderColor: 'transparent',
	    },
	  };
	};
	const getThemedBackgroundColor = (tagColor, themedColors) => {
	  const colorMap = {
	    'background-base': themedColors.backgroundColor,
	    'background-surface': themedColors.backgroundSurfaceColor,
	    primary: themedColors.primaryColor,
	    'notification-info-soft': themedColors.infoSoftColor,
	    'notification-warning-soft': themedColors.warningSoftColor,
	    'notification-success-soft': themedColors.successSoftColor,
	    'notification-error-soft': themedColors.errorSoftColor,
	  };
	  return colorMap[tagColor];
	};

	tagSharedUtils8232b651.TAG_DISMISSIBLE_ARIA_ATTRIBUTES = TAG_DISMISSIBLE_ARIA_ATTRIBUTES;
	tagSharedUtils8232b651.TAG_DISMISSIBLE_COLORS = TAG_DISMISSIBLE_COLORS;
	tagSharedUtils8232b651.getTagFocusJssStyle = getTagFocusJssStyle;
	tagSharedUtils8232b651.getThemedBackgroundColor = getThemedBackgroundColor;

	
	return tagSharedUtils8232b651;
}

var hasRequiredPTagDismissible_cjs_entry;

function requirePTagDismissible_cjs_entry () {
	if (hasRequiredPTagDismissible_cjs_entry) return pTagDismissible_cjs_entry;
	hasRequiredPTagDismissible_cjs_entry = 1;

	Object.defineProperty(pTagDismissible_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsedDa5fe664();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const hoverMediaQuery = requireHoverMediaQueryF2ccfc24();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const tagSharedUtils = requireTagSharedUtils8232b651();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const fontSizeTextXSmall = requireFontSizeTextXSmallE59d35d7();
	requireHelperE5c4e0db();
	requireBorderRadiusMedium758b9411();
	requireTextShared9135e2ef();
	requireFontLineHeight78b03658();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();

	const getComponentCss = (color, hasLabel, theme) => {
	  const themedColors = validateProps.getThemedColors(theme);
	  const themedColorsDark = validateProps.getThemedColors('dark');
	  const { primaryColor, hoverColor, contrastHighColor } = themedColors;
	  const { primaryColor: primaryColorDark, hoverColor: hoverColorDark, contrastHighColor: contrastHighColorDark, } = themedColorsDark;
	  const backgroundColor = tagSharedUtils.getThemedBackgroundColor(color, themedColors);
	  const backgroundColorDark = tagSharedUtils.getThemedBackgroundColor(color, themedColorsDark);
	  return validateProps.getCss({
	    '@global': {
	      ':host': validateProps.addImportantToEachRule({
	        display: 'inline-block',
	        verticalAlign: 'top',
	        outline: 0,
	        ...colorSchemeStyles.colorSchemeStyles,
	        ...colorSchemeStyles.hostHiddenStyles,
	      }),
	      button: {
	        display: 'flex',
	        position: 'relative',
	        alignItems: 'center',
	        gap: '12px',
	        minHeight: '54px',
	        padding: '4px 0 4px 12px',
	        borderRadius: borderRadiusSmall.borderRadiusSmall,
	        border: 0,
	        cursor: 'pointer',
	        background: backgroundColor,
	        color: primaryColor,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          background: backgroundColorDark,
	          color: primaryColorDark,
	        }),
	        textAlign: 'left',
	        ...textSmallStyle.textSmallStyle,
	        outline: validateProps.isHighContrastMode ? '1px solid transparent' : 0,
	        ...tagSharedUtils.getTagFocusJssStyle(themedColors),
	        ...hoverMediaQuery.hoverMediaQuery({
	          '&:hover > .icon': {
	            backgroundColor: hoverColor,
	            ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	              backgroundColor: hoverColorDark,
	            }),
	          },
	        }),
	      },
	    },
	    ...(hasLabel && {
	      label: {
	        display: 'block',
	        marginBottom: '-4px',
	        color: contrastHighColor,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          color: contrastHighColorDark,
	        }),
	        fontSize: fontSizeTextXSmall.fontSizeTextXSmall,
	      },
	    }),
	    icon: {
	      padding: '4px',
	      marginRight: '10px',
	      transition: validateProps.getTransition('background-color'),
	      borderRadius: borderRadiusSmall.borderRadiusSmall,
	    },
	    'sr-only': validateProps.getHiddenTextJssStyle(),
	  });
	};

	const propTypes = {
	  color: validateProps.AllowedTypes.oneOf(tagSharedUtils.TAG_DISMISSIBLE_COLORS),
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	  label: validateProps.AllowedTypes.string,
	  aria: validateProps.AllowedTypes.aria(tagSharedUtils.TAG_DISMISSIBLE_ARIA_ATTRIBUTES),
	};
	const TagDismissible = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.color = 'background-surface';
	    this.theme = 'light';
	    this.label = undefined;
	    this.aria = undefined;
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    const deprecationMap = {
	      'background-default': 'background-base',
	    };
	    warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'color', deprecationMap);
	    validateProps.attachComponentCss(this.host, getComponentCss, (deprecationMap[this.color] || this.color), !!this.label, this.theme);
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    return (validateProps.h("button", { type: "button", ...validateProps.parseAndGetAriaAttributes(this.aria) }, validateProps.h("span", { class: "sr-only" }, "Remove:"), validateProps.h("span", null, this.label && validateProps.h("span", { class: "label" }, this.label), validateProps.h("slot", null)), validateProps.h(PrefixedTagNames.pIcon, { class: "icon", name: "close", theme: this.theme, "aria-hidden": "true" })));
	  }
	  static get delegatesFocus() { return true; }
	  get host() { return validateProps.getElement(this); }
	};

	pTagDismissible_cjs_entry.p_tag_dismissible = TagDismissible;

	
	return pTagDismissible_cjs_entry;
}

var pTag_cjs_entry = {};

var hasRequiredPTag_cjs_entry;

function requirePTag_cjs_entry () {
	if (hasRequiredPTag_cjs_entry) return pTag_cjs_entry;
	hasRequiredPTag_cjs_entry = 1;

	Object.defineProperty(pTag_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const tagSharedUtils = requireTagSharedUtils8232b651();
	const transformSelectorToDirectChildSelector = requireTransformSelectorToDirectChildSelector08da8668();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsedDa5fe664();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const hoverMediaQuery = requireHoverMediaQueryF2ccfc24();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const borderRadiusSmall = requireBorderRadiusSmall5f37fc45();
	const textXSmallStyle = requireTextXSmallStyle1145ee25();
	requireBorderRadiusMedium758b9411();
	requireHelperE5c4e0db();
	requireTextShared9135e2ef();
	requireFontLineHeight78b03658();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextXSmallE59d35d7();

	/* eslint-disable prefer-arrow/prefer-arrow-functions */
	function getDirectChildHTMLElement(element, selector) {
	  // querySelector(All) doesn't work with :scope pseudo class and comma separator in jsdom, yet
	  // https://github.com/jsdom/jsdom/issues/3141
	  // therefore we got a workaround so it works nicely when consumed from jsdom-polyfill package
	  return (transformSelectorToDirectChildSelector.transformSelectorToDirectChildSelector(selector)
	    .split(',')
	    .map((sel) => validateProps.getHTMLElement(element, sel))
	    .filter((x) => x)[0] || null // comma separated selector might return null, so we have to filter
	  );
	}

	const getThemeForIcon = (color, theme) => {
	  return color === 'neutral-contrast-high' || color === 'primary' ? (validateProps.isThemeDark(theme) ? 'light' : 'dark') : theme;
	};
	/** @deprecated */
	const TAG_COLORS_DEPRECATED = [
	  'neutral-contrast-high',
	  'notification-neutral',
	  'notification-warning',
	  'notification-success',
	  'notification-error',
	];
	const TAG_COLORS = [
	  ...tagSharedUtils.TAG_DISMISSIBLE_COLORS,
	  'primary',
	  'notification-info-soft',
	  'notification-warning-soft',
	  'notification-success-soft',
	  'notification-error-soft',
	  ...TAG_COLORS_DEPRECATED,
	];
	const getThemedBackgroundHoverColor = (tagColor, themedColors, theme) => {
	  const isDark = validateProps.isThemeDark(theme);
	  const keySuffix = isDark ? 'Lighten' : 'Darken';
	  const colorMap = {
	    'background-base': themedColors[`backgroundColor${keySuffix}`],
	    'background-surface': themedColors[`backgroundSurfaceColor${keySuffix}`],
	    primary: isDark ? themedColors.contrastHighColorLighten : themedColors.contrastHighColor,
	    'notification-info-soft': themedColors[`infoSoftColor${keySuffix}`],
	    'notification-success-soft': themedColors[`successSoftColor${keySuffix}`],
	    'notification-error-soft': themedColors[`errorSoftColor${keySuffix}`],
	    'notification-warning-soft': themedColors[`warningSoftColor${keySuffix}`],
	  };
	  return colorMap[tagColor];
	};

	const getColors = (themedColors, tagColor, theme) => {
	  const { primaryColor } = tagColor === 'primary' ? validateProps.getInvertedThemedColors(theme) : themedColors;
	  return {
	    primaryColor,
	    focusColor: themedColors.focusColor,
	    backgroundColor: tagSharedUtils.getThemedBackgroundColor(tagColor, themedColors),
	    backgroundHoverColor: getThemedBackgroundHoverColor(tagColor, themedColors, theme),
	  };
	};
	const getComponentCss = (tagColor, isFocusable, theme) => {
	  const themedColors = validateProps.getThemedColors(theme);
	  const themedColorsDark = validateProps.getThemedColors('dark');
	  const { primaryColor, backgroundColor, backgroundHoverColor } = getColors(themedColors, tagColor, theme);
	  const { primaryColor: primaryColorDark, backgroundColor: backgroundColorDark, backgroundHoverColor: backgroundHoverColorDark, } = getColors(themedColorsDark, tagColor, 'dark');
	  return validateProps.getCss({
	    '@global': {
	      ':host': {
	        display: 'inline-flex',
	        verticalAlign: 'top',
	        whiteSpace: 'nowrap',
	        ...validateProps.addImportantToEachRule({
	          ...colorSchemeStyles.colorSchemeStyles,
	          ...colorSchemeStyles.hostHiddenStyles,
	        }),
	      },
	      span: {
	        display: 'flex',
	        gap: '2px',
	        alignItems: 'center',
	        position: 'relative',
	        padding: '4px 9px',
	        borderRadius: borderRadiusSmall.borderRadiusSmall,
	        background: backgroundColor,
	        color: primaryColor,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          background: backgroundColorDark,
	          color: primaryColorDark,
	        }),
	        font: textXSmallStyle.textXSmallStyle.font,
	        ...(validateProps.isHighContrastMode && {
	          outline: '1px solid transparent',
	        }),
	        ...(isFocusable &&
	          hoverMediaQuery.hoverMediaQuery({
	            transition: validateProps.getTransition('background-color'),
	            '&:hover': {
	              background: backgroundHoverColor,
	              ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	                background: backgroundHoverColorDark,
	              }),
	            },
	          })),
	      },
	      '::slotted': validateProps.addImportantToEachRule({
	        '&(a),&(button)': {
	          ...validateProps.getResetInitialStylesForSlottedAnchor,
	          display: 'inline',
	          position: 'static',
	          textDecoration: 'underline',
	          cursor: 'pointer',
	          font: 'inherit',
	          color: 'inherit',
	          appearance: 'none',
	          border: 0,
	          textAlign: 'left',
	        },
	        // Transform selectors of getTagFocusJssStyle() to fit the ::slotted syntax
	        ...Object.entries(tagSharedUtils.getTagFocusJssStyle(themedColors)).reduce((result, [key, value]) => {
	          result[key.replace(/^&([a-z:\-()]*)(::[a-z\-]+)$/, '&(a$1)$2, &(button$1)$2')] = value;
	          return result;
	        }, {}),
	        '&(br)': {
	          display: 'none',
	        },
	      }),
	    },
	    icon: {
	      marginLeft: '-2px',
	      alignSelf: 'flex-start',
	      ...(['neutral-contrast-high', 'primary'].includes(tagColor) && {
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          filter: 'invert(1)',
	        }),
	      }),
	    },
	  });
	};

	const propTypes = {
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	  color: validateProps.AllowedTypes.oneOf(TAG_COLORS),
	  icon: validateProps.AllowedTypes.string,
	  iconSource: validateProps.AllowedTypes.string,
	};
	const Tag = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.theme = 'light';
	    this.color = 'background-surface';
	    this.icon = undefined;
	    this.iconSource = undefined;
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    const deprecationMap = {
	      'background-default': 'background-base',
	      'neutral-contrast-high': 'primary',
	      'notification-neutral': 'notification-info-soft',
	      'notification-warning': 'notification-warning-soft',
	      'notification-success': 'notification-success-soft',
	      'notification-error': 'notification-error-soft',
	    };
	    warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'color', deprecationMap);
	    validateProps.attachComponentCss(this.host, getComponentCss, (deprecationMap[this.color] || this.color), !!getDirectChildHTMLElement(this.host, 'a,button'), this.theme);
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    return (validateProps.h("span", null, (this.icon || this.iconSource) && (validateProps.h(PrefixedTagNames.pIcon, { class: "icon", name: this.icon, source: this.iconSource, color: "primary", size: "x-small", theme: getThemeForIcon(this.color, this.theme), "aria-hidden": "true" })), validateProps.h("div", { class: "label" }, validateProps.h("slot", null))));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	pTag_cjs_entry.p_tag = Tag;

	
	return pTag_cjs_entry;
}

var pTextFieldWrapper_cjs_entry = {};

var hasRequiredPTextFieldWrapper_cjs_entry;

function requirePTextFieldWrapper_cjs_entry () {
	if (hasRequiredPTextFieldWrapper_cjs_entry) return pTextFieldWrapper_cjs_entry;
	hasRequiredPTextFieldWrapper_cjs_entry = 1;

	Object.defineProperty(pTextFieldWrapper_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const buttonHandling = requireButtonHandlingA110f521();
	const required = requireRequiredBc18b612();
	const hasDescription = requireHasDescriptionA19e4bdc();
	const isRequiredAndParentNotRequired = requireIsRequiredAndParentNotRequired0b84c8cc();
	const isWithinForm = requireIsWithinFormA677dade();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed3a5c494c();
	const propertyObserver = requirePropertyObserverBfc089d2();
	const theme = requireThemeBfc10573();
	const getOnlyChildOfKindHTMLElementOrThrow = requireGetOnlyChildOfKindHTMLElementOrThrowF6972c1c();
	const formStyles = requireFormStyles97f2cdf7();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const hasDocument = requireHasDocument079654e6();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();
	const spacingStaticSmall = requireSpacingStaticSmall2130ed04();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const fontLineHeight = requireFontLineHeight78b03658();
	requireGetClosestHTMLElement0135bfd9();
	requireHasNamedSlot28c6bca1();
	requireGetNamedSlotA433c432();
	requireSpacingStaticXSmallB7d708b8();
	requireIsParentFieldsetRequired6f3a68ad();
	requireIsParentOfKindA9c351f2();
	requireHelperE5c4e0db();
	requireGetDirectChildHTMLElements0adb2021();
	requireGetHTMLElements21fc87cc();
	requireTransformSelectorToDirectChildSelector08da8668();
	requireHoverMediaQueryF2ccfc24();
	requireFontSizeTextXSmallE59d35d7();
	requireBorderRadiusSmall5f37fc45();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();

	const UNIT_POSITIONS = ['prefix', 'suffix'];
	const hasCounterAndIsTypeText = (el) => isType(el.type, 'text') && validateProps.hasCounter(el);
	const hasUnitAndIsTypeTextOrNumber = ({ type }, unit) => {
	  return !!unit && (isType(type, 'text') || isType(type, 'number'));
	};
	const isType = (inputType, typeToValidate) => inputType === typeToValidate;
	const hasLocateAction = (icon) => icon === 'locate';
	const getInputPaddingLeftOrRight = (unitElementWidth) => {
	  return `calc(${unitElementWidth}px - ${validateProps.borderWidthBase})`;
	};
	const setInputStyles = (input, unitOrCounterElement, unitPosition) => {
	  if (unitOrCounterElement) {
	    input.style.removeProperty(cssVariableInputPaddingLeft);
	    input.style.removeProperty(cssVariableInputPaddingRight);
	    input.style.setProperty(unitPosition === 'prefix' ? cssVariableInputPaddingLeft : cssVariableInputPaddingRight, getInputPaddingLeftOrRight(unitOrCounterElement.offsetWidth), 'important');
	  }
	};
	const throwIfUnitLengthExceeded = (unit) => {
	  if (unit.length > 5) {
	    validateProps.throwException(`unit='${unit}' passed to p-text-field-wrapper exceeds the maximum length of 5.`);
	  }
	};
	const addInputEventListenerForSearch = (input, inputChangeCallback) => {
	  input.addEventListener('input', (e) => {
	    inputChangeCallback(!!e.target.value);
	  });
	  input.addEventListener('keydown', (e) => {
	    if (e.key === 'Escape' && e.target.value) {
	      e.preventDefault();
	      e.target.value = '';
	      // need to emit event so consumer's change listeners fire for resetting a search, etc.
	      dispatchInputEvent(e.target);
	    }
	  });
	};
	const dispatchInputEvent = (el) => {
	  // { bubbles: true } is crucial for react onChange callback getting invoked
	  el.dispatchEvent(new Event('input', { bubbles: true }));
	};
	// eslint-disable-next-line no-underscore-dangle
	const _hasShowPickerSupport = () => {
	  return (hasDocument.hasDocument &&
	    'showPicker' in HTMLInputElement.prototype &&
	    // TODO: it would be better to determinate support by checking for existence of "calendar-picker-indicator"
	    !!window.navigator.userAgent.match(/chrome|chromium|crios|edg/i));
	};
	const hasShowPickerSupport = _hasShowPickerSupport();
	const showCustomCalendarOrTimeIndicator = (isCalendar, isTime) => {
	  return hasShowPickerSupport && (isCalendar || isTime);
	};

	const cssVariableInputPaddingLeft = '--p-internal-text-field-input-padding-left';
	const cssVariableInputPaddingRight = '--p-internal-text-field-input-padding-right';
	const buttonOrIconPadding = '4px';
	const buttonOrIconSize = `calc(${fontLineHeight.fontLineHeight} + ${buttonOrIconPadding} * 2)`;
	const buttonOrIconOffset = '9px';
	const baseButtonOrIconStyles = {
	  position: 'absolute',
	  bottom: '11px',
	  padding: buttonOrIconPadding,
	  font: `1rem ${fontLineHeight.fontFamily}`,
	};
	const getInputPaddingHorizontal = (buttonOrIconAmount) => {
	  return `calc(${buttonOrIconOffset} * 2 + ${buttonOrIconSize} * ${buttonOrIconAmount})`;
	};
	const getButtonOrIconOffsetHorizontal = (buttonOrIconAmount) => {
	  const multiplier = buttonOrIconAmount > 1 ? ` + ${buttonOrIconSize} * ${buttonOrIconAmount - 1}` : '';
	  return `calc(${buttonOrIconOffset} + ${validateProps.borderWidthBase}${multiplier})`;
	};
	const getComponentCss = (isDisabled, hideLabel, state, hasUnitOrVisibleCounter, unitPosition, inputType, showPasswordToggle, isWithinForm, theme) => {
	  const { contrastMediumColor } = validateProps.getThemedColors(theme);
	  const { contrastMediumColor: contrastMediumColorDark } = validateProps.getThemedColors('dark');
	  const isSearch = isType(inputType, 'search');
	  const isPassword = isType(inputType, 'password');
	  const isNumber = isType(inputType, 'number');
	  const isCalendar = isType(inputType, 'date') || isType(inputType, 'week') || isType(inputType, 'month');
	  const isTime = isType(inputType, 'time');
	  const isSearchOrPassword = isSearch || (isPassword && showPasswordToggle);
	  const isSearchWithoutForm = isSearch && !isWithinForm;
	  const isSearchWithForm = isSearch && isWithinForm;
	  const isCalendarOrTimeWithCustomIndicator = showCustomCalendarOrTimeIndicator(isCalendar, isTime);
	  return validateProps.getCss({
	    '@global': {
	      ':host': {
	        display: 'block',
	        ...validateProps.addImportantToEachRule({
	          [cssVariableInputPaddingLeft]: isSearchWithoutForm ? getInputPaddingHorizontal(1) : spacingStaticMedium.spacingStaticMedium,
	          [cssVariableInputPaddingRight]: isSearchOrPassword || isCalendarOrTimeWithCustomIndicator
	            ? getInputPaddingHorizontal(isSearchWithForm ? 2 : 1)
	            : spacingStaticMedium.spacingStaticMedium,
	          ...colorSchemeStyles.colorSchemeStyles,
	          ...colorSchemeStyles.hostHiddenStyles,
	        }),
	      },
	      ...validateProps.addImportantToEachRule({
	        ...formStyles.getBaseChildStyles('input', state, theme, {
	          padding: `${spacingStaticSmall.spacingStaticSmall} var(${cssVariableInputPaddingRight}) ${spacingStaticSmall.spacingStaticSmall} var(${cssVariableInputPaddingLeft})`,
	          ...(isNumber && {
	            MozAppearance: 'textfield', // hides up/down spin button for Firefox
	          }),
	        }),
	        '::slotted': {
	          '&(input:-internal-autofill-selected),&(input:-internal-autofill-previewed),&(input:-webkit-autofill),&(input:-webkit-autofill:focus)': {
	            WebkitBackgroundClip: 'padding-box', // reset webkit autofill styles
	          },
	        },
	      }),
	    },
	    ...((isSearchOrPassword || isCalendarOrTimeWithCustomIndicator) && {
	      button: {
	        ...baseButtonOrIconStyles,
	        right: getButtonOrIconOffsetHorizontal(1),
	        // TODO: maybe we should render hidden button conditionally, needs to be checked if a11y compliant
	        '&:not([hidden]) ~ .button': {
	          right: getButtonOrIconOffsetHorizontal(2),
	        },
	      },
	    }),
	    ...(isSearchWithoutForm && {
	      icon: {
	        ...baseButtonOrIconStyles,
	        left: getButtonOrIconOffsetHorizontal(1),
	        pointerEvents: 'none',
	      },
	    }),
	    root: {
	      display: 'block',
	      position: 'relative',
	    },
	    ...formStyles.getLabelStyles('input', isDisabled, hideLabel, state, theme, hasUnitOrVisibleCounter && {
	      unit: {
	        position: 'absolute',
	        bottom: '15px',
	        [unitPosition === 'suffix' ? 'right' : 'left']: 0,
	        zIndex: 1,
	        padding: unitPosition === 'suffix' ? `0 ${spacingStaticMedium.spacingStaticMedium} 0 10px` : `0 10px 0 ${spacingStaticMedium.spacingStaticMedium}`,
	        font: textSmallStyle.textSmallStyle.font,
	        color: contrastMediumColor,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          color: contrastMediumColorDark,
	        }),
	      },
	    }),
	    ...required.getFunctionalComponentRequiredStyles(),
	    ...required.getFunctionalComponentStateMessageStyles(theme, state),
	    // TODO: could be made conditional if we had hasUnit
	    'sr-only': {
	      ...validateProps.getHiddenTextJssStyle(),
	      padding: 0,
	    },
	  });
	};

	const propTypes = {
	  label: validateProps.AllowedTypes.string,
	  unit: validateProps.AllowedTypes.string,
	  unitPosition: validateProps.AllowedTypes.oneOf(UNIT_POSITIONS),
	  description: validateProps.AllowedTypes.string,
	  state: validateProps.AllowedTypes.oneOf(required.FORM_STATES),
	  message: validateProps.AllowedTypes.string,
	  hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	  showCharacterCount: validateProps.AllowedTypes.boolean,
	  showCounter: validateProps.AllowedTypes.boolean,
	  actionIcon: validateProps.AllowedTypes.oneOf([undefined, 'locate']),
	  actionLoading: validateProps.AllowedTypes.boolean,
	  showPasswordToggle: validateProps.AllowedTypes.boolean,
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const TextFieldWrapper = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.action = validateProps.createEvent(this, "action", 3);
	    this.onLabelClick = () => {
	      this.input.focus();
	    };
	    this.togglePassword = () => {
	      this.input.type = isType(this.input.type, 'password') ? 'text' : 'password';
	      this.showPassword = !this.showPassword;
	      this.onLabelClick();
	    };
	    this.onSubmit = (event) => {
	      buttonHandling.handleButtonEvent(event, this.host, () => 'submit', () => this.input.disabled);
	    };
	    this.onClear = () => {
	      this.onLabelClick();
	      this.input.value = '';
	      dispatchInputEvent(this.input);
	    };
	    this.observeAttributes = () => {
	      validateProps.observeAttributes(this.input, ['disabled', 'readonly', 'required'], () => validateProps.forceUpdate(this.host));
	    };
	    this.setInputStyles = () => {
	      setInputStyles(this.input, this.unitOrCounterElement, this.isCounterVisible ? 'suffix' : this.unitPosition);
	    };
	    this.label = '';
	    this.unit = '';
	    this.unitPosition = 'prefix';
	    this.description = '';
	    this.state = 'none';
	    this.message = '';
	    this.hideLabel = false;
	    this.showCharacterCount = undefined;
	    this.showCounter = true;
	    this.actionIcon = undefined;
	    this.actionLoading = false;
	    this.showPasswordToggle = true;
	    this.theme = 'light';
	    this.showPassword = false;
	    this.isClearable = false;
	  }
	  connectedCallback() {
	    this.observeAttributes(); // on every reconnect
	  }
	  componentWillLoad() {
	    this.input = getOnlyChildOfKindHTMLElementOrThrow.getOnlyChildOfKindHTMLElementOrThrow(this.host, ['text', 'number', 'email', 'tel', 'search', 'url', 'date', 'time', 'month', 'week', 'password']
	      .map((v) => `input[type=${v}]`)
	      .join());
	    const { type } = this.input;
	    this.observeAttributes(); // once initially
	    this.isSearch = isType(type, 'search');
	    this.isPassword = isType(type, 'password');
	    this.isCalendar = isType(type, 'date') || isType(type, 'week') || isType(type, 'month');
	    this.isTime = isType(type, 'time');
	    this.isWithinForm = isWithinForm.isWithinForm(this.host);
	    this.hasAction = hasLocateAction(this.actionIcon);
	    this.hasCounter = hasCounterAndIsTypeText(this.input);
	    this.isCounterVisible =
	      this.hasCounter && (typeof this.showCharacterCount === 'undefined' ? this.showCounter : this.showCharacterCount);
	    this.hasUnit = !this.isCounterVisible && hasUnitAndIsTypeTextOrNumber(this.input, this.unit);
	    if (this.isSearch) {
	      this.isClearable = !!this.input.value;
	      // detect programmatic value changes like it happens in frameworks
	      propertyObserver.observeProperties(this.input, ['value'], () => (this.isClearable = !!this.input.value));
	    }
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  componentDidLoad() {
	    if (this.hasCounter) {
	      validateProps.addInputEventListenerForCounter(this.input, this.ariaElement, this.isCounterVisible && this.unitOrCounterElement, this.setInputStyles);
	    }
	    else if (this.isSearch) {
	      addInputEventListenerForSearch(this.input, (hasValue) => (this.isClearable = hasValue));
	    }
	  }
	  componentDidRender() {
	    // needs to happen after render in order to have unitOrCounterElement defined
	    this.setInputStyles();
	    /*
	     * This is a workaround to improve accessibility because the input and the label/description/message text are placed in different DOM.
	     * Referencing ID's from outside the component is impossible because the web component’s DOM is separate.
	     * We have to wait for full support of the Accessibility Object Model (AOM) to provide the relationship between shadow DOM and slots
	     */
	    validateProps.setAriaAttributes(this.input, {
	      label: this.label,
	      message: this.message || this.description,
	      state: this.state,
	    });
	  }
	  disconnectedCallback() {
	    validateProps.unobserveAttributes(this.input);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'showCharacterCount', 'Please use showCounter prop instead.');
	    throwIfUnitLengthExceeded(this.unit);
	    const { readOnly, disabled, type } = this.input;
	    validateProps.attachComponentCss(this.host, getComponentCss, disabled, this.hideLabel, this.state, this.hasUnit || this.isCounterVisible, this.isCounterVisible ? 'suffix' : this.unitPosition, this.isPassword ? 'password' : type, this.showPasswordToggle, this.isWithinForm, this.theme);
	    const disabledOrReadOnly = disabled || readOnly;
	    const labelProps = {
	      onClick: this.onLabelClick,
	    };
	    const buttonProps = {
	      hideLabel: true,
	      theme: this.theme,
	      class: 'button',
	    };
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    return (validateProps.h(validateProps.Host, null, validateProps.h("div", { class: "root" }, validateProps.h("label", { class: "label" }, required.hasLabel(this.host, this.label) && (validateProps.h("span", { class: "label__text", ...labelProps }, this.label || validateProps.h("slot", { name: "label" }), isRequiredAndParentNotRequired.isRequiredAndParentNotRequired(this.host, this.input) && validateProps.h(required.Required, null))), hasDescription.hasDescription(this.host, this.description) && (validateProps.h("span", { class: "label__text", ...labelProps }, this.description || validateProps.h("slot", { name: "description" }))), (this.hasUnit || this.isCounterVisible) && (validateProps.h("span", { class: "unit", ref: (el) => (this.unitOrCounterElement = el), "aria-hidden": "true" }, this.unit)), validateProps.h("slot", null), this.hasCounter && validateProps.h("span", { class: "sr-only", ref: (el) => (this.ariaElement = el), "aria-live": "polite" })), this.isPassword && this.showPasswordToggle ? (validateProps.h(PrefixedTagNames.pButtonPure, { ...buttonProps, type: "button", icon: this.showPassword ? 'view-off' : 'view', disabled: disabled, onClick: this.togglePassword, aria: { 'aria-pressed': this.showPassword ? 'true' : 'false' } }, "Toggle password visibility")) : showCustomCalendarOrTimeIndicator(this.isCalendar, this.isTime) ? (validateProps.h(PrefixedTagNames.pButtonPure, { ...buttonProps, type: "button", icon: this.isCalendar ? 'calendar' : 'clock', disabled: disabled, onClick: () => this.input.showPicker() }, `Show ${this.isCalendar ? 'date' : 'time'} picker`)) : (this.isSearch && [
	      // TODO: create an own component, which would fix SSR support too
	      this.isWithinForm ? (validateProps.h(PrefixedTagNames.pButtonPure, { ...buttonProps, key: "btn-submit", type: "submit", icon: "search", disabled: disabledOrReadOnly, onClick: this.onSubmit }, "Search")) : (validateProps.h(PrefixedTagNames.pIcon, { key: "icon", class: "icon", name: "search", color: "state-disabled", theme: this.theme, "aria-hidden": "true" })),
	      validateProps.h(PrefixedTagNames.pButtonPure, { ...buttonProps, type: "button", key: "btn-clear", icon: "close", tabIndex: -1, hidden: !this.isClearable, disabled: disabledOrReadOnly, onClick: this.onClear }, "Clear field"),
	      this.hasAction && (validateProps.h(PrefixedTagNames.pButtonPure, { ...buttonProps, type: "button", key: "btn-action", icon: "locate", hidden: this.isClearable, disabled: disabledOrReadOnly, onClick: !this.actionLoading ? () => this.action.emit() : null, loading: this.actionLoading }, "Locate me")),
	    ])), required.hasMessage(this.host, this.message, this.state) && (validateProps.h(required.StateMessage, { state: this.state, message: this.message, theme: this.theme, host: this.host }))));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	pTextFieldWrapper_cjs_entry.p_text_field_wrapper = TextFieldWrapper;

	
	return pTextFieldWrapper_cjs_entry;
}

var pTextList_2_cjs_entry = {};

var hasRequiredPTextList_2_cjs_entry;

function requirePTextList_2_cjs_entry () {
	if (hasRequiredPTextList_2_cjs_entry) return pTextList_2_cjs_entry;
	hasRequiredPTextList_2_cjs_entry = 1;

	Object.defineProperty(pTextList_2_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed3a5c494c();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const spacingStaticXSmall = requireSpacingStaticXSmallB7d708b8();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();
	const throwIfParentIsNotOfKind = requireThrowIfParentIsNotOfKind99386afd();
	requireHelperE5c4e0db();
	requireTextShared9135e2ef();
	requireFontLineHeight78b03658();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();
	requireIsParentOfKindA9c351f2();

	/** @deprecated */
	const LIST_TYPES = ['unordered', 'ordered'];
	/** @deprecated */
	const ORDER_TYPES = ['numbered', 'alphabetically'];
	const TEXT_LIST_TYPES = ['unordered', 'numbered', 'alphabetically'];
	const isListTypeOrdered = (type) => type !== 'unordered';
	const isListTypeNumbered = (type) => type === 'numbered';

	const cssVariablePseudoSuffix = '--p-internal-text-list-pseudo-suffix';
	const cssVariablePaddingTop = '--p-internal-text-list-padding-top';
	const cssVariablePaddingBottom = '--p-internal-text-list-padding-bottom';
	const cssVariableUnorderedPaddingLeft = '--p-internal-text-list-unordered-padding-left';
	const cssVariableOrderedPaddingLeft = '--p-internal-text-list-ordered-padding-left';
	const cssVariableListStyleType = '--p-internal-text-list-list-style-type';
	const counter = 'p-text-list-counter';
	const getComponentCss$1 = (type, theme) => {
	  const isOrderedList = isListTypeOrdered(type);
	  return validateProps.getCss({
	    '@global': {
	      ':host': {
	        display: 'block',
	        ...validateProps.addImportantToEachRule({
	          counterReset: counter,
	          ...colorSchemeStyles.colorSchemeStyles,
	          ...colorSchemeStyles.hostHiddenStyles,
	        }),
	      },
	      'ol,ul': {
	        ...textSmallStyle.textSmallStyle,
	        margin: 0,
	        padding: `var(${cssVariablePaddingTop},0) 0 var(${cssVariablePaddingBottom},0) ${isOrderedList
	          ? `var(${cssVariableOrderedPaddingLeft},1.5rem)` // reserves space for ::before (root ordered list)
	          : `var(${cssVariableUnorderedPaddingLeft},.375rem)` // reserves space for ::marker "•" (root unordered list)
	        }`,
	        listStyleType: isOrderedList ? 'none' : `var(${cssVariableListStyleType},'•')`,
	        color: validateProps.getThemedColors(theme).primaryColor,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          color: validateProps.getThemedColors('dark').primaryColor,
	        }),
	      },
	      // css selector for text-list-item
	      '::slotted(*)': validateProps.addImportantToEachRule({
	        [cssVariablePaddingTop]: spacingStaticXSmall.spacingStaticXSmall,
	        // TODO: in case it's last root list item with a nested list it would result in outer spacing which is not desired
	        [cssVariablePaddingBottom]: spacingStaticMedium.spacingStaticMedium,
	        [cssVariableOrderedPaddingLeft]: '2rem',
	        [cssVariableUnorderedPaddingLeft]: '.625rem',
	        [cssVariableListStyleType]: '"–"',
	        ...(isOrderedList && {
	          '&::before': {
	            content: `counters(${counter},'.',${isListTypeNumbered(type) ? 'decimal' : 'lower-latin'}) var(${cssVariablePseudoSuffix},'.')`,
	            counterIncrement: counter,
	            position: 'absolute',
	            top: 0,
	            left: 0,
	            transform: 'translate(-100%,0)',
	          },
	        }),
	      }),
	    },
	  });
	};

	const propTypes = {
	  listType: validateProps.AllowedTypes.oneOf([undefined, ...LIST_TYPES]),
	  orderType: validateProps.AllowedTypes.oneOf([undefined, ...ORDER_TYPES]),
	  type: validateProps.AllowedTypes.oneOf(TEXT_LIST_TYPES),
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const TextList = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.listType = undefined;
	    this.orderType = undefined;
	    this.type = 'unordered';
	    this.theme = 'light';
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'listType', 'Please use type prop instead.');
	    warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'orderType', 'Please use type prop instead.');
	    validateProps.attachComponentCss(this.host, getComponentCss$1, this.listType === 'ordered' ? this.orderType || 'numbered' : this.type, this.theme);
	    const TagType = isListTypeOrdered(this.listType || this.type) ? 'ol' : 'ul';
	    return (validateProps.h(TagType, null, validateProps.h("slot", null)));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	const getComponentCss = () => {
	  return validateProps.getCss({
	    '@global': validateProps.addImportantToEachRule({
	      ':host': {
	        display: 'list-item',
	        position: 'relative',
	        font: 'inherit',
	        color: 'inherit',
	        listStyleType: 'inherit',
	        paddingLeft: spacingStaticMedium.spacingStaticMedium,
	        ...colorSchemeStyles.hostHiddenStyles,
	      },
	      '::slotted(*)': {
	        [cssVariablePseudoSuffix]: '""', // don't show suffix "." for nested ordered list
	      },
	    }),
	  });
	};

	const TextListItem = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	  }
	  connectedCallback() {
	    throwIfParentIsNotOfKind.throwIfParentIsNotOfKind(this.host, 'p-text-list');
	  }
	  render() {
	    validateProps.attachComponentCss(this.host, getComponentCss);
	    return (validateProps.h(validateProps.Host, { role: "listitem" }, validateProps.h("slot", null)));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	pTextList_2_cjs_entry.p_text_list = TextList;
	pTextList_2_cjs_entry.p_text_list_item = TextListItem;

	
	return pTextList_2_cjs_entry;
}

var pText_cjs_entry = {};

var hasRequiredPText_cjs_entry;

function requirePText_cjs_entry () {
	if (hasRequiredPText_cjs_entry) return pText_cjs_entry;
	hasRequiredPText_cjs_entry = 1;

	Object.defineProperty(pText_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const typographyStyles = requireTypographyStyles136a56f3();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsedDa5fe664();
	const theme = requireThemeBfc10573();
	const textColor = requireTextColor99ae680c();
	const textSize = requireTextSize3b156bcb();
	const textWeight = requireTextWeight8f0d791a();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const fontWeightStyles = requireFontWeightStyles4b24ddd8();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const fontSizeTextXXSmall = requireFontSizeTextXXSmallA02f9c40();
	const fontSizeTextXSmall = requireFontSizeTextXSmallE59d35d7();
	const fontSizeTextSmall = requireFontSizeTextSmall508930e5();
	const fontSizeTextMedium = requireFontSizeTextMedium88887ad8();
	const fontSizeTextLarge = requireFontSizeTextLarge05a4bc90();
	const fontSizeTextXLarge = requireFontSizeTextXLarge0ecf9ef3();
	requireTextIconStylesDeb3ffbc();
	requireIsThemeAutoC90cd35d();
	requireHelperE5c4e0db();
	requireFontWeightRegularD0c768ac();
	requireFontWeightSemiBold4482c830();
	requireTextShared9135e2ef();
	requireFontLineHeight78b03658();
	requireFontVariant6ba3b7cb();

	const TEXT_TAGS = ['p', 'span', 'div', 'address', 'blockquote', 'figcaption', 'cite', 'time', 'legend'];
	const getTextTagType = (host, tag) => {
	  if (typographyStyles.hasSpecificSlottedTag(host, TEXT_TAGS.join())) {
	    return 'div';
	  }
	  else {
	    return tag;
	  }
	};

	const sizeMap = {
	  'xx-small': fontSizeTextXXSmall.fontSizeTextXXSmall,
	  'x-small': fontSizeTextXSmall.fontSizeTextXSmall,
	  small: fontSizeTextSmall.fontSizeTextSmall,
	  medium: fontSizeTextMedium.fontSizeTextMedium,
	  large: fontSizeTextLarge.fontSizeTextLarge,
	  'x-large': fontSizeTextXLarge.fontSizeTextXLarge,
	};
	const getComponentCss = (size, weight, align, color, ellipsis, theme) => {
	  return validateProps.getCss({
	    '@global': {
	      ':host': {
	        display: 'block',
	        ...validateProps.addImportantToEachRule({
	          ...colorSchemeStyles.colorSchemeStyles,
	          ...colorSchemeStyles.hostHiddenStyles,
	        }),
	      },
	      '::slotted': {
	        [TEXT_TAGS.map((i) => `&(${i})`).join()]: validateProps.addImportantToEachRule(typographyStyles.getTypographySlottedJssStyle()),
	      },
	    },
	    root: typographyStyles.getTypographyRootJssStyle(textSmallStyle.textSmallStyle, validateProps.buildResponsiveStyles(size, (sizeValue) => ({
	      fontSize: sizeValue === 'inherit' ? sizeValue : sizeMap[sizeValue],
	      fontWeight: fontWeightStyles.getFontWeight(weight),
	    })), align, color, ellipsis, theme),
	  });
	};

	const propTypes = {
	  tag: validateProps.AllowedTypes.oneOf(TEXT_TAGS),
	  size: validateProps.AllowedTypes.breakpoint(textSize.TEXT_SIZES),
	  weight: validateProps.AllowedTypes.oneOf(textWeight.TEXT_WEIGHTS),
	  align: validateProps.AllowedTypes.oneOf(typographyStyles.TEXT_ALIGNS),
	  color: validateProps.AllowedTypes.oneOf(textColor.TEXT_COLORS),
	  ellipsis: validateProps.AllowedTypes.boolean,
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Text = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.tag = 'p';
	    this.size = 'small';
	    this.weight = 'regular';
	    this.align = 'left';
	    this.color = 'primary';
	    this.ellipsis = false;
	    this.theme = 'light';
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    const colorDeprecationMap = {
	      brand: 'primary',
	      default: 'primary',
	      'neutral-contrast-low': 'contrast-low',
	      'neutral-contrast-medium': 'contrast-medium',
	      'neutral-contrast-high': 'contrast-high',
	      'notification-neutral': 'notification-info',
	    };
	    warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'color', colorDeprecationMap);
	    const weightDeprecationMap = {
	      thin: 'regular',
	      semibold: 'semi-bold',
	    };
	    warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'weight', weightDeprecationMap);
	    validateProps.attachComponentCss(this.host, getComponentCss, this.size, (weightDeprecationMap[this.weight] || this.weight), this.align, (colorDeprecationMap[this.color] || this.color), this.ellipsis, this.theme);
	    const TagType = getTextTagType(this.host, this.tag);
	    return (validateProps.h(TagType, { class: "root" }, validateProps.h("slot", null)));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	pText_cjs_entry.p_text = Text;

	
	return pText_cjs_entry;
}

var pTextareaWrapper_cjs_entry = {};

var hasRequiredPTextareaWrapper_cjs_entry;

function requirePTextareaWrapper_cjs_entry () {
	if (hasRequiredPTextareaWrapper_cjs_entry) return pTextareaWrapper_cjs_entry;
	hasRequiredPTextareaWrapper_cjs_entry = 1;

	Object.defineProperty(pTextareaWrapper_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const required = requireRequiredBc18b612();
	const hasDescription = requireHasDescriptionA19e4bdc();
	const isRequiredAndParentNotRequired = requireIsRequiredAndParentNotRequired0b84c8cc();
	const warnIfDeprecatedPropIsUsed = requireWarnIfDeprecatedPropIsUsed3a5c494c();
	const theme = requireThemeBfc10573();
	const getOnlyChildOfKindHTMLElementOrThrow = requireGetOnlyChildOfKindHTMLElementOrThrowF6972c1c();
	const formStyles = requireFormStyles97f2cdf7();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const textSmallStyle = requireTextSmallStyle7246779a();
	const spacingStaticMedium = requireSpacingStaticMedium94812711();
	requireHasNamedSlot28c6bca1();
	requireGetNamedSlotA433c432();
	requireSpacingStaticXSmallB7d708b8();
	requireIsParentFieldsetRequired6f3a68ad();
	requireIsParentOfKindA9c351f2();
	requireHelperE5c4e0db();
	requireGetDirectChildHTMLElements0adb2021();
	requireGetHTMLElements21fc87cc();
	requireTransformSelectorToDirectChildSelector08da8668();
	requireHoverMediaQueryF2ccfc24();
	requireFontSizeTextXSmallE59d35d7();
	requireFontLineHeight78b03658();
	requireSpacingStaticSmall2130ed04();
	requireBorderRadiusSmall5f37fc45();
	requireTextShared9135e2ef();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();

	const spacingStaticLarge = '32px';

	const getComponentCss = (isDisabled, hideLabel, state, hasCounter, theme) => {
	  const { contrastMediumColor } = validateProps.getThemedColors(theme);
	  const { contrastMediumColor: contrastMediumColorDark } = validateProps.getThemedColors('dark');
	  return validateProps.getCss({
	    '@global': {
	      ':host': validateProps.addImportantToEachRule({
	        display: 'block',
	        ...colorSchemeStyles.colorSchemeStyles,
	        ...colorSchemeStyles.hostHiddenStyles,
	      }),
	      ...validateProps.mergeDeep(validateProps.addImportantToEachRule(formStyles.getBaseChildStyles('textarea', state, theme, {
	        font: textSmallStyle.textSmallStyle.font,
	        padding: hasCounter ? `12px ${spacingStaticMedium.spacingStaticMedium} ${spacingStaticLarge}` : `12px ${spacingStaticMedium.spacingStaticMedium}`,
	      })), {
	        '::slotted(textarea)': {
	          height: 'auto',
	          minHeight: '200px',
	          resize: 'vertical', // overridable, too
	        },
	      }),
	    },
	    ...formStyles.getLabelStyles('textarea', isDisabled, hideLabel, state, theme, hasCounter && {
	      counter: {
	        position: 'absolute',
	        bottom: '6px',
	        right: '12px',
	        zIndex: 1,
	        font: textSmallStyle.textSmallStyle.font,
	        color: contrastMediumColor,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          color: contrastMediumColorDark,
	        }),
	      },
	    }),
	    ...required.getFunctionalComponentRequiredStyles(),
	    ...required.getFunctionalComponentStateMessageStyles(theme, state),
	    ...(hasCounter && {
	      'sr-only': {
	        ...validateProps.getHiddenTextJssStyle(),
	        padding: 0,
	      },
	    }),
	  });
	};

	const propTypes = {
	  label: validateProps.AllowedTypes.string,
	  description: validateProps.AllowedTypes.string,
	  state: validateProps.AllowedTypes.oneOf(required.FORM_STATES),
	  message: validateProps.AllowedTypes.string,
	  hideLabel: validateProps.AllowedTypes.breakpoint('boolean'),
	  showCharacterCount: validateProps.AllowedTypes.boolean,
	  showCounter: validateProps.AllowedTypes.boolean,
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const TextareaWrapper = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.onLabelClick = () => {
	      this.textarea.focus();
	    };
	    this.observeAttributes = () => {
	      validateProps.observeAttributes(this.textarea, ['disabled', 'readonly', 'required'], () => validateProps.forceUpdate(this.host));
	    };
	    this.label = '';
	    this.description = '';
	    this.state = 'none';
	    this.message = '';
	    this.hideLabel = false;
	    this.showCharacterCount = undefined;
	    this.showCounter = true;
	    this.theme = 'light';
	  }
	  connectedCallback() {
	    this.observeAttributes(); // on every reconnect
	  }
	  componentWillLoad() {
	    this.textarea = getOnlyChildOfKindHTMLElementOrThrow.getOnlyChildOfKindHTMLElementOrThrow(this.host, 'textarea');
	    this.observeAttributes(); // once initially
	    this.hasCounter =
	      validateProps.hasCounter(this.textarea) &&
	        (typeof this.showCharacterCount === 'undefined' ? this.showCounter : this.showCharacterCount);
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  componentDidLoad() {
	    if (this.hasCounter) {
	      validateProps.addInputEventListenerForCounter(this.textarea, this.ariaElement, this.counterElement);
	    }
	  }
	  componentDidRender() {
	    /*
	     * This is a workaround to improve accessibility because the textarea and the label/description/message text are placed in different DOM.
	     * Referencing ID's from outside the component is impossible because the web component’s DOM is separate.
	     * We have to wait for full support of the Accessibility Object Model (AOM) to provide the relationship between shadow DOM and slots.
	     */
	    validateProps.setAriaAttributes(this.textarea, {
	      label: this.label,
	      message: this.message || this.description,
	      state: this.state,
	    });
	  }
	  disconnectedCallback() {
	    validateProps.unobserveAttributes(this.textarea);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    warnIfDeprecatedPropIsUsed.warnIfDeprecatedPropIsUsed(this, 'showCharacterCount', 'Please use showCounter prop instead.');
	    validateProps.attachComponentCss(this.host, getComponentCss, this.textarea.disabled, this.hideLabel, this.state, this.hasCounter, this.theme);
	    const labelProps = {
	      onClick: this.onLabelClick,
	    };
	    return (validateProps.h(validateProps.Host, null, validateProps.h("label", { class: "label" }, required.hasLabel(this.host, this.label) && (validateProps.h("span", { class: "label__text", ...labelProps }, this.label || validateProps.h("slot", { name: "label" }), isRequiredAndParentNotRequired.isRequiredAndParentNotRequired(this.host, this.textarea) && validateProps.h(required.Required, null))), hasDescription.hasDescription(this.host, this.description) && (validateProps.h("span", { class: "label__text", ...labelProps }, this.description || validateProps.h("slot", { name: "description" }))), this.hasCounter && validateProps.h("span", { class: "counter", "aria-hidden": "true", ref: (el) => (this.counterElement = el) }), validateProps.h("slot", null), this.hasCounter && validateProps.h("span", { class: "sr-only", ref: (el) => (this.ariaElement = el), "aria-live": "polite" })), required.hasMessage(this.host, this.message, this.state) && (validateProps.h(required.StateMessage, { state: this.state, message: this.message, theme: this.theme, host: this.host }))));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	pTextareaWrapper_cjs_entry.p_textarea_wrapper = TextareaWrapper;

	
	return pTextareaWrapper_cjs_entry;
}

var pToast_2_cjs_entry = {};

var hasRequiredPToast_2_cjs_entry;

function requirePToast_2_cjs_entry () {
	if (hasRequiredPToast_2_cjs_entry) return pToast_2_cjs_entry;
	hasRequiredPToast_2_cjs_entry = 1;

	Object.defineProperty(pToast_2_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const constants = requireConstantsCa271244();
	const gridExtendedOffsetBase = requireGridExtendedOffsetBaseFb9830f6();
	const theme = requireThemeBfc10573();
	const warnIfDeprecatedPropValueIsUsed = requireWarnIfDeprecatedPropValueIsUsedDa5fe664();
	const throwIfRootNodeIsNotOneOfKind = requireThrowIfRootNodeIsNotOneOfKindB4d3ea18();
	const isThemeAuto = requireIsThemeAutoC90cd35d();
	const inlineNotificationUtils = requireInlineNotificationUtilsAc1154ad();
	const dropShadowHighStyle = requireDropShadowHighStyle7edcadc6();
	const textSmallStyle = requireTextSmallStyle7246779a();
	requireHelperE5c4e0db();
	requireSpacingStaticMedium94812711();
	requireBorderRadiusSmall5f37fc45();
	requireSpacingStaticXSmallB7d708b8();
	requireSpacingStaticSmall2130ed04();
	requireGetMediaQueryMax2587ee0a();
	requireBannerUtils2cc83734();
	requireDropShadowShared6e50faf3();
	requireTextShared9135e2ef();
	requireFontLineHeight78b03658();
	requireFontWeightRegularD0c768ac();
	requireFontVariant6ba3b7cb();
	requireFontSizeTextSmall508930e5();

	const cssVariablePositionBottom = '--p-toast-position-bottom'; // CSS custom property exposed as public interface
	const cssVariablePositionBottomInternal = '--p-internal-toast-position-bottom';
	const easeInQuad = 'cubic-bezier(0.45,0,0.55,1)';
	const easeOutQuad = 'cubic-bezier(0.5,1,0.89,1)';
	const ANIMATION_DURATION = 600;
	const duration = `${ANIMATION_DURATION}ms`;
	const getKeyframes = (direction, outsideStyle) => {
	  const insideStyle = { opacity: 1, transform: 'translate3d(0,0,0)' };
	  return direction === 'in'
	    ? {
	      from: outsideStyle,
	      to: insideStyle,
	    }
	    : {
	      from: insideStyle,
	      to: outsideStyle,
	    };
	};
	const getKeyframesMobile = (direction, bottomVar) => getKeyframes(direction, {
	  opacity: 0,
	  transform: `translate3d(0,calc(var(${bottomVar}) + 100%),0)`, // space before and after "+" is crucial
	});
	const toastCloseClassName = 'close';
	const getComponentCss$1 = () => {
	  return validateProps.getCss({
	    '@global': {
	      ':host': validateProps.addImportantToEachRule({
	        position: 'fixed',
	        left: gridExtendedOffsetBase.gridExtendedOffsetBase,
	        right: gridExtendedOffsetBase.gridExtendedOffsetBase,
	        // Needs a not overridable internal css variable to cover default position depending on viewport size and to handle animation properly.
	        // In addition, a public css variable can be passed to overwrite the default position.
	        [cssVariablePositionBottomInternal]: `var(${cssVariablePositionBottom}, 56px)`,
	        bottom: `var(${cssVariablePositionBottomInternal})`,
	        maxWidth: '42rem',
	        zIndex: constants.TOAST_Z_INDEX,
	        [validateProps.getMediaQueryMin('s')]: {
	          left: '64px',
	          right: 'auto',
	          [cssVariablePositionBottomInternal]: `var(${cssVariablePositionBottom}, 64px)`,
	          bottom: `var(${cssVariablePositionBottomInternal})`,
	        },
	        ...colorSchemeStyles.colorSchemeStyles,
	        ...colorSchemeStyles.hostHiddenStyles,
	      }),
	      '@keyframes in': getKeyframesMobile('in', cssVariablePositionBottomInternal),
	      '@keyframes out': getKeyframesMobile('out', cssVariablePositionBottomInternal),
	    },
	    hydrated: {
	      animation: `${duration} $in ${easeInQuad} forwards`,
	    },
	    [toastCloseClassName]: {
	      animation: validateProps.addImportantToRule(`${ANIMATION_DURATION}ms $out ${easeOutQuad} forwards`),
	    },
	  });
	};

	const TOAST_DEFAULT_TIMEOUT = 6000;
	class ToastManagerClass {
	  constructor() {
	    this.dismissToastItem = () => {
	      this.removeTimeout();
	      this.message = undefined;
	      this.onDismissCallback();
	      setTimeout(() => validateProps.forceUpdate(this.toastEl), 
	      // respect --p-temporary-toast-timeout css variable to override timeout during e2e and vrt tests
	      ANIMATION_DURATION
	        );
	    };
	  }
	  register(toastElement, onDismiss) {
	    if (this.toastEl) {
	      validateProps.throwException('p-toast was rendered multiple times.');
	    }
	    this.toastEl = toastElement;
	    this.onDismissCallback = onDismiss;
	  }
	  unregister() {
	    this.toastEl = null;
	    this.message = undefined;
	    this.removeTimeout();
	  }
	  addMessage(message) {
	    if (!this.toastEl) {
	      validateProps.throwException('missing p-toast element.');
	    }
	    if (!message.text) {
	      validateProps.throwException('p-toast empty text provided to addMessage().');
	    }
	    const msg = {
	      state: message.state || 'info',
	      text: message.text.replace(/<(?!br)[^>]*>/g, ''), // strip all html tags except linebreaks
	    };
	    if (!this.message) {
	      validateProps.forceUpdate(this.toastEl);
	    }
	    else if (this.message.text !== message.text) {
	      this.dismissToastItem();
	    }
	    this.message = msg;
	  }
	  getToast() {
	    this.startTimeout();
	    return this.message;
	  }
	  startTimeout() {
	    if (this.message) {
	      {
	        this.timeout = setTimeout(this.dismissToastItem, TOAST_DEFAULT_TIMEOUT);
	      }
	    }
	  }
	  removeTimeout() {
	    clearTimeout(this.timeout);
	    this.timeout = null;
	  }
	}
	const toastManager = new ToastManagerClass();

	const propTypes$1 = {
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const Toast = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.theme = 'light';
	  }
	  addMessage(message) {
	    toastManager.addMessage(message);
	  }
	  connectedCallback() {
	    toastManager.register(this.host, () => this.toastItemElement.classList.add(toastCloseClassName));
	  }
	  componentDidLoad() {
	    this.host.addEventListener('dismiss', (e) => {
	      e.stopPropagation();
	      toastManager.dismissToastItem();
	    });
	  }
	  componentShouldUpdate(_, __, propName) {
	    return propName !== 'theme';
	  }
	  disconnectedCallback() {
	    toastManager.unregister();
	  }
	  render() {
	    validateProps.validateProps(this, propTypes$1);
	    validateProps.attachComponentCss(this.host, getComponentCss$1);
	    this.toastItemElement?.classList.remove(toastCloseClassName);
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    const toast = toastManager.getToast();
	    return (validateProps.h(validateProps.Host, null, toast && (validateProps.h(PrefixedTagNames.pToastItem, { ...toast, theme: this.theme, ref: (el) => (this.toastItemElement = el) }))));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	/** @deprecated */
	const TOAST_STATES_DEPRECATED = ['neutral']; // state neutral as default state is deprecated in v3 (new state: 'info')
	const TOAST_STATES = ['info', 'success', ...TOAST_STATES_DEPRECATED];

	const getComponentCss = (state, theme) => {
	  return validateProps.getCss({
	    '@global': {
	      ':host': {
	        ...inlineNotificationUtils.getNotificationRootJssStyle(state, false, true, theme),
	        ...dropShadowHighStyle.dropShadowHighStyle,
	      },
	      p: {
	        ...textSmallStyle.textSmallStyle,
	        margin: 0,
	        color: validateProps.getThemedColors(theme).primaryColor,
	        ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	          color: validateProps.getThemedColors('dark').primaryColor,
	        }),
	      },
	    },
	    icon: inlineNotificationUtils.getNotificationIconJssStyle(),
	    content: inlineNotificationUtils.getNotificationContentJssStyle(),
	  });
	};

	const propTypes = {
	  text: validateProps.AllowedTypes.string,
	  state: validateProps.AllowedTypes.oneOf(TOAST_STATES),
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	};
	const ToastItem = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.dismiss = validateProps.createEvent(this, "dismiss", 7);
	    this.text = '';
	    this.state = 'info';
	    this.theme = 'light';
	  }
	  connectedCallback() {
	    throwIfRootNodeIsNotOneOfKind.throwIfRootNodeIsNotOneOfKind(this.host, ['p-toast']);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    warnIfDeprecatedPropValueIsUsed.warnIfDeprecatedPropValueIsUsed(this, 'state', {
	      neutral: 'info',
	    });
	    validateProps.attachComponentCss(this.host, getComponentCss, this.state, this.theme);
	    const toastId = 'toast';
	    const PrefixedTagNames = validateProps.getPrefixedTagNames(this.host);
	    return (validateProps.h(validateProps.Host, null, validateProps.h(PrefixedTagNames.pIcon, { class: "icon", name: inlineNotificationUtils.getInlineNotificationIconName(this.state), color: `notification-${this.state}`, theme: this.theme, "aria-hidden": "true" }), validateProps.h("p", { id: toastId, class: "content", role: "status", "aria-live": "polite", innerHTML: this.text }), validateProps.h(PrefixedTagNames.pButtonPure, { theme: this.theme, class: "close", type: "button", icon: "close", hideLabel: true, "aria-controls": toastId, onClick: this.dismiss.emit }, "Close notification message")));
	  }
	  get host() { return validateProps.getElement(this); }
	};

	pToast_2_cjs_entry.p_toast = Toast;
	pToast_2_cjs_entry.p_toast_item = ToastItem;

	
	return pToast_2_cjs_entry;
}

var pWordmark_cjs_entry = {};

var hasRequiredPWordmark_cjs_entry;

function requirePWordmark_cjs_entry () {
	if (hasRequiredPWordmark_cjs_entry) return pWordmark_cjs_entry;
	hasRequiredPWordmark_cjs_entry = 1;

	Object.defineProperty(pWordmark_cjs_entry, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const linkAriaAttribute = requireLinkAriaAttribute5de11e89();
	const theme = requireThemeBfc10573();
	const colorSchemeStyles = requireColorSchemeStyles81696be8();
	const isThemeAuto = requireIsThemeAutoC90cd35d();

	const WORDMARK_SIZES = ['small', 'inherit'];

	const getComponentCss = (size, theme) => {
	  return validateProps.getCss({
	    '@global': {
	      ':host': {
	        position: 'relative',
	        display: 'inline-block',
	        verticalAlign: 'top',
	        ...validateProps.addImportantToEachRule({
	          outline: 0,
	          maxWidth: '100%',
	          maxHeight: '100%',
	          boxSizing: 'content-box',
	          ...(size !== 'inherit' && {
	            height: 'clamp(0.63rem, 0.42vw + 0.5rem, 1rem)',
	            // workaround for Safari to optimize image rendering
	            '@supports (height: round(down, 1px, 1px))': {
	              height: 'round(down, clamp(0.63rem, 0.42vw + 0.5rem, 1rem), 1px)',
	            },
	          }),
	          ...colorSchemeStyles.colorSchemeStyles,
	          ...colorSchemeStyles.hostHiddenStyles,
	        }),
	      },
	      'a, svg': {
	        display: 'block',
	        maxWidth: '100%',
	        maxHeight: '100%',
	        height: 'inherit',
	      },
	      a: {
	        textDecoration: 'none',
	        ...validateProps.focusPseudoJssStyle,
	      },
	      svg: validateProps.isHighContrastMode
	        ? {
	          fill: validateProps.getHighContrastColors().canvasTextColor,
	        }
	        : {
	          fill: validateProps.getThemedColors(theme).primaryColor,
	          ...isThemeAuto.prefersColorSchemeDarkMediaQuery(theme, {
	            fill: validateProps.getThemedColors('dark').primaryColor,
	          }),
	        },
	    },
	  });
	};

	const propTypes = {
	  size: validateProps.AllowedTypes.oneOf(WORDMARK_SIZES),
	  theme: validateProps.AllowedTypes.oneOf(theme.THEMES),
	  href: validateProps.AllowedTypes.string,
	  target: validateProps.AllowedTypes.string,
	  aria: validateProps.AllowedTypes.aria(linkAriaAttribute.LINK_ARIA_ATTRIBUTES),
	};
	const Wordmark = class {
	  constructor(hostRef) {
	    validateProps.registerInstance(this, hostRef);
	    this.size = 'small';
	    this.theme = 'light';
	    this.href = undefined;
	    this.target = '_self';
	    this.aria = undefined;
	  }
	  componentShouldUpdate(newVal, oldVal) {
	    return validateProps.hasPropValueChanged(newVal, oldVal);
	  }
	  render() {
	    validateProps.validateProps(this, propTypes);
	    validateProps.attachComponentCss(this.host, getComponentCss, this.size, this.theme);
	    // optimized with SVGO, see docs in assets folder
	    const svg = (validateProps.h("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 4500 300" }, validateProps.h("title", null, "Porsche"), validateProps.h("path", { d: "M502 221c48.1 0 74-25.9 74-74V74c0-48.1-25.9-74-74-74H0v300h68v-79h434zm6-143v65c0 7.8-4.2 12-12 12H68V66h428c7.8 0 12 4.2 12 12zm228 222c-48.1 0-74-25.9-74-74V74c0-48.1 25.9-74 74-74h417c48.1 0 74 25.9 74 74v152c0 48.1-25.9 74-74 74H736zm411-66c7.8 0 12-4.2 12-12V78c0-7.8-4.2-12-12-12H742c-7.8 0-12 4.2-12 12v144c0 7.8 4.2 12 12 12h405zm675-36c39.844 16.757 67.853 56.1 68 102h-68c0-54-25-79-79-79h-361v79h-68V0h502c48.1 0 74 25.9 74 74v50.14c0 46.06-23.75 71.76-68 73.86zm-12-43c7.8 0 12-4.2 12-12V78c0-7.8-4.2-12-12-12h-428v89h428zm162-81c0-48.1 25.9-74 74-74h492v56h-486c-7.8 0-12 4.2-12 12v42c0 7.8 4.2 12 12 12h422c48.1 0 74 25.9 74 74v30c0 48.1-25.9 74-74 74h-492v-56h486c7.8 0 12-4.2 12-12v-42c0-7.8-4.2-12-12-12h-422c-48.1 0-74-25.9-74-74V74zm661 0c0-48.1 25.9-74 74-74h480v66h-474c-7.8 0-12 4.2-12 12v144c0 7.8 4.2 12 12 12h474v66h-480c-48.1 0-74-25.9-74-74V74zM3817 0v300h-68V183h-407v117h-68V0h68v117h407V0h68zm156 56v66h527v56h-527v66h527v56h-595V0h595v56h-527z" })));
	    return (validateProps.h(validateProps.Host, null, this.href === undefined ? (svg) : (validateProps.h("a", { href: this.href, target: this.target, ...validateProps.parseAndGetAriaAttributes(this.aria) }, svg))));
	  }
	  static get delegatesFocus() { return true; }
	  get host() { return validateProps.getElement(this); }
	};

	pWordmark_cjs_entry.p_wordmark = Wordmark;

	
	return pWordmark_cjs_entry;
}

var porscheDesignSystem_cjs = {};

var hasRequiredPorscheDesignSystem_cjs;

function requirePorscheDesignSystem_cjs () {
	if (hasRequiredPorscheDesignSystem_cjs) return porscheDesignSystem_cjs;
	hasRequiredPorscheDesignSystem_cjs = 1;

	Object.defineProperty(porscheDesignSystem_cjs, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const appGlobals = requireAppGlobalsBaf8fc74();
	requireGetCDNBaseURLE7722df3();

	/*
	 Stencil Client Patch Browser v4.2.0 | MIT Licensed | https://stenciljs.com
	 */
	const patchBrowser = () => {
	    const importMeta = (typeof document === 'undefined' ? new (createCommonjsRequire("/src/lib")('u' + 'rl').URL)('file:' + __filename).href : (document.currentScript && document.currentScript.src || new URL('porsche-design-system.cjs.js', document.baseURI).href));
	    const opts = {};
	    if (importMeta !== '') {
	        opts.resourcesUrl = new URL('.', importMeta).href;
	    }
	    return validateProps.promiseResolve(opts);
	};

	patchBrowser().then(options => {
	  if(!window.PDS_SKIP_FETCH) { appGlobals.globalScripts(); }
	  return validateProps.bootstrapLazy(JSON.parse("[[\"p-table_7.cjs\",[[1,\"p-table\",{\"caption\":[1],\"theme\":[1]}],[1,\"p-table-body\"],[1,\"p-table-cell\",{\"multiline\":[4]}],[1,\"p-table-head\"],[1,\"p-table-head-cell\",{\"sort\":[16],\"hideLabel\":[4,\"hide-label\"],\"multiline\":[4]}],[1,\"p-table-head-row\"],[1,\"p-table-row\"]]],[\"p-flex_2.cjs\",[[1,\"p-flex\",{\"inline\":[8],\"wrap\":[1],\"direction\":[1],\"justifyContent\":[1,\"justify-content\"],\"alignItems\":[1,\"align-items\"],\"alignContent\":[1,\"align-content\"]}],[1,\"p-flex-item\",{\"width\":[1],\"offset\":[1],\"alignSelf\":[1,\"align-self\"],\"grow\":[8],\"shrink\":[8],\"flex\":[1]}]]],[\"p-grid_2.cjs\",[[1,\"p-grid\",{\"direction\":[1],\"wrap\":[1],\"gutter\":[8]}],[1,\"p-grid-item\",{\"size\":[8],\"offset\":[8]}]]],[\"p-multi-select_2.cjs\",[[1,\"p-multi-select\",{\"label\":[1],\"description\":[1],\"name\":[1],\"value\":[1040],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"disabled\":[4],\"required\":[4],\"dropdownDirection\":[1,\"dropdown-direction\"],\"theme\":[1],\"isOpen\":[32],\"srHighlightedOptionText\":[32],\"hasFilterResults\":[32]},[[0,\"internalOptionUpdate\",\"updateOptionHandler\"]]],[1,\"p-multi-select-option\",{\"value\":[1],\"disabled\":[4]}]]],[\"p-segmented-control_2.cjs\",[[1,\"p-segmented-control\",{\"backgroundColor\":[1,\"background-color\"],\"theme\":[1],\"value\":[8],\"columns\":[8]}],[17,\"p-segmented-control-item\",{\"value\":[8],\"disabled\":[4],\"label\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"]},[[2,\"click\",\"onClick\"]]]]],[\"p-select-wrapper_2.cjs\",[[1,\"p-select-wrapper\",{\"label\":[1],\"description\":[1],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"filter\":[4],\"theme\":[1],\"dropdownDirection\":[1,\"dropdown-direction\"],\"native\":[4]}],[1,\"p-select-wrapper-dropdown\",{\"selectRef\":[16],\"label\":[1],\"description\":[1],\"message\":[1],\"state\":[1],\"direction\":[1],\"theme\":[1],\"filter\":[4],\"required\":[4],\"disabled\":[4],\"onOpenChange\":[16],\"isOpenOverride\":[4,\"is-open-override\"],\"isOpen\":[32],\"optionMaps\":[32],\"searchString\":[32]}]]],[\"p-stepper-horizontal_2.cjs\",[[1,\"p-stepper-horizontal\",{\"size\":[1],\"theme\":[1]}],[17,\"p-stepper-horizontal-item\",{\"state\":[1],\"disabled\":[4]},[[2,\"click\",\"onClick\"]]]]],[\"p-tabs_2.cjs\",[[1,\"p-tabs\",{\"size\":[1],\"weight\":[1],\"theme\":[1],\"gradientColorScheme\":[1,\"gradient-color-scheme\"],\"gradientColor\":[1,\"gradient-color\"],\"activeTabIndex\":[1026,\"active-tab-index\"],\"tabsItemElements\":[32]}],[1,\"p-tabs-item\",{\"label\":[1]}]]],[\"p-text-list_2.cjs\",[[1,\"p-text-list\",{\"listType\":[1,\"list-type\"],\"orderType\":[1,\"order-type\"],\"type\":[1],\"theme\":[1]}],[1,\"p-text-list-item\"]]],[\"p-toast_2.cjs\",[[1,\"p-toast\",{\"theme\":[1],\"addMessage\":[64]}],[1,\"p-toast-item\",{\"text\":[1],\"state\":[1],\"theme\":[1]}]]],[\"p-accordion.cjs\",[[1,\"p-accordion\",{\"size\":[1],\"theme\":[1],\"heading\":[1],\"tag\":[1],\"open\":[4],\"compact\":[4]}]]],[\"p-banner.cjs\",[[1,\"p-banner\",{\"open\":[4],\"heading\":[1],\"description\":[1],\"state\":[1],\"dismissButton\":[4,\"dismiss-button\"],\"persistent\":[4],\"width\":[1],\"theme\":[1]}]]],[\"p-button.cjs\",[[17,\"p-button\",{\"type\":[1],\"disabled\":[4],\"loading\":[4],\"variant\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"hideLabel\":[8,\"hide-label\"],\"theme\":[1],\"aria\":[1]},[[2,\"click\",\"onClick\"]]]]],[\"p-button-group.cjs\",[[1,\"p-button-group\",{\"direction\":[1]}]]],[\"p-button-pure.cjs\",[[17,\"p-button-pure\",{\"type\":[1],\"disabled\":[4],\"loading\":[4],\"size\":[1],\"weight\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"active\":[4],\"hideLabel\":[8,\"hide-label\"],\"alignLabel\":[1,\"align-label\"],\"stretch\":[8],\"theme\":[1],\"aria\":[1]},[[2,\"click\",\"onClick\"]]]]],[\"p-button-tile.cjs\",[[17,\"p-button-tile\",{\"size\":[1],\"weight\":[1],\"background\":[1],\"aspectRatio\":[1,\"aspect-ratio\"],\"label\":[1],\"description\":[1],\"align\":[1],\"gradient\":[4],\"compact\":[1032],\"type\":[1],\"disabled\":[4],\"loading\":[4],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"aria\":[1]},[[2,\"click\",\"onClick\"]]]]],[\"p-carousel.cjs\",[[1,\"p-carousel\",{\"heading\":[1],\"description\":[1],\"alignHeader\":[1,\"align-header\"],\"rewind\":[4],\"wrapContent\":[4,\"wrap-content\"],\"width\":[1],\"slidesPerPage\":[1032,\"slides-per-page\"],\"disablePagination\":[1032,\"disable-pagination\"],\"pagination\":[1032],\"intl\":[1],\"theme\":[1],\"activeSlideIndex\":[2,\"active-slide-index\"],\"skipLinkTarget\":[1,\"skip-link-target\"],\"amountOfPages\":[32]}]]],[\"p-checkbox-wrapper.cjs\",[[1,\"p-checkbox-wrapper\",{\"label\":[1],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"loading\":[4],\"theme\":[1]},[[0,\"keydown\",\"onKeydown\"]]]]],[\"p-content-wrapper.cjs\",[[1,\"p-content-wrapper\",{\"width\":[1],\"backgroundColor\":[1,\"background-color\"],\"theme\":[1]}]]],[\"p-crest.cjs\",[[17,\"p-crest\",{\"href\":[1],\"target\":[1],\"aria\":[1]}]]],[\"p-display.cjs\",[[1,\"p-display\",{\"tag\":[1],\"size\":[1],\"align\":[1],\"color\":[1],\"ellipsis\":[4],\"theme\":[1]}]]],[\"p-divider.cjs\",[[1,\"p-divider\",{\"color\":[1],\"orientation\":[1],\"direction\":[1],\"theme\":[1]}]]],[\"p-fieldset.cjs\",[[1,\"p-fieldset\",{\"label\":[1],\"labelSize\":[1,\"label-size\"],\"required\":[4],\"state\":[1],\"message\":[1],\"theme\":[1]}]]],[\"p-fieldset-wrapper.cjs\",[[1,\"p-fieldset-wrapper\",{\"label\":[1],\"labelSize\":[1,\"label-size\"],\"required\":[4],\"state\":[1],\"message\":[1],\"theme\":[1]}]]],[\"p-flyout.cjs\",[[1,\"p-flyout\",{\"open\":[4],\"position\":[1],\"theme\":[1],\"aria\":[1]}]]],[\"p-heading.cjs\",[[1,\"p-heading\",{\"tag\":[1],\"size\":[1],\"align\":[1],\"color\":[1],\"ellipsis\":[4],\"theme\":[1]}]]],[\"p-headline.cjs\",[[1,\"p-headline\",{\"variant\":[1],\"tag\":[1],\"align\":[1],\"color\":[1],\"ellipsis\":[4],\"theme\":[1]}]]],[\"p-icon.cjs\",[[1,\"p-icon\",{\"name\":[1],\"source\":[1],\"color\":[1],\"size\":[1],\"lazy\":[4],\"theme\":[1],\"aria\":[1]}]]],[\"p-inline-notification.cjs\",[[1,\"p-inline-notification\",{\"heading\":[1],\"description\":[1],\"state\":[1],\"dismissButton\":[4,\"dismiss-button\"],\"persistent\":[4],\"actionLabel\":[1,\"action-label\"],\"actionLoading\":[4,\"action-loading\"],\"actionIcon\":[1,\"action-icon\"],\"theme\":[1]}]]],[\"p-link.cjs\",[[17,\"p-link\",{\"variant\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"href\":[1],\"theme\":[1],\"target\":[1],\"download\":[1],\"rel\":[1],\"hideLabel\":[8,\"hide-label\"],\"aria\":[1]}]]],[\"p-link-pure.cjs\",[[17,\"p-link-pure\",{\"alignLabel\":[1,\"align-label\"],\"stretch\":[8],\"size\":[1],\"weight\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"underline\":[4],\"href\":[1],\"active\":[4],\"hideLabel\":[8,\"hide-label\"],\"theme\":[1],\"target\":[1],\"download\":[1],\"rel\":[1],\"aria\":[1]}]]],[\"p-link-social.cjs\",[[17,\"p-link-social\",{\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"href\":[1],\"theme\":[1],\"target\":[1],\"rel\":[1],\"hideLabel\":[8,\"hide-label\"]}]]],[\"p-link-tile.cjs\",[[17,\"p-link-tile\",{\"size\":[1],\"weight\":[1],\"background\":[1],\"aspectRatio\":[1,\"aspect-ratio\"],\"label\":[1],\"description\":[1],\"align\":[1],\"gradient\":[4],\"compact\":[1032],\"href\":[1],\"target\":[1],\"download\":[1],\"rel\":[1],\"aria\":[1]}]]],[\"p-link-tile-model-signature.cjs\",[[1,\"p-link-tile-model-signature\",{\"model\":[1],\"weight\":[1],\"aspectRatio\":[1,\"aspect-ratio\"],\"heading\":[1],\"description\":[1],\"linkDirection\":[1,\"link-direction\"],\"headingTag\":[1,\"heading-tag\"]}]]],[\"p-marque.cjs\",[[17,\"p-marque\",{\"trademark\":[4],\"variant\":[1],\"size\":[1],\"href\":[1],\"target\":[1],\"aria\":[1]}]]],[\"p-modal.cjs\",[[1,\"p-modal\",{\"open\":[4],\"disableCloseButton\":[4,\"disable-close-button\"],\"dismissButton\":[4,\"dismiss-button\"],\"disableBackdropClick\":[4,\"disable-backdrop-click\"],\"heading\":[1],\"fullscreen\":[8],\"aria\":[1]}]]],[\"p-model-signature.cjs\",[[1,\"p-model-signature\",{\"model\":[1],\"size\":[1],\"color\":[1],\"theme\":[1]}]]],[\"p-pagination.cjs\",[[17,\"p-pagination\",{\"totalItemsCount\":[2,\"total-items-count\"],\"itemsPerPage\":[2,\"items-per-page\"],\"activePage\":[1026,\"active-page\"],\"maxNumberOfPageLinks\":[8,\"max-number-of-page-links\"],\"showLastPage\":[4,\"show-last-page\"],\"allyLabel\":[1,\"ally-label\"],\"allyLabelPrev\":[1,\"ally-label-prev\"],\"allyLabelPage\":[1,\"ally-label-page\"],\"allyLabelNext\":[1,\"ally-label-next\"],\"intl\":[1],\"theme\":[1],\"breakpointMaxNumberOfPageLinks\":[32]}]]],[\"p-pin-code.cjs\",[[1,\"p-pin-code\",{\"label\":[1],\"description\":[1],\"name\":[1],\"length\":[2],\"hideLabel\":[8,\"hide-label\"],\"state\":[1],\"disabled\":[4],\"loading\":[4],\"required\":[4],\"message\":[1],\"type\":[1],\"value\":[1025],\"theme\":[1]}]]],[\"p-popover.cjs\",[[1,\"p-popover\",{\"direction\":[1],\"description\":[1],\"aria\":[1],\"theme\":[1],\"open\":[32]}]]],[\"p-radio-button-wrapper.cjs\",[[1,\"p-radio-button-wrapper\",{\"label\":[1],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"loading\":[4],\"theme\":[1]}]]],[\"p-scroller.cjs\",[[1,\"p-scroller\",{\"gradientColorScheme\":[1,\"gradient-color-scheme\"],\"gradientColor\":[1,\"gradient-color\"],\"scrollToPosition\":[1025,\"scroll-to-position\"],\"scrollIndicatorPosition\":[1,\"scroll-indicator-position\"],\"alignScrollIndicator\":[1,\"align-scroll-indicator\"],\"theme\":[1],\"scrollbar\":[4],\"aria\":[1],\"isPrevHidden\":[32],\"isNextHidden\":[32]}]]],[\"p-spinner.cjs\",[[1,\"p-spinner\",{\"size\":[1],\"theme\":[1],\"aria\":[1]}]]],[\"p-switch.cjs\",[[17,\"p-switch\",{\"alignLabel\":[1,\"align-label\"],\"hideLabel\":[8,\"hide-label\"],\"stretch\":[8],\"checked\":[4],\"disabled\":[4],\"loading\":[4],\"theme\":[1]},[[2,\"click\",\"onClick\"]]]]],[\"p-tabs-bar.cjs\",[[1,\"p-tabs-bar\",{\"size\":[1],\"weight\":[1],\"theme\":[1],\"gradientColorScheme\":[1,\"gradient-color-scheme\"],\"gradientColor\":[1,\"gradient-color\"],\"activeTabIndex\":[1026,\"active-tab-index\"],\"tabElements\":[32]}]]],[\"p-tag.cjs\",[[1,\"p-tag\",{\"theme\":[1],\"color\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"]}]]],[\"p-tag-dismissible.cjs\",[[17,\"p-tag-dismissible\",{\"color\":[1],\"theme\":[1],\"label\":[1],\"aria\":[1]}]]],[\"p-text.cjs\",[[1,\"p-text\",{\"tag\":[1],\"size\":[1],\"weight\":[1],\"align\":[1],\"color\":[1],\"ellipsis\":[4],\"theme\":[1]}]]],[\"p-text-field-wrapper.cjs\",[[1,\"p-text-field-wrapper\",{\"label\":[1],\"unit\":[1],\"unitPosition\":[1,\"unit-position\"],\"description\":[1],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"showCharacterCount\":[4,\"show-character-count\"],\"showCounter\":[4,\"show-counter\"],\"actionIcon\":[1,\"action-icon\"],\"actionLoading\":[4,\"action-loading\"],\"showPasswordToggle\":[4,\"show-password-toggle\"],\"theme\":[1],\"showPassword\":[32],\"isClearable\":[32]}]]],[\"p-textarea-wrapper.cjs\",[[1,\"p-textarea-wrapper\",{\"label\":[1],\"description\":[1],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"showCharacterCount\":[4,\"show-character-count\"],\"showCounter\":[4,\"show-counter\"],\"theme\":[1]}]]],[\"p-wordmark.cjs\",[[17,\"p-wordmark\",{\"size\":[1],\"theme\":[1],\"href\":[1],\"target\":[1],\"aria\":[1]}]]]]"), options);
	});

	porscheDesignSystem_cjs.setNonce = validateProps.setNonce;

	
	return porscheDesignSystem_cjs;
}

var dynamicModules;

function getDynamicModules() {
	return dynamicModules || (dynamicModules = {
		"/src/index.js": requireSrc,
		"/src/lib/align-label-fc1cc093.js": requireAlignLabelFc1cc093,
		"/src/lib/app-globals-baf8fc74.js": requireAppGlobalsBaf8fc74,
		"/src/lib/banner-utils-2cc83734.js": requireBannerUtils2cc83734,
		"/src/lib/borderRadiusLarge-a0aa3a01.js": requireBorderRadiusLargeA0aa3a01,
		"/src/lib/borderRadiusMedium-758b9411.js": requireBorderRadiusMedium758b9411,
		"/src/lib/borderRadiusSmall-5f37fc45.js": requireBorderRadiusSmall5f37fc45,
		"/src/lib/button-handling-a110f521.js": requireButtonHandlingA110f521,
		"/src/lib/button-link-pure-utils-468dbe67.js": requireButtonLinkPureUtils468dbe67,
		"/src/lib/button-type-ae0c09db.js": requireButtonTypeAe0c09db,
		"/src/lib/checkbox-radio-styles-eabaca96.js": requireCheckboxRadioStylesEabaca96,
		"/src/lib/color-scheme-styles-81696be8.js": requireColorSchemeStyles81696be8,
		"/src/lib/constants-ca271244.js": requireConstantsCa271244,
		"/src/lib/displayShared-43dd15a5.js": requireDisplayShared43dd15a5,
		"/src/lib/dropShadowHighStyle-7edcadc6.js": requireDropShadowHighStyle7edcadc6,
		"/src/lib/dropShadowShared-6e50faf3.js": requireDropShadowShared6e50faf3,
		"/src/lib/escapeHashCharacter-072604c4.js": requireEscapeHashCharacter072604c4,
		"/src/lib/fieldset-utils-1fdf9685.js": requireFieldsetUtils1fdf9685,
		"/src/lib/filtersPrimary-7e1fcfed.js": requireFiltersPrimary7e1fcfed,
		"/src/lib/font-weight-styles-4b24ddd8.js": requireFontWeightStyles4b24ddd8,
		"/src/lib/fontLineHeight-78b03658.js": requireFontLineHeight78b03658,
		"/src/lib/fontSizeHeadingLarge-c355151d.js": requireFontSizeHeadingLargeC355151d,
		"/src/lib/fontSizeHeadingMedium-c49ab5a2.js": requireFontSizeHeadingMediumC49ab5a2,
		"/src/lib/fontSizeHeadingSmall-a15141a5.js": requireFontSizeHeadingSmallA15141a5,
		"/src/lib/fontSizeHeadingXLarge-f33a0a84.js": requireFontSizeHeadingXLargeF33a0a84,
		"/src/lib/fontSizeText-728b6387.js": requireFontSizeText728b6387,
		"/src/lib/fontSizeTextLarge-05a4bc90.js": requireFontSizeTextLarge05a4bc90,
		"/src/lib/fontSizeTextMedium-88887ad8.js": requireFontSizeTextMedium88887ad8,
		"/src/lib/fontSizeTextSmall-508930e5.js": requireFontSizeTextSmall508930e5,
		"/src/lib/fontSizeTextXLarge-0ecf9ef3.js": requireFontSizeTextXLarge0ecf9ef3,
		"/src/lib/fontSizeTextXSmall-e59d35d7.js": requireFontSizeTextXSmallE59d35d7,
		"/src/lib/fontSizeTextXXSmall-a02f9c40.js": requireFontSizeTextXXSmallA02f9c40,
		"/src/lib/fontVariant-6ba3b7cb.js": requireFontVariant6ba3b7cb,
		"/src/lib/fontWeightRegular-d0c768ac.js": requireFontWeightRegularD0c768ac,
		"/src/lib/fontWeightSemiBold-4482c830.js": requireFontWeightSemiBold4482c830,
		"/src/lib/form-styles-97f2cdf7.js": requireFormStyles97f2cdf7,
		"/src/lib/get-button-base-aria-attributes-51363b44.js": requireGetButtonBaseAriaAttributes51363b44,
		"/src/lib/getAttribute-4e18832c.js": requireGetAttribute4e18832c,
		"/src/lib/getCDNBaseURL-e7722df3.js": requireGetCDNBaseURLE7722df3,
		"/src/lib/getClickedItem-e7e5ae2c.js": requireGetClickedItemE7e5ae2c,
		"/src/lib/getClosestHTMLElement-0135bfd9.js": requireGetClosestHTMLElement0135bfd9,
		"/src/lib/getDirectChildHTMLElements-0adb2021.js": requireGetDirectChildHTMLElements0adb2021,
		"/src/lib/getHTMLElements-21fc87cc.js": requireGetHTMLElements21fc87cc,
		"/src/lib/getMediaQueryMax-2587ee0a.js": requireGetMediaQueryMax2587ee0a,
		"/src/lib/getNamedSlot-a433c432.js": requireGetNamedSlotA433c432,
		"/src/lib/getOnlyChildOfKindHTMLElementOrThrow-f6972c1c.js": requireGetOnlyChildOfKindHTMLElementOrThrowF6972c1c,
		"/src/lib/getSlotTextContent-5379eb26.js": requireGetSlotTextContent5379eb26,
		"/src/lib/gridBasicOffset-eafb13d6.js": requireGridBasicOffsetEafb13d6,
		"/src/lib/gridExtendedOffsetBase-fb9830f6.js": requireGridExtendedOffsetBaseFb9830f6,
		"/src/lib/gridExtendedOffsetXXL-c7a41e50.js": requireGridExtendedOffsetXXLC7a41e50,
		"/src/lib/gridGap-b5b73e4a.js": requireGridGapB5b73e4a,
		"/src/lib/group-direction-styles-27ae72d0.js": requireGroupDirectionStyles27ae72d0,
		"/src/lib/has-document-079654e6.js": requireHasDocument079654e6,
		"/src/lib/hasAttribute-868c282d.js": requireHasAttribute868c282d,
		"/src/lib/hasDescription-a19e4bdc.js": requireHasDescriptionA19e4bdc,
		"/src/lib/hasNamedSlot-28c6bca1.js": requireHasNamedSlot28c6bca1,
		"/src/lib/heading-tag-0acc4c21.js": requireHeadingTag0acc4c21,
		"/src/lib/headingShared-aa59e66d.js": requireHeadingSharedAa59e66d,
		"/src/lib/headingSmallStyle-0707b97f.js": requireHeadingSmallStyle0707b97f,
		"/src/lib/headingXXLargeStyle-db047d95.js": requireHeadingXXLargeStyleDb047d95,
		"/src/lib/helper-e5c4e0db.js": requireHelperE5c4e0db,
		"/src/lib/hover-media-query-f2ccfc24.js": requireHoverMediaQueryF2ccfc24,
		"/src/lib/index.cjs.js": requireIndex_cjs,
		"/src/lib/inline-notification-utils-ac1154ad.js": requireInlineNotificationUtilsAc1154ad,
		"/src/lib/is-click-outside-07c79402.js": requireIsClickOutside07c79402,
		"/src/lib/is-ssr-hydration-9278b79b.js": requireIsSsrHydration9278b79b,
		"/src/lib/isDisabledOrLoading-ad97a497.js": requireIsDisabledOrLoadingAd97a497,
		"/src/lib/isParentFieldsetRequired-6f3a68ad.js": requireIsParentFieldsetRequired6f3a68ad,
		"/src/lib/isParentOfKind-a9c351f2.js": requireIsParentOfKindA9c351f2,
		"/src/lib/isRequiredAndParentNotRequired-0b84c8cc.js": requireIsRequiredAndParentNotRequired0b84c8cc,
		"/src/lib/isThemeAuto-c90cd35d.js": requireIsThemeAutoC90cd35d,
		"/src/lib/isWithinForm-a677dade.js": requireIsWithinFormA677dade,
		"/src/lib/link-aria-attribute-5de11e89.js": requireLinkAriaAttribute5de11e89,
		"/src/lib/link-button-pure-styles-1e533bc9.js": requireLinkButtonPureStyles1e533bc9,
		"/src/lib/link-button-styles-e68cc0c9.js": requireLinkButtonStylesE68cc0c9,
		"/src/lib/link-button-variant-3104b925.js": requireLinkButtonVariant3104b925,
		"/src/lib/link-styles-60ad2b7b.js": requireLinkStyles60ad2b7b,
		"/src/lib/link-tile-utils-98dcc629.js": requireLinkTileUtils98dcc629,
		"/src/lib/loader.cjs.js": requireLoader_cjs,
		"/src/lib/modal-utils-9e25e7f9.js": requireModalUtils9e25e7f9,
		"/src/lib/p-accordion.cjs.entry.js": requirePAccordion_cjs_entry,
		"/src/lib/p-banner.cjs.entry.js": requirePBanner_cjs_entry,
		"/src/lib/p-button-group.cjs.entry.js": requirePButtonGroup_cjs_entry,
		"/src/lib/p-button-pure.cjs.entry.js": requirePButtonPure_cjs_entry,
		"/src/lib/p-button-tile.cjs.entry.js": requirePButtonTile_cjs_entry,
		"/src/lib/p-button.cjs.entry.js": requirePButton_cjs_entry,
		"/src/lib/p-carousel.cjs.entry.js": requirePCarousel_cjs_entry,
		"/src/lib/p-checkbox-wrapper.cjs.entry.js": requirePCheckboxWrapper_cjs_entry,
		"/src/lib/p-content-wrapper.cjs.entry.js": requirePContentWrapper_cjs_entry,
		"/src/lib/p-crest.cjs.entry.js": requirePCrest_cjs_entry,
		"/src/lib/p-display.cjs.entry.js": requirePDisplay_cjs_entry,
		"/src/lib/p-divider.cjs.entry.js": requirePDivider_cjs_entry,
		"/src/lib/p-fieldset-wrapper.cjs.entry.js": requirePFieldsetWrapper_cjs_entry,
		"/src/lib/p-fieldset.cjs.entry.js": requirePFieldset_cjs_entry,
		"/src/lib/p-flex_2.cjs.entry.js": requirePFlex_2_cjs_entry,
		"/src/lib/p-flyout.cjs.entry.js": requirePFlyout_cjs_entry,
		"/src/lib/p-grid_2.cjs.entry.js": requirePGrid_2_cjs_entry,
		"/src/lib/p-heading.cjs.entry.js": requirePHeading_cjs_entry,
		"/src/lib/p-headline.cjs.entry.js": requirePHeadline_cjs_entry,
		"/src/lib/p-icon.cjs.entry.js": requirePIcon_cjs_entry,
		"/src/lib/p-inline-notification.cjs.entry.js": requirePInlineNotification_cjs_entry,
		"/src/lib/p-link-pure.cjs.entry.js": requirePLinkPure_cjs_entry,
		"/src/lib/p-link-social.cjs.entry.js": requirePLinkSocial_cjs_entry,
		"/src/lib/p-link-tile-model-signature.cjs.entry.js": requirePLinkTileModelSignature_cjs_entry,
		"/src/lib/p-link-tile.cjs.entry.js": requirePLinkTile_cjs_entry,
		"/src/lib/p-link.cjs.entry.js": requirePLink_cjs_entry,
		"/src/lib/p-marque.cjs.entry.js": requirePMarque_cjs_entry,
		"/src/lib/p-modal.cjs.entry.js": requirePModal_cjs_entry,
		"/src/lib/p-model-signature.cjs.entry.js": requirePModelSignature_cjs_entry,
		"/src/lib/p-multi-select_2.cjs.entry.js": requirePMultiSelect_2_cjs_entry,
		"/src/lib/p-pagination.cjs.entry.js": requirePPagination_cjs_entry,
		"/src/lib/p-pin-code.cjs.entry.js": requirePPinCode_cjs_entry,
		"/src/lib/p-popover.cjs.entry.js": requirePPopover_cjs_entry,
		"/src/lib/p-radio-button-wrapper.cjs.entry.js": requirePRadioButtonWrapper_cjs_entry,
		"/src/lib/p-scroller.cjs.entry.js": requirePScroller_cjs_entry,
		"/src/lib/p-segmented-control_2.cjs.entry.js": requirePSegmentedControl_2_cjs_entry,
		"/src/lib/p-select-wrapper_2.cjs.entry.js": requirePSelectWrapper_2_cjs_entry,
		"/src/lib/p-spinner.cjs.entry.js": requirePSpinner_cjs_entry,
		"/src/lib/p-stepper-horizontal_2.cjs.entry.js": requirePStepperHorizontal_2_cjs_entry,
		"/src/lib/p-switch.cjs.entry.js": requirePSwitch_cjs_entry,
		"/src/lib/p-table_7.cjs.entry.js": requirePTable_7_cjs_entry,
		"/src/lib/p-tabs_2.cjs.entry.js": requirePTabs_2_cjs_entry,
		"/src/lib/p-tabs-bar.cjs.entry.js": requirePTabsBar_cjs_entry,
		"/src/lib/p-tag-dismissible.cjs.entry.js": requirePTagDismissible_cjs_entry,
		"/src/lib/p-tag.cjs.entry.js": requirePTag_cjs_entry,
		"/src/lib/p-text-field-wrapper.cjs.entry.js": requirePTextFieldWrapper_cjs_entry,
		"/src/lib/p-text-list_2.cjs.entry.js": requirePTextList_2_cjs_entry,
		"/src/lib/p-text.cjs.entry.js": requirePText_cjs_entry,
		"/src/lib/p-textarea-wrapper.cjs.entry.js": requirePTextareaWrapper_cjs_entry,
		"/src/lib/p-toast_2.cjs.entry.js": requirePToast_2_cjs_entry,
		"/src/lib/p-wordmark.cjs.entry.js": requirePWordmark_cjs_entry,
		"/src/lib/porsche-design-system.cjs.js": requirePorscheDesignSystem_cjs,
		"/src/lib/property-observer-bfc089d2.js": requirePropertyObserverBfc089d2,
		"/src/lib/required-bc18b612.js": requireRequiredBc18b612,
		"/src/lib/schemed-high-contrast-media-query-5956ba22.js": requireSchemedHighContrastMediaQuery5956ba22,
		"/src/lib/scrolling-c37f1aeb.js": requireScrollingC37f1aeb,
		"/src/lib/select-dropdown-5f011c9b.js": requireSelectDropdown5f011c9b,
		"/src/lib/setAttributes-642a7e67.js": requireSetAttributes642a7e67,
		"/src/lib/spacingFluidLarge-6087a0f7.js": requireSpacingFluidLarge6087a0f7,
		"/src/lib/spacingFluidMedium-88ab712b.js": requireSpacingFluidMedium88ab712b,
		"/src/lib/spacingFluidSmall-2c6caae7.js": requireSpacingFluidSmall2c6caae7,
		"/src/lib/spacingFluidXSmall-0dd753ae.js": requireSpacingFluidXSmall0dd753ae,
		"/src/lib/spacingStaticMedium-94812711.js": requireSpacingStaticMedium94812711,
		"/src/lib/spacingStaticSmall-2130ed04.js": requireSpacingStaticSmall2130ed04,
		"/src/lib/spacingStaticXSmall-b7d708b8.js": requireSpacingStaticXSmallB7d708b8,
		"/src/lib/tabs-bar-utils-7de019f3.js": requireTabsBarUtils7de019f3,
		"/src/lib/tag-shared-utils-8232b651.js": requireTagSharedUtils8232b651,
		"/src/lib/text-color-99ae680c.js": requireTextColor99ae680c,
		"/src/lib/text-icon-styles-deb3ffbc.js": requireTextIconStylesDeb3ffbc,
		"/src/lib/text-size-3b156bcb.js": requireTextSize3b156bcb,
		"/src/lib/text-weight-8f0d791a.js": requireTextWeight8f0d791a,
		"/src/lib/textShared-9135e2ef.js": requireTextShared9135e2ef,
		"/src/lib/textSmallStyle-7246779a.js": requireTextSmallStyle7246779a,
		"/src/lib/textXSmallStyle-1145ee25.js": requireTextXSmallStyle1145ee25,
		"/src/lib/theme-bfc10573.js": requireThemeBfc10573,
		"/src/lib/throwIfChildrenAreNotOfKind-39ea431a.js": requireThrowIfChildrenAreNotOfKind39ea431a,
		"/src/lib/throwIfElementIsNotOfKind-aad4cb3e.js": requireThrowIfElementIsNotOfKindAad4cb3e,
		"/src/lib/throwIfInvalidLinkUsage-0b248592.js": requireThrowIfInvalidLinkUsage0b248592,
		"/src/lib/throwIfParentIsNotOfKind-99386afd.js": requireThrowIfParentIsNotOfKind99386afd,
		"/src/lib/throwIfRootNodeIsNotOneOfKind-b4d3ea18.js": requireThrowIfRootNodeIsNotOneOfKindB4d3ea18,
		"/src/lib/tile-base-styles-bc82297d.js": requireTileBaseStylesBc82297d,
		"/src/lib/transformSelectorToDirectChildSelector-08da8668.js": requireTransformSelectorToDirectChildSelector08da8668,
		"/src/lib/typography-styles-136a56f3.js": requireTypographyStyles136a56f3,
		"/src/lib/validateProps-c2afb75b.js": requireValidatePropsC2afb75b,
		"/src/lib/warnIfDeprecatedComponentIsUsed-80115a1d.js": requireWarnIfDeprecatedComponentIsUsed80115a1d,
		"/src/lib/warnIfDeprecatedPropIsUsed-3a5c494c.js": requireWarnIfDeprecatedPropIsUsed3a5c494c,
		"/src/lib/warnIfDeprecatedPropValueIsUsed-da5fe664.js": requireWarnIfDeprecatedPropValueIsUsedDa5fe664
	});
}

function createCommonjsRequire(originalModuleDir) {
	function handleRequire(path) {
		var resolvedPath = commonjsResolve(path, originalModuleDir);
		if (resolvedPath !== null) {
			return getDynamicModules()[resolvedPath]();
		}
		throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
	}
	handleRequire.resolve = function (path) {
		var resolvedPath = commonjsResolve(path, originalModuleDir);
		if (resolvedPath !== null) {
			return resolvedPath;
		}
		return require.resolve(path);
	};
	return handleRequire;
}

function commonjsResolve (path, originalModuleDir) {
	var shouldTryNodeModules = isPossibleNodeModulesPath(path);
	path = normalize(path);
	var relPath;
	if (path[0] === '/') {
		originalModuleDir = '';
	}
	var modules = getDynamicModules();
	var checkedExtensions = ['', '.js', '.json'];
	while (true) {
		if (!shouldTryNodeModules) {
			relPath = normalize(originalModuleDir + '/' + path);
		} else {
			relPath = normalize(originalModuleDir + '/node_modules/' + path);
		}

		if (relPath.endsWith('/..')) {
			break; // Travelled too far up, avoid infinite loop
		}

		for (var extensionIndex = 0; extensionIndex < checkedExtensions.length; extensionIndex++) {
			var resolvedPath = relPath + checkedExtensions[extensionIndex];
			if (modules[resolvedPath]) {
				return resolvedPath;
			}
		}
		if (!shouldTryNodeModules) break;
		var nextDir = normalize(originalModuleDir + '/..');
		if (nextDir === originalModuleDir) break;
		originalModuleDir = nextDir;
	}
	return null;
}

function isPossibleNodeModulesPath (modulePath) {
	var c0 = modulePath[0];
	if (c0 === '/' || c0 === '\\') return false;
	var c1 = modulePath[1], c2 = modulePath[2];
	if ((c0 === '.' && (!c1 || c1 === '/' || c1 === '\\')) ||
		(c0 === '.' && c1 === '.' && (!c2 || c2 === '/' || c2 === '\\'))) return false;
	if (c1 === ':' && (c2 === '/' || c2 === '\\')) return false;
	return true;
}

function normalize (path) {
	path = path.replace(/\\/g, '/');
	var parts = path.split('/');
	var slashed = parts[0] === '';
	for (var i = 1; i < parts.length; i++) {
		if (parts[i] === '.' || parts[i] === '') {
			parts.splice(i--, 1);
		}
	}
	for (var i = 1; i < parts.length; i++) {
		if (parts[i] !== '..') continue;
		if (i > 0 && parts[i - 1] !== '..' && parts[i - 1] !== '.') {
			parts.splice(--i, 2);
			i--;
		}
	}
	path = parts.join('/');
	if (slashed && path[0] !== '/') path = '/' + path;
	else if (path.length === 0) path = '.';
	return path;
}

var validatePropsC2afb75b = {};

var hasRequiredValidatePropsC2afb75b;

function requireValidatePropsC2afb75b () {
	if (hasRequiredValidatePropsC2afb75b) return validatePropsC2afb75b;
	hasRequiredValidatePropsC2afb75b = 1;
	(function (exports) {

		function _interopNamespace(e) {
		  if (e && e.__esModule) return e;
		  var n = Object.create(null);
		  if (e) {
		    Object.keys(e).forEach(function (k) {
		      if (k !== 'default') {
		        var d = Object.getOwnPropertyDescriptor(e, k);
		        Object.defineProperty(n, k, d.get ? d : {
		          enumerable: true,
		          get: function () {
		            return e[k];
		          }
		        });
		      }
		    });
		  }
		  n['default'] = e;
		  return Object.freeze(n);
		}

		const NAMESPACE = 'porsche-design-system';

		/**
		 * Virtual DOM patching algorithm based on Snabbdom by
		 * Simon Friis Vindum (@paldepind)
		 * Licensed under the MIT License
		 * https://github.com/snabbdom/snabbdom/blob/master/LICENSE
		 *
		 * Modified for Stencil's renderer and slot projection
		 */
		let scopeId;
		let hostTagName;
		let isSvgMode = false;
		let queuePending = false;
		const createTime = (fnName, tagName = '') => {
		    {
		        return () => {
		            return;
		        };
		    }
		};
		const uniqueTime = (key, measureText) => {
		    {
		        return () => {
		            return;
		        };
		    }
		};
		const XLINK_NS = 'http://www.w3.org/1999/xlink';
		/**
		 * Default style mode id
		 */
		/**
		 * Reusable empty obj/array
		 * Don't add values to these!!
		 */
		const EMPTY_OBJ = {};
		/**
		 * Namespaces
		 */
		const SVG_NS = 'http://www.w3.org/2000/svg';
		const HTML_NS = 'http://www.w3.org/1999/xhtml';
		const isDef = (v) => v != null;
		/**
		 * Check whether a value is a 'complex type', defined here as an object or a
		 * function.
		 *
		 * @param o the value to check
		 * @returns whether it's a complex type or not
		 */
		const isComplexType = (o) => {
		    // https://jsperf.com/typeof-fn-object/5
		    o = typeof o;
		    return o === 'object' || o === 'function';
		};
		/**
		 * Production h() function based on Preact by
		 * Jason Miller (@developit)
		 * Licensed under the MIT License
		 * https://github.com/developit/preact/blob/master/LICENSE
		 *
		 * Modified for Stencil's compiler and vdom
		 */
		// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;
		// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;
		const h = (nodeName, vnodeData, ...children) => {
		    let child = null;
		    let key = null;
		    let simple = false;
		    let lastSimple = false;
		    const vNodeChildren = [];
		    const walk = (c) => {
		        for (let i = 0; i < c.length; i++) {
		            child = c[i];
		            if (Array.isArray(child)) {
		                walk(child);
		            }
		            else if (child != null && typeof child !== 'boolean') {
		                if ((simple = typeof nodeName !== 'function' && !isComplexType(child))) {
		                    child = String(child);
		                }
		                if (simple && lastSimple) {
		                    // If the previous child was simple (string), we merge both
		                    vNodeChildren[vNodeChildren.length - 1].$text$ += child;
		                }
		                else {
		                    // Append a new vNode, if it's text, we create a text vNode
		                    vNodeChildren.push(simple ? newVNode(null, child) : child);
		                }
		                lastSimple = simple;
		            }
		        }
		    };
		    walk(children);
		    if (vnodeData) {
		        // normalize class / classname attributes
		        if (vnodeData.key) {
		            key = vnodeData.key;
		        }
		        {
		            const classData = vnodeData.className || vnodeData.class;
		            if (classData) {
		                vnodeData.class =
		                    typeof classData !== 'object'
		                        ? classData
		                        : Object.keys(classData)
		                            .filter((k) => classData[k])
		                            .join(' ');
		            }
		        }
		    }
		    if (typeof nodeName === 'function') {
		        // nodeName is a functional component
		        return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils);
		    }
		    const vnode = newVNode(nodeName, null);
		    vnode.$attrs$ = vnodeData;
		    if (vNodeChildren.length > 0) {
		        vnode.$children$ = vNodeChildren;
		    }
		    {
		        vnode.$key$ = key;
		    }
		    return vnode;
		};
		/**
		 * A utility function for creating a virtual DOM node from a tag and some
		 * possible text content.
		 *
		 * @param tag the tag for this element
		 * @param text possible text content for the node
		 * @returns a newly-minted virtual DOM node
		 */
		const newVNode = (tag, text) => {
		    const vnode = {
		        $flags$: 0,
		        $tag$: tag,
		        $text$: text,
		        $elm$: null,
		        $children$: null,
		    };
		    {
		        vnode.$attrs$ = null;
		    }
		    {
		        vnode.$key$ = null;
		    }
		    return vnode;
		};
		const Host = {};
		/**
		 * Check whether a given node is a Host node or not
		 *
		 * @param node the virtual DOM node to check
		 * @returns whether it's a Host node or not
		 */
		const isHost = (node) => node && node.$tag$ === Host;
		/**
		 * Implementation of {@link d.FunctionalUtilities} for Stencil's VDom.
		 *
		 * Note that these functions convert from {@link d.VNode} to
		 * {@link d.ChildNode} to give functional component developers a friendly
		 * interface.
		 */
		const vdomFnUtils = {
		    forEach: (children, cb) => children.map(convertToPublic).forEach(cb),
		    map: (children, cb) => children.map(convertToPublic).map(cb).map(convertToPrivate),
		};
		/**
		 * Convert a {@link d.VNode} to a {@link d.ChildNode} in order to present a
		 * friendlier public interface (hence, 'convertToPublic').
		 *
		 * @param node the virtual DOM node to convert
		 * @returns a converted child node
		 */
		const convertToPublic = (node) => ({
		    vattrs: node.$attrs$,
		    vchildren: node.$children$,
		    vkey: node.$key$,
		    vname: node.$name$,
		    vtag: node.$tag$,
		    vtext: node.$text$,
		});
		/**
		 * Convert a {@link d.ChildNode} back to an equivalent {@link d.VNode} in
		 * order to use the resulting object in the virtual DOM. The initial object was
		 * likely created as part of presenting a public API, so converting it back
		 * involved making it 'private' again (hence, `convertToPrivate`).
		 *
		 * @param node the child node to convert
		 * @returns a converted virtual DOM node
		 */
		const convertToPrivate = (node) => {
		    if (typeof node.vtag === 'function') {
		        const vnodeData = Object.assign({}, node.vattrs);
		        if (node.vkey) {
		            vnodeData.key = node.vkey;
		        }
		        if (node.vname) {
		            vnodeData.name = node.vname;
		        }
		        return h(node.vtag, vnodeData, ...(node.vchildren || []));
		    }
		    const vnode = newVNode(node.vtag, node.vtext);
		    vnode.$attrs$ = node.vattrs;
		    vnode.$children$ = node.vchildren;
		    vnode.$key$ = node.vkey;
		    vnode.$name$ = node.vname;
		    return vnode;
		};
		/**
		 * Parse a new property value for a given property type.
		 *
		 * While the prop value can reasonably be expected to be of `any` type as far as TypeScript's type checker is concerned,
		 * it is not safe to assume that the string returned by evaluating `typeof propValue` matches:
		 *   1. `any`, the type given to `propValue` in the function signature
		 *   2. the type stored from `propType`.
		 *
		 * This function provides the capability to parse/coerce a property's value to potentially any other JavaScript type.
		 *
		 * Property values represented in TSX preserve their type information. In the example below, the number 0 is passed to
		 * a component. This `propValue` will preserve its type information (`typeof propValue === 'number'`). Note that is
		 * based on the type of the value being passed in, not the type declared of the class member decorated with `@Prop`.
		 * ```tsx
		 * <my-cmp prop-val={0}></my-cmp>
		 * ```
		 *
		 * HTML prop values on the other hand, will always a string
		 *
		 * @param propValue the new value to coerce to some type
		 * @param propType the type of the prop, expressed as a binary number
		 * @returns the parsed/coerced value
		 */
		const parsePropertyValue = (propValue, propType) => {
		    // ensure this value is of the correct prop type
		    if (propValue != null && !isComplexType(propValue)) {
		        if (propType & 4 /* MEMBER_FLAGS.Boolean */) {
		            // per the HTML spec, any string value means it is a boolean true value
		            // but we'll cheat here and say that the string "false" is the boolean false
		            return propValue === 'false' ? false : propValue === '' || !!propValue;
		        }
		        if (propType & 2 /* MEMBER_FLAGS.Number */) {
		            // force it to be a number
		            return parseFloat(propValue);
		        }
		        if (propType & 1 /* MEMBER_FLAGS.String */) {
		            // could have been passed as a number or boolean
		            // but we still want it as a string
		            return String(propValue);
		        }
		        // redundant return here for better minification
		        return propValue;
		    }
		    // not sure exactly what type we want
		    // so no need to change to a different type
		    return propValue;
		};
		const getElement = (ref) => (getHostRef(ref).$hostElement$ );
		const createEvent = (ref, name, flags) => {
		    const elm = getElement(ref);
		    return {
		        emit: (detail) => {
		            return emitEvent(elm, name, {
		                bubbles: !!(flags & 4 /* EVENT_FLAGS.Bubbles */),
		                composed: !!(flags & 2 /* EVENT_FLAGS.Composed */),
		                cancelable: !!(flags & 1 /* EVENT_FLAGS.Cancellable */),
		                detail,
		            });
		        },
		    };
		};
		/**
		 * Helper function to create & dispatch a custom Event on a provided target
		 * @param elm the target of the Event
		 * @param name the name to give the custom Event
		 * @param opts options for configuring a custom Event
		 * @returns the custom Event
		 */
		const emitEvent = (elm, name, opts) => {
		    const ev = plt.ce(name, opts);
		    elm.dispatchEvent(ev);
		    return ev;
		};
		/**
		 * Production setAccessor() function based on Preact by
		 * Jason Miller (@developit)
		 * Licensed under the MIT License
		 * https://github.com/developit/preact/blob/master/LICENSE
		 *
		 * Modified for Stencil's compiler and vdom
		 */
		/**
		 * When running a VDom render set properties present on a VDom node onto the
		 * corresponding HTML element.
		 *
		 * Note that this function has special functionality for the `class`,
		 * `style`, `key`, and `ref` attributes, as well as event handlers (like
		 * `onClick`, etc). All others are just passed through as-is.
		 *
		 * @param elm the HTMLElement onto which attributes should be set
		 * @param memberName the name of the attribute to set
		 * @param oldValue the old value for the attribute
		 * @param newValue the new value for the attribute
		 * @param isSvg whether we're in an svg context or not
		 * @param flags bitflags for Vdom variables
		 */
		const setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {
		    if (oldValue !== newValue) {
		        let isProp = isMemberInElement(elm, memberName);
		        let ln = memberName.toLowerCase();
		        if (memberName === 'class') {
		            const classList = elm.classList;
		            const oldClasses = parseClassList(oldValue);
		            const newClasses = parseClassList(newValue);
		            classList.remove(...oldClasses.filter((c) => c && !newClasses.includes(c)));
		            classList.add(...newClasses.filter((c) => c && !oldClasses.includes(c)));
		        }
		        else if (memberName === 'style') {
		            // update style attribute, css properties and values
		            {
		                for (const prop in oldValue) {
		                    if (!newValue || newValue[prop] == null) {
		                        if (prop.includes('-')) {
		                            elm.style.removeProperty(prop);
		                        }
		                        else {
		                            elm.style[prop] = '';
		                        }
		                    }
		                }
		            }
		            for (const prop in newValue) {
		                if (!oldValue || newValue[prop] !== oldValue[prop]) {
		                    if (prop.includes('-')) {
		                        elm.style.setProperty(prop, newValue[prop]);
		                    }
		                    else {
		                        elm.style[prop] = newValue[prop];
		                    }
		                }
		            }
		        }
		        else if (memberName === 'key')
		            ;
		        else if (memberName === 'ref') {
		            // minifier will clean this up
		            if (newValue) {
		                newValue(elm);
		            }
		        }
		        else if ((!isProp ) &&
		            memberName[0] === 'o' &&
		            memberName[1] === 'n') {
		            // Event Handlers
		            // so if the member name starts with "on" and the 3rd characters is
		            // a capital letter, and it's not already a member on the element,
		            // then we're assuming it's an event listener
		            if (memberName[2] === '-') {
		                // on- prefixed events
		                // allows to be explicit about the dom event to listen without any magic
		                // under the hood:
		                // <my-cmp on-click> // listens for "click"
		                // <my-cmp on-Click> // listens for "Click"
		                // <my-cmp on-ionChange> // listens for "ionChange"
		                // <my-cmp on-EVENTS> // listens for "EVENTS"
		                memberName = memberName.slice(3);
		            }
		            else if (isMemberInElement(win, ln)) {
		                // standard event
		                // the JSX attribute could have been "onMouseOver" and the
		                // member name "onmouseover" is on the window's prototype
		                // so let's add the listener "mouseover", which is all lowercased
		                memberName = ln.slice(2);
		            }
		            else {
		                // custom event
		                // the JSX attribute could have been "onMyCustomEvent"
		                // so let's trim off the "on" prefix and lowercase the first character
		                // and add the listener "myCustomEvent"
		                // except for the first character, we keep the event name case
		                memberName = ln[2] + memberName.slice(3);
		            }
		            if (oldValue) {
		                plt.rel(elm, memberName, oldValue, false);
		            }
		            if (newValue) {
		                plt.ael(elm, memberName, newValue, false);
		            }
		        }
		        else {
		            // Set property if it exists and it's not a SVG
		            const isComplex = isComplexType(newValue);
		            if ((isProp || (isComplex && newValue !== null)) && !isSvg) {
		                try {
		                    if (!elm.tagName.includes('-')) {
		                        const n = newValue == null ? '' : newValue;
		                        // Workaround for Safari, moving the <input> caret when re-assigning the same valued
		                        if (memberName === 'list') {
		                            isProp = false;
		                        }
		                        else if (oldValue == null || elm[memberName] != n) {
		                            elm[memberName] = n;
		                        }
		                    }
		                    else {
		                        elm[memberName] = newValue;
		                    }
		                }
		                catch (e) { }
		            }
		            /**
		             * Need to manually update attribute if:
		             * - memberName is not an attribute
		             * - if we are rendering the host element in order to reflect attribute
		             * - if it's a SVG, since properties might not work in <svg>
		             * - if the newValue is null/undefined or 'false'.
		             */
		            let xlink = false;
		            {
		                if (ln !== (ln = ln.replace(/^xlink\:?/, ''))) {
		                    memberName = ln;
		                    xlink = true;
		                }
		            }
		            if (newValue == null || newValue === false) {
		                if (newValue !== false || elm.getAttribute(memberName) === '') {
		                    if (xlink) {
		                        elm.removeAttributeNS(XLINK_NS, memberName);
		                    }
		                    else {
		                        elm.removeAttribute(memberName);
		                    }
		                }
		            }
		            else if ((!isProp || flags & 4 /* VNODE_FLAGS.isHost */ || isSvg) && !isComplex) {
		                newValue = newValue === true ? '' : newValue;
		                if (xlink) {
		                    elm.setAttributeNS(XLINK_NS, memberName, newValue);
		                }
		                else {
		                    elm.setAttribute(memberName, newValue);
		                }
		            }
		        }
		    }
		};
		const parseClassListRegex = /\s/;
		const parseClassList = (value) => (!value ? [] : value.split(parseClassListRegex));
		const updateElement = (oldVnode, newVnode, isSvgMode, memberName) => {
		    // if the element passed in is a shadow root, which is a document fragment
		    // then we want to be adding attrs/props to the shadow root's "host" element
		    // if it's not a shadow root, then we add attrs/props to the same element
		    const elm = newVnode.$elm$.nodeType === 11 /* NODE_TYPE.DocumentFragment */ && newVnode.$elm$.host
		        ? newVnode.$elm$.host
		        : newVnode.$elm$;
		    const oldVnodeAttrs = (oldVnode && oldVnode.$attrs$) || EMPTY_OBJ;
		    const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;
		    {
		        // remove attributes no longer present on the vnode by setting them to undefined
		        for (memberName in oldVnodeAttrs) {
		            if (!(memberName in newVnodeAttrs)) {
		                setAccessor(elm, memberName, oldVnodeAttrs[memberName], undefined, isSvgMode, newVnode.$flags$);
		            }
		        }
		    }
		    // add new & update changed attributes
		    for (memberName in newVnodeAttrs) {
		        setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode, newVnode.$flags$);
		    }
		};
		/**
		 * Create a DOM Node corresponding to one of the children of a given VNode.
		 *
		 * @param oldParentVNode the parent VNode from the previous render
		 * @param newParentVNode the parent VNode from the current render
		 * @param childIndex the index of the VNode, in the _new_ parent node's
		 * children, for which we will create a new DOM node
		 * @param parentElm the parent DOM node which our new node will be a child of
		 * @returns the newly created node
		 */
		const createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {
		    // tslint:disable-next-line: prefer-const
		    const newVNode = newParentVNode.$children$[childIndex];
		    let i = 0;
		    let elm;
		    let childNode;
		    if (newVNode.$text$ !== null) {
		        // create text node
		        elm = newVNode.$elm$ = doc.createTextNode(newVNode.$text$);
		    }
		    else {
		        if (!isSvgMode) {
		            isSvgMode = newVNode.$tag$ === 'svg';
		        }
		        // create element
		        elm = newVNode.$elm$ = (doc.createElementNS(isSvgMode ? SVG_NS : HTML_NS, newVNode.$tag$)
		            );
		        if (isSvgMode && newVNode.$tag$ === 'foreignObject') {
		            isSvgMode = false;
		        }
		        // add css classes, attrs, props, listeners, etc.
		        {
		            updateElement(null, newVNode, isSvgMode);
		        }
		        if (isDef(scopeId) && elm['s-si'] !== scopeId) {
		            // if there is a scopeId and this is the initial render
		            // then let's add the scopeId as a css class
		            elm.classList.add((elm['s-si'] = scopeId));
		        }
		        if (newVNode.$children$) {
		            for (i = 0; i < newVNode.$children$.length; ++i) {
		                // create the node
		                childNode = createElm(oldParentVNode, newVNode, i);
		                // return node could have been null
		                if (childNode) {
		                    // append our new node
		                    elm.appendChild(childNode);
		                }
		            }
		        }
		        {
		            if (newVNode.$tag$ === 'svg') {
		                // Only reset the SVG context when we're exiting <svg> element
		                isSvgMode = false;
		            }
		            else if (elm.tagName === 'foreignObject') {
		                // Reenter SVG context when we're exiting <foreignObject> element
		                isSvgMode = true;
		            }
		        }
		    }
		    return elm;
		};
		/**
		 * Create DOM nodes corresponding to a list of {@link d.Vnode} objects and
		 * add them to the DOM in the appropriate place.
		 *
		 * @param parentElm the DOM node which should be used as a parent for the new
		 * DOM nodes
		 * @param before a child of the `parentElm` which the new children should be
		 * inserted before (optional)
		 * @param parentVNode the parent virtual DOM node
		 * @param vnodes the new child virtual DOM nodes to produce DOM nodes for
		 * @param startIdx the index in the child virtual DOM nodes at which to start
		 * creating DOM nodes (inclusive)
		 * @param endIdx the index in the child virtual DOM nodes at which to stop
		 * creating DOM nodes (inclusive)
		 */
		const addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {
		    let containerElm = (parentElm);
		    let childNode;
		    if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {
		        containerElm = containerElm.shadowRoot;
		    }
		    for (; startIdx <= endIdx; ++startIdx) {
		        if (vnodes[startIdx]) {
		            childNode = createElm(null, parentVNode, startIdx);
		            if (childNode) {
		                vnodes[startIdx].$elm$ = childNode;
		                containerElm.insertBefore(childNode, before);
		            }
		        }
		    }
		};
		/**
		 * Remove the DOM elements corresponding to a list of {@link d.VNode} objects.
		 * This can be used to, for instance, clean up after a list of children which
		 * should no longer be shown.
		 *
		 * This function also handles some of Stencil's slot relocation logic.
		 *
		 * @param vnodes a list of virtual DOM nodes to remove
		 * @param startIdx the index at which to start removing nodes (inclusive)
		 * @param endIdx the index at which to stop removing nodes (inclusive)
		 */
		const removeVnodes = (vnodes, startIdx, endIdx) => {
		    for (let index = startIdx; index <= endIdx; ++index) {
		        const vnode = vnodes[index];
		        if (vnode) {
		            const elm = vnode.$elm$;
		            nullifyVNodeRefs(vnode);
		            if (elm) {
		                // remove the vnode's element from the dom
		                elm.remove();
		            }
		        }
		    }
		};
		/**
		 * Reconcile the children of a new VNode with the children of an old VNode by
		 * traversing the two collections of children, identifying nodes that are
		 * conserved or changed, calling out to `patch` to make any necessary
		 * updates to the DOM, and rearranging DOM nodes as needed.
		 *
		 * The algorithm for reconciling children works by analyzing two 'windows' onto
		 * the two arrays of children (`oldCh` and `newCh`). We keep track of the
		 * 'windows' by storing start and end indices and references to the
		 * corresponding array entries. Initially the two 'windows' are basically equal
		 * to the entire array, but we progressively narrow the windows until there are
		 * no children left to update by doing the following:
		 *
		 * 1. Skip any `null` entries at the beginning or end of the two arrays, so
		 *    that if we have an initial array like the following we'll end up dealing
		 *    only with a window bounded by the highlighted elements:
		 *
		 *    [null, null, VNode1 , ... , VNode2, null, null]
		 *                 ^^^^^^         ^^^^^^
		 *
		 * 2. Check to see if the elements at the head and tail positions are equal
		 *    across the windows. This will basically detect elements which haven't
		 *    been added, removed, or changed position, i.e. if you had the following
		 *    VNode elements (represented as HTML):
		 *
		 *    oldVNode: `<div><p><span>HEY</span></p></div>`
		 *    newVNode: `<div><p><span>THERE</span></p></div>`
		 *
		 *    Then when comparing the children of the `<div>` tag we check the equality
		 *    of the VNodes corresponding to the `<p>` tags and, since they are the
		 *    same tag in the same position, we'd be able to avoid completely
		 *    re-rendering the subtree under them with a new DOM element and would just
		 *    call out to `patch` to handle reconciling their children and so on.
		 *
		 * 3. Check, for both windows, to see if the element at the beginning of the
		 *    window corresponds to the element at the end of the other window. This is
		 *    a heuristic which will let us identify _some_ situations in which
		 *    elements have changed position, for instance it _should_ detect that the
		 *    children nodes themselves have not changed but merely moved in the
		 *    following example:
		 *
		 *    oldVNode: `<div><element-one /><element-two /></div>`
		 *    newVNode: `<div><element-two /><element-one /></div>`
		 *
		 *    If we find cases like this then we also need to move the concrete DOM
		 *    elements corresponding to the moved children to write the re-order to the
		 *    DOM.
		 *
		 * 4. Finally, if VNodes have the `key` attribute set on them we check for any
		 *    nodes in the old children which have the same key as the first element in
		 *    our window on the new children. If we find such a node we handle calling
		 *    out to `patch`, moving relevant DOM nodes, and so on, in accordance with
		 *    what we find.
		 *
		 * Finally, once we've narrowed our 'windows' to the point that either of them
		 * collapse (i.e. they have length 0) we then handle any remaining VNode
		 * insertion or deletion that needs to happen to get a DOM state that correctly
		 * reflects the new child VNodes. If, for instance, after our window on the old
		 * children has collapsed we still have more nodes on the new children that
		 * we haven't dealt with yet then we need to add them, or if the new children
		 * collapse but we still have unhandled _old_ children then we need to make
		 * sure the corresponding DOM nodes are removed.
		 *
		 * @param parentElm the node into which the parent VNode is rendered
		 * @param oldCh the old children of the parent node
		 * @param newVNode the new VNode which will replace the parent
		 * @param newCh the new children of the parent node
		 */
		const updateChildren = (parentElm, oldCh, newVNode, newCh) => {
		    let oldStartIdx = 0;
		    let newStartIdx = 0;
		    let idxInOld = 0;
		    let i = 0;
		    let oldEndIdx = oldCh.length - 1;
		    let oldStartVnode = oldCh[0];
		    let oldEndVnode = oldCh[oldEndIdx];
		    let newEndIdx = newCh.length - 1;
		    let newStartVnode = newCh[0];
		    let newEndVnode = newCh[newEndIdx];
		    let node;
		    let elmToMove;
		    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
		        if (oldStartVnode == null) {
		            // VNode might have been moved left
		            oldStartVnode = oldCh[++oldStartIdx];
		        }
		        else if (oldEndVnode == null) {
		            oldEndVnode = oldCh[--oldEndIdx];
		        }
		        else if (newStartVnode == null) {
		            newStartVnode = newCh[++newStartIdx];
		        }
		        else if (newEndVnode == null) {
		            newEndVnode = newCh[--newEndIdx];
		        }
		        else if (isSameVnode(oldStartVnode, newStartVnode)) {
		            // if the start nodes are the same then we should patch the new VNode
		            // onto the old one, and increment our `newStartIdx` and `oldStartIdx`
		            // indices to reflect that. We don't need to move any DOM Nodes around
		            // since things are matched up in order.
		            patch(oldStartVnode, newStartVnode);
		            oldStartVnode = oldCh[++oldStartIdx];
		            newStartVnode = newCh[++newStartIdx];
		        }
		        else if (isSameVnode(oldEndVnode, newEndVnode)) {
		            // likewise, if the end nodes are the same we patch new onto old and
		            // decrement our end indices, and also likewise in this case we don't
		            // need to move any DOM Nodes.
		            patch(oldEndVnode, newEndVnode);
		            oldEndVnode = oldCh[--oldEndIdx];
		            newEndVnode = newCh[--newEndIdx];
		        }
		        else if (isSameVnode(oldStartVnode, newEndVnode)) {
		            patch(oldStartVnode, newEndVnode);
		            // We need to move the element for `oldStartVnode` into a position which
		            // will be appropriate for `newEndVnode`. For this we can use
		            // `.insertBefore` and `oldEndVnode.$elm$.nextSibling`. If there is a
		            // sibling for `oldEndVnode.$elm$` then we want to move the DOM node for
		            // `oldStartVnode` between `oldEndVnode` and it's sibling, like so:
		            //
		            // <old-start-node />
		            // <some-intervening-node />
		            // <old-end-node />
		            // <!-- ->              <-- `oldStartVnode.$elm$` should be inserted here
		            // <next-sibling />
		            //
		            // If instead `oldEndVnode.$elm$` has no sibling then we just want to put
		            // the node for `oldStartVnode` at the end of the children of
		            // `parentElm`. Luckily, `Node.nextSibling` will return `null` if there
		            // aren't any siblings, and passing `null` to `Node.insertBefore` will
		            // append it to the children of the parent element.
		            parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
		            oldStartVnode = oldCh[++oldStartIdx];
		            newEndVnode = newCh[--newEndIdx];
		        }
		        else if (isSameVnode(oldEndVnode, newStartVnode)) {
		            patch(oldEndVnode, newStartVnode);
		            // We've already checked above if `oldStartVnode` and `newStartVnode` are
		            // the same node, so since we're here we know that they are not. Thus we
		            // can move the element for `oldEndVnode` _before_ the element for
		            // `oldStartVnode`, leaving `oldStartVnode` to be reconciled in the
		            // future.
		            parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);
		            oldEndVnode = oldCh[--oldEndIdx];
		            newStartVnode = newCh[++newStartIdx];
		        }
		        else {
		            // Here we do some checks to match up old and new nodes based on the
		            // `$key$` attribute, which is set by putting a `key="my-key"` attribute
		            // in the JSX for a DOM element in the implementation of a Stencil
		            // component.
		            //
		            // First we check to see if there are any nodes in the array of old
		            // children which have the same key as the first node in the new
		            // children.
		            idxInOld = -1;
		            {
		                for (i = oldStartIdx; i <= oldEndIdx; ++i) {
		                    if (oldCh[i] && oldCh[i].$key$ !== null && oldCh[i].$key$ === newStartVnode.$key$) {
		                        idxInOld = i;
		                        break;
		                    }
		                }
		            }
		            if (idxInOld >= 0) {
		                // We found a node in the old children which matches up with the first
		                // node in the new children! So let's deal with that
		                elmToMove = oldCh[idxInOld];
		                if (elmToMove.$tag$ !== newStartVnode.$tag$) {
		                    // the tag doesn't match so we'll need a new DOM element
		                    node = createElm(oldCh && oldCh[newStartIdx], newVNode, idxInOld);
		                }
		                else {
		                    patch(elmToMove, newStartVnode);
		                    // invalidate the matching old node so that we won't try to update it
		                    // again later on
		                    oldCh[idxInOld] = undefined;
		                    node = elmToMove.$elm$;
		                }
		                newStartVnode = newCh[++newStartIdx];
		            }
		            else {
		                // We either didn't find an element in the old children that matches
		                // the key of the first new child OR the build is not using `key`
		                // attributes at all. In either case we need to create a new element
		                // for the new node.
		                node = createElm(oldCh && oldCh[newStartIdx], newVNode, newStartIdx);
		                newStartVnode = newCh[++newStartIdx];
		            }
		            if (node) {
		                // if we created a new node then handle inserting it to the DOM
		                {
		                    oldStartVnode.$elm$.parentNode.insertBefore(node, oldStartVnode.$elm$);
		                }
		            }
		        }
		    }
		    if (oldStartIdx > oldEndIdx) {
		        // we have some more new nodes to add which don't match up with old nodes
		        addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode, newCh, newStartIdx, newEndIdx);
		    }
		    else if (newStartIdx > newEndIdx) {
		        // there are nodes in the `oldCh` array which no longer correspond to nodes
		        // in the new array, so lets remove them (which entails cleaning up the
		        // relevant DOM nodes)
		        removeVnodes(oldCh, oldStartIdx, oldEndIdx);
		    }
		};
		/**
		 * Compare two VNodes to determine if they are the same
		 *
		 * **NB**: This function is an equality _heuristic_ based on the available
		 * information set on the two VNodes and can be misleading under certain
		 * circumstances. In particular, if the two nodes do not have `key` attrs
		 * (available under `$key$` on VNodes) then the function falls back on merely
		 * checking that they have the same tag.
		 *
		 * So, in other words, if `key` attrs are not set on VNodes which may be
		 * changing order within a `children` array or something along those lines then
		 * we could obtain a false negative and then have to do needless re-rendering
		 * (i.e. we'd say two VNodes aren't equal when in fact they should be).
		 *
		 * @param leftVNode the first VNode to check
		 * @param rightVNode the second VNode to check
		 * @returns whether they're equal or not
		 */
		const isSameVnode = (leftVNode, rightVNode) => {
		    // compare if two vnode to see if they're "technically" the same
		    // need to have the same element tag, and same key to be the same
		    if (leftVNode.$tag$ === rightVNode.$tag$) {
		        // this will be set if components in the build have `key` attrs set on them
		        {
		            return leftVNode.$key$ === rightVNode.$key$;
		        }
		    }
		    return false;
		};
		/**
		 * Handle reconciling an outdated VNode with a new one which corresponds to
		 * it. This function handles flushing updates to the DOM and reconciling the
		 * children of the two nodes (if any).
		 *
		 * @param oldVNode an old VNode whose DOM element and children we want to update
		 * @param newVNode a new VNode representing an updated version of the old one
		 */
		const patch = (oldVNode, newVNode) => {
		    const elm = (newVNode.$elm$ = oldVNode.$elm$);
		    const oldChildren = oldVNode.$children$;
		    const newChildren = newVNode.$children$;
		    const tag = newVNode.$tag$;
		    const text = newVNode.$text$;
		    if (text === null) {
		        {
		            // test if we're rendering an svg element, or still rendering nodes inside of one
		            // only add this to the when the compiler sees we're using an svg somewhere
		            isSvgMode = tag === 'svg' ? true : tag === 'foreignObject' ? false : isSvgMode;
		        }
		        {
		            if (tag === 'slot')
		                ;
		            else {
		                // either this is the first render of an element OR it's an update
		                // AND we already know it's possible it could have changed
		                // this updates the element's css classes, attrs, props, listeners, etc.
		                updateElement(oldVNode, newVNode, isSvgMode);
		            }
		        }
		        if (oldChildren !== null && newChildren !== null) {
		            // looks like there's child vnodes for both the old and new vnodes
		            // so we need to call `updateChildren` to reconcile them
		            updateChildren(elm, oldChildren, newVNode, newChildren);
		        }
		        else if (newChildren !== null) {
		            // no old child vnodes, but there are new child vnodes to add
		            if (oldVNode.$text$ !== null) {
		                // the old vnode was text, so be sure to clear it out
		                elm.textContent = '';
		            }
		            // add the new vnode children
		            addVnodes(elm, null, newVNode, newChildren, 0, newChildren.length - 1);
		        }
		        else if (oldChildren !== null) {
		            // no new child vnodes, but there are old child vnodes to remove
		            removeVnodes(oldChildren, 0, oldChildren.length - 1);
		        }
		        if (isSvgMode && tag === 'svg') {
		            isSvgMode = false;
		        }
		    }
		    else if (oldVNode.$text$ !== text) {
		        // update the text content for the text only vnode
		        // and also only if the text is different than before
		        elm.data = text;
		    }
		};
		/**
		 * 'Nullify' any VDom `ref` callbacks on a VDom node or its children by
		 * calling them with `null`. This signals that the DOM element corresponding to
		 * the VDom node has been removed from the DOM.
		 *
		 * @param vNode a virtual DOM node
		 */
		const nullifyVNodeRefs = (vNode) => {
		    {
		        vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);
		        vNode.$children$ && vNode.$children$.map(nullifyVNodeRefs);
		    }
		};
		/**
		 * The main entry point for Stencil's virtual DOM-based rendering engine
		 *
		 * Given a {@link d.HostRef} container and some virtual DOM nodes, this
		 * function will handle creating a virtual DOM tree with a single root, patching
		 * the current virtual DOM tree onto an old one (if any), dealing with slot
		 * relocation, and reflecting attributes.
		 *
		 * @param hostRef data needed to root and render the virtual DOM tree, such as
		 * the DOM node into which it should be rendered.
		 * @param renderFnResults the virtual DOM nodes to be rendered
		 * @param isInitialLoad whether or not this is the first call after page load
		 */
		const renderVdom = (hostRef, renderFnResults, isInitialLoad = false) => {
		    const hostElm = hostRef.$hostElement$;
		    const oldVNode = hostRef.$vnode$ || newVNode(null, null);
		    // if `renderFnResults` is a Host node then we can use it directly. If not,
		    // we need to call `h` again to wrap the children of our component in a
		    // 'dummy' Host node (well, an empty vnode) since `renderVdom` assumes
		    // implicitly that the top-level vdom node is 1) an only child and 2)
		    // contains attrs that need to be set on the host element.
		    const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);
		    hostTagName = hostElm.tagName;
		    // On the first render and *only* on the first render we want to check for
		    // any attributes set on the host element which are also set on the vdom
		    // node. If we find them, we override the value on the VDom node attrs with
		    // the value from the host element, which allows developers building apps
		    // with Stencil components to override e.g. the `role` attribute on a
		    // component even if it's already set on the `Host`.
		    if (isInitialLoad && rootVnode.$attrs$) {
		        for (const key of Object.keys(rootVnode.$attrs$)) {
		            // We have a special implementation in `setAccessor` for `style` and
		            // `class` which reconciles values coming from the VDom with values
		            // already present on the DOM element, so we don't want to override those
		            // attributes on the VDom tree with values from the host element if they
		            // are present.
		            //
		            // Likewise, `ref` and `key` are special internal values for the Stencil
		            // runtime and we don't want to override those either.
		            if (hostElm.hasAttribute(key) && !['key', 'ref', 'style', 'class'].includes(key)) {
		                rootVnode.$attrs$[key] = hostElm[key];
		            }
		        }
		    }
		    rootVnode.$tag$ = null;
		    rootVnode.$flags$ |= 4 /* VNODE_FLAGS.isHost */;
		    hostRef.$vnode$ = rootVnode;
		    rootVnode.$elm$ = oldVNode.$elm$ = (hostElm.shadowRoot || hostElm );
		    {
		        scopeId = hostElm['s-sc'];
		    }
		    // synchronous patch
		    patch(oldVNode, rootVnode);
		};
		const attachToAncestor = (hostRef, ancestorComponent) => {
		    if (ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent['s-p']) {
		        ancestorComponent['s-p'].push(new Promise((r) => (hostRef.$onRenderResolve$ = r)));
		    }
		};
		const scheduleUpdate = (hostRef, isInitialLoad) => {
		    {
		        hostRef.$flags$ |= 16 /* HOST_FLAGS.isQueuedForUpdate */;
		    }
		    if (hostRef.$flags$ & 4 /* HOST_FLAGS.isWaitingForChildren */) {
		        hostRef.$flags$ |= 512 /* HOST_FLAGS.needsRerender */;
		        return;
		    }
		    attachToAncestor(hostRef, hostRef.$ancestorComponent$);
		    // there is no ancestor component or the ancestor component
		    // has already fired off its lifecycle update then
		    // fire off the initial update
		    const dispatch = () => dispatchHooks(hostRef, isInitialLoad);
		    return writeTask(dispatch) ;
		};
		/**
		 * Dispatch initial-render and update lifecycle hooks, enqueuing calls to
		 * component lifecycle methods like `componentWillLoad` as well as
		 * {@link updateComponent}, which will kick off the virtual DOM re-render.
		 *
		 * @param hostRef a reference to a host DOM node
		 * @param isInitialLoad whether we're on the initial load or not
		 * @returns an empty Promise which is used to enqueue a series of operations for
		 * the component
		 */
		const dispatchHooks = (hostRef, isInitialLoad) => {
		    const endSchedule = createTime('scheduleUpdate', hostRef.$cmpMeta$.$tagName$);
		    const instance = hostRef.$lazyInstance$ ;
		    // We're going to use this variable together with `enqueue` to implement a
		    // little promise-based queue. We start out with it `undefined`. When we add
		    // the first function to the queue we'll set this variable to be that
		    // function's return value. When we attempt to add subsequent values to the
		    // queue we'll check that value and, if it was a `Promise`, we'll then chain
		    // the new function off of that `Promise` using `.then()`. This will give our
		    // queue two nice properties:
		    //
		    // 1. If all functions added to the queue are synchronous they'll be called
		    //    synchronously right away.
		    // 2. If all functions added to the queue are asynchronous they'll all be
		    //    called in order after `dispatchHooks` exits.
		    let maybePromise;
		    if (isInitialLoad) {
		        {
		            hostRef.$flags$ |= 256 /* HOST_FLAGS.isListenReady */;
		            if (hostRef.$queuedListeners$) {
		                hostRef.$queuedListeners$.map(([methodName, event]) => safeCall(instance, methodName, event));
		                hostRef.$queuedListeners$ = undefined;
		            }
		        }
		        {
		            // If `componentWillLoad` returns a `Promise` then we want to wait on
		            // whatever's going on in that `Promise` before we launch into
		            // rendering the component, doing other lifecycle stuff, etc. So
		            // in that case we assign the returned promise to the variable we
		            // declared above to hold a possible 'queueing' Promise
		            maybePromise = safeCall(instance, 'componentWillLoad');
		        }
		    }
		    else {
		        {
		            // Like `componentWillLoad` above, we allow Stencil component
		            // authors to return a `Promise` from this lifecycle callback, and
		            // we specify that our runtime will wait for that `Promise` to
		            // resolve before the component re-renders. So if the method
		            // returns a `Promise` we need to keep it around!
		            maybePromise = safeCall(instance, 'componentWillUpdate');
		        }
		    }
		    endSchedule();
		    return enqueue(maybePromise, () => updateComponent(hostRef, instance, isInitialLoad));
		};
		/**
		 * This function uses a Promise to implement a simple first-in, first-out queue
		 * of functions to be called.
		 *
		 * The queue is ordered on the basis of the first argument. If it's
		 * `undefined`, then nothing is on the queue yet, so the provided function can
		 * be called synchronously (although note that this function may return a
		 * `Promise`). The idea is that then the return value of that enqueueing
		 * operation is kept around, so that if it was a `Promise` then subsequent
		 * functions can be enqueued by calling this function again with that `Promise`
		 * as the first argument.
		 *
		 * @param maybePromise either a `Promise` which should resolve before the next function is called or an 'empty' sentinel
		 * @param fn a function to enqueue
		 * @returns either a `Promise` or the return value of the provided function
		 */
		const enqueue = (maybePromise, fn) => isPromisey(maybePromise) ? maybePromise.then(fn) : fn();
		/**
		 * Check that a value is a `Promise`. To check, we first see if the value is an
		 * instance of the `Promise` global. In a few circumstances, in particular if
		 * the global has been overwritten, this is could be misleading, so we also do
		 * a little 'duck typing' check to see if the `.then` property of the value is
		 * defined and a function.
		 *
		 * @param maybePromise it might be a promise!
		 * @returns whether it is or not
		 */
		const isPromisey = (maybePromise) => maybePromise instanceof Promise ||
		    (maybePromise && maybePromise.then && typeof maybePromise.then === 'function');
		/**
		 * Update a component given reference to its host elements and so on.
		 *
		 * @param hostRef an object containing references to the element's host node,
		 * VDom nodes, and other metadata
		 * @param instance a reference to the underlying host element where it will be
		 * rendered
		 * @param isInitialLoad whether or not this function is being called as part of
		 * the first render cycle
		 */
		const updateComponent = async (hostRef, instance, isInitialLoad) => {
		    var _a;
		    const elm = hostRef.$hostElement$;
		    const endUpdate = createTime('update', hostRef.$cmpMeta$.$tagName$);
		    const rc = elm['s-rc'];
		    const endRender = createTime('render', hostRef.$cmpMeta$.$tagName$);

		    //========= PDS PATCH START
		    if (elm.hasDSR) {
		        elm.shadowRoot.innerHTML = '';
		        delete elm.hasDSR;
		    }
		    //========= PDS PATCH END

		    {
		        callRender(hostRef, instance, elm, isInitialLoad);
		    }
		    if (rc) {
		        // ok, so turns out there are some child host elements
		        // waiting on this parent element to load
		        // let's fire off all update callbacks waiting
		        rc.map((cb) => cb());
		        elm['s-rc'] = undefined;
		    }
		    endRender();
		    endUpdate();
		    {
		        const childrenPromises = (_a = elm['s-p']) !== null && _a !== void 0 ? _a : [];
		        const postUpdate = () => postUpdateComponent(hostRef);
		        if (childrenPromises.length === 0) {
		            postUpdate();
		        }
		        else {
		            Promise.all(childrenPromises).then(postUpdate);
		            hostRef.$flags$ |= 4 /* HOST_FLAGS.isWaitingForChildren */;
		            childrenPromises.length = 0;
		        }
		    }
		};
		/**
		 * Handle making the call to the VDom renderer with the proper context given
		 * various build variables
		 *
		 * @param hostRef an object containing references to the element's host node,
		 * VDom nodes, and other metadata
		 * @param instance a reference to the underlying host element where it will be
		 * rendered
		 * @param elm the Host element for the component
		 * @param isInitialLoad whether or not this function is being called as part of
		 * @returns an empty promise
		 */
		const callRender = (hostRef, instance, elm, isInitialLoad) => {
		    try {
		        instance = instance.render() ;
		        {
		            hostRef.$flags$ &= ~16 /* HOST_FLAGS.isQueuedForUpdate */;
		        }
		        {
		            hostRef.$flags$ |= 2 /* HOST_FLAGS.hasRendered */;
		        }
		        {
		            {
		                // looks like we've got child nodes to render into this host element
		                // or we need to update the css class/attrs on the host element
		                // DOM WRITE!
		                {
		                    renderVdom(hostRef, instance, isInitialLoad);
		                }
		            }
		        }
		    }
		    catch (e) {
		        consoleError$1(e, hostRef.$hostElement$);
		    }
		    return null;
		};
		const postUpdateComponent = (hostRef) => {
		    const tagName = hostRef.$cmpMeta$.$tagName$;
		    const elm = hostRef.$hostElement$;
		    const endPostUpdate = createTime('postUpdate', tagName);
		    const instance = hostRef.$lazyInstance$ ;
		    const ancestorComponent = hostRef.$ancestorComponent$;
		    {
		        safeCall(instance, 'componentDidRender');
		    }
		    if (!(hostRef.$flags$ & 64 /* HOST_FLAGS.hasLoadedComponent */)) {
		        hostRef.$flags$ |= 64 /* HOST_FLAGS.hasLoadedComponent */;
		        {
		            // DOM WRITE!
		            addHydratedFlag(elm);
		        }
		        {
		            safeCall(instance, 'componentDidLoad');
		        }
		        endPostUpdate();
		        {
		            hostRef.$onReadyResolve$(elm);
		            if (!ancestorComponent) {
		                appDidLoad();
		            }
		        }
		    }
		    else {
		        {
		            safeCall(instance, 'componentDidUpdate');
		        }
		        endPostUpdate();
		    }
		    {
		        hostRef.$onInstanceResolve$(elm);
		    }
		    // load events fire from bottom to top
		    // the deepest elements load first then bubbles up
		    {
		        if (hostRef.$onRenderResolve$) {
		            hostRef.$onRenderResolve$();
		            hostRef.$onRenderResolve$ = undefined;
		        }
		        if (hostRef.$flags$ & 512 /* HOST_FLAGS.needsRerender */) {
		            nextTick(() => scheduleUpdate(hostRef, false));
		        }
		        hostRef.$flags$ &= ~(4 /* HOST_FLAGS.isWaitingForChildren */ | 512 /* HOST_FLAGS.needsRerender */);
		    }
		    // ( •_•)
		    // ( •_•)>⌐■-■
		    // (⌐■_■)
		};
		const forceUpdate = (ref) => {
		    {
		        const hostRef = getHostRef(ref);
		        const isConnected = hostRef.$hostElement$.isConnected;
		        if (isConnected &&
		            (hostRef.$flags$ & (2 /* HOST_FLAGS.hasRendered */ | 16 /* HOST_FLAGS.isQueuedForUpdate */)) === 2 /* HOST_FLAGS.hasRendered */) {
		            scheduleUpdate(hostRef, false);
		        }
		        // Returns "true" when the forced update was successfully scheduled
		        return isConnected;
		    }
		};
		const appDidLoad = (who) => {
		    // on appload
		    // we have finish the first big initial render
		    {
		        addHydratedFlag(doc.documentElement);
		    }
		    nextTick(() => emitEvent(win, 'appload', { detail: { namespace: NAMESPACE } }));
		};
		const safeCall = (instance, method, arg) => {
		    if (instance && instance[method]) {
		        try {
		            return instance[method](arg);
		        }
		        catch (e) {
		            consoleError$1(e);
		        }
		    }
		    return undefined;
		};
		const addHydratedFlag = (elm) => elm.classList.add('hydrated')
		    ;
		const getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);
		const setValue = (ref, propName, newVal, cmpMeta) => {
		    // check our new property value against our internal value
		    const hostRef = getHostRef(ref);
		    const elm = hostRef.$hostElement$ ;
		    const oldVal = hostRef.$instanceValues$.get(propName);
		    const flags = hostRef.$flags$;
		    const instance = hostRef.$lazyInstance$ ;
		    newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);
		    // explicitly check for NaN on both sides, as `NaN === NaN` is always false
		    const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);
		    const didValueChange = newVal !== oldVal && !areBothNaN;
		    if ((!(flags & 8 /* HOST_FLAGS.isConstructingInstance */) || oldVal === undefined) && didValueChange) {
		        // gadzooks! the property's value has changed!!
		        // set our new value!
		        hostRef.$instanceValues$.set(propName, newVal);
		        if (instance) {
		            // get an array of method names of watch functions to call
		            if (cmpMeta.$watchers$ && flags & 128 /* HOST_FLAGS.isWatchReady */) {
		                const watchMethods = cmpMeta.$watchers$[propName];
		                if (watchMethods) {
		                    // this instance is watching for when this property changed
		                    watchMethods.map((watchMethodName) => {
		                        try {
		                            // fire off each of the watch methods that are watching this property
		                            instance[watchMethodName](newVal, oldVal, propName);
		                        }
		                        catch (e) {
		                            consoleError$1(e, elm);
		                        }
		                    });
		                }
		            }
		            if ((flags & (2 /* HOST_FLAGS.hasRendered */ | 16 /* HOST_FLAGS.isQueuedForUpdate */)) === 2 /* HOST_FLAGS.hasRendered */) {
		                if (instance.componentShouldUpdate) {
		                    if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {
		                        return;
		                    }
		                }
		                // looks like this value actually changed, so we've got work to do!
		                // but only if we've already rendered, otherwise just chill out
		                // queue that we need to do an update, but don't worry about queuing
		                // up millions cuz this function ensures it only runs once
		                scheduleUpdate(hostRef, false);
		            }
		        }
		    }
		};
		/**
		 * Attach a series of runtime constructs to a compiled Stencil component
		 * constructor, including getters and setters for the `@Prop` and `@State`
		 * decorators, callbacks for when attributes change, and so on.
		 *
		 * @param Cstr the constructor for a component that we need to process
		 * @param cmpMeta metadata collected previously about the component
		 * @param flags a number used to store a series of bit flags
		 * @returns a reference to the same constructor passed in (but now mutated)
		 */
		const proxyComponent = (Cstr, cmpMeta, flags) => {
		    if (cmpMeta.$members$) {
		        if (Cstr.watchers) {
		            cmpMeta.$watchers$ = Cstr.watchers;
		        }
		        // It's better to have a const than two Object.entries()
		        const members = Object.entries(cmpMeta.$members$);
		        const prototype = Cstr.prototype;
		        members.map(([memberName, [memberFlags]]) => {
		            if ((memberFlags & 31 /* MEMBER_FLAGS.Prop */ ||
		                    ((flags & 2 /* PROXY_FLAGS.proxyState */) && memberFlags & 32 /* MEMBER_FLAGS.State */))) {
		                // proxyComponent - prop
		                Object.defineProperty(prototype, memberName, {
		                    get() {
		                        // proxyComponent, get value
		                        return getValue(this, memberName);
		                    },
		                    set(newValue) {
		                        // proxyComponent, set value
		                        setValue(this, memberName, newValue, cmpMeta);
		                    },
		                    configurable: true,
		                    enumerable: true,
		                });
		            }
		            else if (flags & 1 /* PROXY_FLAGS.isElementConstructor */ &&
		                memberFlags & 64 /* MEMBER_FLAGS.Method */) {
		                // proxyComponent - method
		                Object.defineProperty(prototype, memberName, {
		                    value(...args) {
		                        const ref = getHostRef(this);
		                        return ref.$onInstancePromise$.then(() => ref.$lazyInstance$[memberName](...args));
		                    },
		                });
		            }
		        });
		        if ((flags & 1 /* PROXY_FLAGS.isElementConstructor */)) {
		            const attrNameToPropName = new Map();
		            prototype.attributeChangedCallback = function (attrName, _oldValue, newValue) {
		                plt.jmp(() => {
		                    const propName = attrNameToPropName.get(attrName);
		                    //  In a web component lifecycle the attributeChangedCallback runs prior to connectedCallback
		                    //  in the case where an attribute was set inline.
		                    //  ```html
		                    //    <my-component some-attribute="some-value"></my-component>
		                    //  ```
		                    //
		                    //  There is an edge case where a developer sets the attribute inline on a custom element and then
		                    //  programmatically changes it before it has been upgraded as shown below:
		                    //
		                    //  ```html
		                    //    <!-- this component has _not_ been upgraded yet -->
		                    //    <my-component id="test" some-attribute="some-value"></my-component>
		                    //    <script>
		                    //      // grab non-upgraded component
		                    //      el = document.querySelector("#test");
		                    //      el.someAttribute = "another-value";
		                    //      // upgrade component
		                    //      customElements.define('my-component', MyComponent);
		                    //    </script>
		                    //  ```
		                    //  In this case if we do not unshadow here and use the value of the shadowing property, attributeChangedCallback
		                    //  will be called with `newValue = "some-value"` and will set the shadowed property (this.someAttribute = "another-value")
		                    //  to the value that was set inline i.e. "some-value" from above example. When
		                    //  the connectedCallback attempts to unshadow it will use "some-value" as the initial value rather than "another-value"
		                    //
		                    //  The case where the attribute was NOT set inline but was not set programmatically shall be handled/unshadowed
		                    //  by connectedCallback as this attributeChangedCallback will not fire.
		                    //
		                    //  https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties
		                    //
		                    //  TODO(STENCIL-16) we should think about whether or not we actually want to be reflecting the attributes to
		                    //  properties here given that this goes against best practices outlined here
		                    //  https://developers.google.com/web/fundamentals/web-components/best-practices#avoid-reentrancy
		                    if (this.hasOwnProperty(propName)) {
		                        newValue = this[propName];
		                        delete this[propName];
		                    }
		                    else if (prototype.hasOwnProperty(propName) &&
		                        typeof this[propName] === 'number' &&
		                        this[propName] == newValue) {
		                        // if the propName exists on the prototype of `Cstr`, this update may be a result of Stencil using native
		                        // APIs to reflect props as attributes. Calls to `setAttribute(someElement, propName)` will result in
		                        // `propName` to be converted to a `DOMString`, which may not be what we want for other primitive props.
		                        return;
		                    }
		                    this[propName] = newValue === null && typeof this[propName] === 'boolean' ? false : newValue;
		                });
		            };
		            // create an array of attributes to observe
		            // and also create a map of html attribute name to js property name
		            Cstr.observedAttributes = members
		                .filter(([_, m]) => m[0] & 15 /* MEMBER_FLAGS.HasAttribute */) // filter to only keep props that should match attributes
		                .map(([propName, m]) => {
		                const attrName = m[1] || propName;
		                attrNameToPropName.set(attrName, propName);
		                return attrName;
		            });
		        }
		    }
		    return Cstr;
		};
		const initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId, Cstr) => {
		    // initializeComponent
		    if ((hostRef.$flags$ & 32 /* HOST_FLAGS.hasInitializedComponent */) === 0) {
		        // Let the runtime know that the component has been initialized
		        hostRef.$flags$ |= 32 /* HOST_FLAGS.hasInitializedComponent */;
		        {
		            // lazy loaded components
		            // request the component's implementation to be
		            // wired up with the host element
		            Cstr = loadModule(cmpMeta);
		            if (Cstr.then) {
		                // Await creates a micro-task avoid if possible
		                const endLoad = uniqueTime();
		                Cstr = await Cstr;
		                endLoad();
		            }
		            if (!Cstr.isProxied) {
		                // we've never proxied this Constructor before
		                // let's add the getters/setters to its prototype before
		                // the first time we create an instance of the implementation
		                {
		                    cmpMeta.$watchers$ = Cstr.watchers;
		                }
		                proxyComponent(Cstr, cmpMeta, 2 /* PROXY_FLAGS.proxyState */);
		                Cstr.isProxied = true;
		            }
		            const endNewInstance = createTime('createInstance', cmpMeta.$tagName$);
		            // ok, time to construct the instance
		            // but let's keep track of when we start and stop
		            // so that the getters/setters don't incorrectly step on data
		            {
		                hostRef.$flags$ |= 8 /* HOST_FLAGS.isConstructingInstance */;
		            }
		            // construct the lazy-loaded component implementation
		            // passing the hostRef is very important during
		            // construction in order to directly wire together the
		            // host element and the lazy-loaded instance
		            try {
		                new Cstr(hostRef);
		            }
		            catch (e) {
		                consoleError$1(e);
		            }
		            {
		                hostRef.$flags$ &= ~8 /* HOST_FLAGS.isConstructingInstance */;
		            }
		            {
		                hostRef.$flags$ |= 128 /* HOST_FLAGS.isWatchReady */;
		            }
		            endNewInstance();
		            fireConnectedCallback(hostRef.$lazyInstance$);
		        }
		    }
		    // we've successfully created a lazy instance
		    const ancestorComponent = hostRef.$ancestorComponent$;
		    const schedule = () => scheduleUpdate(hostRef, true);
		    if (ancestorComponent && ancestorComponent['s-rc']) {
		        // this is the initial load and this component it has an ancestor component
		        // but the ancestor component has NOT fired its will update lifecycle yet
		        // so let's just cool our jets and wait for the ancestor to continue first
		        // this will get fired off when the ancestor component
		        // finally gets around to rendering its lazy self
		        // fire off the initial update
		        ancestorComponent['s-rc'].push(schedule);
		    }
		    else {
		        schedule();
		    }
		};
		const fireConnectedCallback = (instance) => {
		    {
		        safeCall(instance, 'connectedCallback');
		    }
		};
		const connectedCallback = (elm) => {
		    if ((plt.$flags$ & 1 /* PLATFORM_FLAGS.isTmpDisconnected */) === 0) {
		        const hostRef = getHostRef(elm);
		        const cmpMeta = hostRef.$cmpMeta$;
		        const endConnected = createTime('connectedCallback', cmpMeta.$tagName$);
		        if (!(hostRef.$flags$ & 1 /* HOST_FLAGS.hasConnected */)) {
		            // first time this component has connected
		            hostRef.$flags$ |= 1 /* HOST_FLAGS.hasConnected */;
		            {
		                // find the first ancestor component (if there is one) and register
		                // this component as one of the actively loading child components for its ancestor
		                let ancestorComponent = elm;
		                while ((ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host)) {
		                    // climb up the ancestors looking for the first
		                    // component that hasn't finished its lifecycle update yet
		                    if (ancestorComponent['s-p']) {
		                        // we found this components first ancestor component
		                        // keep a reference to this component's ancestor component
		                        attachToAncestor(hostRef, (hostRef.$ancestorComponent$ = ancestorComponent));
		                        break;
		                    }
		                }
		            }
		            // Lazy properties
		            // https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties
		            if (cmpMeta.$members$) {
		                Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {
		                    if (memberFlags & 31 /* MEMBER_FLAGS.Prop */ && elm.hasOwnProperty(memberName)) {
		                        const value = elm[memberName];
		                        delete elm[memberName];
		                        elm[memberName] = value;
		                    }
		                });
		            }
		            {
		                initializeComponent(elm, hostRef, cmpMeta);
		            }
		        }
		        else {
		            // not the first time this has connected
		            // reattach any event listeners to the host
		            // since they would have been removed when disconnected
		            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$);
		            // fire off connectedCallback() on component instance
		            if (hostRef === null || hostRef === void 0 ? void 0 : hostRef.$lazyInstance$) {
		                fireConnectedCallback(hostRef.$lazyInstance$);
		            }
		            else if (hostRef === null || hostRef === void 0 ? void 0 : hostRef.$onReadyPromise$) {
		                hostRef.$onReadyPromise$.then(() => fireConnectedCallback(hostRef.$lazyInstance$));
		            }
		        }
		        endConnected();
		    }
		};
		const disconnectInstance = (instance) => {
		    {
		        safeCall(instance, 'disconnectedCallback');
		    }
		};
		const disconnectedCallback = async (elm) => {
		    if ((plt.$flags$ & 1 /* PLATFORM_FLAGS.isTmpDisconnected */) === 0) {
		        const hostRef = getHostRef(elm);
		        {
		            if (hostRef.$rmListeners$) {
		                hostRef.$rmListeners$.map((rmListener) => rmListener());
		                hostRef.$rmListeners$ = undefined;
		            }
		        }
		        if (hostRef === null || hostRef === void 0 ? void 0 : hostRef.$lazyInstance$) {
		            disconnectInstance(hostRef.$lazyInstance$);
		        }
		        else if (hostRef === null || hostRef === void 0 ? void 0 : hostRef.$onReadyPromise$) {
		            hostRef.$onReadyPromise$.then(() => disconnectInstance(hostRef.$lazyInstance$));
		        }
		    }
		};
		const bootstrapLazy = (lazyBundles, options = {}) => {
		    const endBootstrap = createTime();
		    const exclude = options.exclude || [];
		    const customElements = win.customElements;
		    const deferredConnectedCallbacks = [];
		    let appLoadFallback;
		    let isBootstrapping = true;
		    Object.assign(plt, options);
		    plt.$resourcesUrl$ = new URL(options.resourcesUrl || './', doc.baseURI).href;
		    lazyBundles.map((lazyBundle) => {
		        lazyBundle[1].map((compactMeta) => {
		            const cmpMeta = {
		                $flags$: compactMeta[0],
		                $tagName$: compactMeta[1],
		                $members$: compactMeta[2],
		                $listeners$: compactMeta[3],
		            };
		            {
		                cmpMeta.$members$ = compactMeta[2];
		            }
		            {
		                cmpMeta.$listeners$ = compactMeta[3];
		            }
		            {
		                cmpMeta.$watchers$ = {};
		            }
		            const tagName = options.transformTagName
		                ? options.transformTagName(cmpMeta.$tagName$)
		                : cmpMeta.$tagName$;
		            const HostElement = class extends HTMLElement {
		                // StencilLazyHost
		                constructor(self) {
		                    // @ts-ignore
		                    super(self);
		                    self = this;
		                    registerHost(self, cmpMeta);
		                    if (cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) {
		                        // this component is using shadow dom
		                        // and this browser supports shadow dom
		                        // add the read-only property "shadowRoot" to the host element
		                        // adding the shadow root build conditionals to minimize runtime
		                        {
		                            //========= PDS PATCH START
		                            let ssrInnerHTML = '';
		                            if (self.shadowRoot) {
		                              ssrInnerHTML = self.shadowRoot.innerHTML;
		                              self.hasDSR = true;
		                            }
		                            //========= PDS PATCH END

		                            {
		                                //========= PDS PATCH START
		                                // in dsr ponyfilled browsers (e.g. Safari), the shadowRoot is already attached
		                                // and a 2nd attempt fails, therefore this needs to always run without SSR
		                                // and only with SSR for browsers that are not ponyfilled
		                                if (!self.hasDSR || HTMLTemplateElement.prototype.hasOwnProperty('shadowRoot')) {
		                                //========= PDS PATCH END

		                                self.attachShadow({
		                                    mode: 'open',
		                                    delegatesFocus: !!(cmpMeta.$flags$ & 16 /* CMP_FLAGS.shadowDelegatesFocus */),
		                                });

		                                //========= PDS PATCH START
		                                    self.shadowRoot.innerHTML = ssrInnerHTML;
		                                }
		                                //========= PDS PATCH END

		                            }
		                        }
		                    }
		                }
		                connectedCallback() {
		                    if (appLoadFallback) {
		                        clearTimeout(appLoadFallback);
		                        appLoadFallback = null;
		                    }
		                    if (isBootstrapping) {
		                        // connectedCallback will be processed once all components have been registered
		                        deferredConnectedCallbacks.push(this);
		                    }
		                    else {
		                        plt.jmp(() => connectedCallback(this));
		                    }
		                }
		                disconnectedCallback() {
		                    plt.jmp(() => disconnectedCallback(this));
		                }
		                componentOnReady() {
		                    return getHostRef(this).$onReadyPromise$;
		                }
		            };
		            cmpMeta.$lazyBundleId$ = lazyBundle[0];
		            if (!exclude.includes(tagName) && !customElements.get(tagName)) {
		                customElements.define(tagName, proxyComponent(HostElement, cmpMeta, 1 /* PROXY_FLAGS.isElementConstructor */));
		            }
		        });
		    });
		    // Process deferred connectedCallbacks now all components have been registered
		    isBootstrapping = false;
		    if (deferredConnectedCallbacks.length) {
		        deferredConnectedCallbacks.map((host) => host.connectedCallback());
		    }
		    else {
		        {
		            plt.jmp(() => (appLoadFallback = setTimeout(appDidLoad, 30)));
		        }
		    }
		    // Fallback appLoad event
		    endBootstrap();
		};
		const addHostEventListeners = (elm, hostRef, listeners, attachParentListeners) => {
		    if (listeners) {
		        listeners.map(([flags, name, method]) => {
		            const target = elm;
		            const handler = hostListenerProxy(hostRef, method);
		            const opts = hostListenerOpts(flags);
		            plt.ael(target, name, handler, opts);
		            (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));
		        });
		    }
		};
		const hostListenerProxy = (hostRef, methodName) => (ev) => {
		    try {
		        {
		            if (hostRef.$flags$ & 256 /* HOST_FLAGS.isListenReady */) {
		                // instance is ready, let's call it's member method for this event
		                hostRef.$lazyInstance$[methodName](ev);
		            }
		            else {
		                (hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([methodName, ev]);
		            }
		        }
		    }
		    catch (e) {
		        consoleError$1(e);
		    }
		};
		// prettier-ignore
		const hostListenerOpts = (flags) => (flags & 2 /* LISTENER_FLAGS.Capture */) !== 0;
		/**
		 * Assigns the given value to the nonce property on the runtime platform object.
		 * During runtime, this value is used to set the nonce attribute on all dynamically created script and style tags.
		 * @param nonce The value to be assigned to the platform nonce property.
		 * @returns void
		 */
		const setNonce = (nonce) => (plt.$nonce$ = nonce);
		const hostRefs = /*@__PURE__*/ new WeakMap();
		const getHostRef = (ref) => hostRefs.get(ref);
		const registerInstance = (lazyInstance, hostRef) => hostRefs.set((hostRef.$lazyInstance$ = lazyInstance), hostRef);
		const registerHost = (elm, cmpMeta) => {
		    const hostRef = {
		        $flags$: 0,
		        $hostElement$: elm,
		        $cmpMeta$: cmpMeta,
		        $instanceValues$: new Map(),
		    };
		    {
		        hostRef.$onInstancePromise$ = new Promise((r) => (hostRef.$onInstanceResolve$ = r));
		    }
		    {
		        hostRef.$onReadyPromise$ = new Promise((r) => (hostRef.$onReadyResolve$ = r));
		        elm['s-p'] = [];
		        elm['s-rc'] = [];
		    }
		    addHostEventListeners(elm, hostRef, cmpMeta.$listeners$);
		    return hostRefs.set(elm, hostRef);
		};
		const isMemberInElement = (elm, memberName) => memberName in elm;
		const consoleError$1 = (e, el) => (0, console.error)(e, el);
		const cmpModules = /*@__PURE__*/ new Map();
		const loadModule = (cmpMeta, hostRef, hmrVersionId) => {
		    // loadModuleImport
		    const exportName = cmpMeta.$tagName$.replace(/-/g, '_');
		    const bundleId = cmpMeta.$lazyBundleId$;
		    const module = cmpModules.get(bundleId) ;
		    if (module) {
		        return module[exportName];
		    }
		    /*!__STENCIL_STATIC_IMPORT_SWITCH__*/
		    return Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(createCommonjsRequire("/src/lib")(
		    /* @vite-ignore */
		    /* webpackInclude: /\.entry\.js$/ */
		    /* webpackExclude: /\.system\.entry\.js$/ */
		    /* webpackMode: "lazy" */
		    `./${bundleId}.entry.js${''}`)); }).then((importedModule) => {
		        {
		            cmpModules.set(bundleId, importedModule);
		        }
		        return importedModule[exportName];
		    }, consoleError$1);
		};
		const win = typeof window !== 'undefined' ? window : {};
		const doc = win.document || { head: {} };
		const plt = {
		    $flags$: 0,
		    $resourcesUrl$: '',
		    jmp: (h) => h(),
		    raf: (h) => requestAnimationFrame(h),
		    ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),
		    rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),
		    ce: (eventName, opts) => new CustomEvent(eventName, opts),
		};
		const promiseResolve = (v) => Promise.resolve(v);
		const queueDomReads = [];
		const queueDomWrites = [];
		const queueTask = (queue, write) => (cb) => {
		    queue.push(cb);
		    if (!queuePending) {
		        queuePending = true;
		        if (write && plt.$flags$ & 4 /* PLATFORM_FLAGS.queueSync */) {
		            nextTick(flush);
		        }
		        else {
		            plt.raf(flush);
		        }
		    }
		};
		const consume = (queue) => {
		    for (let i = 0; i < queue.length; i++) {
		        try {
		            queue[i](performance.now());
		        }
		        catch (e) {
		            consoleError$1(e);
		        }
		    }
		    queue.length = 0;
		};
		const flush = () => {
		    // always force a bunch of medium callbacks to run, but still have
		    // a throttle on how many can run in a certain time
		    // DOM READS!!!
		    consume(queueDomReads);
		    // DOM WRITES!!!
		    {
		        consume(queueDomWrites);
		        if ((queuePending = queueDomReads.length > 0)) {
		            // still more to do yet, but we've run out of time
		            // let's let this thing cool off and try again in the next tick
		            plt.raf(flush);
		        }
		    }
		};
		const nextTick = /*@__PURE__*/ (cb) => promiseResolve().then(cb);
		const writeTask = /*@__PURE__*/ queueTask(queueDomWrites, true);

		const TAG_NAMES = ['p-accordion', 'p-banner', 'p-button', 'p-button-group', 'p-button-pure', 'p-button-tile', 'p-carousel', 'p-checkbox-wrapper', 'p-content-wrapper', 'p-crest', 'p-display', 'p-divider', 'p-fieldset', 'p-fieldset-wrapper', 'p-flex', 'p-flex-item', 'p-flyout', 'p-grid', 'p-grid-item', 'p-heading', 'p-headline', 'p-icon', 'p-inline-notification', 'p-link', 'p-link-pure', 'p-link-social', 'p-link-tile', 'p-link-tile-model-signature', 'p-marque', 'p-modal', 'p-model-signature', 'p-multi-select', 'p-multi-select-option', 'p-pagination', 'p-pin-code', 'p-popover', 'p-radio-button-wrapper', 'p-scroller', 'p-segmented-control', 'p-segmented-control-item', 'p-select-wrapper', 'p-select-wrapper-dropdown', 'p-spinner', 'p-stepper-horizontal', 'p-stepper-horizontal-item', 'p-switch', 'p-table', 'p-table-body', 'p-table-cell', 'p-table-head', 'p-table-head-cell', 'p-table-head-row', 'p-table-row', 'p-tabs', 'p-tabs-bar', 'p-tabs-item', 'p-tag', 'p-tag-dismissible', 'p-text', 'p-text-field-wrapper', 'p-text-list', 'p-text-list-item', 'p-textarea-wrapper', 'p-toast', 'p-toast-item', 'p-wordmark'];

		function _extends() {
		  _extends = Object.assign ? Object.assign.bind() : function (target) {
		    for (var i = 1; i < arguments.length; i++) {
		      var source = arguments[i];
		      for (var key in source) {
		        if (Object.prototype.hasOwnProperty.call(source, key)) {
		          target[key] = source[key];
		        }
		      }
		    }
		    return target;
		  };
		  return _extends.apply(this, arguments);
		}

		var _typeof$1 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

		var isBrowser = (typeof window === "undefined" ? "undefined" : _typeof$1(window)) === "object" && (typeof document === "undefined" ? "undefined" : _typeof$1(document)) === 'object' && document.nodeType === 9;

		function _typeof(o) {
		  "@babel/helpers - typeof";

		  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
		    return typeof o;
		  } : function (o) {
		    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
		  }, _typeof(o);
		}

		function _toPrimitive(input, hint) {
		  if (_typeof(input) !== "object" || input === null) return input;
		  var prim = input[Symbol.toPrimitive];
		  if (prim !== undefined) {
		    var res = prim.call(input, hint || "default");
		    if (_typeof(res) !== "object") return res;
		    throw new TypeError("@@toPrimitive must return a primitive value.");
		  }
		  return (hint === "string" ? String : Number)(input);
		}

		function _toPropertyKey(arg) {
		  var key = _toPrimitive(arg, "string");
		  return _typeof(key) === "symbol" ? key : String(key);
		}

		function _defineProperties(target, props) {
		  for (var i = 0; i < props.length; i++) {
		    var descriptor = props[i];
		    descriptor.enumerable = descriptor.enumerable || false;
		    descriptor.configurable = true;
		    if ("value" in descriptor) descriptor.writable = true;
		    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
		  }
		}
		function _createClass(Constructor, protoProps, staticProps) {
		  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
		  if (staticProps) _defineProperties(Constructor, staticProps);
		  Object.defineProperty(Constructor, "prototype", {
		    writable: false
		  });
		  return Constructor;
		}

		function _setPrototypeOf(o, p) {
		  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
		    o.__proto__ = p;
		    return o;
		  };
		  return _setPrototypeOf(o, p);
		}

		function _inheritsLoose(subClass, superClass) {
		  subClass.prototype = Object.create(superClass.prototype);
		  subClass.prototype.constructor = subClass;
		  _setPrototypeOf(subClass, superClass);
		}

		function _assertThisInitialized(self) {
		  if (self === void 0) {
		    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		  }
		  return self;
		}

		function _objectWithoutPropertiesLoose(source, excluded) {
		  if (source == null) return {};
		  var target = {};
		  var sourceKeys = Object.keys(source);
		  var key, i;
		  for (i = 0; i < sourceKeys.length; i++) {
		    key = sourceKeys[i];
		    if (excluded.indexOf(key) >= 0) continue;
		    target[key] = source[key];
		  }
		  return target;
		}

		var plainObjectConstrurctor = {}.constructor;
		function cloneStyle(style) {
		  if (style == null || typeof style !== 'object') return style;
		  if (Array.isArray(style)) return style.map(cloneStyle);
		  if (style.constructor !== plainObjectConstrurctor) return style;
		  var newStyle = {};

		  for (var name in style) {
		    newStyle[name] = cloneStyle(style[name]);
		  }

		  return newStyle;
		}

		/**
		 * Create a rule instance.
		 */

		function createRule(name, decl, options) {
		  if (name === void 0) {
		    name = 'unnamed';
		  }

		  var jss = options.jss;
		  var declCopy = cloneStyle(decl);
		  var rule = jss.plugins.onCreateRule(name, declCopy, options);
		  if (rule) return rule; // It is an at-rule and it has no instance.

		  return null;
		}

		var join = function join(value, by) {
		  var result = '';

		  for (var i = 0; i < value.length; i++) {
		    // Remove !important from the value, it will be readded later.
		    if (value[i] === '!important') break;
		    if (result) result += by;
		    result += value[i];
		  }

		  return result;
		};
		/**
		 * Converts JSS array value to a CSS string.
		 *
		 * `margin: [['5px', '10px']]` > `margin: 5px 10px;`
		 * `border: ['1px', '2px']` > `border: 1px, 2px;`
		 * `margin: [['5px', '10px'], '!important']` > `margin: 5px 10px !important;`
		 * `color: ['red', !important]` > `color: red !important;`
		 */


		var toCssValue = function toCssValue(value) {
		  if (!Array.isArray(value)) return value;
		  var cssValue = ''; // Support space separated values via `[['5px', '10px']]`.

		  if (Array.isArray(value[0])) {
		    for (var i = 0; i < value.length; i++) {
		      if (value[i] === '!important') break;
		      if (cssValue) cssValue += ', ';
		      cssValue += join(value[i], ' ');
		    }
		  } else cssValue = join(value, ', '); // Add !important, because it was ignored.


		  if (value[value.length - 1] === '!important') {
		    cssValue += ' !important';
		  }

		  return cssValue;
		};

		function getWhitespaceSymbols(options) {
		  if (options && options.format === false) {
		    return {
		      linebreak: '',
		      space: ''
		    };
		  }

		  return {
		    linebreak: '\n',
		    space: ' '
		  };
		}

		/**
		 * Indent a string.
		 * http://jsperf.com/array-join-vs-for
		 */

		function indentStr(str, indent) {
		  var result = '';

		  for (var index = 0; index < indent; index++) {
		    result += '  ';
		  }

		  return result + str;
		}
		/**
		 * Converts a Rule to CSS string.
		 */


		function toCss(selector, style, options) {
		  if (options === void 0) {
		    options = {};
		  }

		  var result = '';
		  if (!style) return result;
		  var _options = options,
		      _options$indent = _options.indent,
		      indent = _options$indent === void 0 ? 0 : _options$indent;
		  var fallbacks = style.fallbacks;

		  if (options.format === false) {
		    indent = -Infinity;
		  }

		  var _getWhitespaceSymbols = getWhitespaceSymbols(options),
		      linebreak = _getWhitespaceSymbols.linebreak,
		      space = _getWhitespaceSymbols.space;

		  if (selector) indent++; // Apply fallbacks first.

		  if (fallbacks) {
		    // Array syntax {fallbacks: [{prop: value}]}
		    if (Array.isArray(fallbacks)) {
		      for (var index = 0; index < fallbacks.length; index++) {
		        var fallback = fallbacks[index];

		        for (var prop in fallback) {
		          var value = fallback[prop];

		          if (value != null) {
		            if (result) result += linebreak;
		            result += indentStr(prop + ":" + space + toCssValue(value) + ";", indent);
		          }
		        }
		      }
		    } else {
		      // Object syntax {fallbacks: {prop: value}}
		      for (var _prop in fallbacks) {
		        var _value = fallbacks[_prop];

		        if (_value != null) {
		          if (result) result += linebreak;
		          result += indentStr(_prop + ":" + space + toCssValue(_value) + ";", indent);
		        }
		      }
		    }
		  }

		  for (var _prop2 in style) {
		    var _value2 = style[_prop2];

		    if (_value2 != null && _prop2 !== 'fallbacks') {
		      if (result) result += linebreak;
		      result += indentStr(_prop2 + ":" + space + toCssValue(_value2) + ";", indent);
		    }
		  } // Allow empty style in this case, because properties will be added dynamically.


		  if (!result && !options.allowEmpty) return result; // When rule is being stringified before selector was defined.

		  if (!selector) return result;
		  indent--;
		  if (result) result = "" + linebreak + result + linebreak;
		  return indentStr("" + selector + space + "{" + result, indent) + indentStr('}', indent);
		}

		var escapeRegex = /([[\].#*$><+~=|^:(),"'`\s])/g;
		var nativeEscape = typeof CSS !== 'undefined' && CSS.escape;
		var escape = (function (str) {
		  return nativeEscape ? nativeEscape(str) : str.replace(escapeRegex, '\\$1');
		});

		var BaseStyleRule =
		/*#__PURE__*/
		function () {
		  function BaseStyleRule(key, style, options) {
		    this.type = 'style';
		    this.isProcessed = false;
		    var sheet = options.sheet,
		        Renderer = options.Renderer;
		    this.key = key;
		    this.options = options;
		    this.style = style;
		    if (sheet) this.renderer = sheet.renderer;else if (Renderer) this.renderer = new Renderer();
		  }
		  /**
		   * Get or set a style property.
		   */


		  var _proto = BaseStyleRule.prototype;

		  _proto.prop = function prop(name, value, options) {
		    // It's a getter.
		    if (value === undefined) return this.style[name]; // Don't do anything if the value has not changed.

		    var force = options ? options.force : false;
		    if (!force && this.style[name] === value) return this;
		    var newValue = value;

		    if (!options || options.process !== false) {
		      newValue = this.options.jss.plugins.onChangeValue(value, name, this);
		    }

		    var isEmpty = newValue == null || newValue === false;
		    var isDefined = name in this.style; // Value is empty and wasn't defined before.

		    if (isEmpty && !isDefined && !force) return this; // We are going to remove this value.

		    var remove = isEmpty && isDefined;
		    if (remove) delete this.style[name];else this.style[name] = newValue; // Renderable is defined if StyleSheet option `link` is true.

		    if (this.renderable && this.renderer) {
		      if (remove) this.renderer.removeProperty(this.renderable, name);else this.renderer.setProperty(this.renderable, name, newValue);
		      return this;
		    }

		    return this;
		  };

		  return BaseStyleRule;
		}();
		var StyleRule =
		/*#__PURE__*/
		function (_BaseStyleRule) {
		  _inheritsLoose(StyleRule, _BaseStyleRule);

		  function StyleRule(key, style, options) {
		    var _this;

		    _this = _BaseStyleRule.call(this, key, style, options) || this;
		    var selector = options.selector,
		        scoped = options.scoped,
		        sheet = options.sheet,
		        generateId = options.generateId;

		    if (selector) {
		      _this.selectorText = selector;
		    } else if (scoped !== false) {
		      _this.id = generateId(_assertThisInitialized(_assertThisInitialized(_this)), sheet);
		      _this.selectorText = "." + escape(_this.id);
		    }

		    return _this;
		  }
		  /**
		   * Set selector string.
		   * Attention: use this with caution. Most browsers didn't implement
		   * selectorText setter, so this may result in rerendering of entire Style Sheet.
		   */


		  var _proto2 = StyleRule.prototype;

		  /**
		   * Apply rule to an element inline.
		   */
		  _proto2.applyTo = function applyTo(renderable) {
		    var renderer = this.renderer;

		    if (renderer) {
		      var json = this.toJSON();

		      for (var prop in json) {
		        renderer.setProperty(renderable, prop, json[prop]);
		      }
		    }

		    return this;
		  }
		  /**
		   * Returns JSON representation of the rule.
		   * Fallbacks are not supported.
		   * Useful for inline styles.
		   */
		  ;

		  _proto2.toJSON = function toJSON() {
		    var json = {};

		    for (var prop in this.style) {
		      var value = this.style[prop];
		      if (typeof value !== 'object') json[prop] = value;else if (Array.isArray(value)) json[prop] = toCssValue(value);
		    }

		    return json;
		  }
		  /**
		   * Generates a CSS string.
		   */
		  ;

		  _proto2.toString = function toString(options) {
		    var sheet = this.options.sheet;
		    var link = sheet ? sheet.options.link : false;
		    var opts = link ? _extends({}, options, {
		      allowEmpty: true
		    }) : options;
		    return toCss(this.selectorText, this.style, opts);
		  };

		  _createClass(StyleRule, [{
		    key: "selector",
		    set: function set(selector) {
		      if (selector === this.selectorText) return;
		      this.selectorText = selector;
		      var renderer = this.renderer,
		          renderable = this.renderable;
		      if (!renderable || !renderer) return;
		      var hasChanged = renderer.setSelector(renderable, selector); // If selector setter is not implemented, rerender the rule.

		      if (!hasChanged) {
		        renderer.replaceRule(renderable, this);
		      }
		    }
		    /**
		     * Get selector string.
		     */
		    ,
		    get: function get() {
		      return this.selectorText;
		    }
		  }]);

		  return StyleRule;
		}(BaseStyleRule);
		var pluginStyleRule = {
		  onCreateRule: function onCreateRule(key, style, options) {
		    if (key[0] === '@' || options.parent && options.parent.type === 'keyframes') {
		      return null;
		    }

		    return new StyleRule(key, style, options);
		  }
		};

		var defaultToStringOptions = {
		  indent: 1,
		  children: true
		};
		var atRegExp = /@([\w-]+)/;
		/**
		 * Conditional rule for @media, @supports
		 */

		var ConditionalRule =
		/*#__PURE__*/
		function () {
		  function ConditionalRule(key, styles, options) {
		    this.type = 'conditional';
		    this.isProcessed = false;
		    this.key = key;
		    var atMatch = key.match(atRegExp);
		    this.at = atMatch ? atMatch[1] : 'unknown'; // Key might contain a unique suffix in case the `name` passed by user was duplicate.

		    this.query = options.name || "@" + this.at;
		    this.options = options;
		    this.rules = new RuleList(_extends({}, options, {
		      parent: this
		    }));

		    for (var name in styles) {
		      this.rules.add(name, styles[name]);
		    }

		    this.rules.process();
		  }
		  /**
		   * Get a rule.
		   */


		  var _proto = ConditionalRule.prototype;

		  _proto.getRule = function getRule(name) {
		    return this.rules.get(name);
		  }
		  /**
		   * Get index of a rule.
		   */
		  ;

		  _proto.indexOf = function indexOf(rule) {
		    return this.rules.indexOf(rule);
		  }
		  /**
		   * Create and register rule, run plugins.
		   */
		  ;

		  _proto.addRule = function addRule(name, style, options) {
		    var rule = this.rules.add(name, style, options);
		    if (!rule) return null;
		    this.options.jss.plugins.onProcessRule(rule);
		    return rule;
		  }
		  /**
		   * Replace rule, run plugins.
		   */
		  ;

		  _proto.replaceRule = function replaceRule(name, style, options) {
		    var newRule = this.rules.replace(name, style, options);
		    if (newRule) this.options.jss.plugins.onProcessRule(newRule);
		    return newRule;
		  }
		  /**
		   * Generates a CSS string.
		   */
		  ;

		  _proto.toString = function toString(options) {
		    if (options === void 0) {
		      options = defaultToStringOptions;
		    }

		    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
		        linebreak = _getWhitespaceSymbols.linebreak;

		    if (options.indent == null) options.indent = defaultToStringOptions.indent;
		    if (options.children == null) options.children = defaultToStringOptions.children;

		    if (options.children === false) {
		      return this.query + " {}";
		    }

		    var children = this.rules.toString(options);
		    return children ? this.query + " {" + linebreak + children + linebreak + "}" : '';
		  };

		  return ConditionalRule;
		}();
		var keyRegExp = /@container|@media|@supports\s+/;
		var pluginConditionalRule = {
		  onCreateRule: function onCreateRule(key, styles, options) {
		    return keyRegExp.test(key) ? new ConditionalRule(key, styles, options) : null;
		  }
		};

		var defaultToStringOptions$1 = {
		  indent: 1,
		  children: true
		};
		var nameRegExp = /@keyframes\s+([\w-]+)/;
		/**
		 * Rule for @keyframes
		 */

		var KeyframesRule =
		/*#__PURE__*/
		function () {
		  function KeyframesRule(key, frames, options) {
		    this.type = 'keyframes';
		    this.at = '@keyframes';
		    this.isProcessed = false;
		    var nameMatch = key.match(nameRegExp);

		    if (nameMatch && nameMatch[1]) {
		      this.name = nameMatch[1];
		    } else {
		      this.name = 'noname';
		    }

		    this.key = this.type + "-" + this.name;
		    this.options = options;
		    var scoped = options.scoped,
		        sheet = options.sheet,
		        generateId = options.generateId;
		    this.id = scoped === false ? this.name : escape(generateId(this, sheet));
		    this.rules = new RuleList(_extends({}, options, {
		      parent: this
		    }));

		    for (var name in frames) {
		      this.rules.add(name, frames[name], _extends({}, options, {
		        parent: this
		      }));
		    }

		    this.rules.process();
		  }
		  /**
		   * Generates a CSS string.
		   */


		  var _proto = KeyframesRule.prototype;

		  _proto.toString = function toString(options) {
		    if (options === void 0) {
		      options = defaultToStringOptions$1;
		    }

		    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
		        linebreak = _getWhitespaceSymbols.linebreak;

		    if (options.indent == null) options.indent = defaultToStringOptions$1.indent;
		    if (options.children == null) options.children = defaultToStringOptions$1.children;

		    if (options.children === false) {
		      return this.at + " " + this.id + " {}";
		    }

		    var children = this.rules.toString(options);
		    if (children) children = "" + linebreak + children + linebreak;
		    return this.at + " " + this.id + " {" + children + "}";
		  };

		  return KeyframesRule;
		}();
		var keyRegExp$1 = /@keyframes\s+/;
		var refRegExp$1 = /\$([\w-]+)/g;

		var findReferencedKeyframe = function findReferencedKeyframe(val, keyframes) {
		  if (typeof val === 'string') {
		    return val.replace(refRegExp$1, function (match, name) {
		      if (name in keyframes) {
		        return keyframes[name];
		      }
		      return match;
		    });
		  }

		  return val;
		};
		/**
		 * Replace the reference for a animation name.
		 */


		var replaceRef = function replaceRef(style, prop, keyframes) {
		  var value = style[prop];
		  var refKeyframe = findReferencedKeyframe(value, keyframes);

		  if (refKeyframe !== value) {
		    style[prop] = refKeyframe;
		  }
		};

		var pluginKeyframesRule = {
		  onCreateRule: function onCreateRule(key, frames, options) {
		    return typeof key === 'string' && keyRegExp$1.test(key) ? new KeyframesRule(key, frames, options) : null;
		  },
		  // Animation name ref replacer.
		  onProcessStyle: function onProcessStyle(style, rule, sheet) {
		    if (rule.type !== 'style' || !sheet) return style;
		    if ('animation-name' in style) replaceRef(style, 'animation-name', sheet.keyframes);
		    if ('animation' in style) replaceRef(style, 'animation', sheet.keyframes);
		    return style;
		  },
		  onChangeValue: function onChangeValue(val, prop, rule) {
		    var sheet = rule.options.sheet;

		    if (!sheet) {
		      return val;
		    }

		    switch (prop) {
		      case 'animation':
		        return findReferencedKeyframe(val, sheet.keyframes);

		      case 'animation-name':
		        return findReferencedKeyframe(val, sheet.keyframes);

		      default:
		        return val;
		    }
		  }
		};

		var KeyframeRule =
		/*#__PURE__*/
		function (_BaseStyleRule) {
		  _inheritsLoose(KeyframeRule, _BaseStyleRule);

		  function KeyframeRule() {
		    return _BaseStyleRule.apply(this, arguments) || this;
		  }

		  var _proto = KeyframeRule.prototype;

		  /**
		   * Generates a CSS string.
		   */
		  _proto.toString = function toString(options) {
		    var sheet = this.options.sheet;
		    var link = sheet ? sheet.options.link : false;
		    var opts = link ? _extends({}, options, {
		      allowEmpty: true
		    }) : options;
		    return toCss(this.key, this.style, opts);
		  };

		  return KeyframeRule;
		}(BaseStyleRule);
		var pluginKeyframeRule = {
		  onCreateRule: function onCreateRule(key, style, options) {
		    if (options.parent && options.parent.type === 'keyframes') {
		      return new KeyframeRule(key, style, options);
		    }

		    return null;
		  }
		};

		var FontFaceRule =
		/*#__PURE__*/
		function () {
		  function FontFaceRule(key, style, options) {
		    this.type = 'font-face';
		    this.at = '@font-face';
		    this.isProcessed = false;
		    this.key = key;
		    this.style = style;
		    this.options = options;
		  }
		  /**
		   * Generates a CSS string.
		   */


		  var _proto = FontFaceRule.prototype;

		  _proto.toString = function toString(options) {
		    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
		        linebreak = _getWhitespaceSymbols.linebreak;

		    if (Array.isArray(this.style)) {
		      var str = '';

		      for (var index = 0; index < this.style.length; index++) {
		        str += toCss(this.at, this.style[index]);
		        if (this.style[index + 1]) str += linebreak;
		      }

		      return str;
		    }

		    return toCss(this.at, this.style, options);
		  };

		  return FontFaceRule;
		}();
		var keyRegExp$2 = /@font-face/;
		var pluginFontFaceRule = {
		  onCreateRule: function onCreateRule(key, style, options) {
		    return keyRegExp$2.test(key) ? new FontFaceRule(key, style, options) : null;
		  }
		};

		var ViewportRule =
		/*#__PURE__*/
		function () {
		  function ViewportRule(key, style, options) {
		    this.type = 'viewport';
		    this.at = '@viewport';
		    this.isProcessed = false;
		    this.key = key;
		    this.style = style;
		    this.options = options;
		  }
		  /**
		   * Generates a CSS string.
		   */


		  var _proto = ViewportRule.prototype;

		  _proto.toString = function toString(options) {
		    return toCss(this.key, this.style, options);
		  };

		  return ViewportRule;
		}();
		var pluginViewportRule = {
		  onCreateRule: function onCreateRule(key, style, options) {
		    return key === '@viewport' || key === '@-ms-viewport' ? new ViewportRule(key, style, options) : null;
		  }
		};

		var SimpleRule =
		/*#__PURE__*/
		function () {
		  function SimpleRule(key, value, options) {
		    this.type = 'simple';
		    this.isProcessed = false;
		    this.key = key;
		    this.value = value;
		    this.options = options;
		  }
		  /**
		   * Generates a CSS string.
		   */
		  // eslint-disable-next-line no-unused-vars


		  var _proto = SimpleRule.prototype;

		  _proto.toString = function toString(options) {
		    if (Array.isArray(this.value)) {
		      var str = '';

		      for (var index = 0; index < this.value.length; index++) {
		        str += this.key + " " + this.value[index] + ";";
		        if (this.value[index + 1]) str += '\n';
		      }

		      return str;
		    }

		    return this.key + " " + this.value + ";";
		  };

		  return SimpleRule;
		}();
		var keysMap = {
		  '@charset': true,
		  '@import': true,
		  '@namespace': true
		};
		var pluginSimpleRule = {
		  onCreateRule: function onCreateRule(key, value, options) {
		    return key in keysMap ? new SimpleRule(key, value, options) : null;
		  }
		};

		var plugins = [pluginStyleRule, pluginConditionalRule, pluginKeyframesRule, pluginKeyframeRule, pluginFontFaceRule, pluginViewportRule, pluginSimpleRule];

		var defaultUpdateOptions = {
		  process: true
		};
		var forceUpdateOptions = {
		  force: true,
		  process: true
		  /**
		   * Contains rules objects and allows adding/removing etc.
		   * Is used for e.g. by `StyleSheet` or `ConditionalRule`.
		   */

		};

		var RuleList =
		/*#__PURE__*/
		function () {
		  // Rules registry for access by .get() method.
		  // It contains the same rule registered by name and by selector.
		  // Original styles object.
		  // Used to ensure correct rules order.
		  function RuleList(options) {
		    this.map = {};
		    this.raw = {};
		    this.index = [];
		    this.counter = 0;
		    this.options = options;
		    this.classes = options.classes;
		    this.keyframes = options.keyframes;
		  }
		  /**
		   * Create and register rule.
		   *
		   * Will not render after Style Sheet was rendered the first time.
		   */


		  var _proto = RuleList.prototype;

		  _proto.add = function add(name, decl, ruleOptions) {
		    var _this$options = this.options,
		        parent = _this$options.parent,
		        sheet = _this$options.sheet,
		        jss = _this$options.jss,
		        Renderer = _this$options.Renderer,
		        generateId = _this$options.generateId,
		        scoped = _this$options.scoped;

		    var options = _extends({
		      classes: this.classes,
		      parent: parent,
		      sheet: sheet,
		      jss: jss,
		      Renderer: Renderer,
		      generateId: generateId,
		      scoped: scoped,
		      name: name,
		      keyframes: this.keyframes,
		      selector: undefined
		    }, ruleOptions); // When user uses .createStyleSheet(), duplicate names are not possible, but
		    // `sheet.addRule()` opens the door for any duplicate rule name. When this happens
		    // we need to make the key unique within this RuleList instance scope.


		    var key = name;

		    if (name in this.raw) {
		      key = name + "-d" + this.counter++;
		    } // We need to save the original decl before creating the rule
		    // because cache plugin needs to use it as a key to return a cached rule.


		    this.raw[key] = decl;

		    if (key in this.classes) {
		      // E.g. rules inside of @media container
		      options.selector = "." + escape(this.classes[key]);
		    }

		    var rule = createRule(key, decl, options);
		    if (!rule) return null;
		    this.register(rule);
		    var index = options.index === undefined ? this.index.length : options.index;
		    this.index.splice(index, 0, rule);
		    return rule;
		  }
		  /**
		   * Replace rule.
		   * Create a new rule and remove old one instead of overwriting
		   * because we want to invoke onCreateRule hook to make plugins work.
		   */
		  ;

		  _proto.replace = function replace(name, decl, ruleOptions) {
		    var oldRule = this.get(name);
		    var oldIndex = this.index.indexOf(oldRule);

		    if (oldRule) {
		      this.remove(oldRule);
		    }

		    var options = ruleOptions;
		    if (oldIndex !== -1) options = _extends({}, ruleOptions, {
		      index: oldIndex
		    });
		    return this.add(name, decl, options);
		  }
		  /**
		   * Get a rule by name or selector.
		   */
		  ;

		  _proto.get = function get(nameOrSelector) {
		    return this.map[nameOrSelector];
		  }
		  /**
		   * Delete a rule.
		   */
		  ;

		  _proto.remove = function remove(rule) {
		    this.unregister(rule);
		    delete this.raw[rule.key];
		    this.index.splice(this.index.indexOf(rule), 1);
		  }
		  /**
		   * Get index of a rule.
		   */
		  ;

		  _proto.indexOf = function indexOf(rule) {
		    return this.index.indexOf(rule);
		  }
		  /**
		   * Run `onProcessRule()` plugins on every rule.
		   */
		  ;

		  _proto.process = function process() {
		    var plugins = this.options.jss.plugins; // We need to clone array because if we modify the index somewhere else during a loop
		    // we end up with very hard-to-track-down side effects.

		    this.index.slice(0).forEach(plugins.onProcessRule, plugins);
		  }
		  /**
		   * Register a rule in `.map`, `.classes` and `.keyframes` maps.
		   */
		  ;

		  _proto.register = function register(rule) {
		    this.map[rule.key] = rule;

		    if (rule instanceof StyleRule) {
		      this.map[rule.selector] = rule;
		      if (rule.id) this.classes[rule.key] = rule.id;
		    } else if (rule instanceof KeyframesRule && this.keyframes) {
		      this.keyframes[rule.name] = rule.id;
		    }
		  }
		  /**
		   * Unregister a rule.
		   */
		  ;

		  _proto.unregister = function unregister(rule) {
		    delete this.map[rule.key];

		    if (rule instanceof StyleRule) {
		      delete this.map[rule.selector];
		      delete this.classes[rule.key];
		    } else if (rule instanceof KeyframesRule) {
		      delete this.keyframes[rule.name];
		    }
		  }
		  /**
		   * Update the function values with a new data.
		   */
		  ;

		  _proto.update = function update() {
		    var name;
		    var data;
		    var options;

		    if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {
		      name = arguments.length <= 0 ? undefined : arguments[0];
		      data = arguments.length <= 1 ? undefined : arguments[1];
		      options = arguments.length <= 2 ? undefined : arguments[2];
		    } else {
		      data = arguments.length <= 0 ? undefined : arguments[0];
		      options = arguments.length <= 1 ? undefined : arguments[1];
		      name = null;
		    }

		    if (name) {
		      this.updateOne(this.get(name), data, options);
		    } else {
		      for (var index = 0; index < this.index.length; index++) {
		        this.updateOne(this.index[index], data, options);
		      }
		    }
		  }
		  /**
		   * Execute plugins, update rule props.
		   */
		  ;

		  _proto.updateOne = function updateOne(rule, data, options) {
		    if (options === void 0) {
		      options = defaultUpdateOptions;
		    }

		    var _this$options2 = this.options,
		        plugins = _this$options2.jss.plugins,
		        sheet = _this$options2.sheet; // It is a rules container like for e.g. ConditionalRule.

		    if (rule.rules instanceof RuleList) {
		      rule.rules.update(data, options);
		      return;
		    }

		    var style = rule.style;
		    plugins.onUpdate(data, rule, sheet, options); // We rely on a new `style` ref in case it was mutated during onUpdate hook.

		    if (options.process && style && style !== rule.style) {
		      // We need to run the plugins in case new `style` relies on syntax plugins.
		      plugins.onProcessStyle(rule.style, rule, sheet); // Update and add props.

		      for (var prop in rule.style) {
		        var nextValue = rule.style[prop];
		        var prevValue = style[prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
		        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.

		        if (nextValue !== prevValue) {
		          rule.prop(prop, nextValue, forceUpdateOptions);
		        }
		      } // Remove props.


		      for (var _prop in style) {
		        var _nextValue = rule.style[_prop];
		        var _prevValue = style[_prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
		        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.

		        if (_nextValue == null && _nextValue !== _prevValue) {
		          rule.prop(_prop, null, forceUpdateOptions);
		        }
		      }
		    }
		  }
		  /**
		   * Convert rules to a CSS string.
		   */
		  ;

		  _proto.toString = function toString(options) {
		    var str = '';
		    var sheet = this.options.sheet;
		    var link = sheet ? sheet.options.link : false;

		    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
		        linebreak = _getWhitespaceSymbols.linebreak;

		    for (var index = 0; index < this.index.length; index++) {
		      var rule = this.index[index];
		      var css = rule.toString(options); // No need to render an empty rule.

		      if (!css && !link) continue;
		      if (str) str += linebreak;
		      str += css;
		    }

		    return str;
		  };

		  return RuleList;
		}();

		var StyleSheet =
		/*#__PURE__*/
		function () {
		  function StyleSheet(styles, options) {
		    this.attached = false;
		    this.deployed = false;
		    this.classes = {};
		    this.keyframes = {};
		    this.options = _extends({}, options, {
		      sheet: this,
		      parent: this,
		      classes: this.classes,
		      keyframes: this.keyframes
		    });

		    if (options.Renderer) {
		      this.renderer = new options.Renderer(this);
		    }

		    this.rules = new RuleList(this.options);

		    for (var name in styles) {
		      this.rules.add(name, styles[name]);
		    }

		    this.rules.process();
		  }
		  /**
		   * Attach renderable to the render tree.
		   */


		  var _proto = StyleSheet.prototype;

		  _proto.attach = function attach() {
		    if (this.attached) return this;
		    if (this.renderer) this.renderer.attach();
		    this.attached = true; // Order is important, because we can't use insertRule API if style element is not attached.

		    if (!this.deployed) this.deploy();
		    return this;
		  }
		  /**
		   * Remove renderable from render tree.
		   */
		  ;

		  _proto.detach = function detach() {
		    if (!this.attached) return this;
		    if (this.renderer) this.renderer.detach();
		    this.attached = false;
		    return this;
		  }
		  /**
		   * Add a rule to the current stylesheet.
		   * Will insert a rule also after the stylesheet has been rendered first time.
		   */
		  ;

		  _proto.addRule = function addRule(name, decl, options) {
		    var queue = this.queue; // Plugins can create rules.
		    // In order to preserve the right order, we need to queue all `.addRule` calls,
		    // which happen after the first `rules.add()` call.

		    if (this.attached && !queue) this.queue = [];
		    var rule = this.rules.add(name, decl, options);
		    if (!rule) return null;
		    this.options.jss.plugins.onProcessRule(rule);

		    if (this.attached) {
		      if (!this.deployed) return rule; // Don't insert rule directly if there is no stringified version yet.
		      // It will be inserted all together when .attach is called.

		      if (queue) queue.push(rule);else {
		        this.insertRule(rule);

		        if (this.queue) {
		          this.queue.forEach(this.insertRule, this);
		          this.queue = undefined;
		        }
		      }
		      return rule;
		    } // We can't add rules to a detached style node.
		    // We will redeploy the sheet once user will attach it.


		    this.deployed = false;
		    return rule;
		  }
		  /**
		   * Replace a rule in the current stylesheet.
		   */
		  ;

		  _proto.replaceRule = function replaceRule(nameOrSelector, decl, options) {
		    var oldRule = this.rules.get(nameOrSelector);
		    if (!oldRule) return this.addRule(nameOrSelector, decl, options);
		    var newRule = this.rules.replace(nameOrSelector, decl, options);

		    if (newRule) {
		      this.options.jss.plugins.onProcessRule(newRule);
		    }

		    if (this.attached) {
		      if (!this.deployed) return newRule; // Don't replace / delete rule directly if there is no stringified version yet.
		      // It will be inserted all together when .attach is called.

		      if (this.renderer) {
		        if (!newRule) {
		          this.renderer.deleteRule(oldRule);
		        } else if (oldRule.renderable) {
		          this.renderer.replaceRule(oldRule.renderable, newRule);
		        }
		      }

		      return newRule;
		    } // We can't replace rules to a detached style node.
		    // We will redeploy the sheet once user will attach it.


		    this.deployed = false;
		    return newRule;
		  }
		  /**
		   * Insert rule into the StyleSheet
		   */
		  ;

		  _proto.insertRule = function insertRule(rule) {
		    if (this.renderer) {
		      this.renderer.insertRule(rule);
		    }
		  }
		  /**
		   * Create and add rules.
		   * Will render also after Style Sheet was rendered the first time.
		   */
		  ;

		  _proto.addRules = function addRules(styles, options) {
		    var added = [];

		    for (var name in styles) {
		      var rule = this.addRule(name, styles[name], options);
		      if (rule) added.push(rule);
		    }

		    return added;
		  }
		  /**
		   * Get a rule by name or selector.
		   */
		  ;

		  _proto.getRule = function getRule(nameOrSelector) {
		    return this.rules.get(nameOrSelector);
		  }
		  /**
		   * Delete a rule by name.
		   * Returns `true`: if rule has been deleted from the DOM.
		   */
		  ;

		  _proto.deleteRule = function deleteRule(name) {
		    var rule = typeof name === 'object' ? name : this.rules.get(name);

		    if (!rule || // Style sheet was created without link: true and attached, in this case we
		    // won't be able to remove the CSS rule from the DOM.
		    this.attached && !rule.renderable) {
		      return false;
		    }

		    this.rules.remove(rule);

		    if (this.attached && rule.renderable && this.renderer) {
		      return this.renderer.deleteRule(rule.renderable);
		    }

		    return true;
		  }
		  /**
		   * Get index of a rule.
		   */
		  ;

		  _proto.indexOf = function indexOf(rule) {
		    return this.rules.indexOf(rule);
		  }
		  /**
		   * Deploy pure CSS string to a renderable.
		   */
		  ;

		  _proto.deploy = function deploy() {
		    if (this.renderer) this.renderer.deploy();
		    this.deployed = true;
		    return this;
		  }
		  /**
		   * Update the function values with a new data.
		   */
		  ;

		  _proto.update = function update() {
		    var _this$rules;

		    (_this$rules = this.rules).update.apply(_this$rules, arguments);

		    return this;
		  }
		  /**
		   * Updates a single rule.
		   */
		  ;

		  _proto.updateOne = function updateOne(rule, data, options) {
		    this.rules.updateOne(rule, data, options);
		    return this;
		  }
		  /**
		   * Convert rules to a CSS string.
		   */
		  ;

		  _proto.toString = function toString(options) {
		    return this.rules.toString(options);
		  };

		  return StyleSheet;
		}();

		var PluginsRegistry =
		/*#__PURE__*/
		function () {
		  function PluginsRegistry() {
		    this.plugins = {
		      internal: [],
		      external: []
		    };
		    this.registry = {};
		  }

		  var _proto = PluginsRegistry.prototype;

		  /**
		   * Call `onCreateRule` hooks and return an object if returned by a hook.
		   */
		  _proto.onCreateRule = function onCreateRule(name, decl, options) {
		    for (var i = 0; i < this.registry.onCreateRule.length; i++) {
		      var rule = this.registry.onCreateRule[i](name, decl, options);
		      if (rule) return rule;
		    }

		    return null;
		  }
		  /**
		   * Call `onProcessRule` hooks.
		   */
		  ;

		  _proto.onProcessRule = function onProcessRule(rule) {
		    if (rule.isProcessed) return;
		    var sheet = rule.options.sheet;

		    for (var i = 0; i < this.registry.onProcessRule.length; i++) {
		      this.registry.onProcessRule[i](rule, sheet);
		    }

		    if (rule.style) this.onProcessStyle(rule.style, rule, sheet);
		    rule.isProcessed = true;
		  }
		  /**
		   * Call `onProcessStyle` hooks.
		   */
		  ;

		  _proto.onProcessStyle = function onProcessStyle(style, rule, sheet) {
		    for (var i = 0; i < this.registry.onProcessStyle.length; i++) {
		      rule.style = this.registry.onProcessStyle[i](rule.style, rule, sheet);
		    }
		  }
		  /**
		   * Call `onProcessSheet` hooks.
		   */
		  ;

		  _proto.onProcessSheet = function onProcessSheet(sheet) {
		    for (var i = 0; i < this.registry.onProcessSheet.length; i++) {
		      this.registry.onProcessSheet[i](sheet);
		    }
		  }
		  /**
		   * Call `onUpdate` hooks.
		   */
		  ;

		  _proto.onUpdate = function onUpdate(data, rule, sheet, options) {
		    for (var i = 0; i < this.registry.onUpdate.length; i++) {
		      this.registry.onUpdate[i](data, rule, sheet, options);
		    }
		  }
		  /**
		   * Call `onChangeValue` hooks.
		   */
		  ;

		  _proto.onChangeValue = function onChangeValue(value, prop, rule) {
		    var processedValue = value;

		    for (var i = 0; i < this.registry.onChangeValue.length; i++) {
		      processedValue = this.registry.onChangeValue[i](processedValue, prop, rule);
		    }

		    return processedValue;
		  }
		  /**
		   * Register a plugin.
		   */
		  ;

		  _proto.use = function use(newPlugin, options) {
		    if (options === void 0) {
		      options = {
		        queue: 'external'
		      };
		    }

		    var plugins = this.plugins[options.queue]; // Avoids applying same plugin twice, at least based on ref.

		    if (plugins.indexOf(newPlugin) !== -1) {
		      return;
		    }

		    plugins.push(newPlugin);
		    this.registry = [].concat(this.plugins.external, this.plugins.internal).reduce(function (registry, plugin) {
		      for (var name in plugin) {
		        if (name in registry) {
		          registry[name].push(plugin[name]);
		        }
		      }

		      return registry;
		    }, {
		      onCreateRule: [],
		      onProcessRule: [],
		      onProcessStyle: [],
		      onProcessSheet: [],
		      onChangeValue: [],
		      onUpdate: []
		    });
		  };

		  return PluginsRegistry;
		}();

		/**
		 * Sheets registry to access all instances in one place.
		 */

		var SheetsRegistry =
		/*#__PURE__*/
		function () {
		  function SheetsRegistry() {
		    this.registry = [];
		  }

		  var _proto = SheetsRegistry.prototype;

		  /**
		   * Register a Style Sheet.
		   */
		  _proto.add = function add(sheet) {
		    var registry = this.registry;
		    var index = sheet.options.index;
		    if (registry.indexOf(sheet) !== -1) return;

		    if (registry.length === 0 || index >= this.index) {
		      registry.push(sheet);
		      return;
		    } // Find a position.


		    for (var i = 0; i < registry.length; i++) {
		      if (registry[i].options.index > index) {
		        registry.splice(i, 0, sheet);
		        return;
		      }
		    }
		  }
		  /**
		   * Reset the registry.
		   */
		  ;

		  _proto.reset = function reset() {
		    this.registry = [];
		  }
		  /**
		   * Remove a Style Sheet.
		   */
		  ;

		  _proto.remove = function remove(sheet) {
		    var index = this.registry.indexOf(sheet);
		    this.registry.splice(index, 1);
		  }
		  /**
		   * Convert all attached sheets to a CSS string.
		   */
		  ;

		  _proto.toString = function toString(_temp) {
		    var _ref = _temp === void 0 ? {} : _temp,
		        attached = _ref.attached,
		        options = _objectWithoutPropertiesLoose(_ref, ["attached"]);

		    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
		        linebreak = _getWhitespaceSymbols.linebreak;

		    var css = '';

		    for (var i = 0; i < this.registry.length; i++) {
		      var sheet = this.registry[i];

		      if (attached != null && sheet.attached !== attached) {
		        continue;
		      }

		      if (css) css += linebreak;
		      css += sheet.toString(options);
		    }

		    return css;
		  };

		  _createClass(SheetsRegistry, [{
		    key: "index",

		    /**
		     * Current highest index number.
		     */
		    get: function get() {
		      return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;
		    }
		  }]);

		  return SheetsRegistry;
		}();

		/**
		 * This is a global sheets registry. Only DomRenderer will add sheets to it.
		 * On the server one should use an own SheetsRegistry instance and add the
		 * sheets to it, because you need to make sure to create a new registry for
		 * each request in order to not leak sheets across requests.
		 */

		var sheets = new SheetsRegistry();

		/* eslint-disable */

		/**
		 * Now that `globalThis` is available on most platforms
		 * (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis#browser_compatibility)
		 * we check for `globalThis` first. `globalThis` is necessary for jss
		 * to run in Agoric's secure version of JavaScript (SES). Under SES,
		 * `globalThis` exists, but `window`, `self`, and `Function('return
		 * this')()` are all undefined for security reasons.
		 *
		 * https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
		 */
		var globalThis$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' && window.Math === Math ? window : typeof self !== 'undefined' && self.Math === Math ? self : Function('return this')();

		var ns = '2f1acc6c3a606b082e5eef5e54414ffb';
		if (globalThis$1[ns] == null) globalThis$1[ns] = 0; // Bundle may contain multiple JSS versions at the same time. In order to identify
		// the current version with just one short number and use it for classes generation
		// we use a counter. Also it is more accurate, because user can manually reevaluate
		// the module.

		var moduleId = globalThis$1[ns]++;
		/**
		 * Returns a function which generates unique class names based on counters.
		 * When new generator function is created, rule counter is reseted.
		 * We need to reset the rule counter for SSR for each request.
		 */

		var createGenerateId = function createGenerateId(options) {
		  if (options === void 0) {
		    options = {};
		  }

		  var ruleCounter = 0;

		  var generateId = function generateId(rule, sheet) {
		    ruleCounter += 1;

		    var jssId = '';
		    var prefix = '';

		    if (sheet) {
		      if (sheet.options.classNamePrefix) {
		        prefix = sheet.options.classNamePrefix;
		      }

		      if (sheet.options.jss.id != null) {
		        jssId = String(sheet.options.jss.id);
		      }
		    }

		    if (options.minify) {
		      // Using "c" because a number can't be the first char in a class name.
		      return "" + (prefix || 'c') + moduleId + jssId + ruleCounter;
		    }

		    return prefix + rule.key + "-" + moduleId + (jssId ? "-" + jssId : '') + "-" + ruleCounter;
		  };

		  return generateId;
		};

		/**
		 * Cache the value from the first time a function is called.
		 */

		var memoize = function memoize(fn) {
		  var value;
		  return function () {
		    if (!value) value = fn();
		    return value;
		  };
		};
		/**
		 * Get a style property value.
		 */


		var getPropertyValue = function getPropertyValue(cssRule, prop) {
		  try {
		    // Support CSSTOM.
		    if (cssRule.attributeStyleMap) {
		      return cssRule.attributeStyleMap.get(prop);
		    }

		    return cssRule.style.getPropertyValue(prop);
		  } catch (err) {
		    // IE may throw if property is unknown.
		    return '';
		  }
		};
		/**
		 * Set a style property.
		 */


		var setProperty = function setProperty(cssRule, prop, value) {
		  try {
		    var cssValue = value;

		    if (Array.isArray(value)) {
		      cssValue = toCssValue(value);
		    } // Support CSSTOM.


		    if (cssRule.attributeStyleMap) {
		      cssRule.attributeStyleMap.set(prop, cssValue);
		    } else {
		      var indexOfImportantFlag = cssValue ? cssValue.indexOf('!important') : -1;
		      var cssValueWithoutImportantFlag = indexOfImportantFlag > -1 ? cssValue.substr(0, indexOfImportantFlag - 1) : cssValue;
		      cssRule.style.setProperty(prop, cssValueWithoutImportantFlag, indexOfImportantFlag > -1 ? 'important' : '');
		    }
		  } catch (err) {
		    // IE may throw if property is unknown.
		    return false;
		  }

		  return true;
		};
		/**
		 * Remove a style property.
		 */


		var removeProperty = function removeProperty(cssRule, prop) {
		  try {
		    // Support CSSTOM.
		    if (cssRule.attributeStyleMap) {
		      cssRule.attributeStyleMap.delete(prop);
		    } else {
		      cssRule.style.removeProperty(prop);
		    }
		  } catch (err) {
		  }
		};
		/**
		 * Set the selector.
		 */


		var setSelector = function setSelector(cssRule, selectorText) {
		  cssRule.selectorText = selectorText; // Return false if setter was not successful.
		  // Currently works in chrome only.

		  return cssRule.selectorText === selectorText;
		};
		/**
		 * Gets the `head` element upon the first call and caches it.
		 * We assume it can't be null.
		 */


		var getHead = memoize(function () {
		  return document.querySelector('head');
		});
		/**
		 * Find attached sheet with an index higher than the passed one.
		 */

		function findHigherSheet(registry, options) {
		  for (var i = 0; i < registry.length; i++) {
		    var sheet = registry[i];

		    if (sheet.attached && sheet.options.index > options.index && sheet.options.insertionPoint === options.insertionPoint) {
		      return sheet;
		    }
		  }

		  return null;
		}
		/**
		 * Find attached sheet with the highest index.
		 */


		function findHighestSheet(registry, options) {
		  for (var i = registry.length - 1; i >= 0; i--) {
		    var sheet = registry[i];

		    if (sheet.attached && sheet.options.insertionPoint === options.insertionPoint) {
		      return sheet;
		    }
		  }

		  return null;
		}
		/**
		 * Find a comment with "jss" inside.
		 */


		function findCommentNode(text) {
		  var head = getHead();

		  for (var i = 0; i < head.childNodes.length; i++) {
		    var node = head.childNodes[i];

		    if (node.nodeType === 8 && node.nodeValue.trim() === text) {
		      return node;
		    }
		  }

		  return null;
		}
		/**
		 * Find a node before which we can insert the sheet.
		 */


		function findPrevNode(options) {
		  var registry = sheets.registry;

		  if (registry.length > 0) {
		    // Try to insert before the next higher sheet.
		    var sheet = findHigherSheet(registry, options);

		    if (sheet && sheet.renderer) {
		      return {
		        parent: sheet.renderer.element.parentNode,
		        node: sheet.renderer.element
		      };
		    } // Otherwise insert after the last attached.


		    sheet = findHighestSheet(registry, options);

		    if (sheet && sheet.renderer) {
		      return {
		        parent: sheet.renderer.element.parentNode,
		        node: sheet.renderer.element.nextSibling
		      };
		    }
		  } // Try to find a comment placeholder if registry is empty.


		  var insertionPoint = options.insertionPoint;

		  if (insertionPoint && typeof insertionPoint === 'string') {
		    var comment = findCommentNode(insertionPoint);

		    if (comment) {
		      return {
		        parent: comment.parentNode,
		        node: comment.nextSibling
		      };
		    } // If user specifies an insertion point and it can't be found in the document -
		  }

		  return false;
		}
		/**
		 * Insert style element into the DOM.
		 */


		function insertStyle(style, options) {
		  var insertionPoint = options.insertionPoint;
		  var nextNode = findPrevNode(options);

		  if (nextNode !== false && nextNode.parent) {
		    nextNode.parent.insertBefore(style, nextNode.node);
		    return;
		  } // Works with iframes and any node types.


		  if (insertionPoint && typeof insertionPoint.nodeType === 'number') {
		    var insertionPointElement = insertionPoint;
		    var parentNode = insertionPointElement.parentNode;
		    if (parentNode) parentNode.insertBefore(style, insertionPointElement.nextSibling);
		    return;
		  }

		  getHead().appendChild(style);
		}
		/**
		 * Read jss nonce setting from the page if the user has set it.
		 */


		var getNonce = memoize(function () {
		  var node = document.querySelector('meta[property="csp-nonce"]');
		  return node ? node.getAttribute('content') : null;
		});

		var _insertRule = function insertRule(container, rule, index) {
		  try {
		    if ('insertRule' in container) {
		      container.insertRule(rule, index);
		    } // Keyframes rule.
		    else if ('appendRule' in container) {
		        container.appendRule(rule);
		      }
		  } catch (err) {
		    return false;
		  }

		  return container.cssRules[index];
		};

		var getValidRuleInsertionIndex = function getValidRuleInsertionIndex(container, index) {
		  var maxIndex = container.cssRules.length; // In case previous insertion fails, passed index might be wrong

		  if (index === undefined || index > maxIndex) {
		    // eslint-disable-next-line no-param-reassign
		    return maxIndex;
		  }

		  return index;
		};

		var createStyle = function createStyle() {
		  var el = document.createElement('style'); // Without it, IE will have a broken source order specificity if we
		  // insert rules after we insert the style tag.
		  // It seems to kick-off the source order specificity algorithm.

		  el.textContent = '\n';
		  return el;
		};

		var DomRenderer =
		/*#__PURE__*/
		function () {
		  // Will be empty if link: true option is not set, because
		  // it is only for use together with insertRule API.
		  function DomRenderer(sheet) {
		    this.getPropertyValue = getPropertyValue;
		    this.setProperty = setProperty;
		    this.removeProperty = removeProperty;
		    this.setSelector = setSelector;
		    this.hasInsertedRules = false;
		    this.cssRules = [];
		    // There is no sheet when the renderer is used from a standalone StyleRule.
		    if (sheet) sheets.add(sheet);
		    this.sheet = sheet;

		    var _ref = this.sheet ? this.sheet.options : {},
		        media = _ref.media,
		        meta = _ref.meta,
		        element = _ref.element;

		    this.element = element || createStyle();
		    this.element.setAttribute('data-jss', '');
		    if (media) this.element.setAttribute('media', media);
		    if (meta) this.element.setAttribute('data-meta', meta);
		    var nonce = getNonce();
		    if (nonce) this.element.setAttribute('nonce', nonce);
		  }
		  /**
		   * Insert style element into render tree.
		   */


		  var _proto = DomRenderer.prototype;

		  _proto.attach = function attach() {
		    // In the case the element node is external and it is already in the DOM.
		    if (this.element.parentNode || !this.sheet) return;
		    insertStyle(this.element, this.sheet.options); // When rules are inserted using `insertRule` API, after `sheet.detach().attach()`
		    // most browsers create a new CSSStyleSheet, except of all IEs.

		    var deployed = Boolean(this.sheet && this.sheet.deployed);

		    if (this.hasInsertedRules && deployed) {
		      this.hasInsertedRules = false;
		      this.deploy();
		    }
		  }
		  /**
		   * Remove style element from render tree.
		   */
		  ;

		  _proto.detach = function detach() {
		    if (!this.sheet) return;
		    var parentNode = this.element.parentNode;
		    if (parentNode) parentNode.removeChild(this.element); // In the most browsers, rules inserted using insertRule() API will be lost when style element is removed.
		    // Though IE will keep them and we need a consistent behavior.

		    if (this.sheet.options.link) {
		      this.cssRules = [];
		      this.element.textContent = '\n';
		    }
		  }
		  /**
		   * Inject CSS string into element.
		   */
		  ;

		  _proto.deploy = function deploy() {
		    var sheet = this.sheet;
		    if (!sheet) return;

		    if (sheet.options.link) {
		      this.insertRules(sheet.rules);
		      return;
		    }

		    this.element.textContent = "\n" + sheet.toString() + "\n";
		  }
		  /**
		   * Insert RuleList into an element.
		   */
		  ;

		  _proto.insertRules = function insertRules(rules, nativeParent) {
		    for (var i = 0; i < rules.index.length; i++) {
		      this.insertRule(rules.index[i], i, nativeParent);
		    }
		  }
		  /**
		   * Insert a rule into element.
		   */
		  ;

		  _proto.insertRule = function insertRule(rule, index, nativeParent) {
		    if (nativeParent === void 0) {
		      nativeParent = this.element.sheet;
		    }

		    if (rule.rules) {
		      var parent = rule;
		      var latestNativeParent = nativeParent;

		      if (rule.type === 'conditional' || rule.type === 'keyframes') {
		        var _insertionIndex = getValidRuleInsertionIndex(nativeParent, index); // We need to render the container without children first.


		        latestNativeParent = _insertRule(nativeParent, parent.toString({
		          children: false
		        }), _insertionIndex);

		        if (latestNativeParent === false) {
		          return false;
		        }

		        this.refCssRule(rule, _insertionIndex, latestNativeParent);
		      }

		      this.insertRules(parent.rules, latestNativeParent);
		      return latestNativeParent;
		    }

		    var ruleStr = rule.toString();
		    if (!ruleStr) return false;
		    var insertionIndex = getValidRuleInsertionIndex(nativeParent, index);

		    var nativeRule = _insertRule(nativeParent, ruleStr, insertionIndex);

		    if (nativeRule === false) {
		      return false;
		    }

		    this.hasInsertedRules = true;
		    this.refCssRule(rule, insertionIndex, nativeRule);
		    return nativeRule;
		  };

		  _proto.refCssRule = function refCssRule(rule, index, cssRule) {
		    rule.renderable = cssRule; // We only want to reference the top level rules, deleteRule API doesn't support removing nested rules
		    // like rules inside media queries or keyframes

		    if (rule.options.parent instanceof StyleSheet) {
		      this.cssRules.splice(index, 0, cssRule);
		    }
		  }
		  /**
		   * Delete a rule.
		   */
		  ;

		  _proto.deleteRule = function deleteRule(cssRule) {
		    var sheet = this.element.sheet;
		    var index = this.indexOf(cssRule);
		    if (index === -1) return false;
		    sheet.deleteRule(index);
		    this.cssRules.splice(index, 1);
		    return true;
		  }
		  /**
		   * Get index of a CSS Rule.
		   */
		  ;

		  _proto.indexOf = function indexOf(cssRule) {
		    return this.cssRules.indexOf(cssRule);
		  }
		  /**
		   * Generate a new CSS rule and replace the existing one.
		   */
		  ;

		  _proto.replaceRule = function replaceRule(cssRule, rule) {
		    var index = this.indexOf(cssRule);
		    if (index === -1) return false;
		    this.element.sheet.deleteRule(index);
		    this.cssRules.splice(index, 1);
		    return this.insertRule(rule, index);
		  }
		  /**
		   * Get all rules elements.
		   */
		  ;

		  _proto.getRules = function getRules() {
		    return this.element.sheet.cssRules;
		  };

		  return DomRenderer;
		}();

		var instanceCounter = 0;

		var Jss =
		/*#__PURE__*/
		function () {
		  function Jss(options) {
		    this.id = instanceCounter++;
		    this.version = "10.10.0";
		    this.plugins = new PluginsRegistry();
		    this.options = {
		      id: {
		        minify: false
		      },
		      createGenerateId: createGenerateId,
		      Renderer: isBrowser ? DomRenderer : null,
		      plugins: []
		    };
		    this.generateId = createGenerateId({
		      minify: false
		    });

		    for (var i = 0; i < plugins.length; i++) {
		      this.plugins.use(plugins[i], {
		        queue: 'internal'
		      });
		    }

		    this.setup(options);
		  }
		  /**
		   * Prepares various options, applies plugins.
		   * Should not be used twice on the same instance, because there is no plugins
		   * deduplication logic.
		   */


		  var _proto = Jss.prototype;

		  _proto.setup = function setup(options) {
		    if (options === void 0) {
		      options = {};
		    }

		    if (options.createGenerateId) {
		      this.options.createGenerateId = options.createGenerateId;
		    }

		    if (options.id) {
		      this.options.id = _extends({}, this.options.id, options.id);
		    }

		    if (options.createGenerateId || options.id) {
		      this.generateId = this.options.createGenerateId(this.options.id);
		    }

		    if (options.insertionPoint != null) this.options.insertionPoint = options.insertionPoint;

		    if ('Renderer' in options) {
		      this.options.Renderer = options.Renderer;
		    } // eslint-disable-next-line prefer-spread


		    if (options.plugins) this.use.apply(this, options.plugins);
		    return this;
		  }
		  /**
		   * Create a Style Sheet.
		   */
		  ;

		  _proto.createStyleSheet = function createStyleSheet(styles, options) {
		    if (options === void 0) {
		      options = {};
		    }

		    var _options = options,
		        index = _options.index;

		    if (typeof index !== 'number') {
		      index = sheets.index === 0 ? 0 : sheets.index + 1;
		    }

		    var sheet = new StyleSheet(styles, _extends({}, options, {
		      jss: this,
		      generateId: options.generateId || this.generateId,
		      insertionPoint: this.options.insertionPoint,
		      Renderer: this.options.Renderer,
		      index: index
		    }));
		    this.plugins.onProcessSheet(sheet);
		    return sheet;
		  }
		  /**
		   * Detach the Style Sheet and remove it from the registry.
		   */
		  ;

		  _proto.removeStyleSheet = function removeStyleSheet(sheet) {
		    sheet.detach();
		    sheets.remove(sheet);
		    return this;
		  }
		  /**
		   * Create a rule without a Style Sheet.
		   * [Deprecated] will be removed in the next major version.
		   */
		  ;

		  _proto.createRule = function createRule$1(name, style, options) {
		    if (style === void 0) {
		      style = {};
		    }

		    if (options === void 0) {
		      options = {};
		    }

		    // Enable rule without name for inline styles.
		    if (typeof name === 'object') {
		      return this.createRule(undefined, name, style);
		    }

		    var ruleOptions = _extends({}, options, {
		      name: name,
		      jss: this,
		      Renderer: this.options.Renderer
		    });

		    if (!ruleOptions.generateId) ruleOptions.generateId = this.generateId;
		    if (!ruleOptions.classes) ruleOptions.classes = {};
		    if (!ruleOptions.keyframes) ruleOptions.keyframes = {};

		    var rule = createRule(name, style, ruleOptions);

		    if (rule) this.plugins.onProcessRule(rule);
		    return rule;
		  }
		  /**
		   * Register plugin. Passed function will be invoked with a rule instance.
		   */
		  ;

		  _proto.use = function use() {
		    var _this = this;

		    for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
		      plugins[_key] = arguments[_key];
		    }

		    plugins.forEach(function (plugin) {
		      _this.plugins.use(plugin);
		    });
		    return this;
		  };

		  return Jss;
		}();

		var createJss = function createJss(options) {
		  return new Jss(options);
		};

		/**
		 * SheetsManager is like a WeakMap which is designed to count StyleSheet
		 * instances and attach/detach automatically.
		 * Used in react-jss.
		 */

		var SheetsManager =
		/*#__PURE__*/
		function () {
		  function SheetsManager() {
		    this.length = 0;
		    this.sheets = new WeakMap();
		  }

		  var _proto = SheetsManager.prototype;

		  _proto.get = function get(key) {
		    var entry = this.sheets.get(key);
		    return entry && entry.sheet;
		  };

		  _proto.add = function add(key, sheet) {
		    if (this.sheets.has(key)) return;
		    this.length++;
		    this.sheets.set(key, {
		      sheet: sheet,
		      refs: 0
		    });
		  };

		  _proto.manage = function manage(key) {
		    var entry = this.sheets.get(key);

		    if (entry) {
		      if (entry.refs === 0) {
		        entry.sheet.attach();
		      }

		      entry.refs++;
		      return entry.sheet;
		    }
		    return undefined;
		  };

		  _proto.unmanage = function unmanage(key) {
		    var entry = this.sheets.get(key);

		    if (entry) {
		      if (entry.refs > 0) {
		        entry.refs--;
		        if (entry.refs === 0) entry.sheet.detach();
		      }
		    }
		  };

		  _createClass(SheetsManager, [{
		    key: "size",
		    get: function get() {
		      return this.length;
		    }
		  }]);

		  return SheetsManager;
		}();

		/**
		* Export a constant indicating if this browser has CSSTOM support.
		* https://developers.google.com/web/updates/2018/03/cssom
		*/
		var hasCSSTOMSupport = typeof CSS === 'object' && CSS != null && 'number' in CSS;

		/**
		 * Extracts a styles object with only props that contain function values.
		 */
		function getDynamicStyles(styles) {
		  var to = null;

		  for (var key in styles) {
		    var value = styles[key];
		    var type = typeof value;

		    if (type === 'function') {
		      if (!to) to = {};
		      to[key] = value;
		    } else if (type === 'object' && value !== null && !Array.isArray(value)) {
		      var extracted = getDynamicStyles(value);

		      if (extracted) {
		        if (!to) to = {};
		        to[key] = extracted;
		      }
		    }
		  }

		  return to;
		}

		/**
		 * A better abstraction over CSS.
		 *
		 * @copyright Oleg Isonen (Slobodskoi) / Isonen 2014-present
		 * @website https://github.com/cssinjs/jss
		 * @license MIT
		 */
		var index = createJss();

		const jss_esm = /*#__PURE__*/Object.freeze({
		  __proto__: null,
		  'default': index,
		  RuleList: RuleList,
		  SheetsManager: SheetsManager,
		  SheetsRegistry: SheetsRegistry,
		  create: createJss,
		  createGenerateId: createGenerateId,
		  createRule: createRule,
		  getDynamicStyles: getDynamicStyles,
		  hasCSSTOMSupport: hasCSSTOMSupport,
		  sheets: sheets,
		  toCssValue: toCssValue
		});

		var at = '@global';
		var atPrefix = '@global ';

		var GlobalContainerRule =
		/*#__PURE__*/
		function () {
		  function GlobalContainerRule(key, styles, options) {
		    this.type = 'global';
		    this.at = at;
		    this.isProcessed = false;
		    this.key = key;
		    this.options = options;
		    this.rules = new RuleList(_extends({}, options, {
		      parent: this
		    }));

		    for (var selector in styles) {
		      this.rules.add(selector, styles[selector]);
		    }

		    this.rules.process();
		  }
		  /**
		   * Get a rule.
		   */


		  var _proto = GlobalContainerRule.prototype;

		  _proto.getRule = function getRule(name) {
		    return this.rules.get(name);
		  }
		  /**
		   * Create and register rule, run plugins.
		   */
		  ;

		  _proto.addRule = function addRule(name, style, options) {
		    var rule = this.rules.add(name, style, options);
		    if (rule) this.options.jss.plugins.onProcessRule(rule);
		    return rule;
		  }
		  /**
		   * Replace rule, run plugins.
		   */
		  ;

		  _proto.replaceRule = function replaceRule(name, style, options) {
		    var newRule = this.rules.replace(name, style, options);
		    if (newRule) this.options.jss.plugins.onProcessRule(newRule);
		    return newRule;
		  }
		  /**
		   * Get index of a rule.
		   */
		  ;

		  _proto.indexOf = function indexOf(rule) {
		    return this.rules.indexOf(rule);
		  }
		  /**
		   * Generates a CSS string.
		   */
		  ;

		  _proto.toString = function toString(options) {
		    return this.rules.toString(options);
		  };

		  return GlobalContainerRule;
		}();

		var GlobalPrefixedRule =
		/*#__PURE__*/
		function () {
		  function GlobalPrefixedRule(key, style, options) {
		    this.type = 'global';
		    this.at = at;
		    this.isProcessed = false;
		    this.key = key;
		    this.options = options;
		    var selector = key.substr(atPrefix.length);
		    this.rule = options.jss.createRule(selector, style, _extends({}, options, {
		      parent: this
		    }));
		  }

		  var _proto2 = GlobalPrefixedRule.prototype;

		  _proto2.toString = function toString(options) {
		    return this.rule ? this.rule.toString(options) : '';
		  };

		  return GlobalPrefixedRule;
		}();

		var separatorRegExp$1 = /\s*,\s*/g;

		function addScope(selector, scope) {
		  var parts = selector.split(separatorRegExp$1);
		  var scoped = '';

		  for (var i = 0; i < parts.length; i++) {
		    scoped += scope + " " + parts[i].trim();
		    if (parts[i + 1]) scoped += ', ';
		  }

		  return scoped;
		}

		function handleNestedGlobalContainerRule(rule, sheet) {
		  var options = rule.options,
		      style = rule.style;
		  var rules = style ? style[at] : null;
		  if (!rules) return;

		  for (var name in rules) {
		    sheet.addRule(name, rules[name], _extends({}, options, {
		      selector: addScope(name, rule.selector)
		    }));
		  }

		  delete style[at];
		}

		function handlePrefixedGlobalRule(rule, sheet) {
		  var options = rule.options,
		      style = rule.style;

		  for (var prop in style) {
		    if (prop[0] !== '@' || prop.substr(0, at.length) !== at) continue;
		    var selector = addScope(prop.substr(at.length), rule.selector);
		    sheet.addRule(selector, style[prop], _extends({}, options, {
		      selector: selector
		    }));
		    delete style[prop];
		  }
		}
		/**
		 * Convert nested rules to separate, remove them from original styles.
		 */


		function jssGlobal() {
		  function onCreateRule(name, styles, options) {
		    if (!name) return null;

		    if (name === at) {
		      return new GlobalContainerRule(name, styles, options);
		    }

		    if (name[0] === '@' && name.substr(0, atPrefix.length) === atPrefix) {
		      return new GlobalPrefixedRule(name, styles, options);
		    }

		    var parent = options.parent;

		    if (parent) {
		      if (parent.type === 'global' || parent.options.parent && parent.options.parent.type === 'global') {
		        options.scoped = false;
		      }
		    }

		    if (!options.selector && options.scoped === false) {
		      options.selector = name;
		    }

		    return null;
		  }

		  function onProcessRule(rule, sheet) {
		    if (rule.type !== 'style' || !sheet) return;
		    handleNestedGlobalContainerRule(rule, sheet);
		    handlePrefixedGlobalRule(rule, sheet);
		  }

		  return {
		    onCreateRule: onCreateRule,
		    onProcessRule: onProcessRule
		  };
		}

		var separatorRegExp = /\s*,\s*/g;
		var parentRegExp = /&/g;
		var refRegExp = /\$([\w-]+)/g;
		/**
		 * Convert nested rules to separate, remove them from original styles.
		 */

		function jssNested() {
		  // Get a function to be used for $ref replacement.
		  function getReplaceRef(container, sheet) {
		    return function (match, key) {
		      var rule = container.getRule(key) || sheet && sheet.getRule(key);

		      if (rule) {
		        return rule.selector;
		      }
		      return key;
		    };
		  }

		  function replaceParentRefs(nestedProp, parentProp) {
		    var parentSelectors = parentProp.split(separatorRegExp);
		    var nestedSelectors = nestedProp.split(separatorRegExp);
		    var result = '';

		    for (var i = 0; i < parentSelectors.length; i++) {
		      var parent = parentSelectors[i];

		      for (var j = 0; j < nestedSelectors.length; j++) {
		        var nested = nestedSelectors[j];
		        if (result) result += ', '; // Replace all & by the parent or prefix & with the parent.

		        result += nested.indexOf('&') !== -1 ? nested.replace(parentRegExp, parent) : parent + " " + nested;
		      }
		    }

		    return result;
		  }

		  function getOptions(rule, container, prevOptions) {
		    // Options has been already created, now we only increase index.
		    if (prevOptions) return _extends({}, prevOptions, {
		      index: prevOptions.index + 1
		    });
		    var nestingLevel = rule.options.nestingLevel;
		    nestingLevel = nestingLevel === undefined ? 1 : nestingLevel + 1;

		    var options = _extends({}, rule.options, {
		      nestingLevel: nestingLevel,
		      index: container.indexOf(rule) + 1 // We don't need the parent name to be set options for chlid.

		    });

		    delete options.name;
		    return options;
		  }

		  function onProcessStyle(style, rule, sheet) {
		    if (rule.type !== 'style') return style;
		    var styleRule = rule;
		    var container = styleRule.options.parent;
		    var options;
		    var replaceRef;

		    for (var prop in style) {
		      var isNested = prop.indexOf('&') !== -1;
		      var isNestedConditional = prop[0] === '@';
		      if (!isNested && !isNestedConditional) continue;
		      options = getOptions(styleRule, container, options);

		      if (isNested) {
		        var selector = replaceParentRefs(prop, styleRule.selector); // Lazily create the ref replacer function just once for
		        // all nested rules within the sheet.

		        if (!replaceRef) replaceRef = getReplaceRef(container, sheet); // Replace all $refs.

		        selector = selector.replace(refRegExp, replaceRef);
		        var name = styleRule.key + "-" + prop;

		        if ('replaceRule' in container) {
		          // for backward compatibility
		          container.replaceRule(name, style[prop], _extends({}, options, {
		            selector: selector
		          }));
		        } else {
		          container.addRule(name, style[prop], _extends({}, options, {
		            selector: selector
		          }));
		        }
		      } else if (isNestedConditional) {
		        // Place conditional right after the parent rule to ensure right ordering.
		        container.addRule(prop, {}, options).addRule(styleRule.key, style[prop], {
		          selector: styleRule.selector
		        });
		      }

		      delete style[prop];
		    }

		    return style;
		  }

		  return {
		    onProcessStyle: onProcessStyle
		  };
		}

		/* eslint-disable no-var, prefer-template */
		var uppercasePattern = /[A-Z]/g;
		var msPattern = /^ms-/;
		var cache = {};

		function toHyphenLower(match) {
		  return '-' + match.toLowerCase()
		}

		function hyphenateStyleName(name) {
		  if (cache.hasOwnProperty(name)) {
		    return cache[name]
		  }

		  var hName = name.replace(uppercasePattern, toHyphenLower);
		  return (cache[name] = msPattern.test(hName) ? '-' + hName : hName)
		}

		/**
		 * Convert camel cased property names to dash separated.
		 */

		function convertCase(style) {
		  var converted = {};

		  for (var prop in style) {
		    var key = prop.indexOf('--') === 0 ? prop : hyphenateStyleName(prop);
		    converted[key] = style[prop];
		  }

		  if (style.fallbacks) {
		    if (Array.isArray(style.fallbacks)) converted.fallbacks = style.fallbacks.map(convertCase);else converted.fallbacks = convertCase(style.fallbacks);
		  }

		  return converted;
		}
		/**
		 * Allow camel cased property names by converting them back to dasherized.
		 */


		function camelCase() {
		  function onProcessStyle(style) {
		    if (Array.isArray(style)) {
		      // Handle rules like @font-face, which can have multiple styles in an array
		      for (var index = 0; index < style.length; index++) {
		        style[index] = convertCase(style[index]);
		      }

		      return style;
		    }

		    return convertCase(style);
		  }

		  function onChangeValue(value, prop, rule) {
		    if (prop.indexOf('--') === 0) {
		      return value;
		    }

		    var hyphenatedProp = hyphenateStyleName(prop); // There was no camel case in place

		    if (prop === hyphenatedProp) return value;
		    rule.prop(hyphenatedProp, value); // Core will ignore that property value we set the proper one above.

		    return null;
		  }

		  return {
		    onProcessStyle: onProcessStyle,
		    onChangeValue: onChangeValue
		  };
		}

		function createCommonjsModule(fn, basedir, module) {
			return module = {
				path: basedir,
				exports: {},
				require: function (path, base) {
					return commonjsRequire();
				}
			}, fn(module, module.exports), module.exports;
		}

		function getAugmentedNamespace(n) {
			if (n.__esModule) return n;
			var a = Object.defineProperty({}, '__esModule', {value: true});
			Object.keys(n).forEach(function (k) {
				var d = Object.getOwnPropertyDescriptor(n, k);
				Object.defineProperty(a, k, d.get ? d : {
					enumerable: true,
					get: function () {
						return n[k];
					}
				});
			});
			return a;
		}

		function commonjsRequire () {
			throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
		}

		var _tslib = createCommonjsModule(function (module, exports) {

		Object.defineProperty(exports, '__esModule', { value: true });

		/*! *****************************************************************************
		Copyright (c) Microsoft Corporation.

		Permission to use, copy, modify, and/or distribute this software for any
		purpose with or without fee is hereby granted.

		THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
		REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
		AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
		INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
		LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
		OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
		PERFORMANCE OF THIS SOFTWARE.
		***************************************************************************** */

		exports.__assign = function () {
			exports.__assign =
				Object.assign ||
				function __assign(t) {
					for (var s, i = 1, n = arguments.length; i < n; i++) {
						s = arguments[i];
						for (var p in s)
							if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
					}
					return t;
				};
			return exports.__assign.apply(this, arguments);
		};
		});

		/**
		 * The custom `sort` method for
		 * for the [`css-mqpacker`](https://www.npmjs.com/package/css-mqpacker) or
		 * [`pleeease`](https://www.npmjs.com/package/pleeease) which using `css-mqpacker`
		 * or, perhaps, something else ))
		 *
		 * @module sort-css-media-queries
		 * @author Oleg Dutchenko <dutchenko.o.wezom@gmail.com>
		 * @version 1.5.0
		 */

		// ----------------------------------------
		// Private
		// ----------------------------------------

		const minMaxWidth = /(!?\(\s*min(-device-)?-width)(.|\n)+\(\s*max(-device)?-width/i;
		const minWidth = /\(\s*min(-device)?-width/i;
		const maxMinWidth = /(!?\(\s*max(-device)?-width)(.|\n)+\(\s*min(-device)?-width/i;
		const maxWidth = /\(\s*max(-device)?-width/i;

		const isMinWidth = _testQuery(minMaxWidth, maxMinWidth, minWidth);
		const isMaxWidth = _testQuery(maxMinWidth, minMaxWidth, maxWidth);

		const minMaxHeight = /(!?\(\s*min(-device)?-height)(.|\n)+\(\s*max(-device)?-height/i;
		const minHeight = /\(\s*min(-device)?-height/i;
		const maxMinHeight = /(!?\(\s*max(-device)?-height)(.|\n)+\(\s*min(-device)?-height/i;
		const maxHeight = /\(\s*max(-device)?-height/i;

		const isMinHeight = _testQuery(minMaxHeight, maxMinHeight, minHeight);
		const isMaxHeight = _testQuery(maxMinHeight, minMaxHeight, maxHeight);

		const isPrint = /print/i;
		const isPrintOnly = /^print$/i;

		const maxValue = Number.MAX_VALUE;

		/**
		 * Obtain the length of the media request in pixels.
		 * Copy from original source `function inspectLength (length)`
		 * {@link https://github.com/hail2u/node-css-mqpacker/blob/master/index.js#L58}
		 * @private
		 * @param {string} length
		 * @return {number}
		 */
		function _getQueryLength (length) {
		  length = /(-?\d*\.?\d+)(ch|em|ex|px|rem)/.exec(length);

		  if (length === null) {
		    return maxValue
		  }

		  let number = length[1];
		  const unit = length[2];

		  switch (unit) {
		    case 'ch':
		      number = parseFloat(number) * 8.8984375;
		      break

		    case 'em':
		    case 'rem':
		      number = parseFloat(number) * 16;
		      break

		    case 'ex':
		      number = parseFloat(number) * 8.296875;
		      break

		    case 'px':
		      number = parseFloat(number);
		      break
		  }

		  return +number
		}

		/**
		 * Wrapper for creating test functions
		 * @private
		 * @param {RegExp} doubleTestTrue
		 * @param {RegExp} doubleTestFalse
		 * @param {RegExp} singleTest
		 * @return {Function}
		 */
		function _testQuery (doubleTestTrue, doubleTestFalse, singleTest) {
		  /**
		   * @param {string} query
		   * @return {boolean}
		   */
		  return function (query) {
		    if (doubleTestTrue.test(query)) {
		      return true
		    } else if (doubleTestFalse.test(query)) {
		      return false
		    }
		    return singleTest.test(query)
		  }
		}

		/**
		 * @private
		 * @param {string} a
		 * @param {string} b
		 * @return {number|null}
		 */
		function _testIsPrint (a, b) {
		  const isPrintA = isPrint.test(a);
		  const isPrintOnlyA = isPrintOnly.test(a);

		  const isPrintB = isPrint.test(b);
		  const isPrintOnlyB = isPrintOnly.test(b);

		  if (isPrintA && isPrintB) {
		    if (!isPrintOnlyA && isPrintOnlyB) {
		      return 1
		    }
		    if (isPrintOnlyA && !isPrintOnlyB) {
		      return -1
		    }
		    return a.localeCompare(b)
		  }
		  if (isPrintA) {
		    return 1
		  }
		  if (isPrintB) {
		    return -1
		  }

		  return null
		}

		// ----------------------------------------
		// Public
		// ----------------------------------------

		/**
		 * Sorting an array with media queries
		 * according to the mobile-first methodology.
		 * @param {string} a
		 * @param {string} b
		 * @return {number} 1 / 0 / -1
		 */
		function sortCSSmq (a, b) {
		  const testIsPrint = _testIsPrint(a, b);
		  if (testIsPrint !== null) {
		    return testIsPrint
		  }

		  const minA = isMinWidth(a) || isMinHeight(a);
		  const maxA = isMaxWidth(a) || isMaxHeight(a);

		  const minB = isMinWidth(b) || isMinHeight(b);
		  const maxB = isMaxWidth(b) || isMaxHeight(b);

		  if (minA && maxB) {
		    return -1
		  }
		  if (maxA && minB) {
		    return 1
		  }

		  let lengthA = _getQueryLength(a);
		  let lengthB = _getQueryLength(b);

		  if (lengthA === maxValue && lengthB === maxValue) {
		    return a.localeCompare(b)
		  } else if (lengthA === maxValue) {
		    return 1
		  } else if (lengthB === maxValue) {
		    return -1
		  }

		  if (lengthA > lengthB) {
		    if (maxA) {
		      return -1
		    }
		    return 1
		  }

		  if (lengthA < lengthB) {
		    if (maxA) {
		      return 1
		    }
		    return -1
		  }

		  return a.localeCompare(b)
		}

		/**
		 * Sorting an array with media queries
		 * according to the desktop-first methodology.
		 * @param {string} a
		 * @param {string} b
		 * @return {number} 1 / 0 / -1
		 */
		sortCSSmq.desktopFirst = function (a, b) {
		  const testIsPrint = _testIsPrint(a, b);
		  if (testIsPrint !== null) {
		    return testIsPrint
		  }

		  const minA = isMinWidth(a) || isMinHeight(a);
		  const maxA = isMaxWidth(a) || isMaxHeight(a);

		  const minB = isMinWidth(b) || isMinHeight(b);
		  const maxB = isMaxWidth(b) || isMaxHeight(b);

		  if (minA && maxB) {
		    return 1
		  }
		  if (maxA && minB) {
		    return -1
		  }

		  const lengthA = _getQueryLength(a);
		  const lengthB = _getQueryLength(b);

		  if (lengthA === maxValue && lengthB === maxValue) {
		    return a.localeCompare(b)
		  } else if (lengthA === maxValue) {
		    return 1
		  } else if (lengthB === maxValue) {
		    return -1
		  }

		  if (lengthA > lengthB) {
		    if (maxA) {
		      return -1
		    }
		    return 1
		  }

		  if (lengthA < lengthB) {
		    if (maxA) {
		      return 1
		    }
		    return -1
		  }

		  return -(a.localeCompare(b))
		};

		// ----------------------------------------
		// Exports
		// ----------------------------------------

		var sortCssMediaQueries = sortCSSmq;

		const jss$1 = /*@__PURE__*/getAugmentedNamespace(jss_esm);

		function _interopDefaultLegacy$1(e) {
			return e && typeof e === 'object' && 'default' in e ? e : { default: e };
		}

		var sortCSSmq__default = /*#__PURE__*/ _interopDefaultLegacy$1(sortCssMediaQueries);

		function isPlainObject(sample) {
			return (
				sample !== null && typeof sample === 'object' && Array.isArray(sample) === false
			);
		}
		var UN_QUERIED = '__UN_QUERIED';
		function recursiveInnerAndGetQueries(pluginOptions, rules) {
			var queries = {
				groups: {},
				groupsSortNames: []
			};
			for (var index = 0; index < rules.length; index++) {
				var rule = rules[index];
				var query =
					rule.type === 'conditional' && typeof rule.query === 'string'
						? rule.query
						: UN_QUERIED;
				if (!queries.groups.hasOwnProperty(query)) {
					queries.groupsSortNames.push(query);
					queries.groups[query] = [];
				}
				queries.groups[query].push(index);
				// eslint-disable-next-line @typescript-eslint/no-use-before-define
				recursive(pluginOptions, rule);
			}
			queries.groupsSortNames.sort(function (a, b) {
				var aWeight = a === UN_QUERIED ? 0 : a.length;
				var bWeight = b === UN_QUERIED ? 0 : b.length;
				if (aWeight > 0 && bWeight > 0) {
					if (pluginOptions.desktopFirst) {
						return sortCSSmq__default['default'].desktopFirst(a, b);
					} else {
						return sortCSSmq__default['default'](a, b);
					}
				} else {
					return aWeight - bWeight;
				}
			});
			return queries;
		}
		function recursive(pluginOptions, data) {
			if (isPlainObject(data) && data.rules instanceof jss$1.RuleList) {
				data.rules.toString = function (options) {
					if (options === void 0) {
						options = {};
					}
					var str = '';
					var sheet = this.options.sheet;
					var link = sheet ? sheet.options.link : false;
					var _a = recursiveInnerAndGetQueries(pluginOptions, this.index),
						groups = _a.groups,
						groupsSortNames = _a.groupsSortNames;
					for (var i = 0; i < groupsSortNames.length; i++) {
						var groupName = groupsSortNames[i];
						var group = groups[groupsSortNames[i]];
						if (groupName !== UN_QUERIED && pluginOptions.combineMediaQueries) {
							str += '\n' + groupName + ' {';
							for (var i_1 = 0; i_1 < group.length; i_1++) {
								var rule = this.index[group[i_1]];
								var css = rule.rules.toString(
									_tslib.__assign(_tslib.__assign({}, options), {
										indent: (options.indent || 0) + 1
									})
								);
								if (!css && !link) continue;
								if (str) str += '\n';
								str += css;
							}
							str += '\n}\n';
						} else {
							for (var i_2 = 0; i_2 < group.length; i_2++) {
								var rule = this.index[group[i_2]];
								var css = rule.toString(options);
								if (!css && !link) continue;
								if (str) str += '\n';
								str += css;
							}
						}
					}
					return str;
				};
			}
		}
		function jssCombineAndSortMQ(options) {
			if (options === void 0) {
				options = {};
			}
			return {
				onProcessSheet: function (sheet) {
					recursive(options, sheet);
				}
			};
		}

		var dist = jssCombineAndSortMQ;

		const paramCaseToCamelCase = (str) => {
		  return str.replace(/-(\w)/g, (_, group) => group.toUpperCase());
		};

		// NOTE: these utils are in the same file on purpose
		// to force them being bundled into our core chunk
		const getTagName = (el) => el.tagName.toLowerCase();
		const getTagNameWithoutPrefix = (host) => {
		  const tagName = getTagName(host);
		  const [, tagNameWithoutPrefix = ''] = /^(?:[a-z-]+-)?(p-[a-z-]+)$/.exec(tagName) || [];
		  return (tagNameWithoutPrefix || tagName); // return tagName as fallback for default tags
		};
		const tagNamesWithoutTextAndHeadline = TAG_NAMES.filter((item) => item !== 'p-text' && item !== 'p-heading' && item !== 'p-headline' && item !== 'p-display');
		const PREFIXED_TAG_NAMES_CACHE = new Map();
		const getPrefixedTagNames = (host) => {
		  const [, prefix = ''] = /^([a-z-]+)-p-[a-z-]+$/.exec(getTagName(host)) || [];
		  if (!PREFIXED_TAG_NAMES_CACHE.has(prefix)) {
		    const tagNames = tagNamesWithoutTextAndHeadline.reduce(prefix
		      ? (result, tag) => ({
		        ...result,
		        [paramCaseToCamelCase(tag)]: `${prefix}-${tag}`,
		      })
		      : (result, tag) => ({
		        ...result,
		        [paramCaseToCamelCase(tag)]: tag,
		      }), {});
		    PREFIXED_TAG_NAMES_CACHE.set(prefix, tagNames);
		  }
		  return PREFIXED_TAG_NAMES_CACHE.get(prefix);
		};

		const prefix = `[Porsche Design System v${"3.7.0-rc.2"}]` // this part isn't covered by unit tests
		  ;
		const consoleWarn = (...messages) => {
		  console.warn(prefix, ...messages); // eslint-disable-line no-console
		};
		const consoleError = (...messages) => {
		  console.error(prefix, ...messages); // eslint-disable-line no-console
		};
		const throwException = (message) => {
		  throw new Error(`${prefix} ${message}`); // eslint-disable-line fp/no-throw
		};

		function getHTMLElement(element, selector) {
		  return element?.querySelector(selector);
		}

		function getShadowRootHTMLElement(element, selector) {
		  return getHTMLElement(element.shadowRoot, selector);
		}

		const removeAttribute = (el, attributeName) => {
		  el.removeAttribute(attributeName);
		};

		const setAttribute = (el, attributeName, attributeValue = '') => {
		  el.setAttribute(attributeName, attributeValue);
		};

		const parseJSONAttribute = (attribute) => {
		  return typeof attribute === 'string'
		    ? // input is potentially JSON parsable string, e.g. "{ aria-label: 'Some label' }"
		      JSON.parse(attribute
		        .replace(/'/g, '"') // convert single quotes to double quotes
		        .replace(/[\s"]?([\w-]+)[\s"]?:/g, '"$1":') // wrap keys in double quotes
		      )
		    : // input is object, e.g. { aria-label: 'Some label' }
		      attribute;
		};

		const hasWindow = typeof window !== 'undefined';

		const setAriaAttributes = (el, opts) => {
		  const { label, message, state } = opts;
		  if (label) {
		    setAttribute(el, 'aria-label', `${label}${message ? `. ${message}` : ''}`);
		  }
		  if (state === 'error') {
		    setAttribute(el, 'aria-invalid', 'true');
		  }
		  else {
		    removeAttribute(el, 'aria-invalid');
		  }
		};
		const parseAndGetAriaAttributes = (rawAttributes) => {
		  if (rawAttributes) {
		    const attributes = parseJSONAttribute(rawAttributes);
		    const attributeKeys = Object.keys(attributes);
		    // convert booleans to strings so that values are properly set and not just result in attributes without a value when true in jsx
		    for (const key of attributeKeys) {
		      if (typeof attributes[key] === 'boolean') {
		        attributes[key] = `${attributes[key]}`;
		      }
		    }
		    return attributes;
		  }
		};
		const isHighContrastMode = hasWindow && window.matchMedia && matchMedia('(forced-colors: active)').matches;

		const attributeMutationMap = new Map();
		const attributeObserver = hasWindow &&
		  new MutationObserver((mutations) => {
		    mutations
		      // reduce array to only entries that have really a changed value
		      .filter((mutation) => mutation.oldValue !== mutation.target.getAttribute(mutation.attributeName))
		      // remove duplicates so we execute callback only once per node
		      .filter((mutation, idx, arr) => arr.findIndex((m) => m.target === mutation.target) === idx)
		      .forEach((mutation) => attributeMutationMap.get(mutation.target)?.());
		  });
		const observeAttributes = (node, attributes, callback) => {
		  // node might not be defined in connectedCallback
		  if (node) {
		    attributeMutationMap.set(node, callback);
		    attributeObserver.observe(node, { attributeFilter: attributes, attributeOldValue: true });
		  }
		};
		const unobserveAttributes = (node) => {
		  attributeMutationMap.delete(node);
		};

		const parseJSON = (prop) => {
		  if (typeof prop === 'string') {
		    try {
		      // prop is potentially JSON parsable string, e.g. "{ base: 'block', l: 'inline' }" or "true" or "false"
		      return JSON.parse(prop
		        .replace(/'/g, '"') // convert single quotes to double quotes
		        .replace(/[\s"]?([a-z]+)[\s"]?:([^//])/g, '"$1":$2') // wrap keys in double quotes if they don't have them but ignore potential urls
		      );
		    }
		    catch {
		      // prop is string, e.g. "block" or "inline"
		      return prop;
		    }
		  }
		  else {
		    // prop is object, e.g. { base: 'block', l: 'inline' } or number, e.g. 123 or boolean, e.g. true
		    return prop;
		  }
		};

		const borderWidthBase = '2px';

		const themeLightStateFocus = '#1A44EA';

		const backdropFilter = 'blur(32px)';
		const frostedGlassStyle = {
		    WebkitBackdropFilter: backdropFilter,
		    backdropFilter,
		};

		const breakpointBase = 0;

		const breakpointXS = 480;

		const breakpointS = 760;

		const breakpointM = 1000;

		const breakpointL = 1300;

		const breakpointXL = 1760;

		const breakpointXXL = 1920;

		const breakpoint = {
		    base: breakpointBase,
		    xs: breakpointXS,
		    s: breakpointS,
		    m: breakpointM,
		    l: breakpointL,
		    xl: breakpointXL,
		    xxl: breakpointXXL,
		};

		function getMediaQueryMin(min) {
		    return `@media(min-width:${breakpoint[min]}px)`;
		}

		const breakpoints = ['base', 'xs', 's', 'm', 'l', 'xl', 'xxl'];

		const themeDarkBackgroundShading = 'rgba(1, 2, 5, 0.67)';

		const mediaQueries = Object.values(breakpoint).map((v) => `(min-width:${v}px)`);
		let mediaQueryLists = hasWindow && window.matchMedia ? mediaQueries.map(window.matchMedia) : [];
		const breakpointChangeCallbackMap = new Map();
		const observeBreakpointChange = (node, callback) => {
		  // node might not be defined in connectedCallback
		  if (node) {
		    if (breakpointChangeCallbackMap.size === 0) {
		      mediaQueryLists.forEach((mediaQueryList) => {
		        // matchmedia-polyfill only implements addListener in jsdom-polyfill
		        mediaQueryList.addEventListener?.('change', handleBreakpointChange);
		      });
		    }
		    breakpointChangeCallbackMap.set(node, callback);
		  }
		};
		const unobserveBreakpointChange = (node) => {
		  breakpointChangeCallbackMap.delete(node);
		  if (breakpointChangeCallbackMap.size === 0) {
		    mediaQueryLists.forEach((mediaQueryList) => {
		      // matchmedia-polyfill only implements removeListener in jsdom-polyfill
		      mediaQueryList.removeEventListener?.('change', handleBreakpointChange);
		    });
		  }
		};
		const handleBreakpointChange = () => {
		  breakpointChangeCallbackMap.forEach((breakpointChangeCallback) => {
		    breakpointChangeCallback();
		  });
		};

		const flippedBreakpoint = Object.entries(breakpoint).reduce((result, [key, val]) => ({ ...result, [`${val}px`]: key }), {});
		const getCurrentBreakpointKey = () => {
		  const lastMatchingMediaQuery = mediaQueryLists
		    .filter((item) => item.matches)
		    .map((item) => item.media)
		    .pop();
		  return flippedBreakpoint[/\d+px/.exec(lastMatchingMediaQuery)[0]];
		};
		const getCurrentMatchingBreakpointValue = (data) => {
		  if (typeof data === 'object') {
		    const currentBreakpoint = getCurrentBreakpointKey();
		    const result = data[currentBreakpoint];
		    if (result) {
		      return result;
		    }
		    else {
		      const valuesArray = breakpoints.map((bp) => data[bp]);
		      // fill gaps with value from preceding breakpoint
		      valuesArray.forEach((val, i, arr) => {
		        if (val === undefined) {
		          arr[i] = arr[i - 1];
		        }
		      });
		      return valuesArray[breakpoints.indexOf(currentBreakpoint)];
		    }
		  }
		  else {
		    return data;
		  }
		};

		/**
		 * Map of observed nodes and their corresponding callback functions.
		 */
		const observedNodesMap = new Map();
		/**
		 * Mutation observer for observing changes in the children of observed nodes.
		 */
		const childrenObserver = hasWindow &&
		  new MutationObserver((mutations) => {
		    // there may be race conditions in jsdom-polyfill tests  where the map is already empty when a mutation happens
		    if (observedNodesMap.size) {
		      const observedNodes = Array.from(observedNodesMap.keys());
		      mutations
		        // remove duplicates so we execute callback only once per node
		        .filter((mutation, idx, arr) => arr.findIndex((m) => m.target === mutation.target) === idx)
		        // find all observing parent nodes of mutated node and invoke their callbacks
		        .forEach((mutation) => {
		        observedNodes
		          .filter((node) => node.contains(mutation.target))
		          .forEach((node) => observedNodesMap.get(node)?.());
		      });
		    }
		  });
		/**
		 * Observes the children of a given node and invokes a callback when changes occur.
		 * @template T - The type of the node.
		 * @template K - The type of the node's attributes.
		 * @param {T} node - The node to observe.
		 * @param {() => void} callback - The callback function to invoke when changes occur.
		 * @param {(Lowercase<K extends string ? K : string> | keyof AriaAttributes)[]} [attributes] - Optional attribute names to be monitored.
		 * @returns {void}
		 */
		const observeChildren = (node, callback, attributes) => {
		  // node might not be defined in connectedCallback
		  if (node) {
		    observedNodesMap.set(node, callback);
		    childrenObserver.observe(node, {
		      childList: true,
		      subtree: true,
		      characterData: true,
		      attributeFilter: attributes,
		    });
		  }
		};
		/**
		 * Stops observing the children of a given node.
		 * @template T - The type of the node.
		 * @param {T} node - The node to unobserve.
		 * @returns {void}
		 */
		const unobserveChildren = (node) => {
		  observedNodesMap.delete(node);
		};

		/* eslint-disable no-undefined,no-param-reassign,no-shadow */

		/**
		 * Throttle execution of a function. Especially useful for rate limiting
		 * execution of handlers on events like resize and scroll.
		 *
		 * @param {number} delay -                  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher)
		 *                                            are most useful.
		 * @param {Function} callback -               A function to be executed after delay milliseconds. The `this` context and all arguments are passed through,
		 *                                            as-is, to `callback` when the throttled-function is executed.
		 * @param {object} [options] -              An object to configure options.
		 * @param {boolean} [options.noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds
		 *                                            while the throttled-function is being called. If noTrailing is false or unspecified, callback will be executed
		 *                                            one final time after the last throttled-function call. (After the throttled-function has not been called for
		 *                                            `delay` milliseconds, the internal counter is reset).
		 * @param {boolean} [options.noLeading] -   Optional, defaults to false. If noLeading is false, the first throttled-function call will execute callback
		 *                                            immediately. If noLeading is true, the first the callback execution will be skipped. It should be noted that
		 *                                            callback will never executed if both noLeading = true and noTrailing = true.
		 * @param {boolean} [options.debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is
		 *                                            false (at end), schedule `callback` to execute after `delay` ms.
		 *
		 * @returns {Function} A new, throttled, function.
		 */
		function throttle (delay, callback, options) {
		  var _ref = options || {},
		      _ref$noTrailing = _ref.noTrailing,
		      noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing,
		      _ref$noLeading = _ref.noLeading,
		      noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading,
		      _ref$debounceMode = _ref.debounceMode,
		      debounceMode = _ref$debounceMode === void 0 ? undefined : _ref$debounceMode;
		  /*
		   * After wrapper has stopped being called, this timeout ensures that
		   * `callback` is executed at the proper times in `throttle` and `end`
		   * debounce modes.
		   */


		  var timeoutID;
		  var cancelled = false; // Keep track of the last time `callback` was executed.

		  var lastExec = 0; // Function to clear existing timeout

		  function clearExistingTimeout() {
		    if (timeoutID) {
		      clearTimeout(timeoutID);
		    }
		  } // Function to cancel next exec


		  function cancel(options) {
		    var _ref2 = options || {},
		        _ref2$upcomingOnly = _ref2.upcomingOnly,
		        upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;

		    clearExistingTimeout();
		    cancelled = !upcomingOnly;
		  }
		  /*
		   * The `wrapper` function encapsulates all of the throttling / debouncing
		   * functionality and when executed will limit the rate at which `callback`
		   * is executed.
		   */


		  function wrapper() {
		    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
		      arguments_[_key] = arguments[_key];
		    }

		    var self = this;
		    var elapsed = Date.now() - lastExec;

		    if (cancelled) {
		      return;
		    } // Execute `callback` and update the `lastExec` timestamp.


		    function exec() {
		      lastExec = Date.now();
		      callback.apply(self, arguments_);
		    }
		    /*
		     * If `debounceMode` is true (at begin) this is used to clear the flag
		     * to allow future `callback` executions.
		     */


		    function clear() {
		      timeoutID = undefined;
		    }

		    if (!noLeading && debounceMode && !timeoutID) {
		      /*
		       * Since `wrapper` is being called for the first time and
		       * `debounceMode` is true (at begin), execute `callback`
		       * and noLeading != true.
		       */
		      exec();
		    }

		    clearExistingTimeout();

		    if (debounceMode === undefined && elapsed > delay) {
		      if (noLeading) {
		        /*
		         * In throttle mode with noLeading, if `delay` time has
		         * been exceeded, update `lastExec` and schedule `callback`
		         * to execute after `delay` ms.
		         */
		        lastExec = Date.now();

		        if (!noTrailing) {
		          timeoutID = setTimeout(debounceMode ? clear : exec, delay);
		        }
		      } else {
		        /*
		         * In throttle mode without noLeading, if `delay` time has been exceeded, execute
		         * `callback`.
		         */
		        exec();
		      }
		    } else if (noTrailing !== true) {
		      /*
		       * In trailing throttle mode, since `delay` time has not been
		       * exceeded, schedule `callback` to execute `delay` ms after most
		       * recent execution.
		       *
		       * If `debounceMode` is true (at begin), schedule `clear` to execute
		       * after `delay` ms.
		       *
		       * If `debounceMode` is false (at end), schedule `callback` to
		       * execute after `delay` ms.
		       */
		      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
		    }
		  }

		  wrapper.cancel = cancel; // Return the wrapper function.

		  return wrapper;
		}

		/* eslint-disable no-undefined */
		/**
		 * Debounce execution of a function. Debouncing, unlike throttling,
		 * guarantees that a function is only executed a single time, either at the
		 * very beginning of a series of calls, or at the very end.
		 *
		 * @param {number} delay -               A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
		 * @param {Function} callback -          A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
		 *                                        to `callback` when the debounced-function is executed.
		 * @param {object} [options] -           An object to configure options.
		 * @param {boolean} [options.atBegin] -  Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds
		 *                                        after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.
		 *                                        (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).
		 *
		 * @returns {Function} A new, debounced function.
		 */

		function debounce (delay, callback, options) {
		  var _ref = options || {},
		      _ref$atBegin = _ref.atBegin,
		      atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;

		  return throttle(delay, callback, {
		    debounceMode: atBegin !== false
		  });
		}

		const hasCounter = (el) => el.maxLength >= 0;
		const setCounterInnerHtml = (el, counterElement) => {
		  counterElement.innerText = `${el.value.length}/${el.maxLength}`;
		};
		const setAriaElementInnerHtml = debounce(800, (el, ariaElement) => {
		  ariaElement.innerText = `You have ${el.maxLength - el.value.length} out of ${el.maxLength} characters left`;
		});
		const addInputEventListenerForCounter = (input, characterCountElement, counterElement, inputChangeCallback) => {
		  if (counterElement) {
		    setCounterInnerHtml(input, counterElement); // initial value
		  }
		  setAriaElementInnerHtml(input, characterCountElement); // initial value
		  input.addEventListener('input', (e) => {
		    if (counterElement) {
		      setCounterInnerHtml(e.target, counterElement);
		    }
		    setAriaElementInnerHtml(e.target, characterCountElement);
		    if (inputChangeCallback) {
		      inputChangeCallback();
		    }
		  });
		};

		const hasPropValueChanged = (newVal, oldVal) => {
		  if (typeof newVal !== 'object' || typeof oldVal !== 'object') {
		    // primitive types
		    return newVal !== oldVal;
		  }
		  else if (Array.isArray(newVal) && Array.isArray(oldVal)) {
		    // type array
		    return !(newVal.length === oldVal.length && newVal.every((val, i) => val === oldVal[i]));
		  }
		  else {
		    // type object
		    // currently this does not take care of nested objects
		    return !(Object.keys(newVal).length === Object.keys(oldVal).length &&
		      Object.entries(newVal).every(([key1, val1]) => val1 === oldVal[key1]));
		  }
		};

		/* Auto Generated Start */
		const themeLight = {
		  primaryColor: '#010205',
		  primaryColorDarken: '#000000',
		  backgroundColor: '#FFF',
		  backgroundColorDarken: '#E0E0E0',
		  backgroundColorLighten: '#FFFFFF',
		  backgroundSurfaceColor: '#EEEFF2',
		  backgroundSurfaceColorDarken: '#CBCED7',
		  backgroundSurfaceColorLighten: '#FFFFFF',
		  contrastLowColor: '#D8D8DB',
		  contrastMediumColor: '#6B6D70',
		  contrastHighColor: '#535457',
		  contrastHighColorDarken: '#353638',
		  contrastHighColorLighten: '#717276',
		  hoverColor: 'rgba(148, 149, 152, .18)',
		  hoverColorDarken: '#75767A',
		  activeColor: 'rgba(148, 149, 152, 0.20)',
		  focusColor: '#1A44EA',
		  disabledColor: '#949598',
		  errorColor: '#CC1922',
		  errorColorDarken: '#951219',
		  errorSoftColor: '#FFE2E4',
		  errorSoftColorDarken: '#F4CED1',
		  errorSoftColorLighten: '#FFFFFF',
		  successColor: '#197E10',
		  successColorDarken: '#0E4809',
		  successSoftColor: '#E4FFEC',
		  successSoftColorDarken: '#D0F4DB',
		  successSoftColorLighten: '#FFFFFF',
		  warningColor: '#F3BE00',
		  warningSoftColor: '#FFF4D2',
		  warningSoftColorDarken: '#F1E5C1',
		  warningSoftColorLighten: '#FCFAF3',
		  infoColor: '#2762EC',
		  infoSoftColor: '#D3E1FF',
		  infoSoftColorDarken: '#C2D1F1',
		  infoSoftColorLighten: '#F4F7FD'
		};
		const themeDark = {
		  primaryColor: '#FBFCFF',
		  primaryColorDarken: '#BECEFF',
		  backgroundColor: '#0E0E12',
		  backgroundColorDarken: '#000000',
		  backgroundColorLighten: '#292934',
		  backgroundSurfaceColor: '#212225',
		  backgroundSurfaceColorDarken: '#040405',
		  backgroundSurfaceColorLighten: '#3E4045',
		  contrastLowColor: '#404044',
		  contrastMediumColor: '#88898C',
		  contrastHighColor: '#AFB0B3',
		  contrastHighColorDarken: '#909195',
		  contrastHighColorLighten: '#CECFD1',
		  hoverColor: 'rgba(148, 149, 152, .18)',
		  hoverColorDarken: '#75767A',
		  activeColor: 'rgba(126, 127, 130, 0.20)',
		  focusColor: '#1A44EA',
		  disabledColor: '#7E7F82',
		  errorColor: '#FC4040',
		  errorColorDarken: '#FB0404',
		  errorSoftColor: '#3A0F0F',
		  errorSoftColorDarken: '#1A1111',
		  errorSoftColorLighten: '#3F2828',
		  successColor: '#09D087',
		  successColorDarken: '#069561',
		  successSoftColor: '#003320',
		  successSoftColorDarken: '#04110C',
		  successSoftColorLighten: '#0F432F',
		  warningColor: '#F7CB47',
		  warningSoftColor: '#362B0A',
		  warningSoftColorDarken: '#16130B',
		  warningSoftColorLighten: '#3E3720',
		  infoColor: '#178BFF',
		  infoSoftColor: '#04294E',
		  infoSoftColorDarken: '#0C1A27',
		  infoSoftColorLighten: '#1A3856'
		};
		const themeAuto = {
		  ...themeLight,
		};
		const themes = {
		  'light': themeLight,
		  'dark': themeDark,
		  'auto': themeAuto
		};
		/* Auto Generated End */
		const schemeHighContrastMerged = {
		  disabledColor: 'GrayText',
		  focusColor: 'Highlight',
		};
		const schemeHighContrast = {
		  canvasColor: 'Canvas',
		  canvasTextColor: 'CanvasText',
		  highlightColor: 'Highlight',
		  linkColor: 'LinkText',
		};
		const getThemedColors = (theme) => {
		  return isHighContrastMode ? { ...themes[theme], ...schemeHighContrastMerged } : themes[theme];
		};
		const getHighContrastColors = () => {
		  return schemeHighContrast;
		};
		const getInvertedThemedColors = (theme) => {
		  return getThemedColors(isThemeDark(theme) ? 'light' : 'dark');
		};

		const transitionDuration = 'var(--p-transition-duration, .24s)';
		const transitionTimingFunction = 'ease';
		const getTransition = (cssProperty) => `${cssProperty} ${transitionDuration} ${transitionTimingFunction}`;
		const pxToRemWithUnit = (px) => `${px / 16}rem`;
		const addImportantToRule = (value) => `${value} !important`;
		const addImportantToEachRule = (input) => {
		  return Object.entries(input).reduce((result, [key, value]) => value === null
		    ? result
		    : ((result[key] =
		      typeof value === 'object' ? addImportantToEachRule(value) : addImportantToRule(value)),
		      result), {});
		};
		// TODO: this is workaround, in order the colors to be bundled in the main bundle, we need to have at least one function here, which is used in project and which calls "getThemedColors"
		// TODO: This mechanism needs to be investigated as part of refactoring
		const doGetThemedColors = (theme = 'light') => {
		  return getThemedColors(theme);
		};
		const getInsetJssStyle = (value = 0) => {
		  value = value === 0 || value === 'auto' ? value : `${value}px`;
		  return {
		    top: value,
		    left: value,
		    right: value,
		    bottom: value,
		  };
		};
		// reset initial styles, e.g. in case link-pure is used with slotted anchor and nested within e.g. an accordion
		const getResetInitialStylesForSlottedAnchor = {
		  margin: 0,
		  padding: 0,
		  outline: 0,
		  borderRadius: 0,
		  background: 'transparent',
		};
		const focusPseudoJssStyle = {
		  outline: 0,
		  '&:focus::before': {
		    content: '""',
		    position: 'absolute',
		    ...getInsetJssStyle(),
		    borderRadius: '1px',
		    outline: `${borderWidthBase} solid ${themeLightStateFocus}`,
		    outlineOffset: '2px',
		  },
		  '&:focus:not(:focus-visible)::before': {
		    outline: 0,
		  },
		};
		/**
		 * Returns a JSS style object that can be used to visually hide text in the browser, while still allowing it to be accessed by screen readers.
		 * @param {boolean} isHidden - A boolean value indicating whether the text should be hidden or not. Defaults to true.
		 * @param {JssStyle} isShownJssStyle - Additional styles applied when isHidden = false
		 * @returns {JssStyle} - A JSS style object containing styles depending on the value of isHidden and isShownJssStyle.
		 */
		const getHiddenTextJssStyle = (isHidden = true, isShownJssStyle) => isHidden
		  ? {
		    position: 'absolute',
		    width: 0,
		    height: '1px',
		    textIndent: '-999999px',
		  }
		  : {
		    position: 'static',
		    width: 'auto',
		    height: 'auto',
		    textIndent: 0,
		    ...isShownJssStyle,
		  };
		const getBackfaceVisibilityJssStyle = () => ({
		  backfaceVisibility: 'hidden',
		  WebkitBackfaceVisibility: 'hidden',
		});
		/**
		 * Generates JSS styles for a frosted glass background.
		 * @param {boolean} isVisible - Determines if the frosted glass effect is visible.
		 * @param {string} duration - The duration of the transition animation.
		 * @param {string} timingFn - The timing function of the transition animation. (default: 'cubic-bezier(.16,1,.3,1)')
		 * @returns {JssStyle} - The JSS styles for the frosted glass background.
		 */
		const getFrostedGlassBackgroundJssStyles = (isVisible, duration, timingFn = 'cubic-bezier(.16,1,.3,1)') => {
		  return {
		    // workaround via pseudo element to fix stacking (black) background in safari
		    '&::before': {
		      content: '""',
		      position: 'fixed',
		      ...getInsetJssStyle(),
		      background: themeDarkBackgroundShading,
		      pointerEvents: 'none',
		      ...(isVisible
		        ? {
		          opacity: 1,
		          ...frostedGlassStyle,
		        }
		        : {
		          opacity: 0,
		          backdropFilter: 'blur(0px)',
		          WebkitBackdropFilter: 'blur(0px)',
		        }),
		      transition: `opacity ${duration} ${timingFn}, backdrop-filter ${duration} ${timingFn}, --webkit-backdrop-filter ${duration} ${timingFn}`,
		    },
		  };
		};

		// NOTE: handpicked selection of plugins from jss-preset-default
		const jss = createJss({
		  plugins: [
		    jssGlobal(),
		    jssNested(),
		    camelCase(),
		    dist({ combineMediaQueries: true }),
		  ],
		});
		const getCss = (jssStyles) => jss
		  .createStyleSheet(jssStyles, {
		  generateId: (rule) => rule.key,
		})
		  .toString();
		const supportsConstructableStylesheets = () => {
		  try {
		    return typeof new CSSStyleSheet().replaceSync === 'function';
		  }
		  catch {
		    return false;
		  }
		};
		// determine it once
		const hasConstructableStylesheetSupport = supportsConstructableStylesheets();
		// getter for easy mocking
		const getHasConstructableStylesheetSupport = () => hasConstructableStylesheetSupport;
		const componentCssMap = new Map();
		const getCachedComponentCss = (host, getComponentCss, ...args) => {
		  const tagName = getTagNameWithoutPrefix(host);
		  if (!componentCssMap.has(tagName)) {
		    componentCssMap.set(tagName, new Map());
		  }
		  const id = args.map((arg) => (typeof arg === 'object' ? JSON.stringify(arg) : arg)).join('|');
		  const cache = componentCssMap.get(tagName);
		  if (!cache.has(id)) {
		    cache.set(id, getComponentCss(...args));
		  }
		  return cache.get(id);
		};
		const attachComponentCss = (host, getComponentCss, ...args) => {
		  const css = getCachedComponentCss(host, getComponentCss, ...args);
		  if (getHasConstructableStylesheetSupport()) {
		    const [sheet] = host.shadowRoot.adoptedStyleSheets;
		    if (sheet) {
		      sheet.replaceSync(css);
		    }
		    else {
		      const newSheet = new CSSStyleSheet();
		      newSheet.replaceSync(css);
		      host.shadowRoot.adoptedStyleSheets = [newSheet];
		    }
		  }
		  else {
		    // NOTE: fallback for Safari
		    // old style needs to be removed and added again in safari to be recognized
		    getShadowRootHTMLElement(host, 'style[jss]')?.remove();
		    const styleEl = document.createElement('style');
		    styleEl.setAttribute('jss', '');
		    styleEl.innerHTML = css;
		    host.shadowRoot.prepend(styleEl);
		  }
		};
		// TODO: this function does nothing but treats for unknowns reasons e.g. getThemedColors to be bundled into main chunk
		const doNothing = () => {
		  addImportantToEachRule({});
		  hasPropValueChanged(1, 1); // to force into main chunk
		};
		const buildResponsiveStyles = (rawValue, getJssStyle) => {
		  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
		  const value = parseJSON(rawValue);
		  return typeof value === 'object'
		    ? Object.keys(value)
		      // base styles are applied on root object, responsive styles are nested within
		      // hence it is used as the initial object within reduce function
		      .filter((key) => key !== 'base')
		      .reduce((result, breakpointValue) => ({
		      ...result,
		      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
		      [getMediaQueryMin(breakpointValue)]: getJssStyle(value[breakpointValue]),
		    }), getJssStyle(value.base))
		    : getJssStyle(value);
		};
		const isObject = (obj) => typeof obj === 'object' && !Array.isArray(obj);
		// NOTE: taken from https://stackoverflow.com/a/48218209
		const mergeDeep = (...objects) => {
		  return objects.reduce((prev, obj) => {
		    Object.keys(obj).forEach((key) => {
		      const pVal = prev[key];
		      const oVal = obj[key];
		      if (isObject(pVal) && isObject(oVal)) {
		        prev[key] = mergeDeep(pVal, oVal);
		      }
		      else {
		        prev[key] = oVal;
		      }
		    });
		    return prev;
		  }, {});
		};

		const isThemeDark = (theme) => {
		  return theme === 'dark';
		};

		const formatObjectOutput = (value) => {
		  return JSON.stringify(value)
		    .replace(/"([a-zA-Z?]+)":/g, '$1:') // remove double quotes from keys
		    .replace(/([,:{])/g, '$1 ') // add space after following: ,:{
		    .replace(/(})/g, ' $1') // add space before following: }
		    .replace(/^"(.+)"$/, '$1'); // remove wrapping double quotes
		};
		const formatArrayOutput = (value) => {
		  return (JSON.stringify(value.map((x) => (x === undefined ? `${x}` : x))) // wrap undefined in quotes to not convert it to null
		    .replace(/'/g, '') // remove single quotes
		    // eslint-disable-next-line @typescript-eslint/quotes
		    .replace(/"/g, "'") // replace double quotes with single quotes
		    .replace(/'(undefined)'/, '$1') // remove quotes around undefined
		    .replace(/,/g, ', ') // add space after comma
		  );
		};
		const printErrorMessage = ({ propName, propValue, // TODO: might be nicer if this is always a string
		propType, componentName, }) => {
		  consoleError(`Invalid property '${propName}' with value '${formatObjectOutput(propValue)}' supplied to ${componentName}, expected one of: ${propType}`);
		};
		const isValueNotOfType = (propValue, propType) => {
		  return propValue !== undefined && typeof propValue !== propType;
		};
		const validateValueOfType = (propName, propValue, propType) => {
		  if (isValueNotOfType(propValue, propType)) {
		    return { propName, propValue, propType };
		  }
		};
		const breakpointCustomizableTemplate = 'value, ' +
		  formatObjectOutput(breakpoints.reduce((prev, key) => ({ ...prev, [key + (key !== 'base' ? '?' : '')]: 'value' }), {})).replace(/"/g, '');
		const getBreakpointCustomizableStructure = (allowedValues) => {
		  if (allowedValues !== 'boolean' && allowedValues !== 'number') {
		    allowedValues = formatArrayOutput(allowedValues)
		      .replace(/\[/g, '(') // starting inline type literal array
		      .replace(/]/g, ')[]') // ending inline type literal array
		      .replace(/,/g, ' |'); // replace commas with a pipe
		  }
		  return breakpointCustomizableTemplate.replace(/value/g, allowedValues);
		};
		const getAriaStructure = (allowedAriaAttributes) => {
		  return (formatObjectOutput(allowedAriaAttributes.reduce((prev, key) => ({
		    ...prev,
		    [key]: 'value',
		  }), {}))
		    .replace(/":/g, '"?:') // add optional modifier on keys before colon
		    // eslint-disable-next-line @typescript-eslint/quotes
		    .replace(/"/g, "'") // replace double quotes with single quotes
		  );
		};
		const getShapeStructure = (shapeStructure) => {
		  return formatObjectOutput(Object.keys(shapeStructure).reduce((prev, key) => ({ ...prev, [key]: shapeStructure[key].name }), {})).replace(/"/g, ''); // remove double quotes
		};
		const isBreakpointCustomizableValueInvalid = (value, allowedValues) => {
		  return allowedValues === 'boolean' || allowedValues === 'number'
		    ? isValueNotOfType(value, allowedValues)
		    : !allowedValues.includes(value);
		};
		// TODO: maybe dissolve object structure and have standalone utils
		const AllowedTypes = {
		  // eslint-disable-next-line id-blacklist
		  string: (...args) => validateValueOfType(...args, 'string'),
		  // eslint-disable-next-line id-blacklist
		  number: (...args) => validateValueOfType(...args, 'number'),
		  // eslint-disable-next-line id-blacklist
		  boolean: (...args) => validateValueOfType(...args, 'boolean'),
		  array: (allowedType) => 
		  // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
		  function array(propName, propValue) {
		    return isValidArray(propName, propValue, allowedType);
		  },
		  oneOf: (allowedValuesOrValidatorFunctions) => 
		  // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
		  function oneOf(propName, propValue) {
		    // use first item to determine if we've got primitive types or validator functions
		    if (typeof allowedValuesOrValidatorFunctions[0] !== 'function') {
		      if (!allowedValuesOrValidatorFunctions.includes(propValue)) {
		        return { propName, propValue, propType: formatArrayOutput(allowedValuesOrValidatorFunctions) };
		      }
		    }
		    else if (!allowedValuesOrValidatorFunctions.some((func) => func(propName, propValue) === undefined)) {
		      return {
		        propName,
		        propValue,
		        propType: allowedValuesOrValidatorFunctions.map((func) => func.name).join(', '),
		      };
		    }
		  },
		  breakpoint: (allowedValues) => 
		  // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
		  function breakpoint(propName, propValue) {
		    // TODO: do parseJSON once in the component, currently it is happening multiple times in a single lifecycle
		    const value = parseJSON(propValue);
		    let isInvalid = false;
		    if (typeof value === 'object') {
		      if (
		      // check structure keys: base, xs, s, m, l, xl
		      // TODO: check for base key
		      Object.keys(value).some((key) => !breakpoints.includes(key)) ||
		        // check actual values of keys, e.g. true, false, 'small' or 5
		        Object.values(value).some((val) => isBreakpointCustomizableValueInvalid(val, allowedValues))) {
		        isInvalid = true;
		      }
		    }
		    else if (isBreakpointCustomizableValueInvalid(value, allowedValues)) {
		      // single flat value like true, false, 'small' or 5, not breakpoint customizable object
		      isInvalid = true;
		    }
		    if (isInvalid) {
		      return {
		        propName,
		        propValue: formatObjectOutput(value),
		        propType: getBreakpointCustomizableStructure(allowedValues),
		      };
		    }
		  },
		  aria: (allowedAriaAttributes) => 
		  // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
		  function aria(propName, propValue) {
		    const ariaAttributes = parseJSONAttribute(propValue);
		    if (ariaAttributes &&
		      Object.keys(ariaAttributes).some((ariaKey) => !allowedAriaAttributes.includes(ariaKey))) {
		      return {
		        propName,
		        propValue: formatObjectOutput(ariaAttributes),
		        propType: getAriaStructure(allowedAriaAttributes),
		      };
		    }
		  },
		  shape: (shapeStructure) => 
		  // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
		  function shape(propName, propValue) {
		    if (propValue) {
		      // const propValueKeys = Object.keys(propValue);
		      if (
		      // check structure, but propValue could contain additional keys
		      // but how to handle optional keys like in table-head-cell's sort property?
		      // Object.keys(shapeStructure).some((key) => !propValueKeys.includes(key)) ||
		      // check values
		      Object.entries(shapeStructure).some(([structureKey, validatorFunc]) => validatorFunc(structureKey, propValue[structureKey]))) {
		        // TODO: more precise inner errors from value validation could be output
		        return {
		          propName,
		          propValue,
		          propType: getShapeStructure(shapeStructure),
		        };
		      }
		    }
		  },
		};
		const validateProps = (instance, propTypes) => {
		  Object.entries(propTypes)
		    .map(([propKey, validatorFunc]) => validatorFunc(propKey, instance[propKey]))
		    .filter((x) => x)
		    .forEach((error) => printErrorMessage({ ...error, componentName: getTagNameWithoutPrefix(instance.host) }));
		};
		/**
		 * Validates an array using a provided validator function and returns the first encountered validation error.
		 *
		 * @param {string} propName - The name of the property being validated.
		 * @param {any} arr - The input to be validated.
		 * @param {ValidatorFunction} validator - The validator function that checks each array item.
		 * @returns {ValidationError | undefined} The first encountered validation error object, or undefined if the array is valid.
		 */
		const isValidArray = (propName, arr, validator) => {
		  const validationError = Array.isArray(arr)
		    ? validator(propName, arr.find((item) => validator(propName, item)))
		    : {
		      propName,
		      propValue: arr,
		      propType: validator(propName, null).propType, // Get propType by passing in null which will always result in error
		    };
		  if (validationError) {
		    return { ...validationError, propType: `${validationError.propType}[]` };
		  }
		};

		exports.AllowedTypes = AllowedTypes;
		exports.Host = Host;
		exports.addImportantToEachRule = addImportantToEachRule;
		exports.addImportantToRule = addImportantToRule;
		exports.addInputEventListenerForCounter = addInputEventListenerForCounter;
		exports.attachComponentCss = attachComponentCss;
		exports.bootstrapLazy = bootstrapLazy;
		exports.borderWidthBase = borderWidthBase;
		exports.breakpoint = breakpoint;
		exports.breakpoints = breakpoints;
		exports.buildResponsiveStyles = buildResponsiveStyles;
		exports.consoleWarn = consoleWarn;
		exports.createEvent = createEvent;
		exports.doGetThemedColors = doGetThemedColors;
		exports.doNothing = doNothing;
		exports.focusPseudoJssStyle = focusPseudoJssStyle;
		exports.forceUpdate = forceUpdate;
		exports.frostedGlassStyle = frostedGlassStyle;
		exports.getBackfaceVisibilityJssStyle = getBackfaceVisibilityJssStyle;
		exports.getCss = getCss;
		exports.getCurrentMatchingBreakpointValue = getCurrentMatchingBreakpointValue;
		exports.getElement = getElement;
		exports.getFrostedGlassBackgroundJssStyles = getFrostedGlassBackgroundJssStyles;
		exports.getHTMLElement = getHTMLElement;
		exports.getHiddenTextJssStyle = getHiddenTextJssStyle;
		exports.getHighContrastColors = getHighContrastColors;
		exports.getInsetJssStyle = getInsetJssStyle;
		exports.getInvertedThemedColors = getInvertedThemedColors;
		exports.getMediaQueryMin = getMediaQueryMin;
		exports.getPrefixedTagNames = getPrefixedTagNames;
		exports.getResetInitialStylesForSlottedAnchor = getResetInitialStylesForSlottedAnchor;
		exports.getShadowRootHTMLElement = getShadowRootHTMLElement;
		exports.getTagName = getTagName;
		exports.getTagNameWithoutPrefix = getTagNameWithoutPrefix;
		exports.getThemedColors = getThemedColors;
		exports.getTransition = getTransition;
		exports.h = h;
		exports.hasCounter = hasCounter;
		exports.hasPropValueChanged = hasPropValueChanged;
		exports.hasWindow = hasWindow;
		exports.isHighContrastMode = isHighContrastMode;
		exports.isThemeDark = isThemeDark;
		exports.mergeDeep = mergeDeep;
		exports.observeAttributes = observeAttributes;
		exports.observeBreakpointChange = observeBreakpointChange;
		exports.observeChildren = observeChildren;
		exports.paramCaseToCamelCase = paramCaseToCamelCase;
		exports.parseAndGetAriaAttributes = parseAndGetAriaAttributes;
		exports.parseJSON = parseJSON;
		exports.parseJSONAttribute = parseJSONAttribute;
		exports.promiseResolve = promiseResolve;
		exports.pxToRemWithUnit = pxToRemWithUnit;
		exports.registerInstance = registerInstance;
		exports.removeAttribute = removeAttribute;
		exports.setAriaAttributes = setAriaAttributes;
		exports.setAttribute = setAttribute;
		exports.setNonce = setNonce;
		exports.throttle = throttle;
		exports.throwException = throwException;
		exports.transitionDuration = transitionDuration;
		exports.unobserveAttributes = unobserveAttributes;
		exports.unobserveBreakpointChange = unobserveBreakpointChange;
		exports.unobserveChildren = unobserveChildren;
		exports.validateProps = validateProps;

		
	} (validatePropsC2afb75b));
	return validatePropsC2afb75b;
}

var hasRequiredLoader_cjs;

function requireLoader_cjs () {
	if (hasRequiredLoader_cjs) return loader_cjs;
	hasRequiredLoader_cjs = 1;

	Object.defineProperty(loader_cjs, '__esModule', { value: true });

	const validateProps = requireValidatePropsC2afb75b();
	const appGlobals = requireAppGlobalsBaf8fc74();
	requireGetCDNBaseURLE7722df3();

	const defineCustomElements = (win, options) => {
	  if (typeof window === 'undefined') return undefined;
	  if(!window.PDS_SKIP_FETCH) { appGlobals.globalScripts(); }
	  return validateProps.bootstrapLazy(JSON.parse("[[\"p-table_7.cjs\",[[1,\"p-table\",{\"caption\":[1],\"theme\":[1]}],[1,\"p-table-body\"],[1,\"p-table-cell\",{\"multiline\":[4]}],[1,\"p-table-head\"],[1,\"p-table-head-cell\",{\"sort\":[16],\"hideLabel\":[4,\"hide-label\"],\"multiline\":[4]}],[1,\"p-table-head-row\"],[1,\"p-table-row\"]]],[\"p-flex_2.cjs\",[[1,\"p-flex\",{\"inline\":[8],\"wrap\":[1],\"direction\":[1],\"justifyContent\":[1,\"justify-content\"],\"alignItems\":[1,\"align-items\"],\"alignContent\":[1,\"align-content\"]}],[1,\"p-flex-item\",{\"width\":[1],\"offset\":[1],\"alignSelf\":[1,\"align-self\"],\"grow\":[8],\"shrink\":[8],\"flex\":[1]}]]],[\"p-grid_2.cjs\",[[1,\"p-grid\",{\"direction\":[1],\"wrap\":[1],\"gutter\":[8]}],[1,\"p-grid-item\",{\"size\":[8],\"offset\":[8]}]]],[\"p-multi-select_2.cjs\",[[1,\"p-multi-select\",{\"label\":[1],\"description\":[1],\"name\":[1],\"value\":[1040],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"disabled\":[4],\"required\":[4],\"dropdownDirection\":[1,\"dropdown-direction\"],\"theme\":[1],\"isOpen\":[32],\"srHighlightedOptionText\":[32],\"hasFilterResults\":[32]},[[0,\"internalOptionUpdate\",\"updateOptionHandler\"]]],[1,\"p-multi-select-option\",{\"value\":[1],\"disabled\":[4]}]]],[\"p-segmented-control_2.cjs\",[[1,\"p-segmented-control\",{\"backgroundColor\":[1,\"background-color\"],\"theme\":[1],\"value\":[8],\"columns\":[8]}],[17,\"p-segmented-control-item\",{\"value\":[8],\"disabled\":[4],\"label\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"]},[[2,\"click\",\"onClick\"]]]]],[\"p-select-wrapper_2.cjs\",[[1,\"p-select-wrapper\",{\"label\":[1],\"description\":[1],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"filter\":[4],\"theme\":[1],\"dropdownDirection\":[1,\"dropdown-direction\"],\"native\":[4]}],[1,\"p-select-wrapper-dropdown\",{\"selectRef\":[16],\"label\":[1],\"description\":[1],\"message\":[1],\"state\":[1],\"direction\":[1],\"theme\":[1],\"filter\":[4],\"required\":[4],\"disabled\":[4],\"onOpenChange\":[16],\"isOpenOverride\":[4,\"is-open-override\"],\"isOpen\":[32],\"optionMaps\":[32],\"searchString\":[32]}]]],[\"p-stepper-horizontal_2.cjs\",[[1,\"p-stepper-horizontal\",{\"size\":[1],\"theme\":[1]}],[17,\"p-stepper-horizontal-item\",{\"state\":[1],\"disabled\":[4]},[[2,\"click\",\"onClick\"]]]]],[\"p-tabs_2.cjs\",[[1,\"p-tabs\",{\"size\":[1],\"weight\":[1],\"theme\":[1],\"gradientColorScheme\":[1,\"gradient-color-scheme\"],\"gradientColor\":[1,\"gradient-color\"],\"activeTabIndex\":[1026,\"active-tab-index\"],\"tabsItemElements\":[32]}],[1,\"p-tabs-item\",{\"label\":[1]}]]],[\"p-text-list_2.cjs\",[[1,\"p-text-list\",{\"listType\":[1,\"list-type\"],\"orderType\":[1,\"order-type\"],\"type\":[1],\"theme\":[1]}],[1,\"p-text-list-item\"]]],[\"p-toast_2.cjs\",[[1,\"p-toast\",{\"theme\":[1],\"addMessage\":[64]}],[1,\"p-toast-item\",{\"text\":[1],\"state\":[1],\"theme\":[1]}]]],[\"p-accordion.cjs\",[[1,\"p-accordion\",{\"size\":[1],\"theme\":[1],\"heading\":[1],\"tag\":[1],\"open\":[4],\"compact\":[4]}]]],[\"p-banner.cjs\",[[1,\"p-banner\",{\"open\":[4],\"heading\":[1],\"description\":[1],\"state\":[1],\"dismissButton\":[4,\"dismiss-button\"],\"persistent\":[4],\"width\":[1],\"theme\":[1]}]]],[\"p-button.cjs\",[[17,\"p-button\",{\"type\":[1],\"disabled\":[4],\"loading\":[4],\"variant\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"hideLabel\":[8,\"hide-label\"],\"theme\":[1],\"aria\":[1]},[[2,\"click\",\"onClick\"]]]]],[\"p-button-group.cjs\",[[1,\"p-button-group\",{\"direction\":[1]}]]],[\"p-button-pure.cjs\",[[17,\"p-button-pure\",{\"type\":[1],\"disabled\":[4],\"loading\":[4],\"size\":[1],\"weight\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"active\":[4],\"hideLabel\":[8,\"hide-label\"],\"alignLabel\":[1,\"align-label\"],\"stretch\":[8],\"theme\":[1],\"aria\":[1]},[[2,\"click\",\"onClick\"]]]]],[\"p-button-tile.cjs\",[[17,\"p-button-tile\",{\"size\":[1],\"weight\":[1],\"background\":[1],\"aspectRatio\":[1,\"aspect-ratio\"],\"label\":[1],\"description\":[1],\"align\":[1],\"gradient\":[4],\"compact\":[1032],\"type\":[1],\"disabled\":[4],\"loading\":[4],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"aria\":[1]},[[2,\"click\",\"onClick\"]]]]],[\"p-carousel.cjs\",[[1,\"p-carousel\",{\"heading\":[1],\"description\":[1],\"alignHeader\":[1,\"align-header\"],\"rewind\":[4],\"wrapContent\":[4,\"wrap-content\"],\"width\":[1],\"slidesPerPage\":[1032,\"slides-per-page\"],\"disablePagination\":[1032,\"disable-pagination\"],\"pagination\":[1032],\"intl\":[1],\"theme\":[1],\"activeSlideIndex\":[2,\"active-slide-index\"],\"skipLinkTarget\":[1,\"skip-link-target\"],\"amountOfPages\":[32]}]]],[\"p-checkbox-wrapper.cjs\",[[1,\"p-checkbox-wrapper\",{\"label\":[1],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"loading\":[4],\"theme\":[1]},[[0,\"keydown\",\"onKeydown\"]]]]],[\"p-content-wrapper.cjs\",[[1,\"p-content-wrapper\",{\"width\":[1],\"backgroundColor\":[1,\"background-color\"],\"theme\":[1]}]]],[\"p-crest.cjs\",[[17,\"p-crest\",{\"href\":[1],\"target\":[1],\"aria\":[1]}]]],[\"p-display.cjs\",[[1,\"p-display\",{\"tag\":[1],\"size\":[1],\"align\":[1],\"color\":[1],\"ellipsis\":[4],\"theme\":[1]}]]],[\"p-divider.cjs\",[[1,\"p-divider\",{\"color\":[1],\"orientation\":[1],\"direction\":[1],\"theme\":[1]}]]],[\"p-fieldset.cjs\",[[1,\"p-fieldset\",{\"label\":[1],\"labelSize\":[1,\"label-size\"],\"required\":[4],\"state\":[1],\"message\":[1],\"theme\":[1]}]]],[\"p-fieldset-wrapper.cjs\",[[1,\"p-fieldset-wrapper\",{\"label\":[1],\"labelSize\":[1,\"label-size\"],\"required\":[4],\"state\":[1],\"message\":[1],\"theme\":[1]}]]],[\"p-flyout.cjs\",[[1,\"p-flyout\",{\"open\":[4],\"position\":[1],\"theme\":[1],\"aria\":[1]}]]],[\"p-heading.cjs\",[[1,\"p-heading\",{\"tag\":[1],\"size\":[1],\"align\":[1],\"color\":[1],\"ellipsis\":[4],\"theme\":[1]}]]],[\"p-headline.cjs\",[[1,\"p-headline\",{\"variant\":[1],\"tag\":[1],\"align\":[1],\"color\":[1],\"ellipsis\":[4],\"theme\":[1]}]]],[\"p-icon.cjs\",[[1,\"p-icon\",{\"name\":[1],\"source\":[1],\"color\":[1],\"size\":[1],\"lazy\":[4],\"theme\":[1],\"aria\":[1]}]]],[\"p-inline-notification.cjs\",[[1,\"p-inline-notification\",{\"heading\":[1],\"description\":[1],\"state\":[1],\"dismissButton\":[4,\"dismiss-button\"],\"persistent\":[4],\"actionLabel\":[1,\"action-label\"],\"actionLoading\":[4,\"action-loading\"],\"actionIcon\":[1,\"action-icon\"],\"theme\":[1]}]]],[\"p-link.cjs\",[[17,\"p-link\",{\"variant\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"href\":[1],\"theme\":[1],\"target\":[1],\"download\":[1],\"rel\":[1],\"hideLabel\":[8,\"hide-label\"],\"aria\":[1]}]]],[\"p-link-pure.cjs\",[[17,\"p-link-pure\",{\"alignLabel\":[1,\"align-label\"],\"stretch\":[8],\"size\":[1],\"weight\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"underline\":[4],\"href\":[1],\"active\":[4],\"hideLabel\":[8,\"hide-label\"],\"theme\":[1],\"target\":[1],\"download\":[1],\"rel\":[1],\"aria\":[1]}]]],[\"p-link-social.cjs\",[[17,\"p-link-social\",{\"icon\":[1],\"iconSource\":[1,\"icon-source\"],\"href\":[1],\"theme\":[1],\"target\":[1],\"rel\":[1],\"hideLabel\":[8,\"hide-label\"]}]]],[\"p-link-tile.cjs\",[[17,\"p-link-tile\",{\"size\":[1],\"weight\":[1],\"background\":[1],\"aspectRatio\":[1,\"aspect-ratio\"],\"label\":[1],\"description\":[1],\"align\":[1],\"gradient\":[4],\"compact\":[1032],\"href\":[1],\"target\":[1],\"download\":[1],\"rel\":[1],\"aria\":[1]}]]],[\"p-link-tile-model-signature.cjs\",[[1,\"p-link-tile-model-signature\",{\"model\":[1],\"weight\":[1],\"aspectRatio\":[1,\"aspect-ratio\"],\"heading\":[1],\"description\":[1],\"linkDirection\":[1,\"link-direction\"],\"headingTag\":[1,\"heading-tag\"]}]]],[\"p-marque.cjs\",[[17,\"p-marque\",{\"trademark\":[4],\"variant\":[1],\"size\":[1],\"href\":[1],\"target\":[1],\"aria\":[1]}]]],[\"p-modal.cjs\",[[1,\"p-modal\",{\"open\":[4],\"disableCloseButton\":[4,\"disable-close-button\"],\"dismissButton\":[4,\"dismiss-button\"],\"disableBackdropClick\":[4,\"disable-backdrop-click\"],\"heading\":[1],\"fullscreen\":[8],\"aria\":[1]}]]],[\"p-model-signature.cjs\",[[1,\"p-model-signature\",{\"model\":[1],\"size\":[1],\"color\":[1],\"theme\":[1]}]]],[\"p-pagination.cjs\",[[17,\"p-pagination\",{\"totalItemsCount\":[2,\"total-items-count\"],\"itemsPerPage\":[2,\"items-per-page\"],\"activePage\":[1026,\"active-page\"],\"maxNumberOfPageLinks\":[8,\"max-number-of-page-links\"],\"showLastPage\":[4,\"show-last-page\"],\"allyLabel\":[1,\"ally-label\"],\"allyLabelPrev\":[1,\"ally-label-prev\"],\"allyLabelPage\":[1,\"ally-label-page\"],\"allyLabelNext\":[1,\"ally-label-next\"],\"intl\":[1],\"theme\":[1],\"breakpointMaxNumberOfPageLinks\":[32]}]]],[\"p-pin-code.cjs\",[[1,\"p-pin-code\",{\"label\":[1],\"description\":[1],\"name\":[1],\"length\":[2],\"hideLabel\":[8,\"hide-label\"],\"state\":[1],\"disabled\":[4],\"loading\":[4],\"required\":[4],\"message\":[1],\"type\":[1],\"value\":[1025],\"theme\":[1]}]]],[\"p-popover.cjs\",[[1,\"p-popover\",{\"direction\":[1],\"description\":[1],\"aria\":[1],\"theme\":[1],\"open\":[32]}]]],[\"p-radio-button-wrapper.cjs\",[[1,\"p-radio-button-wrapper\",{\"label\":[1],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"loading\":[4],\"theme\":[1]}]]],[\"p-scroller.cjs\",[[1,\"p-scroller\",{\"gradientColorScheme\":[1,\"gradient-color-scheme\"],\"gradientColor\":[1,\"gradient-color\"],\"scrollToPosition\":[1025,\"scroll-to-position\"],\"scrollIndicatorPosition\":[1,\"scroll-indicator-position\"],\"alignScrollIndicator\":[1,\"align-scroll-indicator\"],\"theme\":[1],\"scrollbar\":[4],\"aria\":[1],\"isPrevHidden\":[32],\"isNextHidden\":[32]}]]],[\"p-spinner.cjs\",[[1,\"p-spinner\",{\"size\":[1],\"theme\":[1],\"aria\":[1]}]]],[\"p-switch.cjs\",[[17,\"p-switch\",{\"alignLabel\":[1,\"align-label\"],\"hideLabel\":[8,\"hide-label\"],\"stretch\":[8],\"checked\":[4],\"disabled\":[4],\"loading\":[4],\"theme\":[1]},[[2,\"click\",\"onClick\"]]]]],[\"p-tabs-bar.cjs\",[[1,\"p-tabs-bar\",{\"size\":[1],\"weight\":[1],\"theme\":[1],\"gradientColorScheme\":[1,\"gradient-color-scheme\"],\"gradientColor\":[1,\"gradient-color\"],\"activeTabIndex\":[1026,\"active-tab-index\"],\"tabElements\":[32]}]]],[\"p-tag.cjs\",[[1,\"p-tag\",{\"theme\":[1],\"color\":[1],\"icon\":[1],\"iconSource\":[1,\"icon-source\"]}]]],[\"p-tag-dismissible.cjs\",[[17,\"p-tag-dismissible\",{\"color\":[1],\"theme\":[1],\"label\":[1],\"aria\":[1]}]]],[\"p-text.cjs\",[[1,\"p-text\",{\"tag\":[1],\"size\":[1],\"weight\":[1],\"align\":[1],\"color\":[1],\"ellipsis\":[4],\"theme\":[1]}]]],[\"p-text-field-wrapper.cjs\",[[1,\"p-text-field-wrapper\",{\"label\":[1],\"unit\":[1],\"unitPosition\":[1,\"unit-position\"],\"description\":[1],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"showCharacterCount\":[4,\"show-character-count\"],\"showCounter\":[4,\"show-counter\"],\"actionIcon\":[1,\"action-icon\"],\"actionLoading\":[4,\"action-loading\"],\"showPasswordToggle\":[4,\"show-password-toggle\"],\"theme\":[1],\"showPassword\":[32],\"isClearable\":[32]}]]],[\"p-textarea-wrapper.cjs\",[[1,\"p-textarea-wrapper\",{\"label\":[1],\"description\":[1],\"state\":[1],\"message\":[1],\"hideLabel\":[8,\"hide-label\"],\"showCharacterCount\":[4,\"show-character-count\"],\"showCounter\":[4,\"show-counter\"],\"theme\":[1]}]]],[\"p-wordmark.cjs\",[[17,\"p-wordmark\",{\"size\":[1],\"theme\":[1],\"href\":[1],\"target\":[1],\"aria\":[1]}]]]]"), options);
	};

	loader_cjs.setNonce = validateProps.setNonce;
	loader_cjs.defineCustomElements = defineCustomElements;

	
	return loader_cjs;
}

var hasRequiredSrc;

function requireSrc () {
	if (hasRequiredSrc) return src;
	hasRequiredSrc = 1;
	// polyfills for features used by our components but unsupported within jest (jsdom)
	requireAdoptedStyleSheets();
	requireIntersectionObserver();
	requireMatchMedia();
	requireMatchMedia_addListener();
	requireDist();

	if (!navigator.userAgent.includes('Node.js') && !navigator.userAgent.includes('jsdom')) {
	  throw new Error(
	    '[Porsche Design System] the jsdom-polyfill sub package should only be used in node and jsdom environments'
	  );
	}

	// skip initial stylesheet fetch
	window.PDS_SKIP_FETCH = true;

	// Since DSR conversion does not work in jsdom render client side markup instead
	process.browser = true;

	// jsdom polyfill build does not load anything from CDN and also does not use our web components manager
	// therefore, we have to setup the document.porscheDesignSystem ourselves here
	// '3.7.0-rc.2' is replaced during build
	document.porscheDesignSystem = {
	  cdn: {
	    url: 'https://cdn.ui.porsche.com', // needs to be set because we're not initializing via components-js load() method which would normally set this
	    prefixes: [],
	  },
	  ['3.7.0-rc.2']: {
	    readyResolve: () => {},
	    isReady: () => Promise.resolve(),
	  },
	};

	// workaround for WebComponentManager not working in jsdom because of missing <script type="module"> support
	// see: https://github.com/jsdom/jsdom/issues/2475
	requireLoader_cjs().defineCustomElements(); // this is executed synchronous since stencil v4

	window.PDS_SKIP_FETCH = false;
	return src;
}

var srcExports = requireSrc();
var index = /*@__PURE__*/getDefaultExportFromCjs(srcExports);

module.exports = index;
