/// <reference types="google.maps" />
import { LatLong } from '../entities/places';
import { NaviErrorType } from '../utility/navi-error';
type CheckConsent = (args: {
  processorId: string;
  timeoutVar: Record<string, never>;
  mapContainer: string;
  callbacks: {
    success: () => void;
  };
}) => void;
export type MarketingWindow = Window & {
  GlobalConsent?: {
    Processor?: {
      googleMaps?: string;
    };
  };
  PCOM?: {
    globalConsent?: {
      checkConsent?: CheckConsent;
    };
  };
  ucPrivacyShield?: {
    checkConsent?: CheckConsent;
  };
};
declare class WindowService {
  get location(): Location;
  set location(newLocation: Location);
  get sessionStorage(): Storage;
  get localStorage(): Storage;
  set version(version: string);
  set navigationLoaded(loaded: boolean);
  get bodyOverflow(): string;
  get bodyHeight(): string;
  requestAnimationFrame(callback: FrameRequestCallback): number;
  createDiv(): HTMLDivElement;
  getBreakpoint(): number;
  get redirected(): boolean;
  createIframe(id: string, src: string): void;
  removeElement(id: string): void;
  redirectToUrl(url: string): void;
  generateRandom(size: number): string;
  /**
   * site does NOT have consent mechanism -> consent NOT needed
   * site does have consent mechanism + isConsentActive NOT exists -> consent NOT needed
   * site does have consent mechanism + isConsentActive exists + isConsentActive -> consent needed
   * site does have consent mechanism + NOT isConsentActive -> consent NOT needed
   */
  /**
   * consent needed + consent given -> userConsent = true
   * consent needed + consent NOT given -> userConsent = false
   * consent NOT needed -> userConsent = true
   */
  maybeCheckMarketingConsent(handleSuccess: () => void): boolean;
  deriveChallenge(code: string): Promise<string>;
  hashString(text: string): Promise<string>;
  getScrollbarWidth(): string;
  fetchGoogleMapsApi(apiKey: string, url?: string): Promise<typeof google>;
  getNavigatorLatLong(): Promise<LatLong>;
  getCookie(cookieName: string): string;
  setCookie(cookieName: string, newValue: string): void;
  btoa(data: string): string;
  private initialBodyStyleValues;
  private initialDocumentScrollTop;
  lockScroll(): void;
  unlockScroll(): void;
  hasScrollbar(): boolean;
  waitForElement(parent: HTMLElement, selector?: string): Promise<HTMLElement>;
}
interface GeolocationPositionError {
  code: number;
  message: string;
  PERMISSION_DENIED: number;
  POSITION_UNAVAILABLE: number;
  TIMEOUT: number;
}
export declare function getErrorType(error: GeolocationPositionError): NaviErrorType;
declare const _default: WindowService;
export default _default;
