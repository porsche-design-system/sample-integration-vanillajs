import { r as routerStore } from './router-store.js';
import { h as RoutingKeyPointers, f as findTopLevelRoutingKey, R as RoutingKeys, c as constructRoutingKey } from './routing-key.js';
import { o as isDesktop, p as dispatchEvent } from './helper.js';
import { w as windowService } from './window-service.js';
import { d as dealerSearchResultsStore } from './dealer-search-results-store.js';
import { a as animationManager } from './animation-manager.js';

const AnimationSequences = {
  OPEN_DOUBLE_DRAWER: 'openDoubleDrawer',
  CLOSE_DOUBLE_DRAWER: 'closeDoubleDrawer',
  TRANSITION_SAME_LEVEL_DOUBLE_DRAWER: 'transitionSameLevelDoubleDrawer',
  TRANSITION_SAME_LEVEL_DOUBLE_DRAWER_REVERSE: 'transitionSameLevelDoubleDrawerReverse',
  TRANSITION_NEXT_LEVEL_DOUBLE_DRAWER: 'transitionNextLevelDoubleDrawer',
  TRANSITION_PREVIOUS_LEVEL_DOUBLE_DRAWER: 'transitionPreviousLevelDoubleDrawer',
  OPEN_SINGLE_DRAWER: 'openSingleDrawer',
  CLOSE_SINGLE_DRAWER: 'closeSingleDrawer',
  TRANSITION_NEXT_LEVEL_SINGLE_DRAWER: 'transitionNextLevelSingleDrawer',
  TRANSITION_PREVIOUS_LEVEL_SINGLE_DRAWER: 'transitionPreviousLevelSingleDrawer'
};

const handleAnimationRouting = () => {
  const actions = {
    OPENING: openingAction,
    CLOSING: closingAction,
    FORWARD: forwardAction,
    BACKWARDS: backwardAction,
    UNCHANGED: unchangedAction
  };
  const conditionToExecute = getSingleDrawerAction();
  return actions[conditionToExecute]();
};
function getSingleDrawerAction() {
  if (isOpening()) {
    return 'OPENING';
  }
  if (isClosing()) {
    return 'CLOSING';
  }
  if (isAnimatingForward()) {
    return 'FORWARD';
  }
  if (isAnimatingBackward()) {
    return 'BACKWARDS';
  }
  return 'UNCHANGED';
}
const openingAction = () => {
  animationManager.play(AnimationSequences.OPEN_SINGLE_DRAWER);
  return {
    nextRoute: '',
    currentRoute: getCurrentRoute()
  };
};
const closingAction = () => {
  animationManager.play(AnimationSequences.CLOSE_SINGLE_DRAWER).then(() => {
    // TODO: Focus on burger button if using the keyboard
  });
  return {
    nextRoute: getCurrentRoute() || '',
    currentRoute: getAnimatedRoute() || ''
  };
};
const forwardAction = () => {
  var _a, _b;
  setTimeout(() => {
    animationManager.play(AnimationSequences.TRANSITION_NEXT_LEVEL_SINGLE_DRAWER);
  });
  return {
    nextRoute: (_a = getCurrentRoute()) !== null && _a !== void 0 ? _a : '',
    currentRoute: (_b = getAnimatedRoute()) !== null && _b !== void 0 ? _b : ''
  };
};
const backwardAction = () => {
  var _a, _b;
  if (getCurrentRoute() !== '') {
    setTimeout(() => {
      animationManager.play(AnimationSequences.TRANSITION_PREVIOUS_LEVEL_SINGLE_DRAWER);
    });
  }
  return {
    nextRoute: (_a = getAnimatedRoute()) !== null && _a !== void 0 ? _a : '',
    currentRoute: (_b = getCurrentRoute()) !== null && _b !== void 0 ? _b : ''
  };
};
const unchangedAction = () => {
  return {
    nextRoute: '',
    currentRoute: getCurrentRoute()
  };
};
const isPlayingSingleDrawerAnimation = () => {
  try {
    const singleDrawerAnimationSequences = [
      AnimationSequences.OPEN_SINGLE_DRAWER,
      AnimationSequences.CLOSE_SINGLE_DRAWER,
      AnimationSequences.TRANSITION_NEXT_LEVEL_SINGLE_DRAWER,
      AnimationSequences.TRANSITION_PREVIOUS_LEVEL_SINGLE_DRAWER
    ];
    return singleDrawerAnimationSequences.some((sequence) => {
      try {
        return animationManager.isPlaying(sequence);
      }
      catch (_a) {
        return false;
      }
    });
  }
  catch (e) {
    return false;
  }
};

const getCurrentRoute = () => {
  const { routingKeyHistory, routingKeyPointer } = routerStore.state;
  return routingKeyHistory[routingKeyPointer] || '';
};
const getAnimatedRoute = () => {
  const { routingKeyHistory, animatingPointer } = routerStore.state;
  return routingKeyHistory[animatingPointer] || '';
};
const goTo = (...routes) => {
  const newHistory = [RoutingKeys.MAIN_MENU, ...routes];
  routerStore.state.routingKeyPointer = routes.length;
  routerStore.state.routingKeyHistory = newHistory;
};
const back = () => {
  if (!isPlayingSingleDrawerAnimation()) {
    if (findTopLevelRoutingKey(getCurrentRoute()) === RoutingKeys.DEALER_SEARCH) {
      dealerSearchResultsStore.state.savedDealerCookie = null;
    }
    routerStore.state.routingKeyPointer = routerStore.state.routingKeyPointer - 1;
  }
};
const pop = () => {
  if (isNavigatingBackwards())
    routerStore.state.routingKeyHistory.pop();
};
const addRoute = (newRoute) => {
  if (isDesktop(windowService.getBreakpoint())) {
    dispatchEvent('phn-router', 'mobileMenuItemClick', {
      bubbles: true,
      cancelable: false,
      detail: [constructRoutingKey(getCurrentRoute(), ...newRoute)]
    });
  }
  else {
    const newHistory = [...routerStore.state.routingKeyHistory, constructRoutingKey(getCurrentRoute(), ...newRoute)];
    routerStore.state.routingKeyPointer = newHistory.length - 1;
    routerStore.state.routingKeyHistory = newHistory;
  }
};
const reset = () => {
  routerStore.state.routingKeyPointer = -1;
};
const isNavigatingBackwards = () => {
  return routerStore.state.routingKeyPointer < routerStore.state.routingKeyHistory.length - 1;
};
//____________ANIMATIONS______________//
const isAnimatingForward = () => {
  return routerStore.state.routingKeyPointer > routerStore.state.animatingPointer;
};
const isAnimatingBackward = () => {
  return routerStore.state.routingKeyPointer < routerStore.state.animatingPointer;
};
const isOpening = () => {
  return (routerStore.state.animatingPointer === RoutingKeyPointers.LEVEL_ZERO && routerStore.state.routingKeyPointer >= 0);
};
const isOpened = () => {
  return !isClosed();
};
const isClosed = () => {
  return (routerStore.state.routingKeyPointer === RoutingKeyPointers.LEVEL_ZERO &&
    routerStore.state.animatingPointer === RoutingKeyPointers.LEVEL_ZERO);
};
const isClosing = () => {
  return routerStore.state.routingKeyPointer === -1 && routerStore.state.animatingPointer >= 0;
};
const syncAnimation = () => {
  routerStore.state.animatingPointer = routerStore.state.routingKeyPointer;
};
const showBackButton = (section) => {
  const sectionKey = routerStore.state.routingKeyHistory.indexOf(section);
  return sectionKey >= RoutingKeyPointers.LEVEL_TWO;
};

export { AnimationSequences as A, addRoute as a, goTo as b, back as c, isClosed as d, isOpening as e, syncAnimation as f, getCurrentRoute as g, handleAnimationRouting as h, isOpened as i, isAnimatingForward as j, pop as p, reset as r, showBackButton as s };

//# sourceMappingURL=routing-manager.js.map