import { N as NaviError, a as NaviErrorTypes, E as Environments } from './navi-error.js';
import { h as hasKey, a as isString } from './helper.js';

const EventActions = {
  GENERAL_LOAD: 'PAGHomeNav_General_Load',
  COUNTRY_RECOMMENDER_LOAD: 'PAGHomeNav_CountryRecommender_Load',
  COUNTRY_RECOMMENDER_CHANGE: 'PAGHomeNav_CountryRecommenderChange_Click',
  COUNTRY_RECOMMENDER_CLOSE: 'PAGHomeNav_CountryRecommenderClose_Click',
  CREST_CLICK: 'PAGHomeNav_Crest_Click',
  NAVIGATION_LOAD: 'PAGHomeNav_Navigation_Load',
  MODEL_OVERLAY_LOAD: 'PAGHomeNav_ModelRangeOverlay_Load',
  MENU_BACK_CLICK: 'PAGHomeNav_MenuBack_Click',
  MENU_CLOSE_CLICK: 'PAGHomeNav_MenuClose_Click',
  META_FUNCTION_CLICK: 'PAGHomeNav_MetaFunction_Click',
  MODEL_CLICK: 'PAGHomeNav_Model_Click',
  MODEL_META_FUNCTION_CLICK: 'PAGHomeNav_ModelMetaFunction_Click',
  MODEL_CTA_CLICK: 'PAGHomeNav_ModelCTA_Click',
  MODEL_RANGE_CLICK: 'PAGHomeNav_ModelRange_Click',
  MORE_CLICK: 'PAGHomeNav_More_Click',
  NAVIGATION_CLICK: 'PAGHomeNav_Navigation_Click',
  NAVIGATION_LINK_CLICK: 'PAGHomeNav_NavigationLink_Click',
  DEALER_SEARCH_SCREEN_LOAD: 'PAGHomeNav_FindADealerSearchScreen_Load',
  DEALER_RESULTS_SCREEN_LOAD: 'PAGHomeNav_FindADealerResultsScreen_Load',
  DEALER_SEARCH_CLICK: 'PAGHomeNav_FindADealerSearch_Click',
  DEALER_GEOLOCATION_CLICK: 'PAGHomeNav_FindADealerLocateMe_Click',
  DEALER_RESULT_CLICK: 'PAGHomeNav_FindADealerDealer_Click',
  DEALER_DETAILS_SCREEN_LOAD: 'PAGHomeNav_FindADealerDealerScreen_Load',
  DEALER_CONTACT_CLICK: 'PAGHomeNav_FindADealerDealerContact_Click',
  DEALER_MAP_CLICK: 'PAGHomeNav_FindADealerMap_Click',
  CONTEXTUAL_BUTTON_CLICK: 'PAGHomeNav_IconContextLink_Click',
  DRAWER_LOAD: 'PAGHomeNav_Drawer_Load',
  PCOM_SEARCH_CLICK: 'PAGHomeNav_IconGlobalLink_Click'
};
const DATA_LAYER_APP_ID = 'nav';
const DATA_LAYER_APPLICATION_NAME = 'edgecast_CDN';
const ElementTypes = {
  closeButton: 'close-button',
  backdrop: 'backdrop',
  backButton: 'back-button',
  menuItem: 'menu-item',
  sideDrawerItem: 'side-drawer-item',
  doubleDrawer: 'double-drawer',
  singleDrawer: 'single-drawer',
  bodyTypeButton: 'body-type-button',
  myPorscheDrawer: 'my-porsche-drawer',
  dealerSearchForm: 'dealer-search-form'
};
const ClickElementTypes = {
  Link: 'link',
  Button: 'button',
  Image: 'image'
};
const DisplayElementTypes = {
  SingleDrawer: 'singleDrawer',
  DoubleDrawer: 'doubleDrawer'
};
const DEALER_SEARCH_DISPLAY_ELEMENT_ID = 'level1-mainmenu_level2-find_a_dealer';
const DEALER_SEARCH_RESULT_DISPLAY_ELEMENT_ID_DOUBLE_DRAWER = 'level1-mainmenu_level3-dealer-details';
const DEALER_SEARCH_TARGET_ELEMENT = 'level2_dealer-search-form';
const DEALER_SEARCH_ELEMENT_TYPE = 'level3_dealer-details';

var M = Object.defineProperty;
var W = (r, t, e) => t in r ? M(r, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : r[t] = e;
var o = (r, t, e) => (W(r, typeof t != "symbol" ? t + "" : t, e), e);
const y = {
  BEFORE_MERGE: "BEFORE_MERGE",
  AFTER_MERGE: "AFTER_MERGE"
}, w = {
  clean: {
    enabled: !1,
    executionPlace: y.AFTER_MERGE,
    values: ["", void 0, null]
  },
  logging: {
    enabled: !0,
    level: "warn"
  },
  validation: {
    enabled: !1,
    allowUnknown: !1,
    verbose: !0
  },
  webProperties: {
    enabled: !0,
    eventNamePattern: /.*/,
    reactiveUrl: !0,
    reactiveDimensions: !0
  }
};
class U {
  /**
   * Creates a PCOM (default) data layer schema specific object, that contains the given event name.
   *
   * @param data - Contains the event name in a standardized {@link IFactoryData} like way.
   *
   * @returns The event name in the PCOM (default) data layer schema specific object.
   *
   * @example
   * myEventNameFactory.create({ event: 'MY_EVENT_NAME' });
   * // returns:
   * // {
   * //   context: {
   * //     eventAction: 'MY_EVENT_NAME'
   * //   }
   * // }
   */
  create(t) {
    return typeof t.event != "string" || t.event.length === 0 ? {} : {
      context: {
        eventAction: t.event
      }
    };
  }
}
const S = (r, t) => {
  let e;
  for (e in r)
    if (!(!r || !r[e]) && t(r[e], e) === !1)
      return !1;
  return !0;
}, _ = (r, t) => S(r, (e, s) => {
  for (const i in r[s])
    if (t(e[i], i, e, s) === !1)
      return !1;
  return !0;
}), m = (r) => {
  for (const t in r)
    return !1;
  return !0;
}, P = (r, t = ((e) => (e = w.clean) == null ? void 0 : e.values)() || []) => (_(
  r,
  (s, i, n, l) => {
    t.includes(s) && (delete n[i], m(n) && delete r[l]);
  }
), r), G = (r, t) => r && (_(
  r,
  (e, s, i, n) => {
    t.includes(`${n.toString()}.${s.toString()}`) && (delete i[s], m(i) && delete r[n]);
  }
), r), k = (r) => (_(
  r,
  (t, e, s) => (typeof t != "function" || (s[e] = t()), !0)
), r);
const B = (r, t) => {
  const e = t.split(".");
  if (e.length !== 2)
    return;
  const s = r[e[0]];
  if (s)
    return s[e[1]];
}, C = (r) => {
  if (!r)
    return [];
  const t = [];
  return _(
    r,
    (e, s, i, n) => {
      t.push(`${n.toString()}.${s.toString()}`);
    }
  ), t;
}, j = w.logging;
var x = /* @__PURE__ */ ((r) => (r[r.error = 0] = "error", r[r.warn = 1] = "warn", r[r.log = 2] = "log", r))(x || {});
const v = class v {
  /**
   * Creates an instance of the {@link Logger} class.
   *
   * @param prefix A prefix that is used in all logs
   *   (`[PREFIX] MESSAGE`, i.e. `[GlobalDataLayer] This is a serious message`).
   * @param options Options to be merged as settings with the {@link DEFAULT_SETTINGS.logging}.
   */
  constructor(t, e) {
    /**
     * The prefix that is used in all logs.
     * @private
     */
    o(this, "prefix");
    /**
     * The merged settings. Also see the options of the {@link constructor} and the {@link DEFAULT_SETTINGS.logging}.
     *
     * @see {@link TLoggerSettings}
     *
     * @private
     */
    o(this, "settings");
    this.prefix = t, this.settings = {
      ...j,
      ...e
    };
  }
  /**
   * Helper function to merge the options of a log method call with the current {@link settings}.
   *
   * @param options  Options to be merged with the available {@link settings}
   *
   * @returns The merged temporary settings.
   *
   * @private
   */
  _getMergedSettings(t) {
    return t ? {
      ...this.settings,
      ...t
    } : this.settings;
  }
  /**
   * Check, if this log message is allowed.
   *
   * @see {@link TLoggerSettings.enabled} and {@link TLoggerSettings.level} and {@link isAvailable}
   *
   * @param type Type of the current log message.
   * @param settings The current (temporary) settings.
   *
   * @returns `true`if the log message is allowed.
   *
   * @private
   */
  _isAllowed(t, e) {
    if (!v.isAvailable || !e.enabled)
      return !1;
    const s = x[e.level];
    switch (t) {
      case "error":
      case "warn":
        return s >= x[t];
      case "info":
      case "log":
      case "debug":
      case "dir":
        return s >= 2;
      default:
        return !1;
    }
  }
  /**
   * A helper method to execute the log messages of all different types.
   *
   * @param msg The message text.
   * @param type The type of the message.
   * @param options Temporary options, that will be merged with the current {@link settings}.
   *
   * @private
   */
  _log(t, e = "log", s) {
    const i = this._getMergedSettings(s);
    if (this._isAllowed(e, i))
      switch (e) {
        case "dir":
          console.log(`[${this.prefix}] ${e}:`), console[e](t);
          break;
        default:
          console[e](`[${this.prefix}] ${t}`);
      }
  }
  /**
   * Write a normal log message.
   *
   * @param msg The message text.
   * @param options Temporary options, that will be merged with the current {@link settings}.
   */
  log(t, e) {
    this._log(t, "log", e);
  }
  /**
   * Write a log message of type `dir`.
   *
   * This message will be split in two messages, the prefix with " dir:" and the
   * {@link https://developer.mozilla.org/en-US/docs/Web/API/console/dir dir} output as interactive list.
   *
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/console/dir console.dir()}
   *
   * @param msg The message text.
   * @param options Temporary options, that will be merged with the current {@link settings}.
   */
  dir(t, e) {
    this._log(t, "dir", e);
  }
  /**
   * Write a log message of type `debug`.
   *
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/console/debug console.debug()}
   *
   * @param msg The message text.
   * @param options Temporary options, that will be merged with the current {@link settings}.
   */
  debug(t, e) {
    this._log(t, "debug", e);
  }
  /**
   * Write a log message of type `error`.
   *
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/console/error console.error()}
   *
   * @param msg The message text.
   * @param options Temporary options, that will be merged with the current {@link settings}.
   */
  error(t, e) {
    this._log(t, "error", e);
  }
  /**
   * Write a log message of type `info`.
   *
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/console/info console.info()}
   *
   * @param msg The message text.
   * @param options Temporary options, that will be merged with the current {@link settings}.
   */
  info(t, e) {
    this._log(t, "info", e);
  }
  /**
   * Write a log message of type `warn`.
   *
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/console/warn console.warn()}
   *
   * @param msg The message text.
   * @param options Temporary options, that will be merged with the current {@link settings}.
   */
  warn(t, e) {
    this._log(t, "warn", e);
  }
};
/**
 * Check if there is a console available that makes logging possible.
 */
o(v, "isAvailable", (() => typeof console < "u")());
let b = v;
const u = (...r) => {
  const t = {};
  return r.forEach((e) => {
    if (m(e))
      return;
    const s = {
      ...t,
      ...e
    };
    let i;
    for (i in s)
      typeof s[i] == "object" && !Array.isArray(s[i]) ? t[i] = {
        ...t[i],
        ...e[i]
      } : t[i] = s[i];
  }), t;
};
class q {
  /**
   * Creates a PCOM (default) data layer schema specific object, that contains the given web properties.
   *
   * @param data - Contains the web properties in a standardized {@link IFactoryData} like way.
   *
   * @returns The given web properties in the PCOM (default) data layer schema specific object.
   *
   * @example
   * myWebPropertiesFactory.create({ userAgent: 'MY_USE_AGENT' });
   * // returns:
   * // {
   * //   visitor: {
   * //     userAgent: 'MY_USE_AGENT'
   * //   }
   * // }
   */
  create(t) {
    return P(
      {
        context: {
          timestamp: t.timestamp,
          server: t.hostname
        },
        pageExperience: {
          pageId: t.url
        },
        visitor: {
          deviceBrowserBreakpoint: t.breakpoint,
          deviceBrowserHeight: t.height,
          deviceBrowserOrientation: t.orientation,
          deviceBrowserWidth: t.width,
          deviceType: t.deviceType,
          useragent: t.userAgent
        }
      },
      [void 0]
    );
  }
}
const K = w.webProperties, V = () => window.location.href.replace(/[?#].*/, ""), Y = () => (/* @__PURE__ */ new Date()).toISOString(), Q = () => window.location.hostname, R = () => window.innerHeight.toString(), D = () => window.innerHeight > window.innerWidth ? "p" : "l", T = () => window.innerWidth.toString(), X = () => window.matchMedia("(hover: none), (pointer: coarse)").matches ? "mobile" : "desktop", z = () => window.navigator.userAgent, J = (r) => {
  if (!r.breakpoints || r.breakpoints.length < 1)
    return;
  const { breakpoints: t } = r, e = () => {
    const s = window.innerWidth;
    let i = 0, n = 0;
    for (; n < t.length && s >= t[n]; )
      i = t[n], n++;
    return i.toString();
  };
  return r.reactiveDimensions ? e : e();
}, Z = (r, t) => {
  const e = {
    ...K,
    ...r
  }, i = {
    breakpoint: J(e),
    timestamp: Y(),
    hostname: Q(),
    url: e.reactiveUrl ? V : V(),
    height: e.reactiveDimensions ? R : R(),
    orientation: e.reactiveDimensions ? D : D(),
    width: e.reactiveDimensions ? T : T(),
    deviceType: X(),
    userAgent: z()
  };
  return t ? t.create(i) : i;
}, ee = (r, t) => {
  switch (t) {
    case "string":
    case "number":
    case "boolean":
      return typeof r === t;
    case "any[]":
      return Array.isArray(r) && r.length > 0;
    case "Record<string, any>":
      return typeof r == "object" && !Array.isArray(r) && Object.keys(r).length > 0;
    case "any":
      return !0;
    default:
      if ((typeof r == "boolean" || typeof r == "number" || typeof r == "string") && t.indexOf("|") > 0)
        return t.split("|").map((s) => {
          const i = s.trim();
          return /^'.*'$/.test(i) ? i.replace(/(^ ?'?|'? ?$)/g, "") : /^(true|false)$/.test(i) ? i === "true" : /^-?(\d*\.)?\d+$/.test(i) ? Number.parseFloat(i) : i.replace(/(^ ?'?|'? ?$)/g, "");
        }).includes(r);
  }
  return !0;
}, te = (r, t, e) => {
  const s = {
    level: null,
    issues: []
  };
  if (!e.enabled || !e.eventMatrix)
    return s;
  const { events: i, ...n } = e.eventMatrix, l = i.indexOf(r);
  if (l === -1)
    return s.level = "error", s.issues.push({
      level: "error",
      type: "EVENT_NOT_FOUND",
      name: r,
      message: `'${r}': Event does not exist.`
    }), s;
  const a = C(t), d = Object.keys(n), c = a.filter(
    (g) => !d.includes(g)
  );
  c.length > 0 && (e.allowUnknown || G(t, c), c.forEach((g) => {
    s.level = s.level ?? "warn", s.issues.push({
      level: "warn",
      type: "PROPERTY_DOES_NOT_EXIST",
      name: g,
      message: `'${g}': Property does not exist in the given Event Matrix.${e.allowUnknown ? "" : " It was omitted from the DataLayer payload."}`
    });
  }));
  let h;
  for (h in n) {
    const g = n[h], f = typeof g.e[l] < "u", p = g.r === 1, E = t ? B(t, h) : void 0, N = typeof E < "u";
    if (f && // Does the event want this property?
    p && // Is the property mandatory in general?
    !N && (s.level = "error", s.issues.push({
      level: "error",
      type: "REQUIRED_PROPERTY_MISSING",
      name: h,
      message: `'${h}': The required property is missing.`
    }), !e.verbose) || N && !ee(E, g.t) && (s.level = "error", s.issues.push({
      level: "error",
      type: "WRONG_PROPERTY_TYPE",
      name: h,
      message: `'${h}': Wrong type detected. Expected '${g.t}', got '${typeof E}'.`
    }), !e.verbose))
      return s;
  }
  return s;
};
class ie {
  /**
   * Create an instance of the GlobalDataLayer library. This constructor has to be overwritten to initialize the needed
   * factories ({@link _eventNamePayloadFactory} and {@link _webPayloadFactory}).
   *
   * @param options All options are merged with the {@link DEFAULT_SETTINGS} of type {@link TSettings}.
   * @param [dataStore] The array where all the pushes are added to. The default tries to get or generate the
   *   `window.pagData` array. If this is not possible, it creates an empty array, that is exposed via
   *   {@link DataLayerStore}.
   * @param [className] The class name of the library is here, because code can be uglified and/or minified later.
   *
   * @protected
   */
  constructor(t, e, s = "GlobalDataLayer") {
    /**
     * The class name of the library. This is needed, because code can be uglified and/or minified later.
     * @protected
     */
    o(this, "_className");
    /**
     * The merged settings. Also see the options of the {@link constructor} and the {@link DEFAULT_SETTINGS}.
     * @protected
     */
    o(this, "_settings");
    /**
     * An internal store where all default properties are added to.
     * @protected
     */
    o(this, "_defaultProperties");
    /**
     * An internal logger, which has to be used for all console logs.
     * @protected
     */
    o(this, "_logger");
    /**
     * A flag that indicates if the _Web Properties_ feature was already handled.
     *
     * @see {@link getWebProperties}
     *
     * @protected
     */
    o(this, "_webPropertiesHandled", !1);
    /**
     * the _DataLayer_ store array, that is used to push all the data.
     *
     * This can be transferred to the library with the second parameter `dataStore` of the {@link constructor}.
     *
     * @protected
     */
    o(this, "_dataLayerStore");
    /**
     * An internal store where all registered extensions are added to.
     * @protected
     */
    o(this, "_extensions", /* @__PURE__ */ new Map());
    const i = u(
      w,
      t || {}
    );
    this._className = s, this._logger = new b(this._className, i.logging), this._settings = i, e ? this._dataLayerStore = e : typeof window < "u" ? (this._dataLayerStore = window.pagData = window.pagData || [], this._logger.info("`dataLayerStore` was set to default `window.pagData`")) : (this._dataLayerStore = [], this._logger.info("`dataLayerStore` was set to default `[]`")), this._defaultProperties = [];
  }
  /**
   * An internal function to set everything up after initialization is done. This has to be called at the end of the
   * overwritten constructors.
   * @protected
   */
  setup() {
    this._handleDefaultWebProperties();
  }
  /**
   * The current settings object.
   * @readonly
   */
  get Settings() {
    return this._settings;
  }
  /**
   * Get the _DataLayer_ store, that is used to push all the data.
   * @readonly
   */
  get DataLayerStore() {
    return this._dataLayerStore;
  }
  /**
   * Get a registered {@link DataLayerExtension} class instance based of the input type.
   *
   * @param TConstructor The class to search for.
   *
   * @returns The registered instance of the extension class, `undefined` if not found.
   */
  getRegisteredExtension(t) {
    const e = new t();
    return this.getRegisteredExtensionByClassName(e.className);
  }
  /**
   * Get a registered {@link DataLayerExtension} class instance based of a classname.
   *
   * @param className The name of class instance to compare.
   *
   * @returns The registered instance of the extension class, undefined if not found.
   */
  getRegisteredExtensionByClassName(t) {
    return this._extensions.has(t) ? this._extensions.get(t) : void 0;
  }
  /**
   * Get all registered {@link DataLayerExtension}.
   *
   * @returns All registered DataLayerExtensions as array.
   */
  getRegisteredExtensions() {
    const t = [];
    for (const e of this._extensions.values())
      t.push(e);
    return t;
  }
  /**
   * Register a new {@link DataLayerExtension} class for this instance.
   *
   * @param extension The extension class instance to register.
   * @param override If there is an existing instance already registered, we override it, otherwise we do nothing.
   */
  registerExtension(t, e = !1) {
    if (!e && this._extensions.has(t.className)) {
      this._logger.warn(`Tried to register extension class <${t.className}> which already exists.`);
      return;
    }
    t.dataLayerInstance = this, this._extensions.set(t.className, t), e ? this._logger.info(`Overriden registration for extension class <${t.className}>.`) : this._logger.info(`Registered extension class <${t.className}>.`);
  }
  /**
   * Remove a registered {@link DataLayerExtension} instance.
   *
   * @param TConstructor The class to search for.
   */
  removeExtension(t) {
    const e = new t();
    if (this._extensions.has(e.className)) {
      this._extensions.delete(e.className);
      return;
    }
    this._logger.warn(`Tried to remove not existing extension class <${e.className}>.`);
  }
  /**
   * Remove a registered {@link DataLayerExtension} instance by class name.
   *
   * @param className the name of the class
   */
  removeExtensionByClassName(t) {
    if (this._extensions.has(t)) {
      this._extensions.delete(t);
      return;
    }
    this._logger.warn(`Tried to remove not existing extension class <${t}>.`);
  }
  /**
   * Push a GlobalDataLayer Event with payload to the given data layer store. The method can fail and return `false`
   *   because ...
   *
   *   - the given `eventName` was invalid
   *   - the validation failed
   *
   * A settings object can be added as the third parameter to every call. This will then temporary override the provided
   * settings for the time of the push action.
   *
   * @param eventName The name of the event that should be pushed.
   * @param [payload] The _DataLayer_ properties to be merged and added to the data layer.
   * @param [options] Temporary override the settings.
   *
   * @returns A boolean to indicate, if the push was successful.
   */
  push(t, e = [{}], s) {
    var d, c;
    if (t.length === 0)
      return !1;
    const i = s && !m(s) ? u(this._settings, s) : this._settings;
    Array.isArray(e) || (e = [e]), e.forEach(k);
    const n = this._eventNamePayloadFactory.create({ event: t }), l = k(this.getDefaultProperties(t));
    i.clean.enabled && i.clean.executionPlace === y.BEFORE_MERGE && [l || {}, ...e].forEach(
      (h) => P(h, i.clean.values)
    );
    const a = u(
      n,
      l || {},
      ...e
    );
    if (i.clean.enabled && i.clean.executionPlace === y.AFTER_MERGE && P(a, i.clean.values), (d = i == null ? void 0 : i.validation) != null && d.enabled && ((c = i == null ? void 0 : i.validation) != null && c.eventMatrix)) {
      const h = te(t, a, i.validation), g = h.issues.sort((f, p) => f.level !== p.level && p.level === "warn" ? -1 : 0).map((f) => `- [${f.level}]: ${f.message}`).join(`
`);
      switch (h.level) {
        case "error":
          return this._logger.error(
            `Validation failed for event '${t}' with errors/warnings: 
${g}`,
            i.logging
          ), !1;
        case "warn":
          this._logger.warn(
            `Validation success for event '${t}' with warnings: 
${g}`,
            i.logging
          );
          break;
        default:
          this._logger.info(`Validation success for event '${t}'.`, i.logging);
          break;
      }
    }
    return this._dataLayerStore.push(a), !0;
  }
  /**
   * Return the default properties for the given identifier.
   *
   * @param identifier The identifier to get the default properties for.
   *
   * @returns The found default properties for the identifier, otherwise `undefined`.
   */
  getDefaultProperties(t) {
    const e = {
      byName: [],
      byArray: [],
      byRegex: []
    };
    this._defaultProperties.forEach((i) => {
      if (i.identifier === t)
        return e.byName.push(i.data);
      if (Array.isArray(i.identifier) && i.identifier.includes(t))
        return e.byArray.push(i.data);
      if (i.identifier instanceof RegExp && i.identifier.test(t))
        return e.byRegex.push(i.data);
    });
    const s = [...e.byRegex, ...e.byArray, ...e.byName];
    if (s.length)
      return u(...s);
  }
  /**
   * Set default properties, which will later be merged with the payload of a {@link push}, when the provided identifier
   * matches the `eventName`.
   *
   * @param identifier The identifier to use the default properties for.
   * @param data The default properties which will be used with the provided identifier to merge those properties with the payload.
   */
  setDefaultProperties(t, e) {
    const s = this._defaultProperties.find((i) => i.identifier === t);
    if (s) {
      s.data = u(s.data, e);
      return;
    }
    this._defaultProperties.push({
      identifier: t,
      data: e
    });
  }
  /**
   * Checks if the web properties feature ({@link getWebProperties}) is already handled or does the setup with the
   * current settings.
   *
   * @private
   */
  _handleDefaultWebProperties() {
    if (this._webPropertiesHandled || !this._settings.webProperties.enabled)
      return;
    const t = Z(
      this._settings.webProperties,
      this._webPayloadFactory
    );
    this.setDefaultProperties(this._settings.webProperties.eventNamePattern, t), this._webPropertiesHandled = !0;
  }
}
class oe extends ie {
  /**
   * Create an instance of the GlobalDataLayer library.
   *
   * @param options All options are merged with the {@link DEFAULT_SETTINGS} of type {@link TSettings}.
   * @param [dataStore] The array where all the pushes are added to. The default tries to get or generate the
   *   `window.pagData` array. If this is not possible, it creates an empty array, that is exposed via
   *   {@link DataLayerStore}.
   * @param [className] The class name of the library is here, because code can be uglified and/or minified later.
   *
   * @protected
   */
  constructor(e, s, i = "GlobalDataLayer") {
    super(e, s, i);
    o(this, "_eventNamePayloadFactory");
    o(this, "_webPayloadFactory");
    this._eventNamePayloadFactory = new U(), this._webPayloadFactory = new q(), this.setup();
  }
  setup() {
    super.setup();
  }
}

const RegionLocales = {
  ASIA_PACIFIC: 'asia-pacific',
  EASTERN_EUROPE: 'eastern-europe',
  MIDDLE_EAST: 'middle-east',
  LATIN_AMERICA: 'latin-america',
  INTERNATIONAL: 'international' // https://www.porsche.com/international/ -> has myporsche
};
const RegionLocaleMap = {
  AP: RegionLocales.ASIA_PACIFIC,
  CE: RegionLocales.EASTERN_EUROPE,
  LL: RegionLocales.LATIN_AMERICA,
  WW: RegionLocales.INTERNATIONAL
};
function isCountryInOneOfRegions(country) {
  return Object.values(RegionLocales).includes(country);
}
function splitLocale(localeStr) {
  if (!isString(localeStr)) {
    throw new NaviError('empty locale passed', NaviErrorTypes.NO_INPUT);
  }
  const language = localeStr.substring(0, localeStr.indexOf('-')).toLowerCase();
  let country = localeStr.substring(localeStr.indexOf('-') + 1).toLowerCase();
  if (!isCountryInOneOfRegions(country)) {
    country = country.toUpperCase();
  }
  if (!isString(language) || !isString(country)) {
    throw new NaviError(`invalid locale ${localeStr} passed`, NaviErrorTypes.INVALID_INPUT);
  }
  return {
    language,
    country: hasKey(RegionLocaleMap, country) ? RegionLocaleMap[country] : country
  };
}

function getEnvironmentAbbreviation(env) {
  switch (env) {
    case Environments.PRODUCTION:
      return 'P';
    case Environments.PREVIEW:
      return 'PP';
    default:
      return 'K';
  }
}
class GlobalDataLayerService {
  constructor() {
    this.homeNavEventId = /^PAGHomeNav_/;
    this.initialise();
  }
  initialise() {
    this.gdl = new oe();
  }
  pushDataLayerEvent(eventAction, eventData) {
    if (eventData) {
      this.gdl.push(eventAction, eventData);
    }
    else {
      this.gdl.push(eventAction);
    }
  }
  setEnvironment(env) {
    this.gdl.setDefaultProperties(this.homeNavEventId, {
      context: { environment: getEnvironmentAbbreviation(env) }
    });
  }
  setPageName(pageName) {
    this.gdl.setDefaultProperties(this.homeNavEventId, {
      pageExperience: {
        pageName: pageName
      }
    });
  }
  setUser(userId, loginStatus) {
    this.gdl.setDefaultProperties(this.homeNavEventId, {
      ids: { userId },
      visitor: { loginStatus }
    });
  }
  setLocale(locale) {
    try {
      const { country, language } = splitLocale(locale);
      this.gdl.setDefaultProperties(this.homeNavEventId, {
        context: { country: country, language: language }
      });
    }
    catch (err) {
      // throw the error away
    }
  }
  setDefaultProperties(locale, pageName) {
    let defaultGDLProperties = {
      context: { applicationId: DATA_LAYER_APP_ID },
      visitor: { loginStatus: false }
    };
    try {
      const { country, language } = splitLocale(locale);
      defaultGDLProperties = Object.assign(Object.assign({}, defaultGDLProperties), { context: Object.assign(Object.assign({}, defaultGDLProperties.context), { country, language, applicationName: DATA_LAYER_APPLICATION_NAME }) });
    }
    catch (err) {
      // throw the error away
    }
    if (isString(pageName)) {
      defaultGDLProperties = Object.assign(Object.assign({}, defaultGDLProperties), { pageExperience: { pageName: pageName } });
    }
    this.gdl.setDefaultProperties(this.homeNavEventId, defaultGDLProperties);
  }
}
const globalDataLayerService = new GlobalDataLayerService();

export { ClickElementTypes as C, DEALER_SEARCH_ELEMENT_TYPE as D, EventActions as E, RegionLocales as R, ElementTypes as a, DisplayElementTypes as b, DEALER_SEARCH_DISPLAY_ELEMENT_ID as c, DEALER_SEARCH_RESULT_DISPLAY_ELEMENT_ID_DOUBLE_DRAWER as d, DEALER_SEARCH_TARGET_ELEMENT as e, globalDataLayerService as g, isCountryInOneOfRegions as i, splitLocale as s };

//# sourceMappingURL=global-data-layer-service.js.map