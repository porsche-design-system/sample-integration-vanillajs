'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-98b6cdb7.js');
const routingKey = require('./routing-key-2cb3d5c5.js');
const animationManager = require('./animation-manager-feeac76f.js');
const globalDataLayerService = require('./global-data-layer-service-534dfa5c.js');
const helper$1 = require('./helper-67121a1c.js');
const timeout = require('./timeout-2252a895.js');
const menuItemsService = require('./menu-items-service-3605196c.js');
const navContentStore = require('./nav-content-store-ed0e79aa.js');
const singleDrawerAnimationSequences = require('./single-drawer-animation-sequences-44dcfef3.js');
const analyticsManager = require('./analytics-manager-4e31846c.js');
const helper = require('./helper-5035b2a4.js');
const animations = require('./animations-34f77238.js');
require('./ab-testing-constructor-service-30304333.js');
require('./feature-toggles-bb23f232.js');
require('./router-store-1a4e63e5.js');

function DrawerContent({ routingKey, previousRoutingKey, breakpoint, locale, showBackButton, receivedContent }) {
  const { menu } = navContentStore.navContentStore.state;
  const backButtonText = menuItemsService.getBackButtonText(navContentStore.navContentStore.state, previousRoutingKey !== null && previousRoutingKey !== void 0 ? previousRoutingKey : '') || menu.text;
  return (index.h(index.Fragment, null,
    index.h("div", { class: "bottom-gradient" }),
    index.h("div", { class: "drawer-content" },
      index.h("phn-drawer-header", { showBackButton: showBackButton, backButtonAnalyticsId: menu.id, backButtonText: backButtonText, activeRoutingKey: routingKey, breakpoint: breakpoint, receivedContent: receivedContent, locale: locale }),
      index.h("phn-router", { activeRoutingKey: routingKey, breakpoint: breakpoint, locale: locale, receivedContent: receivedContent }))));
}

const singleDrawerCss = "@-webkit-keyframes transition-forward-in-animation{from{left:150%}to{left:0%}}@keyframes transition-forward-in-animation{from{left:150%}to{left:0%}}@-webkit-keyframes transition-backward-in-animation{from{left:-150%}to{left:0%}}@keyframes transition-backward-in-animation{from{left:-150%}to{left:0%}}@-webkit-keyframes single-drawer-transition-forward-in-animation{from{left:100%}to{left:0%}}@keyframes single-drawer-transition-forward-in-animation{from{left:100%}to{left:0%}}@-webkit-keyframes fade-in-animation{from{opacity:0;background-color:rgba(0, 0, 0, 0)}to{opacity:1;background-color:rgba(0, 0, 0, 0.6)}}@keyframes fade-in-animation{from{opacity:0;background-color:rgba(0, 0, 0, 0)}to{opacity:1;background-color:rgba(0, 0, 0, 0.6)}}@-webkit-keyframes slide-in-from-left-absolute{from{left:-1000px}to{left:0px}}@keyframes slide-in-from-left-absolute{from{left:-1000px}to{left:0px}}@-webkit-keyframes slideDown{from{max-height:0}to{max-height:1000px}}@keyframes slideDown{from{max-height:0}to{max-height:1000px}}@-webkit-keyframes slideUp{from{max-height:1000px}to{max-height:0}}@keyframes slideUp{from{max-height:1000px}to{max-height:0}}@-webkit-keyframes slideLeft{from{max-width:0}to{max-width:1000px}}@keyframes slideLeft{from{max-width:0}to{max-width:1000px}}@-webkit-keyframes slideRight{from{max-width:1000px}to{max-width:0}}@keyframes slideRight{from{max-width:1000px}to{max-width:0}}@-webkit-keyframes darken{from{background-color:rgba(0, 0, 0, 0)}to{background-color:rgba(0, 0, 0, 0.8)}}@keyframes darken{from{background-color:rgba(0, 0, 0, 0)}to{background-color:rgba(0, 0, 0, 0.8)}}@-webkit-keyframes lighten{from{background-color:rgba(0, 0, 0, 0.8)}to{background-color:rgba(0, 0, 0, 0)}}@keyframes lighten{from{background-color:rgba(0, 0, 0, 0.8)}to{background-color:rgba(0, 0, 0, 0)}}@-webkit-keyframes fadeInFromBottom{0%{opacity:0;top:36px}100%{opacity:1;top:0px}}@keyframes fadeInFromBottom{0%{opacity:0;top:36px}100%{opacity:1;top:0px}}@-webkit-keyframes fadeOutToTop{0%{opacity:1;bottom:0px}100%{opacity:0;bottom:16px}}@keyframes fadeOutToTop{0%{opacity:1;bottom:0px}100%{opacity:0;bottom:16px}}@-webkit-keyframes slideLeftDoubleDrawer{from{right:-1000px}to{right:0px}}@keyframes slideLeftDoubleDrawer{from{right:-1000px}to{right:0px}}@-webkit-keyframes slideRightDoubleDrawer{from{right:0px}to{right:-1000px}}@keyframes slideRightDoubleDrawer{from{right:0px}to{right:-1000px}}@-webkit-keyframes fadeIn{0%{opacity:0}100%{opacity:1}}@keyframes fadeIn{0%{opacity:0}100%{opacity:1}}@-webkit-keyframes fadeOut{0%{opacity:1}100%{opacity:0}}@keyframes fadeOut{0%{opacity:1}100%{opacity:0}}.transition-forward-animation-out.sc-phn-single-drawer{-webkit-transition:left 250ms;transition:left 250ms;position:relative !important;left:-150% !important}.transition-forward-animation-in.sc-phn-single-drawer{position:relative;-webkit-animation:transition-forward-in-animation 250ms;animation:transition-forward-in-animation 250ms}.transition-backward-animation-out.sc-phn-single-drawer{-webkit-transition:left 250ms;transition:left 250ms;position:relative !important;left:150% !important}.transition-backward-animation-in.sc-phn-single-drawer{position:relative !important;-webkit-animation:transition-backward-in-animation 250ms;animation:transition-backward-in-animation 250ms}.slide-out-to-right-fixed.sc-phn-single-drawer{-webkit-transition:left 400ms;transition:left 400ms;position:fixed;left:100% !important}.slide-in-from-right-fixed.sc-phn-single-drawer{position:fixed;-webkit-animation:single-drawer-transition-forward-in-animation 400ms;animation:single-drawer-transition-forward-in-animation 400ms}.phn-flex-col.sc-phn-single-drawer{display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column}.phn-flex-row.sc-phn-single-drawer{display:-ms-flexbox;display:flex;-ms-flex-direction:row;flex-direction:row}.phn-align-center.sc-phn-single-drawer{-ms-flex-align:center;align-items:center}.phn-justify-around.sc-phn-single-drawer{-ms-flex-pack:distribute;justify-content:space-around}.phn-justify-between.sc-phn-single-drawer{-ms-flex-pack:justify;justify-content:space-between}.phn-flex-wrap.sc-phn-single-drawer{-ms-flex-wrap:wrap;flex-wrap:wrap}.sc-phn-single-drawer-h{display:block;position:fixed;top:0;left:-1000px;height:100vh;width:100vw;z-index:301}.slide-in-from-left.sc-phn-single-drawer-h{position:absolute;-webkit-animation:slide-in-from-left-absolute 600ms;animation:slide-in-from-left-absolute 600ms}.slide-out-to-left.sc-phn-single-drawer-h{position:absolute;animation:slide-in-from-left-absolute 600ms reverse}.sc-phn-single-drawer-h .drawer.sc-phn-single-drawer{z-index:301;background-color:#fff;position:absolute;left:0}.sc-phn-single-drawer-h .drawer.sc-phn-single-drawer .drawer-content.sc-phn-single-drawer{overflow-y:auto;height:100vh;width:100vw;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 1.6875rem 6.25rem 1.6875rem}@media (min-width: 480px){.sc-phn-single-drawer-h .drawer.sc-phn-single-drawer .drawer-content.sc-phn-single-drawer{padding:0 2.1875rem 6.25rem 2.1875rem}}@media (min-width: 760px){.sc-phn-single-drawer-h .drawer.sc-phn-single-drawer .drawer-content.sc-phn-single-drawer{padding:0 3.375rem 6.25rem 3.375rem}}@media (min-width: 1000px){.sc-phn-single-drawer-h .drawer.sc-phn-single-drawer .drawer-content.sc-phn-single-drawer{padding:0 2.25rem 6.25rem 2.25rem}}.sc-phn-single-drawer-h .drawer.sc-phn-single-drawer .drawer-content.sc-phn-single-drawer phn-drawer-header.sc-phn-single-drawer{-webkit-box-sizing:border-box;box-sizing:border-box;margin-top:1.125rem;margin-bottom:1.9375rem}@media (min-width: 480px){.sc-phn-single-drawer-h .drawer.sc-phn-single-drawer .drawer-content.sc-phn-single-drawer phn-drawer-header.sc-phn-single-drawer{margin-top:2rem;margin-bottom:2.3125rem}}@media (min-width: 760px){.sc-phn-single-drawer-h .drawer.sc-phn-single-drawer .drawer-content.sc-phn-single-drawer phn-drawer-header.sc-phn-single-drawer{margin-bottom:1.25rem}}.sc-phn-single-drawer-h .drawer.sc-phn-single-drawer .drawer-content.sc-phn-single-drawer phn-router.sc-phn-single-drawer{padding-bottom:4rem}.sc-phn-single-drawer-h .drawer.sc-phn-single-drawer .bottom-gradient.sc-phn-single-drawer{height:10rem;background:-webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0)), to(rgb(255, 255, 255)));background:linear-gradient(to bottom, rgba(255, 255, 255, 0), rgb(255, 255, 255));opacity:1;position:absolute;width:100%;bottom:0;margin-left:-1.5rem;pointer-events:none;margin-left:0;z-index:1}";

const SingleDrawer = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.drawerClosed = index.createEvent(this, "drawerClosed", 7);
    this.drawerChanged = index.createEvent(this, "drawerChanged", 7);
    this.drawerStartsClosing = index.createEvent(this, "drawerStartsClosing", 7);
    this.backdropClosed = index.createEvent(this, "backdropClosed", 7);
    this.phnDrawerStatus = index.createEvent(this, "phnDrawerStatus", 7);
    this.focusTimeout = new timeout.Timeout(0);
    this.operationPipeline = [];
    this.breakpoint = undefined;
    this.locale = undefined;
    this.usingKeyboard = false;
    this.routingKeyHistory = undefined;
    this.routingKeyPointer = undefined;
    this.receivedContent = false;
    this.animatingPointer = -1;
  }
  handleKeyDown(e) {
    if (e.key !== 'Tab') {
      return;
    }
    const targetElement = helper$1.getHTMLElement(e.target);
    if (targetElement === null) {
      return;
    }
    let focusableDrawerElements = helper.getAllFocusableElements(this.el.querySelector('.active'));
    if (focusableDrawerElements.length === 0) {
      return;
    }
    const activeRoutingKey = this.routingKeyHistory[this.routingKeyPointer];
    if (activeRoutingKey.startsWith(routingKey.RoutingKeys.DEALER_SEARCH)) {
      focusableDrawerElements = focusableDrawerElements.filter((element) => element.nodeName !== 'BUTTON' && element.nodeName !== 'A');
    }
    const firstFocusableDrawerElement = focusableDrawerElements[0];
    const lastFocusableDrawerElement = focusableDrawerElements[focusableDrawerElements.length - 1];
    if (targetElement === firstFocusableDrawerElement && e.shiftKey) {
      e.preventDefault();
      if (lastFocusableDrawerElement !== null) {
        helper$1.focusOnElement(lastFocusableDrawerElement);
      }
      return;
    }
    if (targetElement === lastFocusableDrawerElement && !e.shiftKey) {
      e.preventDefault();
      if (firstFocusableDrawerElement !== null) {
        helper$1.focusOnElement(firstFocusableDrawerElement);
      }
      return;
    }
  }
  handleMobileMenuItemClick(e) {
    if (singleDrawerAnimationSequences.isPlayingSingleDrawerAnimation()) {
      e.stopPropagation();
      return;
    }
    this.animatingPointer = this.routingKeyPointer;
  }
  handleClickDrawerHeaderClose(e) {
    if (singleDrawerAnimationSequences.isPlayingSingleDrawerAnimation()) {
      e.stopPropagation();
      return;
    }
  }
  handleClickDrawerHeaderBack(e) {
    if (singleDrawerAnimationSequences.isPlayingSingleDrawerAnimation()) {
      e.stopPropagation();
      return;
    }
    this.animatingPointer = this.routingKeyPointer;
  }
  onTransitionEnd() {
    const focussedElementId = this.animatingPointer > this.routingKeyPointer ? this.routingKeyHistory[this.animatingPointer] : '';
    this.animatingPointer = this.routingKeyPointer;
    const isNavigatingBackwards = this.routingKeyPointer < this.routingKeyHistory.length - 1;
    this.drawerChanged.emit(isNavigatingBackwards);
    // Focus needs to happen after rerender, so wait for next tick
    this.focusTimeout.set(async () => {
      this.focusOnActiveDrawer(focussedElementId);
    });
    this.sendDataLayerEvent();
  }
  componentWillLoad() {
    singleDrawerAnimationSequences.registerOpenSingleDrawerAnimation({
      onAnimationStarts: () => {
        this.phnDrawerStatus.emit({ status: helper$1.DrawerStatusValues.startOpening });
      },
      onAnimationEnds: () => {
        this.onTransitionEnd();
        this.phnDrawerStatus.emit({ status: helper$1.DrawerStatusValues.finishOpening });
      }
    });
    singleDrawerAnimationSequences.registerCloseSingleDrawerAnimation({
      onAnimationStarts: () => {
        this.phnDrawerStatus.emit({ status: helper$1.DrawerStatusValues.startClosing });
      },
      onAnimationEnds: () => {
        this.backdropClosed.emit();
        this.phnDrawerStatus.emit({ status: helper$1.DrawerStatusValues.finishClosing });
      }
    });
    singleDrawerAnimationSequences.registerTransitionNextLevelSingleDrawerAnimation({
      onAnimationEnds: () => this.onTransitionEnd()
    });
    singleDrawerAnimationSequences.registerTransitionPreviousLevelSingleDrawerAnimation({ onAnimationEnds: () => this.onTransitionEnd() });
  }
  focusOnActiveDrawer(focussedElementId) {
    const autoFocusElement = helper$1.getHTMLElement(this.el.querySelector('.active .autofocus'));
    if (autoFocusElement !== null) {
      helper$1.focusOnElement(autoFocusElement);
      return;
    }
    if (this.usingKeyboard) {
      let focussableElement = null;
      if (helper$1.isString(focussedElementId)) {
        focussableElement = helper$1.getHTMLElement(this.el.querySelector(`.active [data-id="${focussedElementId}"]`));
      }
      if (focussableElement === null) {
        focussableElement = helper$1.getHTMLElement(this.el.querySelector(`.active ${helper$1.FOCUSABLE_ELEMENTS_SELECTOR}`));
      }
      if (focussableElement !== null) {
        helper$1.focusOnElement(focussableElement);
      }
    }
    else {
      //Todo: Why first-focus class? We have it nowhere
      const firstFocus = helper$1.getHTMLElement(this.el.querySelector('.first-focus'));
      if (firstFocus !== null) {
        helper$1.focusOnElement(firstFocus);
      }
    }
  }
  sendDataLayerEvent() {
    analyticsManager.analyticsManager.setDrawerType(navContentStore.DisplayElementTypes.SingleDrawer);
    const activeRoutingKey = this.routingKeyHistory[this.routingKeyPointer];
    globalDataLayerService.globalDataLayerService.pushDataLayerEvent(navContentStore.EventActions.DRAWER_LOAD, {
      componentDisplay: {
        displayElementType: analyticsManager.analyticsManager.calculateDisplayElementType(activeRoutingKey, navContentStore.ElementTypes.singleDrawer),
        displayElementId: analyticsManager.analyticsManager.calculateDisplayElementId(),
        displayElementName: 'Single Drawer'
      }
    });
  }
  disconnectedCallback() {
    this.focusTimeout.cancel();
  }
  async componentDidRender() {
    const promises = [];
    for (const operation of this.operationPipeline) {
      const maybePromise = operation();
      if (helper$1.isPromise(maybePromise)) {
        promises.push(maybePromise);
      }
    }
    await Promise.all(promises);
    this.operationPipeline.splice(0, this.operationPipeline.length);
  }
  render() {
    var _a, _b;
    const isAnimatingForward = this.routingKeyPointer > this.animatingPointer;
    const isAnimatingBackward = this.routingKeyPointer < this.animatingPointer;
    let topDrawerContentPointer = -1;
    let bottomDrawerContentPointer = this.routingKeyPointer;
    if (isAnimatingForward && this.animatingPointer !== routingKey.RoutingKeyPointers.LEVEL_ZERO) {
      topDrawerContentPointer = this.routingKeyPointer;
      bottomDrawerContentPointer = this.animatingPointer;
      this.operationPipeline.push(async () => {
        animationManager.animationManager.play(animations.AnimationSequences.TRANSITION_NEXT_LEVEL_SINGLE_DRAWER);
      });
    }
    else if (isAnimatingBackward) {
      topDrawerContentPointer = this.animatingPointer;
      if (bottomDrawerContentPointer !== routingKey.RoutingKeyPointers.LEVEL_ZERO) {
        this.operationPipeline.push(async () => {
          animationManager.animationManager.play(animations.AnimationSequences.TRANSITION_PREVIOUS_LEVEL_SINGLE_DRAWER);
        });
      }
    }
    const animatingRoutingKey = (_a = this.routingKeyHistory[topDrawerContentPointer]) !== null && _a !== void 0 ? _a : '';
    const routingKey$1 = (_b = this.routingKeyHistory[bottomDrawerContentPointer]) !== null && _b !== void 0 ? _b : '';
    return (index.h(index.Host, null, helper$1.isString(routingKey$1) ? (index.h("div", { class: "drawer active", key: routingKey$1 }, index.h("span", { class: "first-focus", tabIndex: -1, "aria-hidden": "true" }), index.h(DrawerContent, { routingKey: routingKey$1, previousRoutingKey: this.routingKeyHistory[bottomDrawerContentPointer - 1], breakpoint: this.breakpoint, locale: this.locale, showBackButton: bottomDrawerContentPointer > 0, receivedContent: this.receivedContent }))) : null, helper$1.isString(animatingRoutingKey) ? (index.h("div", { class: `drawer animating`, style: isAnimatingForward ? { left: '100%' } : {}, key: animatingRoutingKey }, index.h(DrawerContent, { routingKey: animatingRoutingKey, previousRoutingKey: this.routingKeyHistory[topDrawerContentPointer - 1], breakpoint: this.breakpoint, locale: this.locale, showBackButton: topDrawerContentPointer > 0, receivedContent: this.receivedContent }))) : null));
  }
  get el() { return index.getElement(this); }
};
SingleDrawer.style = singleDrawerCss;

exports.phn_single_drawer = SingleDrawer;

//# sourceMappingURL=phn-single-drawer.cjs.entry.js.map