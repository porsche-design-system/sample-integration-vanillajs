'use strict';

const helper = require('./helper-67121a1c.js');
const index = require('./index-98b6cdb7.js');

const Environments = {
  PRODUCTION: 'production',
  PREVIEW: 'preview',
  TEST: 'test',
  LOCAL: 'local'
};
function getEnvironment(test) {
  switch (test) {
    case Environments.PREVIEW.toString():
      return Environments.PREVIEW;
    case Environments.TEST.toString():
      return Environments.TEST;
    case Environments.LOCAL.toString():
      return Environments.LOCAL;
    case Environments.PRODUCTION.toString():
    default:
      return Environments.PRODUCTION;
  }
}

const EventActions = {
  GENERAL_LOAD: 'PAGHomeNav_General_Load',
  COUNTRY_RECOMMENDER_LOAD: 'PAGHomeNav_CountryRecommender_Load',
  COUNTRY_RECOMMENDER_CHANGE: 'PAGHomeNav_CountryRecommenderChange_Click',
  COUNTRY_RECOMMENDER_CLOSE: 'PAGHomeNav_CountryRecommenderClose_Click',
  CREST_CLICK: 'PAGHomeNav_Crest_Click',
  NAVIGATION_LOAD: 'PAGHomeNav_Navigation_Load',
  MODEL_OVERLAY_LOAD: 'PAGHomeNav_ModelRangeOverlay_Load',
  MENU_BACK_CLICK: 'PAGHomeNav_MenuBack_Click',
  MENU_CLOSE_CLICK: 'PAGHomeNav_MenuClose_Click',
  META_FUNCTION_CLICK: 'PAGHomeNav_MetaFunction_Click',
  MODEL_CLICK: 'PAGHomeNav_Model_Click',
  MODEL_META_FUNCTION_CLICK: 'PAGHomeNav_ModelMetaFunction_Click',
  MODEL_CTA_CLICK: 'PAGHomeNav_ModelCTA_Click',
  MODEL_RANGE_CLICK: 'PAGHomeNav_ModelRange_Click',
  MORE_CLICK: 'PAGHomeNav_More_Click',
  NAVIGATION_CLICK: 'PAGHomeNav_Navigation_Click',
  NAVIGATION_LINK_CLICK: 'PAGHomeNav_NavigationLink_Click',
  DEALER_SEARCH_SCREEN_LOAD: 'PAGHomeNav_FindADealerSearchScreen_Load',
  DEALER_RESULTS_SCREEN_LOAD: 'PAGHomeNav_FindADealerResultsScreen_Load',
  DEALER_SEARCH_CLICK: 'PAGHomeNav_FindADealerSearch_Click',
  DEALER_GEOLOCATION_CLICK: 'PAGHomeNav_FindADealerLocateMe_Click',
  DEALER_RESULT_CLICK: 'PAGHomeNav_FindADealerDealer_Click',
  DEALER_DETAILS_SCREEN_LOAD: 'PAGHomeNav_FindADealerDealerScreen_Load',
  DEALER_CONTACT_CLICK: 'PAGHomeNav_FindADealerDealerContact_Click',
  DEALER_MAP_CLICK: 'PAGHomeNav_FindADealerMap_Click',
  CONTEXTUAL_BUTTON_CLICK: 'PAGHomeNav_IconContextLink_Click',
  DRAWER_LOAD: 'PAGHomeNav_Drawer_Load',
  PCOM_SEARCH_CLICK: 'PAGHomeNav_IconGlobalLink_Click'
};
const DATA_LAYER_APP_ID = 'nav';
const DATA_LAYER_APPLICATION_NAME = 'edgecast_CDN';
const ElementTypes = {
  closeButton: 'close-button',
  backdrop: 'backdrop',
  backButton: 'back-button',
  menuItem: 'menu-item',
  sideDrawerItem: 'side-drawer-item',
  doubleDrawer: 'double-drawer',
  singleDrawer: 'single-drawer',
  bodyTypeButton: 'body-type-button',
  myPorscheDrawer: 'my-porsche-drawer',
  dealerSearchForm: 'dealer-search-form'
};
const ClickElementTypes = {
  Link: 'link',
  Button: 'button',
  Image: 'image'
};
const DisplayElementTypes = {
  SingleDrawer: 'singleDrawer',
  DoubleDrawer: 'doubleDrawer'
};
const DEALER_SEARCH_DISPLAY_ELEMENT_ID = 'level1-mainmenu_level2-find_a_dealer';
const DEALER_SEARCH_RESULT_DISPLAY_ELEMENT_ID_DOUBLE_DRAWER = 'level1-mainmenu_level3-dealer-details';
const DEALER_SEARCH_TARGET_ELEMENT = 'level2_dealer-search-form';
const DEALER_SEARCH_ELEMENT_TYPE = 'level3_dealer-details';

class NaviError extends Error {
  constructor(message, type) {
    super(message);
    this.type = type;
    // This line fixes a bug/feature in typescript to do with extending built-in classes.
    // Do not touch.
    // Link: https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
    Object.setPrototypeOf(this, NaviError.prototype);
  }
}
const NaviErrorTypes = {
  NO_INPUT: 'NO_INPUT',
  INVALID_INPUT: 'INVALID_INPUT',
  NO_RESULTS: 'NO_RESULTS',
  GENERAL: 'GENERAL',
  RETRY: 'RETRY',
  GEOLOCATION_DENIED: 'GEOLOCATION_DENIED',
  UNAUTHORIZED: 'UNAUTHORIZED'
};
function getErrorMessage(errorContent, err) {
  if (!(err instanceof NaviError)) {
    return errorContent.wrong;
  }
  switch (err.type) {
    case NaviErrorTypes.NO_INPUT:
      return errorContent.noInput;
    case NaviErrorTypes.INVALID_INPUT:
      return errorContent.invalidInput;
    case NaviErrorTypes.NO_RESULTS:
      return errorContent.noResults;
    case NaviErrorTypes.GENERAL:
      return errorContent.wrong;
    case NaviErrorTypes.RETRY:
      return errorContent.retry;
    case NaviErrorTypes.GEOLOCATION_DENIED:
      return errorContent.geolocationDenied;
    default:
      return errorContent.wrong;
  }
}

const RegionLocales = {
  ASIA_PACIFIC: 'asia-pacific',
  EASTERN_EUROPE: 'eastern-europe',
  MIDDLE_EAST: 'middle-east',
  LATIN_AMERICA: 'latin-america',
  INTERNATIONAL: 'international' // https://www.porsche.com/international/ -> has myporsche
};
const RegionLocaleMap = {
  AP: RegionLocales.ASIA_PACIFIC,
  CE: RegionLocales.EASTERN_EUROPE,
  LL: RegionLocales.LATIN_AMERICA,
  WW: RegionLocales.INTERNATIONAL
};
function isCountryInOneOfRegions(country) {
  return Object.values(RegionLocales).includes(country);
}
function splitLocale(localeStr) {
  if (!helper.isString(localeStr)) {
    throw new NaviError('empty locale passed', NaviErrorTypes.NO_INPUT);
  }
  const language = localeStr.substring(0, localeStr.indexOf('-')).toLowerCase();
  let country = localeStr.substring(localeStr.indexOf('-') + 1).toLowerCase();
  if (!isCountryInOneOfRegions(country)) {
    country = country.toUpperCase();
  }
  if (!helper.isString(language) || !helper.isString(country)) {
    throw new NaviError(`invalid locale ${localeStr} passed`, NaviErrorTypes.INVALID_INPUT);
  }
  return {
    language,
    country: helper.hasKey(RegionLocaleMap, country) ? RegionLocaleMap[country] : country
  };
}

const appendToMap = (map, propName, value) => {
    const items = map.get(propName);
    if (!items) {
        map.set(propName, [value]);
    }
    else if (!items.includes(value)) {
        items.push(value);
    }
};
const debounce = (fn, ms) => {
    let timeoutId;
    return (...args) => {
        if (timeoutId) {
            clearTimeout(timeoutId);
        }
        timeoutId = setTimeout(() => {
            timeoutId = 0;
            fn(...args);
        }, ms);
    };
};

/**
 * Check if a possible element isConnected.
 * The property might not be there, so we check for it.
 *
 * We want it to return true if isConnected is not a property,
 * otherwise we would remove these elements and would not update.
 *
 * Better leak in Edge than to be useless.
 */
const isConnected = (maybeElement) => !('isConnected' in maybeElement) || maybeElement.isConnected;
const cleanupElements = debounce((map) => {
    for (let key of map.keys()) {
        map.set(key, map.get(key).filter(isConnected));
    }
}, 2000);
const stencilSubscription = () => {
    if (typeof index.getRenderingRef !== 'function') {
        // If we are not in a stencil project, we do nothing.
        // This function is not really exported by @stencil/core.
        return {};
    }
    const elmsToUpdate = new Map();
    return {
        dispose: () => elmsToUpdate.clear(),
        get: (propName) => {
            const elm = index.getRenderingRef();
            if (elm) {
                appendToMap(elmsToUpdate, propName, elm);
            }
        },
        set: (propName) => {
            const elements = elmsToUpdate.get(propName);
            if (elements) {
                elmsToUpdate.set(propName, elements.filter(index.forceUpdate));
            }
            cleanupElements(elmsToUpdate);
        },
        reset: () => {
            elmsToUpdate.forEach((elms) => elms.forEach(index.forceUpdate));
            cleanupElements(elmsToUpdate);
        },
    };
};

const unwrap = (val) => (typeof val === 'function' ? val() : val);
const createObservableMap = (defaultState, shouldUpdate = (a, b) => a !== b) => {
    const unwrappedState = unwrap(defaultState);
    let states = new Map(Object.entries(unwrappedState !== null && unwrappedState !== void 0 ? unwrappedState : {}));
    const handlers = {
        dispose: [],
        get: [],
        set: [],
        reset: [],
    };
    const reset = () => {
        var _a;
        // When resetting the state, the default state may be a function - unwrap it to invoke it.
        // otherwise, the state won't be properly reset
        states = new Map(Object.entries((_a = unwrap(defaultState)) !== null && _a !== void 0 ? _a : {}));
        handlers.reset.forEach((cb) => cb());
    };
    const dispose = () => {
        // Call first dispose as resetting the state would
        // cause less updates ;)
        handlers.dispose.forEach((cb) => cb());
        reset();
    };
    const get = (propName) => {
        handlers.get.forEach((cb) => cb(propName));
        return states.get(propName);
    };
    const set = (propName, value) => {
        const oldValue = states.get(propName);
        if (shouldUpdate(value, oldValue, propName)) {
            states.set(propName, value);
            handlers.set.forEach((cb) => cb(propName, value, oldValue));
        }
    };
    const state = (typeof Proxy === 'undefined'
        ? {}
        : new Proxy(unwrappedState, {
            get(_, propName) {
                return get(propName);
            },
            ownKeys(_) {
                return Array.from(states.keys());
            },
            getOwnPropertyDescriptor() {
                return {
                    enumerable: true,
                    configurable: true,
                };
            },
            has(_, propName) {
                return states.has(propName);
            },
            set(_, propName, value) {
                set(propName, value);
                return true;
            },
        }));
    const on = (eventName, callback) => {
        handlers[eventName].push(callback);
        return () => {
            removeFromArray(handlers[eventName], callback);
        };
    };
    const onChange = (propName, cb) => {
        const unSet = on('set', (key, newValue) => {
            if (key === propName) {
                cb(newValue);
            }
        });
        // We need to unwrap the defaultState because it might be a function.
        // Otherwise we might not be sending the right reset value.
        const unReset = on('reset', () => cb(unwrap(defaultState)[propName]));
        return () => {
            unSet();
            unReset();
        };
    };
    const use = (...subscriptions) => {
        const unsubs = subscriptions.reduce((unsubs, subscription) => {
            if (subscription.set) {
                unsubs.push(on('set', subscription.set));
            }
            if (subscription.get) {
                unsubs.push(on('get', subscription.get));
            }
            if (subscription.reset) {
                unsubs.push(on('reset', subscription.reset));
            }
            if (subscription.dispose) {
                unsubs.push(on('dispose', subscription.dispose));
            }
            return unsubs;
        }, []);
        return () => unsubs.forEach((unsub) => unsub());
    };
    const forceUpdate = (key) => {
        const oldValue = states.get(key);
        handlers.set.forEach((cb) => cb(key, oldValue, oldValue));
    };
    return {
        state,
        get,
        set,
        on,
        onChange,
        use,
        dispose,
        reset,
        forceUpdate,
    };
};
const removeFromArray = (array, item) => {
    const index = array.indexOf(item);
    if (index >= 0) {
        array[index] = array[array.length - 1];
        array.length--;
    }
};

const createStore = (defaultState, shouldUpdate) => {
    const map = createObservableMap(defaultState, shouldUpdate);
    map.use(stencilSubscription());
    return map;
};

const navStateStore = createStore({
  loggedInState: helper.LOGGED_OUT_USER_STATUS,
  unreadMessagesCount: helper.DEFAULT_UNREAD_MESSAGES_COUNT,
  userConsent: false,
  env: getEnvironment(helper.DEFAULT_ENVIRONMENT),
  app: helper.Application.default
});

const EMPTY_LINK = { id: '', text: '', link: '', icon: '', description: '' };
const EMPTY_BUTTON = { id: '', text: '', description: '' };
const EMPTY_COUNTRY_RECOMMENDER = {
  statement: '',
  region: '',
  language: '',
  change: EMPTY_BUTTON
};
const EMPTY_MODELS = {
  text: '',
  id: '',
  all: {
    id: '',
    text: '',
    link: '',
    icon: '',
    description: ''
  },
  series: []
};
const EMPTY_MENU = {
  id: '',
  text: '',
  link: '',
  children: []
};
const EMPTY_SHOP_MENU = {
  cart: '',
  additionalContent: [],
  id: '',
  text: '',
  link: '',
  children: [],
  availableLocales: [],
  availableLocalesOnlyForShop: [],
  logoLinksToShopLocales: []
};
const EMPTY_MYPORSCHE = {
  id: '',
  text: '',
  link: '',
  loggedInFallback: '',
  login: EMPTY_LINK,
  loginText: '',
  logout: EMPTY_LINK,
  messages: EMPTY_LINK,
  more: null,
  signup: EMPTY_LINK,
  signupText: '',
  links: [],
  savedSearches: null,
  savedVehicles: null
};
const EMPTY_DEALER = {
  id: '',
  text: '',
  numberOfDealers: 42,
  search: {
    id: '',
    text: '',
    form: {
      inputPlaceholder: '',
      inputDescription: ''
    },
    clear: EMPTY_BUTTON,
    or: '',
    geolocation: EMPTY_BUTTON,
    dropdown: {
      province: '',
      city: '',
      selectAProvince: '',
      selectACity: ''
    },
    load: '',
    map: EMPTY_LINK,
    outboundLink: EMPTY_LINK
  },
  details: {
    id: '',
    finder: EMPTY_LINK,
    bookService: EMPTY_LINK,
    testDrive: EMPTY_LINK,
    backToSearch: ''
  },
  openingHours: null
};
const EMPTY_ERRORS = {
  wrong: '',
  retry: '',
  noResults: '',
  noInput: '',
  invalidInput: '',
  geolocationDenied: ''
};
const EMPTY_CONTENT = {
  menu: EMPTY_BUTTON,
  crest: EMPTY_LINK,
  back: EMPTY_BUTTON,
  close: EMPTY_BUTTON,
  accessibilityStatement: EMPTY_LINK,
  countryRecommender: EMPTY_COUNTRY_RECOMMENDER,
  contextualButtons: {},
  contextualLinks: {},
  models: EMPTY_MODELS,
  dealer: EMPTY_DEALER,
  myPorsche: EMPTY_MYPORSCHE,
  vehiclePurchase: EMPTY_MENU,
  shop: EMPTY_SHOP_MENU,
  externalShop: EMPTY_LINK,
  experience: EMPTY_MENU,
  services: EMPTY_MENU,
  error: EMPTY_ERRORS,
  loadingDescription: '',
  legacyMore: EMPTY_MENU,
  legacyShop: EMPTY_MENU
};
function findMenuItemById(menu, id) {
  if (!helper.isString(id)) {
    return null;
  }
  if (menu !== null) {
    if (menu.id === id) {
      return menu;
    }
    if (!Array.isArray(menu.children)) {
      return null;
    }
    for (const child of menu.children) {
      const foundChild = findMenuItemById(child, id);
      if (foundChild !== null) {
        return foundChild;
      }
    }
  }
  return null;
}

const navContentStore = createStore(EMPTY_CONTENT);

exports.ClickElementTypes = ClickElementTypes;
exports.DATA_LAYER_APPLICATION_NAME = DATA_LAYER_APPLICATION_NAME;
exports.DATA_LAYER_APP_ID = DATA_LAYER_APP_ID;
exports.DEALER_SEARCH_DISPLAY_ELEMENT_ID = DEALER_SEARCH_DISPLAY_ELEMENT_ID;
exports.DEALER_SEARCH_ELEMENT_TYPE = DEALER_SEARCH_ELEMENT_TYPE;
exports.DEALER_SEARCH_RESULT_DISPLAY_ELEMENT_ID_DOUBLE_DRAWER = DEALER_SEARCH_RESULT_DISPLAY_ELEMENT_ID_DOUBLE_DRAWER;
exports.DEALER_SEARCH_TARGET_ELEMENT = DEALER_SEARCH_TARGET_ELEMENT;
exports.DisplayElementTypes = DisplayElementTypes;
exports.ElementTypes = ElementTypes;
exports.Environments = Environments;
exports.EventActions = EventActions;
exports.NaviError = NaviError;
exports.NaviErrorTypes = NaviErrorTypes;
exports.RegionLocales = RegionLocales;
exports.createStore = createStore;
exports.findMenuItemById = findMenuItemById;
exports.getEnvironment = getEnvironment;
exports.getErrorMessage = getErrorMessage;
exports.isCountryInOneOfRegions = isCountryInOneOfRegions;
exports.navContentStore = navContentStore;
exports.navStateStore = navStateStore;
exports.splitLocale = splitLocale;

//# sourceMappingURL=nav-content-store-ed0e79aa.js.map