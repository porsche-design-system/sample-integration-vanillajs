{"version":3,"names":["DrawerContent","_c","routingKey","previousRoutingKey","breakpoint","locale","showBackButton","receivedContent","menu","navContentStore","state","backButtonText","getBackButtonText","text","h","Fragment","class","backButtonAnalyticsId","id","activeRoutingKey","singleDrawerCss","SingleDrawer","exports","this","focusTimeout","Timeout","operationPipeline","class_1","prototype","handleKeyDown","e","key","targetElement","getHTMLElement","target","focusableDrawerElements","getAllFocusableElements","el","querySelector","length","routingKeyHistory","routingKeyPointer","startsWith","RoutingKeys","DEALER_SEARCH","filter","element","nodeName","firstFocusableDrawerElement","lastFocusableDrawerElement","shiftKey","preventDefault","focusOnElement","handleMobileMenuItemClick","isPlayingSingleDrawerAnimation","stopPropagation","animatingPointer","handleClickDrawerHeaderClose","handleClickDrawerHeaderBack","onTransitionEnd","_this","focussedElementId","isNavigatingBackwards","drawerChanged","emit","set","__awaiter","focusOnActiveDrawer","sendDataLayerEvent","componentWillLoad","registerOpenSingleDrawerAnimation","onAnimationStarts","phnDrawerStatus","status","DrawerStatusValues","startOpening","onAnimationEnds","finishOpening","registerCloseSingleDrawerAnimation","startClosing","backdropClosed","finishClosing","registerTransitionNextLevelSingleDrawerAnimation","registerTransitionPreviousLevelSingleDrawerAnimation","autoFocusElement","usingKeyboard","focussableElement","isString","concat","FOCUSABLE_ELEMENTS_SELECTOR","firstFocus","analyticsManager","setDrawerType","DisplayElementTypes","globalDataLayerService","pushDataLayerEvent","EventActions","DRAWER_LOAD","componentDisplay","displayElementType","calculateDisplayElementType","ElementTypes","singleDrawer","displayElementId","calculateDisplayElementId","displayElementName","disconnectedCallback","cancel","componentDidRender","promises","_i","operation","maybePromise","isPromise","push","Promise","all","_d","sent","splice","render","isAnimatingForward","isAnimatingBackward","topDrawerContentPointer","bottomDrawerContentPointer","RoutingKeyPointers","LEVEL_ZERO","animationManager","play","AnimationSequences","TRANSITION_NEXT_LEVEL_SINGLE_DRAWER","TRANSITION_PREVIOUS_LEVEL_SINGLE_DRAWER","animatingRoutingKey","_a","_b","Host","tabIndex","style","left"],"sources":["src/components/single-drawer/drawer-content.tsx","src/components/single-drawer/single-drawer.scss?tag=phn-single-drawer&encapsulation=scoped","src/components/single-drawer/single-drawer.tsx"],"sourcesContent":["import { Fragment, h, JSX } from '@stencil/core';\nimport { getBackButtonText } from '../../services/menu-items-service';\nimport { navContentStore } from '../../state/nav-content-store';\n\nexport default function DrawerContent({\n  routingKey,\n  previousRoutingKey,\n  breakpoint,\n  locale,\n  showBackButton,\n  receivedContent\n}: {\n  routingKey: string;\n  previousRoutingKey: string;\n  breakpoint: number;\n  locale: string;\n  showBackButton: boolean;\n  receivedContent: boolean;\n}): JSX.Element {\n  const { menu } = navContentStore.state;\n  const backButtonText = getBackButtonText(navContentStore.state, previousRoutingKey ?? '') || menu.text;\n\n  return (\n    <Fragment>\n      <div class=\"bottom-gradient\"></div>\n      <div class=\"drawer-content\">\n        <phn-drawer-header\n          showBackButton={showBackButton}\n          backButtonAnalyticsId={menu.id}\n          backButtonText={backButtonText}\n          activeRoutingKey={routingKey}\n          breakpoint={breakpoint}\n          receivedContent={receivedContent}\n          locale={locale}\n        />\n        <phn-router\n          activeRoutingKey={routingKey}\n          breakpoint={breakpoint}\n          locale={locale}\n          receivedContent={receivedContent}\n        />\n      </div>\n    </Fragment>\n  );\n}\n","@import '../../scss';\n\n:host {\n  display: block;\n  position: fixed;\n  top: 0;\n  left: -1000px;\n  height: 100vh;\n  width: 100vw;\n  z-index: $phn-z-index-mega-flyout + 1;\n\n  &.slide-in-from-left {\n    position: absolute;\n    animation: slide-in-from-left-absolute 600ms;\n  }\n\n  &.slide-out-to-left {\n    position: absolute;\n    animation: slide-in-from-left-absolute 600ms reverse;\n  }\n\n  .drawer {\n    z-index: $phn-z-index-mega-flyout + 1;\n    background-color: $pds-theme-light-background-base;\n    position: absolute;\n    left: 0;\n\n    .drawer-content {\n      overflow-y: auto;\n      height: 100vh;\n      width: 100vw;\n      box-sizing: border-box;\n      padding: 0 p-px-to-rem(27px) p-px-to-rem(100px) p-px-to-rem(27px);\n\n      @include pds-media-query-min('xs') {\n        padding: 0 p-px-to-rem(35px) p-px-to-rem(100px) p-px-to-rem(35px);\n      }\n\n      @include pds-media-query-min('s') {\n        padding: 0 p-px-to-rem(54px) p-px-to-rem(100px) p-px-to-rem(54px);\n      }\n\n      @include pds-media-query-min('m') {\n        padding: 0 p-px-to-rem(36px) p-px-to-rem(100px) p-px-to-rem(36px);\n      }\n\n      phn-drawer-header {\n        box-sizing: border-box;\n        margin-top: p-px-to-rem(18px);\n        margin-bottom: p-px-to-rem(31px);\n\n        @include pds-media-query-min('xs') {\n          margin-top: p-px-to-rem(32px);\n          margin-bottom: p-px-to-rem(37px);\n        }\n\n        @include pds-media-query-min('s') {\n          margin-bottom: p-px-to-rem(20px);\n        }\n      }\n\n      phn-router {\n        padding-bottom: 4rem;\n      }\n    }\n\n    .bottom-gradient{\n      @include drawer-gradient(rgba(255, 255, 255, 0), rgba(255, 255, 255));\n      margin-left: 0;\n      z-index: 1;\n    }\n  }\n\n}\n","import { Component, Element, Event, EventEmitter, h, Host, Listen, Prop, State } from '@stencil/core';\nimport { RoutingKeyPointers, RoutingKeys } from '../../entities/routing-key';\nimport animationManager from '../../services/animations/animation-manager';\nimport globalDataLayerService from '../../services/analytics/global-data-layer-service';\nimport {\n  AnimationSequences,\n  DisplayElementTypes,\n  ElementTypes,\n  EventActions,\n  FOCUSABLE_ELEMENTS_SELECTOR\n} from '../../utility/constants';\nimport { focusOnElement, getHTMLElement, isPromise, isString } from '../../utility/helper';\nimport { Timeout } from '../../utility/timeout';\nimport DrawerContent from './drawer-content';\nimport {\n  isPlayingSingleDrawerAnimation,\n  registerCloseSingleDrawerAnimation,\n  registerOpenSingleDrawerAnimation,\n  registerTransitionNextLevelSingleDrawerAnimation,\n  registerTransitionPreviousLevelSingleDrawerAnimation\n} from './single-drawer-animation-sequences';\nimport analyticsManager from '../../services/analytics/analytics-manager';\nimport { DrawerStatusTypes, DrawerStatusValues } from '../../utility/constants/app';\nimport { getAllFocusableElements } from '../double-drawer/helper';\n\n// INFO: For routing explanation, see README in this directory\n\n@Component({\n  tag: 'phn-single-drawer',\n  scoped: true,\n  styleUrl: 'single-drawer.scss'\n})\nexport class SingleDrawer {\n  @Prop() breakpoint!: number;\n  @Prop() locale!: string;\n  @Prop() usingKeyboard = false;\n  @Prop() routingKeyHistory!: string[];\n  @Prop() routingKeyPointer!: number;\n  @Prop() receivedContent = false;\n\n  @State() animatingPointer = -1;\n\n  @Event() drawerClosed!: EventEmitter<void>;\n  @Event() drawerChanged!: EventEmitter<boolean>;\n  @Event() drawerStartsClosing!: EventEmitter<void>;\n  @Event() backdropClosed!: EventEmitter<void>;\n  @Event({ composed: true, bubbles: true }) phnDrawerStatus!: EventEmitter<{\n    status: DrawerStatusTypes;\n  }>;\n\n  @Element() el!: HTMLPhnSingleDrawerElement;\n\n  private focusTimeout = new Timeout(0);\n  private operationPipeline: ((() => Promise<void>) | (() => void))[] = [];\n\n  @Listen('keydown', { passive: false })\n  handleKeyDown(e: KeyboardEvent): void {\n    if (e.key !== 'Tab') {\n      return;\n    }\n\n    const targetElement = getHTMLElement(e.target);\n    if (targetElement === null) {\n      return;\n    }\n\n    let focusableDrawerElements = getAllFocusableElements(this.el.querySelector('.active'));\n    if (focusableDrawerElements.length === 0) {\n      return;\n    }\n\n    const activeRoutingKey = this.routingKeyHistory[this.routingKeyPointer];\n    if (activeRoutingKey.startsWith(RoutingKeys.DEALER_SEARCH)) {\n      focusableDrawerElements = focusableDrawerElements.filter(\n        (element) => element.nodeName !== 'BUTTON' && element.nodeName !== 'A'\n      );\n    }\n\n    const firstFocusableDrawerElement = focusableDrawerElements[0];\n    const lastFocusableDrawerElement = focusableDrawerElements[focusableDrawerElements.length - 1];\n\n    if (targetElement === firstFocusableDrawerElement && e.shiftKey) {\n      e.preventDefault();\n\n      if (lastFocusableDrawerElement !== null) {\n        focusOnElement(lastFocusableDrawerElement);\n      }\n\n      return;\n    }\n\n    if (targetElement === lastFocusableDrawerElement && !e.shiftKey) {\n      e.preventDefault();\n\n      if (firstFocusableDrawerElement !== null) {\n        focusOnElement(firstFocusableDrawerElement);\n      }\n\n      return;\n    }\n  }\n\n  @Listen('mobileMenuItemClick')\n  handleMobileMenuItemClick(e: MouseEvent): void {\n    if (isPlayingSingleDrawerAnimation()) {\n      e.stopPropagation();\n      return;\n    }\n    this.animatingPointer = this.routingKeyPointer;\n  }\n\n  @Listen('clickDrawerHeaderClose')\n  handleClickDrawerHeaderClose(e: MouseEvent): void {\n    if (isPlayingSingleDrawerAnimation()) {\n      e.stopPropagation();\n      return;\n    }\n  }\n\n  @Listen('clickDrawerHeaderBack')\n  handleClickDrawerHeaderBack(e: MouseEvent): void {\n    if (isPlayingSingleDrawerAnimation()) {\n      e.stopPropagation();\n      return;\n    }\n    this.animatingPointer = this.routingKeyPointer;\n  }\n\n  private onTransitionEnd() {\n    const focussedElementId =\n      this.animatingPointer > this.routingKeyPointer ? this.routingKeyHistory[this.animatingPointer] : '';\n\n    this.animatingPointer = this.routingKeyPointer;\n\n    const isNavigatingBackwards = this.routingKeyPointer < this.routingKeyHistory.length - 1;\n    this.drawerChanged.emit(isNavigatingBackwards);\n\n    // Focus needs to happen after rerender, so wait for next tick\n    this.focusTimeout.set(async () => {\n      this.focusOnActiveDrawer(focussedElementId);\n    });\n    this.sendDataLayerEvent();\n  }\n\n  componentWillLoad(): void {\n    registerOpenSingleDrawerAnimation({\n      onAnimationStarts: () => {\n        this.phnDrawerStatus.emit({ status: DrawerStatusValues.startOpening });\n      },\n      onAnimationEnds: () => {\n        this.onTransitionEnd();\n        this.phnDrawerStatus.emit({ status: DrawerStatusValues.finishOpening });\n      }\n    });\n    registerCloseSingleDrawerAnimation({\n      onAnimationStarts: () => {\n        this.phnDrawerStatus.emit({ status: DrawerStatusValues.startClosing });\n      },\n      onAnimationEnds: () => {\n        this.backdropClosed.emit();\n        this.phnDrawerStatus.emit({ status: DrawerStatusValues.finishClosing });\n      }\n    });\n    registerTransitionNextLevelSingleDrawerAnimation({\n      onAnimationEnds: () => this.onTransitionEnd()\n    });\n    registerTransitionPreviousLevelSingleDrawerAnimation({ onAnimationEnds: () => this.onTransitionEnd() });\n  }\n\n  private focusOnActiveDrawer(focussedElementId: string): void {\n    const autoFocusElement = getHTMLElement(this.el.querySelector('.active .autofocus'));\n    if (autoFocusElement !== null) {\n      focusOnElement(autoFocusElement);\n      return;\n    }\n\n    if (this.usingKeyboard) {\n      let focussableElement: HTMLElement | null = null;\n\n      if (isString(focussedElementId)) {\n        focussableElement = getHTMLElement(this.el.querySelector(`.active [data-id=\"${focussedElementId}\"]`));\n      }\n\n      if (focussableElement === null) {\n        focussableElement = getHTMLElement(this.el.querySelector(`.active ${FOCUSABLE_ELEMENTS_SELECTOR}`));\n      }\n\n      if (focussableElement !== null) {\n        focusOnElement(focussableElement);\n      }\n    } else {\n      //Todo: Why first-focus class? We have it nowhere\n      const firstFocus = getHTMLElement(this.el.querySelector('.first-focus'));\n\n      if (firstFocus !== null) {\n        focusOnElement(firstFocus);\n      }\n    }\n  }\n\n  private sendDataLayerEvent() {\n    analyticsManager.setDrawerType(DisplayElementTypes.SingleDrawer);\n    const activeRoutingKey = this.routingKeyHistory[this.routingKeyPointer];\n\n    globalDataLayerService.pushDataLayerEvent(EventActions.DRAWER_LOAD, {\n      componentDisplay: {\n        displayElementType: analyticsManager.calculateDisplayElementType(activeRoutingKey, ElementTypes.singleDrawer),\n        displayElementId: analyticsManager.calculateDisplayElementId(),\n        displayElementName: 'Single Drawer'\n      }\n    });\n  }\n\n  disconnectedCallback(): void {\n    this.focusTimeout.cancel();\n  }\n\n  async componentDidRender(): Promise<void> {\n    const promises = [];\n    for (const operation of this.operationPipeline) {\n      const maybePromise = operation();\n      if (isPromise<void>(maybePromise)) {\n        promises.push(maybePromise);\n      }\n    }\n\n    await Promise.all(promises);\n    this.operationPipeline.splice(0, this.operationPipeline.length);\n  }\n\n  render(): HTMLPhnSingleDrawerElement {\n    const isAnimatingForward = this.routingKeyPointer > this.animatingPointer;\n    const isAnimatingBackward = this.routingKeyPointer < this.animatingPointer;\n\n    let topDrawerContentPointer = -1;\n    let bottomDrawerContentPointer = this.routingKeyPointer;\n\n    if (isAnimatingForward && this.animatingPointer !== RoutingKeyPointers.LEVEL_ZERO) {\n      topDrawerContentPointer = this.routingKeyPointer;\n      bottomDrawerContentPointer = this.animatingPointer;\n\n      this.operationPipeline.push(async () => {\n        animationManager.play(AnimationSequences.TRANSITION_NEXT_LEVEL_SINGLE_DRAWER);\n      });\n    } else if (isAnimatingBackward) {\n      topDrawerContentPointer = this.animatingPointer;\n\n      if (bottomDrawerContentPointer !== RoutingKeyPointers.LEVEL_ZERO) {\n        this.operationPipeline.push(async () => {\n          animationManager.play(AnimationSequences.TRANSITION_PREVIOUS_LEVEL_SINGLE_DRAWER);\n        });\n      }\n    }\n\n    const animatingRoutingKey = this.routingKeyHistory[topDrawerContentPointer] ?? '';\n    const routingKey = this.routingKeyHistory[bottomDrawerContentPointer] ?? '';\n\n    return (\n      <Host>\n        {isString(routingKey) ? (\n          <div class=\"drawer active\" key={routingKey}>\n            <span class=\"first-focus\" tabIndex={-1} aria-hidden=\"true\" />\n\n            <DrawerContent\n              routingKey={routingKey}\n              previousRoutingKey={this.routingKeyHistory[bottomDrawerContentPointer - 1]}\n              breakpoint={this.breakpoint}\n              locale={this.locale}\n              showBackButton={bottomDrawerContentPointer > 0}\n              receivedContent={this.receivedContent}\n            />\n          </div>\n        ) : null}\n\n        {isString(animatingRoutingKey) ? (\n          <div class={`drawer animating`} style={isAnimatingForward ? { left: '100%' } : {}} key={animatingRoutingKey}>\n            <DrawerContent\n              routingKey={animatingRoutingKey}\n              previousRoutingKey={this.routingKeyHistory[topDrawerContentPointer - 1]}\n              breakpoint={this.breakpoint}\n              locale={this.locale}\n              showBackButton={topDrawerContentPointer > 0}\n              receivedContent={this.receivedContent}\n            />\n          </div>\n        ) : null}\n      </Host>\n    );\n  }\n}\n"],"mappings":"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"}