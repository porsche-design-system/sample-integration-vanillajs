{"version":3,"names":["animationRegistry","sequences","animationTimeoutDurationMs","initialize","getRootElement","addEventListener","animationEndListener","register","sequenceIdentifier","animationSequence","reset","Object","keys","forEach","key","async","play","sequence","undefined","Promise","_","reject","Error","running","promise","resolve","value","applyCurrentAnimationSequenceStep","currentStepIndex","steps","length","finishAnimationSequence","sequenceStep","promises","animation","push","executeAnimation","all","error","_a","call","setTimeout","event","target","getHTMLElement","type","id","dataset","phnAmId","finishAnimationPromise","onStart","onEnd","elementSelector","maybePromise","isPromise","animatedElements","Array","from","querySelectorAll","animationExecutors","element","animationPromiseEffect","generateAndCleanUpAnimationPromise","animationPromiseGenerator","cleanUpBeforeAnimation","cleanUpAfterAnimation","animationPromise","classList","remove","className","Math","floor","random","add","toString","timeout","_resolve","_reject","console","warn","String","clearTimeout","isPlaying","makeSequence","sequenceSteps","animationDefaults","map","step","assign","animationManager"],"sources":["src/services/animations/animation-manager.ts"],"sourcesContent":["import { AnimationSequencesType } from '../../utility/constants';\nimport { getHTMLElement, getRootElement, isPromise } from '../../utility/helper';\n\nexport type AnimationStartsCallbacks = {\n  onAnimationStarts?: (() => Promise<unknown>) | (() => void);\n};\n\nexport type AnimationEndsCallbacks = {\n  onAnimationEnds?: (() => Promise<unknown>) | (() => void);\n};\n\nexport type AnimationStatusCallbacks = AnimationStartsCallbacks & AnimationEndsCallbacks;\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport type SequenceIdentifier = AnimationSequencesType | (string & {});\n\nexport interface NaviAnimation {\n  animation: AnimationGeneratorType;\n  elementSelector: string;\n  onStart?: (() => Promise<unknown>) | (() => unknown);\n  onEnd?: (() => Promise<unknown>) | (() => unknown);\n}\n\nexport type SequenceStep = Array<NaviAnimation>;\n\nexport type AnimationSequence = {\n  steps: Array<SequenceStep>;\n  currentStepIndex: number;\n  running: boolean;\n  resolve?: (value: unknown) => void;\n  reject?: (reason?: unknown) => void;\n  promise?: Promise<void>;\n};\n\nexport type AnimationGeneratorType = {\n  className: string;\n  cleanUpBeforeAnimation?: ((el: HTMLElement) => Promise<void>) | ((el: HTMLElement) => void) | boolean;\n  cleanUpAfterAnimation?: ((el: HTMLElement) => Promise<void>) | ((el: HTMLElement) => void) | boolean;\n};\n\nconst animationRegistry: Record<\n  string,\n  {\n    promise: Promise<void>;\n    resolve: (value: void) => void;\n    reject: (reason?: unknown) => void;\n    animation: AnimationGeneratorType;\n    timeout: NodeJS.Timeout;\n  }\n> = {};\n\nconst sequences: {\n  [key in SequenceIdentifier]?: AnimationSequence | undefined;\n} = {};\n\nconst animationTimeoutDurationMs = 1000;\n\nfunction initialize(): void {\n  getRootElement().addEventListener('transitionend', animationEndListener);\n  getRootElement().addEventListener('animationend', animationEndListener);\n}\n\nfunction register(sequenceIdentifier: SequenceIdentifier, animationSequence: AnimationSequence): void {\n  sequences[sequenceIdentifier] = animationSequence;\n}\n\nfunction reset(): void {\n  Object.keys(sequences).forEach((key) => delete sequences[key]);\n}\n\nasync function play(sequenceIdentifier: SequenceIdentifier): Promise<unknown> {\n  const sequence = sequences[sequenceIdentifier];\n\n  if (sequence === undefined) {\n    return new Promise((_, reject) => reject(new Error(`Sequence ${sequenceIdentifier} has not been registered`)));\n  }\n\n  if (!sequence.running) {\n    sequence.promise = new Promise<void>((resolve, reject) => {\n      sequence.resolve = () => {\n        sequence.running = false;\n        resolve();\n      };\n\n      sequence.reject = (value: unknown) => {\n        sequence.running = false;\n        reject(value);\n      };\n\n      sequence.running = true;\n\n      applyCurrentAnimationSequenceStep(sequence);\n    });\n  }\n\n  return sequence.promise;\n}\n\nasync function applyCurrentAnimationSequenceStep(sequence: AnimationSequence) {\n  if (sequence.currentStepIndex >= sequence.steps.length) {\n    finishAnimationSequence(sequence);\n    return;\n  }\n\n  const sequenceStep = sequence.steps[sequence.currentStepIndex];\n\n  const promises = [];\n  for (const animation of sequenceStep) {\n    promises.push(executeAnimation(animation));\n  }\n\n  try {\n    await Promise.all(promises);\n  } catch (error) {\n    sequence.reject?.(error);\n    return;\n  }\n\n  sequence.currentStepIndex += 1;\n\n  setTimeout(() => applyCurrentAnimationSequenceStep(sequence), 0);\n}\n\nfunction finishAnimationSequence(sequence: AnimationSequence) {\n  sequence.currentStepIndex = 0;\n  sequence.resolve?.(null);\n  sequence.promise = undefined;\n}\n\nfunction animationEndListener(event: AnimationEvent | TransitionEvent): void {\n  const target = getHTMLElement(event.target);\n\n  if (target === null) {\n    throw new Error(`${event.type} event target is null`);\n  }\n\n  const id = target.dataset.phnAmId;\n\n  if (id !== undefined && id !== null) {\n    finishAnimationPromise(id, target);\n  }\n}\n\nasync function executeAnimation({ onStart, onEnd, animation, elementSelector }: NaviAnimation): Promise<void> {\n  if (onStart) {\n    const maybePromise = onStart();\n    if (isPromise<void>(maybePromise)) {\n      await maybePromise;\n    }\n  }\n\n  const animatedElements: HTMLElement[] = Array.from(getRootElement().querySelectorAll(elementSelector));\n  const animationExecutors = [];\n\n  for (const element of animatedElements) {\n    const animationPromiseEffect = generateAndCleanUpAnimationPromise(animationPromiseGenerator)(element, animation);\n    animationExecutors.push(animationPromiseEffect);\n  }\n\n  await Promise.all(animationExecutors);\n  if (onEnd) {\n    const maybePromise = onEnd();\n    if (isPromise<void>(maybePromise)) {\n      await maybePromise;\n    }\n  }\n}\n\nfunction generateAndCleanUpAnimationPromise(\n  animationPromiseGenerator: (element: HTMLElement, animation: AnimationGeneratorType) => Promise<void>\n): (element: HTMLElement, animation: AnimationGeneratorType) => Promise<void> {\n  return async function (element: HTMLElement, animation: AnimationGeneratorType): Promise<void> {\n    const { cleanUpBeforeAnimation, cleanUpAfterAnimation } = animation;\n\n    const animationPromise = animationPromiseGenerator(element, animation);\n\n    if (typeof cleanUpBeforeAnimation === 'function') {\n      const maybePromise: void | Promise<void> = cleanUpBeforeAnimation(element);\n      if (isPromise<void>(maybePromise)) {\n        await maybePromise;\n      }\n    }\n\n    await animationPromise;\n\n    if (typeof cleanUpAfterAnimation === 'function') {\n      const maybePromise: void | Promise<void> = cleanUpAfterAnimation(element);\n      if (isPromise<void>(maybePromise)) {\n        await maybePromise;\n      }\n    }\n\n    if (cleanUpAfterAnimation !== false) {\n      // only not remove class if cleanUpAfterAnimation is explicitely set to false\n      element.classList.remove(animation.className);\n    }\n  };\n}\n\nconst animationPromiseGenerator = (element: HTMLElement, animation: AnimationGeneratorType): Promise<void> => {\n  const id = Math.floor(Math.random() * 1e7);\n\n  element.classList.add(animation.className);\n  element.dataset.phnAmId = id.toString();\n\n  let resolve!: (value: void) => void;\n  let reject!: (reason?: unknown) => void;\n  let timeout!: NodeJS.Timeout;\n  const promise = new Promise<void>((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n\n    timeout = setTimeout(() => {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `Animation with className ${animation.className} didn't finish after ${animationTimeoutDurationMs}ms. Forcefully finishing animation and continuing with the rest of the sequence.`\n      );\n      finishAnimationPromise(String(id), element);\n    }, animationTimeoutDurationMs);\n  });\n\n  animationRegistry[id] = { animation, resolve, reject, promise, timeout };\n\n  return promise;\n};\n\nfunction finishAnimationPromise(phnAmId: string, target: HTMLElement): void {\n  const { resolve, timeout } = animationRegistry[phnAmId];\n\n  clearTimeout(timeout);\n  delete animationRegistry[phnAmId];\n  delete target.dataset.phnAmId;\n\n  resolve();\n}\n\nfunction isPlaying(sequenceIdentifier: SequenceIdentifier): boolean {\n  const sequence = sequences[sequenceIdentifier];\n\n  if (sequence === undefined) {\n    throw new Error(`Sequence ${sequenceIdentifier} has not been registered`);\n  }\n\n  return sequence.promise !== undefined;\n}\n\nfunction makeSequence(\n  sequenceSteps: SequenceStep[],\n  animationDefaults?: Partial<Omit<AnimationGeneratorType, 'name'>>\n): AnimationSequence {\n  return {\n    steps: sequenceSteps.map((step) => step.map((animation) => ({ ...animationDefaults, ...animation }))),\n    currentStepIndex: 0,\n    running: false\n  };\n}\n\nexport default {\n  initialize,\n  play,\n  isPlaying,\n  register,\n  reset\n};\n\nexport { makeSequence };\n"],"mappings":"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"}