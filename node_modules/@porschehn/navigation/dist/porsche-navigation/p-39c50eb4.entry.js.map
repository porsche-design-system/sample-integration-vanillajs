{"version":3,"names":["DrawerContent","routingKey","previousRoutingKey","breakpoint","locale","showBackButton","receivedContent","menu","navContentStore","state","backButtonText","getBackButtonText","text","h","Fragment","class","backButtonAnalyticsId","id","activeRoutingKey","singleDrawerCss","SingleDrawer","this","focusTimeout","Timeout","operationPipeline","handleKeyDown","e","key","targetElement","getHTMLElement","target","focusableDrawerElements","getAllFocusableElements","el","querySelector","length","routingKeyHistory","routingKeyPointer","startsWith","RoutingKeys","DEALER_SEARCH","filter","element","nodeName","firstFocusableDrawerElement","lastFocusableDrawerElement","shiftKey","preventDefault","focusOnElement","handleMobileMenuItemClick","isPlayingSingleDrawerAnimation","stopPropagation","animatingPointer","handleClickDrawerHeaderClose","handleClickDrawerHeaderBack","onTransitionEnd","focussedElementId","isNavigatingBackwards","drawerChanged","emit","set","async","focusOnActiveDrawer","sendDataLayerEvent","componentWillLoad","registerOpenSingleDrawerAnimation","onAnimationStarts","phnDrawerStatus","status","DrawerStatusValues","startOpening","onAnimationEnds","finishOpening","registerCloseSingleDrawerAnimation","startClosing","backdropClosed","finishClosing","registerTransitionNextLevelSingleDrawerAnimation","registerTransitionPreviousLevelSingleDrawerAnimation","autoFocusElement","usingKeyboard","focussableElement","isString","FOCUSABLE_ELEMENTS_SELECTOR","firstFocus","analyticsManager","setDrawerType","DisplayElementTypes","globalDataLayerService","pushDataLayerEvent","EventActions","DRAWER_LOAD","componentDisplay","displayElementType","calculateDisplayElementType","ElementTypes","singleDrawer","displayElementId","calculateDisplayElementId","displayElementName","disconnectedCallback","cancel","componentDidRender","promises","operation","maybePromise","isPromise","push","Promise","all","splice","render","isAnimatingForward","isAnimatingBackward","topDrawerContentPointer","bottomDrawerContentPointer","RoutingKeyPointers","LEVEL_ZERO","animationManager","play","AnimationSequences","TRANSITION_NEXT_LEVEL_SINGLE_DRAWER","TRANSITION_PREVIOUS_LEVEL_SINGLE_DRAWER","animatingRoutingKey","_a","_b","Host","tabIndex","style","left"],"sources":["src/components/single-drawer/drawer-content.tsx","src/components/single-drawer/single-drawer.scss?tag=phn-single-drawer&encapsulation=scoped","src/components/single-drawer/single-drawer.tsx"],"sourcesContent":["import { Fragment, h, JSX } from '@stencil/core';\nimport { getBackButtonText } from '../../services/menu-items-service';\nimport { navContentStore } from '../../state/nav-content-store';\n\nexport default function DrawerContent({\n  routingKey,\n  previousRoutingKey,\n  breakpoint,\n  locale,\n  showBackButton,\n  receivedContent\n}: {\n  routingKey: string;\n  previousRoutingKey: string;\n  breakpoint: number;\n  locale: string;\n  showBackButton: boolean;\n  receivedContent: boolean;\n}): JSX.Element {\n  const { menu } = navContentStore.state;\n  const backButtonText = getBackButtonText(navContentStore.state, previousRoutingKey ?? '') || menu.text;\n\n  return (\n    <Fragment>\n      <div class=\"bottom-gradient\"></div>\n      <div class=\"drawer-content\">\n        <phn-drawer-header\n          showBackButton={showBackButton}\n          backButtonAnalyticsId={menu.id}\n          backButtonText={backButtonText}\n          activeRoutingKey={routingKey}\n          breakpoint={breakpoint}\n          receivedContent={receivedContent}\n          locale={locale}\n        />\n        <phn-router\n          activeRoutingKey={routingKey}\n          breakpoint={breakpoint}\n          locale={locale}\n          receivedContent={receivedContent}\n        />\n      </div>\n    </Fragment>\n  );\n}\n","@import '../../scss';\n\n:host {\n  display: block;\n  position: fixed;\n  top: 0;\n  left: -1000px;\n  height: 100vh;\n  width: 100vw;\n  z-index: $phn-z-index-mega-flyout + 1;\n\n  &.slide-in-from-left {\n    position: absolute;\n    animation: slide-in-from-left-absolute 600ms;\n  }\n\n  &.slide-out-to-left {\n    position: absolute;\n    animation: slide-in-from-left-absolute 600ms reverse;\n  }\n\n  .drawer {\n    z-index: $phn-z-index-mega-flyout + 1;\n    background-color: $pds-theme-light-background-base;\n    position: absolute;\n    left: 0;\n\n    .drawer-content {\n      overflow-y: auto;\n      height: 100vh;\n      width: 100vw;\n      box-sizing: border-box;\n      padding: 0 p-px-to-rem(27px) p-px-to-rem(100px) p-px-to-rem(27px);\n\n      @include pds-media-query-min('xs') {\n        padding: 0 p-px-to-rem(35px) p-px-to-rem(100px) p-px-to-rem(35px);\n      }\n\n      @include pds-media-query-min('s') {\n        padding: 0 p-px-to-rem(54px) p-px-to-rem(100px) p-px-to-rem(54px);\n      }\n\n      @include pds-media-query-min('m') {\n        padding: 0 p-px-to-rem(36px) p-px-to-rem(100px) p-px-to-rem(36px);\n      }\n\n      phn-drawer-header {\n        box-sizing: border-box;\n        margin-top: p-px-to-rem(18px);\n        margin-bottom: p-px-to-rem(31px);\n\n        @include pds-media-query-min('xs') {\n          margin-top: p-px-to-rem(32px);\n          margin-bottom: p-px-to-rem(37px);\n        }\n\n        @include pds-media-query-min('s') {\n          margin-bottom: p-px-to-rem(20px);\n        }\n      }\n\n      phn-router {\n        padding-bottom: 4rem;\n      }\n    }\n\n    .bottom-gradient{\n      @include drawer-gradient(rgba(255, 255, 255, 0), rgba(255, 255, 255));\n      margin-left: 0;\n      z-index: 1;\n    }\n  }\n\n}\n","import { Component, Element, Event, EventEmitter, h, Host, Listen, Prop, State } from '@stencil/core';\nimport { RoutingKeyPointers, RoutingKeys } from '../../entities/routing-key';\nimport animationManager from '../../services/animations/animation-manager';\nimport globalDataLayerService from '../../services/analytics/global-data-layer-service';\nimport {\n  AnimationSequences,\n  DisplayElementTypes,\n  ElementTypes,\n  EventActions,\n  FOCUSABLE_ELEMENTS_SELECTOR\n} from '../../utility/constants';\nimport { focusOnElement, getHTMLElement, isPromise, isString } from '../../utility/helper';\nimport { Timeout } from '../../utility/timeout';\nimport DrawerContent from './drawer-content';\nimport {\n  isPlayingSingleDrawerAnimation,\n  registerCloseSingleDrawerAnimation,\n  registerOpenSingleDrawerAnimation,\n  registerTransitionNextLevelSingleDrawerAnimation,\n  registerTransitionPreviousLevelSingleDrawerAnimation\n} from './single-drawer-animation-sequences';\nimport analyticsManager from '../../services/analytics/analytics-manager';\nimport { DrawerStatusTypes, DrawerStatusValues } from '../../utility/constants/app';\nimport { getAllFocusableElements } from '../double-drawer/helper';\n\n// INFO: For routing explanation, see README in this directory\n\n@Component({\n  tag: 'phn-single-drawer',\n  scoped: true,\n  styleUrl: 'single-drawer.scss'\n})\nexport class SingleDrawer {\n  @Prop() breakpoint!: number;\n  @Prop() locale!: string;\n  @Prop() usingKeyboard = false;\n  @Prop() routingKeyHistory!: string[];\n  @Prop() routingKeyPointer!: number;\n  @Prop() receivedContent = false;\n\n  @State() animatingPointer = -1;\n\n  @Event() drawerClosed!: EventEmitter<void>;\n  @Event() drawerChanged!: EventEmitter<boolean>;\n  @Event() drawerStartsClosing!: EventEmitter<void>;\n  @Event() backdropClosed!: EventEmitter<void>;\n  @Event({ composed: true, bubbles: true }) phnDrawerStatus!: EventEmitter<{\n    status: DrawerStatusTypes;\n  }>;\n\n  @Element() el!: HTMLPhnSingleDrawerElement;\n\n  private focusTimeout = new Timeout(0);\n  private operationPipeline: ((() => Promise<void>) | (() => void))[] = [];\n\n  @Listen('keydown', { passive: false })\n  handleKeyDown(e: KeyboardEvent): void {\n    if (e.key !== 'Tab') {\n      return;\n    }\n\n    const targetElement = getHTMLElement(e.target);\n    if (targetElement === null) {\n      return;\n    }\n\n    let focusableDrawerElements = getAllFocusableElements(this.el.querySelector('.active'));\n    if (focusableDrawerElements.length === 0) {\n      return;\n    }\n\n    const activeRoutingKey = this.routingKeyHistory[this.routingKeyPointer];\n    if (activeRoutingKey.startsWith(RoutingKeys.DEALER_SEARCH)) {\n      focusableDrawerElements = focusableDrawerElements.filter(\n        (element) => element.nodeName !== 'BUTTON' && element.nodeName !== 'A'\n      );\n    }\n\n    const firstFocusableDrawerElement = focusableDrawerElements[0];\n    const lastFocusableDrawerElement = focusableDrawerElements[focusableDrawerElements.length - 1];\n\n    if (targetElement === firstFocusableDrawerElement && e.shiftKey) {\n      e.preventDefault();\n\n      if (lastFocusableDrawerElement !== null) {\n        focusOnElement(lastFocusableDrawerElement);\n      }\n\n      return;\n    }\n\n    if (targetElement === lastFocusableDrawerElement && !e.shiftKey) {\n      e.preventDefault();\n\n      if (firstFocusableDrawerElement !== null) {\n        focusOnElement(firstFocusableDrawerElement);\n      }\n\n      return;\n    }\n  }\n\n  @Listen('mobileMenuItemClick')\n  handleMobileMenuItemClick(e: MouseEvent): void {\n    if (isPlayingSingleDrawerAnimation()) {\n      e.stopPropagation();\n      return;\n    }\n    this.animatingPointer = this.routingKeyPointer;\n  }\n\n  @Listen('clickDrawerHeaderClose')\n  handleClickDrawerHeaderClose(e: MouseEvent): void {\n    if (isPlayingSingleDrawerAnimation()) {\n      e.stopPropagation();\n      return;\n    }\n  }\n\n  @Listen('clickDrawerHeaderBack')\n  handleClickDrawerHeaderBack(e: MouseEvent): void {\n    if (isPlayingSingleDrawerAnimation()) {\n      e.stopPropagation();\n      return;\n    }\n    this.animatingPointer = this.routingKeyPointer;\n  }\n\n  private onTransitionEnd() {\n    const focussedElementId =\n      this.animatingPointer > this.routingKeyPointer ? this.routingKeyHistory[this.animatingPointer] : '';\n\n    this.animatingPointer = this.routingKeyPointer;\n\n    const isNavigatingBackwards = this.routingKeyPointer < this.routingKeyHistory.length - 1;\n    this.drawerChanged.emit(isNavigatingBackwards);\n\n    // Focus needs to happen after rerender, so wait for next tick\n    this.focusTimeout.set(async () => {\n      this.focusOnActiveDrawer(focussedElementId);\n    });\n    this.sendDataLayerEvent();\n  }\n\n  componentWillLoad(): void {\n    registerOpenSingleDrawerAnimation({\n      onAnimationStarts: () => {\n        this.phnDrawerStatus.emit({ status: DrawerStatusValues.startOpening });\n      },\n      onAnimationEnds: () => {\n        this.onTransitionEnd();\n        this.phnDrawerStatus.emit({ status: DrawerStatusValues.finishOpening });\n      }\n    });\n    registerCloseSingleDrawerAnimation({\n      onAnimationStarts: () => {\n        this.phnDrawerStatus.emit({ status: DrawerStatusValues.startClosing });\n      },\n      onAnimationEnds: () => {\n        this.backdropClosed.emit();\n        this.phnDrawerStatus.emit({ status: DrawerStatusValues.finishClosing });\n      }\n    });\n    registerTransitionNextLevelSingleDrawerAnimation({\n      onAnimationEnds: () => this.onTransitionEnd()\n    });\n    registerTransitionPreviousLevelSingleDrawerAnimation({ onAnimationEnds: () => this.onTransitionEnd() });\n  }\n\n  private focusOnActiveDrawer(focussedElementId: string): void {\n    const autoFocusElement = getHTMLElement(this.el.querySelector('.active .autofocus'));\n    if (autoFocusElement !== null) {\n      focusOnElement(autoFocusElement);\n      return;\n    }\n\n    if (this.usingKeyboard) {\n      let focussableElement: HTMLElement | null = null;\n\n      if (isString(focussedElementId)) {\n        focussableElement = getHTMLElement(this.el.querySelector(`.active [data-id=\"${focussedElementId}\"]`));\n      }\n\n      if (focussableElement === null) {\n        focussableElement = getHTMLElement(this.el.querySelector(`.active ${FOCUSABLE_ELEMENTS_SELECTOR}`));\n      }\n\n      if (focussableElement !== null) {\n        focusOnElement(focussableElement);\n      }\n    } else {\n      //Todo: Why first-focus class? We have it nowhere\n      const firstFocus = getHTMLElement(this.el.querySelector('.first-focus'));\n\n      if (firstFocus !== null) {\n        focusOnElement(firstFocus);\n      }\n    }\n  }\n\n  private sendDataLayerEvent() {\n    analyticsManager.setDrawerType(DisplayElementTypes.SingleDrawer);\n    const activeRoutingKey = this.routingKeyHistory[this.routingKeyPointer];\n\n    globalDataLayerService.pushDataLayerEvent(EventActions.DRAWER_LOAD, {\n      componentDisplay: {\n        displayElementType: analyticsManager.calculateDisplayElementType(activeRoutingKey, ElementTypes.singleDrawer),\n        displayElementId: analyticsManager.calculateDisplayElementId(),\n        displayElementName: 'Single Drawer'\n      }\n    });\n  }\n\n  disconnectedCallback(): void {\n    this.focusTimeout.cancel();\n  }\n\n  async componentDidRender(): Promise<void> {\n    const promises = [];\n    for (const operation of this.operationPipeline) {\n      const maybePromise = operation();\n      if (isPromise<void>(maybePromise)) {\n        promises.push(maybePromise);\n      }\n    }\n\n    await Promise.all(promises);\n    this.operationPipeline.splice(0, this.operationPipeline.length);\n  }\n\n  render(): HTMLPhnSingleDrawerElement {\n    const isAnimatingForward = this.routingKeyPointer > this.animatingPointer;\n    const isAnimatingBackward = this.routingKeyPointer < this.animatingPointer;\n\n    let topDrawerContentPointer = -1;\n    let bottomDrawerContentPointer = this.routingKeyPointer;\n\n    if (isAnimatingForward && this.animatingPointer !== RoutingKeyPointers.LEVEL_ZERO) {\n      topDrawerContentPointer = this.routingKeyPointer;\n      bottomDrawerContentPointer = this.animatingPointer;\n\n      this.operationPipeline.push(async () => {\n        animationManager.play(AnimationSequences.TRANSITION_NEXT_LEVEL_SINGLE_DRAWER);\n      });\n    } else if (isAnimatingBackward) {\n      topDrawerContentPointer = this.animatingPointer;\n\n      if (bottomDrawerContentPointer !== RoutingKeyPointers.LEVEL_ZERO) {\n        this.operationPipeline.push(async () => {\n          animationManager.play(AnimationSequences.TRANSITION_PREVIOUS_LEVEL_SINGLE_DRAWER);\n        });\n      }\n    }\n\n    const animatingRoutingKey = this.routingKeyHistory[topDrawerContentPointer] ?? '';\n    const routingKey = this.routingKeyHistory[bottomDrawerContentPointer] ?? '';\n\n    return (\n      <Host>\n        {isString(routingKey) ? (\n          <div class=\"drawer active\" key={routingKey}>\n            <span class=\"first-focus\" tabIndex={-1} aria-hidden=\"true\" />\n\n            <DrawerContent\n              routingKey={routingKey}\n              previousRoutingKey={this.routingKeyHistory[bottomDrawerContentPointer - 1]}\n              breakpoint={this.breakpoint}\n              locale={this.locale}\n              showBackButton={bottomDrawerContentPointer > 0}\n              receivedContent={this.receivedContent}\n            />\n          </div>\n        ) : null}\n\n        {isString(animatingRoutingKey) ? (\n          <div class={`drawer animating`} style={isAnimatingForward ? { left: '100%' } : {}} key={animatingRoutingKey}>\n            <DrawerContent\n              routingKey={animatingRoutingKey}\n              previousRoutingKey={this.routingKeyHistory[topDrawerContentPointer - 1]}\n              breakpoint={this.breakpoint}\n              locale={this.locale}\n              showBackButton={topDrawerContentPointer > 0}\n              receivedContent={this.receivedContent}\n            />\n          </div>\n        ) : null}\n      </Host>\n    );\n  }\n}\n"],"mappings":"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"}