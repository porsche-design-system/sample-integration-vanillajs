import { r as routerStore } from './router-store-26b5bff5.js';
import { R as RoutingKeyPointers, f as findTopLevelRoutingKey, a as RoutingKeys, c as constructRoutingKey } from './routing-key-808e9d26.js';
import { l as isDesktop, E as dispatchEvent } from './helper-76937d0b.js';
import { w as windowService } from './feature-toggles-f5a05f06.js';
import { d as dealerSearchResultsStore } from './dealer-search-results-store-f00291b6.js';
import { a as animationManager } from './animation-manager-2e28abcf.js';
import { A as AnimationSequences } from './animations-8383aa25.js';

const handleAnimationRouting = () => {
  const actions = {
    OPENING: openingAction,
    CLOSING: closingAction,
    FORWARD: forwardAction,
    BACKWARDS: backwardAction,
    UNCHANGED: unchangedAction
  };
  const conditionToExecute = getSingleDrawerAction();
  return actions[conditionToExecute]();
};
function getSingleDrawerAction() {
  if (isOpening()) {
    return 'OPENING';
  }
  if (isClosing()) {
    return 'CLOSING';
  }
  if (isAnimatingForward()) {
    return 'FORWARD';
  }
  if (isAnimatingBackward()) {
    return 'BACKWARDS';
  }
  return 'UNCHANGED';
}
const openingAction = () => {
  animationManager.play(AnimationSequences.OPEN_SINGLE_DRAWER);
  return {
    nextRoute: '',
    currentRoute: getCurrentRoute()
  };
};
const closingAction = () => {
  animationManager.play(AnimationSequences.CLOSE_SINGLE_DRAWER).then(() => {
    // TODO: Focus on burger button if using the keyboard
  });
  return {
    nextRoute: getCurrentRoute() || '',
    currentRoute: getAnimatedRoute() || ''
  };
};
const forwardAction = () => {
  var _a, _b;
  setTimeout(() => {
    animationManager.play(AnimationSequences.TRANSITION_NEXT_LEVEL_SINGLE_DRAWER);
  });
  return {
    nextRoute: (_a = getCurrentRoute()) !== null && _a !== void 0 ? _a : '',
    currentRoute: (_b = getAnimatedRoute()) !== null && _b !== void 0 ? _b : ''
  };
};
const backwardAction = () => {
  var _a, _b;
  if (getCurrentRoute() !== '') {
    setTimeout(() => {
      animationManager.play(AnimationSequences.TRANSITION_PREVIOUS_LEVEL_SINGLE_DRAWER);
    });
  }
  return {
    nextRoute: (_a = getAnimatedRoute()) !== null && _a !== void 0 ? _a : '',
    currentRoute: (_b = getCurrentRoute()) !== null && _b !== void 0 ? _b : ''
  };
};
const unchangedAction = () => {
  return {
    nextRoute: '',
    currentRoute: getCurrentRoute()
  };
};
const isPlayingSingleDrawerAnimation = () => {
  try {
    const singleDrawerAnimationSequences = [
      AnimationSequences.OPEN_SINGLE_DRAWER,
      AnimationSequences.CLOSE_SINGLE_DRAWER,
      AnimationSequences.TRANSITION_NEXT_LEVEL_SINGLE_DRAWER,
      AnimationSequences.TRANSITION_PREVIOUS_LEVEL_SINGLE_DRAWER
    ];
    return singleDrawerAnimationSequences.some((sequence) => {
      try {
        return animationManager.isPlaying(sequence);
      }
      catch (_a) {
        return false;
      }
    });
  }
  catch (e) {
    return false;
  }
};

const getCurrentRoute = () => {
  const { routingKeyHistory, routingKeyPointer } = routerStore.state;
  return routingKeyHistory[routingKeyPointer] || '';
};
const getAnimatedRoute = () => {
  const { routingKeyHistory, animatingPointer } = routerStore.state;
  return routingKeyHistory[animatingPointer] || '';
};
const goTo = (...routes) => {
  const newHistory = [RoutingKeys.MAIN_MENU, ...routes];
  routerStore.state.routingKeyPointer = routes.length;
  routerStore.state.routingKeyHistory = newHistory;
};
const back = () => {
  if (!isPlayingSingleDrawerAnimation()) {
    if (findTopLevelRoutingKey(getCurrentRoute()) === RoutingKeys.DEALER_SEARCH) {
      dealerSearchResultsStore.state.savedDealerCookie = null;
    }
    routerStore.state.routingKeyPointer = routerStore.state.routingKeyPointer - 1;
  }
};
const pop = () => {
  if (isNavigatingBackwards())
    routerStore.state.routingKeyHistory.pop();
};
const addRoute = (newRoute) => {
  if (isDesktop(windowService.getBreakpoint())) {
    dispatchEvent('phn-router', 'mobileMenuItemClick', {
      bubbles: true,
      cancelable: false,
      detail: [constructRoutingKey(getCurrentRoute(), ...newRoute)]
    });
  }
  else {
    const newHistory = [...routerStore.state.routingKeyHistory, constructRoutingKey(getCurrentRoute(), ...newRoute)];
    routerStore.state.routingKeyPointer = newHistory.length - 1;
    routerStore.state.routingKeyHistory = newHistory;
  }
};
const reset = () => {
  routerStore.state.routingKeyPointer = -1;
};
const isNavigatingBackwards = () => {
  return routerStore.state.routingKeyPointer < routerStore.state.routingKeyHistory.length - 1;
};
//____________ANIMATIONS______________//
const isAnimatingForward = () => {
  return routerStore.state.routingKeyPointer > routerStore.state.animatingPointer;
};
const isAnimatingBackward = () => {
  return routerStore.state.routingKeyPointer < routerStore.state.animatingPointer;
};
const isOpening = () => {
  return (routerStore.state.animatingPointer === RoutingKeyPointers.LEVEL_ZERO && routerStore.state.routingKeyPointer >= 0);
};
const isOpened = () => {
  return !isClosed();
};
const isClosed = () => {
  return (routerStore.state.routingKeyPointer === RoutingKeyPointers.LEVEL_ZERO &&
    routerStore.state.animatingPointer === RoutingKeyPointers.LEVEL_ZERO);
};
const isClosing = () => {
  return routerStore.state.routingKeyPointer === -1 && routerStore.state.animatingPointer >= 0;
};
const syncAnimation = () => {
  routerStore.state.animatingPointer = routerStore.state.routingKeyPointer;
};
const showBackButton = (section) => {
  const sectionKey = routerStore.state.routingKeyHistory.indexOf(section);
  return sectionKey >= RoutingKeyPointers.LEVEL_TWO;
};

export { isClosed as a, isOpening as b, goTo as c, syncAnimation as d, isAnimatingForward as e, back as f, getCurrentRoute as g, handleAnimationRouting as h, isOpened as i, addRoute as j, pop as p, reset as r, showBackButton as s };

//# sourceMappingURL=routing-manager-2bba85b2.js.map