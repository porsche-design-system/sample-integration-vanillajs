import { t as isPromise } from './navi-error-d2e07707.js';
import { w as windowService } from './window-service-890948e7.js';

/* istanbul ignore file */
const shrinkElement = (el, progress, { to = 100 }) => {
  el.style.width = `${(1 - progress) * to}%`;
};
const growElement = (el, progress, { to = 100 }) => {
  el.style.width = `${progress * to}%`;
};
const slideOutToRightRelative = (el, progress, { from = 0, to = -100 }) => {
  el.style.right = `calc(${progress * to + from}%)`;
  el.style.position = 'relative';
};
const slideOutToLeftRelative = (el, progress, { from = 0, to = -100 }) => {
  el.style.left = `calc(${progress * to + from}%)`;
  el.style.position = 'relative';
};
const slideInFromLeftRelative = (el, progress, { from = -100, to = 0 }) => {
  el.style.left = `calc(${(1 - progress) * from + to}%)`;
  el.style.position = 'relative';
};
const slideInFromRightRelative = (el, progress, { from = -100, to = 0 }) => {
  el.style.right = `calc(${(1 - progress) * from + to}%)`;
  el.style.position = 'relative';
};
const slideInFromRight = (el, progress, { from = -100, to = 0 }) => {
  el.style.right = `${(1 - progress) * from + to}px`;
};
const slideInFromLeft = (el, progress, { from = -100, to = 0 }) => {
  el.style.left = `${(1 - progress) * from + to}px`;
};
const slideOutToRight = (el, progress, { from = 0, to = -100 }) => {
  el.style.right = `${progress * to + from}px`;
};
const slideOutToLeft = (el, progress, { from = 0, to = -100 }) => {
  el.style.left = `${progress * to + from}px`;
};
const slideInFromRightFixed = (el, progress, { from = -100, to = 0 }) => {
  el.style.right = `calc(${(1 - progress) * from + to}%)`;
  el.style.position = 'fixed';
};
const slideOutToRightFixed = (el, progress, { from = 0, to = -100 }) => {
  el.style.right = `calc(${progress * to + from}%)`;
  el.style.position = 'fixed';
};
const slideInFromLeftFixed = (el, progress, { from = -100, to = 0 }) => {
  el.style.left = `calc(${(1 - progress) * from + to}%)`;
  el.style.position = 'fixed';
};
const slideOutToLeftFixed = (el, progress, { from = 0, to = -100 }) => {
  el.style.left = `calc(${progress * to + from}%)`;
  el.style.position = 'fixed';
};
const fadeOut = (el, progress, { from = 1, to = 0 }) => {
  el.style.opacity = `${(1 - progress) * from + progress * to}`;
};
const fadeIn = (el, progress, { from = 0, to = 1 }) => {
  el.style.opacity = `${progress * to + (progress - 1) * from}`;
};
const fadeOutBackdrop = (el, progress, { from = 1, to = 0 }) => {
  el.style.backgroundColor = `rgba(0, 0, 0, ${(1 - progress) * from + progress * to})`;
  el.style.opacity = `${1 - progress + progress * to}`;
};
const fadeInBackdrop = (el, progress, { from = 0, to = 1 }) => {
  el.style.backgroundColor = `rgba(0, 0, 0, ${progress * to + (progress - 1) * from})`;
  el.style.opacity = `${progress + (progress - 1) * from}`;
};
const AnimationsAction = {
  slideOutToLeftRelative,
  slideInFromRightRelative,
  slideInFromLeftRelative,
  slideOutToRightRelative,
  shrinkElement,
  growElement,
  slideInFromRight,
  slideInFromLeft,
  slideOutToRight,
  slideOutToLeft,
  fadeOut,
  fadeIn,
  fadeInBackdrop,
  fadeOutBackdrop,
  slideInFromRightFixed,
  slideOutToRightFixed,
  slideInFromLeftFixed,
  slideOutToLeftFixed
};

var __rest = (undefined && undefined.__rest) || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
const resetStyle = (el) => {
  el.removeAttribute('style');
};
const getAnimationEffect = (effectName) => {
  return AnimationsAction[effectName];
};
/* istanbul ignore next */
const timingFunctions = {
  easeInOutSin: (timeFraction) => {
    return -(Math.cos(Math.PI * timeFraction) - 1) / 2;
  },
  easeInOutQuad: (timeFraction) => {
    if (timeFraction < 0.5) {
      return (2 * timeFraction) / 2;
    }
    else {
      return (2 - 2 * (1 - timeFraction)) / 2;
    }
  },
  linear: (timeFraction) => {
    return timeFraction < 0 || timeFraction > 1 ? Math.round(timeFraction) : timeFraction;
  },
  cubicBezierStart: (timeFraction) => {
    return cubicBezier(timeFraction, 0.1, 0.0, 0.0, 100);
  },
  cubicBezierEnd: (timeFraction) => {
    return cubicBezier(timeFraction, 0.3, 0.0, 1.0, 0.8);
  }
};
function animationPromiseGenerator(el, animation) {
  const { duration = 300, cleanUpAfterAnimation = false } = animation, effect = __rest(animation, ["duration", "cleanUpAfterAnimation"]);
  return new Promise((resolve) => {
    let animationFrame;
    const timeout = setTimeout(() => {
      cancelAnimationFrame(animationFrame);
      finishAnimation();
    }, duration + 50);
    function finishAnimation() {
      playEffect(el, 1, effect);
      clearTimeout(timeout);
      if (typeof cleanUpAfterAnimation === 'function') {
        const maybePromise = cleanUpAfterAnimation(el);
        if (isPromise(maybePromise)) {
          maybePromise.then(() => resolve());
          return;
        }
      }
      else if (cleanUpAfterAnimation === true) {
        resetStyle(el);
      }
      resolve();
    }
    const start = performance.now();
    const playEffect = getAnimationEffect(effect.name);
    function animate(time) {
      const timingFunction = timingFunctions[effect.timingFunction || 'linear'];
      let progress = timingFunction((time - start) / duration);
      progress = Math.round((progress + Number.EPSILON) * 1000) / 1000;
      const ANIMATION_HAS_FINISHED = progress >= 1;
      const ANIMATION_ON_PROGRESS = progress < 1;
      if (ANIMATION_HAS_FINISHED) {
        return finishAnimation();
      }
      playEffect(el, progress, effect);
      if (ANIMATION_ON_PROGRESS) {
        animationFrame = windowService.requestAnimationFrame(animate);
      }
    }
    animationFrame = windowService.requestAnimationFrame(animate);
  });
}
function cubicBezier(t, initial, p1, p2, final) {
  return ((1 - t) * (1 - t) * (1 - t) * initial +
    3 * (1 - t) * (1 - t) * t * p1 +
    3 * (1 - t) * t * t * p2 +
    t * t * t * final);
}

const sequences = {};
let rootElement = null;
function initialize(element) {
  rootElement = element;
}
function register(sequenceIdentifier, animationSequence) {
  sequences[sequenceIdentifier] = animationSequence;
}
function reset() {
  Object.keys(sequences).forEach((key) => delete sequences[key]);
}
async function play(sequenceIdentifier) {
  const sequence = sequences[sequenceIdentifier];
  if (sequence === undefined) {
    return new Promise((_, reject) => reject(new Error(`Sequence ${sequenceIdentifier} has not been registered`)));
  }
  if (!sequence.running) {
    sequence.promise = new Promise((resolve, reject) => {
      sequence.resolve = () => {
        sequence.running = false;
        resolve();
      };
      sequence.reject = (value) => {
        sequence.running = false;
        reject(value);
      };
      sequence.running = true;
      applyCurrentAnimationSequenceStep(sequence);
    });
  }
  return sequence.promise;
}
function finishAnimationSequence(sequence) {
  var _a;
  sequence.currentStepIndex = 0;
  (_a = sequence.resolve) === null || _a === void 0 ? void 0 : _a.call(sequence, null);
  sequence.promise = undefined;
}
async function applyCurrentAnimationSequenceStep(sequence) {
  var _a;
  if (sequence.currentStepIndex >= sequence.steps.length) {
    finishAnimationSequence(sequence);
    return;
  }
  const sequenceStep = sequence.steps[sequence.currentStepIndex];
  const promises = [];
  for (const animation of sequenceStep) {
    promises.push(executeAnimation(animation));
  }
  try {
    await Promise.all(promises);
  }
  catch (error) {
    (_a = sequence.reject) === null || _a === void 0 ? void 0 : _a.call(sequence, error);
    return;
  }
  sequence.currentStepIndex += 1;
  setTimeout(() => applyCurrentAnimationSequenceStep(sequence), 0);
}
async function executeAnimation({ onStart, onEnd, animation, elementSelector }) {
  if (rootElement === null) {
    throw new Error('No root element present');
  }
  if (onStart) {
    const maybePromise = onStart();
    if (isPromise(maybePromise)) {
      await maybePromise;
    }
  }
  const animatedElements = Array.from(rootElement.querySelectorAll(elementSelector));
  const animationExecutors = [];
  for (const element of animatedElements) {
    const animationPromiseEffect = animationPromiseGenerator(element, animation);
    animationExecutors.push(animationPromiseEffect);
  }
  await Promise.all(animationExecutors);
  if (onEnd) {
    const maybePromise = onEnd();
    if (isPromise(maybePromise)) {
      await maybePromise;
    }
  }
}
function isPlaying(sequenceIdentifier) {
  const sequence = sequences[sequenceIdentifier];
  if (sequence === undefined) {
    throw new Error(`Sequence ${sequenceIdentifier} has not been registered`);
  }
  return sequence.promise !== undefined;
}
function makeSequence(sequenceSteps, animationDefaults) {
  return {
    steps: sequenceSteps.map((step) => step.map((animation) => (Object.assign(Object.assign({}, animationDefaults), animation)))),
    currentStepIndex: 0,
    running: false
  };
}
const animationManager = {
  initialize,
  play,
  isPlaying,
  register,
  reset
};

export { animationManager as a, makeSequence as m };

//# sourceMappingURL=animation-manager-137f1cb8.js.map