/* istanbul ignore file */
import { breakpoint } from "@porsche-design-system/components-js/styles";
import { COOKIE_DOMAIN, MS_IN_MONTH } from "../utility/constants";
import { camelToKebapCase, getHTMLElement, getString, hasKey, isString, shallowCopySpecifiedAttributesWithDefault } from "../utility/helper";
import { NaviError, NaviErrorTypes } from "../utility/navi-error";
class WindowService {
  constructor() {
    this.initialBodyStyleValues = {
      top: '',
      position: '',
      inlineSize: '',
      overflowY: ''
    };
    this.initialDocumentScrollTop = 0;
  }
  get location() {
    return window.location;
  }
  set location(newLocation) {
    window.location = newLocation;
  }
  get sessionStorage() {
    return window.sessionStorage;
  }
  get localStorage() {
    return window.localStorage;
  }
  set version(version) {
    Object.assign(window, { PHN_HEADER_VERSION: version });
  }
  set navigationLoaded(loaded) {
    Object.assign(window, { PHN_NAVIGATION_LOADED: loaded });
  }
  get bodyOverflow() {
    return document.body.style.overflow;
  }
  get bodyHeight() {
    return document.body.style.height;
  }
  requestAnimationFrame(callback) {
    return window.requestAnimationFrame(callback);
  }
  createDiv() {
    return window.document.createElement('div');
  }
  getBreakpoint() {
    const clientWidth = Math.max(window.document.documentElement.clientWidth, window.innerWidth || 0);
    const matchingBreakpoint = Object.keys(breakpoint)
      .reverse()
      .find((foundBreakpoint) => hasKey(breakpoint, foundBreakpoint) && clientWidth >= breakpoint[foundBreakpoint]);
    return typeof matchingBreakpoint === 'string' && hasKey(breakpoint, matchingBreakpoint)
      ? breakpoint[matchingBreakpoint]
      : 0;
  }
  get redirected() {
    return (window.REDIRECTED === true ||
      window.location.search.includes('cs_redirect='));
  }
  createIframe(id, src) {
    const iframe = window.document.createElement('iframe');
    iframe.id = id;
    iframe.style.display = 'none';
    iframe.src = src;
    window.document.body.appendChild(iframe);
  }
  removeElement(id) {
    var _a;
    (_a = window.document.getElementById(id)) === null || _a === void 0 ? void 0 : _a.remove();
  }
  redirectToUrl(url) {
    window.location.assign(url);
  }
  generateRandom(size) {
    const CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    const buffer = new Uint8Array(size);
    window.crypto.getRandomValues(buffer);
    const state = [];
    for (let i = 0; i < buffer.byteLength; i += 1) {
      const index = buffer[i] % CHARSET.length;
      state.push(CHARSET[index]);
    }
    return state.join('');
  }
  /**
   * site does NOT have consent mechanism -> consent NOT needed
   * site does have consent mechanism + isConsentActive NOT exists -> consent NOT needed
   * site does have consent mechanism + isConsentActive exists + isConsentActive -> consent needed
   * site does have consent mechanism + NOT isConsentActive -> consent NOT needed
   */
  /**
   * consent needed + consent given -> userConsent = true
   * consent needed + consent NOT given -> userConsent = false
   * consent NOT needed -> userConsent = true
   */
  maybeCheckMarketingConsent(handleSuccess) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const args = {
      processorId: (_c = (_b = (_a = window.GlobalConsent) === null || _a === void 0 ? void 0 : _a.Processor) === null || _b === void 0 ? void 0 : _b.googleMaps) !== null && _c !== void 0 ? _c : 'Google Maps',
      timeoutVar: {},
      mapContainer: '',
      callbacks: {
        success: handleSuccess
      }
    };
    if (typeof ((_e = (_d = window.PCOM) === null || _d === void 0 ? void 0 : _d.globalConsent) === null || _e === void 0 ? void 0 : _e.checkConsent) === 'function') {
      (_h = (_g = (_f = window.PCOM) === null || _f === void 0 ? void 0 : _f.globalConsent) === null || _g === void 0 ? void 0 : _g.checkConsent) === null || _h === void 0 ? void 0 : _h.call(_g, args);
      return true;
    }
    if (typeof ((_j = window.ucPrivacyShield) === null || _j === void 0 ? void 0 : _j.checkConsent) === 'function') {
      (_l = (_k = window.ucPrivacyShield) === null || _k === void 0 ? void 0 : _k.checkConsent) === null || _l === void 0 ? void 0 : _l.call(_k, args);
      return true;
    }
    handleSuccess();
    return false;
  }
  async deriveChallenge(code) {
    if (code.length < 43 || code.length > 128) {
      throw new NaviError('invalid code length', NaviErrorTypes.INVALID_INPUT);
    }
    const buf = new ArrayBuffer(code.length);
    const bufView = new Uint8Array(buf);
    for (let i = 0; i < code.length; i++) {
      bufView[i] = code.charCodeAt(i);
    }
    const buffer = await window.crypto.subtle.digest('SHA-256', bufView);
    const bytes = new Uint8Array(buffer);
    let binary = '';
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return window.btoa(binary).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
  }
  async hashString(text) {
    const msgUint8 = new TextEncoder().encode(text);
    const hashBuffer = await window.crypto.subtle.digest('SHA-256', msgUint8);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map((b) => b.toString(16).padStart(2, '0')).join('');
  }
  getScrollbarWidth() {
    const scrollDiv = window.document.createElement('div');
    scrollDiv.style.overflow = 'scroll';
    window.document.body.appendChild(scrollDiv);
    const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    window.document.body.removeChild(scrollDiv);
    return Number.isNaN(scrollbarWidth) ? '0px' : `${scrollbarWidth}px`;
  }
  async fetchGoogleMapsApi(apiKey, url = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&libraries=places`) {
    if (window.google !== undefined && window.google.maps !== undefined && window.google.maps.version !== undefined) {
      return window.google;
    }
    const existingScript = document.getElementById('googleMaps'); // -> Current name?!
    if (existingScript) {
      return window.google;
    }
    const script = document.createElement('script');
    script.src = url;
    script.id = 'googleMaps';
    document.head.appendChild(script);
    return new Promise((resolve, reject) => {
      script.onerror = () => {
        reject(new NaviError('Failed to load google maps script.', NaviErrorTypes.GENERAL));
      };
      script.onload = () => {
        resolve(window.google);
      };
    });
  }
  async getNavigatorLatLong() {
    return new Promise((resolve, reject) => {
      window.navigator.geolocation.getCurrentPosition(({ coords: { latitude, longitude } }) => {
        resolve({ latitude, longitude });
      }, (error) => reject(new NaviError(`geolocation.getCurrentPosition failed with ${error.code}: ${error.message}`, getErrorType(error))));
    });
  }
  getCookie(cookieName) {
    var _a;
    return getString((_a = document.cookie
      .split('; ')
      .find((row) => row.startsWith(`${cookieName}=`))) === null || _a === void 0 ? void 0 : _a.split('=')[1]);
  }
  setCookie(cookieName, newValue) {
    document.cookie = `${cookieName}=${newValue};domain=${COOKIE_DOMAIN};expires=${new Date(Date.now() + MS_IN_MONTH * 10).toUTCString()};`;
  }
  btoa(data) {
    return window.btoa(data);
  }
  lockScroll() {
    this.initialBodyStyleValues = shallowCopySpecifiedAttributesWithDefault(document.body.style, this.initialBodyStyleValues);
    this.initialDocumentScrollTop = document.documentElement.scrollTop;
    document.body.style.top = `-${document.documentElement.scrollTop}px`;
    document.body.style.position = 'fixed';
    document.body.style.inlineSize = '100%';
    document.body.style.overflowY = 'scroll';
  }
  unlockScroll() {
    Object.entries(this.initialBodyStyleValues).forEach(([key, value]) => document.body.style.setProperty(camelToKebapCase(key), value));
    document.documentElement.scrollTop = this.initialDocumentScrollTop;
  }
  hasScrollbar() {
    return window.document.body.offsetHeight > window.innerHeight;
  }
  async waitForElement(parent, selector) {
    if (!isString(selector)) {
      return parent;
    }
    const el = getHTMLElement(parent.querySelector(selector));
    if (el !== null) {
      return el;
    }
    return new Promise((resolve) => {
      const observer = new MutationObserver(() => {
        const newEl = getHTMLElement(parent.querySelector(selector));
        if (newEl !== null) {
          resolve(newEl);
          observer.disconnect();
        }
      });
      observer.observe(parent, { childList: true, subtree: true });
    });
  }
}
export function getErrorType(error) {
  switch (error.code) {
    case error.PERMISSION_DENIED: {
      return NaviErrorTypes.GEOLOCATION_DENIED;
    }
    case error.POSITION_UNAVAILABLE:
    case error.TIMEOUT: {
      return NaviErrorTypes.RETRY;
    }
    default: {
      return NaviErrorTypes.GENERAL;
    }
  }
}
export default new WindowService();
//# sourceMappingURL=window-service.js.map
