/* istanbul ignore file */
import { splitLocale } from "../entities/locale";
import { isString } from "../utility/helper";
import windowService from "./window-service";
import { NaviErrorTypes, NaviError } from "../utility/navi-error";
import { getRegionSpecificCountry } from "../utility/helpers/dealer-search-helper";
export class MapsService {
  constructor() {
    this.autocompleteService = null;
    this.placesService = null;
    this.geocoderService = null;
    this.getLocation = null;
  }
  async init(apiKey) {
    try {
      const google = await windowService.fetchGoogleMapsApi(apiKey);
      this.autocompleteService = new google.maps.places.AutocompleteService();
      this.placesService = new google.maps.places.PlacesService(new google.maps.Map(windowService.createDiv()));
      this.geocoderService = new google.maps.Geocoder();
      this.getLocation = (latLong) => new google.maps.LatLng(latLong.latitude, latLong.longitude);
    }
    catch (err) {
      throw new NaviError(`windowService.fetchGoogleMapsApi failed with error: ${err}`, NaviErrorTypes.GENERAL);
    }
  }
  async getPredictions(input, locale) {
    var _a;
    if (input.length === 0) {
      return [];
    }
    //ToDo: Check what todo if country is no valid iso-code
    const predictions = await new Promise((resolve, reject) => {
      if (this.autocompleteService === null) {
        reject(new NaviError('autocompleteService is not initialised', NaviErrorTypes.GENERAL));
        return;
      }
      this.autocompleteService.getPlacePredictions({
        input,
        componentRestrictions: { country: getRegionSpecificCountry(splitLocale(locale).country) }
      }, (predictions, status) => status === 'OK'
        ? resolve(predictions)
        : reject(new NaviError(`autocompleteService.getPlacePredictions failed with ${status}`, getErrorType(status))));
    });
    return ((_a = predictions === null || predictions === void 0 ? void 0 : predictions.filter(({ place_id, description }) => isString(place_id) && isString(description)).map(({ place_id: id, description: text }) => ({ id, text }))) !== null && _a !== void 0 ? _a : []);
  }
  async getPlaceCoordinates(placeId) {
    var _a, _b, _c, _d;
    const response = await new Promise((resolve, reject) => {
      if (this.placesService === null) {
        reject(new NaviError('placesService is not initialised', NaviErrorTypes.GENERAL));
        return;
      }
      this.placesService.getDetails({
        placeId
      }, (response, status) => status === 'OK'
        ? resolve(response)
        : reject(new NaviError(`placeService.getDetails failed with ${status}`, getErrorType(status))));
    });
    const latitude = (_b = (_a = response === null || response === void 0 ? void 0 : response.geometry) === null || _a === void 0 ? void 0 : _a.location) === null || _b === void 0 ? void 0 : _b.lat();
    const longitude = (_d = (_c = response === null || response === void 0 ? void 0 : response.geometry) === null || _c === void 0 ? void 0 : _c.location) === null || _d === void 0 ? void 0 : _d.lng();
    if (typeof latitude !== 'number' || typeof longitude !== 'number') {
      throw new NaviError(`placesService.getDetails did not find latitude or longitude for placeId: ${placeId}`, NaviErrorTypes.NO_RESULTS);
    }
    return { latitude, longitude };
  }
  async getFormattedAddressFromCoordinates(latLong) {
    if (this.getLocation === null) {
      throw new NaviError('getLocation is not initialised', NaviErrorTypes.GENERAL);
    }
    const location = this.getLocation(latLong);
    const response = await new Promise((resolve, reject) => {
      if (this.geocoderService === null) {
        reject(new NaviError('geocoderService is not initialised', NaviErrorTypes.GENERAL));
        return;
      }
      this.geocoderService.geocode({ location }, (response, status) => {
        status === 'OK'
          ? resolve(response)
          : reject(new NaviError(`geocoderService.geocode failed with status ${status}`, getErrorType(status)));
      });
    });
    if (response === null || response.length === 0) {
      throw new NaviError('geocoderService.geocode did not find the location based on coordinates.', NaviErrorTypes.NO_RESULTS);
    }
    return response[0].formatted_address;
  }
}
export function getErrorType(status) {
  switch (status) {
    case 'INVALID_REQUEST': {
      return NaviErrorTypes.INVALID_INPUT;
    }
    case 'NOT_FOUND':
    case 'ZERO_RESULTS': {
      return NaviErrorTypes.NO_RESULTS;
    }
    case 'OVER_QUERY_LIMIT':
    case 'UNKNOWN_ERROR': {
      return NaviErrorTypes.RETRY;
    }
    case 'ERROR':
    case 'REQUEST_DENIED':
    default: {
      return NaviErrorTypes.GENERAL;
    }
  }
}
export default new MapsService();
//# sourceMappingURL=maps-service.js.map
