import { firstUserProfileData } from "../test/test-data";
import * as userService from "./user-service";
import { NaviError, NaviErrorTypes } from "../utility/navi-error";
import { navStateStore } from "../state/nav-state-store";
import { DEFAULT_UNREAD_MESSAGES_COUNT, LOGGED_IN_USER_NO_NAME_STATUS } from "../utility/constants";
const { getUserNameFromUserData, initializeUserData } = userService;
describe('User Service', () => {
  describe('getUserNameFromUserData', () => {
    it('should return default value if no name parameters are present in userData', async () => {
      const userDataNoName = Object.assign(Object.assign({}, firstUserProfileData), { firstName: undefined, lastName: undefined });
      expect(getUserNameFromUserData(userDataNoName)).toBe('');
    });
    it('should return name if only firstName parameters are present in userData', async () => {
      const userDataNoName = Object.assign(Object.assign({}, firstUserProfileData), { lastName: undefined });
      expect(getUserNameFromUserData(userDataNoName)).toBe('Mirinda');
    });
    it('should return name if only firstName and lastName parameters are present in userData', async () => {
      const userDataNoName = Object.assign({}, firstUserProfileData);
      expect(getUserNameFromUserData(userDataNoName)).toBe('Mirinda Doe');
    });
    it('should return last name if only lastName parameter is present in userData', async () => {
      const userDataNoName = Object.assign(Object.assign({}, firstUserProfileData), { firstName: undefined });
      expect(getUserNameFromUserData(userDataNoName)).toBe('Doe');
    });
    it('should return first name if only firstName parameter is present in userData', async () => {
      const userDataNoName = Object.assign(Object.assign({}, firstUserProfileData), { lastName: undefined });
      expect(getUserNameFromUserData(userDataNoName)).toBe('Mirinda');
    });
    it('should return name if all name parameters are present in userData', async () => {
      expect(getUserNameFromUserData(firstUserProfileData)).toBe('Mirinda Doe');
    });
    it('should return empty string empty profile passed', async () => {
      expect(getUserNameFromUserData({})).toBe('');
    });
  });
  describe('initialize user data', () => {
    const accessToken = 'fake-access-token';
    const locale = 'en-US';
    const throwOnMockedFetch = (reason) => {
      jest.spyOn(global, 'fetch').mockImplementationOnce(() => {
        throw new Error(reason);
      });
    };
    it('should throw general error', async () => {
      const errorReason = 'Error fetching user';
      const expectedError = new NaviError(`Get User information request failed in Frontend with error: "${errorReason}"`, NaviErrorTypes.GENERAL);
      throwOnMockedFetch(errorReason);
      try {
        await initializeUserData(accessToken, locale);
      }
      catch (err) {
        expect(navStateStore.state.unreadMessagesCount).toEqual(DEFAULT_UNREAD_MESSAGES_COUNT);
        expect(navStateStore.state.loggedInState).toEqual(LOGGED_IN_USER_NO_NAME_STATUS);
        expect(err).toEqual(expectedError);
      }
    });
    it('should throw error if user is null', async () => {
      const error = new NaviError('Invalid user data object extracted from user profile response', NaviErrorTypes.NO_RESULTS);
      jest.spyOn(global, 'fetch').mockResolvedValueOnce({
        ok: true,
        status: 200,
        json: async () => null
      });
      try {
        await initializeUserData(accessToken, locale);
      }
      catch (err) {
        expect(navStateStore.state.unreadMessagesCount).toEqual(DEFAULT_UNREAD_MESSAGES_COUNT);
        expect(navStateStore.state.loggedInState).toEqual(LOGGED_IN_USER_NO_NAME_STATUS);
        expect(err).toEqual(error);
      }
    });
    it('should throw error if results returns a malformed json', async () => {
      const error = new NaviError('Error on user profile response', NaviErrorTypes.GENERAL);
      jest.spyOn(global, 'fetch').mockResolvedValueOnce({
        ok: true,
        status: 200,
        json: async () => Promise.reject(error)
      });
      try {
        await initializeUserData(accessToken, locale);
      }
      catch (err) {
        expect(navStateStore.state.unreadMessagesCount).toEqual(DEFAULT_UNREAD_MESSAGES_COUNT);
        expect(navStateStore.state.loggedInState).toEqual(LOGGED_IN_USER_NO_NAME_STATUS);
        expect(err).toEqual(error);
      }
    });
  });
});
//# sourceMappingURL=user-service.spec.js.map
