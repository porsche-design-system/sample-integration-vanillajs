import { firstUserProfileData } from "../test/test-data";
import * as userService from "./user-service";
import windowService from "./window-service";
import { NaviError, NaviErrorTypes } from "../utility/navi-error";
import { navStateStore } from "../state/nav-state-store";
import { DEFAULT_UNREAD_MESSAGES_COUNT, LOGGED_IN_USER_NO_NAME_STATUS, LOGGED_OUT_USER_STATUS } from "../utility/constants";
const { getUserIdFromUserData, getUserNameFromUserData, initializeUserData } = userService;
describe('User Service', () => {
  describe('getUserNameFromUserData', () => {
    it('should return hashed email address as userId', async () => {
      const crypto = jest.spyOn(windowService, 'hashString').mockImplementation(async () => '');
      await getUserIdFromUserData(Object.assign({}, firstUserProfileData));
      expect(crypto).toHaveBeenCalledTimes(1);
    });
  });
  describe('getUserNameFromUserData', () => {
    it('should return default value if no name parameters are present in userData', async () => {
      const userDataNoName = Object.assign(Object.assign({}, firstUserProfileData), { firstName: undefined, lastName: undefined });
      expect(getUserNameFromUserData(userDataNoName)).toBe('');
    });
    it('should return name if only firstName parameters are present in userData', async () => {
      const userDataNoName = Object.assign(Object.assign({}, firstUserProfileData), { lastName: undefined });
      expect(getUserNameFromUserData(userDataNoName)).toBe('Mirinda');
    });
    it('should return name if only firstName and lastName parameters are present in userData', async () => {
      const userDataNoName = Object.assign({}, firstUserProfileData);
      expect(getUserNameFromUserData(userDataNoName)).toBe('Mirinda Doe');
    });
    it('should return last name if only lastName parameter is present in userData', async () => {
      const userDataNoName = Object.assign(Object.assign({}, firstUserProfileData), { firstName: undefined });
      expect(getUserNameFromUserData(userDataNoName)).toBe('Doe');
    });
    it('should return first name if only firstName parameter is present in userData', async () => {
      const userDataNoName = Object.assign(Object.assign({}, firstUserProfileData), { lastName: undefined });
      expect(getUserNameFromUserData(userDataNoName)).toBe('Mirinda');
    });
    it('should return name if all name parameters are present in userData', async () => {
      expect(getUserNameFromUserData(firstUserProfileData)).toBe('Mirinda Doe');
    });
    it('should return empty string empty profile passed', async () => {
      expect(getUserNameFromUserData({})).toBe('');
    });
  });
  describe('initialize user data', () => {
    const accessToken = 'fake-access-token';
    const locale = 'en-US';
    const config = { API_URL: 'http://fake-api-url.com' };
    const throwOnMockedFetch = (reason) => {
      jest.spyOn(global, 'fetch').mockImplementationOnce(() => {
        throw new Error(reason);
      });
    };
    it('should throw general error', async () => {
      const errorReason = 'Error fetching user';
      const expectedError = new NaviError(`Exception occurred while fetching user info: "${errorReason}"`, NaviErrorTypes.GENERAL);
      throwOnMockedFetch(errorReason);
      try {
        await initializeUserData(accessToken, locale, config);
      }
      catch (err) {
        expect(navStateStore.state.unreadMessagesCount).toEqual(DEFAULT_UNREAD_MESSAGES_COUNT);
        expect(navStateStore.state.loggedInState).toEqual(LOGGED_IN_USER_NO_NAME_STATUS);
        expect(err).toEqual(expectedError);
      }
    });
    it('should throw unauthorized user', async () => {
      const error = new NaviError(`AccessToken has expired`, NaviErrorTypes.UNAUTHORIZED);
      jest.spyOn(global, 'fetch').mockResolvedValueOnce({
        status: 401
      });
      try {
        await initializeUserData(accessToken, locale, config);
      }
      catch (err) {
        expect(navStateStore.state.unreadMessagesCount).toEqual(DEFAULT_UNREAD_MESSAGES_COUNT);
        expect(navStateStore.state.loggedInState).toEqual(LOGGED_OUT_USER_STATUS);
        expect(err).toEqual(error);
      }
    });
    it('should throw general error if response is not Ok', async () => {
      const error = new NaviError('Error occurred: 200 Some error occurred', NaviErrorTypes.GENERAL);
      jest.spyOn(global, 'fetch').mockResolvedValueOnce({
        ok: false,
        status: 200,
        statusText: 'Some error occurred'
      });
      try {
        await initializeUserData(accessToken, locale, config);
      }
      catch (err) {
        expect(navStateStore.state.unreadMessagesCount).toEqual(DEFAULT_UNREAD_MESSAGES_COUNT);
        expect(navStateStore.state.loggedInState).toEqual(LOGGED_IN_USER_NO_NAME_STATUS);
        expect(err).toEqual(error);
      }
    });
    it('should throw error if user is null', async () => {
      const error = new NaviError('Invalid user data object extracted from user profile response', NaviErrorTypes.NO_RESULTS);
      jest.spyOn(global, 'fetch').mockResolvedValueOnce({
        ok: true,
        status: 200,
        json: async () => null
      });
      try {
        await initializeUserData(accessToken, locale, config);
      }
      catch (err) {
        expect(navStateStore.state.unreadMessagesCount).toEqual(DEFAULT_UNREAD_MESSAGES_COUNT);
        expect(navStateStore.state.loggedInState).toEqual(LOGGED_IN_USER_NO_NAME_STATUS);
        expect(err).toEqual(error);
      }
    });
    it('should throw error if results returns a malformed json', async () => {
      const error = new NaviError('Could not extract json from user profile response: Error on user profile response', NaviErrorTypes.GENERAL);
      jest.spyOn(global, 'fetch').mockResolvedValueOnce({
        ok: true,
        status: 200,
        json: async () => Promise.reject('Error on user profile response')
      });
      try {
        await initializeUserData(accessToken, locale, config);
      }
      catch (err) {
        expect(navStateStore.state.unreadMessagesCount).toEqual(DEFAULT_UNREAD_MESSAGES_COUNT);
        expect(navStateStore.state.loggedInState).toEqual(LOGGED_IN_USER_NO_NAME_STATUS);
        expect(err).toEqual(error);
      }
    });
  });
});
//# sourceMappingURL=user-service.spec.js.map
