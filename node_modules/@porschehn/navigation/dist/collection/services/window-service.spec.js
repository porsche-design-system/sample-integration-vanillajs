import windowService, { getErrorType } from "./window-service";
describe('window service', () => {
  it('should return location', () => {
    expect(windowService.location).not.toBeUndefined();
  });
  it('should return sessionStorage', () => {
    expect(windowService.sessionStorage).not.toBeUndefined();
  });
  describe('GoogleMaps', () => {
    const url = 'http://google-maps-api-url/';
    it('should add googlemaps script, if googlemaps is not already loaded', async () => {
      var _a;
      jest.restoreAllMocks();
      const promise = windowService.fetchGoogleMapsApi('apiKey', url);
      const googleMapsScript = document.getElementById('googleMaps');
      expect(googleMapsScript).toBeTruthy();
      if (googleMapsScript instanceof HTMLScriptElement) {
        (_a = googleMapsScript.onload) === null || _a === void 0 ? void 0 : _a.call(googleMapsScript, new Event('test'));
        expect(googleMapsScript.src).toBe(url);
      }
      await promise;
    });
    it('should not fetch googlemaps script, if googlemaps is already loaded', async () => {
      window.google = { maps: { version: 'version' } };
      await windowService.fetchGoogleMapsApi('apiKey', url);
      expect(document.getElementById('googleMaps')).toBeNull();
    });
    it('should not fetch googlemaps script, if googlemaps script is already added', async () => {
      const script = document.createElement('script');
      script.src = url;
      script.id = 'googleMaps';
      document.head.appendChild(script);
      await windowService.fetchGoogleMapsApi('apiKey', url);
      expect(document.querySelectorAll('#googleMaps')).toHaveLength(1);
    });
  });
  describe('getErrorType', () => {
    it('should return GEOLOCATION_DENIED for PERMISSION_DENIED', () => {
      const positionError = {
        code: 1,
        message: 'Permission got denied',
        PERMISSION_DENIED: 1,
        POSITION_UNAVAILABLE: 2,
        TIMEOUT: 3
      };
      expect(getErrorType(positionError)).toEqual('GEOLOCATION_DENIED');
    });
    it('should return RETRY for POSITION_UNAVAILABLE', () => {
      const positionError = {
        code: 2,
        message: 'Some internal error happened',
        PERMISSION_DENIED: 1,
        POSITION_UNAVAILABLE: 2,
        TIMEOUT: 3
      };
      expect(getErrorType(positionError)).toEqual('RETRY');
    });
    it('should return RETRY for TIMEOUT', () => {
      const positionError = {
        code: 3,
        message: 'This timed out',
        PERMISSION_DENIED: 1,
        POSITION_UNAVAILABLE: 2,
        TIMEOUT: 3
      };
      expect(getErrorType(positionError)).toEqual('RETRY');
    });
    it('should return GENERAL for default', () => {
      const positionError = {
        code: 0,
        message: 'Unknown error',
        PERMISSION_DENIED: 1,
        POSITION_UNAVAILABLE: 2,
        TIMEOUT: 3
      };
      expect(getErrorType(positionError)).toEqual('GENERAL');
    });
  });
  /**
   * site does NOT EVEN HAVE PCOM?! -> consent NOT needed
   * site does NOT have consent mechanism -> consent NOT needed
   * site does have consent mechanism + isConsentActive NOT exists -> consent NOT needed
   * site does have consent mechanism + isConsentActive exists + isConsentActive -> consent needed
   * site does have consent mechanism + NOT isConsentActive -> consent NOT needed
   */
  describe('maybeCheckMarketingConsent', () => {
    it('marketing consent is not needed if header is loaded outside of PCOM', () => {
      expect(windowService.maybeCheckMarketingConsent(() => null)).toBeFalsy();
    });
    it('marketing consent is not needed if consent is not needed by law', () => {
      window.PCOM = {};
      expect(windowService.maybeCheckMarketingConsent(() => null)).toBeFalsy();
    });
    it('marketing consent is checked if checkConsent is a function', () => {
      const checkConsent = jest.fn();
      const handleSuccess = jest.fn();
      window.PCOM = { globalConsent: { checkConsent } };
      expect(windowService.maybeCheckMarketingConsent(handleSuccess)).toBeTruthy();
      expect(checkConsent).toBeCalledWith({
        processorId: 'Google Maps',
        mapContainer: '',
        timeoutVar: {},
        callbacks: {
          success: handleSuccess
        }
      });
    });
    it('marketing consent is not needed if user centrics does not exist', () => {
      window.ucPrivacyShield = {};
      expect(windowService.maybeCheckMarketingConsent(() => null)).toBeFalsy();
    });
    it('marketing consent is checked if user centrics exists', () => {
      const checkConsent = jest.fn();
      const handleSuccess = jest.fn();
      window.ucPrivacyShield = { checkConsent };
      expect(windowService.maybeCheckMarketingConsent(handleSuccess)).toBeTruthy();
      expect(checkConsent).toBeCalledWith({
        processorId: 'Google Maps',
        mapContainer: '',
        timeoutVar: {},
        callbacks: {
          success: handleSuccess
        }
      });
    });
  });
  xdescribe('crypto', () => {
    it('produces the right challenge for a valid code', async () => {
      const code = windowService.generateRandom(43);
      const result = await windowService.deriveChallenge(code);
      expect(result).toBeTruthy();
      expect(result).not.toContain('=');
    });
    it('generateRandom produces different values', () => {
      const code1 = windowService.generateRandom(10);
      const code2 = windowService.generateRandom(10);
      expect(code1).not.toEqual(code2);
    });
    it('produces the right base64 encoded challenge', async () => {
      const code = new Array(6).join('challenge');
      const challenge = await windowService.deriveChallenge(code);
      expect(challenge).toEqual('MYdqq2Vt_ZLMAWpXXsjGIrlxrCF2e4ZP4SxDf7cm_tg');
    });
  });
});
//# sourceMappingURL=window-service.spec.js.map
