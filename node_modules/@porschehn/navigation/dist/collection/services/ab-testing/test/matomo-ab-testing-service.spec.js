import { MatomoAbTestingService } from "../matomo-ab-testing-service";
import { navStateStore } from "../../../state/nav-state-store";
import experimentsTestdata, { contentDefinitions, testMenu } from "../../../test/experiments.testdata";
import { NaviError, NaviErrorTypes } from "../../../utility/navi-error";
import Logger from "../../logger";
import * as utilityHelper from "../../../utility/helper";
import featureToggles from "../../feature-toggles";
import { navContentStore } from "../../../state/nav-content-store";
const clientMock = {
  AbTesting: {
    Experiment: jest.fn()
  }
};
const mockEmptyExperiment = {
  name: 'experiment_present',
  getActivatedVariationName: () => {
    return 'variation_not_present';
  },
  variations: []
};
const mockExistingExperiment = {
  name: 'experiment_present',
  getActivatedVariationName: () => {
    return 'variation_present';
  },
  variations: [
    {
      name: 'variation_present',
      activate: jest.fn()
    }
  ]
};
describe('Matomo AB testing Service', () => {
  let loggerMock;
  beforeEach(() => {
    loggerMock = jest.spyOn(Logger, 'error');
    jest.spyOn(featureToggles, 'isABTestingToggleActive').mockReturnValue(true);
  });
  describe('Init', () => {
    describe.each(['production', 'preview'])('Initialize service', (env) => {
      it(`should inject matomo script for ${env}`, async () => {
        navStateStore.state.env = env;
        const service = new MatomoAbTestingService();
        service.init();
        expect(document.getElementsByTagName('script')[0].text).toEqual(getMatomoScript(env));
      });
    });
    it('should set client', function () {
      jest.spyOn(MatomoAbTestingService.prototype, 'injectScript').mockResolvedValue(true);
      const w = window;
      w.Matomo = clientMock;
      const service = new MatomoAbTestingService();
      expect(() => service.init()).not.toThrow();
    });
    it('should catch error if no matomo script is available client', async function () {
      jest.spyOn(utilityHelper, 'getHTMLElement').mockReturnValue(null);
      const service = new MatomoAbTestingService();
      await service.init();
      expect(loggerMock).toHaveBeenCalledWith('Could not initialize AbTesting', new NaviError('There is no HTML Script element available', NaviErrorTypes.GENERAL));
    });
    it('set client should throw error', async function () {
      jest.spyOn(MatomoAbTestingService.prototype, 'injectScript').mockResolvedValue(true);
      const service = new MatomoAbTestingService();
      await service.init();
      expect(loggerMock).toHaveBeenCalledWith('Could not initialize AbTesting', new NaviError('No client is set, you must call init first', NaviErrorTypes.GENERAL));
    });
    it('should load Experiments', async () => {
      jest
        .spyOn(MatomoAbTestingService.prototype, 'getAbTestingDefinitions')
        .mockReturnValue(experimentsTestdata);
      jest.spyOn(MatomoAbTestingService.prototype, 'getClient').mockReturnValue(clientMock);
      jest.spyOn(MatomoAbTestingService.prototype, 'injectScript').mockResolvedValue(true);
      const service = new MatomoAbTestingService();
      await service.init();
      expect(clientMock.AbTesting.Experiment).toHaveBeenCalledTimes(1);
    });
    it('should init Ab Testing based on Matomo', async () => {
      const setClientMock = jest.spyOn(MatomoAbTestingService.prototype, 'setClient').mockResolvedValue(true);
      const loadExperimentsMock = jest
        .spyOn(MatomoAbTestingService.prototype, 'loadExperiments')
        .mockResolvedValue(true);
      const service = new MatomoAbTestingService();
      await service.init();
      expect(setClientMock).toHaveBeenCalledTimes(1);
      expect(loadExperimentsMock).toHaveBeenCalledTimes(1);
    });
    it('should thrown error when Ab Testing init fails', async () => {
      jest.spyOn(MatomoAbTestingService.prototype, 'setClient').mockRejectedValue(false);
      const service = new MatomoAbTestingService();
      await expect(() => service.init()).not.toThrow();
    });
    it('should Log error when Ab Testing init fails', async () => {
      jest.spyOn(MatomoAbTestingService.prototype, 'setClient').mockRejectedValue('Failed');
      const service = new MatomoAbTestingService();
      await service.init();
      expect(loggerMock).toHaveBeenCalled();
      expect(loggerMock).toHaveBeenCalledWith('Could not initialize AbTesting', 'Failed');
    });
  });
  describe('Execute', () => {
    beforeEach(() => {
      navContentStore.state.abExperiences = contentDefinitions;
      jest.spyOn(MatomoAbTestingService.prototype, 'getClient').mockReturnValue(clientMock);
      jest.spyOn(MatomoAbTestingService.prototype, 'injectScript').mockResolvedValue(true);
    });
    it('should throw error when no experiment is found', () => {
      const service = new MatomoAbTestingService();
      service.execute('experiment_not_present');
      expect(loggerMock).toHaveBeenCalled();
      expect(loggerMock).toHaveBeenCalledWith('Could not execute experiment experiment_not_present', new NaviError('No experiment with name: experiment_not_present found', NaviErrorTypes.GENERAL));
    });
    it('should throw error when no variation is found', () => {
      jest.spyOn(MatomoAbTestingService.prototype, 'getExperiment').mockReturnValue(mockEmptyExperiment);
      const service = new MatomoAbTestingService();
      service.execute('experiment_present');
      expect(loggerMock).toHaveBeenCalled();
      expect(loggerMock).toHaveBeenCalledWith('Could not execute experiment experiment_present', new NaviError('No variation in experiment: experiment_present with name: variation_not_present found', NaviErrorTypes.GENERAL));
    });
    it('should call variation activate function', function () {
      jest.spyOn(MatomoAbTestingService.prototype, 'getExperiment').mockReturnValue(mockExistingExperiment);
      const service = new MatomoAbTestingService();
      service.execute('experiment_present');
      expect(mockExistingExperiment.variations[0].activate).toHaveBeenCalledTimes(1);
    });
  });
  describe('feature Toggle', () => {
    it('should not set client if feature toggle is false', async () => {
      const setClientMock = jest.spyOn(MatomoAbTestingService.prototype, 'setClient').mockReturnValue(false);
      const loadExperimentsMock = jest
        .spyOn(MatomoAbTestingService.prototype, 'loadExperiments')
        .mockReturnValue(false);
      jest.spyOn(featureToggles, 'isABTestingToggleActive').mockReturnValue(false);
      const service = new MatomoAbTestingService();
      await service.init();
      expect(setClientMock).not.toHaveBeenCalled();
      expect(loadExperimentsMock).not.toHaveBeenCalled();
    });
  });
  describe('content experiments', () => {
    beforeEach(() => {
      navContentStore.state.abExperiences = contentDefinitions;
      jest.spyOn(MatomoAbTestingService.prototype, 'getClient').mockReturnValue(clientMock);
      jest.spyOn(MatomoAbTestingService.prototype, 'injectScript').mockResolvedValue(true);
    });
    it('should load content experiments', async () => {
      const service = new MatomoAbTestingService();
      await service.loadContentGeneratorExperiments();
      expect(clientMock.AbTesting.Experiment).toHaveBeenCalledTimes(1);
      const experimentParameters = clientMock.AbTesting.Experiment.mock.calls[0][0];
      expect(experimentParameters.variations[0].name).toEqual('variation1');
      expect(experimentParameters.variations[0].activate()).toEqual([
        { children: [], id: '1', link: 'var1 link', text: 'var1 text' }
      ]);
      expect(experimentParameters.variations[1].name).toEqual('original');
      expect(experimentParameters.variations[1].activate()).toEqual(null);
    });
    it('should return original menu children for original variation', async () => {
      const variation = {
        name: 'original',
        activate: jest.fn()
      };
      const experiment = {
        name: 'experiment1',
        getActivatedVariationName: jest.fn(),
        variations: [variation]
      };
      jest.spyOn(MatomoAbTestingService.prototype, 'getExperiment').mockReturnValue(experiment);
      jest.spyOn(MatomoAbTestingService.prototype, 'getVariation').mockReturnValue(variation);
      const service = new MatomoAbTestingService();
      const originalChildren = service.executeContentChange(testMenu);
      expect(originalChildren).toEqual(testMenu.children);
    });
    it('should return original menu children when feature toggle is disabled', async () => {
      jest.spyOn(featureToggles, 'isABTestingToggleActive').mockReturnValue(false);
      const service = new MatomoAbTestingService();
      const variationChildren = service.executeContentChange(testMenu);
      expect(variationChildren).toEqual(testMenu.children);
    });
    it('executeContentChange should return changed content', async () => {
      const variation = {
        name: 'variation1',
        activate: jest.fn()
      };
      const experiment = {
        name: 'experiment1',
        getActivatedVariationName: jest.fn(),
        variations: [variation]
      };
      jest.spyOn(MatomoAbTestingService.prototype, 'getExperiment').mockReturnValue(experiment);
      jest.spyOn(MatomoAbTestingService.prototype, 'getVariation').mockReturnValue(variation);
      const service = new MatomoAbTestingService();
      service.executeContentChange(testMenu);
      expect(variation.activate).toHaveBeenCalledTimes(1);
    });
  });
});
function getMatomoScript(currentEnvironment) {
  return `var _paq = window._paq = window._paq || [];
    _paq.push(['trackPageView']);
    _paq.push(['enableLinkTracking']);
    (function() {
      var u="https://porsche.matomo.cloud/";
      _paq.push(['setTrackerUrl', u+'matomo.php']);
      _paq.push(['setSiteId', ${currentEnvironment === 'production' ? '7' : '8'}]);
      var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
      g.async=true; g.src='//cdn.matomo.cloud/porsche.matomo.cloud/matomo.js'; s.parentNode.insertBefore(g,s);
    })
   ();`;
}
//# sourceMappingURL=matomo-ab-testing-service.spec.js.map
