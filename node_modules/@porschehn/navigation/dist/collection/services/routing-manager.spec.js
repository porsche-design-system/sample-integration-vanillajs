import { routerStore } from "../state/router-store";
import { addRoute, back, getAnimatedRoute, getCurrentRoute, goTo, isAnimating, isAnimatingBackward, isAnimatingForward, isClosed, isClosing, isNavigatingBackwards, isOpened, isOpening, pop, reset, showBackButton, syncAnimation } from "./routing-manager";
import { RoutingKeyPointers, RoutingKeys } from "../entities/routing-key";
import * as helper from "../utility/helper";
import * as singleDrawerAnimationController from "../components/single-drawer/animations/animations-controller";
import { dealerSearchResultsStore } from "../state/dealer-search-results-store";
import { mockPPNDealer } from "../test/test-data";
describe('Routing Manager', () => {
  beforeEach(() => {
    routerStore.state.routingKeyHistory = ['route1', 'route2', 'route3'];
    routerStore.state.routingKeyPointer = 1;
  });
  describe('Get Current Route', () => {
    it('should return the current route', () => {
      const currentRoute = getCurrentRoute();
      expect(currentRoute).toBe('route2');
    });
    it('should return an empty string when the history is empty', () => {
      routerStore.state.routingKeyHistory = [];
      routerStore.state.routingKeyPointer = 0;
      const currentRoute = getCurrentRoute();
      expect(currentRoute).toBe('');
    });
    it('should return an empty string when the pointer is out of bounds', () => {
      routerStore.state.routingKeyPointer = -1;
      const currentRoute = getCurrentRoute();
      expect(currentRoute).toBe('');
    });
  });
  describe('getAnimatedRoute', () => {
    it('should return the animated route when the animatingPointer is valid', () => {
      routerStore.state.animatingPointer = 1;
      const animatedRoute = getAnimatedRoute();
      expect(animatedRoute).toBe('route2');
    });
    it('should return an empty string when the history is empty', () => {
      routerStore.state.routingKeyHistory = [];
      routerStore.state.animatingPointer = -1;
      const animatedRoute = getAnimatedRoute();
      expect(animatedRoute).toBe('');
    });
    it('should return an empty string when the animatingPointer is out of bounds', () => {
      routerStore.state.routingKeyHistory = ['route1', 'route2', 'route3'];
      routerStore.state.animatingPointer = 3;
      const animatedRoute = getAnimatedRoute();
      expect(animatedRoute).toBe('');
    });
  });
  describe('goTo', () => {
    it('should update routingKeyHistory and routingKeyPointer when adding routes', () => {
      goTo('route1', 'route2', 'route3');
      expect(routerStore.state.routingKeyHistory).toEqual(['mainmenu', 'route1', 'route2', 'route3']);
      expect(routerStore.state.routingKeyPointer).toBe(3);
    });
    it('should point to main menu if no route is provided', () => {
      goTo();
      expect(routerStore.state.routingKeyHistory).toEqual(['mainmenu']);
      expect(routerStore.state.routingKeyPointer).toBe(0);
    });
    it('should update routingKeyHistory when adding a single route', () => {
      goTo('route1');
      expect(routerStore.state.routingKeyHistory).toEqual(['mainmenu', 'route1']);
      expect(routerStore.state.routingKeyPointer).toBe(1);
    });
  });
  describe('showBackButton', () => {
    it('should return true when section is at or beyond LEVEL_TWO', () => {
      goTo('route1', 'route2');
      const result = showBackButton('route1');
      expect(result).toBe(true);
    });
    it('should return false when section is before LEVEL_TWO', () => {
      goTo('route1');
      const result = showBackButton('route1');
      expect(result).toBe(true);
    });
    it('should return false when section is not in the routingKeyHistory', () => {
      goTo('route1', 'route2');
      const result = showBackButton('route3');
      expect(result).toBe(false);
    });
  });
  describe('syncAnimation', () => {
    it('should set animatingPointer to the value of routingKeyPointer', () => {
      routerStore.state.routingKeyPointer = 2;
      syncAnimation();
      expect(routerStore.state.animatingPointer).toBe(2);
    });
    it('should maintain the same value if routingKeyPointer is unchanged', () => {
      routerStore.state.routingKeyPointer = 1;
      syncAnimation();
      expect(routerStore.state.animatingPointer).toBe(1);
    });
  });
  describe('isClosing', () => {
    it('should return true when routingKeyPointer is -1 and animatingPointer is greater than or equal to 0', () => {
      routerStore.state.routingKeyPointer = -1;
      routerStore.state.animatingPointer = 2;
      const result = isClosing();
      expect(result).toBe(true);
    });
    it('should return false when routingKeyPointer is not -1', () => {
      routerStore.state.routingKeyPointer = 1;
      routerStore.state.animatingPointer = 0;
      const result = isClosing();
      expect(result).toBe(false);
    });
    it('should return false when animatingPointer is less than 0', () => {
      routerStore.state.routingKeyPointer = -1;
      routerStore.state.animatingPointer = -1;
      const result = isClosing();
      expect(result).toBe(false);
    });
  });
  describe('isClosed', () => {
    it('should return true when both routingKeyPointer and animatingPointer are LEVEL_ZERO', () => {
      routerStore.state.routingKeyPointer = RoutingKeyPointers.LEVEL_ZERO;
      routerStore.state.animatingPointer = RoutingKeyPointers.LEVEL_ZERO;
      const result = isClosed();
      expect(result).toBe(true);
    });
    it('should return false when routingKeyPointer is not LEVEL_ZERO', () => {
      routerStore.state.routingKeyPointer = 1;
      routerStore.state.animatingPointer = RoutingKeyPointers.LEVEL_ZERO;
      const result = isClosed();
      expect(result).toBe(false);
    });
    it('should return false when animatingPointer is not LEVEL_ZERO', () => {
      routerStore.state.routingKeyPointer = RoutingKeyPointers.LEVEL_ZERO;
      routerStore.state.animatingPointer = 1;
      const result = isClosed();
      expect(result).toBe(false);
    });
  });
  describe('isOpened', () => {
    it('should return true when routing is opened state', () => {
      routerStore.state.routingKeyPointer = 1;
      routerStore.state.animatingPointer = 1;
      const result = isOpened();
      expect(result).toBe(true);
    });
    it('should return true when is on main menu', () => {
      routerStore.state.routingKeyPointer = 0;
      routerStore.state.animatingPointer = 0;
      const result = isOpened();
      expect(result).toBe(true);
    });
  });
  describe('isOpening', () => {
    it('should return true when animatingPointer comes from level 0 (-1) and routingKeyPointer is greater than or equal to 0', () => {
      routerStore.state.animatingPointer = -1;
      routerStore.state.routingKeyPointer = 2;
      const result = isOpening();
      expect(result).toBe(true);
    });
    it('should return false when animatingPointer is not LEVEL_ZERO, that means that is animating, but not opening', () => {
      routerStore.state.animatingPointer = 1;
      routerStore.state.routingKeyPointer = 0;
      const result = isOpening();
      expect(result).toBe(false);
    });
    it('should return false when routingKeyPointer is less than 0', () => {
      routerStore.state.animatingPointer = 0;
      routerStore.state.routingKeyPointer = -1;
      const result = isOpening();
      expect(result).toBe(false);
    });
  });
  describe('isAnimatingBackward', () => {
    it('should return true when routingKeyPointer is less than animatingPointer', () => {
      routerStore.state.routingKeyPointer = 2;
      routerStore.state.animatingPointer = 3;
      const result = isAnimatingBackward();
      expect(result).toBe(true);
    });
    it('should return false when routingKeyPointer is greater than animatingPointer', () => {
      routerStore.state.routingKeyPointer = 3;
      routerStore.state.animatingPointer = 2;
      const result = isAnimatingBackward();
      expect(result).toBe(false);
    });
    it('should return false when routingKeyPointer is equal to animatingPointer', () => {
      routerStore.state.routingKeyPointer = 2;
      routerStore.state.animatingPointer = 2;
      const result = isAnimatingBackward();
      expect(result).toBe(false);
    });
  });
  describe('isAnimatingForward', () => {
    it('should return true when routingKeyPointer is greater than animatingPointer', () => {
      routerStore.state.routingKeyPointer = 3;
      routerStore.state.animatingPointer = 2;
      const result = isAnimatingForward();
      expect(result).toBe(true);
    });
    it('should return false when routingKeyPointer is less than animatingPointer', () => {
      routerStore.state.routingKeyPointer = 2;
      routerStore.state.animatingPointer = 3;
      const result = isAnimatingForward();
      expect(result).toBe(false);
    });
    it('should return false when routingKeyPointer is equal to animatingPointer', () => {
      routerStore.state.routingKeyPointer = 2;
      routerStore.state.animatingPointer = 2;
      const result = isAnimatingForward();
      expect(result).toBe(false);
    });
  });
  describe('isAnimating', () => {
    it('should return true when routingKeyPointer is not equal to animatingPointer', () => {
      routerStore.state.routingKeyPointer = 3;
      routerStore.state.animatingPointer = 2;
      const result = isAnimating();
      expect(result).toBe(true);
    });
    it('should return false when routingKeyPointer is equal to animatingPointer', () => {
      routerStore.state.routingKeyPointer = 2;
      routerStore.state.animatingPointer = 2;
      const result = isAnimating();
      expect(result).toBe(false);
    });
  });
  describe('isNavigatingBackwards', () => {
    it('should return true when points to a previous route', () => {
      routerStore.state.routingKeyPointer = 1;
      routerStore.state.routingKeyHistory = ['route1', 'route2', 'route3'];
      const result = isNavigatingBackwards();
      expect(result).toBe(true);
      expect(getCurrentRoute()).toBe('route2');
    });
    it('should return false when points to the last route ', () => {
      routerStore.state.routingKeyPointer = 1;
      routerStore.state.routingKeyHistory = ['route1', 'route2'];
      const result = isNavigatingBackwards();
      expect(result).toBe(false);
      expect(getCurrentRoute()).toBe('route2');
    });
    it('should return false when points to an non existing route', () => {
      routerStore.state.routingKeyPointer = 2;
      routerStore.state.routingKeyHistory = ['route1', 'route2'];
      const result = isNavigatingBackwards();
      expect(result).toBe(false);
      expect(getCurrentRoute()).toBe('');
    });
  });
  describe('reset', () => {
    it('should set routingKeyPointer to -1', () => {
      routerStore.state.routingKeyPointer = 2;
      reset();
      expect(routerStore.state.routingKeyPointer).toBe(-1);
    });
  });
  describe('addRoute', () => {
    let dispatchEventSpy;
    beforeEach(() => {
      dispatchEventSpy = jest.spyOn(helper, 'dispatchEvent').mockReturnValue();
    });
    afterEach(() => {
      dispatchEventSpy.mockClear();
    });
    it('should dispatch an event for changing route on desktop', () => {
      jest.spyOn(helper, 'isDesktop').mockReturnValue(true);
      routerStore.state.routingKeyPointer = 1;
      routerStore.state.routingKeyHistory = ['main_menu'];
      addRoute(['route2', 'route3']);
      expect(dispatchEventSpy).toHaveBeenCalledWith('phn-router', 'mobileMenuItemClick', {
        bubbles: true,
        cancelable: false,
        detail: ['route2/route3']
      });
    });
    it('should add a route to history when not on a desktop', () => {
      jest.spyOn(helper, 'isDesktop').mockReturnValue(false);
      routerStore.state.routingKeyPointer = 1;
      routerStore.state.routingKeyHistory = ['main_menu'];
      addRoute(['route2']);
      expect(routerStore.state.routingKeyPointer).toBe(1);
      expect(routerStore.state.routingKeyHistory).toEqual(['main_menu', 'route2']);
    });
  });
  describe('pop', () => {
    it('should remove the last route when navigating backwards', () => {
      routerStore.state.routingKeyPointer = 1;
      routerStore.state.routingKeyHistory = ['route1', 'route2', 'route3'];
      pop();
      expect(routerStore.state.routingKeyHistory).toEqual(['route1', 'route2']);
    });
    it('should not remove the last route when not navigating backwards', () => {
      routerStore.state.routingKeyPointer = 1;
      routerStore.state.routingKeyHistory = ['route1', 'route2'];
      pop();
      expect(routerStore.state.routingKeyHistory).toEqual(['route1', 'route2']);
    });
  });
  describe('back', () => {
    let isPlayingSingleDrawerAnimationSpy;
    beforeEach(() => {
      isPlayingSingleDrawerAnimationSpy = jest.spyOn(singleDrawerAnimationController, 'isPlayingSingleDrawerAnimation');
    });
    it('should decrease the routingKeyPointer when not playing a single drawer animation', () => {
      routerStore.state.routingKeyPointer = 2;
      isPlayingSingleDrawerAnimationSpy.mockReturnValue(false);
      back();
      expect(routerStore.state.routingKeyPointer).toBe(1);
    });
    it('should not decrease the routingKeyPointer when playing a single drawer animation', () => {
      routerStore.state.routingKeyPointer = 2;
      isPlayingSingleDrawerAnimationSpy.mockReturnValue(true);
      back();
      expect(routerStore.state.routingKeyPointer).toBe(2);
    });
    it('should clear the savedDealerCookie when going back from a dealer details route', () => {
      routerStore.state.routingKeyPointer = 2;
      routerStore.state.routingKeyHistory = ['main_menu', RoutingKeys.DEALER_SEARCH, 'find_a_dealer/dealer-id'];
      dealerSearchResultsStore.state.savedDealerCookie = {
        id: mockPPNDealer.id,
        longitude: mockPPNDealer.coordinates.longitude,
        latitude: mockPPNDealer.coordinates.latitude
      };
      isPlayingSingleDrawerAnimationSpy.mockReturnValue(false);
      back();
      expect(routerStore.state.routingKeyPointer).toBe(1);
      expect(dealerSearchResultsStore.state.savedDealerCookie).toBe(null);
    });
  });
});
//# sourceMappingURL=routing-manager.spec.js.map
