import { h } from "@stencil/core";
import { newSpecPage } from "@stencil/core/testing";
import { animationPromiseGenerator } from "./animation-effects";
describe('Animation effects', () => {
  const testElementSelector = '#animate';
  const testAnimation = {
    name: 'growElement',
    cleanUpAfterAnimation: false,
    duration: 5,
    timingFunction: 'cubicBezierStart'
  };
  it('Should not clean up animation using default method when cleanup prop is false', async () => {
    var _a;
    const page = await newSpecPage({
      components: [],
      template: () => h("div", { id: testElementSelector.replace('#', '') })
    });
    let promise = null;
    if (page.root) {
      promise = animationPromiseGenerator(page.root, testAnimation);
    }
    expect(promise).not.toBeNull();
    await promise;
    expect((_a = page.root) === null || _a === void 0 ? void 0 : _a.getAttribute('style')).toEqual('width: 100%;');
  });
  it('Should clean up animation using default method when cleanup prop is true', async () => {
    var _a;
    const page = await newSpecPage({
      components: [],
      template: () => h("div", { id: testElementSelector.replace('#', '') })
    });
    let promise = null;
    if (page.root) {
      promise = animationPromiseGenerator(page.root, Object.assign(Object.assign({}, testAnimation), { cleanUpAfterAnimation: true }));
    }
    expect(promise).not.toBeNull();
    await promise;
    expect((_a = page.root) === null || _a === void 0 ? void 0 : _a.getAttribute('style')).toBeNull();
  });
  it('Should clean up animation using async custom function when given', async () => {
    const cleanupMock = jest.fn().mockReturnValue(new Promise((resolve) => resolve()));
    const page = await newSpecPage({
      components: [],
      template: () => h("div", { id: testElementSelector.replace('#', '') })
    });
    let promise = null;
    if (page.root) {
      promise = animationPromiseGenerator(page.root, Object.assign(Object.assign({}, testAnimation), { cleanUpAfterAnimation: cleanupMock }));
    }
    expect(promise).not.toBeNull();
    await promise;
    expect(cleanupMock).toBeCalledTimes(1);
  });
  it('should clean up animation when timeout interrupts animation', async () => {
    const cleanupMock = jest.fn().mockReturnValue(new Promise((resolve) => resolve()));
    const page = await newSpecPage({
      components: [],
      template: () => h("div", { id: testElementSelector.replace('#', '') })
    });
    jest.useFakeTimers();
    let promise = null;
    if (page.root) {
      promise = animationPromiseGenerator(page.root, Object.assign(Object.assign({}, testAnimation), { cleanUpAfterAnimation: cleanupMock }));
    }
    jest.runAllTimers();
    expect(promise).not.toBeNull();
    await promise;
    expect(cleanupMock).toBeCalledTimes(1);
    jest.useRealTimers();
  });
});
//# sourceMappingURL=animation-effects.spec.js.map
