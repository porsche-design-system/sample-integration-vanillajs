var __rest = (this && this.__rest) || function (s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
import { isPromise } from "../../utility/helper";
import windowService from "../window-service";
import AnimationsAction from "./animation-actions";
const resetStyle = (el) => {
  el.removeAttribute('style');
};
export const getAnimationEffect = (effectName) => {
  return AnimationsAction[effectName];
};
/* istanbul ignore next */
const timingFunctions = {
  easeInOutSin: (timeFraction) => {
    return -(Math.cos(Math.PI * timeFraction) - 1) / 2;
  },
  easeInOutQuad: (timeFraction) => {
    if (timeFraction < 0.5) {
      return (2 * timeFraction) / 2;
    }
    else {
      return (2 - 2 * (1 - timeFraction)) / 2;
    }
  },
  linear: (timeFraction) => {
    return timeFraction < 0 || timeFraction > 1 ? Math.round(timeFraction) : timeFraction;
  },
  cubicBezierStart: (timeFraction) => {
    return cubicBezier(timeFraction, 0.1, 0.0, 0.0, 100);
  },
  cubicBezierEnd: (timeFraction) => {
    return cubicBezier(timeFraction, 0.3, 0.0, 1.0, 0.8);
  }
};
export function animationPromiseGenerator(el, animation) {
  const { duration = 300, cleanUpAfterAnimation = false } = animation, effect = __rest(animation, ["duration", "cleanUpAfterAnimation"]);
  return new Promise((resolve) => {
    let animationFrame;
    const timeout = setTimeout(() => {
      cancelAnimationFrame(animationFrame);
      finishAnimation();
    }, duration + 50);
    function finishAnimation() {
      playEffect(el, 1, effect);
      clearTimeout(timeout);
      if (typeof cleanUpAfterAnimation === 'function') {
        const maybePromise = cleanUpAfterAnimation(el);
        if (isPromise(maybePromise)) {
          maybePromise.then(() => resolve());
          return;
        }
      }
      else if (cleanUpAfterAnimation === true) {
        resetStyle(el);
      }
      resolve();
    }
    const start = performance.now();
    const playEffect = getAnimationEffect(effect.name);
    function animate(time) {
      const timingFunction = timingFunctions[effect.timingFunction || 'linear'];
      let progress = timingFunction((time - start) / duration);
      progress = Math.round((progress + Number.EPSILON) * 1000) / 1000;
      const ANIMATION_HAS_FINISHED = progress >= 1;
      const ANIMATION_ON_PROGRESS = progress < 1;
      if (ANIMATION_HAS_FINISHED) {
        return finishAnimation();
      }
      playEffect(el, progress, effect);
      if (ANIMATION_ON_PROGRESS) {
        animationFrame = windowService.requestAnimationFrame(animate);
      }
    }
    animationFrame = windowService.requestAnimationFrame(animate);
  });
}
function cubicBezier(t, initial, p1, p2, final) {
  return ((1 - t) * (1 - t) * (1 - t) * initial +
    3 * (1 - t) * (1 - t) * t * p1 +
    3 * (1 - t) * t * t * p2 +
    t * t * t * final);
}
//# sourceMappingURL=animation-effects.js.map
