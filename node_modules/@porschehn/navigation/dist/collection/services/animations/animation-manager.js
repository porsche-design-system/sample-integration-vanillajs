import { isPromise } from "../../utility/helper";
import { animationPromiseGenerator } from "./animation-effects";
const sequences = {};
let rootElement = null;
function initialize(element) {
  rootElement = element;
}
function register(sequenceIdentifier, animationSequence) {
  sequences[sequenceIdentifier] = animationSequence;
}
function reset() {
  Object.keys(sequences).forEach((key) => delete sequences[key]);
}
async function play(sequenceIdentifier) {
  const sequence = sequences[sequenceIdentifier];
  if (sequence === undefined) {
    return new Promise((_, reject) => reject(new Error(`Sequence ${sequenceIdentifier} has not been registered`)));
  }
  if (!sequence.running) {
    sequence.promise = new Promise((resolve, reject) => {
      sequence.resolve = () => {
        sequence.running = false;
        resolve();
      };
      sequence.reject = (value) => {
        sequence.running = false;
        reject(value);
      };
      sequence.running = true;
      applyCurrentAnimationSequenceStep(sequence);
    });
  }
  return sequence.promise;
}
function finishAnimationSequence(sequence) {
  var _a;
  sequence.currentStepIndex = 0;
  (_a = sequence.resolve) === null || _a === void 0 ? void 0 : _a.call(sequence, null);
  sequence.promise = undefined;
}
async function applyCurrentAnimationSequenceStep(sequence) {
  var _a;
  if (sequence.currentStepIndex >= sequence.steps.length) {
    finishAnimationSequence(sequence);
    return;
  }
  const sequenceStep = sequence.steps[sequence.currentStepIndex];
  const promises = [];
  for (const animation of sequenceStep) {
    promises.push(executeAnimation(animation));
  }
  try {
    await Promise.all(promises);
  }
  catch (error) {
    (_a = sequence.reject) === null || _a === void 0 ? void 0 : _a.call(sequence, error);
    return;
  }
  sequence.currentStepIndex += 1;
  setTimeout(() => applyCurrentAnimationSequenceStep(sequence), 0);
}
async function executeAnimation({ onStart, onEnd, animation, elementSelector }) {
  if (rootElement === null) {
    throw new Error('No root element present');
  }
  if (onStart) {
    const maybePromise = onStart();
    if (isPromise(maybePromise)) {
      await maybePromise;
    }
  }
  const animatedElements = Array.from(rootElement.querySelectorAll(elementSelector));
  const animationExecutors = [];
  for (const element of animatedElements) {
    const animationPromiseEffect = animationPromiseGenerator(element, animation);
    animationExecutors.push(animationPromiseEffect);
  }
  await Promise.all(animationExecutors);
  if (onEnd) {
    const maybePromise = onEnd();
    if (isPromise(maybePromise)) {
      await maybePromise;
    }
  }
}
function isPlaying(sequenceIdentifier) {
  const sequence = sequences[sequenceIdentifier];
  if (sequence === undefined) {
    throw new Error(`Sequence ${sequenceIdentifier} has not been registered`);
  }
  return sequence.promise !== undefined;
}
function makeSequence(sequenceSteps, animationDefaults) {
  return {
    steps: sequenceSteps.map((step) => step.map((animation) => (Object.assign(Object.assign({}, animationDefaults), animation)))),
    currentStepIndex: 0,
    running: false
  };
}
export default {
  initialize,
  play,
  isPlaying,
  register,
  reset
};
export { makeSequence };
//# sourceMappingURL=animation-manager.js.map
