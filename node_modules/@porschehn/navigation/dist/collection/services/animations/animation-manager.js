import { getHTMLElement, getRootElement, isPromise } from "../../utility/helper";
const animationRegistry = {};
const sequences = {};
const animationTimeoutDurationMs = 1000;
function initialize() {
  getRootElement().addEventListener('transitionend', animationEndListener);
  getRootElement().addEventListener('animationend', animationEndListener);
}
function register(sequenceIdentifier, animationSequence) {
  sequences[sequenceIdentifier] = animationSequence;
}
function reset() {
  Object.keys(sequences).forEach((key) => delete sequences[key]);
}
async function play(sequenceIdentifier) {
  const sequence = sequences[sequenceIdentifier];
  if (sequence === undefined) {
    return new Promise((_, reject) => reject(new Error(`Sequence ${sequenceIdentifier} has not been registered`)));
  }
  if (!sequence.running) {
    sequence.promise = new Promise((resolve, reject) => {
      sequence.resolve = () => {
        sequence.running = false;
        resolve();
      };
      sequence.reject = (value) => {
        sequence.running = false;
        reject(value);
      };
      sequence.running = true;
      applyCurrentAnimationSequenceStep(sequence);
    });
  }
  return sequence.promise;
}
async function applyCurrentAnimationSequenceStep(sequence) {
  var _a;
  if (sequence.currentStepIndex >= sequence.steps.length) {
    finishAnimationSequence(sequence);
    return;
  }
  const sequenceStep = sequence.steps[sequence.currentStepIndex];
  const promises = [];
  for (const animation of sequenceStep) {
    promises.push(executeAnimation(animation));
  }
  try {
    await Promise.all(promises);
  }
  catch (error) {
    (_a = sequence.reject) === null || _a === void 0 ? void 0 : _a.call(sequence, error);
    return;
  }
  sequence.currentStepIndex += 1;
  setTimeout(() => applyCurrentAnimationSequenceStep(sequence), 0);
}
function finishAnimationSequence(sequence) {
  var _a;
  sequence.currentStepIndex = 0;
  (_a = sequence.resolve) === null || _a === void 0 ? void 0 : _a.call(sequence, null);
  sequence.promise = undefined;
}
function animationEndListener(event) {
  const target = getHTMLElement(event.target);
  if (target === null) {
    throw new Error(`${event.type} event target is null`);
  }
  const id = target.dataset.phnAmId;
  if (id !== undefined && id !== null) {
    finishAnimationPromise(id, target);
  }
}
async function executeAnimation({ onStart, onEnd, animation, elementSelector }) {
  if (onStart) {
    const maybePromise = onStart();
    if (isPromise(maybePromise)) {
      await maybePromise;
    }
  }
  const animatedElements = Array.from(getRootElement().querySelectorAll(elementSelector));
  const animationExecutors = [];
  for (const element of animatedElements) {
    const animationPromiseEffect = generateAndCleanUpAnimationPromise(animationPromiseGenerator)(element, animation);
    animationExecutors.push(animationPromiseEffect);
  }
  await Promise.all(animationExecutors);
  if (onEnd) {
    const maybePromise = onEnd();
    if (isPromise(maybePromise)) {
      await maybePromise;
    }
  }
}
function generateAndCleanUpAnimationPromise(animationPromiseGenerator) {
  return async function (element, animation) {
    const { cleanUpBeforeAnimation, cleanUpAfterAnimation } = animation;
    const animationPromise = animationPromiseGenerator(element, animation);
    if (typeof cleanUpBeforeAnimation === 'function') {
      const maybePromise = cleanUpBeforeAnimation(element);
      if (isPromise(maybePromise)) {
        await maybePromise;
      }
    }
    await animationPromise;
    if (typeof cleanUpAfterAnimation === 'function') {
      const maybePromise = cleanUpAfterAnimation(element);
      if (isPromise(maybePromise)) {
        await maybePromise;
      }
    }
    if (cleanUpAfterAnimation !== false) {
      // only not remove class if cleanUpAfterAnimation is explicitely set to false
      element.classList.remove(animation.className);
    }
  };
}
const animationPromiseGenerator = (element, animation) => {
  const id = Math.floor(Math.random() * 1e7);
  element.classList.add(animation.className);
  element.dataset.phnAmId = id.toString();
  let resolve;
  let reject;
  let timeout;
  const promise = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
    timeout = setTimeout(() => {
      // eslint-disable-next-line no-console
      console.warn(`Animation with className ${animation.className} didn't finish after ${animationTimeoutDurationMs}ms. Forcefully finishing animation and continuing with the rest of the sequence.`);
      finishAnimationPromise(String(id), element);
    }, animationTimeoutDurationMs);
  });
  animationRegistry[id] = { animation, resolve, reject, promise, timeout };
  return promise;
};
function finishAnimationPromise(phnAmId, target) {
  const { resolve, timeout } = animationRegistry[phnAmId];
  clearTimeout(timeout);
  delete animationRegistry[phnAmId];
  delete target.dataset.phnAmId;
  resolve();
}
function isPlaying(sequenceIdentifier) {
  const sequence = sequences[sequenceIdentifier];
  if (sequence === undefined) {
    throw new Error(`Sequence ${sequenceIdentifier} has not been registered`);
  }
  return sequence.promise !== undefined;
}
function makeSequence(sequenceSteps, animationDefaults) {
  return {
    steps: sequenceSteps.map((step) => step.map((animation) => (Object.assign(Object.assign({}, animationDefaults), animation)))),
    currentStepIndex: 0,
    running: false
  };
}
export default {
  initialize,
  play,
  isPlaying,
  register,
  reset
};
export { makeSequence };
//# sourceMappingURL=animation-manager.js.map
