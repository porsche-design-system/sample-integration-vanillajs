import { h } from "@stencil/core";
import { newSpecPage } from "@stencil/core/testing";
import animationManager, { makeSequence } from "./animation-manager";
describe('Animation manager', () => {
  const elementSelector = '#animate';
  const testSequence = {
    sequenceIdentifier: 'abcdef',
    animationSequence: makeSequence([[{ elementSelector, animation: { name: 'growElement' } }]])
  };
  beforeEach(() => {
    jest.spyOn(animationManager, 'initialize').mockRestore();
    jest.spyOn(animationManager, 'register').mockRestore();
    jest.spyOn(animationManager, 'play').mockRestore();
    jest.spyOn(animationManager, 'isPlaying').mockRestore();
    animationManager.reset();
  });
  // TODO MX/OF (16.02.23): we couldn't get it to work with jest's .toThrow, should revisit this in the future
  const expectAsyncThrows = async (throwingMethod) => {
    try {
      await throwingMethod();
    }
    catch (error) {
      return error;
    }
    return null;
  };
  it("Throws an error if wasn't initialized", async () => {
    animationManager.register(testSequence.sequenceIdentifier, testSequence.animationSequence);
    const expectedError = await expectAsyncThrows(async () => {
      await animationManager.play(testSequence.sequenceIdentifier);
    });
    expect(expectedError).toHaveProperty('message', 'No root element present');
  });
  it('Should not throw an error when playing after initializing', async () => {
    animationManager.register(testSequence.sequenceIdentifier, testSequence.animationSequence);
    const page = await newSpecPage({
      components: [],
      template: () => (h("div", null, h("div", { id: elementSelector.replace('#', '') })))
    });
    if (page.root)
      animationManager.initialize(page.root);
    const expectedError = await expectAsyncThrows(async () => {
      await animationManager.play(testSequence.sequenceIdentifier);
    });
    expect(expectedError).toBeNull();
  });
  it('Should throw error if not registered sequence is played', async () => {
    const expectedError = await expectAsyncThrows(async () => {
      await animationManager.play(testSequence.sequenceIdentifier);
    });
    expect(expectedError).toHaveProperty('message', `Sequence ${testSequence.sequenceIdentifier} has not been registered`);
  });
  it('Should call onStart and onEnd callbacks', async () => {
    const onStartMock = jest.fn(() => Promise.resolve());
    const onEndMock = jest.fn(() => Promise.resolve());
    const sequenceWithStartCallback = Object.assign(Object.assign({}, testSequence), { animationSequence: Object.assign(Object.assign({}, testSequence.animationSequence), { steps: [
          [
            Object.assign(Object.assign({}, testSequence.animationSequence.steps[0][0]), { onStart: onStartMock, onEnd: onEndMock })
          ]
        ] }) });
    animationManager.register(sequenceWithStartCallback.sequenceIdentifier, sequenceWithStartCallback.animationSequence);
    const page = await newSpecPage({
      components: [],
      template: () => (h("div", null, h("div", { id: elementSelector.replace('#', '') })))
    });
    if (page.root)
      animationManager.initialize(page.root);
    await animationManager.play(sequenceWithStartCallback.sequenceIdentifier);
    expect(onStartMock).toHaveBeenCalledTimes(1);
    expect(onEndMock).toHaveBeenCalledTimes(1);
  });
  it('Should call two animations simultaneously', async () => {
    var _a, _b;
    const onStartMock = jest.fn(() => Promise.resolve());
    const onEndMock = jest.fn(() => Promise.resolve());
    const testSequence = {
      sequenceIdentifier: 'abcdef',
      animationSequence: makeSequence([
        [
          { elementSelector, animation: { name: 'growElement' }, onStart: onStartMock },
          { elementSelector, animation: { name: 'slideOutToRightRelative' }, onEnd: onEndMock }
        ]
      ])
    };
    animationManager.register(testSequence.sequenceIdentifier, testSequence.animationSequence);
    const page = await newSpecPage({
      components: [],
      template: () => (h("div", null, h("div", { id: elementSelector.replace('#', '') })))
    });
    if (page.root)
      animationManager.initialize(page.root);
    await animationManager.play(testSequence.sequenceIdentifier);
    expect(onStartMock).toHaveBeenCalledTimes(1);
    expect(onEndMock).toHaveBeenCalledTimes(1);
    const animatedStyle = (_b = (_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector(elementSelector)) === null || _b === void 0 ? void 0 : _b.getAttribute('style');
    expect(animatedStyle).toContain('width: 100%;');
    expect(animatedStyle).toContain('right: calc(-100%);');
    expect(animatedStyle).toContain('position: relative;');
  });
  it('Should call two animation steps', async () => {
    var _a;
    let resolveEndMock;
    let resolvePromise;
    const promise = new Promise((resolve) => {
      resolvePromise = resolve;
    });
    const onEndMock = jest.fn(() => {
      resolvePromise(null);
      return new Promise((resolve) => {
        resolveEndMock = resolve;
      });
    });
    const sequenceWithStartCallback = Object.assign(Object.assign({}, testSequence), { animationSequence: Object.assign(Object.assign({}, testSequence.animationSequence), { steps: [
          [
            Object.assign(Object.assign({}, testSequence.animationSequence.steps[0][0]), { onEnd: onEndMock })
          ],
          [{ elementSelector, animation: { name: 'slideOutToRightRelative' } }]
        ] }) });
    animationManager.register(sequenceWithStartCallback.sequenceIdentifier, sequenceWithStartCallback.animationSequence);
    const page = await newSpecPage({
      components: [],
      template: () => (h("div", null, h("div", { id: elementSelector.replace('#', '') })))
    });
    if (page.root)
      animationManager.initialize(page.root);
    const playPromise = animationManager.play(sequenceWithStartCallback.sequenceIdentifier);
    await promise;
    expect(onEndMock).toHaveBeenCalledTimes(1);
    const animatedElement = (_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector(elementSelector);
    expect(animatedElement === null || animatedElement === void 0 ? void 0 : animatedElement.getAttribute('style')).toContain('width: 100%;');
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    resolveEndMock === null || resolveEndMock === void 0 ? void 0 : resolveEndMock(null);
    await playPromise;
    expect(animatedElement === null || animatedElement === void 0 ? void 0 : animatedElement.getAttribute('style')).toContain('right: calc(-100%);');
    expect(animatedElement === null || animatedElement === void 0 ? void 0 : animatedElement.getAttribute('style')).toContain('position: relative;');
  });
  it('Should return true from isPlaying while sequence is playing', async () => {
    var _a;
    const resolvers = {};
    const promise = new Promise((resolve) => {
      resolvers['onEndLockPromiseResolver'] = resolve;
    });
    const onEndMock = jest.fn(() => {
      resolvers['onEndLockPromiseResolver']();
      return new Promise((resolve) => {
        resolvers['onEndResolver'] = resolve;
      });
    });
    const sequenceWithStartCallback = Object.assign(Object.assign({}, testSequence), { animationSequence: Object.assign(Object.assign({}, testSequence.animationSequence), { steps: [
          [
            Object.assign(Object.assign({}, testSequence.animationSequence.steps[0][0]), { onEnd: onEndMock })
          ]
        ] }) });
    animationManager.register(sequenceWithStartCallback.sequenceIdentifier, sequenceWithStartCallback.animationSequence);
    const page = await newSpecPage({
      components: [],
      template: () => (h("div", null, h("div", { id: elementSelector.replace('#', '') })))
    });
    if (page.root)
      animationManager.initialize(page.root);
    const playPromise = animationManager.play(sequenceWithStartCallback.sequenceIdentifier);
    await promise;
    expect(animationManager.isPlaying(sequenceWithStartCallback.sequenceIdentifier)).toBeTruthy();
    (_a = resolvers['onEndResolver']) === null || _a === void 0 ? void 0 : _a.call(resolvers);
    await playPromise;
    expect(animationManager.isPlaying(sequenceWithStartCallback.sequenceIdentifier)).toBeFalsy();
  });
});
//# sourceMappingURL=animation-manager.spec.js.map
