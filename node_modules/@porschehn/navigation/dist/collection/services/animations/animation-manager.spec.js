import { h } from "@stencil/core";
import { newSpecPage } from "@stencil/core/testing";
import { endAnimation } from "../../test/element-helpers";
import { getHTMLElement, loadRootElement } from "../../utility/helper";
import animationManager, { makeSequence } from "./animation-manager";
describe('Animation manager', () => {
  const elementSelector = '#animate';
  const testSequence = {
    sequenceIdentifier: 'abcdef',
    animationSequence: makeSequence([[{ elementSelector, animation: { className: 'growElement' } }]])
  };
  beforeEach(() => {
    jest.spyOn(animationManager, 'initialize').mockRestore();
    jest.spyOn(animationManager, 'register').mockRestore();
    jest.spyOn(animationManager, 'play').mockRestore();
    jest.spyOn(animationManager, 'isPlaying').mockRestore();
    animationManager.reset();
  });
  // TODO MX/OF (16.02.23): we couldn't get it to work with jest's .toThrow, should revisit this in the future
  const expectAsyncThrows = async (throwingMethod) => {
    try {
      await throwingMethod();
    }
    catch (error) {
      return error;
    }
    return null;
  };
  const endTestAnimation = (page, className) => {
    var _a;
    const element = getHTMLElement((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector(elementSelector));
    if (!endAnimation(element, className || '')) {
      throw new Error('Test animation element was not found');
    }
  };
  it("Throws an error if wasn't initialized", async () => {
    animationManager.register(testSequence.sequenceIdentifier, testSequence.animationSequence);
    const expectedError = await expectAsyncThrows(async () => {
      await animationManager.play(testSequence.sequenceIdentifier);
    });
    expect(expectedError).toHaveProperty('message', 'No root element present');
  });
  it('Should not throw an error when playing after initializing', async () => {
    animationManager.register(testSequence.sequenceIdentifier, testSequence.animationSequence);
    const page = await newSpecPage({
      components: [],
      template: () => (h("div", null, h("div", { id: elementSelector.replace('#', '') })))
    });
    if (page.root)
      loadRootElement(page.root);
    const expectedError = await expectAsyncThrows(async () => {
      const animationPromise = animationManager.play(testSequence.sequenceIdentifier);
      endTestAnimation(page);
      await animationPromise;
    });
    expect(expectedError).toBeNull();
  });
  it('Should throw error if not registered sequence is played', async () => {
    const expectedError = await expectAsyncThrows(async () => {
      await animationManager.play(testSequence.sequenceIdentifier);
    });
    expect(expectedError).toHaveProperty('message', `Sequence ${testSequence.sequenceIdentifier} has not been registered`);
  });
  it('Should call onStart and onEnd callbacks', async () => {
    const onStartMock = jest.fn(() => Promise.resolve());
    const onEndMock = jest.fn(() => Promise.resolve());
    let cleanUpBeforeAnimationResolve;
    const cleanUpBeforeAnimationPromise = new Promise((resolve) => (cleanUpBeforeAnimationResolve = resolve));
    const sequenceWithStartCallback = Object.assign(Object.assign({}, testSequence), { animationSequence: Object.assign(Object.assign({}, testSequence.animationSequence), { steps: [
          [
            Object.assign(Object.assign({}, testSequence.animationSequence.steps[0][0]), { animation: Object.assign(Object.assign({}, testSequence.animationSequence.steps[0][0].animation), { cleanUpBeforeAnimation: () => cleanUpBeforeAnimationResolve() }), onStart: onStartMock, onEnd: onEndMock })
          ]
        ] }) });
    animationManager.register(sequenceWithStartCallback.sequenceIdentifier, sequenceWithStartCallback.animationSequence);
    const page = await newSpecPage({
      components: [],
      template: () => (h("div", null, h("div", { id: elementSelector.replace('#', '') })))
    });
    if (page.root)
      loadRootElement(page.root);
    const animationPromise = animationManager.play(sequenceWithStartCallback.sequenceIdentifier);
    await cleanUpBeforeAnimationPromise;
    endTestAnimation(page);
    await animationPromise;
    expect(onStartMock).toHaveBeenCalledTimes(1);
    expect(onEndMock).toHaveBeenCalledTimes(1);
  });
  xit('Should call two animations simultaneously', async () => {
    var _a, _b;
    const onStartMock = jest.fn(() => Promise.resolve());
    const onEndMock = jest.fn(() => Promise.resolve());
    const cleanUpBeforeAnimationResolves = [];
    const cleanUpBeforeAnimationPromises = [
      new Promise((resolve) => cleanUpBeforeAnimationResolves.push(resolve)),
      new Promise((resolve) => cleanUpBeforeAnimationResolves.push(resolve))
    ];
    const testSequence = {
      sequenceIdentifier: 'abcdef',
      animationSequence: makeSequence([
        [
          {
            elementSelector,
            animation: { className: 'growElement', cleanUpBeforeAnimation: () => cleanUpBeforeAnimationResolves[0]() },
            onStart: onStartMock
          },
          {
            elementSelector,
            animation: {
              className: 'slideOutToRightRelative',
              cleanUpBeforeAnimation: () => cleanUpBeforeAnimationResolves[1]()
            },
            onEnd: onEndMock
          }
        ]
      ])
    };
    animationManager.register(testSequence.sequenceIdentifier, testSequence.animationSequence);
    const page = await newSpecPage({
      components: [],
      template: () => (h("div", null, h("div", { id: elementSelector.replace('#', '') })))
    });
    if (page.root)
      loadRootElement(page.root);
    const animationPromise = animationManager.play(testSequence.sequenceIdentifier);
    await Promise.all(cleanUpBeforeAnimationPromises);
    endTestAnimation(page, '');
    endTestAnimation(page);
    await animationPromise;
    expect(onStartMock).toHaveBeenCalledTimes(1);
    expect(onEndMock).toHaveBeenCalledTimes(1);
    const animatedStyle = (_b = (_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector(elementSelector)) === null || _b === void 0 ? void 0 : _b.getAttribute('style');
    expect(animatedStyle).toContain('width: 100%;');
    expect(animatedStyle).toContain('right: calc(-100%);');
    expect(animatedStyle).toContain('position: relative;');
  });
  it('Should call two animation steps', async () => {
    var _a;
    const cleanUpBeforeAnimationResolves = [];
    const cleanUpBeforeAnimationPromises = [
      new Promise((resolve) => cleanUpBeforeAnimationResolves.push(resolve)),
      new Promise((resolve) => cleanUpBeforeAnimationResolves.push(resolve))
    ];
    const sequenceWithStartCallback = Object.assign(Object.assign({}, testSequence), { animationSequence: Object.assign(Object.assign({}, testSequence.animationSequence), { steps: [
          [
            Object.assign(Object.assign({}, testSequence.animationSequence.steps[0][0]), { animation: Object.assign(Object.assign({}, testSequence.animationSequence.steps[0][0].animation), { cleanUpBeforeAnimation: () => cleanUpBeforeAnimationResolves[0]() }) })
          ],
          [
            {
              elementSelector,
              animation: {
                className: 'slideOutToRightRelative',
                cleanUpBeforeAnimation: () => cleanUpBeforeAnimationResolves[1]()
              }
            }
          ]
        ] }) });
    animationManager.register(sequenceWithStartCallback.sequenceIdentifier, sequenceWithStartCallback.animationSequence);
    const page = await newSpecPage({
      components: [],
      template: () => (h("div", null, h("div", { id: elementSelector.replace('#', '') })))
    });
    if (page.root)
      loadRootElement(page.root);
    const playPromise = animationManager.play(sequenceWithStartCallback.sequenceIdentifier);
    await cleanUpBeforeAnimationPromises[0];
    const animatedElement = (_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector(elementSelector);
    expect(animatedElement === null || animatedElement === void 0 ? void 0 : animatedElement.getAttribute('class')).toContain(sequenceWithStartCallback.animationSequence.steps[0][0].animation.className);
    endTestAnimation(page);
    await cleanUpBeforeAnimationPromises[1];
    expect(animatedElement === null || animatedElement === void 0 ? void 0 : animatedElement.getAttribute('class')).toContain(sequenceWithStartCallback.animationSequence.steps[1][0].animation.className);
    endTestAnimation(page);
    await playPromise;
  });
  it('Should return true from isPlaying while sequence is playing', async () => {
    var _a;
    const resolvers = {};
    const promise = new Promise((resolve) => {
      resolvers['onEndLockPromiseResolver'] = resolve;
    });
    const onEndMock = jest.fn(() => {
      resolvers['onEndLockPromiseResolver']();
      return new Promise((resolve) => {
        resolvers['onEndResolver'] = resolve;
      });
    });
    const sequenceWithStartCallback = Object.assign(Object.assign({}, testSequence), { animationSequence: Object.assign(Object.assign({}, testSequence.animationSequence), { steps: [
          [
            Object.assign(Object.assign({}, testSequence.animationSequence.steps[0][0]), { onEnd: onEndMock })
          ]
        ] }) });
    animationManager.register(sequenceWithStartCallback.sequenceIdentifier, sequenceWithStartCallback.animationSequence);
    const page = await newSpecPage({
      components: [],
      template: () => (h("div", null, h("div", { id: elementSelector.replace('#', '') })))
    });
    if (page.root)
      loadRootElement(page.root);
    const playPromise = animationManager.play(sequenceWithStartCallback.sequenceIdentifier);
    endTestAnimation(page);
    await promise;
    expect(animationManager.isPlaying(sequenceWithStartCallback.sequenceIdentifier)).toBeTruthy();
    (_a = resolvers['onEndResolver']) === null || _a === void 0 ? void 0 : _a.call(resolvers);
    await playPromise;
    expect(animationManager.isPlaying(sequenceWithStartCallback.sequenceIdentifier)).toBeFalsy();
  });
});
//# sourceMappingURL=animation-manager.spec.js.map
