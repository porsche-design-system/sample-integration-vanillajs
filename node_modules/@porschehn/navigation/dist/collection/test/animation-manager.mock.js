/* istanbul ignore file */
var __rest = (this && this.__rest) || function (s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
import { isPromise } from "../utility/helper";
import { getAnimationEffect } from "../services/animations/animation-effects";
const sequences = {};
let rootElement = null;
function initialize(element) {
  rootElement = element;
}
function register(sequenceIdentifier, animationSequence) {
  sequences[sequenceIdentifier] = animationSequence;
}
function reset() {
  Object.keys(sequences).forEach((key) => delete sequences[key]);
}
async function play(sequenceIdentifier) {
  const sequence = sequences[sequenceIdentifier];
  if (sequence === undefined) {
    return new Promise((_, reject) => reject(new Error(`Sequence ${sequenceIdentifier} has not been registered`)));
  }
  sequence.promise = new Promise(() => {
    // do nothing
  });
  for (let i = 0; i < sequence.steps.length; i++) {
    sequence.currentStepIndex = i;
    await applyCurrentAnimationSequenceStep(sequence);
  }
  finishAnimationSequence(sequence);
  return sequence.promise;
}
function finishAnimationSequence(sequence) {
  var _a;
  sequence.currentStepIndex = 0;
  (_a = sequence.resolve) === null || _a === void 0 ? void 0 : _a.call(sequence, null);
  sequence.promise = undefined;
}
async function applyCurrentAnimationSequenceStep(sequence) {
  if (sequence.currentStepIndex >= sequence.steps.length) {
    finishAnimationSequence(sequence);
    return;
  }
  const sequenceStep = sequence.steps[sequence.currentStepIndex];
  const promises = [];
  for (const animation of sequenceStep) {
    promises.push(executeAnimation(animation));
  }
  await Promise.all(promises);
}
function skipAnimationToEnd(element, animation) {
  const { duration: _, cleanUpAfterAnimation = false } = animation, effect = __rest(animation, ["duration", "cleanUpAfterAnimation"]);
  if (cleanUpAfterAnimation) {
    element.removeAttribute('style');
    return;
  }
  const playEffect = getAnimationEffect(animation.name);
  playEffect(element, 1, effect);
}
async function executeAnimation({ onStart, onEnd, animation, elementSelector }) {
  if (rootElement === null) {
    throw new Error('No root element present');
  }
  if (onStart) {
    const maybePromise = onStart();
    if (isPromise(maybePromise)) {
      await maybePromise;
    }
  }
  const animatedElements = Array.from(rootElement.querySelectorAll(elementSelector));
  for (const element of animatedElements) {
    skipAnimationToEnd(element, animation);
  }
  if (onEnd) {
    const maybePromise = onEnd();
    if (isPromise(maybePromise)) {
      await maybePromise;
    }
  }
}
function isPlaying(sequenceIdentifier) {
  const sequence = sequences[sequenceIdentifier];
  if (sequence === undefined) {
    throw new Error(`Sequence ${sequenceIdentifier} has not been registered`);
  }
  return sequence.promise !== undefined;
}
const mock = {
  initialize,
  play,
  register,
  isPlaying,
  reset
};
export default mock;
//# sourceMappingURL=animation-manager.mock.js.map
