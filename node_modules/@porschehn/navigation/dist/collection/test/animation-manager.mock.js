/* istanbul ignore file */
import { getRootElement, isPromise } from "../utility/helper";
const sequences = {};
function initialize() {
  return;
}
function register(sequenceIdentifier, animationSequence) {
  sequences[sequenceIdentifier] = animationSequence;
}
function reset() {
  Object.keys(sequences).forEach((key) => delete sequences[key]);
}
async function play(sequenceIdentifier) {
  const sequence = sequences[sequenceIdentifier];
  if (sequence === undefined) {
    return new Promise((_, reject) => reject(new Error(`Sequence ${sequenceIdentifier} has not been registered`)));
  }
  if (sequence.promise !== undefined) {
    return sequence.promise;
  }
  sequence.promise = new Promise((resolve) => {
    sequence.resolve = () => {
      resolve();
    };
  });
  for (let i = 0; i < sequence.steps.length; i++) {
    sequence.currentStepIndex = i;
    await applyCurrentAnimationSequenceStep(sequence);
  }
  finishAnimationSequence(sequence);
  return sequence.promise;
}
function finishAnimationSequence(sequence) {
  var _a;
  sequence.currentStepIndex = 0;
  (_a = sequence.resolve) === null || _a === void 0 ? void 0 : _a.call(sequence, null);
  sequence.promise = undefined;
}
async function applyCurrentAnimationSequenceStep(sequence) {
  if (sequence.currentStepIndex >= sequence.steps.length) {
    finishAnimationSequence(sequence);
    return;
  }
  const sequenceStep = sequence.steps[sequence.currentStepIndex];
  const promises = [];
  for (const animation of sequenceStep) {
    promises.push(executeAnimation(animation));
  }
  await Promise.all(promises);
}
async function skipAnimationToEnd(element, animation) {
  const { cleanUpAfterAnimation, cleanUpBeforeAnimation = false } = animation;
  if (typeof cleanUpBeforeAnimation === 'function') {
    const maybePromise = cleanUpBeforeAnimation(element);
    if (isPromise(maybePromise)) {
      await maybePromise;
    }
  }
  if (typeof cleanUpAfterAnimation === 'function') {
    const maybePromise = cleanUpAfterAnimation(element);
    if (isPromise(maybePromise)) {
      await maybePromise;
    }
  }
  if (cleanUpAfterAnimation !== false) {
    // only not remove class if cleanUpAfterAnimation is explicitely set to false
    element.classList.remove(animation.className);
  }
}
async function executeAnimation({ onStart, onEnd, animation, elementSelector }) {
  const rootElement = getRootElement();
  if (rootElement === null) {
    throw new Error('No root element present');
  }
  if (onStart) {
    const maybePromise = onStart();
    if (isPromise(maybePromise)) {
      await maybePromise;
    }
  }
  const animatedElements = Array.from(rootElement.querySelectorAll(elementSelector));
  const animationPromises = animatedElements.map((element) => skipAnimationToEnd(element, animation));
  await Promise.all(animationPromises);
  if (onEnd) {
    const maybePromise = onEnd();
    if (isPromise(maybePromise)) {
      await maybePromise;
    }
  }
}
function isPlaying(sequenceIdentifier) {
  const sequence = sequences[sequenceIdentifier];
  if (sequence === undefined) {
    throw new Error(`Sequence ${sequenceIdentifier} has not been registered`);
  }
  return sequence.promise !== undefined;
}
const mock = {
  initialize,
  play,
  register,
  isPlaying,
  reset
};
export default mock;
//# sourceMappingURL=animation-manager.mock.js.map
