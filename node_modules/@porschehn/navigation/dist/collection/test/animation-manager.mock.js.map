{"version":3,"file":"animation-manager.mock.js","sourceRoot":"","sources":["../../../src/test/animation-manager.mock.ts"],"names":[],"mappings":"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","sourcesContent":["/* istanbul ignore file */\n\nimport { getRootElement, isPromise } from '../utility/helper';\nimport actualAnimationManager, {\n  AnimationGeneratorType,\n  AnimationSequence,\n  NaviAnimation,\n  SequenceIdentifier\n} from '../services/animations/animation-manager';\n\nconst sequences: {\n  [identifier in SequenceIdentifier]?: AnimationSequence;\n} = {};\n\nfunction initialize(): void {\n  return;\n}\n\nfunction register(sequenceIdentifier: string, animationSequence: AnimationSequence): void {\n  sequences[sequenceIdentifier] = animationSequence;\n}\n\nfunction reset(): void {\n  Object.keys(sequences).forEach((key) => delete sequences[key]);\n}\n\nasync function play(sequenceIdentifier: string): Promise<unknown> {\n  const sequence = sequences[sequenceIdentifier];\n\n  if (sequence === undefined) {\n    return new Promise((_, reject) => reject(new Error(`Sequence ${sequenceIdentifier} has not been registered`)));\n  }\n\n  if (sequence.promise !== undefined) {\n    return sequence.promise;\n  }\n\n  sequence.promise = new Promise<void>((resolve) => {\n    sequence.resolve = () => {\n      resolve();\n    };\n  });\n\n  for (let i = 0; i < sequence.steps.length; i++) {\n    sequence.currentStepIndex = i;\n\n    await applyCurrentAnimationSequenceStep(sequence);\n  }\n\n  finishAnimationSequence(sequence);\n\n  return sequence.promise;\n}\n\nfunction finishAnimationSequence(sequence: AnimationSequence) {\n  sequence.currentStepIndex = 0;\n  sequence.resolve?.(null);\n  sequence.promise = undefined;\n}\n\nasync function applyCurrentAnimationSequenceStep(sequence: AnimationSequence): Promise<void> {\n  if (sequence.currentStepIndex >= sequence.steps.length) {\n    finishAnimationSequence(sequence);\n    return;\n  }\n\n  const sequenceStep = sequence.steps[sequence.currentStepIndex];\n\n  const promises = [];\n  for (const animation of sequenceStep) {\n    promises.push(executeAnimation(animation));\n  }\n  await Promise.all(promises);\n}\n\nasync function skipAnimationToEnd(element: HTMLElement, animation: AnimationGeneratorType): Promise<void> {\n  const { cleanUpAfterAnimation, cleanUpBeforeAnimation = false } = animation;\n\n  if (typeof cleanUpBeforeAnimation === 'function') {\n    const maybePromise: void | Promise<void> = cleanUpBeforeAnimation(element);\n    if (isPromise<void>(maybePromise)) {\n      await maybePromise;\n    }\n  }\n\n  if (typeof cleanUpAfterAnimation === 'function') {\n    const maybePromise: void | Promise<void> = cleanUpAfterAnimation(element);\n    if (isPromise<void>(maybePromise)) {\n      await maybePromise;\n    }\n  }\n\n  if (cleanUpAfterAnimation !== false) {\n    // only not remove class if cleanUpAfterAnimation is explicitely set to false\n    element.classList.remove(animation.className);\n  }\n}\n\nasync function executeAnimation({ onStart, onEnd, animation, elementSelector }: NaviAnimation): Promise<void> {\n  const rootElement = getRootElement();\n  if (rootElement === null) {\n    throw new Error('No root element present');\n  }\n\n  if (onStart) {\n    const maybePromise = onStart();\n    if (isPromise<void>(maybePromise)) {\n      await maybePromise;\n    }\n  }\n\n  const animatedElements: HTMLElement[] = Array.from(rootElement.querySelectorAll(elementSelector));\n\n  const animationPromises: Promise<void>[] = animatedElements.map((element) => skipAnimationToEnd(element, animation));\n\n  await Promise.all(animationPromises);\n\n  if (onEnd) {\n    const maybePromise = onEnd();\n    if (isPromise<void>(maybePromise)) {\n      await maybePromise;\n    }\n  }\n}\n\nfunction isPlaying(sequenceIdentifier: SequenceIdentifier): boolean {\n  const sequence = sequences[sequenceIdentifier];\n\n  if (sequence === undefined) {\n    throw new Error(`Sequence ${sequenceIdentifier} has not been registered`);\n  }\n\n  return sequence.promise !== undefined;\n}\n\nconst mock: typeof actualAnimationManager = {\n  initialize,\n  play,\n  register,\n  isPlaying,\n  reset\n};\n\nexport default mock;\n"]}