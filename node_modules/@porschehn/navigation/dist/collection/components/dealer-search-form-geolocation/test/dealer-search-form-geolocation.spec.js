import { newSpecPage } from "@stencil/core/testing";
import { DealerSearchFormGeolocation } from "../dealer-search-form-geolocation";
import { dealerSearchResultsStore } from "../../../state/dealer-search-results-store";
import { getConfig, getHTMLElement, getHTMLInputElement } from "../../../utility/helper";
import { Environments } from "../../../entities/environment";
import * as el from "../../../test/element-helpers";
import { h } from "@stencil/core";
import { mockDealerContent, mockErrorContent, mockPPNDealerSearchResultsWithLocalizedAddress, mockPredictions } from "../../../test/test-data";
import * as dealerService from "../../../services/dealer-service";
import { navContentStore } from "../../../state/nav-content-store";
import mapsService from "../../../services/maps-service";
import { NaviError, NaviErrorTypes } from "../../../utility/navi-error";
import windowService from "../../../services/window-service";
import { AutocompleteSearchField } from "../../autocomplete-search-field/autocomplete-search-field";
import globalDataLayerService from "../../../services/analytics/global-data-layer-service";
import { ClickElementTypes, DEALER_SEARCH_DISPLAY_ELEMENT_ID, DEALER_SEARCH_TARGET_ELEMENT, ElementTypes, EventActions, GEOLOCATION_BUTTON_SEARCH_TERM } from "../../../utility/constants";
import analyticsManager from "../../../services/analytics/analytics-manager";
import { RoutingKeys } from "../../../entities/routing-key";
const defaultProps = {
  dealer: mockDealerContent,
  locale: 'xx-XX',
  errorContent: mockErrorContent
};
describe('dealer search Geolocation', () => {
  beforeEach(async () => {
    dealerSearchResultsStore.state.results = mockPPNDealerSearchResultsWithLocalizedAddress.map(({ ppnDealer: dealer }) => dealer.id);
    dealerSearchResultsStore.state.ppnDealers = mockPPNDealerSearchResultsWithLocalizedAddress.reduce((ppnDealers, dealerSearchResult) => (Object.assign(Object.assign({}, ppnDealers), { [dealerSearchResult.ppnDealer.id]: dealerSearchResult })), {});
  });
  const getPage = async () => {
    navContentStore.set('error', mockErrorContent);
    return await newSpecPage({
      components: [DealerSearchFormGeolocation, AutocompleteSearchField],
      template: () => h("phn-dealer-search-form-geolocation", Object.assign({}, defaultProps))
    });
  };
  describe('snapshot testing', () => {
    let page;
    beforeEach(async () => {
      page = await newSpecPage({
        components: [DealerSearchFormGeolocation],
        template: () => h("phn-dealer-search-form-geolocation", Object.assign({}, defaultProps))
      });
      jest.spyOn(page.rootInstance.debounceTimeout, 'set').mockImplementation(async (cb) => {
        if (typeof cb === 'function') {
          await cb();
        }
      });
    });
    it('should render dealer search geolocation form', async () => {
      navContentStore.set('dealer', mockDealerContent);
      expect(page.root).toMatchInlineSnapshot(`
        <phn-dealer-search-form-geolocation class="skeleton">
          <div class="input-container">
            <div class="skeleton-autocomplete-search-field"></div>
            <phn-autocomplete-search-field errormessage="" initialvalue="" placeholder="" style="display: none;"></phn-autocomplete-search-field>
          </div>
        </phn-dealer-search-form-geolocation>
      `);
    });
    it('should render dealer search geolocation form with geolocation button (with and without skeleton)', async () => {
      navContentStore.set('dealer', mockDealerContent);
      dealerSearchResultsStore.state.results = null;
      page.rootInstance.showGeolocationButton = true;
      await page.waitForChanges();
      expect(page.root).toMatchInlineSnapshot(`
        <phn-dealer-search-form-geolocation class="skeleton">
          <div class="input-container">
            <div class="skeleton-autocomplete-search-field"></div>
            <phn-autocomplete-search-field errormessage="" initialvalue="" placeholder="Location" style="display: none;"></phn-autocomplete-search-field>
          </div>
          <div class="or-container">
            <div class="skeleton-or-text"></div>
            <phn-p-text color="inherit" data-test-id="dealer-search-or-label" size="inherit" tag="div" style="display: none;">
              Or
            </phn-p-text>
            <div class="skeleton-geolocation-button"></div>
            <phn-p-button class="geolocation" icon="locate" variant="tertiary" style="display: none;">
              Current location
            </phn-p-button>
          </div>
        </phn-dealer-search-form-geolocation>
      `);
      page.rootInstance.showSkeleton = false;
      await page.waitForChanges();
      expect(page.root).toMatchInlineSnapshot(`
        <phn-dealer-search-form-geolocation>
          <div class="input-container">
            <phn-autocomplete-search-field errormessage="" initialvalue="" placeholder="Location"></phn-autocomplete-search-field>
          </div>
          <div class="or-container">
            <phn-p-text color="inherit" data-test-id="dealer-search-or-label" size="inherit" tag="div">
              Or
            </phn-p-text>
            <phn-p-button class="geolocation" icon="locate" variant="tertiary">
              Current location
            </phn-p-button>
          </div>
        </phn-dealer-search-form-geolocation>
      `);
    });
    it('should show spinner if the page is loading', async () => {
      navContentStore.state.dealer = mockDealerContent;
      page.rootInstance.isLoading = true;
      await page.waitForChanges();
      expect(page.root).toMatchInlineSnapshot(`
        <phn-dealer-search-form-geolocation class="skeleton">
          <div class="input-container">
            <div class="skeleton-autocomplete-search-field"></div>
            <phn-autocomplete-search-field errormessage="" initialvalue="" placeholder="Location" style="display: none;"></phn-autocomplete-search-field>
          </div>
          <div class="spinner">
            <phn-p-spinner size="medium"></phn-p-spinner>
          </div>
        </phn-dealer-search-form-geolocation>
      `);
    });
  });
  describe('Current location button', () => {
    it('should call dealer service when click on geolocation button', async () => {
      var _a, _b;
      const dealerServiceSpy = jest.spyOn(dealerService, 'getPPNDealers');
      dealerSearchResultsStore.state.results = null;
      const page = await getPage();
      (_b = getHTMLElement((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('.geolocation'))) === null || _b === void 0 ? void 0 : _b.click();
      await page.waitForChanges();
      expect(dealerServiceSpy).toBeCalledTimes(1);
      expect(dealerServiceSpy).toBeCalledWith(Environments.TEST, getConfig(Environments.TEST).DEALER_API_URL, { latitude: 0, longitude: 0 }, 'XX');
    });
    it('should fade out and remove geolocation button after it is clicked', async () => {
      var _a, _b;
      dealerSearchResultsStore.state.results = null;
      const page = await getPage();
      page.rootInstance.isLoading = true;
      await page.waitForChanges();
      const orContainer = getHTMLElement((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('.or-container'));
      expect(orContainer === null || orContainer === void 0 ? void 0 : orContainer.className).toContain('animate-out');
      el.endAnimation(orContainer, 'fadeOutToTop');
      await page.waitForChanges();
      expect(getHTMLElement((_b = page.root) === null || _b === void 0 ? void 0 : _b.querySelector('.or-container'))).toBeNull();
    });
  });
  describe('Autocompletion', () => {
    it('should clear results and show geolocation button when search input is removed', async () => {
      var _a, _b, _c, _d;
      navContentStore.set('dealer', mockDealerContent);
      const page = await getPage();
      const inputField = getHTMLInputElement((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('phn-autocomplete-search-field'));
      inputField === null || inputField === void 0 ? void 0 : inputField.dispatchEvent(new CustomEvent('submitSearch', { detail: mockPredictions[0] }));
      await page.waitForChanges();
      expect((_b = page.root) === null || _b === void 0 ? void 0 : _b.querySelectorAll('.dealer-card')).not.toBeNull();
      inputField === null || inputField === void 0 ? void 0 : inputField.dispatchEvent(new CustomEvent('clearSearch'));
      await page.waitForChanges();
      expect((_c = page.root) === null || _c === void 0 ? void 0 : _c.querySelector('.dealer-card')).toBeNull();
      expect((_d = page.root) === null || _d === void 0 ? void 0 : _d.querySelector('.geolocation')).not.toBeNull();
    });
    it('should animate dealer cards when clicking on the first prediction', async () => {
      var _a;
      const page = await getPage();
      jest.spyOn(page.rootInstance.debounceTimeout, 'set').mockImplementation(async (cb) => {
        if (typeof cb === 'function') {
          await cb();
        }
      });
      const inputField = getHTMLInputElement((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('phn-autocomplete-search-field'));
      dealerSearchResultsStore.dispose();
      inputField === null || inputField === void 0 ? void 0 : inputField.dispatchEvent(new CustomEvent('searchInput', { detail: 'Stu' }));
      page.rootInstance.predictions = mockPredictions;
      await page.waitForChanges();
      await page.waitForChanges();
      expect(page.rootInstance.animateResults).toBe(false);
      inputField === null || inputField === void 0 ? void 0 : inputField.dispatchEvent(new CustomEvent('submitSearch', { detail: mockPredictions[0] }));
      await page.waitForChanges();
      expect(page.rootInstance.animateResults).toBe(true);
    });
  });
  describe('Error handling', () => {
    it('displays general error when maps service throws error on init', async () => {
      var _a;
      jest.spyOn(mapsService, 'init').mockRejectedValue(new NaviError('maps error', NaviErrorTypes.GENERAL));
      const page = await getPage();
      await page.waitForChanges();
      const validationError = (_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('.error-message');
      expect(validationError === null || validationError === void 0 ? void 0 : validationError.innerHTML).toMatchInlineSnapshot(`"<phn-p-inline-notification state=\\"error\\" description=\\"Wrong\\"></phn-p-inline-notification>"`);
    });
    it('displays geolocation denied error when user blocks their prompt to provide their location', async () => {
      var _a, _b, _c;
      jest
        .spyOn(windowService, 'getNavigatorLatLong')
        .mockRejectedValue(new NaviError('some error', NaviErrorTypes.GEOLOCATION_DENIED));
      dealerSearchResultsStore.state.results = null;
      const page = await getPage();
      (_b = getHTMLElement((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('.geolocation'))) === null || _b === void 0 ? void 0 : _b.click();
      await page.waitForChanges();
      const validationError = (_c = page.root) === null || _c === void 0 ? void 0 : _c.querySelector('.error-message');
      expect(validationError === null || validationError === void 0 ? void 0 : validationError.innerHTML).toMatchInlineSnapshot(`"<phn-p-inline-notification state=\\"error\\" description=\\"Geolocation denied\\"></phn-p-inline-notification>"`);
    });
    it('should clear geolocation denied error when user types in search field', async () => {
      var _a, _b, _c, _d;
      jest
        .spyOn(windowService, 'getNavigatorLatLong')
        .mockRejectedValue(new NaviError('some error', NaviErrorTypes.GEOLOCATION_DENIED));
      jest.spyOn(mapsService, 'getPredictions').mockResolvedValue(mockPredictions);
      dealerSearchResultsStore.state.results = null;
      const page = await getPage();
      jest.spyOn(page.rootInstance.debounceTimeout, 'set').mockImplementation(async (cb) => {
        if (typeof cb === 'function') {
          await cb();
        }
      });
      (_b = getHTMLElement((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('.geolocation'))) === null || _b === void 0 ? void 0 : _b.click();
      await page.waitForChanges();
      const autocompleteInput = getHTMLInputElement((_c = page.root) === null || _c === void 0 ? void 0 : _c.querySelector('phn-autocomplete-search-field'));
      autocompleteInput === null || autocompleteInput === void 0 ? void 0 : autocompleteInput.dispatchEvent(new CustomEvent('searchInput', { detail: 'Stu' }));
      await page.waitForChanges();
      const validationError = (_d = page.root) === null || _d === void 0 ? void 0 : _d.querySelector('.error-message');
      expect(validationError).toBeNull();
    });
    it('displays retry error when there is some issue with accessing the users location', async () => {
      var _a, _b, _c;
      jest
        .spyOn(windowService, 'getNavigatorLatLong')
        .mockRejectedValue(new NaviError('some error', NaviErrorTypes.RETRY));
      dealerSearchResultsStore.state.results = null;
      const page = await getPage();
      (_b = getHTMLElement((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('.geolocation'))) === null || _b === void 0 ? void 0 : _b.click();
      await page.waitForChanges();
      const validationError = (_c = page.root) === null || _c === void 0 ? void 0 : _c.querySelector('.error-message');
      expect(validationError === null || validationError === void 0 ? void 0 : validationError.innerHTML).toMatchInlineSnapshot(`"<phn-p-inline-notification state=\\"error\\" description=\\"Retry\\"></phn-p-inline-notification>"`);
    });
    it('displays invalid input error when there is no prediction that was submitted', async () => {
      var _a, _b;
      const page = await getPage();
      jest.spyOn(page.rootInstance.debounceTimeout, 'set').mockImplementation(async (cb) => {
        if (typeof cb === 'function') {
          await cb();
        }
      });
      jest.spyOn(mapsService, 'getPredictions').mockResolvedValue([]);
      const autocompleteInput = getHTMLElement((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('phn-autocomplete-search-field'));
      autocompleteInput === null || autocompleteInput === void 0 ? void 0 : autocompleteInput.dispatchEvent(new CustomEvent('searchInput', { detail: '?/**?' }));
      autocompleteInput === null || autocompleteInput === void 0 ? void 0 : autocompleteInput.dispatchEvent(new CustomEvent('submitSearch', { detail: null }));
      await page.waitForChanges();
      const validationError = (_b = page.root) === null || _b === void 0 ? void 0 : _b.querySelector('.error-message');
      expect(validationError === null || validationError === void 0 ? void 0 : validationError.innerHTML).toMatchInlineSnapshot(`"<phn-p-inline-notification state=\\"error\\" description=\\"Invalid input\\"></phn-p-inline-notification>"`);
      expect(page.rootInstance.predictions).toEqual([]);
    });
    it('displays invalid input error when the google api returns an invalid request status', async () => {
      var _a, _b, _c;
      const page = await getPage();
      jest.spyOn(page.rootInstance.debounceTimeout, 'set').mockImplementation(async (cb) => {
        if (typeof cb === 'function') {
          await cb();
        }
      });
      // makes sure there are predictions to then delete when the API does not return predictions on invalid request
      jest.spyOn(mapsService, 'getPredictions').mockResolvedValue(mockPredictions);
      const autocompleteInput = getHTMLInputElement((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('phn-autocomplete-search-field'));
      autocompleteInput === null || autocompleteInput === void 0 ? void 0 : autocompleteInput.dispatchEvent(new CustomEvent('searchInput', { detail: 'Stu' }));
      jest
        .spyOn(mapsService, 'getPredictions')
        .mockRejectedValue(new NaviError('some error', NaviErrorTypes.INVALID_INPUT));
      autocompleteInput === null || autocompleteInput === void 0 ? void 0 : autocompleteInput.dispatchEvent(new CustomEvent('searchInput', { detail: 'Stu$' }));
      // It only works with 2 waitForChanges. We assume this is because of the debounceTimeout
      await page.waitForChanges();
      await page.waitForChanges();
      const validationError = (_c = (_b = page.root) === null || _b === void 0 ? void 0 : _b.querySelector('phn-p-text-field-wrapper')) === null || _c === void 0 ? void 0 : _c.getAttribute('message');
      expect(validationError).toEqual(mockErrorContent.invalidInput);
      expect(page.rootInstance.predictions).toEqual([]);
    });
    it('displays no input error when the user submits search without input', async () => {
      var _a, _b, _c;
      const page = await getPage();
      jest.spyOn(page.rootInstance.debounceTimeout, 'set').mockImplementation(async (cb) => {
        if (typeof cb === 'function') {
          await cb();
        }
      });
      jest.spyOn(mapsService, 'getPredictions').mockResolvedValue([]);
      const autocompleteInput = getHTMLInputElement((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('phn-autocomplete-search-field'));
      autocompleteInput === null || autocompleteInput === void 0 ? void 0 : autocompleteInput.dispatchEvent(new CustomEvent('searchInput', { detail: '' }));
      autocompleteInput === null || autocompleteInput === void 0 ? void 0 : autocompleteInput.dispatchEvent(new CustomEvent('submitSearch', { detail: null }));
      // It only works with 2 waitForChanges. We assume this is because of the debounceTimeout
      await page.waitForChanges();
      await page.waitForChanges();
      const validationError = (_c = (_b = page.root) === null || _b === void 0 ? void 0 : _b.querySelector('phn-p-text-field-wrapper')) === null || _c === void 0 ? void 0 : _c.getAttribute('message');
      expect(validationError).toEqual(mockErrorContent.noInput);
    });
  });
  describe('Analytics', () => {
    beforeEach(async () => {
      jest.spyOn(dealerService, 'getPPNDealers').mockResolvedValue(mockPPNDealerSearchResultsWithLocalizedAddress);
      dealerSearchResultsStore.state.results = mockPPNDealerSearchResultsWithLocalizedAddress.map(({ ppnDealer: dealer }) => dealer.id);
      dealerSearchResultsStore.state.ppnDealers = mockPPNDealerSearchResultsWithLocalizedAddress.reduce((ppnDealers, dealerSearchResult) => (Object.assign(Object.assign({}, ppnDealers), { [dealerSearchResult.ppnDealer.id]: dealerSearchResult })), {});
      navContentStore.set('dealer', mockDealerContent);
    });
    it('emits DEALER_SEARCH_CLICK when autocomplete is submitted and DEALER_RESULTS_SCREEN_LOAD when results are returned', async () => {
      var _a, _b, _c;
      const page = await getPage();
      jest.spyOn(page.rootInstance.debounceTimeout, 'set').mockImplementation(async (cb) => {
        if (typeof cb === 'function') {
          await cb();
        }
      });
      const inputField = getHTMLInputElement((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('phn-autocomplete-search-field'));
      inputField === null || inputField === void 0 ? void 0 : inputField.dispatchEvent(new CustomEvent('searchInput', { detail: mockPredictions[0].text }));
      inputField === null || inputField === void 0 ? void 0 : inputField.dispatchEvent(new CustomEvent('submitSearch', { detail: mockPredictions[0] }));
      await page.waitForChanges();
      const dataLayer = globalDataLayerService.gdl.DataLayerStore;
      expect(dataLayer).toHaveLength(3);
      const clickEvent = globalDataLayerService.gdl.DataLayerStore[1];
      expect((_b = clickEvent.context) === null || _b === void 0 ? void 0 : _b.eventAction).toEqual(EventActions.DEALER_SEARCH_CLICK);
      expect(clickEvent.componentClick).toEqual({
        clickElementId: mockPredictions[0].id,
        clickElementName: mockPredictions[0].text,
        clickElementType: ClickElementTypes.Button,
        targetElement: DEALER_SEARCH_TARGET_ELEMENT
      });
      expect(clickEvent.componentDisplay).toEqual({
        displayElementId: DEALER_SEARCH_DISPLAY_ELEMENT_ID,
        displayElementType: analyticsManager.calculateDisplayElementType(RoutingKeys.DEALER_SEARCH, ElementTypes.dealerSearchForm),
        displayElementName: mockDealerContent.text
      });
      expect(clickEvent.componentSearch).toEqual({
        searchTerm: mockPredictions[0].text
      });
      const { results } = dealerSearchResultsStore.state;
      const loadEvent = globalDataLayerService.gdl.DataLayerStore[2];
      expect((_c = loadEvent.context) === null || _c === void 0 ? void 0 : _c.eventAction).toEqual(EventActions.DEALER_RESULTS_SCREEN_LOAD);
      expect(loadEvent.componentSearch).toEqual({
        numberOfResults: results === null || results === void 0 ? void 0 : results.length,
        searchTerm: mockPredictions[0].text
      });
    });
    it('emits DEALER_GEOLOCATION_CLICK when geolocation button is clicked and DEALER_RESULTS_SCREEN_LOAD when results are returned', async () => {
      var _a, _b, _c, _d;
      dealerSearchResultsStore.state.results = null;
      const page = await getPage();
      (_b = getHTMLElement((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('.geolocation'))) === null || _b === void 0 ? void 0 : _b.click();
      await page.waitForChanges();
      expect(globalDataLayerService.gdl.DataLayerStore).toHaveLength(3);
      const locateEvent = globalDataLayerService.gdl.DataLayerStore[1];
      expect((_c = locateEvent.context) === null || _c === void 0 ? void 0 : _c.eventAction).toEqual(EventActions.DEALER_GEOLOCATION_CLICK);
      expect(locateEvent.componentClick).toEqual({
        clickElementId: mockDealerContent.search.geolocation.id,
        clickElementName: mockDealerContent.search.geolocation.text,
        clickElementType: ClickElementTypes.Button,
        targetElement: DEALER_SEARCH_TARGET_ELEMENT
      });
      expect(locateEvent.componentSearch).toEqual({
        searchTerm: GEOLOCATION_BUTTON_SEARCH_TERM
      });
      const loadEvent = globalDataLayerService.gdl.DataLayerStore[2];
      expect((_d = loadEvent.context) === null || _d === void 0 ? void 0 : _d.eventAction).toEqual(EventActions.DEALER_RESULTS_SCREEN_LOAD);
      expect(loadEvent.componentSearch).toEqual({
        numberOfResults: 6,
        searchTerm: GEOLOCATION_BUTTON_SEARCH_TERM
      });
    });
  });
  it('emits DEALER_SEARCH_SCREEN_LOAD when geolocation page is loaded and there are previously loaded search results', async () => {
    var _a;
    await getPage();
    expect(globalDataLayerService.gdl.DataLayerStore).toHaveLength(1);
    const event = globalDataLayerService.gdl.DataLayerStore[0];
    expect((_a = event.context) === null || _a === void 0 ? void 0 : _a.eventAction).toEqual(EventActions.DEALER_SEARCH_SCREEN_LOAD);
  });
});
//# sourceMappingURL=dealer-search-form-geolocation.spec.js.map
