var __rest = (this && this.__rest) || function (s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
import { h } from "@stencil/core";
import { newSpecPage } from "@stencil/core/testing";
import { Environments } from "../../../entities/environment";
import globalDataLayerService from "../../../services/analytics/global-data-layer-service";
import * as contentService from "../../../services/content-service";
import * as dealerService from "../../../services/dealer-service";
import windowService from "../../../services/window-service";
import { dealerSearchResultsStore } from "../../../state/dealer-search-results-store";
import { navContentStore } from "../../../state/nav-content-store";
import { navStateStore } from "../../../state/nav-state-store";
import { shopStateStore } from "../../../state/shop-state-store";
import { firstAccessToken, mockNewContent, mockPPNDealer, mockPPNDealerSearchResultsWithLocalizedAddress, mockUserInformation } from "../../../test/test-data";
import { DATA_LAYER_APPLICATION_NAME, EventActions, IFRAME_ID, NavigationMode } from "../../../utility/constants";
import { getConfig } from "../../../utility/helper";
import { NaviError, NaviErrorTypes } from "../../../utility/navi-error";
import { Header } from "../header";
import * as abTestingService from "../../../services/ab-testing/ab-testing-constructor-service";
describe('header', () => {
  const initABTestingMock = jest.fn().mockResolvedValue(true);
  const executeABTestingMock = jest.fn().mockResolvedValue(true);
  const loadContentGeneratorExperiments = jest.fn().mockReturnValue(true);
  beforeEach(() => {
    jest.spyOn(abTestingService, 'default').mockReturnValue({
      init: initABTestingMock,
      execute: executeABTestingMock,
      executeContentChange: executeABTestingMock,
      loadContentGeneratorExperiments: loadContentGeneratorExperiments
    });
  });
  describe('AB testing', () => {
    it('should call initABTesting', async function () {
      await newSpecPage({
        components: [Header],
        template: () => h("phn-header", { locale: "it-CH", env: Environments.TEST })
      });
      expect(initABTestingMock).toHaveBeenCalledTimes(1);
      expect(loadContentGeneratorExperiments).toHaveBeenCalledTimes(1);
    });
  });
  it('renders header', async () => {
    const page = await newSpecPage({
      components: [Header],
      template: () => h("phn-header", { locale: "it-CH", env: Environments.TEST })
    });
    expect(page.root).toMatchInlineSnapshot(`
      <phn-header>
        <mock:shadow-root>
          <div class="header">
            <phn-wrapper app="default" breakpoint="0" locale="it-CH" mode="navbar" receivedcontent="" theme="light"></phn-wrapper>
          </div>
        </mock:shadow-root>
      </phn-header>
    `);
  });
  it('renders header with search drawer', async () => {
    const page = await newSpecPage({
      components: [Header],
      template: () => h("phn-header", { locale: "sv-SE", env: Environments.TEST, app: "shop" })
    });
    expect(page.root).toMatchInlineSnapshot(`
      <phn-header>
        <mock:shadow-root>
          <div class="header">
            <phn-wrapper app="shop" breakpoint="0" locale="sv-SE" mode="navbar" receivedcontent="" theme="light">
              <div slot="contextual_drawer_header">
                <slot name="contextual_drawer_header"></slot>
              </div>
            </phn-wrapper>
          </div>
        </mock:shadow-root>
      </phn-header>
    `);
  });
  it('renders header with default app', async () => {
    const page = await newSpecPage({
      components: [Header],
      template: () => h("phn-header", { locale: "it-CH", env: Environments.TEST })
    });
    expect(page.root).toMatchInlineSnapshot(`
      <phn-header>
        <mock:shadow-root>
          <div class="header">
            <phn-wrapper app="default" breakpoint="0" locale="it-CH" mode="navbar" receivedcontent="" theme="light"></phn-wrapper>
          </div>
        </mock:shadow-root>
      </phn-header>
    `);
  });
  it('should set header version on window', async () => {
    const page = await newSpecPage({
      components: [Header],
      template: () => h("phn-header", { locale: "it-CH", env: Environments.TEST })
    });
    expect(page.win.PHN_HEADER_VERSION).toEqual('VERSION_STRING');
  });
  it('should emit a navigationDidLoad event if receives a navigationLoaded event', async () => {
    const page = await newSpecPage({
      components: [Header],
      template: () => h("phn-header", { locale: "it-CH", env: Environments.TEST })
    });
    const navigationDidLoadSpy = jest.spyOn(page.rootInstance.navigationDidLoad, 'emit');
    page.rootInstance.navigationLoadedHandler({ detail: true });
    expect(navigationDidLoadSpy).toHaveBeenCalled();
  });
  describe('data analytics', () => {
    it('should call the global data layer service to configure the global data layer instance and push the load event', async () => {
      var _a, _b, _c, _d;
      const page = await newSpecPage({
        components: [Header],
        template: () => h("phn-header", { locale: "it-CH", env: Environments.TEST, "page-name": "local" })
      });
      await page.rootInstance.newAuthMessageReceived({
        origin: getConfig(Environments.TEST).LOGIN_REDIRECT_URL,
        data: { token: firstAccessToken }
      });
      // @ts-expect-error waiting for gdl module to update its types
      const defaultProperties = globalDataLayerService.gdl.getDefaultProperties(globalDataLayerService.homeNavEventId);
      const _e = (defaultProperties === null || defaultProperties === void 0 ? void 0 : defaultProperties.context) || {}, { timestamp, server } = _e, context = __rest(_e, ["timestamp", "server"]);
      expect(context).toEqual({
        applicationId: 'nav',
        country: 'CH',
        language: 'it',
        applicationName: DATA_LAYER_APPLICATION_NAME,
        environment: 'K'
      });
      expect((_a = defaultProperties === null || defaultProperties === void 0 ? void 0 : defaultProperties.visitor) === null || _a === void 0 ? void 0 : _a.loginStatus).toEqual(true);
      expect((_b = defaultProperties === null || defaultProperties === void 0 ? void 0 : defaultProperties.ids) === null || _b === void 0 ? void 0 : _b.userId).toEqual(mockUserInformation.userData.userId);
      expect((_c = defaultProperties === null || defaultProperties === void 0 ? void 0 : defaultProperties.pageExperience) === null || _c === void 0 ? void 0 : _c.pageName).toEqual('local');
      expect(globalDataLayerService.gdl.DataLayerStore).toHaveLength(1);
      const event = globalDataLayerService.gdl.DataLayerStore[0];
      expect((_d = event.context) === null || _d === void 0 ? void 0 : _d.eventAction).toEqual(EventActions.GENERAL_LOAD);
    });
    it('should call the global data layer service after page-name property changes', async () => {
      var _a, _b;
      const page = await newSpecPage({
        components: [Header],
        template: () => h("phn-header", { locale: "it-CH", env: Environments.TEST, "page-name": "local" })
      });
      (_a = page.root) === null || _a === void 0 ? void 0 : _a.setAttribute('page-name', 'other');
      await page.waitForChanges();
      // @ts-expect-error waiting for gdl module to update its types
      const defaultProperties = globalDataLayerService.gdl.getDefaultProperties(globalDataLayerService.homeNavEventId);
      expect((_b = defaultProperties === null || defaultProperties === void 0 ? void 0 : defaultProperties.pageExperience) === null || _b === void 0 ? void 0 : _b.pageName).toEqual('other');
    });
    it('should call the global data layer service after locale property changes', async () => {
      var _a;
      const page = await newSpecPage({
        components: [Header],
        template: () => h("phn-header", { locale: "it-CH", env: Environments.TEST, "page-name": "local" })
      });
      (_a = page.root) === null || _a === void 0 ? void 0 : _a.setAttribute('locale', 'de-CH');
      await page.waitForChanges();
      // @ts-expect-error waiting for gdl module to update its types
      const defaultProperties = globalDataLayerService.gdl.getDefaultProperties(globalDataLayerService.homeNavEventId);
      const { country, language } = (defaultProperties === null || defaultProperties === void 0 ? void 0 : defaultProperties.context) || {};
      expect(country).toEqual('CH');
      expect(language).toEqual('de');
    });
  });
  describe('nav content store', () => {
    it('Nothing should happen if no props are passed', async () => {
      const startState = navContentStore.state;
      await newSpecPage({
        components: [Header],
        template: () => h("phn-header", null)
      });
      expect(navContentStore.state).toEqual(startState);
    });
    it('should not fetch content when env is set but locale is not', async () => {
      const startState = navContentStore.state;
      await newSpecPage({
        components: [Header],
        template: () => h("phn-header", { env: Environments.TEST })
      });
      expect(navContentStore.state).toEqual(startState);
    });
    it('should be reset with new locale when prop changes', async () => {
      var _a;
      const page = await newSpecPage({
        components: [Header],
        template: () => h("phn-header", { locale: "de-CH", env: Environments.TEST })
      });
      expect(navContentStore.state).toEqual(mockNewContent['de-CH']);
      (_a = page.root) === null || _a === void 0 ? void 0 : _a.setAttribute('locale', 'it-CH');
      await page.waitForChanges();
      expect(navContentStore.state).toEqual(mockNewContent['it-CH']);
    });
    it('should not set content when locale is updated while the fetch is taking place', async () => {
      var _a, _b;
      const page = await newSpecPage({
        components: [Header],
        template: () => h("phn-header", { env: Environments.TEST, locale: "de-CH" })
      });
      expect(navContentStore.state).toEqual(mockNewContent['de-CH']);
      let resolverCH;
      let resolverGB;
      jest.spyOn(contentService, 'fetchContent').mockImplementation(async (locale) => {
        await new Promise((resolve) => {
          if (resolverCH === undefined) {
            resolverCH = resolve;
          }
          else {
            resolverGB = resolve;
          }
        });
        return mockNewContent[locale];
      });
      (_a = page.root) === null || _a === void 0 ? void 0 : _a.setAttribute('locale', 'it-CH');
      await page.waitForChanges();
      (_b = page.root) === null || _b === void 0 ? void 0 : _b.setAttribute('locale', 'en-GB');
      await page.waitForChanges();
      // @ts-expect-error the function is definitely defined by this point :)
      resolverGB();
      await page.waitForChanges();
      expect(navContentStore.state).toEqual(mockNewContent['en-GB']);
      // @ts-expect-error the function is definitely defined by this point :)
      resolverCH();
      await page.waitForChanges();
      expect(navContentStore.state).toEqual(mockNewContent['en-GB']);
    });
    it('should use default content when locale provided does not exist', async () => {
      const startState = navContentStore.state;
      await newSpecPage({
        components: [Header],
        template: () => h("phn-header", { locale: "missing-locale", env: Environments.TEST })
      });
      expect(navContentStore.state).toEqual(startState);
    });
    it('should not try to fetch content when locale provided is not valid', async () => {
      const startState = navContentStore.state;
      await newSpecPage({
        components: [Header],
        template: () => h("phn-header", { locale: "super wrong", env: Environments.TEST })
      });
      expect(navContentStore.state).toEqual(startState);
    });
  });
  describe('shop state store', () => {
    it('should watch shop variables on store', async () => {
      const page = await newSpecPage({
        components: [Header],
        template: () => h("phn-header", null)
      });
      page.rootInstance.shopInformation =
        '{ "wishlistItemsNumber": 50, "numberOfShoppingItems": 10, "subTotal": "100€" }';
      expect(shopStateStore.state.shopInformation.wishlistItemsNumber).toEqual(50);
      expect(shopStateStore.state.shopInformation.numberOfShoppingItems).toEqual(10);
      expect(shopStateStore.state.shopInformation.subTotal).toEqual('100€');
    });
    it('should load shop variables and update store', async () => {
      const page = await newSpecPage({
        components: [Header],
        template: () => (h("phn-header", { "shop-information": '{ "wishlistItemsNumber": 100, "numberOfShoppingItems": 50, "subTotal": "100$" }' }))
      });
      await page.waitForChanges();
      expect(shopStateStore.state.shopInformation.wishlistItemsNumber).toEqual(100);
      expect(shopStateStore.state.shopInformation.numberOfShoppingItems).toEqual(50);
      expect(shopStateStore.state.shopInformation.subTotal).toEqual('100$');
    });
  });
  describe('header with env prop', () => {
    it('should use the default environment if invalid environment is passed', async () => {
      navStateStore.state.env = Environments.PRODUCTION;
      await newSpecPage({
        components: [Header],
        template: () => h("phn-header", { locale: "it-CH", env: "lala" })
      });
      expect(navStateStore.state.env).toBe(Environments.PRODUCTION);
    });
    it('should allow a user to set env after the component has been initialised', async () => {
      var _a;
      navStateStore.state.env = Environments.PRODUCTION;
      const page = await newSpecPage({
        components: [Header],
        template: () => h("phn-header", { locale: "it-CH" })
      });
      expect(navStateStore.state.env).toBe(Environments.PRODUCTION);
      (_a = page.root) === null || _a === void 0 ? void 0 : _a.setAttribute('env', Environments.PREVIEW);
      await page.waitForChanges();
      expect(navStateStore.state.env).toBe(Environments.PREVIEW);
    });
  });
  describe('limitedWidth prop', () => {
    it('should use false as default value for limitedWidth when no mode is given', async () => {
      const page = await newSpecPage({
        components: [Header],
        template: () => h("phn-header", { locale: "de-DE", env: Environments.TEST })
      });
      expect(page.rootInstance.hasLimitedWidth()).toEqual(false);
    });
    it('should use true as default value for limitedWidth when in hero mode', async () => {
      const page = await newSpecPage({
        components: [Header],
        template: () => h("phn-header", { locale: "de-DE", env: Environments.TEST, mode: NavigationMode.hero })
      });
      expect(page.rootInstance.hasLimitedWidth()).toEqual(true);
    });
    it('should use false for isWithLimitedWidth when in navbar mode', async () => {
      const page = await newSpecPage({
        components: [Header],
        template: () => h("phn-header", { locale: "de-DE", env: Environments.TEST, mode: NavigationMode.navbar })
      });
      expect(page.rootInstance.hasLimitedWidth()).toEqual(false);
    });
    it('should use false for limitedWidth when set to false in prop', async () => {
      const page = await newSpecPage({
        components: [Header],
        template: () => h("phn-header", { locale: "de-DE", env: Environments.TEST, "limited-width": "false" })
      });
      expect(page.rootInstance.hasLimitedWidth()).toEqual(false);
    });
  });
  describe('authentication process', () => {
    it('authIframe was initialized with token after the component was loaded', async () => {
      const page = await newSpecPage({
        components: [Header],
        url: getConfig(Environments.TEST).PORSCHE_COM_URL[0],
        template: () => h("phn-header", { locale: "de-DEB", env: Environments.TEST })
      });
      const iFrame = page.win.document.getElementById(IFRAME_ID);
      expect(iFrame).toBeDefined();
    });
    it('authIframe was destroyed and token got updated after authIframe was created', async () => {
      const page = await newSpecPage({
        components: [Header],
        url: getConfig(Environments.TEST).PORSCHE_COM_URL[0],
        template: () => h("phn-header", { locale: "de-DEB", env: Environments.TEST })
      });
      await page.rootInstance.newAuthMessageReceived({
        origin: getConfig(Environments.TEST).LOGIN_REDIRECT_URL,
        data: {
          token: firstAccessToken
        }
      });
      const iFrame = page.win.document.getElementById(IFRAME_ID);
      expect(iFrame).toBeNull();
      expect(navStateStore.state.loggedInState).toEqual('Mirinda Doe');
      expect(navStateStore.state.env).toBe(Environments.TEST);
    });
  });
  describe('logout', () => {
    const logoutUrl = 'http://identity-redirect/url/v2/logout';
    let page;
    beforeEach(async () => {
      page = await newSpecPage({
        components: [Header],
        template: () => h("phn-header", { locale: 'it-CH', env: Environments.TEST })
      });
      jest.spyOn(page.rootInstance.eventPreventedTimeout, 'set').mockImplementation(async (cb) => {
        if (typeof cb === 'function') {
          await cb();
        }
      });
    });
    it('Should listen for logout event and redirect to logout page', async () => {
      const redirectFunction = jest.spyOn(windowService, 'redirectToUrl');
      const logoutEvent = new CustomEvent('logoutEvent');
      await page.rootInstance.handleLogout(logoutEvent);
      expect(redirectFunction).toBeCalledWith(logoutUrl);
    });
    it('should emit phn logout event on logout', async () => {
      jest.spyOn(page.rootInstance.phnLogout, 'emit');
      const logoutEvent = new CustomEvent('logoutEvent');
      await page.rootInstance.handleLogout(logoutEvent);
      expect(page.rootInstance.phnLogout.emit).toHaveBeenCalledTimes(1);
    });
  });
  describe('login', () => {
    let page;
    beforeEach(async () => {
      page = await newSpecPage({
        components: [Header],
        template: () => h("phn-header", { locale: 'it-CH', env: Environments.TEST })
      });
      jest.spyOn(page.rootInstance.eventPreventedTimeout, 'set').mockImplementation(async (cb) => {
        if (typeof cb === 'function') {
          await cb();
        }
      });
    });
    it('Should listen for login event and redirect to login page', async () => {
      if (navContentStore.state.myPorsche) {
        navContentStore.state.myPorsche.link = 'http://my.porsche.com/url/v2/login';
      }
      const redirectFunction = jest.spyOn(windowService, 'redirectToUrl');
      const loginEvent = new CustomEvent('loginEvent');
      await page.rootInstance.handleLogin(loginEvent);
      expect(redirectFunction).toBeCalledWith('http://my.porsche.com/url/v2/login');
    });
    it('should emit phn login event on login', async () => {
      jest.spyOn(page.rootInstance.phnLogin, 'emit');
      const loginEvent = new CustomEvent('loginEvent');
      await page.rootInstance.handleLogin(loginEvent);
      expect(page.rootInstance.phnLogin.emit).toHaveBeenCalledTimes(1);
    });
  });
  describe('stored dealer', () => {
    beforeEach(() => {
      dealerSearchResultsStore.dispose();
    });
    it('should render dealer name if a stored dealerId exists', async () => {
      const mockDealer = mockPPNDealerSearchResultsWithLocalizedAddress[0];
      const { ppnDealer: mockPPNDealer } = mockDealer;
      jest.spyOn(dealerService, 'getPPNDealer').mockResolvedValue(mockDealer);
      dealerSearchResultsStore.state.savedDealerCookie = {
        id: mockPPNDealer.id,
        longitude: mockPPNDealer.coordinates.longitude,
        latitude: mockPPNDealer.coordinates.latitude
      };
      await newSpecPage({
        components: [Header],
        template: () => h("phn-header", { locale: 'it-CH', env: Environments.TEST })
      });
      expect(dealerSearchResultsStore.state.ppnDealers[mockPPNDealer.id]).toBe(mockDealer);
    });
    it('should not render saved dealer name when fetching a single dealer fails', async () => {
      jest.spyOn(dealerService, 'getPPNDealer').mockImplementation(() => {
        throw new NaviError('Unable to fetch a dealer', NaviErrorTypes.GENERAL);
      });
      dealerSearchResultsStore.state.savedDealerCookie = {
        id: mockPPNDealer.id,
        longitude: mockPPNDealer.coordinates.longitude,
        latitude: mockPPNDealer.coordinates.latitude
      };
      await newSpecPage({
        components: [Header],
        template: () => h("phn-header", { locale: 'it-CH', env: Environments.TEST })
      });
      expect(dealerSearchResultsStore.state.savedDealerCookie).toBeNull();
    });
    it('should render dealer name if a stored dealerId exists in a dropdown market', async () => {
      const mockDealer = mockPPNDealerSearchResultsWithLocalizedAddress[0];
      const { ppnDealer: mockPPNDealer } = mockDealer;
      jest.spyOn(dealerService, 'getPPNDealerByRegion').mockResolvedValue(mockDealer);
      dealerSearchResultsStore.state.savedDealerCookie = {
        id: mockPPNDealer.id,
        longitude: mockPPNDealer.coordinates.longitude,
        latitude: mockPPNDealer.coordinates.latitude
      };
      await newSpecPage({
        components: [Header],
        template: () => h("phn-header", { locale: 'zh-CN', env: Environments.TEST })
      });
      expect(dealerSearchResultsStore.state.ppnDealers[mockPPNDealer.id]).toBe(mockDealer);
    });
  });
  describe('checkMarketingConsent', () => {
    let maybeCheckMarketingConsentSpy;
    beforeEach(() => {
      maybeCheckMarketingConsentSpy = jest
        .spyOn(windowService, 'maybeCheckMarketingConsent')
        .mockImplementation((cb) => {
        cb();
        return true;
      });
    });
    it('should check marketing on component load', async () => {
      await newSpecPage({
        components: [Header],
        template: () => h("phn-header", { locale: 'de-CH', env: Environments.TEST })
      });
      expect(maybeCheckMarketingConsentSpy).toHaveBeenCalledTimes(1);
      expect(navStateStore.state.userConsent).toBe(true);
    });
    it('should listen to ucReady event listener, but not checks marketing consent again', async () => {
      const page = await newSpecPage({
        components: [Header],
        template: () => h("phn-header", { locale: 'de-CH', env: Environments.TEST })
      });
      page.rootInstance.handleUserCentricsReady();
      expect(maybeCheckMarketingConsentSpy).toHaveBeenCalledTimes(1);
      expect(navStateStore.state.userConsent).toBe(true);
    });
    it('should listen to ucInit event listener, but only checks marketing consent again if it was not yet initialised', async () => {
      const maybeCheckMarketingConsentSpy = jest
        .spyOn(windowService, 'maybeCheckMarketingConsent')
        .mockImplementation((cb) => {
        cb();
        return false;
      });
      const page = await newSpecPage({
        components: [Header],
        template: () => h("phn-header", { locale: 'de-CH', env: Environments.TEST })
      });
      page.rootInstance.handleUserCentricsInitalization();
      expect(maybeCheckMarketingConsentSpy).toHaveBeenCalledTimes(2);
      expect(navStateStore.state.userConsent).toBe(true);
    });
  });
});
//# sourceMappingURL=header.spec.js.map
