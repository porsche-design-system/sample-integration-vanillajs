import { breakpoint } from "@porsche-design-system/components-js/styles";
import { h } from "@stencil/core";
import { newSpecPage } from "@stencil/core/testing";
import { constructRoutingKey, getDealerDetailsRoutingKey, getModelsRoutingKey, RoutingKeys } from "../../../entities/routing-key";
import globalDataLayerService from "../../../services/analytics/global-data-layer-service";
import animationManager from "../../../services/animations/animation-manager";
import { navContentStore } from "../../../state/nav-content-store";
import { routerStore } from "../../../state/router-store";
import * as el from "../../../test/element-helpers";
import { mockDealerContent, mockModelsContent, mockMoreContent, mockPPNDealer, mockShopContent } from "../../../test/test-data";
import { AnimationSequences, ClickElementTypes, EventActions } from "../../../utility/constants";
import { DrawerStatusValues } from "../../../utility/constants/app";
import * as helper from "../../../utility/helper";
import { getHTMLElement } from "../../../utility/helper";
import { AutocompleteSearchField } from "../../autocomplete-search-field/autocomplete-search-field";
import { Backdrop } from "../../backdrop/backdrop";
import { DealerSearchForm } from "../../dealer-search-form/dealer-search-form";
import { Level1 } from "../../level-1/level-1";
import { MenuItem } from "../../menu-item/menu-item";
import { Menu } from "../../menu/menu";
import { Models } from "../../models/models";
import { Router } from "../../router/router";
import { SideDrawerItem } from "../../side-drawer-item/side-drawer-item";
import { SideDrawer } from "../../side-drawer/side-drawer";
import { DoubleDrawer } from "../double-drawer";
import { DealerSearchFormGeolocation } from "../../dealer-search-form-geolocation/dealer-search-form-geolocation";
describe('double-drawer', () => {
  let defaultProps = {
    breakpoint: 0,
    locale: 'xx-XX',
    routingKeyHistory: [RoutingKeys.MAIN_MENU, RoutingKeys.MODELS],
    routingKeyPointer: 1,
    receivedContent: true
  };
  describe('snapshot tests', () => {
    let page;
    let mainDrawer;
    let mainDrawerContent;
    let sideDrawerContent;
    beforeEach(async () => {
      var _a, _b;
      page = await newSpecPage({
        components: [DoubleDrawer],
        template: () => h("phn-double-drawer", Object.assign({}, defaultProps))
      });
      if (page.root)
        animationManager.initialize(page.root);
      mainDrawer = getHTMLElement((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('#main-drawer'));
      mainDrawerContent = getHTMLElement(mainDrawer === null || mainDrawer === void 0 ? void 0 : mainDrawer.querySelector('.drawer-content'));
      const sideDrawer = getHTMLElement((_b = page.root) === null || _b === void 0 ? void 0 : _b.querySelector('#side-drawer'));
      sideDrawerContent = getHTMLElement(sideDrawer === null || sideDrawer === void 0 ? void 0 : sideDrawer.querySelector('.drawer-content'));
    });
    it('renders both drawer contents', async () => {
      el.endAnimation(page.root || null, 'slideLeftDoubleDrawer');
      await page.waitForChanges();
      el.endAnimation(sideDrawerContent, 'shrinkHighlightIn');
      await page.waitForChanges();
      expect(page.root).toMatchInlineSnapshot(`
        <phn-double-drawer aria-label="navigation modal dialog" aria-modal="true" role="dialog" style="left: -1000px;">
          <phn-p-button aria="{ 'aria-label': 'close modal dialog' }" class="close-button" data-test-id="close-button" hide-label="true" icon="close" theme="dark" variant="secondary"></phn-p-button>
          <div class="drawer" id="side-drawer">
            <div class="drawer-content">
              <span aria-hidden="true" class="first-focus" tabindex="-1"></span>
              <div class="side-drawer-header"></div>
              <phn-side-drawer activeroutingkey="models" locale="xx-XX"></phn-side-drawer>
            </div>
          </div>
          <div class="drawer" id="main-drawer">
            <div class="drawer-content">
              <div class="main-drawer-header"></div>
              <phn-router activeroutingkey="models" breakpoint="0" locale="xx-XX" receivedcontent=""></phn-router>
            </div>
            <div class="bottom-gradient"></div>
          </div>
        </phn-double-drawer>
      `);
    });
    it('should render correct content in side and main drawer when clicking on an item inside of more', async () => {
      el.endAnimation(page.root || null, 'slideLeftDoubleDrawer');
      await page.waitForChanges();
      el.endAnimation(sideDrawerContent, 'shrinkHighlightIn');
      await page.waitForChanges();
      // given
      if (page.root !== undefined) {
        page.root.routingKeyHistory = [
          RoutingKeys.MAIN_MENU,
          RoutingKeys.MORE,
          constructRoutingKey(RoutingKeys.MORE, 'mainmenu.services')
        ];
        page.root.routingKeyPointer = 2;
      }
      el.endAnimation(sideDrawerContent, 'shrinkHighlightOut');
      await page.waitForChanges();
      el.endAnimation(sideDrawerContent, 'slideOutToLeft');
      el.endAnimation(mainDrawerContent, 'slideOutToLeft');
      await page.waitForChanges();
      el.endAnimation(sideDrawerContent, 'slideInFromRight');
      el.endAnimation(mainDrawerContent, 'slideInFromRight');
      await page.waitForChanges();
      el.endAnimation(sideDrawerContent, 'shrinkHighlightIn');
      await page.waitForChanges();
      // then
      expect(page.root).toMatchInlineSnapshot(`
        <phn-double-drawer aria-label="navigation modal dialog" aria-modal="true" role="dialog" style="left: -1000px;">
          <phn-p-button aria="{ 'aria-label': 'close modal dialog' }" class="close-button" data-test-id="close-button" hide-label="true" icon="close" theme="dark" variant="secondary"></phn-p-button>
          <div class="drawer" id="side-drawer">
            <div class="drawer-content">
              <span aria-hidden="true" class="first-focus" tabindex="-1"></span>
              <div class="side-drawer-header"></div>
              <phn-side-drawer activeroutingkey="more/mainmenu.services" locale="xx-XX"></phn-side-drawer>
            </div>
          </div>
          <div class="drawer" id="main-drawer">
            <div class="drawer-content">
              <div class="main-drawer-header"></div>
              <phn-router activeroutingkey="more/mainmenu.services" breakpoint="0" locale="xx-XX" receivedcontent=""></phn-router>
            </div>
            <div class="bottom-gradient"></div>
          </div>
        </phn-double-drawer>
      `);
    });
    it('should move backwards from services to more when back button is clicked', async () => {
      const page = await newSpecPage({
        components: [DoubleDrawer],
        template: () => (h("phn-double-drawer", Object.assign({}, defaultProps, { routingKeyPointer: 2, routingKeyHistory: [
            RoutingKeys.MAIN_MENU,
            RoutingKeys.MORE,
            constructRoutingKey(RoutingKeys.MORE, 'mainmenu.services')
          ] })))
      });
      if (page.root)
        animationManager.initialize(page.root);
      await animationManager.play('openDoubleDrawer');
      await page.waitForChanges();
      if (page.root !== undefined) {
        page.rootInstance.goBackToPreviousMenu();
        page.root.routingKeyPointer = 1;
      }
      await page.waitForChanges();
      // then
      expect(page.root).toMatchInlineSnapshot(`
        <phn-double-drawer aria-label="navigation modal dialog" aria-modal="true" role="dialog" style="left: -1000px;">
          <phn-p-button aria="{ 'aria-label': 'close modal dialog' }" class="close-button" data-test-id="close-button" hide-label="true" icon="close" theme="dark" variant="secondary"></phn-p-button>
          <div class="drawer" id="side-drawer">
            <div class="drawer-content">
              <span aria-hidden="true" class="first-focus" tabindex="-1"></span>
              <div class="side-drawer-header"></div>
              <phn-side-drawer activeroutingkey="more" locale="xx-XX"></phn-side-drawer>
            </div>
          </div>
          <div class="drawer" id="main-drawer">
            <div class="drawer-content">
              <div class="main-drawer-header"></div>
              <phn-router activeroutingkey="more" breakpoint="0" locale="xx-XX" receivedcontent=""></phn-router>
            </div>
            <div class="bottom-gradient"></div>
          </div>
        </phn-double-drawer>
      `);
    });
    it('should return empty if routingHistory is empty', async () => {
      const page = await newSpecPage({
        components: [DoubleDrawer],
        template: () => h("phn-double-drawer", Object.assign({}, defaultProps, { routingKeyHistory: [], routingKeyPointer: -1 }))
      });
      if (page.root)
        animationManager.initialize(page.root);
      expect(page.root).toMatchInlineSnapshot(`
        <phn-double-drawer aria-label="navigation modal dialog" aria-modal="true" role="dialog" style="left: -1000px;">
          <phn-p-button aria="{ 'aria-label': 'close modal dialog' }" class="close-button" data-test-id="close-button" hide-label="true" icon="close" theme="dark" variant="secondary"></phn-p-button>
        </phn-double-drawer>
      `);
    });
  });
  describe('keyboard navigation', () => {
    let page;
    let sideDrawer;
    let mainDrawer;
    beforeEach(async () => {
      var _a, _b;
      navContentStore.state.legacyMore = mockMoreContent;
      navContentStore.state.legacyShop = mockShopContent;
      navContentStore.state.shop = mockShopContent;
      navContentStore.state.models = mockModelsContent;
      page = await newSpecPage({
        components: [DoubleDrawer, Router, SideDrawer, Level1, Models, Menu, MenuItem, SideDrawerItem],
        template: () => h("phn-double-drawer", Object.assign({}, defaultProps))
      });
      if (page.root)
        animationManager.initialize(page.root);
      sideDrawer = getHTMLElement((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('#side-drawer'));
      mainDrawer = getHTMLElement((_b = page.root) === null || _b === void 0 ? void 0 : _b.querySelector('#main-drawer'));
    });
    it('should focus on first main-drawer item when tabbing on the active side-drawer item', () => {
      const firstFocusableMainDrawerElement = el.getFirstFocusable(mainDrawer);
      const activeFocusableSideDrawerElement = el.getFocusableByDataId(sideDrawer, RoutingKeys.MODELS);
      el.tabKeyDown(activeFocusableSideDrawerElement);
      expect(helper.focusOnElement).toBeCalledTimes(1);
      expect(helper.focusOnElement).toBeCalledWith(firstFocusableMainDrawerElement);
    });
    it('should focus on next side-drawer item after tabbing on last main-drawer item', () => {
      const lastFocusableMainDrawerElement = el.getLastFocusable(mainDrawer);
      const focusableSideDrawerElements = el.getAllFocusables(sideDrawer);
      el.tabKeyDown(lastFocusableMainDrawerElement);
      expect(helper.focusOnElement).toBeCalledTimes(1);
      if (focusableSideDrawerElements !== null) {
        expect(helper.focusOnElement).toBeCalledWith(focusableSideDrawerElements[1]);
      }
    });
    it('should focus on close button after tabbing on last side-drawer item', () => {
      var _a;
      const lastFocusableSideDrawerElement = el.getLastFocusable(sideDrawer);
      const closeButton = getHTMLElement((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('.close-button'));
      el.tabKeyDown(lastFocusableSideDrawerElement);
      expect(helper.focusOnElement).toBeCalledTimes(1);
      expect(helper.focusOnElement).toBeCalledWith(closeButton);
    });
    it('should focus on first side-drawer item after tabbing on close-button', () => {
      var _a;
      const firstFocusableSideDrawerElement = el.getFirstFocusable(sideDrawer);
      const closeButton = getHTMLElement((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('.close-button'));
      el.tabKeyDown(closeButton);
      expect(helper.focusOnElement).toBeCalledTimes(1);
      expect(helper.focusOnElement).toBeCalledWith(firstFocusableSideDrawerElement);
    });
    it('should focus on last side-drawer item after shift tabbing on close-button', () => {
      var _a;
      const lastFocusableSideDrawerElement = el.getLastFocusable(sideDrawer);
      const closeButton = getHTMLElement((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('.close-button'));
      el.tabKeyDown(closeButton, true);
      expect(helper.focusOnElement).toBeCalledTimes(1);
      expect(helper.focusOnElement).toBeCalledWith(lastFocusableSideDrawerElement);
    });
    it('should focus on active side-drawer item when shift tabbing on the first main-drawer item', () => {
      const firstFocusableMainDrawerElement = el.getFirstFocusable(mainDrawer);
      const activeFocusableSideDrawerElement = el.getFocusableByDataId(sideDrawer, RoutingKeys.MODELS);
      el.tabKeyDown(firstFocusableMainDrawerElement, true);
      expect(helper.focusOnElement).toBeCalledTimes(1);
      expect(helper.focusOnElement).toBeCalledWith(activeFocusableSideDrawerElement);
    });
    it('should focus on first side-drawer item when last side-drawer item is active and tabbing on last main-drawer item', async () => {
      var _a, _b;
      const page = await newSpecPage({
        components: [DoubleDrawer, Router, Level1, Menu, MenuItem, SideDrawer, SideDrawerItem],
        template: () => (h("phn-double-drawer", Object.assign({}, defaultProps, { routingKeyHistory: [RoutingKeys.MAIN_MENU, RoutingKeys.MORE] })))
      });
      if (page.root)
        animationManager.initialize(page.root);
      const sideDrawer = getHTMLElement((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('#side-drawer'));
      const mainDrawer = getHTMLElement((_b = page.root) === null || _b === void 0 ? void 0 : _b.querySelector('#main-drawer'));
      const firstFocusableSideDrawerElement = el.getFirstFocusable(sideDrawer);
      const lastFocusableMainDrawerElement = el.getLastFocusable(mainDrawer);
      el.tabKeyDown(lastFocusableMainDrawerElement);
      expect(helper.focusOnElement).toBeCalledTimes(1);
      expect(helper.focusOnElement).toBeCalledWith(firstFocusableSideDrawerElement);
    });
    it('should focus on first main-drawer item when tabbing on the active find-a-dealer side-drawer item', async () => {
      var _a, _b;
      navContentStore.state.dealer = mockDealerContent;
      const page = await newSpecPage({
        components: [
          DoubleDrawer,
          Router,
          Level1,
          Menu,
          MenuItem,
          DealerSearchForm,
          AutocompleteSearchField,
          SideDrawer,
          SideDrawerItem,
          DealerSearchFormGeolocation
        ],
        template: () => (h("phn-double-drawer", Object.assign({}, defaultProps, { routingKeyHistory: [RoutingKeys.MAIN_MENU, RoutingKeys.DEALER_SEARCH] })))
      });
      const sideDrawer = getHTMLElement((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('#side-drawer'));
      const mainDrawer = getHTMLElement((_b = page.root) === null || _b === void 0 ? void 0 : _b.querySelector('#main-drawer'));
      const firstFocusableMainDrawerElement = el.getFirstFocusable(mainDrawer);
      const activeFocusableSideDrawerElement = el.getFocusableByDataId(sideDrawer, RoutingKeys.DEALER_SEARCH);
      el.tabKeyDown(activeFocusableSideDrawerElement);
      expect(helper.focusOnElement).toBeCalledTimes(1);
      expect(helper.focusOnElement).toBeCalledWith(firstFocusableMainDrawerElement);
    });
    it('should do nothing if any key but tab is pressed', () => {
      el.keyDown(getHTMLElement(page.root), 'escape');
      expect(helper.focusOnElement).toBeCalledTimes(0);
    });
  });
  describe('close button', () => {
    it('should emit clickDrawerHeaderClose event when close button is clicked', async () => {
      var _a;
      const page = await newSpecPage({
        components: [DoubleDrawer],
        template: () => h("phn-double-drawer", Object.assign({}, defaultProps))
      });
      if (page.root)
        animationManager.initialize(page.root);
      const closeEventSpy = jest.spyOn(page.rootInstance.clickDrawerHeaderClose, 'emit');
      const closeButton = getHTMLElement((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('.close-button'));
      closeButton === null || closeButton === void 0 ? void 0 : closeButton.click();
      expect(closeEventSpy).toBeCalledTimes(1);
    });
  });
  describe('back button', () => {
    const mockMenuButton = {
      id: 'menuId',
      text: 'Menu',
      description: 'Menu'
    };
    it('renders back button for nested models level', async () => {
      var _a;
      navContentStore.state.models = mockModelsContent;
      navContentStore.state.menu = mockMenuButton;
      const page = await newSpecPage({
        components: [DoubleDrawer],
        template: () => (h("phn-double-drawer", Object.assign({}, defaultProps, { routingKeyHistory: [
            RoutingKeys.MAIN_MENU,
            constructRoutingKey(RoutingKeys.MODELS),
            constructRoutingKey(RoutingKeys.MODELS, getModelsRoutingKey(navContentStore.state.models.series[0].id))
          ], routingKeyPointer: 2 })))
      });
      if (page.root)
        animationManager.initialize(page.root);
      expect((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('phn-back-button')).toMatchInlineSnapshot(`
        <phn-back-button
          activeroutingkey="models/models/mainmenu.718"
          analyticsid="menuId"
          class="back-button"
          text="Models"
        />
      `);
    });
    it('renders no back button for broken child id', async () => {
      var _a;
      navContentStore.state.shop = mockShopContent;
      const page = await newSpecPage({
        components: [DoubleDrawer],
        template: () => (h("phn-double-drawer", Object.assign({}, defaultProps, { routingKeyHistory: [
            RoutingKeys.MAIN_MENU,
            constructRoutingKey(RoutingKeys.SHOP),
            constructRoutingKey(RoutingKeys.SHOP, 'broken-id'),
            constructRoutingKey(RoutingKeys.SHOP, 'broken-id', 'other-broken-id')
          ], routingKeyPointer: 3 })))
      });
      if (page.root)
        animationManager.initialize(page.root);
      expect((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('phn-back-button')).toBeNull();
    });
    it('should not render back button in side-drawer if user goes from dealers detail page to shop', async () => {
      var _a;
      navContentStore.state.shop = mockShopContent;
      navContentStore.state.menu = mockMenuButton;
      const page = await newSpecPage({
        components: [DoubleDrawer],
        template: () => (h("phn-double-drawer", Object.assign({}, defaultProps, { routingKeyHistory: [
            RoutingKeys.MAIN_MENU,
            RoutingKeys.DEALER_SEARCH,
            constructRoutingKey(RoutingKeys.SHOP)
          ], routingKeyPointer: 2 })))
      });
      if (page.root)
        animationManager.initialize(page.root);
      expect((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('phn-back-button')).toBeNull();
    });
    it('renders back button in main drawer for dealer-details-page', async () => {
      var _a, _b;
      navContentStore.state.dealer = mockDealerContent;
      const page = await newSpecPage({
        components: [DoubleDrawer],
        template: () => (h("phn-double-drawer", Object.assign({}, defaultProps, { routingKeyHistory: [
            RoutingKeys.MAIN_MENU,
            RoutingKeys.DEALER_SEARCH,
            getDealerDetailsRoutingKey(mockPPNDealer.id)
          ], routingKeyPointer: 2 })))
      });
      if (page.root)
        animationManager.initialize(page.root);
      const clickDrawerHeaderBackSpy = jest.spyOn(page.rootInstance.clickDrawerHeaderBack, 'emit');
      (_b = getHTMLElement((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('phn-back-button'))) === null || _b === void 0 ? void 0 : _b.click();
      expect(clickDrawerHeaderBackSpy).toHaveBeenCalled();
    });
  });
  describe('animations', () => {
    let page;
    beforeEach(async () => {
      page = await newSpecPage({
        components: [DoubleDrawer, Backdrop],
        template: () => h("phn-double-drawer", Object.assign({}, defaultProps))
      });
      if (page.root)
        animationManager.initialize(page.root);
    });
    it('should call focusOnElement with .first-focus when animations are complete if no focusable main-drawer elements', async () => {
      var _a;
      const page = await newSpecPage({
        components: [DoubleDrawer, Router, Level1],
        template: () => h("phn-double-drawer", Object.assign({}, defaultProps))
      });
      if (page.root)
        animationManager.initialize(page.root);
      await animationManager.play('openDoubleDrawer');
      expect(helper.focusOnElement).toBeCalledTimes(1);
      expect(helper.focusOnElement).toBeCalledWith(getHTMLElement((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('.first-focus')));
    });
    it('should focus on input field element after animations are complete when going to a main drawer with dealer-search', async () => {
      var _a;
      navContentStore.state.dealer = mockDealerContent;
      const page = await newSpecPage({
        components: [
          DoubleDrawer,
          Router,
          Level1,
          Menu,
          MenuItem,
          DealerSearchForm,
          AutocompleteSearchField,
          SideDrawer,
          SideDrawerItem,
          DealerSearchFormGeolocation
        ],
        template: () => (h("phn-double-drawer", Object.assign({}, defaultProps, { routingKeyHistory: [RoutingKeys.MAIN_MENU, RoutingKeys.DEALER_SEARCH] })))
      });
      if (page.root)
        animationManager.initialize(page.root);
      const mainDrawer = getHTMLElement((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('#main-drawer'));
      await animationManager.play('openDoubleDrawer');
      const autoFocusElement = getHTMLElement(mainDrawer === null || mainDrawer === void 0 ? void 0 : mainDrawer.querySelector('.autofocus'));
      expect(helper.focusOnElement).toBeCalledTimes(1);
      expect(helper.focusOnElement).toBeCalledWith(autoFocusElement);
    });
    it('should focus on active sidedrawer item after animations are complete when rendering the double-drawer with the keyboard', async () => {
      var _a;
      const page = await newSpecPage({
        components: [DoubleDrawer, Router, Level1, Menu, MenuItem, SideDrawer, SideDrawerItem],
        template: () => h("phn-double-drawer", Object.assign({}, defaultProps, { initialUsingKeyboard: true }))
      });
      if (page.root)
        animationManager.initialize(page.root);
      const sideDrawer = getHTMLElement((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('#side-drawer'));
      await animationManager.play('openDoubleDrawer');
      expect(helper.focusOnElement).toBeCalledTimes(1);
      expect(helper.focusOnElement).toBeCalledWith(el.getFocusableByDataId(sideDrawer, RoutingKeys.MODELS));
    });
    it('should focus on previous main drawer item after animations are complete when rendering the double-drawer after navigating back with the keyboard', async () => {
      var _a;
      navContentStore.state.shop = mockShopContent;
      const accessoriesRoutingKey = 'shop/mainmenu.services.accessories';
      const page = await newSpecPage({
        components: [DoubleDrawer, Router, Level1, Menu, MenuItem, SideDrawer, SideDrawerItem],
        template: () => (h("phn-double-drawer", Object.assign({}, defaultProps, { initialUsingKeyboard: true, routingKeyHistory: [RoutingKeys.MAIN_MENU, RoutingKeys.SHOP, accessoriesRoutingKey] })))
      });
      if (page.root)
        animationManager.initialize(page.root);
      const mainDrawer = getHTMLElement((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('#main-drawer'));
      const accessoriesMenuItem = el.getFocusableByDataId(mainDrawer, accessoriesRoutingKey);
      await animationManager.play('openDoubleDrawer');
      expect(helper.focusOnElement).toBeCalledTimes(1);
      expect(helper.focusOnElement).toBeCalledWith(accessoriesMenuItem);
    });
    it('Should animate Side Drawer and Main Drawer when click on Main Drawer Links', async () => {
      if (page.root !== undefined) {
        page.root.routingKeyHistory = [
          RoutingKeys.MAIN_MENU,
          RoutingKeys.MORE,
          constructRoutingKey(RoutingKeys.MORE, 'mainmenu.services')
        ];
        page.root.routingKeyPointer = 2;
      }
      expect(animationManager.play).toBeCalledWith(AnimationSequences.TRANSITION_NEXT_LEVEL_DOUBLE_DRAWER);
    });
    it('Should animate Main Drawer when clicking on Side Drawer Links', async () => {
      if (page.root !== undefined) {
        page.root.routingKeyHistory = [RoutingKeys.MAIN_MENU, RoutingKeys.MORE];
      }
      await page.waitForChanges();
      expect(animationManager.play).toBeCalledWith(AnimationSequences.TRANSITION_SAME_LEVEL_DOUBLE_DRAWER);
    });
    it('Should intercept and cancel mobileMenuItemClick event while next level double drawer transition is playing', async () => {
      const testEvent = new CustomEvent('mobileMenuItemClick');
      const stopPropagationSpy = jest.spyOn(testEvent, 'stopPropagation');
      const promise = animationManager.play('transitionNextLevelDoubleDrawer');
      page.rootInstance.handleMobileMenuItemClick(testEvent);
      await promise;
      expect(stopPropagationSpy).toHaveBeenCalledTimes(1);
    });
    it('Should intercept and cancel sideDrawerItemClick event while same level double drawer transition is playing', async () => {
      const testEvent = new CustomEvent('sideDrawerItemClick');
      const stopPropagationSpy = jest.spyOn(testEvent, 'stopPropagation');
      const promise = animationManager.play('transitionSameLevelDoubleDrawer');
      page.rootInstance.handleSideDrawerItemClick(testEvent);
      await promise;
      expect(stopPropagationSpy).toHaveBeenCalledTimes(1);
    });
    it('Should play samelevel animation when navigating through dealer Search', async () => {
      const animationPlayMock = jest.spyOn(animationManager, 'play');
      if (page.root !== undefined) {
        page.root.routingKeyHistory = [
          RoutingKeys.MAIN_MENU,
          RoutingKeys.DEALER_SEARCH,
          getDealerDetailsRoutingKey(mockPPNDealer.id)
        ];
        page.root.routingKeyPointer = 1;
      }
      await page.waitForChanges();
      page.rootInstance.watchRoutingKeyPointer(2, 1);
      expect(animationPlayMock).toHaveBeenCalledTimes(1);
      expect(animationPlayMock).toHaveBeenCalledWith('transitionSameLevelDoubleDrawer');
    });
    describe('phnDrawerStatus event', () => {
      let page;
      beforeEach(async () => {
        page = await newSpecPage({
          components: [DoubleDrawer, Backdrop],
          template: () => h("phn-double-drawer", Object.assign({}, defaultProps))
        });
        if (page.root)
          animationManager.initialize(page.root);
      });
      it('should dispatch phnDrawerStatus event with correct status when double drawer starts opening', async () => {
        const phnDrawerStatusEvent = jest.spyOn(page.rootInstance.phnDrawerStatus, 'emit');
        await animationManager.play(AnimationSequences.OPEN_DOUBLE_DRAWER);
        expect(phnDrawerStatusEvent).toHaveBeenCalled();
        expect(phnDrawerStatusEvent).toHaveBeenCalledWith({ status: DrawerStatusValues.startOpening });
      });
      it('should dispatch phnDrawerStatus event with correct status when double drawer finishes opening', async () => {
        const phnDrawerStatusEvent = jest.spyOn(page.rootInstance.phnDrawerStatus, 'emit');
        await animationManager.play(AnimationSequences.OPEN_DOUBLE_DRAWER);
        expect(phnDrawerStatusEvent).toHaveBeenCalled();
        expect(phnDrawerStatusEvent).toHaveBeenCalledWith({ status: DrawerStatusValues.finishOpening });
      });
      it('should dispatch phnDrawerStatus event with correct status when double drawer starts closing', async () => {
        const phnDrawerStatusEvent = jest.spyOn(page.rootInstance.phnDrawerStatus, 'emit');
        await animationManager.play(AnimationSequences.CLOSE_DOUBLE_DRAWER);
        expect(phnDrawerStatusEvent).toHaveBeenCalled();
        expect(phnDrawerStatusEvent).toHaveBeenCalledWith({ status: DrawerStatusValues.startClosing });
      });
      it('should dispatch phnDrawerStatus event with correct status when double drawer finishes closing', async () => {
        const phnDrawerStatusEvent = jest.spyOn(page.rootInstance.phnDrawerStatus, 'emit');
        await animationManager.play(AnimationSequences.CLOSE_DOUBLE_DRAWER);
        expect(phnDrawerStatusEvent).toHaveBeenCalled();
        expect(phnDrawerStatusEvent).toHaveBeenCalledWith({ status: DrawerStatusValues.finishClosing });
      });
    });
  });
  describe('data analytics', () => {
    it('should send data event after double drawer is loaded', async () => {
      var _a;
      routerStore.state.routingKeyHistory = ['mainmenu', 'models'];
      routerStore.state.routingKeyPointer = 1;
      const page = await newSpecPage({
        components: [DoubleDrawer],
        template: () => h("phn-double-drawer", Object.assign({}, defaultProps))
      });
      if (page.root)
        animationManager.initialize(page.root);
      const event = globalDataLayerService.gdl.DataLayerStore[0];
      expect((_a = event.context) === null || _a === void 0 ? void 0 : _a.eventAction).toEqual(EventActions.DRAWER_LOAD);
      expect(event.componentDisplay).toEqual({
        displayElementType: 'level2_double-drawer',
        displayElementId: 'level1-mainmenu_level2-models',
        displayElementName: 'Double Drawer'
      });
    });
    it('should send data event after close button is clicked', async () => {
      var _a, _b;
      const page = await newSpecPage({
        components: [DoubleDrawer],
        template: () => h("phn-double-drawer", Object.assign({}, defaultProps))
      });
      el.mouseClick(getHTMLElement((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('.close-button')));
      const event = globalDataLayerService.gdl.DataLayerStore[1];
      expect((_b = event.context) === null || _b === void 0 ? void 0 : _b.eventAction).toEqual(EventActions.MENU_CLOSE_CLICK);
      expect(event.componentClick).toEqual({
        clickElementId: 'mainmenu.drawer.close',
        clickElementName: 'X',
        clickElementType: ClickElementTypes.Button,
        targetElement: 'level-0'
      });
      expect(event.componentDisplay).toEqual({
        displayElementType: 'level2_close-button',
        displayElementId: 'level1-mainmenu_level2-models',
        displayElementName: 'Double Drawer'
      });
    });
    it('should send data event after transitioning to next menu', async () => {
      var _a;
      routerStore.state.routingKeyHistory = ['mainmenu', 'models'];
      routerStore.state.routingKeyPointer = 1;
      const page = await newSpecPage({
        components: [DoubleDrawer],
        template: () => h("phn-double-drawer", Object.assign({}, defaultProps))
      });
      if (page.root === undefined) {
        throw Error('Page root should not be null');
      }
      animationManager.initialize(page.root);
      const mockRoutingKeyHistory = ['mainmenu', 'models', 'models/mainmenu.911'];
      const mockRoutingKeyPointer = 2;
      page.root.routingKeyHistory = mockRoutingKeyHistory;
      page.root.routingKeyPointer = mockRoutingKeyPointer;
      routerStore.state.routingKeyHistory = mockRoutingKeyHistory;
      routerStore.state.routingKeyPointer = mockRoutingKeyPointer;
      if (animationManager.isPlaying('transitionNextLevelDoubleDrawer'))
        await animationManager.play('transitionNextLevelDoubleDrawer');
      await page.waitForChanges();
      const event = globalDataLayerService.gdl.DataLayerStore[1];
      expect((_a = event.context) === null || _a === void 0 ? void 0 : _a.eventAction).toEqual(EventActions.DRAWER_LOAD);
      expect(event.componentDisplay).toEqual({
        displayElementType: 'level3_double-drawer',
        displayElementId: 'level2-models_level3-mainmenu.911',
        displayElementName: 'Double Drawer'
      });
    });
    it('should send data event after transitioning back to previous menu', async () => {
      var _a;
      const initialRoutingKeyHistory = ['mainmenu', 'models', 'models/mainmenu.911'];
      const initialRoutingKeyPointer = 2;
      routerStore.state.routingKeyHistory = initialRoutingKeyHistory;
      routerStore.state.routingKeyPointer = initialRoutingKeyPointer;
      const page = await newSpecPage({
        components: [DoubleDrawer],
        template: () => (h("phn-double-drawer", Object.assign({}, defaultProps, { routingKeyHistory: initialRoutingKeyHistory, routingKeyPointer: initialRoutingKeyPointer })))
      });
      if (page.root === undefined) {
        throw Error('Page root should not be null');
      }
      animationManager.initialize(page.root);
      const mockRoutingKeyHistory = ['mainmenu', 'models'];
      const mockRoutingKeyPointer = 1;
      page.root.routingKeyHistory = mockRoutingKeyHistory;
      page.root.routingKeyPointer = mockRoutingKeyPointer;
      routerStore.state.routingKeyHistory = mockRoutingKeyHistory;
      routerStore.state.routingKeyPointer = mockRoutingKeyPointer;
      if (animationManager.isPlaying('transitionPreviousLevelDoubleDrawer'))
        await animationManager.play('transitionPreviousLevelDoubleDrawer');
      await page.waitForChanges();
      const event = globalDataLayerService.gdl.DataLayerStore[1];
      expect((_a = event.context) === null || _a === void 0 ? void 0 : _a.eventAction).toEqual(EventActions.DRAWER_LOAD);
      expect(event.componentDisplay).toEqual({
        displayElementType: 'level2_double-drawer',
        displayElementId: 'level1-mainmenu_level2-models',
        displayElementName: 'Double Drawer'
      });
    });
  });
  describe('resize window', () => {
    it('resizes window when resized', async () => {
      var _a;
      defaultProps = {
        breakpoint: breakpoint.l,
        locale: 'xx-XX',
        routingKeyHistory: [RoutingKeys.MAIN_MENU, RoutingKeys.MODELS],
        routingKeyPointer: 1,
        receivedContent: true
      };
      const page = await newSpecPage({
        components: [DoubleDrawer],
        template: () => h("phn-double-drawer", Object.assign({}, defaultProps))
      });
      if (page.root)
        animationManager.initialize(page.root);
      const onResizeWindowSpy = jest.spyOn(page.rootInstance, 'onResizeWindow');
      (_a = page.win) === null || _a === void 0 ? void 0 : _a.dispatchEvent(new Event('resize'));
      expect(onResizeWindowSpy).toBeCalled();
    });
    it('updates animating routing keys when resizing the window', async () => {
      defaultProps = {
        breakpoint: breakpoint.base,
        locale: 'xx-XX',
        routingKeyHistory: [RoutingKeys.MAIN_MENU, RoutingKeys.MODELS],
        routingKeyPointer: 0,
        receivedContent: true
      };
      const page = await newSpecPage({
        components: [DoubleDrawer],
        template: () => h("phn-double-drawer", Object.assign({}, defaultProps))
      });
      if (page.root)
        animationManager.initialize(page.root);
      page.rootInstance.animatingRoutingKeyPointer = 0;
      page.rootInstance.routingKeyPointer = 1;
      page.rootInstance.onResizeWindow();
      expect(page.rootInstance.animatingRoutingKeyPointer).toEqual(1);
      expect(page.rootInstance.animatingRoutingKey).toEqual(RoutingKeys.MODELS);
    });
  });
});
//# sourceMappingURL=double-drawer.spec.js.map
