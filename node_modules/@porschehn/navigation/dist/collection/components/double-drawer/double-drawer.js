import { Fragment, h, Host } from "@stencil/core";
import { findTopLevelRoutingKey, RoutingKeyPointers, RoutingKeys } from "../../entities/routing-key";
import analyticsManager from "../../services/analytics/analytics-manager";
import globalDataLayerService from "../../services/analytics/global-data-layer-service";
import animationManager from "../../services/animations/animation-manager";
import { getBackButtonText } from "../../services/menu-items-service";
import { navContentStore } from "../../state/nav-content-store";
import { ClickElementTypes, DisplayElementTypes, ElementTypes, EventActions, FOCUSABLE_ELEMENTS_SELECTOR } from "../../utility/constants";
import { focusOnElement, getHTMLElement, isString } from "../../utility/helper";
import { registerBackToPreviousMenuSequence, registerCloseDoubleDrawerSequence, registerForwardToNextMenuSequence, registerOpenDoubleDrawerSequence, registerTransitionSequence } from "./double-drawer-animation-sequences";
import { getAllFocusableElements } from "./helper";
import { MainDrawerContent } from "./main-drawer-content";
import { SideDrawerContent } from "./side-drawer-content";
import { DrawerStatusValues } from "../../utility/constants/app";
export class DoubleDrawer {
  constructor() {
    this.breakpoint = undefined;
    this.locale = undefined;
    this.initialUsingKeyboard = false;
    this.routingKeyHistory = [];
    this.routingKeyPointer = RoutingKeyPointers.LEVEL_ZERO;
    this.receivedContent = undefined;
    this.usingKeyboard = false;
    this.animatingRoutingKeyPointer = RoutingKeyPointers.LEVEL_ZERO;
    this.isAnimating = true;
    this.animatingRoutingKey = '';
  }
  watchRoutingKeyPointer(newPointer, oldPointer) {
    if (oldPointer < newPointer) {
      const topLevelRoutingKey = findTopLevelRoutingKey(this.routingKeyHistory[this.routingKeyPointer]);
      if (topLevelRoutingKey === RoutingKeys.DEALER_SEARCH) {
        animationManager.play('transitionSameLevelDoubleDrawer').then(() => this.focusOnInitialElement());
      }
      else {
        animationManager.play('transitionNextLevelDoubleDrawer').then(() => this.focusOnInitialElement());
      }
    }
  }
  watchRoutingKeyHistory(newHistory, oldHistory) {
    if (newHistory.length < oldHistory.length || this.animateIfSameLength(newHistory, oldHistory)) {
      animationManager.play('transitionSameLevelDoubleDrawer').then(() => this.focusOnInitialElement());
    }
  }
  onResizeWindow() {
    if (this.animatingRoutingKeyPointer !== this.routingKeyPointer) {
      this.animatingRoutingKey = this.routingKeyHistory[this.routingKeyPointer];
      this.animatingRoutingKeyPointer = this.routingKeyPointer;
    }
  }
  handleKeyDown(e) {
    if (e.key !== 'Tab') {
      return;
    }
    let activeRoutingKey = this.routingKeyHistory[this.routingKeyPointer];
    if (activeRoutingKey.startsWith(RoutingKeys.DEALER_SEARCH)) {
      activeRoutingKey = activeRoutingKey.split('/')[0];
    }
    const eventSourceElement = getHTMLElement(e.target);
    if (eventSourceElement === null) {
      return;
    }
    const focusableSideDrawerElements = getAllFocusableElements(this.el.querySelector('#side-drawer'));
    let focusableMainDrawerElements = getAllFocusableElements(this.el.querySelector('#main-drawer'));
    if (focusableSideDrawerElements.length === 0 || focusableMainDrawerElements.length === 0) {
      return;
    }
    const highlightedSideDrawerElementIndex = focusableSideDrawerElements.findIndex((el) => el.getAttribute('data-id') === activeRoutingKey);
    const highlightedSideDrawerElement = focusableSideDrawerElements[highlightedSideDrawerElementIndex];
    if (activeRoutingKey === RoutingKeys.DEALER_SEARCH) {
      focusableMainDrawerElements = focusableMainDrawerElements.filter((element) => element.nodeName !== 'BUTTON' && element.nodeName !== 'A');
    }
    const lastSideDrawerElement = focusableSideDrawerElements[focusableSideDrawerElements.length - 1];
    const lastMainDrawerElement = focusableMainDrawerElements[focusableMainDrawerElements.length - 1];
    const closeButton = this.el.querySelector('.close-button');
    if (!e.shiftKey) {
      if (eventSourceElement === highlightedSideDrawerElement) {
        e.preventDefault();
        focusOnElement(focusableMainDrawerElements[0]);
        return;
      }
      if (eventSourceElement === lastSideDrawerElement) {
        e.preventDefault();
        if (closeButton !== null) {
          focusOnElement(closeButton);
        }
      }
      if (eventSourceElement === lastMainDrawerElement) {
        e.preventDefault();
        const nextSideDrawerElementIndex = highlightedSideDrawerElementIndex + 1 >= focusableSideDrawerElements.length
          ? 0
          : highlightedSideDrawerElementIndex + 1;
        const nextSideDrawerElement = getHTMLElement(focusableSideDrawerElements[nextSideDrawerElementIndex]);
        focusOnElement(nextSideDrawerElement);
      }
      if (eventSourceElement === closeButton) {
        e.preventDefault();
        focusOnElement(focusableSideDrawerElements[0]);
      }
    }
    else if (e.shiftKey) {
      if (eventSourceElement === focusableMainDrawerElements[0]) {
        e.preventDefault();
        if (highlightedSideDrawerElement !== null) {
          focusOnElement(highlightedSideDrawerElement);
        }
      }
      if (eventSourceElement === closeButton) {
        e.preventDefault();
        focusOnElement(lastSideDrawerElement);
      }
    }
  }
  handleMobileMenuItemClick(event) {
    if (animationManager.isPlaying('transitionNextLevelDoubleDrawer')) {
      event.stopPropagation();
    }
  }
  handleSideDrawerItemClick(event) {
    if (animationManager.isPlaying('transitionSameLevelDoubleDrawer')) {
      event.stopPropagation();
    }
  }
  focusOnInitialElement() {
    const isNavigatingBackwards = this.routingKeyPointer < this.routingKeyHistory.length - 1;
    let focusedRoutingKey = isNavigatingBackwards
      ? this.routingKeyHistory[this.routingKeyPointer + 1]
      : this.routingKeyHistory[this.routingKeyPointer];
    if (focusedRoutingKey.startsWith(RoutingKeys.DEALER_SEARCH)) {
      focusedRoutingKey = focusedRoutingKey.split('/')[0];
    }
    const autoFocusElement = getHTMLElement(this.el.querySelector('.autofocus'));
    if (autoFocusElement !== null) {
      focusOnElement(autoFocusElement);
      return;
    }
    if (this.usingKeyboard) {
      let focusableElement = null;
      if (isString(focusedRoutingKey)) {
        focusableElement = getHTMLElement(this.el.querySelector(`[data-id="${focusedRoutingKey}"]`));
      }
      if (focusableElement === null) {
        focusableElement = getHTMLElement(this.el.querySelector(`${FOCUSABLE_ELEMENTS_SELECTOR}`));
      }
      if (focusableElement !== null) {
        focusOnElement(focusableElement);
      }
      return;
    }
    const firstFocus = getHTMLElement(this.el.querySelector('.first-focus'));
    if (firstFocus !== null) {
      focusOnElement(firstFocus);
    }
  }
  async goBackToPreviousMenu() {
    if (this.routingKeyPointer === this.animatingRoutingKeyPointer) {
      this.clickDrawerHeaderBack.emit();
      const topLevelRoutingKey = findTopLevelRoutingKey(this.routingKeyHistory[this.routingKeyPointer]);
      if (topLevelRoutingKey === RoutingKeys.DEALER_SEARCH) {
        animationManager.play('transitionSameLevelDoubleDrawerReverse').then(() => this.focusOnInitialElement());
      }
      else {
        animationManager.play('transitionPreviousLevelDoubleDrawer').then(() => this.focusOnInitialElement());
      }
    }
  }
  async updateRouting() {
    this.animatingRoutingKey = this.routingKeyHistory[this.routingKeyPointer];
    this.animatingRoutingKeyPointer = this.routingKeyPointer;
    const isNavigatingBackwards = this.routingKeyPointer < this.routingKeyHistory.length - 1;
    this.drawerChanged.emit(isNavigatingBackwards);
    this.sendDoubleDrawerLoadDataEvent();
  }
  sendDoubleDrawerLoadDataEvent() {
    analyticsManager.setDrawerType(DisplayElementTypes.DoubleDrawer);
    const activeRoutingKey = this.animatingRoutingKey || '';
    globalDataLayerService.pushDataLayerEvent(EventActions.DRAWER_LOAD, {
      componentDisplay: {
        displayElementType: analyticsManager.calculateDisplayElementType(activeRoutingKey, ElementTypes.doubleDrawer),
        displayElementId: analyticsManager.calculateDisplayElementId(),
        displayElementName: 'Double Drawer'
      }
    });
  }
  sendDataEventOfCloseButtonClick() {
    const activeRoutingKey = this.animatingRoutingKey || '';
    globalDataLayerService.pushDataLayerEvent(EventActions.MENU_CLOSE_CLICK, {
      componentClick: {
        clickElementId: 'mainmenu.drawer.close',
        clickElementName: 'X',
        clickElementType: ClickElementTypes.Button,
        targetElement: 'level-0'
      },
      componentDisplay: {
        displayElementType: analyticsManager.calculateDisplayElementType(activeRoutingKey, ElementTypes.closeButton),
        displayElementId: analyticsManager.calculateDisplayElementId(),
        displayElementName: 'Double Drawer'
      }
    });
  }
  animateIfSameLength(newHistory, oldHistory) {
    return (newHistory.length === oldHistory.length &&
      this.routingKeyPointer === newHistory.length - 1 &&
      newHistory[newHistory.length - 1] !== oldHistory[oldHistory.length - 1]);
  }
  componentWillLoad() {
    this.animatingRoutingKey = this.routingKeyHistory[this.routingKeyPointer];
    this.animatingRoutingKeyPointer = this.routingKeyPointer;
    this.usingKeyboard = this.initialUsingKeyboard;
  }
  componentDidLoad() {
    const routeChangeCallbacks = {
      onSlideMainDrawerOutEnd: async () => this.updateRouting()
    };
    registerOpenDoubleDrawerSequence({
      onAnimationStarts: () => {
        this.phnDrawerStatus.emit({ status: DrawerStatusValues.startOpening });
      },
      onAnimationEnds: () => {
        this.phnDrawerStatus.emit({ status: DrawerStatusValues.finishOpening });
        this.focusOnInitialElement();
      }
    });
    registerCloseDoubleDrawerSequence({
      onBackdropFadeOutEnd: async () => {
        this.backdropClosed.emit();
      },
      onAnimationStarts: () => {
        this.phnDrawerStatus.emit({ status: DrawerStatusValues.startClosing });
      },
      onAnimationEnds: () => {
        this.phnDrawerStatus.emit({ status: DrawerStatusValues.finishClosing });
      }
    });
    registerBackToPreviousMenuSequence(routeChangeCallbacks);
    registerForwardToNextMenuSequence(routeChangeCallbacks);
    registerTransitionSequence(routeChangeCallbacks);
    registerTransitionSequence(routeChangeCallbacks, 'reverse');
    this.sendDoubleDrawerLoadDataEvent();
  }
  render() {
    const previousRoutingKey = this.routingKeyHistory[this.animatingRoutingKeyPointer - 1];
    const backButtonText = getBackButtonText(navContentStore.state, previousRoutingKey);
    const topLevelRoutingKey = findTopLevelRoutingKey(this.animatingRoutingKey);
    const wasPreviouslyOnDealerSearch = findTopLevelRoutingKey(previousRoutingKey) === RoutingKeys.DEALER_SEARCH;
    const isOnDealerDetails = topLevelRoutingKey === RoutingKeys.DEALER_SEARCH && this.animatingRoutingKey !== topLevelRoutingKey;
    return (h(Host, { role: "dialog", "aria-modal": "true", "aria-label": "navigation modal dialog" }, h("phn-p-button", { variant: "secondary", class: "close-button", theme: "dark", "hide-label": "true", icon: 'close', aria: "{ 'aria-label': 'close modal dialog' }", "data-test-id": "close-button", onClick: () => {
        this.sendDataEventOfCloseButtonClick();
        this.clickDrawerHeaderClose.emit();
      } }), isString(this.animatingRoutingKey) ? (h(Fragment, null, h("div", { class: "drawer", id: "side-drawer" }, h(SideDrawerContent, { activeRoutingKey: this.animatingRoutingKey, locale: this.locale, backButtonText: wasPreviouslyOnDealerSearch ? '' : backButtonText, onClickBack: () => this.goBackToPreviousMenu() })), h("div", { class: "drawer", id: "main-drawer" }, h(MainDrawerContent, { activeRoutingKey: this.animatingRoutingKey, breakpoint: this.breakpoint, locale: this.locale, backButtonText: isOnDealerDetails ? backButtonText : '', receivedContent: this.receivedContent, onClickBack: () => this.goBackToPreviousMenu() }), h("div", { class: "bottom-gradient" })))) : null));
  }
  static get is() { return "phn-double-drawer"; }
  static get encapsulation() { return "scoped"; }
  static get originalStyleUrls() {
    return {
      "$": ["double-drawer.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["double-drawer.css"]
    };
  }
  static get properties() {
    return {
      "breakpoint": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": true,
        "optional": false,
        "docs": {
          "tags": [],
          "text": ""
        },
        "attribute": "breakpoint",
        "reflect": false
      },
      "locale": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": true,
        "optional": false,
        "docs": {
          "tags": [],
          "text": ""
        },
        "attribute": "locale",
        "reflect": false
      },
      "initialUsingKeyboard": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": ""
        },
        "attribute": "initial-using-keyboard",
        "reflect": false,
        "defaultValue": "false"
      },
      "routingKeyHistory": {
        "type": "unknown",
        "mutable": false,
        "complexType": {
          "original": "string[]",
          "resolved": "string[]",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": ""
        },
        "defaultValue": "[]"
      },
      "routingKeyPointer": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": ""
        },
        "attribute": "routing-key-pointer",
        "reflect": false,
        "defaultValue": "RoutingKeyPointers.LEVEL_ZERO"
      },
      "receivedContent": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": true,
        "optional": false,
        "docs": {
          "tags": [],
          "text": ""
        },
        "attribute": "received-content",
        "reflect": false
      }
    };
  }
  static get states() {
    return {
      "usingKeyboard": {},
      "animatingRoutingKeyPointer": {},
      "isAnimating": {},
      "animatingRoutingKey": {}
    };
  }
  static get events() {
    return [{
        "method": "clickDrawerHeaderClose",
        "name": "clickDrawerHeaderClose",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": ""
        },
        "complexType": {
          "original": "void",
          "resolved": "void",
          "references": {}
        }
      }, {
        "method": "clickDrawerHeaderBack",
        "name": "clickDrawerHeaderBack",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": ""
        },
        "complexType": {
          "original": "void",
          "resolved": "void",
          "references": {}
        }
      }, {
        "method": "drawerClosed",
        "name": "drawerClosed",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": ""
        },
        "complexType": {
          "original": "void",
          "resolved": "void",
          "references": {}
        }
      }, {
        "method": "drawerChanged",
        "name": "drawerChanged",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": ""
        },
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        }
      }, {
        "method": "backdropClosed",
        "name": "backdropClosed",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": ""
        },
        "complexType": {
          "original": "void",
          "resolved": "void",
          "references": {}
        }
      }, {
        "method": "phnDrawerStatus",
        "name": "phnDrawerStatus",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": ""
        },
        "complexType": {
          "original": "{\n    status: DrawerStatusTypes;\n  }",
          "resolved": "{ status: DrawerStatusTypes; }",
          "references": {
            "DrawerStatusTypes": {
              "location": "import",
              "path": "../../utility/constants/app",
              "id": "src/utility/constants/app.ts::DrawerStatusTypes"
            }
          }
        }
      }];
  }
  static get elementRef() { return "el"; }
  static get watchers() {
    return [{
        "propName": "routingKeyPointer",
        "methodName": "watchRoutingKeyPointer"
      }, {
        "propName": "routingKeyHistory",
        "methodName": "watchRoutingKeyHistory"
      }];
  }
  static get listeners() {
    return [{
        "name": "resize",
        "method": "onResizeWindow",
        "target": "window",
        "capture": false,
        "passive": true
      }, {
        "name": "keydown",
        "method": "handleKeyDown",
        "target": undefined,
        "capture": false,
        "passive": false
      }, {
        "name": "mobileMenuItemClick",
        "method": "handleMobileMenuItemClick",
        "target": undefined,
        "capture": false,
        "passive": false
      }, {
        "name": "sideDrawerItemClick",
        "method": "handleSideDrawerItemClick",
        "target": undefined,
        "capture": false,
        "passive": false
      }];
  }
}
//# sourceMappingURL=double-drawer.js.map
