import { DealerSearchFormGeolocation } from "../../dealer-search-form-geolocation/dealer-search-form-geolocation";
import { h } from "@stencil/core";
import { newSpecPage } from "@stencil/core/testing";
import { constructRoutingKey, getSeriesRoutingKey, RoutingKeys } from "../../../entities/routing-key";
import globalDataLayerService from "../../../services/analytics/global-data-layer-service";
import animationManager from "../../../services/animations/animation-manager";
import { navContentStore } from "../../../state/nav-content-store";
import * as el from "../../../test/element-helpers";
import { mockDealerContent, mockModelsContent, mockShopContent } from "../../../test/test-data";
import { AnimationSequences, EventActions } from "../../../utility/constants";
import * as helper from "../../../utility/helper";
import { getHTMLElement, loadRootElement } from "../../../utility/helper";
import { AutocompleteSearchField } from "../../autocomplete-search-field/autocomplete-search-field";
import { DealerSearchForm } from "../../dealer-search-form/dealer-search-form";
import { DrawerHeader } from "../../drawer-header/drawer-header";
import { Router } from "../../router/router";
import { SingleDrawer } from "../single-drawer";
import { Backdrop } from "../../backdrop/backdrop";
import { back, goTo, syncAnimation } from "../../../services/routing-manager";
import { clickOnBackButton, getHTMLElementFromPage, openMenuFromMyPorscheIcon, waitForFocusTimeout } from "../../../test/actions";
import { Level1 } from "../../level-1/level-1";
import { Models } from "../../models/models";
import { CarBodyTypeDrawer } from "../../car-body-types-drawer/car-body-types-drawer";
import { breakpoint } from "@porsche-design-system/components-js/styles";
import { navStateStore } from "../../../state/nav-state-store";
jest.mock('../../../services/maps-service.ts');
describe('Single Drawer', () => {
  const defaultProps = {
    breakpoint: 0,
    locale: 'xx-XX',
    usingKeyboard: false
  };
  afterEach(() => {
    jest.clearAllMocks();
    jest.resetAllMocks();
    jest.restoreAllMocks();
  });
  async function setUp(props, additionalComponents = []) {
    const page = await newSpecPage({
      components: [SingleDrawer, ...additionalComponents],
      template: () => h("phn-single-drawer", Object.assign({}, props))
    });
    if (page.root) {
      loadRootElement(page.root);
      animationManager.initialize();
    }
    return page;
  }
  describe('keyboard navigation', () => {
    it('focuses on the first focusable element when user is at the last focusable element and presses tab', async () => {
      var _a, _b, _c;
      const page = await setUp(defaultProps, [Router, DrawerHeader]);
      goTo();
      await page.waitForChanges();
      await waitForFocusTimeout();
      expect(helper.focusOnElement).toBeCalledTimes(1);
      expect(helper.focusOnElement).toBeCalledWith((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('.first-focus'));
      const activeDrawer = helper.getHTMLElement((_b = page.root) === null || _b === void 0 ? void 0 : _b.querySelector('.active'));
      const lastFocussable = el.getLastFocusable(activeDrawer);
      // when
      el.tabKeyDown(lastFocussable);
      // then
      expect(helper.focusOnElement).toBeCalledTimes(2);
      expect(helper.focusOnElement).toBeCalledWith((_c = page.root) === null || _c === void 0 ? void 0 : _c.querySelector('.first-focus'));
    });
    it('focuses on the last focusable element when user is at the first focusable element and presses shift+tab', async () => {
      var _a, _b;
      // given
      const page = await setUp(defaultProps, [Router, DrawerHeader]);
      goTo();
      await page.waitForChanges();
      await waitForFocusTimeout();
      expect(helper.focusOnElement).toBeCalledTimes(1);
      expect(helper.focusOnElement).toBeCalledWith((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('.first-focus'));
      const activeDrawer = helper.getHTMLElement((_b = page.root) === null || _b === void 0 ? void 0 : _b.querySelector('.active'));
      const firstFocussable = el.getFirstFocusable(activeDrawer);
      el.tabKeyDown(firstFocussable, true);
      expect(helper.focusOnElement).toBeCalledTimes(2);
    });
    it('focuses on the first focusable element when user is using keyboard and opens a new drawer', async () => {
      var _a;
      navStateStore.state.usingKeyboard = true;
      const page = await setUp(Object.assign(Object.assign({}, defaultProps), { usingKeyboard: true }), [SingleDrawer, Router, DrawerHeader]);
      goTo();
      await page.waitForChanges();
      await waitForFocusTimeout();
      const activeDrawer = helper.getHTMLElement((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('.drawer'));
      const firstFocussable = el.getFirstFocusable(activeDrawer);
      // then
      expect(helper.focusOnElement).toBeCalledTimes(1);
      expect(helper.focusOnElement).toBeCalledWith(firstFocussable);
    });
    it('focusses on the first autofocussable element when user is opening a drawer which contains an autofocussable element with keyboard', async () => {
      var _a, _b;
      const dealer = mockDealerContent;
      navStateStore.state.userConsent = true;
      navContentStore.state.dealer = dealer;
      const page = await setUp(Object.assign(Object.assign({}, defaultProps), { breakpoint: breakpoint.xs, usingKeyboard: true }), [
        Level1,
        Router,
        DrawerHeader,
        DealerSearchForm,
        AutocompleteSearchField,
        DealerSearchFormGeolocation
      ]);
      goTo();
      await page.waitForChanges();
      await waitForFocusTimeout();
      expect(helper.focusOnElement).toBeCalledTimes(1);
      expect(helper.focusOnElement).toBeCalledWith((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('.first-focus'));
      const findADealerButton = getHTMLElementFromPage(page, 'phn-menu-item[elementid="find_a_dealer"]');
      findADealerButton === null || findADealerButton === void 0 ? void 0 : findADealerButton.click();
      await waitForFocusTimeout();
      await page.waitForChanges();
      await waitForFocusTimeout();
      const autofocusElement = helper.getHTMLElement((_b = page.root) === null || _b === void 0 ? void 0 : _b.querySelector('.autofocus'));
      el.tabKeyDown(autofocusElement);
      await waitForFocusTimeout();
      expect(helper.focusOnElement).toBeCalledTimes(2);
      // expect(helper.focusOnElement).toBeCalledWith(autofocusElement);
    });
    it.skip('focusses on the previously-clicked element when user is using keyboard and clicks the back button', async () => {
      var _a, _b, _c, _d;
      navContentStore.state.shop = mockShopContent;
      const page = await setUp(Object.assign(Object.assign({}, defaultProps), { usingKeyboard: true }), [Router, DrawerHeader]);
      goTo(RoutingKeys.SHOP);
      await page.waitForChanges();
      await waitForFocusTimeout();
      expect(helper.focusOnElement).toBeCalledTimes(1);
      expect(helper.focusOnElement).toHaveBeenLastCalledWith((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('.first-focus'));
      back();
      await page.waitForChanges();
      await waitForFocusTimeout();
      expect(helper.focusOnElement).toBeCalledTimes(2);
      expect(helper.focusOnElement).toHaveBeenLastCalledWith((_b = page.root) === null || _b === void 0 ? void 0 : _b.querySelector('.first-focus'));
      goTo(RoutingKeys.SHOP, constructRoutingKey(RoutingKeys.SHOP, mockShopContent.children[0].id));
      await page.waitForChanges();
      await waitForFocusTimeout();
      // then
      expect(helper.focusOnElement).toBeCalledTimes(2);
      expect(helper.focusOnElement).toHaveBeenLastCalledWith((_c = page.root) === null || _c === void 0 ? void 0 : _c.querySelector('.first-focus'));
      // then
      expect(helper.focusOnElement).toBeCalledTimes(3);
      expect(helper.focusOnElement).toHaveBeenLastCalledWith((_d = page.root) === null || _d === void 0 ? void 0 : _d.querySelector(`.active [data-id="${constructRoutingKey(RoutingKeys.SHOP, mockShopContent.children[0].id)}"]`));
    });
    it('focusses on the first autofocussable element when user is opening a drawer which contains an autofocussable element with mouse click', async () => {
      var _a, _b, _c;
      // given
      navContentStore.state.dealer = mockDealerContent;
      navStateStore.state.userConsent = true;
      const page = await setUp(Object.assign({}, defaultProps), [
        Router,
        DrawerHeader,
        DealerSearchForm,
        AutocompleteSearchField,
        DealerSearchFormGeolocation,
        Level1
      ]);
      goTo();
      await page.waitForChanges();
      await waitForFocusTimeout();
      expect(helper.focusOnElement).toBeCalledTimes(1);
      expect(helper.focusOnElement).toBeCalledWith((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('.first-focus'));
      (_c = getHTMLElement((_b = page.root) === null || _b === void 0 ? void 0 : _b.querySelector('phn-menu-item[elementid="find_a_dealer"]'))) === null || _c === void 0 ? void 0 : _c.click();
      await waitForFocusTimeout();
      await page.waitForChanges();
      await waitForFocusTimeout();
      expect(helper.focusOnElement).toBeCalledTimes(2);
      // expect(helper.focusOnElement).toBeCalledWith(page.root?.querySelector('.autofocus'));
    });
    it('should handle keydown event', async () => {
      const page = await setUp(defaultProps);
      goTo();
      await page.waitForChanges();
      const keyboardEvent = new KeyboardEvent('keydown', { key: 'Escape' });
      const returnValue = page.rootInstance.handleKeyDown(keyboardEvent);
      expect(returnValue).toBeUndefined();
    });
  });
  describe('snapshot tests', () => {
    it.skip('renders the animation drawer and starts opening', async () => {
      const page = await setUp(defaultProps);
      goTo();
      await page.waitForChanges();
      expect(page.root).toMatchInlineSnapshot(`
        <phn-single-drawer>
          <div class="active drawer">
            <span aria-hidden="true" class="first-focus" tabindex="-1"></span>
            <div class="bottom-gradient"></div>
            <div class="drawer-content">
              <phn-drawer-header backbuttonanalyticsid="" breakpoint="0" locale="xx-XX" route="mainmenu"></phn-drawer-header>
              <phn-router activeroutingkey="mainmenu" breakpoint="0" locale="xx-XX"></phn-router>
            </div>
          </div>
        </phn-single-drawer>
      `);
    });
    it.skip('should stop menu-item click event propagating while animation is running and user click on a button', async () => {
      const page = await setUp(defaultProps);
      const event = new MouseEvent('mouseUp');
      const propagationMock = jest.spyOn(event, 'stopPropagation');
      if (page.root !== undefined) {
        goTo(RoutingKeys.SHOP);
      }
      await page.waitForChanges();
      // const promise = playAnimationOfSlideLeft(page);
      page.rootInstance.handleMobileMenuItemClick(event);
      await page.waitForChanges();
      expect(propagationMock).toBeCalledTimes(1);
      expect(page.root).toMatchInlineSnapshot(`
        <phn-single-drawer>
          <div class="active drawer">
            <span aria-hidden="true" class="first-focus" tabindex="-1"></span>
            <div class="bottom-gradient"></div>
            <div class="drawer-content">
              <phn-drawer-header backbuttonanalyticsid="" backbuttontext="" breakpoint="0" locale="xx-XX" showbackbutton=""></phn-drawer-header>
              <phn-router activeroutingkey="shop" breakpoint="0" locale="xx-XX"></phn-router>
            </div>
          </div>
        </phn-single-drawer>
      `);
      // await promise;
    });
    it.skip('should stop menu-item click event propagating while animation is running and the user close drawer', async () => {
      const page = await setUp(defaultProps);
      const event = new MouseEvent('click');
      const propagationMock = jest.spyOn(event, 'stopPropagation');
      if (page.root !== undefined) {
        goTo(RoutingKeys.SHOP);
      }
      await page.waitForChanges();
      // const promise = playAnimationOfSlideLeft(page);
      page.rootInstance.handleClickDrawerHeaderClose(event);
      await page.waitForChanges();
      expect(propagationMock).toBeCalledTimes(1);
      expect(page.root).toMatchInlineSnapshot(`
        <phn-single-drawer>
          <div class="active drawer">
            <span aria-hidden="true" class="first-focus" tabindex="-1"></span>
            <div class="bottom-gradient"></div>
            <div class="drawer-content">
              <phn-drawer-header backbuttonanalyticsid="" backbuttontext="" breakpoint="0" locale="xx-XX" showbackbutton=""></phn-drawer-header>
              <phn-router activeroutingkey="shop" breakpoint="0" locale="xx-XX"></phn-router>
            </div>
          </div>
        </phn-single-drawer>
      `);
      // await promise;
    });
    it.skip('should stop menu-item click event propagating while animation is running and the user click back on the drawer', async () => {
      var _a, _b, _c;
      const page = await setUp(defaultProps, [DrawerHeader]);
      goTo();
      await page.waitForChanges();
      expect(getHTMLElement((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('phn-back-button'))).toBeFalsy();
      goTo(RoutingKeys.SHOP);
      await page.waitForChanges();
      expect(getHTMLElement((_b = page.root) === null || _b === void 0 ? void 0 : _b.querySelector('phn-back-button'))).toBeTruthy();
      await page.waitForChanges();
      syncAnimation();
      await page.waitForChanges();
      expect(getHTMLElement((_c = page.root) === null || _c === void 0 ? void 0 : _c.querySelector('phn-back-button'))).toBeTruthy();
    });
  });
  describe('data analytics', () => {
    it('should send data event after single drawer is loaded', async () => {
      var _a;
      const page = await setUp(defaultProps);
      goTo(RoutingKeys.MODELS);
      await page.waitForChanges();
      const event = globalDataLayerService.gdl.DataLayerStore[0];
      expect((_a = event.context) === null || _a === void 0 ? void 0 : _a.eventAction).toEqual(EventActions.DRAWER_LOAD);
      expect(event.componentDisplay).toEqual({
        displayElementType: 'level2_single-drawer',
        displayElementId: 'level2-models',
        displayElementName: 'Single Drawer'
      });
    });
  });
  describe('phnDrawerStatus event', () => {
    let dispatchEventSpy;
    beforeEach(() => {
      dispatchEventSpy = jest.spyOn(helper, 'dispatchEvent');
    });
    afterEach(() => {
      dispatchEventSpy.mockClear();
    });
    it('should dispatch phnDrawerStatus event with correct status when double drawer starts opening', async () => {
      await setUp(defaultProps, [Backdrop]);
      await animationManager.play(AnimationSequences.OPEN_SINGLE_DRAWER);
      expect(dispatchEventSpy).toHaveBeenCalled();
      expect(dispatchEventSpy).toHaveBeenCalledWith('phn-single-drawer', 'phnDrawerStatus', {
        bubbles: true,
        composed: true,
        detail: { status: 'startOpening' }
      });
    });
    it('should dispatch phnDrawerStatus event with correct status when double drawer finishes opening', async () => {
      await setUp(defaultProps, [Backdrop]);
      await animationManager.play(AnimationSequences.OPEN_SINGLE_DRAWER);
      expect(dispatchEventSpy).toHaveBeenCalled();
      expect(dispatchEventSpy).toHaveBeenCalledWith('phn-single-drawer', 'phnDrawerStatus', {
        bubbles: true,
        composed: true,
        detail: { status: 'finishOpening' }
      });
    });
    it('should dispatch phnDrawerStatus event with correct status when double drawer starts closing', async () => {
      await setUp(defaultProps, [Backdrop]);
      await animationManager.play(AnimationSequences.CLOSE_SINGLE_DRAWER);
      expect(dispatchEventSpy).toHaveBeenCalled();
      expect(dispatchEventSpy).toHaveBeenCalledWith('phn-single-drawer', 'phnDrawerStatus', {
        bubbles: true,
        composed: true,
        detail: { status: 'finishClosing' }
      });
    });
    it('should dispatch phnDrawerStatus event with correct status when double drawer finishes closing', async () => {
      await setUp(defaultProps, [Backdrop]);
      await animationManager.play(AnimationSequences.CLOSE_SINGLE_DRAWER);
      expect(dispatchEventSpy).toHaveBeenCalled();
      expect(dispatchEventSpy).toHaveBeenCalledWith('phn-single-drawer', 'phnDrawerStatus', {
        bubbles: true,
        composed: true,
        detail: { status: 'finishClosing' }
      });
    });
  });
  describe('Sections', () => {
    it('Should show mainmenu at the first opening', async () => {
      const page = await setUp(defaultProps, [Router]);
      goTo();
      await page.waitForChanges();
      expect(page.root).toMatchInlineSnapshot(`
        <phn-single-drawer>
          <div class="active drawer">
            <span aria-hidden="true" class="first-focus" tabindex="-1"></span>
            <div class="bottom-gradient"></div>
            <div class="drawer-content">
              <phn-drawer-header backbuttonanalyticsid="" breakpoint="0" locale="xx-XX" route="mainmenu"></phn-drawer-header>
              <phn-router>
                <phn-level-1 breakpoint="0" locale="xx-XX"></phn-level-1>
              </phn-router>
            </div>
          </div>
        </phn-single-drawer>
      `);
    });
    it('should open myPorsche Section when myporsche button is clicked', async () => {
      var _a;
      const page = await setUp(defaultProps, [Router]);
      goTo();
      await page.waitForChanges();
      goTo(RoutingKeys.MY_PORSCHE);
      await page.waitForChanges();
      await openMenuFromMyPorscheIcon(page);
      expect((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('phn-myporsche-drawer')).toBeTruthy();
    });
    it('should go to car series model overview when one model item in mainmenu is clicked', async () => {
      navContentStore.state.models = mockModelsContent;
      const page = await setUp(defaultProps, [Router, Level1, Models, CarBodyTypeDrawer]);
      goTo();
      await page.waitForChanges();
      //Select Models Section from Level 1
      const modelsMenuItem = getHTMLElementFromPage(page, 'phn-menu-item[elementid="models"]');
      expect(modelsMenuItem).toBeTruthy();
      modelsMenuItem === null || modelsMenuItem === void 0 ? void 0 : modelsMenuItem.click();
      await page.waitForChanges();
      await waitForFocusTimeout();
      await page.waitForChanges();
      //Select Model 718 from Models menu
      const modelMenuItem718 = getHTMLElementFromPage(page, 'phn-menu-item[elementid="models/mainmenu.718"]');
      expect(modelMenuItem718).toBeTruthy();
      goTo(getSeriesRoutingKey('mainmenu.718')); //a better test case would be clicking at the menu item itself
      await page.waitForChanges();
      await waitForFocusTimeout();
      await page.waitForChanges();
      expect(getHTMLElementFromPage(page, 'phn-car-body-types-drawer')).toBeTruthy();
    });
    it('should move backwards from car series model overview to the drawer level1 when back button is clicked', async () => {
      navContentStore.state.models = mockModelsContent;
      const page = await setUp(defaultProps, [Router, DrawerHeader, CarBodyTypeDrawer, Models, Level1]);
      goTo(getSeriesRoutingKey('mainmenu.718'));
      await page.waitForChanges();
      expect(getHTMLElementFromPage(page, 'phn-car-body-types-drawer')).toBeTruthy();
      await clickOnBackButton(page);
      await waitForFocusTimeout();
      await page.waitForChanges();
      expect(getHTMLElementFromPage(page, 'phn-car-body-types-drawer')).toBeFalsy();
      expect(getHTMLElementFromPage(page, 'phn-level-1')).toBeTruthy();
    });
  });
});
//# sourceMappingURL=single-drawer.spec.js.map
