import { DealerSearchFormGeolocation } from "../../dealer-search-form-geolocation/dealer-search-form-geolocation";
jest.mock('../../../services/maps-service.ts');
import { h } from "@stencil/core";
import { newSpecPage } from "@stencil/core/testing";
import { constructRoutingKey, getSeriesRoutingKey, RoutingKeys } from "../../../entities/routing-key";
import globalDataLayerService from "../../../services/analytics/global-data-layer-service";
import animationManager from "../../../services/animations/animation-manager";
import { navContentStore } from "../../../state/nav-content-store";
import * as el from "../../../test/element-helpers";
import { mockDealerContent, mockShopContent } from "../../../test/test-data";
import { AnimationSequences, EventActions } from "../../../utility/constants";
import * as helper from "../../../utility/helper";
import { AutocompleteSearchField } from "../../autocomplete-search-field/autocomplete-search-field";
import { DealerSearchForm } from "../../dealer-search-form/dealer-search-form";
import { DrawerHeader } from "../../drawer-header/drawer-header";
import { MenuItem } from "../../menu-item/menu-item";
import { Menu } from "../../menu/menu";
import { Router } from "../../router/router";
import { SingleDrawer } from "../single-drawer";
import { Backdrop } from "../../backdrop/backdrop";
import { DrawerStatusValues } from "../../../utility/constants/app";
import { routerStore } from "../../../state/router-store";
describe('Single Drawer', () => {
  const defaultProps = {
    breakpoint: 0,
    locale: 'xx-XX',
    routingKeyHistory: [RoutingKeys.MAIN_MENU],
    routingKeyPointer: 0
  };
  const playAnimationOfSlideLeft = async (page) => {
    await animationManager.play('transitionNextLevelSingleDrawer');
    await page.waitForChanges();
    await waitForFocusTimeout();
  };
  const playAnimationOfSlideRight = async (page) => {
    await animationManager.play('transitionPreviousLevelSingleDrawer');
    await page.waitForChanges();
    await waitForFocusTimeout();
  };
  const waitForFocusTimeout = async () => {
    await new Promise((resolve) => {
      setTimeout(resolve, 0);
    });
  };
  describe('snapshot tests', () => {
    let page;
    beforeEach(async () => {
      page = await newSpecPage({
        components: [SingleDrawer],
        template: () => h("phn-single-drawer", Object.assign({}, defaultProps))
      });
      if (page.root)
        animationManager.initialize(page.root);
      jest.spyOn(page.rootInstance.focusTimeout, 'set').mockImplementation((cb) => {
        if (typeof cb === 'function') {
          cb();
        }
      });
    });
    it('renders the animation drawer and starts opening', async () => {
      expect(page.root).toMatchInlineSnapshot(`
        <phn-single-drawer>
          <div class="animating drawer" style="right: -100%;">
            <div class="bottom-gradient"></div>
            <div class="drawer-content">
              <phn-drawer-header activeroutingkey="mainmenu" backbuttonanalyticsid="" backbuttontext="" breakpoint="0" locale="xx-XX"></phn-drawer-header>
              <phn-router activeroutingkey="mainmenu" breakpoint="0" locale="xx-XX"></phn-router>
            </div>
          </div>
        </phn-single-drawer>
      `);
    });
    it('once the drawer is open and the animation is complete, it should still show mainmenu', async () => {
      await playAnimationOfSlideLeft(page);
      expect(page.root).toMatchInlineSnapshot(`
        <phn-single-drawer>
          <div class="active drawer">
            <span aria-hidden="true" class="first-focus" tabindex="-1"></span>
            <div class="bottom-gradient"></div>
            <div class="drawer-content">
              <phn-drawer-header activeroutingkey="mainmenu" backbuttonanalyticsid="" backbuttontext="" breakpoint="0" locale="xx-XX"></phn-drawer-header>
              <phn-router activeroutingkey="mainmenu" breakpoint="0" locale="xx-XX"></phn-router>
            </div>
          </div>
        </phn-single-drawer>
      `);
    });
    it.skip('should complete animation of car series model overview when one model item in mainmenu is clicked', async () => {
      // given
      await playAnimationOfSlideLeft(page);
      if (page.root !== undefined) {
        page.root.routingKeyHistory = [RoutingKeys.MAIN_MENU, getSeriesRoutingKey('mainmenu.718')];
        page.root.routingKeyPointer = 1;
      }
      await page.waitForChanges();
      // then
      expect(page.root).toMatchInlineSnapshot(`
        <phn-single-drawer>
          <div class="active drawer">
            <span aria-hidden="true" class="first-focus" tabindex="-1"></span>
            <div class="bottom-gradient"></div>
            <div class="menu-drawer-content">
              <phn-drawer-header backbuttonanalyticsid="" backbuttontext="" breakpoint="0"></phn-drawer-header>
              <phn-router activeroutingkey="mainmenu" breakpoint="0" locale="xx-XX"></phn-router>
            </div>
          </div>
          <div class="animating drawer opening">
            <div class="bottom-gradient"></div>
            <div class="menu-drawer-content">
              <phn-drawer-header backbuttonanalyticsid="" backbuttontext="" showbackbutton="" breakpoint="0"></phn-drawer-header>
              <phn-router activeroutingkey="series/mainmenu.718" breakpoint="0" locale="xx-XX"></phn-router>
            </div>
          </div>
        </phn-single-drawer>
      `);
      // when
      await playAnimationOfSlideLeft(page);
      // then
      expect(page.root).toMatchInlineSnapshot(`
        <phn-single-drawer>
          <div class="active drawer">
            <span aria-hidden="true" class="first-focus" tabindex="-1"></span>
            <div class="bottom-gradient"></div>
            <div class="menu-drawer-content">
              <phn-drawer-header backbuttonanalyticsid="" backbuttontext="" showbackbutton="" breakpoint="0"></phn-drawer-header>
              <phn-router activeroutingkey="series/mainmenu.718" breakpoint="0" locale="xx-XX"></phn-router>
            </div>
          </div>
        </phn-single-drawer>
      `);
    });
    it.skip('should move backwards from car series model overview to the drawer level1 when back button is clicked', async () => {
      // given
      await playAnimationOfSlideLeft(page);
      if (page.root !== undefined) {
        page.root.routingKeyHistory = [RoutingKeys.MAIN_MENU, getSeriesRoutingKey('mainmenu.718')];
        page.root.routingKeyPointer = 1;
      }
      await playAnimationOfSlideLeft(page);
      if (page.root !== undefined) {
        page.root.routingKeyPointer = 0;
      }
      // await page.waitForChanges();
      // then
      expect(page.root).toMatchInlineSnapshot(`
        <phn-single-drawer>
          <div class="active drawer">
            <span aria-hidden="true" class="first-focus" tabindex="-1"></span>
            <div class="bottom-gradient"></div>
            <div class="menu-drawer-content">
              <phn-drawer-header backbuttonanalyticsid="" backbuttontext="" breakpoint="0"></phn-drawer-header>
              <phn-router activeroutingkey="mainmenu" breakpoint="0" locale="xx-XX"></phn-router>
            </div>
          </div>
          <div class="animating closing drawer">
            <div class="bottom-gradient"></div>
            <div class="menu-drawer-content">
              <phn-drawer-header backbuttonanalyticsid="" backbuttontext="" showbackbutton="" breakpoint="0"></phn-drawer-header>
              <phn-router activeroutingkey="series/mainmenu.718" breakpoint="0" locale="xx-XX"></phn-router>
            </div>
          </div>
        </phn-single-drawer>
      `);
      // when
      await playAnimationOfSlideRight(page);
      // then
      expect(page.root).toMatchInlineSnapshot(`
        <phn-single-drawer>
          <div class="active drawer">
            <span aria-hidden="true" class="first-focus" tabindex="-1"></span>
            <div class="bottom-gradient"></div>
            <div class="menu-drawer-content">
              <phn-drawer-header backbuttonanalyticsid="" backbuttontext="" breakpoint="0"></phn-drawer-header>
              <phn-router activeroutingkey="mainmenu" breakpoint="0" locale="xx-XX"></phn-router>
            </div>
          </div>
        </phn-single-drawer>
      `);
    });
    it('should begin close drawer animation when close button is clicked', async () => {
      // given
      await playAnimationOfSlideLeft(page);
      page.rootInstance.drawerClosed.emit = jest.fn();
      if (page.root !== undefined) {
        page.root.routingKeyPointer = -1;
      }
      await page.waitForChanges();
      // then
      expect(page.root).toMatchInlineSnapshot(`
        <phn-single-drawer>
          <div class="animating drawer">
            <div class="bottom-gradient"></div>
            <div class="drawer-content">
              <phn-drawer-header activeroutingkey="mainmenu" backbuttonanalyticsid="" backbuttontext="" breakpoint="0" locale="xx-XX"></phn-drawer-header>
              <phn-router activeroutingkey="mainmenu" breakpoint="0" locale="xx-XX"></phn-router>
            </div>
          </div>
        </phn-single-drawer>
      `);
    });
    it('should stop menu-item click event propagating while animation is running and user click on a button', async () => {
      const event = new MouseEvent('mouseUp');
      const propagationMock = jest.spyOn(event, 'stopPropagation');
      if (page.root !== undefined) {
        page.root.routingKeyHistory = [RoutingKeys.MAIN_MENU, RoutingKeys.SHOP];
        page.root.routingKeyPointer = 1;
      }
      await page.waitForChanges();
      const promise = playAnimationOfSlideLeft(page);
      page.rootInstance.handleMobileMenuItemClick(event);
      await page.waitForChanges();
      expect(propagationMock).toBeCalledTimes(1);
      expect(page.root).toMatchInlineSnapshot(`
        <phn-single-drawer>
          <div class="active drawer">
            <span aria-hidden="true" class="first-focus" tabindex="-1"></span>
            <div class="bottom-gradient"></div>
            <div class="drawer-content">
              <phn-drawer-header activeroutingkey="shop" backbuttonanalyticsid="" backbuttontext="" breakpoint="0" locale="xx-XX" showbackbutton=""></phn-drawer-header>
              <phn-router activeroutingkey="shop" breakpoint="0" locale="xx-XX"></phn-router>
            </div>
          </div>
        </phn-single-drawer>
      `);
      await promise;
    });
    it('should stop menu-item click event propagating while animation is running and the user close drawer', async () => {
      const event = new MouseEvent('click');
      const propagationMock = jest.spyOn(event, 'stopPropagation');
      if (page.root !== undefined) {
        page.root.routingKeyHistory = [RoutingKeys.MAIN_MENU, RoutingKeys.SHOP];
        page.root.routingKeyPointer = 1;
      }
      await page.waitForChanges();
      const promise = playAnimationOfSlideLeft(page);
      page.rootInstance.handleClickDrawerHeaderClose(event);
      await page.waitForChanges();
      expect(propagationMock).toBeCalledTimes(1);
      expect(page.root).toMatchInlineSnapshot(`
        <phn-single-drawer>
          <div class="active drawer">
            <span aria-hidden="true" class="first-focus" tabindex="-1"></span>
            <div class="bottom-gradient"></div>
            <div class="drawer-content">
              <phn-drawer-header activeroutingkey="shop" backbuttonanalyticsid="" backbuttontext="" breakpoint="0" locale="xx-XX" showbackbutton=""></phn-drawer-header>
              <phn-router activeroutingkey="shop" breakpoint="0" locale="xx-XX"></phn-router>
            </div>
          </div>
        </phn-single-drawer>
      `);
      await promise;
    });
    it('should stop menu-item click event propagating while animation is running and the user click back on the drawer', async () => {
      const event = new MouseEvent('click');
      const propagationMock = jest.spyOn(event, 'stopPropagation');
      if (page.root !== undefined) {
        page.root.routingKeyHistory = [RoutingKeys.MAIN_MENU, RoutingKeys.SHOP];
        page.root.routingKeyPointer = 1;
      }
      await page.waitForChanges();
      const promise = playAnimationOfSlideLeft(page);
      page.rootInstance.handleClickDrawerHeaderBack(event);
      await page.waitForChanges();
      expect(propagationMock).toBeCalledTimes(1);
      expect(page.root).toMatchInlineSnapshot(`
        <phn-single-drawer>
          <div class="active drawer">
            <span aria-hidden="true" class="first-focus" tabindex="-1"></span>
            <div class="bottom-gradient"></div>
            <div class="drawer-content">
              <phn-drawer-header activeroutingkey="shop" backbuttonanalyticsid="" backbuttontext="" breakpoint="0" locale="xx-XX" showbackbutton=""></phn-drawer-header>
              <phn-router activeroutingkey="shop" breakpoint="0" locale="xx-XX"></phn-router>
            </div>
          </div>
        </phn-single-drawer>
      `);
      await promise;
    });
  });
  describe('mouse navigation', () => {
    let page;
    beforeEach(async () => {
      page = await newSpecPage({
        components: [SingleDrawer],
        template: () => h("phn-single-drawer", Object.assign({}, defaultProps))
      });
      if (page.root)
        animationManager.initialize(page.root);
      jest.spyOn(page.rootInstance.focusTimeout, 'set').mockImplementation((cb) => {
        if (typeof cb === 'function') {
          cb();
        }
      });
    });
    it('closes menu when clicking off drawer', async () => {
      var _a;
      // given
      await playAnimationOfSlideLeft(page);
      const body = helper.getHTMLElement((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('body'));
      // when
      body === null || body === void 0 ? void 0 : body.click();
      await page.waitForChanges();
      // then
      expect(page.rootInstance.routingKeyHistory).toEqual([RoutingKeys.MAIN_MENU]);
      expect(page.rootInstance.animatingPointer).toEqual(0);
      expect(page.rootInstance.routingKeyPointer).toEqual(0);
      expect(page.rootInstance.usingKeyboard).toBeFalsy();
    });
    it('closes menu when clicking off drawer but drawer is not completely open', async () => {
      var _a;
      // given
      const body = helper.getHTMLElement((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('body'));
      // when
      body === null || body === void 0 ? void 0 : body.click();
      await page.waitForChanges();
      // then
      expect(page.rootInstance.routingKeyHistory).toEqual([RoutingKeys.MAIN_MENU]);
      expect(page.rootInstance.animatingPointer).toEqual(-1);
      expect(page.rootInstance.routingKeyPointer).toEqual(0);
      expect(page.rootInstance.usingKeyboard).toBeFalsy();
    });
  });
  describe('keyboard navigation', () => {
    it('focuses on the first focusable element when user is at the last focusable element and presses tab', async () => {
      var _a, _b;
      // given
      const page = await newSpecPage({
        components: [SingleDrawer, Router, DrawerHeader],
        template: () => h("phn-single-drawer", Object.assign({}, defaultProps))
      });
      if (page.root)
        animationManager.initialize(page.root);
      await playAnimationOfSlideLeft(page);
      expect(helper.focusOnElement).toBeCalledTimes(1);
      expect(helper.focusOnElement).toBeCalledWith((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('.first-focus'));
      const activeDrawer = helper.getHTMLElement((_b = page.root) === null || _b === void 0 ? void 0 : _b.querySelector('.active'));
      const firstFocussable = el.getFirstFocusable(activeDrawer);
      const lastFocussable = el.getLastFocusable(activeDrawer);
      // when
      el.tabKeyDown(lastFocussable);
      // then
      expect(helper.focusOnElement).toBeCalledTimes(2);
      expect(helper.focusOnElement).toBeCalledWith(firstFocussable);
    });
    it('focusses on the last focusable element when user is at the first focusable element and presses shift+tab', async () => {
      var _a, _b;
      // given
      const page = await newSpecPage({
        components: [SingleDrawer, Router, DrawerHeader],
        template: () => h("phn-single-drawer", Object.assign({}, defaultProps))
      });
      if (page.root)
        animationManager.initialize(page.root);
      await playAnimationOfSlideLeft(page);
      expect(helper.focusOnElement).toBeCalledTimes(1);
      expect(helper.focusOnElement).toBeCalledWith((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('.first-focus'));
      const activeDrawer = helper.getHTMLElement((_b = page.root) === null || _b === void 0 ? void 0 : _b.querySelector('.active'));
      const firstFocussable = el.getFirstFocusable(activeDrawer);
      const lastFocussable = el.getLastFocusable(activeDrawer);
      // when
      el.tabKeyDown(firstFocussable, true);
      // then
      expect(helper.focusOnElement).toBeCalledTimes(2);
      expect(helper.focusOnElement).toBeCalledWith(lastFocussable);
    });
    it('focusses on the first focusable element when user is using keyboard and opens a new drawer', async () => {
      var _a;
      // given
      const page = await newSpecPage({
        components: [SingleDrawer, Router, DrawerHeader],
        template: () => h("phn-single-drawer", Object.assign({}, defaultProps, { usingKeyboard: true }))
      });
      if (page.root)
        animationManager.initialize(page.root);
      await playAnimationOfSlideLeft(page);
      const activeDrawer = helper.getHTMLElement((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('.active'));
      const firstFocussable = el.getFirstFocusable(activeDrawer);
      // then
      expect(helper.focusOnElement).toBeCalledTimes(1);
      expect(helper.focusOnElement).toBeCalledWith(firstFocussable);
    });
    it('focusses on the first autofocussable element when user is opening a drawer which contains an autofocussable element with keyboard', async () => {
      var _a, _b;
      const dealer = mockDealerContent;
      navContentStore.state.dealer = dealer;
      // given
      const page = await newSpecPage({
        components: [
          SingleDrawer,
          Router,
          DrawerHeader,
          DealerSearchForm,
          AutocompleteSearchField,
          DealerSearchFormGeolocation
        ],
        template: () => h("phn-single-drawer", Object.assign({}, defaultProps, { usingKeyboard: true }))
      });
      if (page.root)
        animationManager.initialize(page.root);
      await playAnimationOfSlideLeft(page);
      expect(helper.focusOnElement).toBeCalledTimes(1);
      expect(helper.focusOnElement).toBeCalledWith((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('.close-button'));
      if (page.root !== undefined) {
        page.root.routingKeyHistory = [RoutingKeys.MAIN_MENU, RoutingKeys.DEALER_SEARCH];
        page.root.routingKeyPointer = 1;
      }
      await page.waitForChanges();
      await playAnimationOfSlideLeft(page);
      const autofocusElement = helper.getHTMLElement((_b = page.root) === null || _b === void 0 ? void 0 : _b.querySelector('.autofocus'));
      el.tabKeyDown(autofocusElement);
      // then
      expect(helper.focusOnElement).toBeCalledTimes(2);
      expect(helper.focusOnElement).toBeCalledWith(autofocusElement);
    });
    it('focusses on the previously-clicked element when user is using keyboard and clicks the back button', async () => {
      var _a, _b, _c;
      // given
      navContentStore.state.shop = mockShopContent;
      const page = await newSpecPage({
        components: [SingleDrawer, Router, DrawerHeader, Menu, MenuItem],
        template: () => h("phn-single-drawer", Object.assign({}, defaultProps, { usingKeyboard: true }))
      });
      if (page.root)
        animationManager.initialize(page.root);
      jest.spyOn(page.rootInstance.focusTimeout, 'set').mockImplementation((cb) => {
        if (typeof cb === 'function') {
          cb();
        }
      });
      await playAnimationOfSlideLeft(page);
      await page.waitForChanges();
      if (page.root !== undefined) {
        page.root.routingKeyHistory = [RoutingKeys.MAIN_MENU, RoutingKeys.SHOP];
        page.root.routingKeyPointer = 1;
      }
      await playAnimationOfSlideLeft(page);
      await page.waitForChanges();
      expect(helper.focusOnElement).toBeCalledTimes(2);
      expect(helper.focusOnElement).toHaveBeenLastCalledWith((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('.back-button'));
      if (page.root !== undefined) {
        page.root.routingKeyHistory = [
          RoutingKeys.MAIN_MENU,
          RoutingKeys.SHOP,
          constructRoutingKey(RoutingKeys.SHOP, mockShopContent.children[0].id)
        ];
        page.root.routingKeyPointer = 2;
      }
      await playAnimationOfSlideLeft(page);
      await page.waitForChanges();
      // then
      expect(helper.focusOnElement).toBeCalledTimes(3);
      expect(helper.focusOnElement).toHaveBeenLastCalledWith((_b = page.root) === null || _b === void 0 ? void 0 : _b.querySelector('.back-button'));
      // when
      if (page.root !== undefined) {
        page.root.routingKeyPointer = 1;
      }
      await playAnimationOfSlideRight(page);
      await page.waitForChanges();
      // then
      expect(helper.focusOnElement).toBeCalledTimes(4);
      expect(helper.focusOnElement).toHaveBeenLastCalledWith((_c = page.root) === null || _c === void 0 ? void 0 : _c.querySelector(`.active [data-id="${constructRoutingKey(RoutingKeys.SHOP, mockShopContent.children[0].id)}"]`));
    });
    it('focusses on the first autofocussable element when user is opening a drawer which contains an autofocussable element with mouse click', async () => {
      var _a, _b;
      const dealer = mockDealerContent;
      navContentStore.state.dealer = dealer;
      // given
      const page = await newSpecPage({
        components: [
          SingleDrawer,
          Router,
          DrawerHeader,
          DealerSearchForm,
          AutocompleteSearchField,
          DealerSearchFormGeolocation
        ],
        template: () => h("phn-single-drawer", Object.assign({}, defaultProps))
      });
      if (page.root)
        animationManager.initialize(page.root);
      await playAnimationOfSlideLeft(page);
      expect(helper.focusOnElement).toBeCalledTimes(1);
      expect(helper.focusOnElement).toBeCalledWith((_a = page.root) === null || _a === void 0 ? void 0 : _a.querySelector('.first-focus'));
      if (page.root !== undefined) {
        page.root.routingKeyHistory = [RoutingKeys.MAIN_MENU, RoutingKeys.DEALER_SEARCH];
        page.root.routingKeyPointer = 1;
      }
      await page.waitForChanges();
      await playAnimationOfSlideLeft(page);
      // then
      expect(helper.focusOnElement).toBeCalledTimes(2);
      expect(helper.focusOnElement).toBeCalledWith((_b = page.root) === null || _b === void 0 ? void 0 : _b.querySelector('.autofocus'));
    });
  });
  describe('data analytics', () => {
    it('should send data event after single drawer is loaded', async () => {
      var _a;
      routerStore.state.routingKeyHistory = ['mainmenu', 'models'];
      routerStore.state.routingKeyPointer = 1;
      const page = await newSpecPage({
        components: [SingleDrawer],
        template: () => (h("phn-single-drawer", Object.assign({}, defaultProps, { routingKeyHistory: ['mainmenu', 'models'], routingKeyPointer: 1 })))
      });
      if (page.root)
        animationManager.initialize(page.root);
      page.rootInstance.onTransitionEnd();
      await page.waitForChanges();
      await waitForFocusTimeout();
      const event = globalDataLayerService.gdl.DataLayerStore[0];
      expect((_a = event.context) === null || _a === void 0 ? void 0 : _a.eventAction).toEqual(EventActions.DRAWER_LOAD);
      expect(event.componentDisplay).toEqual({
        displayElementType: 'level2_single-drawer',
        displayElementId: 'level2-models',
        displayElementName: 'Single Drawer'
      });
    });
  });
  describe('phnDrawerStatus event', () => {
    let page;
    beforeEach(async () => {
      page = await newSpecPage({
        components: [SingleDrawer, Backdrop],
        template: () => h("phn-single-drawer", Object.assign({}, defaultProps))
      });
      if (page.root)
        animationManager.initialize(page.root);
      jest.spyOn(page.rootInstance.focusTimeout, 'set').mockImplementation((cb) => {
        if (typeof cb === 'function') {
          cb();
        }
      });
    });
    it('should dispatch phnDrawerStatus event with correct status when double drawer starts opening', async () => {
      const phnDrawerStatusEvent = jest.spyOn(page.rootInstance.phnDrawerStatus, 'emit');
      await animationManager.play(AnimationSequences.OPEN_SINGLE_DRAWER);
      expect(phnDrawerStatusEvent).toHaveBeenCalled();
      expect(phnDrawerStatusEvent).toHaveBeenCalledWith({ status: DrawerStatusValues.startOpening });
    });
    it('should dispatch phnDrawerStatus event with correct status when double drawer finishes opening', async () => {
      const phnDrawerStatusEvent = jest.spyOn(page.rootInstance.phnDrawerStatus, 'emit');
      await animationManager.play(AnimationSequences.OPEN_SINGLE_DRAWER);
      expect(phnDrawerStatusEvent).toHaveBeenCalled();
      expect(phnDrawerStatusEvent).toHaveBeenCalledWith({ status: DrawerStatusValues.finishOpening });
    });
    it('should dispatch phnDrawerStatus event with correct status when double drawer starts closing', async () => {
      const phnDrawerStatusEvent = jest.spyOn(page.rootInstance.phnDrawerStatus, 'emit');
      await animationManager.play(AnimationSequences.CLOSE_SINGLE_DRAWER);
      expect(phnDrawerStatusEvent).toHaveBeenCalled();
      expect(phnDrawerStatusEvent).toHaveBeenCalledWith({ status: DrawerStatusValues.startClosing });
    });
    it('should dispatch phnDrawerStatus event with correct status when double drawer finishes closing', async () => {
      const phnDrawerStatusEvent = jest.spyOn(page.rootInstance.phnDrawerStatus, 'emit');
      await animationManager.play(AnimationSequences.CLOSE_SINGLE_DRAWER);
      expect(phnDrawerStatusEvent).toHaveBeenCalled();
      expect(phnDrawerStatusEvent).toHaveBeenCalledWith({ status: DrawerStatusValues.finishClosing });
    });
  });
});
//# sourceMappingURL=single-drawer.spec.js.map
