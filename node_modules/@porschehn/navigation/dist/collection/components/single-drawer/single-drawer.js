import { h, Host } from "@stencil/core";
import { RoutingKeyPointers, RoutingKeys } from "../../entities/routing-key";
import animationManager from "../../services/animations/animation-manager";
import globalDataLayerService from "../../services/analytics/global-data-layer-service";
import { AnimationSequences, DisplayElementTypes, ElementTypes, EventActions, FOCUSABLE_ELEMENTS_SELECTOR } from "../../utility/constants";
import { focusOnElement, getHTMLElement, isPromise, isString } from "../../utility/helper";
import { Timeout } from "../../utility/timeout";
import DrawerContent from "./drawer-content";
import { isPlayingSingleDrawerAnimation, registerCloseSingleDrawerAnimation, registerOpenSingleDrawerAnimation, registerTransitionNextLevelSingleDrawerAnimation, registerTransitionPreviousLevelSingleDrawerAnimation } from "./single-drawer-animation-sequences";
import analyticsManager from "../../services/analytics/analytics-manager";
import { DrawerStatusValues } from "../../utility/constants/app";
import { getAllFocusableElements } from "../double-drawer/helper";
// INFO: For routing explanation, see README in this directory
export class SingleDrawer {
  constructor() {
    this.focusTimeout = new Timeout(0);
    this.operationPipeline = [];
    this.breakpoint = undefined;
    this.locale = undefined;
    this.usingKeyboard = false;
    this.routingKeyHistory = undefined;
    this.routingKeyPointer = undefined;
    this.receivedContent = false;
    this.animatingPointer = -1;
  }
  handleKeyDown(e) {
    if (e.key !== 'Tab') {
      return;
    }
    const targetElement = getHTMLElement(e.target);
    if (targetElement === null) {
      return;
    }
    let focusableDrawerElements = getAllFocusableElements(this.el.querySelector('.active'));
    if (focusableDrawerElements.length === 0) {
      return;
    }
    const activeRoutingKey = this.routingKeyHistory[this.routingKeyPointer];
    if (activeRoutingKey.startsWith(RoutingKeys.DEALER_SEARCH)) {
      focusableDrawerElements = focusableDrawerElements.filter((element) => element.nodeName !== 'BUTTON' && element.nodeName !== 'A');
    }
    const firstFocusableDrawerElement = focusableDrawerElements[0];
    const lastFocusableDrawerElement = focusableDrawerElements[focusableDrawerElements.length - 1];
    if (targetElement === firstFocusableDrawerElement && e.shiftKey) {
      e.preventDefault();
      if (lastFocusableDrawerElement !== null) {
        focusOnElement(lastFocusableDrawerElement);
      }
      return;
    }
    if (targetElement === lastFocusableDrawerElement && !e.shiftKey) {
      e.preventDefault();
      if (firstFocusableDrawerElement !== null) {
        focusOnElement(firstFocusableDrawerElement);
      }
      return;
    }
  }
  handleMobileMenuItemClick(e) {
    if (isPlayingSingleDrawerAnimation()) {
      e.stopPropagation();
      return;
    }
    this.animatingPointer = this.routingKeyPointer;
  }
  handleClickDrawerHeaderClose(e) {
    if (isPlayingSingleDrawerAnimation()) {
      e.stopPropagation();
      return;
    }
  }
  handleClickDrawerHeaderBack(e) {
    if (isPlayingSingleDrawerAnimation()) {
      e.stopPropagation();
      return;
    }
    this.animatingPointer = this.routingKeyPointer;
  }
  onTransitionEnd() {
    const focussedElementId = this.animatingPointer > this.routingKeyPointer ? this.routingKeyHistory[this.animatingPointer] : '';
    this.animatingPointer = this.routingKeyPointer;
    const isNavigatingBackwards = this.routingKeyPointer < this.routingKeyHistory.length - 1;
    this.drawerChanged.emit(isNavigatingBackwards);
    // Focus needs to happen after rerender, so wait for next tick
    this.focusTimeout.set(async () => {
      this.focusOnActiveDrawer(focussedElementId);
    });
    this.sendDataLayerEvent();
  }
  componentWillLoad() {
    registerOpenSingleDrawerAnimation({
      onAnimationStarts: () => {
        this.phnDrawerStatus.emit({ status: DrawerStatusValues.startOpening });
      },
      onAnimationEnds: () => {
        this.onTransitionEnd();
        this.phnDrawerStatus.emit({ status: DrawerStatusValues.finishOpening });
      }
    });
    registerCloseSingleDrawerAnimation({
      onAnimationStarts: () => {
        this.phnDrawerStatus.emit({ status: DrawerStatusValues.startClosing });
      },
      onAnimationEnds: () => {
        this.backdropClosed.emit();
        this.phnDrawerStatus.emit({ status: DrawerStatusValues.finishClosing });
      }
    });
    registerTransitionNextLevelSingleDrawerAnimation({
      onAnimationEnds: () => this.onTransitionEnd()
    });
    registerTransitionPreviousLevelSingleDrawerAnimation({ onAnimationEnds: () => this.onTransitionEnd() });
  }
  focusOnActiveDrawer(focussedElementId) {
    const autoFocusElement = getHTMLElement(this.el.querySelector('.active .autofocus'));
    if (autoFocusElement !== null) {
      focusOnElement(autoFocusElement);
      return;
    }
    if (this.usingKeyboard) {
      let focussableElement = null;
      if (isString(focussedElementId)) {
        focussableElement = getHTMLElement(this.el.querySelector(`.active [data-id="${focussedElementId}"]`));
      }
      if (focussableElement === null) {
        focussableElement = getHTMLElement(this.el.querySelector(`.active ${FOCUSABLE_ELEMENTS_SELECTOR}`));
      }
      if (focussableElement !== null) {
        focusOnElement(focussableElement);
      }
    }
    else {
      //Todo: Why first-focus class? We have it nowhere
      const firstFocus = getHTMLElement(this.el.querySelector('.first-focus'));
      if (firstFocus !== null) {
        focusOnElement(firstFocus);
      }
    }
  }
  sendDataLayerEvent() {
    analyticsManager.setDrawerType(DisplayElementTypes.SingleDrawer);
    const activeRoutingKey = this.routingKeyHistory[this.routingKeyPointer];
    globalDataLayerService.pushDataLayerEvent(EventActions.DRAWER_LOAD, {
      componentDisplay: {
        displayElementType: analyticsManager.calculateDisplayElementType(activeRoutingKey, ElementTypes.singleDrawer),
        displayElementId: analyticsManager.calculateDisplayElementId(),
        displayElementName: 'Single Drawer'
      }
    });
  }
  disconnectedCallback() {
    this.focusTimeout.cancel();
  }
  async componentDidRender() {
    const promises = [];
    for (const operation of this.operationPipeline) {
      const maybePromise = operation();
      if (isPromise(maybePromise)) {
        promises.push(maybePromise);
      }
    }
    await Promise.all(promises);
    this.operationPipeline.splice(0, this.operationPipeline.length);
  }
  render() {
    var _a, _b;
    const isAnimatingForward = this.routingKeyPointer > this.animatingPointer;
    const isAnimatingBackward = this.routingKeyPointer < this.animatingPointer;
    let topDrawerContentPointer = -1;
    let bottomDrawerContentPointer = this.routingKeyPointer;
    if (isAnimatingForward && this.animatingPointer !== RoutingKeyPointers.LEVEL_ZERO) {
      topDrawerContentPointer = this.routingKeyPointer;
      bottomDrawerContentPointer = this.animatingPointer;
      this.operationPipeline.push(async () => {
        animationManager.play(AnimationSequences.TRANSITION_NEXT_LEVEL_SINGLE_DRAWER);
      });
    }
    else if (isAnimatingBackward) {
      topDrawerContentPointer = this.animatingPointer;
      if (bottomDrawerContentPointer !== RoutingKeyPointers.LEVEL_ZERO) {
        this.operationPipeline.push(async () => {
          animationManager.play(AnimationSequences.TRANSITION_PREVIOUS_LEVEL_SINGLE_DRAWER);
        });
      }
    }
    const animatingRoutingKey = (_a = this.routingKeyHistory[topDrawerContentPointer]) !== null && _a !== void 0 ? _a : '';
    const routingKey = (_b = this.routingKeyHistory[bottomDrawerContentPointer]) !== null && _b !== void 0 ? _b : '';
    return (h(Host, null, isString(routingKey) ? (h("div", { class: "drawer active", key: routingKey }, h("span", { class: "first-focus", tabIndex: -1, "aria-hidden": "true" }), h(DrawerContent, { routingKey: routingKey, previousRoutingKey: this.routingKeyHistory[bottomDrawerContentPointer - 1], breakpoint: this.breakpoint, locale: this.locale, showBackButton: bottomDrawerContentPointer > 0, receivedContent: this.receivedContent }))) : null, isString(animatingRoutingKey) ? (h("div", { class: `drawer animating`, style: isAnimatingForward ? { left: '100%' } : {}, key: animatingRoutingKey }, h(DrawerContent, { routingKey: animatingRoutingKey, previousRoutingKey: this.routingKeyHistory[topDrawerContentPointer - 1], breakpoint: this.breakpoint, locale: this.locale, showBackButton: topDrawerContentPointer > 0, receivedContent: this.receivedContent }))) : null));
  }
  static get is() { return "phn-single-drawer"; }
  static get encapsulation() { return "scoped"; }
  static get originalStyleUrls() {
    return {
      "$": ["single-drawer.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["single-drawer.css"]
    };
  }
  static get properties() {
    return {
      "breakpoint": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": true,
        "optional": false,
        "docs": {
          "tags": [],
          "text": ""
        },
        "attribute": "breakpoint",
        "reflect": false
      },
      "locale": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": true,
        "optional": false,
        "docs": {
          "tags": [],
          "text": ""
        },
        "attribute": "locale",
        "reflect": false
      },
      "usingKeyboard": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": ""
        },
        "attribute": "using-keyboard",
        "reflect": false,
        "defaultValue": "false"
      },
      "routingKeyHistory": {
        "type": "unknown",
        "mutable": false,
        "complexType": {
          "original": "string[]",
          "resolved": "string[]",
          "references": {}
        },
        "required": true,
        "optional": false,
        "docs": {
          "tags": [],
          "text": ""
        }
      },
      "routingKeyPointer": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": true,
        "optional": false,
        "docs": {
          "tags": [],
          "text": ""
        },
        "attribute": "routing-key-pointer",
        "reflect": false
      },
      "receivedContent": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": ""
        },
        "attribute": "received-content",
        "reflect": false,
        "defaultValue": "false"
      }
    };
  }
  static get states() {
    return {
      "animatingPointer": {}
    };
  }
  static get events() {
    return [{
        "method": "drawerClosed",
        "name": "drawerClosed",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": ""
        },
        "complexType": {
          "original": "void",
          "resolved": "void",
          "references": {}
        }
      }, {
        "method": "drawerChanged",
        "name": "drawerChanged",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": ""
        },
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        }
      }, {
        "method": "drawerStartsClosing",
        "name": "drawerStartsClosing",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": ""
        },
        "complexType": {
          "original": "void",
          "resolved": "void",
          "references": {}
        }
      }, {
        "method": "backdropClosed",
        "name": "backdropClosed",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": ""
        },
        "complexType": {
          "original": "void",
          "resolved": "void",
          "references": {}
        }
      }, {
        "method": "phnDrawerStatus",
        "name": "phnDrawerStatus",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": ""
        },
        "complexType": {
          "original": "{\n    status: DrawerStatusTypes;\n  }",
          "resolved": "{ status: DrawerStatusTypes; }",
          "references": {
            "DrawerStatusTypes": {
              "location": "import",
              "path": "../../utility/constants/app",
              "id": "src/utility/constants/app.ts::DrawerStatusTypes"
            }
          }
        }
      }];
  }
  static get elementRef() { return "el"; }
  static get listeners() {
    return [{
        "name": "keydown",
        "method": "handleKeyDown",
        "target": undefined,
        "capture": false,
        "passive": false
      }, {
        "name": "mobileMenuItemClick",
        "method": "handleMobileMenuItemClick",
        "target": undefined,
        "capture": false,
        "passive": false
      }, {
        "name": "clickDrawerHeaderClose",
        "method": "handleClickDrawerHeaderClose",
        "target": undefined,
        "capture": false,
        "passive": false
      }, {
        "name": "clickDrawerHeaderBack",
        "method": "handleClickDrawerHeaderBack",
        "target": undefined,
        "capture": false,
        "passive": false
      }];
  }
}
//# sourceMappingURL=single-drawer.js.map
